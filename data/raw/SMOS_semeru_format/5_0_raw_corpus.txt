Nome: EliminaUtente
Attori: Amministratore
Descrizione: Elimina un utente dal sistema
Precondizioni:
•	L’utente è loggato come amministratore • L’utente ha svolto il caso d’uso “VisualizzaDettagliUtente” e il sistema sta
visualizzando i dettagli di un utente •	L’utente clicca sul pulsante “Elimina”
Sequenza degli eventi
Utente
Sistema
1. Elimina l’utente dall’archivio
2. Visualizza l’elenco degli utenti aggiornato
Postcondizioni:
•	L’utente è stato cancellato •	Connessione al server SMOS interrotta
Nome: VisualizzaElencoIndirizzi
Attori: Amministratore
Descrizione: Permette di visualizzare l’elenco degli Indirizzi
Precondizioni:
•	L’utente è loggato al sistema con il ruolo di Amministratore •	L’utente clicca sul pulsante “Gestione Indirizzi”
Sequenza degli eventi
Utente
Sistema
1.	Visualizza l’elenco degli indirizzi.
Postcondizioni:
•	Il sistema mostra l’elenco degli indirizzi presenti nell’archivio •	Connessione al server SMOS interrotta
Nome: EliminaClasse
Attori: Amministratore
Descrizione: Elimina una classe dall’archivio
Precondizioni:
• • • •
L’utente è loggato al sistema come Amministratore L’utente ha eseguito il caso d’uso “VisualizzaDettagliClasse” L’utente visualizza le informazione dettagliate di una classe L’utente Clicca sul pulsante “Elimina”
Sequenza degli eventi
Utente
Sistema
1.	Elimina la classe dall’archivio
2.	Visualizza l’elenco delle classi aggiornato
Postcondizioni:
•	L’utente ha eliminato una classe •	Connessione al server SMOS interrotta
Nome: ModificaUtente
Attori: Amministratore
Descrizione: Modifica di uno o più dati riguardanti un utente presente nel sistema
Precondizioni:
•	L’utente è loggato come amministratore • L’utente ha svolto il caso d’uso “VisualizzaDettagliUtente” e il sistema sta
visualizzando i dettagli di un utente • L’utente modifica una o più informazioni contenute nel form di
visualizzazione dei dettagli dell’utente.
Sequenza degli eventi
Utente
1. Clicca sul pulsante “modifica”
Sistema
2. Effettua dei controlli sulla validità dei dati immessi e modifica l’utente; nel caso in cui i dati inseriti non sono validi, attiva il caso d’uso “ErroreDati”
Postcondizioni:
• • • •
L’utente è stato modificato Viene notificato l’errore dati L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: InserisciNuovaClasse
Attori: Amministratore
Descrizione: Inserisce una nuova classe nell’archivio
Precondizioni:
•	L’utente è loggato al sistema come Amministratore • L’utente ha già eseguito il caso d’uso “VisualizzaElencoClassi” e il sistema
sta visualizzando l’elenco delle classi di un particolare anno accademico. •	L’ utente clicca sul pulsante “Nuova Classe”
Sequenza degli eventi
Utente
2.	Compila il form 3.	Clicca sul pulsante “Salva”
Sistema
1. Il sistema mostra il form da compilare con: nome, indirizzo, anno accademico.
4. Effettua dei controlli sulla validità dei dati immessi e inserisce la nuova classe nell’archivio; nel caso in cui i dati inseriti non sono validi, attiva il caso d’uso “ErroreDati”.
Postcondizioni:
• • • •
L’utente ha inserito una classe nel sistema E’ notificato l’errore dati Connessione al server SMOS interrotta L’Amministratore interrompe l’operazione
Nome: VisualizzaDettagliSingoloRegistro
Attori: Amministratore
Descrizione: Visualizza i dettagli di uno dei registri di classe
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L’utente deve aver svolto il caso d’uso “VisualizzaElencoRegistri” Clicca sul pulsante “Dettagli” associato ad uno dei registri.
Sequenza degli eventi
Utente
Sistema
1. Visualizza a video le informazioni contenute nel registro organizzate per data. In particolare mostra, per la data odierna,	l’elenco	degli	alunni, specificando: assenti/presenti, entrate in ritardo ed un form dal quale è possibile gestire giustifiche e note disciplinari.
Postcondizioni:
•	Il sistema sta visualizzando i dettagli di un registro di classe •	Connessione al server SMOS interrotta
Nome: InserisciAssenzeAdmin
Attori: Amministratore
Descrizione: Digitalizzazione del Registro, inserimento dati da parte dell’Amministratore
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d’uso “VisualizzaDettagliSingoloRegistro” Seleziona la data in cui vuole inserire le informazioni.
Sequenza degli eventi
Utente
Sistema
2. Compila il form inserendo studenti assenti/presenti e clicca “Salva”
1. Aggiorna la schermata visualizzata in base alla data
3. Invia i dati al server. Il server per ogni assenza invia una e-mail di notifica	al	genitore	dell'alunno.
4. Visualizza i dati del registro aggiornati.
Postcondizioni:
• I dati di assenze e ritardi sono stati inseriti nel sistema, ed il sistema ha inviato le notifiche ai genitori. Il sistema rimane sulla schermata del registro.
•	L’amministratore interrompe l’operazione. •	Connessione al server SMOS interrotta.
Nome:VisualizzaDettagliClasse
Attori: Amministratore
Descrizione: Permette di visualizzare i dettagli di una classe
Precondizioni:
•	L’utente ha già effettuato il login • L’utente ha già eseguito il caso d’uso “VisualizzaElencoClassi” e il sistema
sta visualizzando l’elenco delle classi di un anno accademico •	Clicca sul pulsante “mostra dettagli classe”
Sequenza degli eventi
Utente
Sistema
1.	Visualizza la scherma con i dettagli di una singola classe: nome, indirizzo, anno scolastico.
Postcondizioni:
•	L’utente visualizza le informazioni dettagliate relative ad una classe. •	Connessione al server SMOS interrotta
Nome: VisualizzaDettagliNota
Attori: Amministratore
Descrizione: Visualizza i dettagli di una nota
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaElencoNote” Clicca sul pulsante “dettagli” associato ad una delle note
Sequenza degli eventi
Utente
Sistema
1. Mostra un form con i dettagli della nota: alunno, descrizione, docente, data.
Postcondizioni:
• • •
Il sistema sta visualizzando i dettagli di una nota. L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: Assegna/RimuoviInsegnamentiAdUnDocente
Attori: Amministratore
Descrizione: Consente di assegnare o rimuovere insegnamenti ad un docente
Precondizioni:
•	L’utente è loggato come amministratore • L’utente ha svolto il caso d’uso “VisualizzaDettagliUtente” e il sistema sta
visualizzando i dettagli di un docente •	L’utente clicca sul pulsante “Insegnamenti Docente”
Sequenza degli eventi
Utente
2. Seleziona l'anno accademico
4. Seleziona la classe desiderata
6. Seleziona gli insegnamenti da associare o rimuovere al docente
Sistema
1. Visualizza il form di gestione degli insegnamenti per il docente in oggetto
3. Visualizza l'elenco delle classi disponibili per l'anno selezionato
5. Visualizza l'elenco degli insegnamenti associati a quella classe
7. Assegna o rimuove gli insegnamenti del docente come indicato dall’Amministratore
Postcondizioni:
• • •
Sono stati assegnati o rimossi uno o più insegnamenti al docente L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: Assegna/RimuoviRuoliAdUnUtente
Attori: Amministratore
Descrizione: Consente di assegnare o rimuovere ruoli ad un utente
Precondizioni:
•	L’utente è loggato come amministratore • L’utente ha svolto il caso d’uso “VisualizzaDettagliUtente” e il sistema sta
visualizzando i dettagli di un utente •	L’utente clicca sul pulsante “Ruoli Utente”
Sequenza degli eventi
Utente
2. Seleziona i ruoli da assegnare o rimuovere all’utente
3. Clicca sul pulsante “Invia”
Sistema
1. Visualizza il form di gestione dei ruoli
4. Assegna o rimuove i ruoli dell’utente come indicato dall’Amministratore
Postcondizioni:
• • •
Sono modificati i ruoli dell’utente L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: VisualizzaDettagliGiustifica
Attori: Amministratore
Descrizione: Visualizza i dettagli di una giustifica
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaElencoGiustifiche” Clicca su una delle assenze in verde
Sequenza degli eventi
Utente
Sistema
1. Mostra un form con i dettagli della giustifica e la possibilità di modificare o eliminare la giustifica.
Postcondizioni:
• • •
Il sistema sta visualizzando i dettagli di una giustifica. L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: Assegna/RimuoviStudentiAdUnGenitore
Attori: Amministratore
Descrizione: Consente di associare nuovi studenti ad un genitore o di rimuovere le associazioni precedentemente inserite
Precondizioni:
•	L’utente è loggato come amministratore • L’utente ha svolto il caso d’uso “VisualizzaDettagliUtente” e il sistema sta
visualizzando i dettagli di un genitore •	L’utente clicca sul pulsante “Parentela”
Sequenza degli eventi
Utente
2. Selezione gli studenti da assegnare o rimuovere al genitore
3. Clicca sul pulsante “Invia”
Sistema
1. Visualizza il form di gestione dei figli per il genitore in oggetto
4. Assegna/Rimuove gli studenti associati ad un Genitore
Postcondizioni:
• • •
Sono stati associati o rimossi una o più figli ad un genitore. L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: VisualizzaElencoClassi
Attori: Amministratore
Descrizione: Permette di visualizzare l’elenco delle classi
Precondizioni:
•	L’utente è loggato al sistema con il ruolo di Amministratore •	L’utente clicca sul pulsante “Gestione Classi”
Sequenza degli eventi
Utente
2. Seleziona l’anno accademico di interesse.
Sistema
1.	Permette di selezionare l’anno accademico di cui si vuole visualizzare l’elenco delle classi.
3. Cerca le classi nell’archivio e visualizza la schermata di gestione delle classi
4. Visualizza l’elenco delle classi dell’anno accademico selezionato.
Postcondizioni:
• • •
Il sistema mostra l’elenco delle classi dell’anno accademico selezionato. L’Amministratore interrompe le operazioni. Connessione al server SMOS interrotta
Nome: VisualizzaDatiScolasticiStudente
Attori: Studente
Descrizione: Visualizzazione delle informazioni scolastiche riguardanti l’ utente
Precondizioni:
•	L’utente è loggato al sistema come studente •	L’utente clicca il pulsante “Registro Digitale”
Sequenza degli eventi
Utente
Sistema
1.
2.
Cerca nell’ archivio i dati relativi al registro della classe a cui appartiene lo studente
Visualizza i dati relativi allo studente ed in particolare: Data, Assenze, Note disciplinari, Ritardi e Giustifiche.
Postcondizioni:
•	Sono stati mostrati i dati del registro di classe relativi allo studente •	Connessione al server SMOS interrotta
Nome: CancellazioneDiUnaPagella
Attori: Amministratore
Descrizione: L’Amministratore elimina una pagella dal sistema
Precondizioni:
• • •
L'utente si è loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “Visualizzazione di una pagella” L’utente clicca sul tasto “cancella”
Sequenza degli eventi
Utente
2. L'utente accetta la cancellazione premendo il tasto di conferma
Sistema
1. Il sistema visualizza un form per confermare la cancellazione
3. Visualizza un messaggio di corretta cancellazione e visualizza il form con l'elenco delle classi
Postcondizioni:
•	Una pagella relativa ad un alunno viene cancellata •	Connessione al server SMOS interrotta
Nome: VisualizzaRichiesteDiIscrizione
Attori: Amministratore
Descrizione: Consente all'amministratore di visualizzare l'elenco delle richieste di iscrizione giunte al sistema
Precondizioni:
•	L'utente è loggato al sistema come amministratore •	L'utente clicca sul pulsante “Visualizza Elenco Richieste di Iscrizione”
presente nella home
Sequenza degli eventi
Utente
Sistema
1 . Visualizza l'elenco delle iscrizioni ancora da attivare.
Postcondizioni:
•
• •
L’utente sta visualizzando l'elenco di richieste di iscrizione al sistema da parte degli studenti L'utente interrompe l'operazione Connessione al server SMOS interrotta
Nome: VisualizzaDatiStudenti
Attori: Genitore
Descrizione: Il presente caso d'uso consente ad un genitore di visualizzare le informazioni relative ai propri figli
Precondizioni:
•	L’utente è loggato al sistema come genitore •	L’ utente clicca il pulsante “Registro” associato ad uno dei suoi figli
Sequenza degli eventi
Utente
Sistema
1. Visualizza	una	tabella riassuntiva con le informazioni relative	ai	figli	ed	in particolare:Data, Assenze, Note disciplinari,	Ritardi	e Giustifiche.
Postcondizioni:
•	Sono state mostrate le informazioni relative ad uno dei figli dell’ utente •	Connessione al server SMOS interrotta
Nom: EffettuaMonitoraggioStudenti
Attori: Direzione
Descrizione: Consente di visualizzare gli studenti con un numero di note e assenze superiore ad una soglia indicata dall'utente
Precondizioni:
•	L’utente è loggato al sistema come direzione •	L’ utente clicca sul pulsante “Monitoraggio Studenti”
Sequenza degli eventi
Utente
Sistema
1. Cerca gli studenti con un numero di assenze e note superiori alla soglia stabilita.
2.	Visualizza	le	informazioni recuperate.
Postcondizioni: :
•	Sono state visualizzate le informazioni inerenti i dati raccolti •	Connessione al server SMOS interrotta.
Nome: VisualizzazioneDiUnaPagella
Attori: Genitore
Descrizione: Viene visualizzata la pagella dell’alunno richiesto
Precondizioni:
•	L'utente si è loggato al sistema come Genitore •	L’utente clicca sul pulsante pagella associato ad uno dei suoi figli
Sequenza degli eventi
Utente
Sistema
2. Seleziona la pagella di interesse
1. Visualizza le pagelle dello studente selezionato
3. Visualizza i dettagli della pagella selezionata
Postcondizioni:
•	Il sistema visualizza la pagella di uno studente •	Connessione al server SMOS interrotta
Nome: VisualizzazioneDiUnaPagella
Attori: Direzione
Descrizione: Visualizzazione di una pagella
Precondizioni:
•	L'utente si è loggato al sistema come Direzione •	L’utente clicca sul pulsante “Pagelle online”
Sequenza degli eventi
Utente
Sistema
1. Seleziona l’anno accademico
3 . Sceglie la classe dell'alunno di cui vuole visualizzare la pagella
5. Seleziona l'alunno di cui visualizzare la pagella e il quadrimestre di interesse cliccando sul relativo tasto
2. Visualizza l’elenco delle classi presenti nel sistema con accanto un pulsante “Pagelle” associato ad ogni classe
4. Visualizza l'elenco degli alunni della classe scelta dall'utente
6. Visualizza la pagella dell'alunno scelto	riferita	al	semestre selezionato.
Postcondizioni:
• • •
Il sistema visualizza la pagella di uno studente L’utente interrompe l’operazione Connessione al server SMOS interrotta
Nome: RegistrazioneAlSito
Attori: Visitatore
Descrizione: Consente ad uno studente di registrarsi al sistema
Precondizioni:
•	L'utente clicca sul pulsante “Registrati” presente nella home page
Sequenza degli eventi
Utente
Sistema
2. Riempie i campi del form 3. Sottomette il form
1 . Visualizza il form di registrazione contenente: Nome, Cognome, Cellulare, e-mail, username, password, conferma password.
4. Inserisce la richiesta di iscrizione nel sistema
Postcondizioni:
• • •
L’utente ha effettuato richiesta di iscrizione al sistema L'utente interrompe l'operazione Connessione al server SMOS interrotta
Nome: VisualizzazioneDiUnaPagellaStudente
Attori: Studente
Descrizione: Viene visualizzata la pagella dell’alunno che lo richiede
Precondizioni:
•	L'utente si è loggato al sistema come Studente •	L’utente clicca su “pagella online”
Sequenza degli eventi
Utente
Sistema
2. Seleziona la pagella di interesse
1. Il sistema visualizza le pagelle dello studente loggato presenti in archivio
3. Visualizza i dettagli della pagella selezionata
Postcondizioni:
•	Il sistema visualizza la pagella di un alunno •	Connessione al server SMOS interrotta
Nome: VisualizzaRegistro
Attori: Direzione
Descrizione: Dettagli relativi al registro di una classe
Precondizioni:
• •
•
L’ utente è loggato al sistema direzione L’ utente ha svolto il caso d’ uso “VisualizzaElencoRegistri” e il sistema sta visualizzando l’ elenco di tutti i registri di un particolare anno accademico L’utente clicca il pulsante “Registro” associato ad una delle classi
Sequenza degli eventi
Utente
Sistema
1. Visualizza	a	video	le informazioni	contenute	nel registro organizzate per data. In particolare mostra, per la data selezionata	l’elenco	degli alunni,	specificando: assenti/presenti,	entrate	in ritardo ed un form dal quale è possibile gestire giustifiche e note disciplinari.
Postcondizioni:
•	Sono state mostrate le informazioni relative al registro di classe •	Connessione al server SMOS interrotta
Nome: VisualizzaElencoRegistri
Attori: Direzione
Descrizione: Visualizza l’elenco dei registri per un anno accademico
Precondizioni:
•	L'utente deve essere loggato al sistema come Direzione •	L’ utente clicca sul pulsante “Registro Digitale”
Sequenza degli eventi
Utente
Sistema
2. Seleziona l’anno accademico
1.Mostra una schermata per la selezione dell’anno accademico di interesse.
3. Cerca nell’archivio tutti i registri digitali di quell’anno e li visualizza associati alla classe cui appartengono
Postcondizioni:
•
• •
Il sistema sta visualizzando l’elenco dei registri riferiti ad un particolare anno accademico La direzione interrompe l’operazione Connessione al server SMOS interrotta
Nome: VisualizzazioneDiUnaPagellaDocente
Attori: Docente
Descrizione: Visualizzazione di una pagella
Precondizioni:
•	L'utente si è loggato al sistema come Docente •	L’utente clicca sul pulsante “Pagelle on-line”
Sequenza degli eventi
Utente
Sistema
2. Seleziona l'anno accademico di interesse.
4.	Seleziona	una	delle	classi visualizzate.
6. Seleziona l'alunno di cui visualizzare la pagella e il quadrimestre di riferimento	cliccando	sull'apposito pulsante.
1	. Visualizza	l'elenco	degli	anni accademici in cui è presente almeno una classe in cui il docente insegna.
3. Visualizza le classi associate all'anno scolastico selezionato.
5. Visualizza l'elenco degli alunni della classe scelta dall'utente
7. Visualizza la pagella dell'alunno scelto	riferita	al	quadrimestre specificato.
Postcondizioni:
• • •
Il sistema visualizza la pagella di uno studente L’utente interrompe l’operazione Connessione al server SMOS interrotta
Nome: ModificaNota
Attori: Amministratore
Descrizione: Modifica di una Nota Disciplinare
Precondizioni:
•	L'utente deve essere loggato al sistema come Amministratore •	L'utente ha svolto il caso d’uso “VisualizzaDettagliNota”
Sequenza degli eventi
Utente
Sistema
1. L'utente modifica uno o più campi del	form	visualizzato:	Studente, descrizione,	docente,	data.
2. L'utente clicca su “Salva”
3. Il sistema salva le modifiche
Postcondizioni:
• I dati della nota sono stati modificati. Il sistema ritorna alla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome: InserisciRitardiAta
Attori: Personale ATA
Descrizione: Digitalizzazione del Registro, raccolta dati dal personale ATA classe per classe
Precondizioni:
• • •
L'utente deve essere loggato al sistema come personale ATA L'utente ha svolto il caso d'uso VisualizzaElencoClassiATA Seleziona una classe di cui inserire i dati nel sistema
Sequenza degli eventi
Utente
Sistema
2.	L'utente	seleziona	i	ritardi 3. L'utente clicca “Conferma”
1. Il sistema mostra all'utente una schermata con tutti gli alunni presenti, con a fianco una checkbox “ritardo”. Se selezionata si attivano dei campi di select a lato per selezionare l'ora del ritardo
4. Il sistema invia i dati al server.
Postcondizioni:
•
• •
I dati dei ritardi sono stati inseriti nel sistema. All'utente è mostrata di nuovo la schermata iniziale. Connessione al server SMOS interrotta. L’utente interrompe le operazioni.
Nome: InserisciAssenze
Attori: Personale ATA
Descrizione: Digitalizzazione del Registro, raccolta dati dal personale ATA classe per classe
Precondizioni:
• • •
L'utente deve essere loggato al sistema come personale ATA L'utente ha svolto il caso d'uso VisualizzaElencoClassiATA Selezione una classe di cui inserire i dati nel sistema
Sequenza degli eventi
Utente
Sistema
2. L'utente seleziona gli studenti assenti 3. Clicca su salva
1. Mostra all'utente una schermata con gli alunni e dei radio button per selezionare se un alunno è assente o presente. Di default l'alunno è presente.
4. Il sistema invia i dati al server. Il server per ogni assenza invia una e- mail di notifica al genitore dell'alunno.
Postcondizioni:
• I dati di assenze sono stati inseriti nel sistema, ed il sistema ha inviato le notifiche ai genitori. All'utente è mostrata di nuovo la schermata iniziale.
•	Connessione al server SMOS interrotta. •	L’utente interrompe l’operazione.
Nome: ModificaGiustifica
Attori: Amministratore
Descrizione: Modifica di una Giustifica
Precondizioni:
•	L'utente deve essere loggato al sistema come Amministratore •	L'utente ha svolto il caso d'uso “VisualizzaDettagliGiustifica” e il sistema sta
visualizzando i dettagli di una giustifica
Sequenza degli eventi
Utente
Sistema
1. Modifica uno o più campi del form	visualizzato:	data giustifica.
2. Clicca su “Salva”
3.	Modifica	la	giustifica.
Postcondizioni:
• • •
La giustifica è stata modificata. Il sistema ritorna alla schermata del registro. L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: VisualizzaElencoClassiDocente
Attori: Docente
Descrizione: Il presente caso d'uso consente ad un docente di visualizzare l'elenco delle classi in cui insegna
Precondizioni:
•	L’utente è loggato al sistema come docente •	L’ utente clicca il pulsante “Registro Digitale”
Sequenza degli eventi
Utente
Sistema
2. Seleziona l'anno accademico di interesse.
1. Visualizza l'elenco degli anni accademici in cui è presente almeno una classe in cui il docente insegna.
3. Visualizza le classi associate all'anno scolastico selezionato.
Postcondizioni:
•	E’ stata mostrata la lista di tutte le classi in cui insegna il docente •	Connessione al server SMOS interrotta.
Nome: EliminaGiustifica
Attori: Amministratore
Descrizione: Elimina Giustifica
Precondizioni:
•	L'utente deve essere loggato al sistema come Amministratore • L'utente ha svolto il caso d'uso “VisualizzaDettagliGiustifica” e il
sistema sta visualizzando i dettagli di una giustifica. •	Clicca su “Elimina”
Sequenza degli eventi
Utente
Sistema
1. Elimina la giustifica.
Postcondizioni:
• La giustifica è stata eliminata dal sistema. Il sistema ritorna alla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome: EliminaNota
Attori: Amministratore
Descrizione: Eliminazione Note Disciplinari
Precondizioni:
•	L'utente deve essere loggato al sistema come Amministratore • L'utente ha svolto il caso d'uso “VisualizzaDettagliNota” e il sistema sta
visualizzando I dettagli di una nota •	L'utente clicca il pulsante “Elimina”
Sequenza degli eventi
Utente
Sistema
1. Il sistema invia una notifica di errata corrige ai genitori dello studente, poi elimina i dati della nota dall’archivio.
Postcondizioni:
• La nota è stata cancellata, ed il sistema ha inviato la notifica ai genitori. Il sistema ritorna alla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome: VisualizzaRegistro
Attori: Docente
Descrizione: Visualizzazione del registro di classe
Precondizioni:
•	L’utente è loggato al sistema come docente • L’ utente ha svolto il caso d’ uso “VisualizzaElencoClassi” e il sistema sta
visualizzando l’ elenco di tutte le classi in cui insegna •	L’ utente clicca sul pulsante “Registro” associato ad una delle classi
Sequenza degli eventi
Utente
Sistema
1.	Visualizza	le	informazioni relative al registro di classe ed in particolare:Data, Assenze, Note disciplinari, Ritardi e Giustifiche.
Postcondizioni: :
•	Sono state mostrate le informazioni relative al registro di classe •	Connessione al server SMOS interrotta.
Nome: VisualizzaElencoClassi
Attori: Personale ATA
Descrizione: Visualizzazione delle classi
Precondizioni:
•	L'utente deve essere loggato al sistema come personale ATA
Sequenza degli eventi
Utente
Sistema
1. Il sistema mostra all'utente una schermata con tutte le classi presenti nel database, con un tasto per accedere al registro di ogni classe.
Postcondizioni:
All'utente viene visualizzata una lista da cui scegliere la classe.
Nome: ModificaDiUnaPagella
Attori: Amministratore
Descrizione: Caso d’uso per modificare la pagella di un alunno
Precondizioni:
• • •
L'utente si è loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzazioneDiUnaPagella ” L’utente clicca sul tasto di modifica
Sequenza degli eventi
Utente
2. Inserisce i nuovi dati e clicca il tasto di conferma
Sistema
1. Visualizza il form con i campi da poter modificare tra cui i voti delle diverse materie
3. Il sistema visualizza un messaggio di conferma e visualizza il form con l'elenco degli alunni
Postcondizioni:
• • •
Una pagella relativa ad un alunno viene modificata L’utente interrompe l’operazione Connessione al server SMOS interrotta
Nome: InserimentoPagella
Attori: Amministratore
Descrizione: Inserimento di una pagella di uno studente eseguito dall’Amministratore
Precondizioni:
•	L'utente si è loggato al sistema come Amministratore •	L’utente clicca sul pulsante “Pagelle online”
Sequenza degli eventi
Utente
2. Sceglie la classe dell'alunno di cui inserire la pagella
4. Seleziona l'alunno a cui inserire la pagella cliccando sul relativo tasto
6. Inserisce i voti della pagella, tutti o in parte, e clicca sul tasto “salva”
Sistema
1. Visualizza l’elenco delle classi presenti nel sistema riferito all’anno accademico in corso con accanto un pulsante “Pagelle” associato ad ogni classe
3. Visualizza l'elenco degli alunni della classe scelta dall'utente
5. Visualizza il form per l'inserimento di una pagella
7. Inserisce i voti inseriti nell'archivio e riporta l'utente alla pagina di visualizzazione degli studenti della classe.
Postcondizioni:
• • •
Nel sistema è stata aggiunta la pagella relativa ad un alunno. L’utente interrompe l’operazione Connessione al server SMOS interrotta
Nome: Ricerca EntitaAttori: Amministratore
Descrizione: Consente all'amministratore di ricercare nel sistema tutte le entità caratterizzate dalle keywords inserite
Precondizioni:
•	L'utente è loggato al sistema come amministrator •	L'utente inserisce il testo da cercare e clicca sul pulsante “Ricerca”
Sequenza degli eventi
Utente
Sistema
1	. Visualizza	l'elenco	delle	entità correlate alla keywords ricercate; in particolare vengono mostrate in una lista attiva: Classi, Insegnamenti, Indirizzi, Utenti trovati.
Postcondizioni:
• L’utente sta visualizzando una lista attiva di entità corrispondenti alle keyword inserite.
•	L'utente interrompe l'operazione •	Connessione al server SMOS interrotta
Nome: EffettuaMonitoraggioStudenti
Attori: Amministratore
Descrizione: Consente di interrogare il sistema circa il numero di assenze e note associate agli studenti
Precondizioni:
•	L’utente è loggato al sistema come amministratore •	L’utente clicca sul pulsante “Monitoraggio Studenti”
Sequenza degli eventi
Utente
Sistema
1. Cerca nell'archivio gli studenti che abbiano, per l'anno scolastico in corso un numero di assenze e note superiori ad una soglia prestabilita.
2. Visualizza una schermata di presentazione dei dati ottenuti.
Postcondizioni: :
•	Sono state le informazioni circa assenze e note degli alunni. •	Connessione al server SMOS interrotta.
Nome: AccettaIscrizioneStudente
Attori: Amministratore
Descrizione: Consente all'amministratore di accettare l'iscrizione al sistema di uno studente
Precondizioni:
•	L'utente ha già svolto il caso d'uso “Visualizza Richieste di Iscrizione” •	L'utente clicca sul pulsante “Accetta” associato ad una richiesta di iscrizione
Sequenza degli eventi
Utente
Sistema
1 . Attiva il nuovo utente nel sistema.
2. Visualizza l'elenco delle iscrizioni ancora da attivare
Postcondizioni:
• • •
L’utente ha accettato una richiesta di iscrizione al sistema L'utente interrompe l'operazione Connessione al server SMOS interrotta
Nome: RifiutaIscrizioneStudente
Attori: Amministratore
Descrizione: Consente all'amministratore di rifiutare l'iscrizione al sistema di uno studente
Precondizioni:
•	L'utente ha già svolto il caso d'uso “Visualizza Richieste di Iscrizione” •	L'utente clicca sul pulsante “Rifiuta” associato ad una richiesta di iscrizione
Sequenza degli eventi
Utente
Sistema
1. Elimina la richiesta di iscrizione al sistema.
2. Visualizza l'elenco delle iscrizioni ancora da attivare
Postcondizioni:
• • •
L’utente ha rifiutato una richiesta di iscrizione al sistema L'utente interrompe l'operazione Connessione al server SMOS interrotta
Nome: VisualizzazioneDiUnaPagella
Attori: Amministratore
Descrizione: Visualizzazione di una pagella
Precondizioni:
•	L'utente si è loggato al sistema come Amministratore •	L’utente clicca sul pulsante “Pagelle online”
Sequenza degli eventi
Utente
1. Seleziona l’anno accademico
3. Sceglie la classe dell'alunno di cui vuole visualizzare la pagella
5.	Seleziona	l'alunno	e	il quadrimestre di cui visualizzare la pagella cliccando sul relativo pulsante.
Sistema
2. Visualizza l’elenco delle classi presenti nel sistema con accanto un pulsante “Pagelle” associato ad ogni classe
4. Visualizza l'elenco degli alunni della classe scelta dall'utente
6.	Visualizza la pagella dell'alunno scelto riferita al quadrimestre selezionato.
Postcondizioni:
• • •
Il sistema visualizza la pagella di uno studente L’utente interrompe l’operazione Connessione al server SMOS interrotta
Nome: VisualizzaElencoInsegnamenti
Attori: Amministratore
Descrizione: Permette di visualizzare l’elenco degli insegnamenti
Precondizioni:
•	L’utente è loggato al sistema con il ruolo di Amministratore •	L’utente clicca sul pulsante “Gestione Insegnamenti”
Sequenza degli eventi
Utente
Sistema
1.
2.
Cerca	gli nell’archivio	e schermata	di insegnamenti
Visualizza insegnamenti
insegnamenti visualizza	la gestione	degli
l’elenco	degli
Postcondizioni:
•	Il sistema mostra l’elenco degli insegnamenti presenti nell’archivio •	Connessione al server SMOS interrotta
Nome: InserisciGiustifica
Attori: Amministratore
Descrizione: Inserimento Giustifica
Precondizioni:
• • • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaDettagliSingoloRegistro” L'utente ha svolto il caso d'uso “VisualizzaElencoGiustifiche” L'utente clicca su una delle assenze in rosso
Sequenza degli eventi
Utente
Sistema
2. Compila il form 3. Clicca su “Salva”
1. Mostra un form in cui inserire i campi della giustifica (data giustifica).
4. Salva la giustifica.
Postcondizioni:
• I dati della giustifica sono stati inseriti nel sistema. Il sistema ritorna alla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome: InserisciNota
Attori: Amministratore
Descrizione: Inserimento Note Disciplinari
Precondizioni:
• • • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaDettagliSingoloRegistro” L'utente ha già svolto il caso d'uso “VisualizzaElencoNote” L'utente clicca sul pulsante “Nuova nota”
Sequenza degli eventi
Utente
Sistema
2. Compila il form 3. Clicca su “Salva”
1. Mostra un form con i campi della nota (studente, data, docente , descrizione).
4. Salva la nota e invia una notifica via e-mail al genitore
Postcondizioni:
•
• •
I dati della nota sono stati inseriti nel sistema, ed il sistema ha inviato la notifica ai genitori. Il sistema ritorna alla schermata del registro. L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome:InserisciNuovoInsegnamento
Attori: Amministratore
Descrizione: Inserisce un nuovo insegnamento nell’archivio
Precondizioni:
•	L’utente è loggato al sistema come Amministratore • L’utente ha già eseguito il caso d’uso “VisualizzaElencoInsegnamenti” e il
sistema sta visualizzando l’elenco degli insegnamenti •	L’utente clicca sul pulsante “Nuovo Insegnamento”
Sequenza degli eventi
Utente
2.	Compila il form 3.	Clicca sul pulsante “Salva”
Sistema
1. Il sistema mostra il form da compilare	con:	nome insegnamento.
4. Effettua dei controlli sulla validità dei dati immessi e inserisce il nuovo insegnamento nell’archivio; nel caso in cui i dati inseriti non sono validi, attiva il caso d’uso “ErroreDati”.
Postcondizioni:
• • • •
L’utente ha inserito un insegnamento Viene notificato l’errore Connessione al server SMOS interrotta L’Amministratore interrompe l’operazione

Nome: Login
Attori: Utente registrato
Descrizione: Permette ad un utente di loggarsi al sistema
Precondizioni:
L’utente non è loggato al sistema L’utente possiede username e password Compila e sottomette il form per il login
Sequenza degli eventi
Utente
Sistema
1.	Verifica che username e password abbiano lunghezza >=5. Se la condizione è rispettata passa al punto due, altrimenti notifica l'errore all'utente.
2.	Cerca nell’archivio se username e password inseriti dall’utente sono presenti tra gli utenti loggabili
3.	Se la ricerca ha avuto successo l’utente viene loggato al sistema
Postcondizioni:
•	Il sistema visualizza l’area di lavoro dell’Utente Registrato •	Interruzione della connessione al server SMOS
Nome: Logout
Attori: Utente registrato
Descrizione: Permette ad un utente di uscire dal sistema
Precondizioni:
•	L’utente è loggato al sistema •	Clicca sul pulsante di logout
Sequenza degli eventi
Utente
Sistema
1.	Visualizza il form di login
Postcondizioni:
•	L’utente può nuovamente loggarsi al sistema
Nome: VisualizzaElencoNote
Attori: Amministratore
Descrizione: Visualizza l'elenco delle note inerente allo studente
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaDettagliSingoloRegistro” Clicca sul pulsante “Note” associato ad uno studente
Sequenza degli eventi
Utente
Sistema
1.	Mostra tutte le note dell'alunno registrate durante l'anno scolastico
Postcondizioni:
• • •
Il sistema sta visualizzando l'elenco note riferite allo studente L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome:AssegnaRimuoviInsegnamenti
Attori: Amministratore
Descrizione: Assegna o rimuove uno o più insegnamenti da un indirizzo
Precondizioni:
• • • •
L’utente è loggato al sistema come Amministratore L’utente ha eseguito il caso d’uso “VisualizzaDettagliIndirizzo” L’utente visualizza le informazione dettagliate di un indirizzo L’utente clicca sul pulsante “Insegnamenti Indirizzo”
Sequenza degli eventi
Utente
2. Seleziona gli insegnamenti da assegnare o rimuovere all’indirizzo
3. Clicca sul pulsante “Invia”
Sistema
1. Visualizza un form da cui è possibile	aggiungere	e/o rimuovere	insegnamenti all’indirizzo.
4. Associa o rimuove gli insegnamenti selezionati all’indirizzo.
5. Torna alla visualizzazione dei dettagli dell’indirizzo.
Postcondizioni:
• • •
L’Amministratore interrompe l’operazione Connessione al server SMOS interrotta Il sistema ha modificato gli insegnamenti relativi all’indirizzo
Nome: EliminaIndirizzo
Attori: Amministratore
Descrizione: Elimina un indirizzo dall’archivio
Precondizioni:
• • • •
L’utente è loggato al sistema come Amministratore L’utente ha eseguito il caso d’uso “VisualizzaDettagliIndirizzo” L’utente visualizza le informazione dettagliate di un indirizzo L’utente clicca sul pulsante “Elimina”
Sequenza degli eventi
Utente
Sistema
1. Verifica se l'indirizzo ha classi associate; in caso affermativo mostra un messaggio di errore “Impossibile eliminare l'indirizzo, cancellare le classi associate e riprovare”, altrimenti elimina l'indirizzo.
2. Visualizza l’elenco degli indirizzi aggiornato
Postcondizioni:
•	L’utente ha eliminato un indirizzo •	Connessione al server SMOS interrotta
Nome: VisualizzaElencoGiustifiche
Attori: Amministratore
Descrizione: Visualizza i l'elenco delle giustifiche
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaDettagliSingoloRegistro” Clicca il tasto “Giustifiche” relativo ad un alunno
Sequenza degli eventi
Utente
Sistema
1.	Mostra	tutte	le	assenze dell'alunno
registrate scolastico selezionato Le assenze già giustificate vengono
visualizzate in verde, quelle da giustificare in rosso
durante	l'anno
Postcondizioni:
• • •
Il sistema sta visualizzando l'elenco delle giustifiche inerenti allo studente L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: LoginErrato
Attori: Utente registrato
Descrizione: Si verifica quando l’utente ha inserito dati di autenticazione errati.
Precondizioni:
•	I dati forniti per il login non sono corretti
Sequenza degli eventi
Utente
Sistema
1.	Visualizza il form di login
Postcondizioni:
•	L’utente può riprovare ad effettuare il login
Nome: NuovoUtente
Attori: Amministratore
Descrizione: Inserimento di un nuovo utente nel sistema
Precondizioni:
•	L’utente è loggato come amministratore • L’utente ha svolto il caso d’uso “VisualizzaElencoUtenti” e il sistema sta
visualizzando l’elenco degli utenti presenti nel sistema •	L’utente clicca sul pulsante “Nuovo Utente”
Sequenza degli eventi
Utente
2. Riempie i campi del form 3. Clicca sul pulsante “Salva”
Sistema
1. Visualizza il form di inserimento degli utenti costituito dai seguenti campi: Nome, Cognome, e-mail, cell, login, password, conferma password.
4. Effettua dei controlli sulla validità dei dati immessi e inserisce il nuovo utente nell’archivio; nel caso in cui i dati inseriti non sono validi, attiva il caso d’uso “ErroreDati”
Postcondizioni:
• • • •
E’ stato creato un nuovo utente Viene notificato l’errore dati L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: InserisciNuovoIndirizzo
Attori: Amministratore
Descrizione: Inserisce un nuovo indirizzo nell’archivio
Precondizioni:
• •
•
L’utente è loggato al sistema come Amministratore L’utente ha già eseguito il caso d’uso “VisualizzaElencoIndirizzi” e il sistema sta visualizzando l’elenco degli indirizzi L’utente clicca sul pulsante “Nuovo Indirizzo”
Sequenza degli eventi
Utente
2.	Compila il form 3.	Clicca sul pulsante “Salva”
Sistema
1. Il sistema mostra il form da compilare con: nome indirizzo.
4. Effettua dei controlli sulla validità dei dati immessi e inserisce un nuovo indirizzo nell’archivio; nel caso in cui i dati inseriti non sono validi, attiva il caso d’uso “ErroreDati”.
Postcondizioni:
• • • •
L’utente ha inserito un indirizzo Viene notificato l’errore dati Connessione al server SMOS interrotta L’Amministratore interrompe l’operazione
Nome: InserisciRitardiAdmin
Attori: Amministratore
Descrizione: Digitalizzazione del Registro, inserimento dati da parte dell’Amministratore
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d’uso “VisualizzaDettagliSingoloRegistro” Seleziona la data in cui vuole inserire le informazioni.
Sequenza degli eventi
Utente
Sistema
2. Compila il form inserendo studenti con ritardo e clicca “Salva”
1. Aggiorna la schermata visualizzata in base alla data
3.	Invia	i	dati	al	server.
4. Visualizza i dati del registro aggiornati.
Postcondizioni:
• I dati dei ritardi sono stati inseriti nel sistema, ed il sistema ha inviato le notifiche ai genitori. Il sistema rimane sulla schermata del registro.
•	L’amministratore interrompe l’operazione. •	Connessione al server SMOS interrotta.
Nome:VisualizzaDettagliInsegnamento
Attori: Amministratore
Descrizione: Permette di visualizzare i dettagli di un insegnamento
Precondizioni:
•	L’utente ha già effettuato il login • L’utente ha già eseguito il caso d’uso “VisualizzaElencoInsegnamenti” e il
sistema sta visualizzando l’elenco degli insegnamenti •	L’utente clicca sul pulsante “dettagli insegnamento”
Sequenza degli eventi
Utente
Sistema
1.	Visualizza la schermata con i dettagli di un singolo insegnamento.
Postcondizioni:
•	L’utente visualizza le informazioni dettagliate di un singolo insegnamento •	Connessione al server SMOS interrotta
Nome:ModificaInsegnamento
Attori: Amministratore
Descrizione: Modifica dettagli di un insegnamento
Precondizioni:
•	L’utente è loggato al sistema come Amministratore •	L’utente ha eseguito il caso d’uso “VisualizzaDettagliInsegnamento” •	L’utente visualizza le informazione dettagliate di un insegnamento • L’utente modifica una delle informazioni contenute nel form di
visualizzazione dei dettagli dell’insegnamento
Sequenza degli eventi
Utente
Sistema
1.	Clicca sul pulsante “Salva”
2. Effettua dei controlli sulla validità dei dati immessi e modifica l’insegnamento nell’archivio; nel caso in cui i dati inseriti non sono validi,	attiva	il	caso	d’uso “ErroreDati”.
3. Visualizza	l’elenco	degli insegnamenti aggiornato
Postcondizioni:
• • • •
L’utente ha modificato un insegnamento Viene notificato l’errore dati Connessione al server SMOS interrotta L’Amministratore interrompe l’operazione
Nome: ModificaAssenza
Attori: Amministratore
Descrizione: Modifica delle assenze da parte dell'Amministratore. La modifica è da intendersi come inserimento/cancellazione dell’assenza.
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaDettagliSingoloRegistro” Seleziona la data in cui desidera modificare un’assenza
Sequenza degli eventi
Utente
Sistema
2. Modifica l'assenza (Inserisce o Elimina) e clicca “Salva”
1. Aggiorna la schermata in base alla data selezionata
3. Invia i dati modificati al server. Il sistema invia una e-mail di rettifica al genitore dell'alunno.
Postcondizioni:
• Il sistema ha modificato l'assenza selezionata ed ha inviato ai genitori una notifica della modifica. Il sistema rimane sulla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome:VisualizzaDettagliIndirizzo
Attori: Amministratore
Descrizione: Permette di visualizzare i dettagli di un indirizzo
Precondizioni:
• •
•
L’utente ha già effettuato il login L’utente ha già eseguito il caso d’uso “VisualizzaElencoIndirizzi” e il sistema sta visualizzando l’elenco degli indirizzi L’utente clicca sul pulsante “mostra dettagli indirizzo”
Sequenza degli eventi
Utente
Sistema
1.	Visualizza la schermata con i dettagli di un singolo indirizzo; in particolare :nome indirizzo.
Postcondizioni:
• L’utente visualizza le informazioni dettagliate relative ad un singolo indirizzo.
• Connessione al server SMOS interrotta Connessione al server SMOS interrotta

Nome: VisualizzaDettagliUtente
Attori: Amministratore
Descrizione: Visualizza i dettagli di un utente
Precondizioni:
• •
•
L’utente è loggato come amministratore L’utente ha svolto il caso d’uso “VisualizzaElencoUtenti” e il sistema sta visualizzando l’elenco degli utenti presenti nel sistema L’utente clicca sul pulsante “Dettagli”
Sequenza degli eventi
Utente
Sistema
1. Visualizza le informazioni dettagliate dell’utente ed in particolare: Nome, Cognome, e-mail, cell, login, password.
Postcondizioni:
•	Il sistema visualizza le informazioni dettagliate relative ad un utente •	Connessione al server SMOS interrotta
Nome: VisualizzaElencoUtenti
Attori: Amministratore
Descrizione: Visualizza l’elenco degli utenti presenti nel sistema
Precondizioni:
•	L’utente è loggato come amministratore •	L’utente clicca sul pulsante “Gestione Utenti”
Sequenza degli eventi
Utente
Sistema
1. Cerca gli utenti nell’archivio e ne visualizza l’elenco
Postcondizioni:
•	Il sistema visualizza l’elenco degli utenti presenti nel sistema •	Connessione al server SMOS interrotta
Nome: VisualizzaElencoRegistri
Attori: Amministratore
Descrizione: Visualizza l’elenco dei registri per un anno accademico
Precondizioni:
•	L'utente deve essere loggato al sistema come Amministratore •	Clicca sul pulsante “Registro Digitale”
Sequenza degli eventi
Utente
Sistema
2. Seleziona l’anno scolastico
1. Mostra una schermata per la selezione dell’anno accademico di interesse.
3. Cerca nell’archivio tutti i registri digitali di quell’anno e li visualizza associati alla classe cui appartengono.
Postcondizioni:
•
• •
Il sistema sta visualizzando l’elenco dei registri riferiti ad un particolare anno accademico L’amministratore interrompe l’operazione Connessione al server SMOS interrotta
Nome: EliminaRitardo
Attori: Amministratore
Descrizione: Eliminazione di un ritardo da parte dell'Amministratore
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d'uso “VisualizzaDettagliSingoloRegistro” Seleziona la data in cui desidera eliminare un ritardo.
Sequenza degli eventi
Utente
Sistema
2. Elimina l’entrata in ritardo di uno studente e clicca “Salva”
1. Aggiorna la schermata in base alla data selezionata
3.	Elimina	l’entrata	in	ritardo dall’archivio.
Postcondizioni:
• Il sistema ha eliminato il ritardo. Il sistema rimane sulla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome: ModificaRitardo
Attori: Amministratore
Descrizione: modifica di un ritardo da parte dell'Amministratore
Precondizioni:
• • •
L'utente deve essere loggato al sistema come Amministratore L'utente ha svolto il caso d’uso “VisualizzaDettagliSingoloRegistro” Seleziona la data in cui desidera modificare il ritardo
Sequenza degli eventi
Utente
Sistema
2. L'utente modifica il ritardo e clicca su “Salva”
1. Aggiorna la schermata in base alla data selezionata
3. Il sistema invia i dati modificati al server	.
Postcondizioni:
• Il sistema ha modificato i ritardi alla data inserita. Il sistema rimane sulla schermata del registro.
•	L’amministratore interrompe l’operazione •	Connessione al server SMOS interrotta
Nome: EliminaInsegnamento
Attori: Amministratore
Descrizione: Elimina un insegnamento dall’archivio
Precondizioni:
• • • •
L’utente è loggato al sistema come Amministratore L’utente ha eseguito il caso d’uso “VisualizzaDettagliInsegnamento” L’utente visualizza le informazione dettagliate di un insegnamento L’utente clicca sul pulsante “Elimina”
Sequenza degli eventi
Utente
Sistema
1.	Elimina	l’insegnamento dall’archivio
2.	Visualizza	l’elenco	degli insegnamenti aggiornato
Postcondizioni:
•	L’utente ha eliminato un insegnamento •	Connessione al server SMOS interrotta
Nome: ModificaPassword
Attori: Utente registrato
Descrizione: Permette ad un utente di modificare la propria password
Precondizioni:
•	L’utente è loggato al sistema •	Clicca sul pulsante “Modifica Password”
Sequenza degli eventi
Utente
2. Compila il form e sottomette;
Sistema
1.	Visualizza il form con i campi: vecchia password, nuova password, conferma nuova password.
3.	Conferma l’avvenuta modifica della password
Postcondizioni:
• • •
La password dell’utente è stata modificata L’utente annulla l’operazione Interruzione della connessione al server SMOS
package smos.application.userManagement;

import javax.servlet.http.HttpServlet;

public class ServletShowUserClassroomForm extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8625643776134227947L;

	/**
	 * 
	 */
	
	

}

package smos.application.reportManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.ManagerVotes;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per caricare la lista degli insegnamenti Associati alla classe dello studente.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletLoadTeachingList extends HttpServlet {


	private static final long serialVersionUID = -708492643674363470L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./reportsManagement/insertReport.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Teaching> teachingList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla funzionalita'!";
				gotoPage = "./error.jsp";
			}
			Classroom classroom = (Classroom) session.getAttribute("classroom");
			// Lista teaching
			teachingList = managerTeaching.getTeachingsByClassroomId(classroom
					.getIdAddress());
			Integer year = (Integer) session.getAttribute("selectedYear");
			 //Quadrimestre
			int turn = (Integer) session.getAttribute("q");

			UserListItem student = (UserListItem) session
					.getAttribute("student");
			session.setAttribute("teachingList", teachingList);
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.teachingManagement;

import smos.Environment;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per modificare un insegnamento.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletShowTeachingDetails extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 7882088509329309672L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/teachingManagement/showTeachingDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		int teachingId = 0;
		Teaching teaching = null;
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			teachingId = Integer.valueOf(pRequest.getParameter("idTeaching"));
			teaching = managerTeaching.getTeachingById(teachingId);
			session.setAttribute("teaching", teaching);
		} catch (NumberFormatException numberFormatException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Note;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletInsertNewNote extends HttpServlet {

	
	
	
	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -6496360730201101300L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		//instanziare gli oggetti qua
		
		ManagerRegister managerRegister = ManagerRegister.getInstance(); 
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			//settare le cose da passare alla session, usare session.setAttribute(String, attribute) 
			
			
			if(pRequest.getParameter("insert")==null){
				User student =(User) session.getAttribute("student"); 
					//managerUser.getUserById(Integer.valueOf((String)pRequest.getAttribute("student")));
				session.setAttribute("student", student);
				session.setAttribute("idStudent", student.getId());
				gotoPage="./registerManagement/insertNewNote.jsp";
			}else{
				
				
				Note nNote= new Note();
				nNote.setAcademicYear(((Classroom) session.getAttribute("classroom")).getAcademicYear());
				nNote.setDateNote(Utility.String2Date(pRequest.getParameter("dateNote")));
				nNote.setIdUser((Integer) session.getAttribute("idStudent"));
				nNote.setTeacher(pRequest.getParameter("noteTeacher"));
				nNote.setDescription(pRequest.getParameter("noteDescription"));
				
				try{
					managerRegister.insertNote(nNote);
					gotoPage="./showNoteList?student="+session.getAttribute("idStudent");
				}catch(MandatoryFieldException e){
					session.setAttribute("error", e.getMessage());
					gotoPage="./registerManagement/insertNewNote.jsp";
				}				
				
			}
			
			
				pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	
		
}

/*
 * NotYetImplementedException
 *
 */

package smos.storage.connectionManagement.exception;

/**
 * This exception is thrown as a warning from a part of the code which has not
 * been implemented yet, but will be in future.
 */
public class NotImplementedYetException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    /**
     * 
     */
    public NotImplementedYetException() {
        super();
    }

    /**
     * @param pMessage
     */
    public NotImplementedYetException(String pMessage) {
        super(pMessage);
    }

}

package smos.storage;


import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

import smos.bean.Classroom;
import smos.bean.User;

import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.connectionManagement.DBConnection;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ManagerClassroom  {

	/**
	 * Classe che gestiste le classi dell'istituto 
	 * @author Nicola Pisanti
	 * @version 1.0
	 */
	
	private static ManagerClassroom instance;
	
	public static final String TABLE_CLASSROOM = "classroom";
	public static final String TABLE_ADDRESS ="address";
	public static final String TABLE_TEACHER_HAS_CLASSROOM = "teacher_has_classroom";
	public static final String TABLE_STUDENT_HAS_CLASSROOM = "student_has_classroom";
	
	private ManagerClassroom(){
		super();
	}
	
	
	
	/**
	 * Ritorna la sola istanza della classe esistente.
	 * 
	 * @return Ritorna l'istanza della classe.
	 */
	public static synchronized ManagerClassroom getInstance(){
		if(instance==null){
			instance = new ManagerClassroom();
		}
		return instance;
	}
	
	
	
	
	
	/**
	 * Verifica se la classe data in input è nel database
	 * @param La classe di cui bisogna verificare l'esistenza
	 * @return true se la classe è nel database, altrimenti false
	 * @throws MandatoryFieldException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized boolean exists (Classroom pClassroom) throws MandatoryFieldException, ConnectionException, SQLException {
		
		boolean result = false;
		Connection connect = null;

		if (pClassroom.getName() == null)
			throw new MandatoryFieldException("Specificare il nome della classe.");
		if (pClassroom.getAcademicYear() <=1970)
			throw new MandatoryFieldException("Specificare l'anno accademico");
		if (pClassroom.getIdAddress()<=0){
			throw new MandatoryFieldException("Specificare l'indirizzo");
			//l'utente inserisce l'indirizzo, viene convertito in idAddress
		}
		
		try {
			//Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			String sql = "SELECT * FROM " 
				+ ManagerClassroom.TABLE_CLASSROOM
				+ " WHERE name = " 
				+ Utility.isNull(pClassroom.getName()) 
				+ " AND accademic_year = "
				+ Utility.isNull(pClassroom.getAcademicYear()
				+ " AND id_address = "
				+ Utility.isNull(pClassroom.getIdAddress())
				
				);

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);

			if (tRs.next())
				result = true;

			return result;
			
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}
	
	
	
	/**
	 * Inserisce l'oggetto di tipo classe nel database
	 * @param la classe da inserire nel database
	 * @throws MandatoryFieldException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insert(Classroom pClassroom) throws MandatoryFieldException, 
		ConnectionException, SQLException, EntityNotFoundException, InvalidValueException{
		
		Connection connect= null;
		try{
			// controllo dei campi obbligatori
			if (pClassroom.getName() == null)
				throw new MandatoryFieldException("Specificare il nome della classe.");
			if (pClassroom.getAcademicYear() <=1970)
				throw new MandatoryFieldException("Specificare l'anno accademico");
			if (pClassroom.getIdAddress()<=0){
				throw new MandatoryFieldException("Specificare l'indirizzo");
				//l'utente inserisce l'indirizzo, viene convertito in idAddress
			}
			
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			//Prepariamo la stringa Sql
			String sql =
				"INSERT INTO " 
				+ ManagerClassroom.TABLE_CLASSROOM 
				+ " (id_address, name, accademic_year) " 
				+ "VALUES (" 
				+ Utility.isNull(pClassroom.getIdAddress()) 
				+ "," 
				+ Utility.isNull(pClassroom.getName()) 
				+ "," 
				+ Utility.isNull(pClassroom.getAcademicYear())
				+ ")";
		
			Utility.executeOperation(connect,sql);
		
			pClassroom.setIdClassroom((Utility.getMaxValue("id_classroom",ManagerClassroom.TABLE_CLASSROOM)));
		
		}finally {
		//rilascia le risorse
		
		DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Aggiorna le statistiche di una classe
	 * @param La classe con le statistiche aggiornate (ma ID identico)
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	public synchronized void update (Classroom pClassroom) throws ConnectionException,
	SQLException, EntityNotFoundException, MandatoryFieldException{
		Connection connect= null;
		
		try{
			if (pClassroom.getIdClassroom()<=0)
				throw new EntityNotFoundException("Impossibile trovare la classe!");
			
			if (pClassroom.getName() == null)
				throw new MandatoryFieldException("Specificare il nome della classe.");
			if (pClassroom.getAcademicYear() <=1970)
				throw new MandatoryFieldException("Specificare l'anno accademico");
			if (pClassroom.getIdAddress()<=0){
				throw new MandatoryFieldException("Specificare l'indirizzo");
				//l'utente inserisce l'indirizzo, viene convertito in idAddress
			}
			//Prepariamo la stringa SQL
			String sql=
				"UPDATE " 
				+	ManagerClassroom.TABLE_CLASSROOM 
				+ " SET" 
				+ " id_address = " 
				+ Utility.isNull(pClassroom.getIdAddress()) 
				+ ", name = " 
				+ Utility.isNull(pClassroom.getName()) 
				+ ", accademic_year = " 
				+ Utility.isNull(pClassroom.getAcademicYear())  
				+ " WHERE id_classroom = " 
				+ Utility.isNull(pClassroom.getIdClassroom());
			
			//effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			
			Utility.executeOperation(connect, sql);
		}finally {
		//rilascia le risorse
		DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Cancella una classe dal database
	 * @param La classe da cancellare
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 * @throws InvalidValueException
	 */
	public synchronized void delete (Classroom pClassroom) throws ConnectionException, 
			SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException {
		Connection connect = null;
		
		
		try {
			//ManagerUser.getInstance().userOnDeleteCascade(pUser);
			connect = DBConnection.getConnection();
				//Prepariamo la stringa SQL
				String sql = "DELETE FROM " 
							+ ManagerClassroom.TABLE_CLASSROOM 
							+ " WHERE id_classroom = "
							+ Utility.isNull(pClassroom.getIdClassroom());
			
				Utility.executeOperation(connect, sql);
		}finally {
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	
	public synchronized Collection<Classroom> getClassroomsByStudent(User pUser) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException, MandatoryFieldException{
		Collection<Classroom> result=null;
		Connection connect = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		try
		{
			// Se non esiste l'utente
			if (!managerUser.exists(pUser))
					throw new EntityNotFoundException("L'utente non esiste!!!");
			if(!managerUser.isStudent(pUser))
					throw new InvalidValueException("L'utente non  uno studente!");
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			int iduser=managerUser.getUserId(pUser);
			String tSql = 
				
				"SELECT " 
				+ ManagerClassroom.TABLE_CLASSROOM 
				+".* FROM " 
				+ ManagerClassroom.TABLE_STUDENT_HAS_CLASSROOM 
				+ ", "
				+ ManagerClassroom.TABLE_CLASSROOM 
				+ " WHERE "
				+ ManagerClassroom.TABLE_STUDENT_HAS_CLASSROOM
				+ ".id_user = "  
				+ Utility.isNull(iduser)
				+" AND "
				+ ManagerClassroom.TABLE_CLASSROOM 
				+".id_classroom = "
				+ ManagerClassroom.TABLE_STUDENT_HAS_CLASSROOM 
				+".id_classroom";
				
				
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
				result = this.loadRecordsFromRs(tRs);
				
			if(result.isEmpty()) 
				throw new EntityNotFoundException("Impossibile Trovare Classi per l'utente inserito");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Restituisce la classe che ha l'ID passato 
	 * @param L'ID della classe cercata
	 * @return una stringa che rappresenta la classe con l'ID fornito
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Classroom getClassroomByID(int pId) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Classroom result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pId <= 0)
				throw new EntityNotFoundException("Impossibile trovare la classe!");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerClassroom.TABLE_CLASSROOM 
				+ " WHERE id_classroom = " 
				+ Utility.isNull(pId) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = this.loadRecordFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare l'utente!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	
	/**
	 * Restituisce una collezione di classi dello stesso anno accademico
	 */
	public synchronized Collection<Classroom> getClassroomsByAcademicYear(int pAcademicYear) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Collection<Classroom> result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pAcademicYear <= 1970)
				throw new EntityNotFoundException("Data troppo vecchia");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerClassroom.TABLE_CLASSROOM 
				+ " WHERE accademic_year = " 
				+ Utility.isNull(pAcademicYear) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
				result = this.loadRecordsFromRs(tRs);
				
			if(result.isEmpty()) 
				throw new EntityNotFoundException("Impossibile Trovare Classi per la data inserita");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
		
	public synchronized Collection<Integer> getAcademicYearList() throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Collection<Integer> result=null;
		Connection connect = null;
		try
		{	
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT DISTINCT accademic_year FROM " 
				+ ManagerClassroom.TABLE_CLASSROOM
				+ " order by accademic_year ";
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
				result = this.loadIntegersFromRs(tRs);
				
			if(result.isEmpty()) 
				throw new EntityNotFoundException("Impossibile Trovare Classi per la data inserita");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	
	public synchronized Classroom getClassroomByUserAcademicYear(User pUser, int pAcademicYear) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException, MandatoryFieldException{
		Classroom result = null;
		Classroom temp = null;
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		Collection<Classroom> list = null;
		list = managerClassroom.getClassroomsByStudent(pUser);
		Iterator<Classroom> it = list.iterator();
		while(it.hasNext()){
			temp = it.next();
			if(temp.getAcademicYear()==pAcademicYear){
				result = temp;
				break;
			}
		}
		return result;
	}
	public synchronized Collection<Classroom> getClassroomsByTeacherAcademicYear(User pUser, int pAcademicYear) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException, MandatoryFieldException{
		Collection<Classroom> result = null;
		Connection connect = null;
		int idUser = pUser.getId();
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pAcademicYear <= 1970)
				throw new EntityNotFoundException("Data troppo vecchia");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * 
			 */
			String tSql = 
				"SELECT DISTINCT " 
				+ ManagerClassroom.TABLE_CLASSROOM +".* FROM "  
				+ ManagerClassroom.TABLE_CLASSROOM + ", "
				+ ManagerClassroom.TABLE_TEACHER_HAS_CLASSROOM 
				+ " WHERE  "
				+ ManagerClassroom.TABLE_CLASSROOM + ".id_classroom = "
				+ ManagerClassroom.TABLE_TEACHER_HAS_CLASSROOM 
				+ ".id_classroom  AND "
				+ ManagerClassroom.TABLE_CLASSROOM + ".accademic_year = "
				+ Utility.isNull(pAcademicYear)
				+ " AND "
				+ ManagerClassroom.TABLE_TEACHER_HAS_CLASSROOM + ".id_user = "
				+ Utility.isNull(idUser)
				;
			
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
				result = this.loadRecordsFromRs(tRs);
				
			if(result.isEmpty()) 
				throw new EntityNotFoundException("Impossibile Trovare Classi per l'utente e l'anno inseriti");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	
	}
	public synchronized Collection<Classroom> getClassroomsByTeacher(User pUser) 
	throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException, MandatoryFieldException{
		Collection<Classroom> result=null;
		Connection connect = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		try
		{
			// Se non esiste l'utente
			if (!managerUser.exists(pUser))
					throw new EntityNotFoundException("L'utente non esiste!!!");
			if(!managerUser.isTeacher(pUser))
					throw new InvalidValueException("L'utente non  uno studente!");
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			int iduser=managerUser.getUserId(pUser);
			String tSql = 
				
				"SELECT DISTINCT " 
				+ ManagerClassroom.TABLE_CLASSROOM 
				+".* FROM " 
				+ ManagerClassroom.TABLE_TEACHER_HAS_CLASSROOM 
				+ ", "
				+ ManagerClassroom.TABLE_CLASSROOM 
				+ " WHERE "
				+ ManagerClassroom.TABLE_TEACHER_HAS_CLASSROOM
				+ ".id_user = "  
				+ Utility.isNull(iduser)
				+" AND "
				+ ManagerClassroom.TABLE_CLASSROOM 
				+".id_classroom = "
				+ ManagerClassroom.TABLE_TEACHER_HAS_CLASSROOM 
				+".id_classroom";
				
				
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
				result = this.loadRecordsFromRs(tRs);
				
			if(result.isEmpty()) {
				
				throw new EntityNotFoundException("Impossibile Trovare Classi per l'utente inserito");
			}
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	/** COnsente la lettura di un intero dal recod resultSet
	 * 
	 * @param pRs
	 * 		resultSet
	 * @return
	 * 	collection<Integer>
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Collection<Integer> loadIntegersFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Collection<Integer> result = new Vector<Integer>();
		while(pRs.next())  {
			result.add(pRs.getInt("accademic_year"));
		} 
		return result;
	}



	/**
	 * Consente la lettura di un solo record dal Result Set
	 * @param Il result set da cui estrarre l'oggetto Classroom
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Classroom loadRecordFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Classroom classroom = new Classroom();
		classroom.setName(pRs.getString("name"));
		classroom.setAcademicYear(pRs.getInt("accademic_year"));
		classroom.setIdClassroom(pRs.getInt("id_classroom"));
		classroom.setIdAddress(pRs.getInt("id_address"));
		return classroom;
	}

	/**
	 * Consente la lettura di un più record dal Result Set
	 * @param Il result set da cui estrarre l'oggetto Classroom
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	
	private Collection<Classroom> loadRecordsFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Collection<Classroom> result = new Vector<Classroom>();
		while(pRs.next())  {
			result.add(loadRecordFromRs(pRs));
		} 
		return result;
	}

}

package smos.application.addressManagement;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import smos.Environment;
import smos.bean.Address;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerAddress;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli indirizzi.
 * 
 * @author Vecchione Giuseppe
 * 
 */
public class ServletShowAddressList extends HttpServlet {

	
	private static final long serialVersionUID = 8797912020763935353L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	
	protected void doGet(HttpServletRequest pRequest, HttpServletResponse pResponse){
		String errorMessage="";
		String gotoPage="./persistentDataManagement/addressManagement/showAddressList.jsp";
		HttpSession session=pRequest.getSession();
		Collection<Address> addressList=null;
		ManagerUser managerUser= ManagerUser.getInstance();
		ManagerAddress managerAddress= ManagerAddress.getInstance();
		User loggedUser = (User)session.getAttribute("loggedUser");
		
		
		try {
			if(loggedUser==null){
				pResponse.sendRedirect("./index.htm");
				return;
				}
			if(!managerUser.isAdministrator(loggedUser)){
				errorMessage="L' utente collegato non ha accesso alla funzionalita'!";
				gotoPage="./error.jsp";
				}
			addressList=managerAddress.getAddressList();
			
			
			session.setAttribute("addressList", addressList);
			pResponse.sendRedirect(gotoPage);
			return;
				
			} catch (IOException ioException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
				gotoPage = "./error.jsp";
				ioException.printStackTrace();
			} catch (SQLException sqlException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
				gotoPage = "./error.jsp";
				sqlException.printStackTrace();
			} catch (EntityNotFoundException entityNotFoundException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
				gotoPage = "./error.jsp";
				entityNotFoundException.printStackTrace();
			} catch (ConnectionException connectionException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
				gotoPage = "./error.jsp";
				connectionException.printStackTrace();
			} catch (InvalidValueException invalidValueException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
				gotoPage = "./error.jsp";
				invalidValueException.printStackTrace();
			}
		pRequest.getSession().setAttribute("errorMessage",errorMessage);
		
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}
	
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione generata quando un utente
  * inserisce una password errata durante l'autenticazione
  */
public class LoginException extends Exception {
	
	private static final long serialVersionUID = -1213284697567763493L;

	/**
	 * Genera l'eccezione senza un messagio di errore associato.
	 */
	public LoginException() {
		super("Login or Password Incorrect or Invalid Session!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public LoginException(String pMessage) {
		super(pMessage);
	}
	
}
package smos.bean;

import java.io.Serializable;
import java.util.Date;
public class Absence implements Serializable {

	/**
	 * Classe che modella l'assenza di uno studente
	 * @author Nicola Pisanti
	 * @version 1.0 
	 */
	private static final long serialVersionUID = -8396513309450121449L;
	
	private int idAbsence;
	private int idUser;
	private Date dateAbsence;
	private Integer idJustify;
	private int academicYear;
	
	public Absence (){
		
	}
	
	/**
	 * Metodo che restituisce l'id dell'assenza
	 * @return un intero che rappresenta l'id dell'assenza
	 */
	public int getIdAbsence() {
		return idAbsence;
	}
	/**
	 * Metodo che setta l'id dell'assenza
	 * @param un intero che rappresenta l'id da settare
	 */
	public void setIdAbsence(int pIdAbsence) {
		this.idAbsence = pIdAbsence;
	}
	/**
	 * Metodo che restituisce l'id dello studente relativo all'assenza
	 * @return un intero che rappresenta l'id dello studente assente
	 */
	public int getIdUser() {
		return idUser;
	}
	/**
	 * Metodo che setta l'id dello studente relativo all'assenza
	 * @param un intero che rappresenta l'id da settare
	 */
	public void setIdUser(int pIdUser) {
		this.idUser = pIdUser;
	}
	/**
	 * Metodo che restituisce la data dell'assenza
	 * @return una stringa che rappresenta la data dell'assenza
	 */
	public Date getDateAbsence() {
		return dateAbsence;
	}
	/**
	 * Metodo che setta la data dell'assenza
	 * @param una stringa con la data da settare
	 */
	public void setDateAbsence(Date pDateAbsence) {
		this.dateAbsence = pDateAbsence;
	}
	/**
	 * Metodo che ritorna l'id della giustifica relativa all'assenza
	 * @return un intero che rappresenta l'id della giustifica relativa all'assenza, oppure null se l'assenza non è stata giustificata
	 */
	public Integer getIdJustify() {
		
		return idJustify;
		
	}
	/**
	 * Metodo che setta l'id della giustifica relativa all'assenza
	 * @param un intero che rappresenta l'id della giustifica da settare
	 */
	public void setIdJustify(Integer pIdJustify) {
		this.idJustify = pIdJustify;
	}
	/**
	 * Metodo che restituisce l'anno accademico relativo all'assenza
	 * @return un intero che rappresenta l'anno in cui è iniziato l'anno accademico 
	 */
	public int getAcademicYear() {
		return academicYear;
	}
	/**
	 * Metodo che setta l'anno accademico relativo all'assenza
	 * @param un intero che rappresenta l'anno accademico da settare
	 */
	public void setAcademicYear(int pAcademicYear) {
		this.academicYear = pAcademicYear;
	}

}

package smos;

/**
 * Classe utilizzata per contenere le variabili d'ambiente di GESA 
 */
public class Environment {

    /**
     * Messaggio di errore di default.
     */
    public static String DEFAULT_ERROR_MESSAGE = "Un errore si e' verificato durante l'elaborazione della richiesta.<br><br>";

    private static String poolPropertiesPath = "";

    /**
     * @return getPoolPropertiesPath()
     */
    public static String getPoolPropertiesPath() {
        return poolPropertiesPath;
    }
    
    /**
     * @param poolPropertiesPath
     */
    public static void setPoolPropertiesPath(String poolPropertiesPath) {
        Environment.poolPropertiesPath = poolPropertiesPath;
    }
}
package smos.application.teachingManagement;

import smos.Environment;
import smos.bean.*;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per eliminare un insegnamento.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletDeleteTeaching extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7133554709559970023L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./teachingList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		User loggedUser = (User) session.getAttribute("loggedUser");
		ManagerUser managerUser = ManagerUser.getInstance();
		Teaching teaching = (Teaching) session.getAttribute("teaching");
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			} else
				managerTeaching.delete(teaching);

		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.storage;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Date;
import java.util.Vector;

import smos.bean.Absence;
import smos.bean.Delay;
import smos.bean.Justify;
import smos.bean.Note;
import smos.bean.RegisterLine;
import smos.bean.UserListItem;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.connectionManagement.DBConnection;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ManagerRegister {

	
	/**
	 * Classe che gestisce il Registro Digitale
	 * @author Nicola Pisanti
	 * @version 1.0
	 */
	
	private static ManagerRegister instance;
	
	public final static String TABLE_ABSENCE="absence";
	public final static String TABLE_DELAY="delay";
	public final static String TABLE_JUSTIFY="justify";
	public final static String TABLE_NOTE="note";
	
	
	private ManagerRegister(){
		super();
	}
	
	
	/**
	 * Ritorna la sola istanza della classe esistente.
	 * 
	 * @return Ritorna l'istanza della classe.
	 */
	public static synchronized ManagerRegister getInstance(){
		if(instance==null){
			instance = new ManagerRegister();
		}
		return instance;
	}
	
	/**
	 * Verifica se la classe data in input è nel database
	 * @param pAbsence
	 * 		La classe di cui bisogna verificare l'esistenza
	 * @return true se la classe è nel database, altrimenti false
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized boolean exists(Absence pAbsence) throws ConnectionException, SQLException {
		
		boolean result = false;
		Connection connect = null;

		try {
			//Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			String sql = "SELECT * FROM " 
				+ ManagerRegister.TABLE_ABSENCE
				+ " WHERE id_absence = "
				+ Utility.isNull(pAbsence.getIdAbsence());

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);

			if (tRs.next()){
				result = true;
			}
			
			return result;
			
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Verifica se la classe data in input è nel database
	 * @param pDelay
	 * 		La classe di cui bisogna verificare l'esistenza
	 * @return true se la classe è nel database, altrimenti false
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized boolean exists(Delay pDelay) throws ConnectionException, SQLException {
		
		boolean result = false;
		Connection connect = null;

		try {
			//Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			String sql = "SELECT * FROM " 
				+ ManagerRegister.TABLE_ABSENCE
				+ " WHERE id_delay = "
				+ Utility.isNull(pDelay.getIdDelay());
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);

			if (tRs.next())
				result = true;

			return result;
			
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Verifica se la classe data in input è nel database
	 * @param pDelay
	 * 		La classe di cui bisogna verificare l'esistenza
	 * @return true se la classe è nel database, altrimenti false
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized boolean exists(Justify pJustify) throws ConnectionException, SQLException {
		
		boolean result = false;
		Connection connect = null;

		try {
			//Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			String sql = "SELECT * FROM " 
				+ ManagerRegister.TABLE_JUSTIFY
				+ " WHERE  id_justify = "
				+ Utility.isNull(pJustify.getIdJustify());

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);

			if (tRs.next())
				result = true;

			return result;
			
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Inserisce un assenza nel database
	 * @param pAbsence
	 * 		un oggetto di tipo Absence da inserire nel database
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insertAbsence(Absence pAbsence) throws  
		ConnectionException, SQLException, EntityNotFoundException, InvalidValueException{
		
		Connection connect= null;
		try{
			
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			//Prepariamo la stringa Sql
			String sql =
				"INSERT INTO " 
				+ ManagerRegister.TABLE_ABSENCE 
				+ " (id_user, date_absence, id_justify, accademic_year) " 
				+ "VALUES (" 
				+ Utility.isNull(pAbsence.getIdUser()) 
				+ "," 
				+ Utility.isNull(pAbsence.getDateAbsence()) 
				+ "," 
				+ Utility.isNull(pAbsence.getIdJustify()) 
				+ "," 
				+ Utility.isNull(pAbsence.getAcademicYear())
				+ ")";
		
			Utility.executeOperation(connect,sql);
		
			pAbsence.setIdAbsence((Utility.getMaxValue("id_absence",ManagerRegister.TABLE_ABSENCE)));
		
		}finally {
		//rilascia le risorse
		
		DBConnection.releaseConnection(connect);
		}
	}
	

	/**
	 * Inserisce un ritardo nel database
	 * @param pDelay
	 * 		un oggetto di tipo Delay da inserire nel database
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insertDelay(Delay pDelay) throws  
		ConnectionException, SQLException, EntityNotFoundException, InvalidValueException{
		
		Connection connect= null;
		try{
			
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			//Prepariamo la stringa Sql
			String sql =
				"INSERT INTO " 
				+ ManagerRegister.TABLE_DELAY 
				+ " (id_user, date_delay, time_delay, accademic_year) " 
				+ "VALUES (" 
				+ Utility.isNull(pDelay.getIdUser()) 
				+ "," 
				+ Utility.isNull(pDelay.getDateDelay()) 
				+ "," 
				+ Utility.isNull(pDelay.getTimeDelay()) 
				+ "," 
				+ Utility.isNull(pDelay.getAcademicYear())
				+ ")";
		
			Utility.executeOperation(connect,sql);
		
			pDelay.setIdDelay((Utility.getMaxValue("id_delay",ManagerRegister.TABLE_DELAY)));
		
		}finally {
		//rilascia le risorse
		
		DBConnection.releaseConnection(connect);
		}
	}
	


	/**
	 * Inserisce una nota nel database
	 * @param pNote
	 * 		un oggetto di tipo Note da inserire nel database
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insertNote(Note pNote) throws MandatoryFieldException,  
		ConnectionException, SQLException, EntityNotFoundException, InvalidValueException{
		
		Connection connect= null;
		try{
			if (pNote.getDescription() == null || pNote.getDescription().equals(""))
				throw new MandatoryFieldException("Inserire il testo della nota");
			
			if (pNote.getTeacher() == null || pNote.getTeacher().equals("") )
				throw new MandatoryFieldException("Inserire l'insegnante");
			
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			//Prepariamo la stringa Sql
			String sql =
				"INSERT INTO " 
				+ ManagerRegister.TABLE_NOTE 
				+ " (id_user, date_note, description, teacher, accademic_year) " 
				+ "VALUES (" 
				+ Utility.isNull(pNote.getIdUser()) 
				+ "," 
				+ Utility.isNull(pNote.getDateNote()) 
				+ "," 
				+ Utility.isNull(pNote.getDescription()) 
				+ "," 
				+ Utility.isNull(pNote.getTeacher()) 
				+ "," 
				+ Utility.isNull(pNote.getAcademicYear())
				+ ")";
		
			Utility.executeOperation(connect,sql);
		
			pNote.setIdNote((Utility.getMaxValue("id_note",ManagerRegister.TABLE_NOTE)));
		
		}finally {
		//rilascia le risorse
		
		DBConnection.releaseConnection(connect);
		}
	}
	

	/**
	 * Inserisce una giustifica nel database
	 * @param pJustify 
	 * 		un oggetto di tipo Justify da inserire nel database
	 * @param pAbsence
	 * 		un oggetto di tipo Absence che rappresenta l'assenza giustificata
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insertJustify(Justify pJustify, Absence pAbsence) throws   
		ConnectionException, SQLException, EntityNotFoundException, InvalidValueException{
		
		Connection connect= null;
		try{
			
			
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			//Prepariamo la stringa Sql
			String sql =
				"INSERT INTO " 
				+ ManagerRegister.TABLE_JUSTIFY 
				+ " (id_user, date_justify, accademic_year) " 
				+ "VALUES (" 
				+ Utility.isNull(pJustify.getIdUser()) 
				+ "," 
				+ Utility.isNull(pJustify.getDateJustify()) 
				+ "," 
				+ Utility.isNull(pJustify.getAcademicYear())
				+ ")";
		
			Utility.executeOperation(connect,sql);
		
			pJustify.setIdJustify((Utility.getMaxValue("id_justify",ManagerRegister.TABLE_JUSTIFY)));
			
			pAbsence.setIdJustify(pJustify.getIdJustify());
			this.updateAbsence(pAbsence);
		
		}finally {
		//rilascia le risorse
		
		DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Cancella un'assenza dal database
	 * @param pAbsence
	 * 		l'assenza da cancellare
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void deleteAbsence (Absence pAbsence) throws ConnectionException, 
			SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException {
		Connection connect = null;
		
		
		try {
			connect = DBConnection.getConnection();
				//Prepariamo la stringa SQL
				String sql = "DELETE FROM " 
							+ ManagerRegister.TABLE_ABSENCE 
							+ " WHERE id_absence = "
							+ Utility.isNull(pAbsence.getIdAbsence());
			
				Utility.executeOperation(connect, sql);
				
				if (!(pAbsence.getIdJustify()==null)){
					deleteJustify(pAbsence.getIdJustify());
				}
		}finally {
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}


	/**
	 * Cancella un ritardo dal database
	 * @param pDelay
	 * 		il ritardo da cancellare
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void deleteDelay (Delay pDelay) throws ConnectionException, 
			SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException {
		Connection connect = null;
		
		
		try {
			connect = DBConnection.getConnection();
				//Prepariamo la stringa SQL
				String sql = "DELETE FROM " 
							+ ManagerRegister.TABLE_DELAY 
							+ " WHERE id_delay = "
							+ Utility.isNull(pDelay.getIdDelay());
			
				Utility.executeOperation(connect, sql);
		}finally {
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Cancella una nota dal database
	 * @param pNote
	 * 		la nota da cancellare
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void deleteNote (Note pNote) throws ConnectionException, 
			SQLException, EntityNotFoundException, InvalidValueException {
		Connection connect = null;
		
		
		try {
			connect = DBConnection.getConnection();
				//Prepariamo la stringa SQL
				String sql = "DELETE FROM " 
							+ ManagerRegister.TABLE_NOTE 
							+ " WHERE id_note = "
							+ Utility.isNull(pNote.getIdNote());
			
				Utility.executeOperation(connect, sql);
		}finally {
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Cancella una nota dal database
	 * @param pJIDustify
	 * 		l'ID della nota da cancellare
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void deleteJustify (int pIDJustify) throws ConnectionException, 
			SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException {
		Connection connect = null;
		
		
		try {
			connect = DBConnection.getConnection();
				//Prepariamo la stringa SQL
				String sql = "DELETE FROM " 
							+ ManagerRegister.TABLE_JUSTIFY 
							+ " WHERE id_justify = "
							+ Utility.isNull(pIDJustify);
			
				Utility.executeOperation(connect, sql);
				
				try{
					Absence temp= getAbsenceByIdJustify(pIDJustify);
					temp.setIdJustify(0);
					updateAbsence(temp);
				}catch(Exception e){
					//  normale se un exception viene generata
					// dato che pu essere che stiamo cancellando una giustifica
					//di cui abbiamo appena cancellato l'assenza 
				}
				
				
		}finally {
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Aggiorna le statistiche di un'assenza
	 * @param pAbsence
	 * 		L'assenza con le statistiche aggiornate (ma ID identico)
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	
	
	public synchronized void updateAbsence (Absence pAbsence) throws ConnectionException,
	SQLException, EntityNotFoundException{
		Connection connect= null;
		
		try{

			
			//Prepariamo la stringa SQL
			String sql=
				"UPDATE " 
				+	ManagerRegister.TABLE_ABSENCE 
				+ " SET" 
				+ " id_user = " 
				+ Utility.isNull(pAbsence.getIdUser()) 
				+ ", date_absence = " 
				+ Utility.isNull(pAbsence.getDateAbsence()) 
				+ ", id_justify = " 
				+ Utility.isNull(pAbsence.getIdJustify())  
				+ ", accademic_year = " 
				+ Utility.isNull(pAbsence.getAcademicYear())  
				+ " WHERE id_absence = " 
				+ Utility.isNull(pAbsence.getIdAbsence());
			
			//effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			
			Utility.executeOperation(connect, sql);
		}finally {
		//rilascia le risorse
		DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Aggiorna le statistiche di un ritardo
	 * @param pDelay
	 * 		Il ritardo con le statistiche aggiornate (ma ID identico)
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	
	
	public synchronized void updateDelay (Delay pDelay) throws ConnectionException,
	SQLException, EntityNotFoundException, MandatoryFieldException{
		Connection connect= null;
		
		try{

			
			//Prepariamo la stringa SQL
			String sql=
				"UPDATE " 
				+	ManagerRegister.TABLE_DELAY 
				+ " SET" 
				+ " id_user = " 
				+ Utility.isNull(pDelay.getIdUser()) 
				+ ", date_delay = " 
				+ Utility.isNull(pDelay.getDateDelay()) 
				+ ", time_delay = " 
				+ Utility.isNull(pDelay.getTimeDelay())  
				+ ", accademic_year = " 
				+ Utility.isNull(pDelay.getAcademicYear())  
				+ " WHERE id_delay = " 
				+ Utility.isNull(pDelay.getIdDelay());
			
			//effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			
			Utility.executeOperation(connect, sql);
		}finally {
		//rilascia le risorse
		DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Metodo che aggiorna le statistiche di una Nota
	 * @param pNote
	 * 		un oggetto di tipo Note con le statistiche aggiornate ma id identico
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	
	public synchronized void updateNote (Note pNote) throws ConnectionException,
	SQLException, EntityNotFoundException, MandatoryFieldException{
		Connection connect= null;
		
		try{
			if (pNote.getDescription() == null || pNote.getDescription().equals(""))
				throw new MandatoryFieldException("Inserire il testo della nota");
			
			if (pNote.getTeacher() == null || pNote.getTeacher().equals("") )
				throw new MandatoryFieldException("Inserire l'insegnante");
			//Prepariamo la stringa SQL
			String sql=
				"UPDATE " 
				+	ManagerRegister.TABLE_NOTE
				+ " SET" 
				+ " id_user = " 
				+ Utility.isNull(pNote.getIdUser()) 
				+ ", date_note = " 
				+ Utility.isNull(pNote.getDateNote())   
				+ ", description = " 
				+ Utility.isNull(pNote.getDescription())   
				+ ", teacher = " 
				+ Utility.isNull(pNote.getTeacher())   
				+ ", accademic_year = " 
				+ Utility.isNull(pNote.getAcademicYear())  
				+ " WHERE id_note = " 
				+ Utility.isNull(pNote.getIdNote());
			
			//effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			
			Utility.executeOperation(connect, sql);
		}finally {
		//rilascia le risorse
		DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Aggiorna le statistiche di una giustifica 
	 * @param pJustify
	 * 		la giustifica con le statistiche aggiornate (ma ID identico)
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	

	public synchronized void updateJustify (Justify pJustify) throws ConnectionException,
	SQLException, EntityNotFoundException, MandatoryFieldException{
		Connection connect= null;
		
		try{

			
			//Prepariamo la stringa SQL
			String sql=
				"UPDATE " 
				+	ManagerRegister.TABLE_JUSTIFY
				+ " SET" 
				+ " id_user = " 
				+ Utility.isNull(pJustify.getIdUser()) 
				+ ", date_justify = " 
				+ Utility.isNull(pJustify.getDateJustify())   
				+ ", accademic_year = " 
				+ Utility.isNull(pJustify.getAcademicYear())  
				+ " WHERE id_justify = " 
				+ Utility.isNull(pJustify.getIdJustify());
			
			//effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect==null)
				throw new ConnectionException();
			
			Utility.executeOperation(connect, sql);
		}finally {
		//rilascia le risorse
		DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Metodo che restituisce una nota dato l'id della note stessa
	 * @param pIDJustify
	 * 		un intero che rappresenta l'id della nota  
	 * @return un oggetto di tipo Note che rappresenta la nota
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	
	
	public synchronized Note getNoteById( int pIDNote)throws InvalidValueException,
			EntityNotFoundException, ConnectionException, SQLException{
		Note result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pIDNote<=0)
				throw new EntityNotFoundException("Impossibile trovare la nota");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_NOTE 
				+ " WHERE id_note = " 
				+ Utility.isNull(pIDNote) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = this.loadNoteFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare la nota!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}	
	
	
	
	
	
	
	
	/**
	 * Metodo che restituisce un assenza dato l'id della giustifca associata a tale assenza
	 * @param pIDJustify
	 * 		un intero che rappresenta l'id della giustifica  
	 * @return un oggetto di tipo Absence che rappresenta l'assenza giustificata
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	
	
	public synchronized Absence getAbsenceByIdJustify( int pIDJustify)throws InvalidValueException,
			EntityNotFoundException, ConnectionException, SQLException{
		Absence result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pIDJustify<=0)
				throw new EntityNotFoundException("Impossibile trovare la l'assenza");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_ABSENCE 
				+ " WHERE id_justify = " 
				+ Utility.isNull(pIDJustify) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = this.loadAbsenceFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare l'assenza!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Metodo che restituisce un assenza dato l'id di questa
	 * @param pIDAbsence
	 * 		un intero che rappresenta l'id dell'assenza  
	 * @return un oggetto di tipo Absence che rappresenta l'assenza 
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	
	
	public synchronized Absence getAbsenceByIdAbsence( int pIDAbsence)throws InvalidValueException,
			EntityNotFoundException, ConnectionException, SQLException{
		Absence result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pIDAbsence<=0)
				throw new EntityNotFoundException("Impossibile trovare l' assenza");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_ABSENCE 
				+ " WHERE id_absence = " 
				+ Utility.isNull(pIDAbsence) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = this.loadAbsenceFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare l'assenza!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	
	/**
	 * Metodo che restituisce un ritardo dato l'id di questo
	 * @param pIDDelay
	 * 		un intero che rappresenta l'id del ritardo  
	 * @return un oggetto di tipo Delay che rappresenta il ritardo
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	
	
	public synchronized Delay getDelayById( int pIDDelay)throws InvalidValueException,
			EntityNotFoundException, ConnectionException, SQLException{
		Delay result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pIDDelay<=0)
				throw new EntityNotFoundException("Impossibile trovare il ritardo");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_DELAY
				+ " WHERE id_delay = " 
				+ Utility.isNull(pIDDelay) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = this.loadDelayFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare l'assenza!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Metodo che restituisce un assenza dato l'id di questa
	 * @param pIDAbsence
	 * 		un intero che rappresenta l'id dell'assenza  
	 * @return un oggetto di tipo Absence che rappresenta l'assenza 
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	
	
	public synchronized Justify getJustifyByIdJustify( int pIDJustify)throws InvalidValueException,
			EntityNotFoundException, ConnectionException, SQLException{
		Justify result=null;
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pIDJustify<=0)
				throw new EntityNotFoundException("Impossibile trovare la giustifica");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_JUSTIFY 
				+ " WHERE id_justify = " 
				+ Utility.isNull(pIDJustify) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				
				result= this.loadJustifyFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare la giustifica!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Metodo che restituisce true se l'assenza data in input ha una giustifica assegnata
	 * @param pAbsence
	 * 		un oggetto di valore Absence di cui bisogna controllare se ha giustifica
	 * @return true se l'assenza è giustificata, false altrimenti
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	
	public synchronized boolean hasJustify(Absence pAbsence)throws EntityNotFoundException, ConnectionException, SQLException{
		if(!exists(pAbsence)) throw new EntityNotFoundException("Assenza non presente in database");
		if(pAbsence.getIdJustify()==null) return false;
		return true;
	}
	
	/**
	 * Metodo che restituisce la giustifica legata a una data assenza
	 * @param pAbsence
	 * 		un oggetto di tipo Absence che rappresenta l'assenza
	 * @return	un oggetto di tipo Justify, oppure null se l'assenza non ha giustifica
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */

	public synchronized Justify getJustifyByAbsence(Absence pAbsence)throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		if(!exists(pAbsence)) throw new EntityNotFoundException("Assenza non presente in database");
		if(pAbsence.getIdJustify()==null) return null;
		
		Justify result=null;
		Connection connect = null;
		try{
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_JUSTIFY 
				+ " WHERE id_justify = " 
				+ Utility.isNull(pAbsence.getIdJustify()) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = this.loadJustifyFromRs(tRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare la giustifica!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
		
		
	}

	/**
	 * Metodo che restituisce le assenze preso un dato anno scolastico e utente in input
	 * @param pIdUser
	 * 		un intero che rappresenta l'id dell'utente
	 * @param pAcademicYear
	 * 		un intero che rappresenta l'anno accademico 
	 * @return una colleczione di assenze (vuota se l'utente non ha avuto assenze ) 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	
	
	public synchronized Collection<Absence> getAbsenceByIDUserAndAcademicYear(int pIdUser, int pAcademicYear) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Collection<Absence> result=new Vector<Absence>();
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pAcademicYear <= 1970)
				throw new EntityNotFoundException("Data troppo vecchia");

			// idem per l'id user
			if (pIdUser<=0)
				throw new EntityNotFoundException("Utente non trovato");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_ABSENCE 
				+ " WHERE accademic_year = " 
				+ Utility.isNull(pAcademicYear) 
				+ " AND id_user = "
				+ Utility.isNull(pIdUser);
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			while(tRs.next())  {
				result.add(loadAbsenceFromRs(tRs));
			} 
				
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Metodo che restituisce una collezione di note per un dato utente ed un dato anno scolastico
	 * @param pIdUser
	 * 		un intero che rappresenta l'id dell'utente
	 * @param pAcademicYear
	 * 		un intero che rappresenta l'anno accademico 
	 * @return una collezione di note, vuota se l'utente non ne ha ricevute
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Note> getNoteByIDUserAndAcademicYear(int pIdUser, int pAcademicYear) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Collection<Note> result=new Vector<Note>();
		Connection connect = null;
		try
		{
			// Se non è stato fornito l'id restituiamo un codice di errore
			if (pAcademicYear <= 1970)
				throw new EntityNotFoundException("Data troppo vecchia");

			// idem per l'id user
			if (pIdUser<=0)
				throw new EntityNotFoundException("Utente non trovato");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_NOTE 
				+ " WHERE accademic_year = " 
				+ Utility.isNull(pAcademicYear) 
				+ " AND id_user = "
				+ Utility.isNull(pIdUser);
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			while(tRs.next())  {
				result.add(loadNoteFromRs(tRs));
			} 
				
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Metodo che restituisce l'assenza di una dato studente in un dato giorno 
	 * @param pIdUser
	 * 		un intero che rappresenta l'id dello studente
	 * @param pDate
	 * 		una stringa che rappresenta la data formattata per il database
	 * @return un oggetto di tipo Absence, oppure null se lo studente era presente
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */

	
	public synchronized Absence getAbsenceByIDUserAndDate(int pIdUser, Date pDate) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Absence result=new Absence();
		Connection connect = null;
		try
		{
			//TODO controlli sulla formattazione della stringa
			
			
			// idem per l'id user
			if (pIdUser<=0)
				throw new EntityNotFoundException("Utente non trovato");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_ABSENCE 
				+ " WHERE date_absence = " 
				+ Utility.isNull(pDate) 
				+ " AND id_user = "
				+ Utility.isNull(pIdUser);
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if(tRs.next())  {
				result=loadAbsenceFromRs(tRs);
			}else {
				result=null;
			}
				
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	
	/**
	 * Metodo che restituisce il ritardo di una dato studente in un dato giorno 
	 * @param pIdUser
	 * 		un intero che rappresenta l'id dello studente
	 * @param pDate
	 * 		una stringa che rappresenta la data formattata per il database
	 * @return un oggetto di tipo Delay, oppure null se lo studente era in orario o assente
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */

	
	public synchronized Delay getDelayByIDUserAndDate(int pIdUser, Date pDate) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Delay result=new Delay();
		Connection connect = null;
		try
		{
			//TODO controlli sulla formattazione della stringa
			
			
			// idem per l'id user
			if (pIdUser<=0)
				throw new EntityNotFoundException("Utente non trovato");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti alla classe dell'id passato
			 */
			String tSql = 
				"SELECT * FROM " 
				+ ManagerRegister.TABLE_DELAY 
				+ " WHERE date_delay = " 
				+ Utility.isNull(pDate) 
				+ " AND id_user = "
				+ Utility.isNull(pIdUser);
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if(tRs.next())  {
				result=loadDelayFromRs(tRs);
			}else {
				result=null;
			}
				
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	
	public synchronized Collection<RegisterLine> getRegisterByClassIDAndDate(int pClassID, Date pDate) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		
		Collection<RegisterLine> result = new Vector<RegisterLine>();
		ManagerUser mg = ManagerUser.getInstance();
		
		Collection<UserListItem> students = mg.getStudentsByClassroomId(pClassID);
		
		
		for (UserListItem x : students){
			RegisterLine temp = new RegisterLine();
			temp.setStudent(x);
			temp.setAbsence(this.getAbsenceByIDUserAndDate(x.getId(), pDate));
			temp.setDelay(this.getDelayByIDUserAndDate(x.getId(), pDate));
			result.add(temp);
		}
		
		return result;
	}

	/**
	 * Metodo che verifica se c' un'assenza in una linea del registro 
	 * @param pRegisterLine
	 * 		un oggetto di tipo RegisterLine
	 * @return	true se c' un'assenza nella linea di registro passata, altrimenti false
	 */
	
	
	public boolean hasAbsence(RegisterLine pRegisterLine){
		if(pRegisterLine.getAbsence()==null)return false;
		return true;
	}

	/**
	 * Metodo che verifica se c' un ritardo in una linea del registro 
	 * @param pRegisterLine
	 * 		un oggetto di tipo RegisterLine
	 * @return	true se c' un ritardo nella linea di registro passata, altrimenti false
	 */
	
	
	public boolean hasDelay(RegisterLine pRegisterLine){
		if(pRegisterLine.getDelay()==null)return false;
		return true;
	}

	/**
	 * Consente la lettura di un solo record dal Result Set
	 * @param pRs
	 * 		Il result set da cui estrarre l'oggetto Absence
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Absence loadAbsenceFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Absence absence = new Absence();
		
		absence.setIdAbsence(pRs.getInt("id_absence"));
		absence.setIdUser(pRs.getInt("id_user"));
		absence.setDateAbsence((Date)pRs.getDate("date_absence"));
		absence.setIdJustify(pRs.getInt("id_justify"));
		absence.setAcademicYear(pRs.getInt("accademic_year"));
		
		return absence;
	}
	
	/**
	 * Consente la lettura di un solo record dal Result Set
	 * @param pRs
	 * 		Il result set da cui estrarre l'oggetto Justify
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Justify loadJustifyFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Justify justify = new Justify();
		
		justify.setIdJustify(pRs.getInt("id_justify"));
		justify.setIdUser(pRs.getInt("id_user"));
		justify.setDateJustify((Date)pRs.getDate("date_justify"));
		justify.setAcademicYear(pRs.getInt("accademic_year"));
		
		return justify;
	}
	/**
	 * Consente la lettura di un solo record dal Result Set
	 * @param pRs
	 * 		Il result set da cui estrarre l'oggetto Note
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	
	private Note loadNoteFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Note note= new Note();
		
		note.setIdNote(pRs.getInt("id_note"));
		note.setIdUser(pRs.getInt("id_user"));
		note.setDateNote((Date)pRs.getDate("date_note"));
		note.setDescription(pRs.getString("description"));
		note.setTeacher(pRs.getString("teacher"));	
		note.setAcademicYear(pRs.getInt("accademic_year"));
	
		return note;
	}

	/**
	 * Consente la lettura di un solo record dal Result Set
	 * @param pRs
	 * 		Il result set da cui estrarre l'oggetto Delay
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	
	private Delay loadDelayFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Delay delay = new Delay();
				
		delay.setIdDelay(pRs.getInt("id_delay"));
		delay.setIdUser(pRs.getInt("id_user"));
		delay.setDateDelay((Date)pRs.getDate("date_delay"));
		delay.setTimeDelay(pRs.getString("time_delay"));
		delay.setAcademicYear(pRs.getInt("accademic_year"));
	
		return delay;
	}
}

package smos.application.addressManagement;

import smos.Environment;
import smos.bean.Address;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerAddress;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per modificare un indirizzo.
 * 
 * @author Vecchione Giuseppe.
 * 
 */
public class ServletShowAddressDetails extends HttpServlet {

	

	

	
	private static final long serialVersionUID = 2136348837349051766L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/addressManagement/showAddressDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		int addressId = 0;
		Address address= null;
		ManagerAddress managerAddress = ManagerAddress.getInstance();
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			addressId = Integer.valueOf(pRequest.getParameter("idAddress"));
			address = managerAddress.getAddressById(addressId);
			session.setAttribute("address", address);
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
	} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Justify;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletDeleteJustify extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7692034998093997864L;

	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showRegister.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		String idClassroom=(String) session.getAttribute("idClassroom");
		int id= Integer.parseInt(idClassroom);
		gotoPage+="?idClassroom="+id;
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerRegister mR= ManagerRegister.getInstance();
		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) &&
					(!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
		
			Justify justify = (Justify) session.getAttribute("justify");
			
			if(mR.exists(justify)){
				mR.deleteJustify(justify.getIdJustify());
			}else{
				errorMessage= "impossibile cancellare la giustifica, questa non esiste!";
				gotoPage = "./error.jsp";
			}
			
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} 

		session.setAttribute("errorMessage", errorMessage);
		try {
			
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}


}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Absence;
import smos.bean.Classroom;
import smos.bean.Delay;
import smos.bean.RegisterLine;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletUpdateRegister extends HttpServlet {

	private static final long serialVersionUID = 5966298318913522686L;
	
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showClassroomList.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		
		//Variabile booleana utilizzata per verificare se lo studente ha o meno un'assenza
		boolean flag = false;
		
		//Collection utilizzata per la memorizzazione del registro di una particolare data
		Collection<RegisterLine> register = null;
		//Iteratore necessario a scorrere la collection
		Iterator itRegister = null;
		//Variabile temporanea necessaria a leggere le informazioni dalla collection
		RegisterLine tmpRegisterLine = null;
		//Variabile temporanea necessaria a leggere le informazioni dalla collection
		UserListItem student = null;
		
		//Variabile temporanea necessaria all'inserimento delle nuove assenze
		Absence tmpAbsence = null;
		
		//Variabile temporanea necessaria all'inserimento di nuovi ritardi
		Delay tmpDelay = null;
		
		//Classi manager necessarie all'elaborazione
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerRegister managerRegister = ManagerRegister.getInstance();
		
		//Variabili necessarie per la memorizzazione dei dati provenienti dalla request
		String[] absences = null; //Memorizza gli alunni assenti
		String[] delays = null; //Memorizza gli alunni ritardatari
		
		//Recupero l'utente loggato dalla sessione
		User loggedUser = (User) session.getAttribute("loggedUser");
		//Verifico che l'utente loggato abbia i permessi necessari
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}

			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
				return;
			}
		
		//Recupero i parametri dalla pRequest
		Date date = Utility.String2Date(pRequest.getParameter("date"));
		absences = pRequest.getParameterValues("absences");
		delays = pRequest.getParameterValues("delays");
		
		//Recupero l'oggetto classroom dalla session
		Classroom classroom = ((Classroom) session.getAttribute("classroom"));
		
		/*Invoco il metodo della managerRegister per recuperare dal db le informazioni
		 * inerenti il registro di una classe ad una particolare data (Assenze, Ritardi)
		 */
		register = managerRegister.getRegisterByClassIDAndDate(classroom.getIdClassroom(),date);
			
		if (register != null){
			itRegister = register.iterator();
		}
		
		if (itRegister != null){
			while(itRegister.hasNext()){
				tmpRegisterLine = (RegisterLine) itRegister.next();
				//Recupero lo studente cui la register line si riferisce
				student = tmpRegisterLine.getStudent();
				
				//Verifico se per lo studente e' stata inserita o meno un'assenza
				if (absences != null){
					for (int i=0; i<absences.length; i++){
						if (Integer.valueOf(absences[i]) == student.getId()){
							flag = true;
							if (!managerRegister.hasAbsence(tmpRegisterLine)){
								tmpAbsence = new Absence();
								tmpAbsence.setAcademicYear(classroom.getAcademicYear());
								tmpAbsence.setDateAbsence(date);
								tmpAbsence.setIdJustify(0);
								tmpAbsence.setIdUser(student.getId());
								managerRegister.insertAbsence(tmpAbsence);
							}
						}
						
					}
					if (!flag){
						if (managerRegister.hasAbsence(tmpRegisterLine)){
							managerRegister.deleteAbsence(tmpRegisterLine.getAbsence());
						}
					}
				} else {
					if (managerRegister.hasAbsence(tmpRegisterLine)){
						managerRegister.deleteAbsence(tmpRegisterLine.getAbsence());
					}
				}
				flag = false;
				
				//Verifico se per lo studente e' stata inserito o meno un ritardo
				if (delays != null){
					for (int i=0; i<delays.length; i++){
						if (Integer.valueOf(delays[i]) == student.getId()){
							flag = true;
							if (!managerRegister.hasDelay(tmpRegisterLine)){
								tmpDelay = new Delay();
								tmpDelay.setAcademicYear(classroom.getAcademicYear());
								tmpDelay.setDateDelay(date);
								tmpDelay.setIdUser(student.getId());
								tmpDelay.setTimeDelay(pRequest.getParameter("hour_" + student.getId()));
								managerRegister.insertDelay(tmpDelay);
							} else {
								tmpDelay = tmpRegisterLine.getDelay();
								tmpDelay.setTimeDelay(pRequest.getParameter("hour_" + student.getId()));
								managerRegister.updateDelay(tmpDelay);
							}
							
						}
						
					}
					if (!flag){
						if (managerRegister.hasDelay(tmpRegisterLine)){
							managerRegister.deleteDelay(tmpRegisterLine.getDelay());
						}
					}
				} else {
					if (managerRegister.hasDelay(tmpRegisterLine)){
						managerRegister.deleteDelay(tmpRegisterLine.getDelay());
					}
				}
				flag = false;
			}
		}
			
			

		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (InvalidValueException e) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + e.getMessage();
			gotoPage = "./error.jsp";
			e.printStackTrace();
		} catch (MandatoryFieldException e) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + e.getMessage();
			gotoPage = "./error.jsp";
			e.printStackTrace();
		}
		
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Absence;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletShowJustifyList extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6666791203700528449L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		
		String gotoPage = "./registerManagement/showJustifyList.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerRegister  managerRegister= ManagerRegister.getInstance();
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		
		String student =pRequest.getParameter("student");
		
		int st = Integer.parseInt(student);
		Classroom classroom=(Classroom)session.getAttribute("classroom");
		
		
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			
			User userStudent=managerUser.getUserById(st);
			
			Collection<Absence> absenceList =(Collection<Absence>)managerRegister.getAbsenceByIDUserAndAcademicYear(st, classroom.getAcademicYear());
			session.setAttribute("absenceList", absenceList);
			session.setAttribute("utente", userStudent);
				
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();}
		
		
	}
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	
}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione generata quando un utente
  * tenta di compiere un'operazione per la quale non ha il permesso.
  */
public class PermissionException extends Exception {
	
	private static final long serialVersionUID = 1881009447251825664L;

	/**
	 * Genera l'eccezione senza un messaggio di errore associato.
	 */
	public PermissionException() {
		super("Permission Denied!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public PermissionException(String pMessage) {
		super(pMessage);
	}
	
	
}
package smos.application.reportManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletShowStudentsByClass extends HttpServlet {

	/**
	 * Servlet utilizzata per visualizzare gli alunni associati ad una Classe.
	 * 
	 * @author Giulio D'Amora
	 * 
	 */

	/**
	 * 
	 */
	private static final long serialVersionUID = 2020233250419553067L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./reportsManagement/showStudentsByClass.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			int idClassroom = Integer.valueOf(pRequest
					.getParameter("idClassroom"));
			Classroom classroom = ManagerClassroom.getInstance().getClassroomByID(idClassroom);
			Collection<UserListItem> students = (Collection<UserListItem>) managerUser
					.getStudentsByClassroomId(idClassroom);
			session.setAttribute("StudentList", students);
			session.setAttribute("classroom", classroom);

		} catch (NumberFormatException numberFormatException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.utility;

import java.io.UnsupportedEncodingException;
import java.util.Properties;
import javax.mail.*;
import javax.mail.internet.*;


public class MailUtility {

	public static void sendMail(String pSender, String pReceiver, String pSubject, String pText) throws MessagingException, UnsupportedEncodingException {
		
		// Creazione di una mail session
		Properties props = new Properties();
		props.put("mail.smtp.host", Utility.getServerSmtp());
		Session session = Session.getDefaultInstance(props);

		// Creazione del messaggio da inviare
		MimeMessage message = new MimeMessage(session);
		message.setSubject(pSubject);
		message.setText(pText);

		// Aggiunta degli indirizzi del mittente e del destinatario
		InternetAddress fromAddress = new InternetAddress(pSender);
		InternetAddress toAddress = new InternetAddress(pReceiver);
		message.setFrom(fromAddress);
		message.setRecipient(Message.RecipientType.TO, toAddress);

		// Invio del messaggio
		Transport.send(message);
	}

}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione predefinita generata dal sistema.
  */
public class DefaultException extends Exception {
	
	private static final long serialVersionUID = -8985617134055655964L;

	/**
	 * Genera l'eccezione senza un messagio di errore associato.
	 */
	public DefaultException() {
		super();
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public DefaultException(String pMessage) {
		super(pMessage);
	}
	
	
}
package smos.bean;

import java.io.Serializable;

import smos.exception.InvalidValueException;

/**
 * 
 * Classe utilizzata per modellare una voto.
 * 
 * @author Luigi Colangelo 
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class Votes implements Serializable {

	/**
	 * Classe utilizzata per modellare un voto
	 * 
	 */
	private static final long serialVersionUID = 3014235634635608576L;
    private int id_votes;
    private int id_user;
    private int teaching;
    private int written;
    private int oral;
    private int laboratory;
    private int accademicYear;
    private int turn;
    
    /**
     * Il costruttore della classe
     */
    public Votes(){
    	id_votes=0;
    }
    
    /**
     * Metodo che restituisce l'id del voto.
     * @return l'id del voto
     */
	public int getId_votes() {
		return id_votes;
	}
	
	/**
	 * Metodo che setta l'id del voto
	 * @param pId_votes
     *             l'id da settare
	 */
	public void setId_votes(int pId_votes) {
		this.id_votes = pId_votes;
	}
	
	/**
	 * Metodo che restituisce l'id dell'utente collegato al voto
	 * @return l'id dell'utente
	 */
	public int getId_user() {
		return id_user;
	}
	
	/**
	 * Metodo che setta l'id dell'utente relativo al voto
	 * @param pId_user
	 *               l'id da settare
	 */
	public void setId_user(int pId_user) {
		this.id_user = pId_user;
	}
	
	/**
	 * metodo che restituisce il codice dell'insegnamento del voto
	 * @return il metodo dell'insegnamento
	 */
	public int getTeaching() {
		return teaching;
	}
	
	/**
	 * Metodo che setta il codice dell'insegnamento relativo al voto
	 * @param pTeaching
	 *              il codice dell'insegnamento
	 */
	public void setTeaching(int pTeaching) {
		this.teaching = pTeaching;
	}
	
	/**
	 * Metodo che restituisce il voto dello scritto 
	 * @return il voto nello scritto 
	 */
	public int getWritten() {
		return written;
	}
	
	/**
	 * Metodo che setta il voto dello scritto, controllando che esso sia compreso tra 0 e 10
	 * @param pWritten
	 */
	public void setWritten(int pWritten) throws InvalidValueException {
		if (pWritten < 0 || pWritten > 10)
			throw new InvalidValueException();
		else
		this.written = pWritten;
	}
	
	/**
	 *  metodo che restituisce il voto dell' orale
	 * @return il voto dell'orale
	 */
	public int getOral() {
		return oral;
	}
	
	/**
	 * Metodo che setta il voto dell'orale, controllando che esso sia compreso tra 0 e 10 
	 * @param pOral
	 *            il voto dell'orale da settare
	 */
	public void setOral(int pOral) throws InvalidValueException{
		if (pOral < 0 || pOral > 10)
			throw new InvalidValueException();
		else
		this.oral = pOral;
	}
	
	/**
	 * Metodo che restituisce il voto del laboratorio
	 * @return il voto del laboratorio
	 */
	public int getLaboratory() {
		return laboratory;
	}
	
	/**
	 * metodo che setta il voto del laboratorio, controllando che esso sia compreso tra 0 e 10
	 * @param pLaboratory
	 *                 il voto del laboratorio da settare
	 */
	public void setLaboratory(int pLaboratory)throws InvalidValueException {
		if (pLaboratory < 0 || pLaboratory > 10)
			throw new InvalidValueException();
		else
		this.laboratory = pLaboratory;
	}
	
	/**
	 * Metodo che restituisce l'anno accademico del voto
	 * @return l'anno accademico
	 */
	public int getAccademicYear() {
		return accademicYear;
	}
	
	/**
	 * metodo che setta l'anno accademico del voto
	 * @param pAccademicYear
	 */
	public void setAccademicYear(int pAccademicYear) {
		this.accademicYear = pAccademicYear;
	}
	
	/**
	 * Metodo che restituisce il quadrimestre del voto 
	 * @return il semestre del voto (0 o 1)
	 */
	public int getTurn() {
		return turn;
	}
	
	/**
	 * Metodo che setta il quadrimestre del voto
	 * @param pTurn
	 *            il semestre del voto da settare
	 */
	public void setTurn(int pTurn) {
		this.turn = pTurn;
	}
	
	public String toString(){
		return("id voto= "+id_votes+" id user= "+id_user+" id insegnamento= "+teaching+" scritto= "+written+" orale= "+oral+" laboratorio= "+laboratory+" anno accademico= "+accademicYear+" quadrimestre= "+turn);
	}
    
 
}

package smos.application.classroomManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;


import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletShowClassroomList extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8468821050771730936L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/classroomManagement/showClassroomList.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Classroom> classroomList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom= ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
			
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			
			//prendere l'academic year dalla session
			
			classroomList = managerClassroom.getClassroomsByAcademicYear(Integer.valueOf(pRequest.getParameter("academicYear")));
			
					
			session.setAttribute("classroomList", classroomList);
			pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<%@ page import="smos.bean.*" %>
<%@ page import="smos.storage.ManagerUser"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="display" uri="http://displaytag.sf.net" %>
<%@ page import="smos.utility.Utility"%>

<%
	User loggedUser = (User) session.getAttribute("loggedUser");
	if ((loggedUser == null) || ((!ManagerUser.getInstance().isAdministrator(loggedUser)))) {
		response.sendRedirect("../index.htm");
		return;
	}
%>

<html>
<head>

	<title>School MOnitoring System</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" >
	<link rel="stylesheet" href="../../stylesheets/generic.css" type="text/css">
	<link rel="stylesheet" href="../../stylesheets/display.css" type="text/css">
</head>

<body>
		
	  <div id="container">
	  
	  	   <div id="header">
		   	    
			</div>
		   	      
			<div id="content_center" style="overflow-y:scroll;">
		    
            <div id="navigation">
           <a class="genericLink" href="<% if (ManagerUser.getInstance().isAdministrator(loggedUser)){%>../../homePage/homeAdmin.jsp<%}%>">Home</a> -> <font style="color:#0066FF; font-size:9pt">Gestione Utenti</font>
           </div>
            
            <div id="userspace">
				 User: <b><%=loggedUser.getFirstName() + " " + loggedUser.getLastName()%></b><br>
                 [<a style="font-size:11px" class="genericLink" href="../../logout">Esci</a>, <a style="font-size:11px" class="genericLink" href="../userManagement/alterPersonalDate.jsp">Modifica Password</a>]
			</div>
           
		  

		   <h1 align="left"> GESTIONE UTENTI </h1>

           <table id="transparent" align="center">
           <tr id="transparent">
           <td id="transparent">
		<% if (ManagerUser.getInstance().isAdministrator(loggedUser)) {%>
           <p class="button"><a class="menuLink" href="../userManagement/insertUser.jsp">Nuovo Utente</a></p>
		<%}%>
           </td>
           </tr>
           </table>
		   
		   <br>
		   <display:table name="sessionScope.userList" pagesize="15" sort="list" id="user" defaultsort="1" class="datatable" export="true">
				<display:setProperty name="basic.msg.empty_list">
					<caption>
						<p>Non ci sono utenti da visualizzare</p>
					</caption>
				</display:setProperty>
				
    			<display:setProperty name="export.pdf" value="true"/>				
				<display:column property="name" title="Nome" style="width:200px" sortable="true" headerClass="tdHeaderColumn"/>
				<display:column property="EMail" style="width:200px" title="e-mail" sortable="true" headerClass="tdHeaderColumn"/>	
				
				<display:column style="width:25px" title="Visualizza" sortable="false" headerClass="tdHeaderColumn"> 
				<%  if (((UserListItem)user).getId()!=0) { %>
					<a href="../../showUserDetails?userId=<%=((UserListItem)user).getId()%>"><img src="../../images/details.jpg" border="none"></a>
				<% } %>
				</display:column>
	       	</display:table>
				
		   </div>
		   
		   <div id="footer">
		   		<p><%= Utility.getTextFooter() %></p>
		   </div>
	  
	  </div>

</body>
</html>
package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli utenti.
 * 
 * @author Napolitano Vincenzo.
 *
 */
public class ServletShowUserList extends HttpServlet {

	private static final long serialVersionUID = -3988115259356084996L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/managerUser.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<UserListItem> userList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error0.jsp";
			} 
				
			userList = managerUser.getUserList();
			
					
			session.setAttribute("userList", userList);
			pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error1.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error2.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error3.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error4.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error5.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

/*
 * AdaptorException
 *
 */

package smos.storage.connectionManagement.exception;

import java.rmi.RemoteException;

/**
 * Thrown when a problem occurs running code in ensj.
 */
public class AdaptorException extends RemoteException {

    private static final long serialVersionUID = 1L;

    /**
     * 
     */
    public AdaptorException() {
        super();
    }

    /**
     * @param pMessage
     */
    public AdaptorException(String pMessage) {
        super(pMessage + buildLabel());
    }

    /**
     * @param pMessage
     * @param pParentException
     */
    public AdaptorException(String pMessage, Exception pParentException) {
        super(pMessage + buildLabel(), pParentException);
    }

    /**
     * @param pParentException
     */
    public AdaptorException(Exception pParentException) {
        super(buildLabel(), pParentException);
    }

    private static String buildLabel() {
        return " [1]";
    }
}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli anni accademici presenti nel
 * db.
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletShowTeacherTeachingFormByClass extends HttpServlet {

	private static final long serialVersionUID = -3988115259356084996L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/teacherTeachings.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Teaching> teachingList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		//User teacher = (User) session.getAttribute("user");
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			// recuperiamo l'id della classe selezionata
			int selectedClassId = Integer.valueOf(pRequest.getParameter("classId"));
			ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
			//Calcoliamo l'elenco degli insegnamenti associati alla class eselezionata
			teachingList = managerTeaching.getTeachingsByClassroomId(selectedClassId);
			session.setAttribute("teachingList", teachingList);
			Classroom selectedClass = ManagerClassroom.getInstance().getClassroomByID(selectedClassId);
			session.setAttribute("selectedClass", selectedClass);
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Note;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletShowNoteDetails extends HttpServlet {

	
	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 7648669052646601677L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		//instanziare gli oggetti qua
		
		ManagerRegister managerRegister = ManagerRegister.getInstance(); 
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			//settare le cose da passare alla session, usare session.setAttribute(String, attribute) 
			
			
			if(pRequest.getParameter("update")==null){
				User student =(User) session.getAttribute("student"); 
					//managerUser.getUserById(Integer.valueOf((String)pRequest.getAttribute("student")));
				session.setAttribute("student", student);
				session.setAttribute("idStudent", student.getId());
				session.setAttribute("note", ((ManagerRegister) managerRegister).getNoteById(Integer.valueOf(pRequest.getParameter("noteId"))));
				gotoPage="./registerManagement/showNoteDetails.jsp";
			}else{
				
				
				Note nNote= new Note();
				nNote.setAcademicYear(((Classroom) session.getAttribute("classroom")).getAcademicYear());
				nNote.setDateNote(Utility.String2Date(pRequest.getParameter("dateNote")));
				nNote.setIdUser((Integer) session.getAttribute("idStudent"));
				nNote.setTeacher(pRequest.getParameter("noteTeacher"));
				nNote.setDescription(pRequest.getParameter("noteDescription"));
				nNote.setIdNote(((Note)session.getAttribute("note")).getIdNote());
				
				try{
					managerRegister.updateNote(nNote);
					gotoPage="./showNoteList?student="+session.getAttribute("idStudent");
				}catch(MandatoryFieldException e){
					session.setAttribute("error", e.getMessage());
					gotoPage="./registerManagement/showNoteDetails.jsp";
				}				
				
			}
			
			
				pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	
}

package smos.storage;

import java.sql.SQLException;
import java.util.Collection;

import smos.bean.Address;
import smos.bean.Teaching;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.connectionManagement.exception.ConnectionException;

public class UserTest {

	/**
	 * @param args
	 * @throws InvalidValueException 
	 * @throws ConnectionException 
	 * @throws EntityNotFoundException 
	 * @throws SQLException 
	 * @throws MandatoryFieldException 
	 */
	public static void main(String[] args) throws SQLException, EntityNotFoundException, ConnectionException, InvalidValueException, MandatoryFieldException {
		
	UserListItem temp =new UserListItem();
	temp.setId(5);
	Teaching teaching = new Teaching();
	teaching.setId(3);
	ManagerVotes mv = ManagerVotes.getInstance();
	Votes ghh = new Votes();
	ghh.setAccademicYear(2134);
	ghh.setId_user(88);
	ghh.setLaboratory(3);
	ghh.setOral(4);
	ghh.setTeaching(9);
	ghh.setTurn(2);
	ghh.setWritten(3);
	mv.insert(ghh);
	}	
}

package smos.application.userManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Role;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.DeleteManagerException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletRemoveStudentClassroom extends HttpServlet {

	/**
	 * 
	 */
	
	
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
			
			User user = (User) session.getAttribute("user");
			Classroom classroom = (Classroom)session.getAttribute("classroom");
			int idClassroom= classroom.getIdClassroom();
			
			Collection <UserListItem> studentClass= (Collection<UserListItem>)managerUser.getStudentsByClassroomId(idClassroom);
			Iterator<UserListItem> itStudent = null;
			if (studentClass != null){
				itStudent = studentClass.iterator();
			}
				
			while((itStudent != null) && (itStudent.hasNext())){ 
				UserListItem stud = (UserListItem)itStudent.next();
				if(stud.getId()==user.getId())
					managerUser.removeStudentClassroom(user, idClassroom);
			}	
			
			
			
			
			
					
						
				
				
			
			
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.storage;
import smos.bean.Address;
import smos.bean.Teaching;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.connectionManagement.DBConnection;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Vector;
import java.sql.Connection;

/**
*
* Classe manager degli indirizzi 
*
*/

public class ManagerAddress {

	private static ManagerAddress instance;
	
     /**
	 * Il nome della tabella degli indirizzi
	 */
	public static final String TABLE_ADDRESS = "address";
	public static final String TABLE_ADDRESS_HAS_TEACHING = "address_has_teaching";
	
	private ManagerAddress() {
		super();
	}
	

	/**
	 * Ritorna la sola istanza della classe esistente.
	 * 
	 * @return Ritorna l'istanza della classe.
	 */
	public static synchronized ManagerAddress getInstance(){
		if(instance==null){
			instance = new ManagerAddress();
			}
			return instance;
		}
	/**
	 * Verifica l'esistenza di un indirizzo nel database.
	 * 
	 * @param pAddress
	 *            L'indirizzo da controllare.
	 * @return Ritorna true se esiste gi l'indirizzo passato come parametro,
	 * 			false altrimenti.
	 *  
	 * @throws MandatoryFieldException 
	 * @throws SQLException
	 * @throws MandatoryFieldException
	 * @throws ConnectionException 
	 * @throws ConnectionException
	 * @throws SQLException 
	 */
	
	public synchronized boolean hasTeaching(Teaching pTeaching, Address pAddress)
	throws SQLException, EntityNotFoundException, ConnectionException,
	InvalidValueException {
Connection connect = null;
boolean result = false;
if (pTeaching.getId() <= 0)
	throw new EntityNotFoundException("Specificare l'insegnamento");

try {
	connect = DBConnection.getConnection();
	if (connect == null)
		throw new ConnectionException();

	// Preparimao la stringa sql
	String sql = "SELECT * FROM "
			+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS
			+ " WHERE id_teaching = "
			+ Utility.isNull(pTeaching.getId())
			+" AND id_address = "
			+ Utility.isNull(pAddress.getIdAddress());
	// Inviamo la Query al database
	ResultSet pRs = Utility.queryOperation(connect, sql);
	if (pRs.next())
		result = true;

	return result;

} finally {
	// rilasciamo le risorse
	DBConnection.releaseConnection(connect);

}
}

	public synchronized boolean exists (Address pAddress) throws MandatoryFieldException, ConnectionException, SQLException {
	boolean result= false;
	Connection connect = null;
	
	if (pAddress.getName() == null)
		throw new MandatoryFieldException("Specificare il nome.");
	try{
		//Otteniamo la connessione al database
		connect= DBConnection.getConnection();
		
		if (connect == null)
			throw new ConnectionException();
		
		String sql =" SELECT * FROM "
		+ ManagerAddress.TABLE_ADDRESS 
		+ " WHERE name = "
		+ Utility.isNull(pAddress.getName());
		
		ResultSet tRs = Utility.queryOperation(connect, sql);
		
		if(tRs.next())
			result = true;
		
		return result;
		
	}
	finally{
		DBConnection.releaseConnection(connect);
	}
	}
	/**
	 * Inserisce un nuovo indirizzo nella tabella address.
	 * 
	 * @param pAddress 
	 * 			L'indirizzo da inserire.
	 * 
	 * @throws SQLException
	 * @throws ConnectionException
	 * @throws MandatoryFieldException 
	 * @throws EntityNotFoundException  
	 * @throws InvalidValueException 
	 */
	
	public synchronized void insert(Address pAddress) 
	throws MandatoryFieldException, ConnectionException, 
	SQLException, EntityNotFoundException, 
	InvalidValueException{
	Connection connect= null;
try{
// controllo dei campi obbligatori
if(pAddress.getName()==null)
	throw new MandatoryFieldException("Specificare il campo nome");

	connect = DBConnection.getConnection();
if (connect==null)
	throw new ConnectionException();
	//Prepariamo la stringa Sql
	String sql =
	"INSERT INTO " 
	+ ManagerAddress.TABLE_ADDRESS 
	+ " (name) " 
	+ "VALUES (" 
	+ Utility.isNull(pAddress.getName()) 
	+ ")";

	Utility.executeOperation(connect,sql);

	pAddress.setIdAddress(Utility.getMaxValue("id_address",ManagerAddress.TABLE_ADDRESS));

	}finally {
		//rilascia le risorse

		DBConnection.releaseConnection(connect);
}
}
	/**
	 * Elimina un indirizzo dalla tabella address.
	 * 
	 * @param pAddress 
	 * 			L'indirizzo da eliminare.
	 * 
	 * @throws MandatoryFieldException 
	 * @throws EntityNotFoundException 
	 * @throws SQLException 
	 * @throws ConnectionException 
	 * @throws InvalidValueException 
	 * 
	 */
	public synchronized void delete (Address pAddress) throws ConnectionException, 
			SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException {
		Connection connect = null;

		
		try {
			//ManagerAddress.getInstance().AddressOnDeleteCascade(pAddress);
			connect = DBConnection.getConnection();
				//Prepariamo la stringa SQL
				String sql = "DELETE FROM " 
							+ ManagerAddress.TABLE_ADDRESS 
							+ " WHERE id_address = "
							+ Utility.isNull(pAddress.getIdAddress());
			
				Utility.executeOperation(connect, sql);
		}  
		finally {
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	public synchronized void assignTeachingAsAddress (Address pAddress, Teaching pTeaching) throws ConnectionException, 
	SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException, DuplicatedEntityException {
Connection connect = null;
ManagerAddress managerAddress = ManagerAddress.getInstance();
if(managerAddress.hasTeaching(pTeaching, pAddress))
	throw new DuplicatedEntityException("Questo indirizzo ha gi quest'insegnamento associato");

try {
	//ManagerAddress.getInstance().AddressOnDeleteCascade(pAddress);
	connect = DBConnection.getConnection();
		//Prepariamo la stringa SQL
		String sql = "INSERT INTO " 
					+ ManagerAddress.TABLE_ADDRESS_HAS_TEACHING
					+ " (id_address, id_teaching) "
					+ " VALUES( "
					+ Utility.isNull(pAddress.getIdAddress())
					+ " , "
					+ Utility.isNull(pTeaching.getId())
					+ " )";
	
		Utility.executeOperation(connect, sql);
}  
finally {
	//rilascia le risorse
	DBConnection.releaseConnection(connect);
}
}
	public synchronized void removeTeachingAsAddress (Address pAddress, Teaching pTeaching) throws ConnectionException, 
	SQLException, EntityNotFoundException, MandatoryFieldException, InvalidValueException {
Connection connect = null;
ManagerAddress managerAddress = ManagerAddress.getInstance();
if(!managerAddress.hasTeaching(pTeaching, pAddress))
	throw new EntityNotFoundException("Questo indirizzo non contiene l'insegnamento da rimuovere");

try {
	//ManagerAddress.getInstance().AddressOnDeleteCascade(pAddress);
	connect = DBConnection.getConnection();
		//Prepariamo la stringa SQL
		String sql = "DELETE FROM " 
					+ ManagerAddress.TABLE_ADDRESS_HAS_TEACHING
					+ " WHERE id_address= "
					+ Utility.isNull(pAddress.getIdAddress())		
					+ " AND id_teaching = "
					+ Utility.isNull(pTeaching.getId());
	
		Utility.executeOperation(connect, sql);
}  
finally {
	//rilascia le risorse
	DBConnection.releaseConnection(connect);
}
}

	/**
	 * Ritorna l'id dell'indirizzo passato come parametro.
	 * 
	 * @param pAddress
	 *            L'indirizzo di cui si richiede l'id.
	 * @return Ritorna l'id dell'indirizzo passato come parametro.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized int getAddressId(Address pAddress)
			throws EntityNotFoundException, ConnectionException, SQLException {
		int result = 0;
		Connection connect = null;
		try {
			if (pAddress == null)
				throw new EntityNotFoundException("Impossibile trovare l'indirizzo!");

			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti all'id dell'indirizzo passato come parametro.
			 */
			String tSql = "SELECT id_address FROM " 
				+ ManagerAddress.TABLE_ADDRESS
				+ " WHERE name = " 
				+ Utility.isNull(pAddress.getName());

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);

			if (tRs.next())
				result = tRs.getInt("id_address");

			return result;
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Ritorna l'indirizzo corrispondente all'id passato come parametro.
	 * 
	 * @param pIdAddress
	 * 			L'id dell'indirizzo.
	 * @return Ritorna l'indirizzo associato all'id passato come parametro.
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException 
	 */
	public synchronized Address getAddressById (int pIdAddress) throws ConnectionException, SQLException, EntityNotFoundException, InvalidValueException{
		Address result = null;
		Connection connect = null;
		try
		{
						
			if (pIdAddress <= 0) 
				throw new EntityNotFoundException("Impossibile trovare l'indirizzo!");
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Prepariamo la stringa SQL
			String sql = 
				"SELECT * FROM " 
				+ ManagerAddress.TABLE_ADDRESS
				+ " WHERE id_address = " 
				+ Utility.isNull(pIdAddress);
			
			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);
			
			if (pRs.next()) 
				result = this.loadRecordFromRs(pRs);
			else 
				throw new EntityNotFoundException("Impossibile trovare l'utente!");
							
			return result;
		}finally{
			//rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Ritorna l'insieme di tutti gli indirizzi presenti nel database.
	 * 
	 * @return Ritorna una collection di indirizzi.
	 * 
	 * @throws ConnectionException 
	 * @throws EntityNotFoundException 
	 * @throws SQLException 
	 * @throws InvalidValueException 
	 */
	public synchronized Collection<Address> getAddressList() throws ConnectionException, EntityNotFoundException, SQLException, InvalidValueException{
		Connection connect = null;
		Collection<Address> result = new Vector<Address>();;
		
		try {
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			//Prepariamo la stringa sql
			String sql = "SELECT * "  
				+ " FROM " 
				+ ManagerAddress.TABLE_ADDRESS 
				+ " ORDER BY id_address";
				
			//Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);
			
			if (tRs.next())
				result = this.loadRecordsFromRs(tRs);		
			return result;
		} finally {
			//rilascia le risorse			
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Ritorna il nome dell'indirizzo corrispondente all'id 
	 * passato come parametro.
	 * 
	 * @param pIdAddress
	 * 			L'id dell'indirizzo.
	 * @return Ritorna una stringa contenente il nome dell'indirizzo.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized String getAddressNameById(int pIdAddress) throws EntityNotFoundException, ConnectionException, SQLException{
		String result;
		Connection connect = null;
		try
		{
			// Se non e' stato fornito l'id restituiamo un codice di errore
			if (pIdAddress <= 0)
				throw new EntityNotFoundException("Impossibile trovare l'indirizzo!");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti all'id dell'utente passato come parametro 
			 */
			String tSql = 
				"SELECT name FROM " 
				+ ManagerAddress.TABLE_ADDRESS 
				+ " WHERE id_address = " 
				+ Utility.isNull(pIdAddress) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			if (tRs.next()) 
				result = tRs.getString("name");
			else 
				throw new EntityNotFoundException("Impossibile trovare l'indirizzo!");
			
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}
	
	/**
	 * Ritorna una collection con gli id degli insegnamenti associati all'id 
	 * passato come parametro.
	 * 
	 * @param pIdAddress
	 * 			L'id dell'indirizzo.
	 * @return Ritorna una collection con di int 
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	
	public synchronized Collection<Integer> getAddressTechings(int pIdAddress) throws EntityNotFoundException, ConnectionException, SQLException, InvalidValueException{
		Collection<Integer> result;
		Connection connect = null;
		try
		{
			// Se non e' stato fornito l'id restituiamo un codice di errore
			if (pIdAddress <= 0)
				throw new EntityNotFoundException("Impossibile trovare l'indirizzo!");
			
			
			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti all'id dell'utente passato come parametro 
			 */
			String tSql = 
				"SELECT id_teaching FROM " 
				+ ManagerAddress.TABLE_ADDRESS_HAS_TEACHING
				+ " WHERE id_address = " 
				+ Utility.isNull(pIdAddress) ;
			
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null) 
				throw new ConnectionException();
			
			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);
			
			result = this.loadIntegersFromRs(tRs);
			return result;
		}finally{
			DBConnection.releaseConnection(connect);
		}
	}

	/*
	 * Consente la lettura di un record dal ResultSet.
	 */
	private Address loadRecordFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Address address = new Address();
		address.setName(pRs.getString("name"));
		address.setIdAddress(pRs.getInt("id_address"));
		return address;
	}
	
	/*
	 * Consente la lettura dei record dal ResultSet.
	 */
	private Collection<Address> loadRecordsFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Collection<Address> result = new Vector<Address>();
		do  {
			result.add(loadRecordFromRs(pRs));
		} while (pRs.next());
		return result;
	}
	
	private Collection<Integer> loadIntegersFromRs(ResultSet pRs) throws SQLException, InvalidValueException{
		Collection<Integer> result = new Vector<Integer>();
		while(pRs.next())  {
			result.add(pRs.getInt("id_teaching"));
		} 
		return result;
	}
	
		
	
}

package smos.application.userManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
/**
 * Servlet  che modifica il record dello studente con l'id del padre.
 * 
 * @author Napolitano Vincenzo.
 * 
 */
public class ServletAssignParentStudent extends HttpServlet {

	
	private static final long serialVersionUID = -4507225018030147979L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "showUserList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		

		ManagerUser managerUser = ManagerUser.getInstance();

		User loggedUser = (User) session.getAttribute("loggedUser");
		
		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
			
			User user = (User) session.getAttribute("user");
			int idParent=user.getId();
			
			Collection<UserListItem> students = new Vector<UserListItem>();
			Iterator<UserListItem> itStu = null;
			
			students = managerUser.getStudents();
			
			
			String[] selectedStudent = pRequest.getParameterValues("selectedStudent");
			String[] unselectedStudent = pRequest.getParameterValues("unselectedStudent");
			
			if (selectedStudent != null) {
				int selectedlength = selectedStudent.length;
				UserListItem tmp = null;
				User stu=null;
				int idStudent=0;
				for (int i = 0; i < selectedlength; i++) {
					itStu = students.iterator();
					String dd = selectedStudent[i];
					idStudent=Integer.parseInt(dd);
					while(itStu.hasNext()){
						 tmp = (UserListItem)itStu.next();
						if(tmp.getId()==idStudent){	
							stu=managerUser.getUserById(tmp.getId());//recupero userStudente	
							managerUser.assignParent(stu, idParent);
						}
					}	
				}
				
			} else {
				gotoPage="./error.jsp";
			}
			if (unselectedStudent != null) {
				itStu=null;
				int unselectedlength = unselectedStudent.length;
				UserListItem tmp = null;
				User stu=null;
				int idStudent=0;
				for (int i = 0; i < unselectedlength; i++) {
					itStu = students.iterator();
					String dd = unselectedStudent[i];
					idStudent=Integer.parseInt(dd);
					while(itStu.hasNext()){
						 tmp = (UserListItem)itStu.next();
						if(tmp.getId()==idStudent){	
							stu=managerUser.getUserById(tmp.getId());//recupero userStudente	
							managerUser.removeParent(stu);
						}
					}
				}
			}
			
			
			session.setAttribute("user", user);
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}  catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} 
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.application.reportManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletShowClassroomByAcademicYear extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8468821050771730936L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./reportsManagement/showClassroomByAcademicYear.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Classroom> classroomList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}

			// prendere l'academic year dalla session
			int anno = Integer.valueOf(pRequest.getParameter("academicYear"));
			if (anno != 0){
				classroomList = managerClassroom
						.getClassroomsByAcademicYear(anno);
			}

			session.setAttribute("classroomList", classroomList);
			session.setAttribute("selectedYear", anno);
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.bean;

import java.io.Serializable;
import java.util.Date;

public class Delay implements Serializable {

	/**
	 * Classe che modella un entrata in ritardo di uno studente
	 * @author Nicola Pisanti
	 * @version 1.0 
	 */
	private static final long serialVersionUID = 78680884161960621L;

	private int idDelay;
	private int idUser;
	private Date dateDelay;
	private String timeDelay;
	private int academicYear;
	
	
	/**
	 * Metodo che restituisce l'id del Ritardo 
	 * @return un intero che rappresenta l'id del ritardo 
	 */
	public int getIdDelay() {
		return idDelay;
	}
	/**
	 * Metodo che setta l'id del Ritardo 
	 * @param intero che rappresenta l'id da settare
	 */
	public void setIdDelay(int pIdDelay) {
		this.idDelay = pIdDelay;
	}
	/**
	 * Metodo che restituisce l'id dello studente ritardatario 
	 * @return un intero che rappresenta l'id dello studente
	 */
	public int getIdUser() {
		return idUser;
	}
	/**
	 * Metodo che setta l'id dello studente relativo al ritardo 
	 * @param un intero che rappresenta l'id da settare
	 */
	public void setIdUser(int pIdUser) {
		this.idUser = pIdUser;
	}
	/**
	 * Metodo che restituisce la data del ritardo 
	 * @return una stringa che rappresenta la data del ritardo 
	 */
	public Date getDateDelay() {
		return dateDelay;
	}
	/**
	 * Metodo che setta la data del ritardo
	 * @param una stringa che rappresenta la data del ritardo
	 */
	public void setDateDelay(Date pDateDelay) {
		this.dateDelay = pDateDelay;
	}
	/**
	 * Metodo che restituisce l'ora d'entrata dello studente
	 * @return una stringa che rappresenta l'ora di entrata dello studente ritardatario
	 */
	public String getTimeDelay() {
		if (this.timeDelay.length() > 0){
			return timeDelay.substring(0, 5);
		} else {
			return this.timeDelay;
		}
	}
	/**
	 * Metodo che setta l'ora di entrata dello studente 
	 * @param una stringa che rappresenta l'ora di entrata da settare
	 */
	public void setTimeDelay(String pTimeDelay) {
		this.timeDelay = pTimeDelay;
	}
	/**
	 * Metodo che restituisce l'anno accademico relativo all'assenza
	 * @return un intero che rappresenta l'anno in cui è iniziato l'anno accademico 
	 */
	public int getAcademicYear() {
		return academicYear;
	}
	/**
	 * Metodo che setta l'anno accademico relativo all'assenza
	 * @param un intero che rappresenta l'anno accademico da settare
	 */
	public void setAcademicYear(int pAcademicYear) {
		this.academicYear = pAcademicYear;
	}
}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletShowClassroomManagement extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3100959843623661377L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showClassroomList.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Classroom> classroomList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom= ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
			
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			
			//prendere l'academic year dalla session
			
			classroomList = managerClassroom.getClassroomsByAcademicYear(Integer.valueOf(pRequest.getParameter("academicYear")));
			
					
			session.setAttribute("classroomList", classroomList);
			pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione generata quando un'entita'
  * non viene trovata nel database.
  */
public class EntityNotFoundException extends Exception {
	
	private static final long serialVersionUID = -1236105333523133721L;

	/**
	 * Genera l'eccezione senza un messagio di errore associato.
	 */
	public EntityNotFoundException() {
		super("Object Not Found in Repository!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public EntityNotFoundException(String pMessage) {
		super(pMessage);
	}
	
	
}
package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.LoginException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per inserire un utente nel DataBase.
 * 
 * @author napolitano Vincenzo.
 *
 */
public class ServletInsertUser extends HttpServlet {

	private static final long serialVersionUID = -3860569607870099419L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	public void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./showUserList";
		String errorMessage = "";
		
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
		
			User user = new User();
			user.setFirstName(pRequest.getParameter("firstName"));
			user.setLastName(pRequest.getParameter("lastName"));
			user.setCell(pRequest.getParameter("cell"));
			user.setEMail(pRequest.getParameter("eMail"));
			
			/*
			 * verifichiamo che la login sia unica.
			 */
			String login = pRequest.getParameter("login");
			user.setLogin(login);
			
			if (managerUser.existsLogin(user)) 
				throw new InvalidValueException("La login inserita esiste gia'. Inserire una nuova login.");
			
			if (pRequest.getParameter("password").equals(pRequest.getParameter("password1"))){
						user.setPassword((pRequest.getParameter("password")));
			}
			else{
				throw new LoginException("I valori inseriti per la password non coincidono!");
			}
			//inserimento utente
			if (!managerUser.exists(user)){
				managerUser.insert(user);
				session.setAttribute("user", user);
			
				
			}else 
				throw new DuplicatedEntityException("Utente gia' esistente");
			
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (LoginException loginException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + loginException.getMessage();
			gotoPage = "./error.jsp";
			loginException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
				+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.bean;

import java.io.Serializable;

/**
 * Classe utilizzata per modellare le informazioni principali 
 * di un utente.
 */
public class UserListItem implements Serializable{

	private static final long serialVersionUID = 3436931564172045464L;

	private String name;
	private String eMail;
	private int id;
	
	
	
	/**
	 * @return Ritorna l'id dell'utente.
	 */
	public int getId() {
		return this.id;
	}
	
	/**
	 * Setta l'id dell'utente.
	 * @param pId
	 * 			L'id da settare.
	 */
	public void setId(int pId) {
		this.id = pId;
	}
	
	/**
	 * @return Ritorna il nome dell'utente.
	 */
	public String getName() {
		return this.name;
	}
	
	/**
	 * Setta il nome dell'utente.
	 * @param pName
	 * 			Il nome da settare.
	 */
	public void setName(String pName) {
		this.name = pName;
	}
	

	/**
	 * @return the eMail
	 */
	public String getEMail() {
		return this.eMail;
	}

	/**
	 * @param mail the eMail to set
	 */
	public void setEMail(String pMail) {
		this.eMail = pMail;
	}
}

package smos.application.reportManagement;


import smos.Environment;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.ManagerVotes;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli insegnamenti.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletShowReports extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1361713427864776624L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./reportsManagement/showReports.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Votes> votesList = null;
		ManagerVotes managerVotes = ManagerVotes.getInstance();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla funzionalita'!";
				gotoPage = "./error.jsp";
			}
			int studentId = Integer.valueOf(pRequest.getParameter("student"));
			Integer year=(Integer) session.getAttribute("selectedYear");
			Integer turn=Integer.valueOf(pRequest.getParameter("q"));
			session.setAttribute("q", turn);
			votesList = managerVotes.getVotesByUserIdYearTurn(studentId,year,turn);
			User u = (User) managerUser.getUserById(studentId);
			UserListItem st=new UserListItem();
			st.setName(u.getName());
			st.setEMail(u.getEMail());
			st.setId(u.getId());
			session.setAttribute("std", st);
			session.setAttribute("votesList", votesList);
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}



package smos.application.userManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
/**
 * Servlet di modifica Password dell'utente loggato.
 * 
 * @author Napolitano Vincenzo.
 * 
 */
public class ServletAlterPersonalDate extends HttpServlet {

	private static final long serialVersionUID = 1L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "showUserList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User user = (User) session.getAttribute("loggedUser");
		
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
	
			//verifichiamo che la login sia unica.
			if (managerUser.existsLogin(user))
				throw new InvalidValueException("La login inserita esiste gia'. Inserire una nuova login.");
			user.setPassword(pRequest.getParameter("pass"));
			//aggiorniamo
			if (!managerUser.exists(user)){
				managerUser.update(user);
			}else {
				int userId = managerUser.getUserId(user);
				if (user.getId()==userId)
					managerUser.update(user);
				else 
					throw new DuplicatedEntityException("Utente gi esistente");
			}
			
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}  catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
			
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	
}


package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Justify;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletUpdateJustify extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8405877983387271542L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showRegister.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerRegister mR= ManagerRegister.getInstance();
		Justify justify = (Justify) session.getAttribute("justify");
		User loggedUser = (User) session.getAttribute("loggedUser");
		String idClassroom=(String) session.getAttribute("idClassroom");
		int id= Integer.parseInt(idClassroom);
		gotoPage+="?idClassroom="+id;
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
			
			justify.setAcademicYear(Integer.parseInt((pRequest.getParameter("academicYear"))));
			justify.setDateJustify(Utility.String2Date(pRequest.getParameter("date")));
			
			
			/*
			 * verifichiamo che la giustifica esista.
			 */
		
			if (!mR.exists(justify)){
				errorMessage="la giustifica non esiste!!";
				gotoPage = "./error.jsp";
				
			}else {//aggiorniamo
				mR.updateJustify(justify);
			}
			
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}  catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
			
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.teachingManagement;

import smos.Environment;
import smos.bean.*;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per inserire un insegnamento nel DataBase.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletInsertTeaching extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4519458598257606331L;

	/**
	 * 
	 */

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	public void doGet(HttpServletRequest pRequest, HttpServletResponse pResponse) {
		String gotoPage = "./teachingList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		// String isWizard = "yes";

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}

			Teaching teaching = new Teaching();
			teaching.setName(pRequest.getParameter("name"));

			if (!managerTeaching.exists(teaching)) {
				managerTeaching.insert(teaching);
				session.setAttribute("teaching", teaching);
				// session.setAttribute("isWizard", isWizard);

			} else
				throw new DuplicatedEntityException(
						"Insegnamento gia' esistente");

		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.reportManagement;

import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import smos.Environment;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.ManagerVotes;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletDeleteReport extends HttpServlet {

	/**
	 * Servlet utilizzata per visualizzare gli alunni associati ad una Classe.
	 * 
	 * @author Giulio D'Amora
	 * 
	 */

	/**
	 * 
	 */
	private static final long serialVersionUID = 2020233250419553067L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./reportsManagement/showStudentsByClass.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerVotes managerVotes = ManagerVotes.getInstance();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		int year= 0;
		int turn=0;
		int studentId=0;
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error2.jsp";
			}
			UserListItem student = (UserListItem) (session.getAttribute("student"));
			studentId = student.getId();
			year=(Integer) session.getAttribute("selectedYear");
			turn=(Integer) session.getAttribute("q");
			managerVotes.deleteVotesByUserIdYearTurn(studentId, year, turn);
			pResponse.sendRedirect(gotoPage);
			

		} catch (NumberFormatException numberFormatException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ numberFormatException.getMessage();
			gotoPage = "./error1.jsp?Year="+year+"&turn="+turn+"&idStudent="+studentId;
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error3.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error4.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error5.jsp?Year="+year+"&turn="+turn+"&idStudent="+studentId;
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}


package smos.application.reportManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.ManagerVotes;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per aggiornare la pagella di uno studente.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletUpdateReport extends HttpServlet {

	private static final long serialVersionUID = -1045906657573424217L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./showReports";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Teaching> teachingList = null;
		ManagerVotes managerVotes = ManagerVotes.getInstance();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla funzionalita'!";
				gotoPage = "./error.jsp";
			}
			Classroom classroom = (Classroom) session.getAttribute("classroom");
			// Lista teaching
			teachingList = managerTeaching.getTeachingsByClassroomId(classroom
					.getIdAddress());
			Iterator<Teaching> itTeaching = teachingList.iterator();
			Integer year = (Integer) session.getAttribute("selectedYear");
			UserListItem student = (UserListItem) session
					.getAttribute("student");
			// Quadrimestre
			int turn = (Integer) session.getAttribute("q");
			Teaching teachingTemp = null;
			int idTemp;
			String write, oral, lab;
			gotoPage += "?student=" + student.getId() + "&q=" + turn;
			while (itTeaching.hasNext()) {
				teachingTemp = itTeaching.next();
				idTemp = teachingTemp.getId();
				write = "scritto_" + idTemp;
				oral = "orale_" + idTemp;
				lab = "laboratorio_" + idTemp;
				write = pRequest.getParameter(write);
				oral = pRequest.getParameter(oral);
				lab = pRequest.getParameter(lab);
				Votes newVotes = new Votes();
				// SE il voto non esiste dobbiamo crearlo
				int idVoto = managerVotes.getIdVotes(teachingTemp, year, turn,
						student);
				int writeInt=0, oralInt=0,labInt=0;
				if(write!="")
					writeInt = Integer.valueOf(write);
				if(oral!="")
					oralInt = Integer.valueOf(oral);
				if(lab!="")
					labInt = Integer.valueOf(lab);
				if (idVoto <= 0) {
					if (writeInt != 0 || oralInt != 0 || labInt != 0) {
						newVotes.setAccademicYear(year);
						newVotes.setId_user(student.getId());
						newVotes.setLaboratory(labInt);
						newVotes.setOral(oralInt);
						newVotes.setTeaching(idTemp);
						newVotes.setTurn(turn);
						newVotes.setWritten(writeInt);
						managerVotes.insert(newVotes);
					}
				}
				// Se il voto esiste dobbiamo aggiornarlo
				else {
					if (writeInt != 0 || oralInt != 0 || labInt != 0) {
						newVotes = managerVotes.getVotesById(idVoto);
						newVotes.setLaboratory(labInt);
						newVotes.setOral(oralInt);
						newVotes.setWritten(writeInt);
						managerVotes.update(newVotes);
					}
					else
						managerVotes.delete(managerVotes.getVotesById(idVoto));
				}
			}

			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (MandatoryFieldException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Date;
import java.util.Vector;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletComputateStatistics extends HttpServlet {

	private static final long serialVersionUID = 6690162445433486239L;
	
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	@SuppressWarnings("deprecation")
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./statisticsManagement/showStatistictsByAcademicYear.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Integer academicYear = Integer.valueOf(pRequest.getParameter("academicYear"));
		Integer absenceLimit = Integer.valueOf(pRequest.getParameter("absenceLimit"));
		Integer noteLimit = Integer.valueOf(pRequest.getParameter("noteLimit"));
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		Collection <User> alertStudentAbsence = new Vector<User>();
		
		Date today = new Date();
		
		
		
		int [][] unjustifiedAbsence = null;
		
		Collection <User> alertStudentNote = new Vector<User>();
		
		int [][] note = null;
		
		User tmpUser = null;
		
		try {
		
		if (loggedUser == null) {
			pResponse.sendRedirect("./index.htm");
			return;
		}
		if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
			errorMessage = "L'Utente collegato non ha accesso alla "
					+ "funzionalita'!";
			gotoPage = "./error.jsp";
		}
		
		
			
		if (academicYear == 0){
			academicYear = today.getYear() + 1900;
		}
		
		Collection <Integer> academicYearList = ManagerClassroom.getInstance().getAcademicYearList();
		
		unjustifiedAbsence = managerUser.getHighlightsStudentAbsence(academicYear);
		
		if (unjustifiedAbsence != null){
			for (int i=0; i< unjustifiedAbsence.length; i++){
					if (unjustifiedAbsence[i][0] >= absenceLimit){
						tmpUser = managerUser.getUserById(unjustifiedAbsence[i][1]);
						alertStudentAbsence.add(tmpUser);
					}
			}
		}
		
		note = managerUser.getHighlightsStudentNote(academicYear);
		
		if (note != null){
			for (int i=0; i< note.length; i++){
					if (note[i][0] >= noteLimit){
						
							tmpUser = managerUser.getUserById(note[i][1]);
						
						alertStudentNote.add(tmpUser);
					}
			}
		}
		
		
		session.setAttribute("alertStudentAbsence", alertStudentAbsence);
		session.setAttribute("alertStudentNote", alertStudentNote);
		session.setAttribute("academicYearList", academicYearList);
		session.setAttribute("absenceLimit", absenceLimit);
		session.setAttribute("noteLimit", noteLimit);
		session.setAttribute("yearSelected", academicYear);
		
			
		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.reportManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.ManagerVotes;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per caricare la Pagella di uno studente.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletLoadReport extends HttpServlet {

	private static final long serialVersionUID = -1045906657573424217L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./reportsManagement/updateReport.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Votes> votesList = null;
		Collection<Teaching> teachingList = null;
		ManagerVotes managerVotes = ManagerVotes.getInstance();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla funzionalita'!";
				gotoPage = "./error.jsp";
			}
			Classroom classroom = (Classroom) session.getAttribute("classroom");
			// Lista teaching
			teachingList = managerTeaching.getTeachingsByClassroomId(classroom
					.getIdAddress());
			Integer year = (Integer) session.getAttribute("selectedYear");
			// Quadrimestre
			int turn = (Integer) session.getAttribute("q");

			UserListItem student = (UserListItem) session
					.getAttribute("student");
			// Lista Voti
			votesList = managerVotes.getVotesByUserIdYearTurn(student.getId(),
					year, turn);
			session.setAttribute("teachingList", teachingList);
			session.setAttribute("votesList", votesList);
			// provare i dati
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per assegnare Insegnamenti ad un docente
 * 
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletAddTeachingAsTeacher extends HttpServlet {



	/**
	 * 
	 */
	private static final long serialVersionUID = 4931185354259866391L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/teacherTeachings.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();

		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		ManagerClassroom managerClass = ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
					+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			// //Mi servono i 3 Id user class teachings(che non so quanti ne sono)
			int idTeacher = (int) ((User) session.getAttribute("user")).getId();
			User teacher = managerUser.getUserById(idTeacher); 
			int idClass = Integer.valueOf(pRequest.getParameter("classId"));
			String[] idTeachingList = pRequest.getParameterValues("selectedTeachings");
			int nTeaching =idTeachingList.length;
			int temp;
			//Collection<Teaching> listSelcected = new Vector<Teaching>();
			if(idTeachingList==null)
				gotoPage = "./error.jsp";
			else{
				for(int i=0;i<nTeaching;i++){
					temp = Integer.valueOf(idTeachingList[i]);
					if(!managerUser.hasTeaching(teacher,managerTeaching.getTeachingById(temp),managerClass.getClassroomByID(idClass))){
						managerUser.assignTeacherAtClassroomTeaching(teacher,idClass,temp);
						//listSelcected.add(managerTeaching.getTeachingById(temp));
					}
				}
			}
			//session.setAttribute("teachingListTeacher", listSelcected);
		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

	package smos.bean;

import smos.exception.InvalidValueException;

import java.io.Serializable;

/**
 *  Classe utilizzata per modellare un utente.
 *
 * 
 */
public class User implements Serializable{
	

	private static final long serialVersionUID = 7272532316912745508L;
	
	
	private int id;
	private String login;
	private String password;
	private String firstName;
	private String lastName;
	private int idParent;
	private String cell;
	private String eMail;
	
	/**
	 * Il costruttore della classe.
	 */
	public User(){
		this.id = 0 ;
	}
	
	
	/**
	 * @return Ritorna la login dell'utente.
	 */
	public String getLogin() {
		return this.login;
	}
	
	/**
	 * Setta la login dell'utente.
	 * @param pLogin
	 * 			La login da settare.
	 * 
	 * @throws InvalidValueException 
	 */
	public void setLogin(String pLogin) throws InvalidValueException {
		if(pLogin.length()<=4)
			throw new InvalidValueException();
		else
			this.login = pLogin;
	}
	
	/**
	 * @return Ritorna il nome dell'utente.
	 */
	public String getName() {
		return this.lastName + " " + this.firstName;
	}
	
	/**
	 * @return Ritorna il nome dell'utente.
	 */
	public String getFirstName() {
		return this.firstName;
	}
	
	/**
	 * Setta il nome dell'utente.
	 * @param pFirstName
	 * 			Il nome da settare.
	 */
	public void setFirstName(String pFirstName) {
		this.firstName = pFirstName;
	}
	
	
	/**
	 * @return Ritorna la password dell'utente.
	 */
	public String getPassword() {
		return this.password;
	}
	
	/**
	 * Setta la password dell'utente.
	 * @param pPassword
	 * 			La password da settare.
	 * 
	 * @throws InvalidValueException 
	 */
	public void setPassword(String pPassword) throws InvalidValueException {
		if(pPassword.length()<=4)
			throw new InvalidValueException();
		else
		this.password = pPassword;
	}
	
	/**
	 * @return Ritorna il cognome dell'utente.
	 */
	public String getLastName() {
		return this.lastName;
	}
	
	/**
	 * Setta il cognome dell'utente.
	 * @param pLastName
	 * 			Il cognome da settare.
	 */
	public void setLastName(String pLastName) {
		this.lastName = pLastName;
	}
	
	/**
	 * @return Ritorna l'id dell'utente.
	 */
	public int getId() {
		return this.id;
	}
	
	/**
	 * Setta l'id dell'utente.
	 * @param pId
	 * 			L'id da settare.
	 */
	public void setId(int pId) {
		this.id = pId;
	}
	
	/**
	 * Ritorna una stringa contenente nome e cognome dell'utente.
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return this.getFirstName() 
		+ " " 
		+ this.getLastName();
	}
	
	/**
	 * @return the eMail
	 */
	public String getEMail() {
		return this.eMail;
	}
	/**
	 * @param pMail the eMail to set
	 */
	public void setEMail(String pMail) {
		this.eMail = pMail;
	}


	/**
	 * @return the cell
	 */
	public String getCell() {
		return this.cell;
	}


	/**
	 * @param cell the cell to set
	 */
	public void setCell(String pCell) {
		this.cell = pCell;
	}


	/**
	 * @return the idParent
	 */
	public int getIdParent() {
		return this.idParent;
	}


	/**
	 * @param idParent the idParent to set
	 */
	public void setIdParent(int pIdParent) {
		this.idParent = pIdParent;
	}
	
}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Absence;
import smos.bean.Justify;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletInsertJustify extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1252760418542867296L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	public void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showClassroomList.jsp";
		String errorMessage = "";
		
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
		ManagerRegister mR= ManagerRegister.getInstance();
			Justify justify=new Justify();
			justify.setAcademicYear(Integer.parseInt(pRequest.getParameter("academicYear")));
			
			justify.setDateJustify(Utility.String2Date(pRequest.getParameter("date")));
			
			justify.setIdUser(Integer.parseInt(pRequest.getParameter("idUser")));
			String idA= pRequest.getParameter("idAbsence");
			int idAbsence=Integer.parseInt(idA);
			
			//String idC = pRequest.getParameter("idClassroom");
			//int idClassroom= Integer.parseInt(idC);
			
			//gotoPage+=idClassroom;
			Absence absence = mR.getAbsenceByIdAbsence(idAbsence);
			
			if(!mR.exists(absence)){
				errorMessage =  "assenza non prensente nel db!";	
					gotoPage = "./error.jsp";
			}
			
			//inserimento giustifica
			
			if(!mR.exists(justify)){
				mR.insertJustify(justify, absence);
				session.setAttribute("justify", justify);
				
			}else 
				throw new DuplicatedEntityException("Giustifica gia' esistente");
			
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
				+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}


}

package smos.storage.connectionManagement;


import java.sql.*;

/**
 * Implementazione del thread in grado di mantenere la connessione al database
 * Mysql qualora non vi siano pi connessioni attive (risoluzione del problema
 * dell'autoreconnect di Mysql). Tale classe si occupa anche di richimare il
 * metodo di rilascio delle connessioni attive che non hanno eseguito operazioni
 * in un certo intervallo di tempo.
 */

public class ControlConnection extends Thread {
    private static ConnectionPoolDataSource manager = null;

    private static int waitTimeout;

    /**
     * Crea una nuova istanza del Thread.
     * 
     * @author Di Giorgio Domenico, Cris Malinconico
     * @param pManager
     *            il pool delle connessioni attulamente in esecuzione.
     */

    public ControlConnection(ConnectionPoolDataSource pManager) {
        ControlConnection.manager = pManager;
    }

    /**
     * Crea una nuova istanza del Thread.
     * 
     * @param pManager
     *            il pool delle connessioni attulamente in esecuzione.
     * @param pTime
     *            Il tempo entro cui ristabilire la connessione con mysql prima
     *            che scada.Tale valore dovr essere necessariamente minore del
     *            valore della variabile globale wait_timeout di Mysql.
     */

    public ControlConnection(ConnectionPoolDataSource pManager, int pTime) {
        ControlConnection.waitTimeout = pTime;
        ControlConnection.manager = pManager;
    }

    /**
     * Il thread non fa altro che dormire quando ci sono utenti attivi e
     * mantenere aperta la connessione con MySQL altrimenti.
     * 
     */

    public void run() {
        try {
            while (true) {
                if (manager.activeSize() > 0) {
                    this.setPriority(Thread.MAX_PRIORITY);
                    manager.clearActive();
                    this.setPriority(Thread.NORM_PRIORITY);
                }
                if (manager.activeSize() == 0) {
                    while (true) {
                        try {
                            manager.closeAllPooledConnections();
                            Connection con = null;
                            con = manager.getConnection();
                            Statement st = con.createStatement();
                            st.executeQuery("show tables");
                            manager.release(con);
                            break;
                        } catch (Exception e) {
                            System.out.println("Eccezione geneata "
                                    + "nel Thread ControlConnection:" + e);
                        }
                    }
                    Thread.sleep(waitTimeout);
                } else {
                    Thread.sleep(waitTimeout);
                }
            }
        } catch (InterruptedException ex) {
            System.out.println("Thread ControlConnection interrotto:" + ex);
        }
    }
}

/*
 * DBConnection
 *
 */

package smos.storage.connectionManagement;

import smos.Environment;
import smos.utility.Utility;

import java.sql.*;
import java.util.*;
import java.io.*;


/**
 * Classe che s'interfaccia con il pool di connessioni. In particolare crea un
 * unico oggetto ConnectionPoolDataSource (il pool di connessioni) ed ottiene i
 * suoi parametri di configurazione dal file di properties
 * connection.properties.
 */

public class DBConnection {

    private static int ACTIVE_TIMEOUT;

    private static String DRIVER_MYSQL = "";

    private static String FULL_PATH_DATABASE = "";

    private static ControlConnection linker = null;

    private static ConnectionPoolDataSource manager = null;

    private static int MAX_POOL_SIZE;

    private static String PASSWORD = "";

    private static int POOL_TIMEOUT;

    private static Properties properties = null;

    private static String USER_NAME = "";

    private static int WAIT_TIMEOUT;

    
   
    
    
    /**
     * Blocco d'inizializzazione statico che si occupa di generare il pool nel
     * momento in cui ci sar una prima invocazione del metodo getConnection()
     */

    static {
        try {
            properties = new Properties();
            File fileProp = new File(Environment.getPoolPropertiesPath());

            if (fileProp.exists()) {
                properties.load(new FileInputStream(fileProp));

                DRIVER_MYSQL = properties.getProperty("connection.jdbc.name");
                if (DRIVER_MYSQL.equals("")) {
                    DRIVER_MYSQL = Utility.getDriverMySql();
                }

                FULL_PATH_DATABASE = properties
                        .getProperty("connection.jdbc.fullPath");

                if (FULL_PATH_DATABASE.equals("")) {
                    FULL_PATH_DATABASE = Utility.getFullPathDatabase();
                }

                USER_NAME = properties.getProperty("connection.username");
                if (USER_NAME.equals("")) {
                    USER_NAME = Utility.getUserName();
                }

                PASSWORD = properties.getProperty("connection.password");
                if (PASSWORD.equals("")) {
                    PASSWORD = Utility.getPassword();
                }

                try {
                    MAX_POOL_SIZE = Integer.parseInt(properties
                            .getProperty("connection.maxPoolSize"));
                } catch (Exception ex) {
                    MAX_POOL_SIZE = Utility.getMaxPoolSize();
                }

                try {
                    WAIT_TIMEOUT = Integer.parseInt(properties
                            .getProperty("connection.waitTimeout"));
                } catch (Exception ex) {
                    WAIT_TIMEOUT = Utility.getWaitTimeout();
                }

                try {
                    ACTIVE_TIMEOUT = Integer.parseInt(properties
                            .getProperty("connection.activeTimeout"));
                } catch (Exception ex) {
                    ACTIVE_TIMEOUT = Utility.getActiveTimeout();
                }

                try {
                    POOL_TIMEOUT = Integer.parseInt(properties
                            .getProperty("connection.poolTimeout"));
                } catch (Exception ex) {
                    POOL_TIMEOUT = Utility.getPoolTimeout();
                }
            } else {
                /* Se il file di properties non esiste carica valori di default */

                DRIVER_MYSQL = Utility.getDriverMySql();
                FULL_PATH_DATABASE = Utility.getFullPathDatabase();
                USER_NAME = Utility.getUserName();
                PASSWORD = Utility.getPassword();
                MAX_POOL_SIZE = Utility.getMaxPoolSize();
                WAIT_TIMEOUT = Utility.getWaitTimeout();
                ACTIVE_TIMEOUT = Utility.getActiveTimeout();
                POOL_TIMEOUT = Utility.getPoolTimeout();
            }

            loadPool(); // Crea il manager e prepara il pool di connessioni

        } catch (Exception e) {
            /* Se un'eccezione viene generata in precedenza */

        	DRIVER_MYSQL = Utility.getDriverMySql();
            FULL_PATH_DATABASE = Utility.getFullPathDatabase();
            USER_NAME = Utility.getUserName();
            PASSWORD = Utility.getPassword();
            MAX_POOL_SIZE = 100;
            WAIT_TIMEOUT = 2000;
            ACTIVE_TIMEOUT = 240000;
            POOL_TIMEOUT = 300000;
            loadPool(); // Crea il manager e prepara il pool di connessioni
        }

    }

    /**
     * Restituisce una connessione dal pool.
     * 
     * @return la connessione se possibile null altrimenti
     */

    public static Connection getConnection() {
        try {
            return manager.getConnection();
        } catch (SQLException e) {
            System.out.println("Eccezione generata"
                    + "in DBConnection.getConnection() " + e);
            return null;
        }
    }

    /**
     * Creazione effettiva del pool di connessione.
     * 
     */
    private static void loadPool() {
        try {
            manager = new ConnectionPoolDataSource(DRIVER_MYSQL,
                    FULL_PATH_DATABASE, USER_NAME, PASSWORD, MAX_POOL_SIZE,
                    POOL_TIMEOUT);
            manager.setActivedTimeout(ACTIVE_TIMEOUT);
            linker = new ControlConnection(manager, WAIT_TIMEOUT);
            linker.start();
        } catch (Exception e) {
            System.out.println("Impossibile creare il pool"
                    + "di connessioni in DBConnection:" + e);
        }
    }

    /**
     * Restituisce una connessione al pool che sar inserita nella lista delle
     * connesioni pool, ossia quelle riutilizzabili in seguito.
     * 
     * @param pConnection
     *            la connessione non pi attiva.
     */

    public static void releaseConnection(Connection pConnection) {
        manager.release(pConnection);
    }

}

package smos.application.addressManagement;

import smos.Environment;
import smos.bean.Address;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerAddress;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per assegnare Insegnamenti ad un docente
 * 
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletAddRemoveTeachingsAsAddress extends HttpServlet {



	
	/**
	 * 
	 */
	private static final long serialVersionUID = -6692711286746163446L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./showAddressList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		ManagerAddress managerAddress = ManagerAddress.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
					+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			// //Mi servono l'id dell'address e le due liste di insegnamenti!
			Address address = (Address) session.getAttribute("address"); 
			String[] idSelectedList = pRequest.getParameterValues("selectedTeachings");
			String[] idUnselectedList = pRequest.getParameterValues("unselectedTeachings");
			int nSelected =idSelectedList.length;
			int nUnselected =idUnselectedList.length;
			int temp;
			//Aggiungiamo gli insegnamenti selezionati!!
				for(int i=0;i<nSelected;i++){
					temp = Integer.valueOf(idSelectedList[i]);
					if(!managerAddress.hasTeaching(managerTeaching.getTeachingById(temp), address)){
						managerAddress.assignTeachingAsAddress(address, managerTeaching.getTeachingById(temp));
					}
				}
			//Rimuoviamo gli insegnamenti non selezionati
				for(int i=0;i<nUnselected;i++){
					temp = Integer.valueOf(idUnselectedList[i]);
					if(managerAddress.hasTeaching(managerTeaching.getTeachingById(temp), address)){
						managerAddress.removeTeachingAsAddress(address, managerTeaching.getTeachingById(temp));
					}
				}
			//session.setAttribute("teachingListTeacher", listSelcected);
		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MandatoryFieldException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (DuplicatedEntityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.LoginException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per effettuare il login dell'utente.
 * 
 * @author Napolitano Vincenzo.
 */
public class ServletLogin extends HttpServlet {

	private static final long serialVersionUID = 1L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,HttpServletResponse pResponse) {
		String gotoPage = "";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();		
		
		// Ottengo i dati dalla request
		String login = pRequest.getParameter("user");
		String password = pRequest.getParameter("password");
		
		// Login dell'utente
		try {
			
			ManagerUser managerUser = ManagerUser.getInstance();
			
			if(managerUser.getUserByLogin(login) != null){
			
				User loggedUser = managerUser.login(login, password);
				if (loggedUser != null)
					session.setAttribute("loggedUser", loggedUser);
				else throw new LoginException("Nome Utente e/o Password errati!");
				
				if (managerUser.isAdministrator(loggedUser) ){
					gotoPage="./homePage/homeAdmin.jsp";
				}else if (managerUser.isTeacher(loggedUser) ){ 
					gotoPage="./homePage/homeProfessor.jsp";
				}else if (managerUser.isStudent(loggedUser) ){ 
					gotoPage="./homePage/homeStudent.jsp";
				}else if (managerUser.isParent(loggedUser) ){ 
					gotoPage="./homePage/homeParent.jsp";
				}else if (managerUser.isAtaPeople(loggedUser) ){ 
					gotoPage="./homePage/homeAtaPeople.jsp";
				}else if (managerUser.isDirector(loggedUser) ){ 
					gotoPage="./homePage/homeDirector.jsp";
				}
				
			}
			
		} catch (LoginException loginException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + loginException.getMessage();
			gotoPage = "./error.jsp";
			loginException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} 
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Note;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletDeleteNote extends HttpServlet {

	
	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -7968126163648714515L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		//instanziare gli oggetti qua
		
		ManagerRegister managerRegister = ManagerRegister.getInstance(); 
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			//settare le cose da passare alla session, usare session.setAttribute(String, attribute) 
			
			
			gotoPage="./showNoteList?student="+session.getAttribute("idStudent");
			
			Note toDelete= (Note) session.getAttribute("note");
				
			managerRegister.deleteNote(toDelete);
				
			pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} 
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.application.classroomManagement;

import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletDeleteClassroom extends HttpServlet {

	/**
	 *  Servlet per cancellare una classe
	 *  
	 *  @author Nicola Pisanti
	 *  @version 0.9
	 */
	private static final long serialVersionUID = 5272269413504847511L;

	
	
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		
		int  aC=0;
		String gotoPage = "./showClassroomList?academicYear="+aC;
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		User loggedUser = (User) session.getAttribute("loggedUser");
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom= ManagerClassroom.getInstance();
		
		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
		
			Classroom classroom = (Classroom) session.getAttribute("classroom");
			aC=Integer.valueOf(classroom.getAcademicYear());
			managerClassroom.delete(classroom);
			gotoPage = "./showClassroomList?academicYear="+aC;
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} /*catch (DeleteManagerException deleteManagerException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + deleteManagerException.getMessage();
			gotoPage = "./error.jsp";
			deleteManagerException.printStackTrace();
		} */catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.application.teachingManagement;

import javax.servlet.http.HttpServlet;

public class ServletProva extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -832177625776300783L;

}

package smos.bean;
import java.io.Serializable;

/**
 *  Classe utilizzata per modellare un indirizzo.
 *
 * 
 */
public class Address implements Serializable{
	
	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -9194626030239503689L;
	
	private int idAddress;
	private String name;
	
	/**
	 * Il costruttore della classe.
	 */
		public Address(){
		this.idAddress= 0;
	}
		
	/**
	 * @return Ritorna l' id dell' indirizzo.
	 */
		
	public int getIdAddress() {
		return idAddress;
	}
	
	/**
	 * Setta l' id dell' indirizzo.
	 * @param pIdAddress
	 * 			l' id da settare.
	 */
	public void setIdAddress(int pIdAddress) {
		this.idAddress = pIdAddress;
	}
	
	/**
	 * @return Ritorna il nome dell' indirizzo.
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * Setta il nome dell' indirizzo.
	 * @param pName
	 * 			Il nome da settare.
	 */
	public void setName(String pName) {
		this.name = pName;
	}
	
	
}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare il form di gestione
 * dei ruoli degli utenti.
 * 
 * @author Napolitano Vincenzo.
 *
 */
public class ServletShowUserRoleForm extends HttpServlet {

	private static final long serialVersionUID = -2210761175435137331L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/userRolez.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		
		
		
		boolean isTeacherBoolean = false;
		boolean isAdministratorBoolean = false;
		boolean isParentBoolean = false;
		boolean isStudentBoolean = false;
		boolean isAtaBoolean = false;
		boolean isDirectorBoolean = false;
		
		int isTeacher = 0;
		int isAdministrator = 0;
		int isDirector = 0;
		int isParent = 0;
		int isStudent = 0;
		int isAta = 0;
		
		User user = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
		
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			user = (User) session.getAttribute("user");
			//prepariamo i valori da passare alla jsp
			isTeacherBoolean = managerUser.isTeacher(user);
			isAdministratorBoolean = managerUser.isAdministrator(user);
			isAtaBoolean = managerUser.isAtaPeople(user);
			isDirectorBoolean= managerUser.isDirector(user);
			isStudentBoolean= managerUser.isStudent(user);
			isParentBoolean= managerUser.isParent(user);
		
			isTeacher = Utility.BooleanToInt(isTeacherBoolean);
			isDirector = Utility.BooleanToInt(isDirectorBoolean);
			isAdministrator = Utility.BooleanToInt(isAdministratorBoolean);
			isAta = Utility.BooleanToInt(isAtaBoolean);
			isStudent = Utility.BooleanToInt(isStudentBoolean);
			isParent = Utility.BooleanToInt(isParentBoolean);
			
			gotoPage = "./persistentDataManagement/userManagement/userRolez.jsp?isTeacher="+isTeacher+"&isAdmin="+isAdministrator+"&isAta="+isAta
			+"&isStudent="+isStudent+"&isParent="+isParent+"&isDirector="+isDirector;
			pResponse.sendRedirect(gotoPage);
			
			return;  
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}
	
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.storage;

import java.sql.SQLException;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;

import smos.bean.Absence;
import smos.bean.Delay;
import smos.bean.Justify;
import smos.bean.Note;
import smos.bean.RegisterLine;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerRegister;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;


public class TestRegister {

	// database errato, impossibile inserire null nel campo id_justify di absence
	public static void main(String[] args) {
		
		ManagerRegister mr=  ManagerRegister.getInstance();
		
		Date datenow= new Date();
		
		Absence absence = new Absence();		
		absence.setIdUser(61);
		absence.setDateAbsence(datenow);
		absence.setIdJustify(0);
		absence.setAcademicYear(2009);
		//absence.setIdAbsence(13);
		
		/*
		try {
			absence= mr.getAbsenceByIdAbsence(12);
			
		} catch (InvalidValueException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (EntityNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (ConnectionException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		*/
		
		Justify justifynew= new Justify();
		justifynew.setIdUser(1);
		justifynew.setDateJustify(datenow);
		justifynew.setAcademicYear(2008);

		justifynew.setIdJustify(6);
		
		
		Delay delay = new Delay();
		//delay.setIdDelay(3);
		delay.setIdUser(62);
		delay.setDateDelay(datenow);
		delay.setTimeDelay("10:00:00");
		delay.setAcademicYear(2009);
		
		Note notenew= new Note();
		notenew.setIdUser(2);
		notenew.setTeacher("boh");
		notenew.setAcademicYear(2009);
		notenew.setDateNote(datenow);
		notenew.setDescription("lo studente dorme in classe");
		notenew.setIdNote(1);
		
		try{
			//mr.insertAbsence(absence);
			//if(mr.exists(absence)) System.out.println("esiste");;
			//mr.deleteAbsence(absence);
			//mr.updateAbsence(absence);
			
			mr.insertDelay(delay);
			//if(mr.exists(delay)) System.out.println("esiste");;
			//mr.updateDelay(delay);
			//mr.deleteDelay(delay);
			
			//mr.insertNote(notenew);
			//mr.deleteNote(notenew);
			
			//mr.insertJustify(justifynew, absence);
			//mr.deleteJustify(justifynew.getIdJustify());
			//if(mr.hasJustify(absence))System.out.println("giustificata");
			
			//absence= mr.getAbsenceByIDUserAndDate(2, "2009-05-18");
			//absence= mr.getAbsenceByIdJustify(1);
			//System.out.println(absence.getDateAbsence());
			
			//Collection<Absence> ac= mr.getAbsenceByIDUserAndAcademicYear(2, 2009);
			//for(Absence x : ac) System.out.println(x.getDateAbsence());
			
			//justifynew=mr.getJustifyByAbsence(absence);
			//System.out.println(justifynew.getDateJustify());
			
			//Collection<Note> nc = mr.getNoteByIDUserAndAcademicYear(2, 2009);
			//for(Note x : nc) System.out.println(x.getDescription());
			
			//delay= mr.getDelayByIDUserAndDate(1, datenow);
			//System.out.println(delay.getDateDelay());
			//System.out.println(delay.getTimeDelay());
			
			
			///*
			Collection<RegisterLine> crl = mr.getRegisterByClassIDAndDate(64, datenow );
			for(RegisterLine x : crl){
				System.out.println(x.getStudent().getName());
				if(mr.hasAbsence(x)){
					System.out.println("assente");
				}
				System.out.println(mr.hasAbsence(x));
				if(mr.hasDelay(x)){
					System.out.println("ritardo");
				}
			}
			//*/
			
			GregorianCalendar gc = new GregorianCalendar();
	
			String date="";
			int year=gc.get(GregorianCalendar.YEAR);
			
			int month=gc.get(GregorianCalendar.MONTH)+1;
			String months="";
			if(month<10){
				months="0"+month;
			}else{
				months= months+month;
			}
			
			int day=gc.get(GregorianCalendar.DAY_OF_MONTH);
			String days="";
			if(day<10){
				days="0"+day;
			}else{
				days= days+day;
			}
			
			date= date + year+"-"+months+"-"+days;
			System.out.println(date);
			
		}catch (Exception e) {
			System.out.println("errore");
			System.out.println(e.getMessage());
		}
		
		System.out.println(datenow.toString());
		System.out.println(Utility.isNull(datenow));
		System.out.println("TEST COMPLETATO");
	}
	
}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per recuperare i dettagli dell'utente.
 * 
 * @author Napolitano Vincenzo.
 *
 */
public class ServletShowUserDetails extends HttpServlet {

	private static final long serialVersionUID = 1726037792193089501L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/showUserDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}

			int userId = Integer.valueOf(pRequest.getParameter("userId"));
			User user = managerUser.getUserById(userId);
			
			session.setAttribute("user",user);
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
	}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}



/****************** displaytag stylesheet ****************/

table.datatable {
	border-color:#89B2DB;
	border-collapse: collapse;
	border-width: 1px;
	border-style:solid;
	width: 80%;
	margin: 5px 0 10px 10% !important;
	font-size: 8pt;
}
table.cardtable {
	border: 1px solid  #CCFFFF ;
	width: 80%;
	margin: 5px 0 10px 10% !important;
	font-size: 8pt;
}
table.simpletable {
	border: 0px;
	width: 80%;
	margin: 0px 0 0px 0 !important;
	font-size: 8pt;

}
table.datatable a:active,
table.datatable a:link,
table.datatable a:visited ,
table.cardtable a:active,
table.cardtable a:link,
table.cardtable a:visited{
	color:#000000;
	text-decoration:none;
	font-weight:bold;
}
table.cardtable a:hover,
table.datatable a:hover {
	color:#1075bd;
	text-decoration:none;
	font-weight:bold;
}
table.cardtable td{
	font-family:"trebuchet ms",Verdana, Arial, Helvetica, sans-serif;
	text-align:left;
	border: 1px solid  #89B2DB ;

}
table.datatable td{
	font-family:"trebuchet ms",Verdana, Arial, Helvetica, sans-serif;
	text-align:left;
}


thead tr {
	background-color: #C4CBD0;
}

th.sorted {
	background-color:#9ec7e2;
}

th.sorted a,
th.sortable a {
	color:#000000;
	background-position: right;
	display: block;
}
th.sorted a:hover,
th.sortable a:hover {
	color:#1075bd;
	text-decoration:none;
	font-weight:bold;
}
th.sortable a {
	background-image: url(../icons/arrow_off.png);
	background-repeat: no-repeat;	
	background-position:left; /* non supportata da mozilla */

}



th.order1 a {
	background-image: url(../images/down_arrow.gif);
}

th.order2 a {
	background-image: url(../images/up_arrow.gif);
}

tr.odd {
	background-color:#FFFFFF;
}

tr.tableRowEven, tr.even {
	background-color: #FFFFFF;
}

div.exportlinks {
	background-color: #ffffff;
	border: 1px dotted #89B2DB;
	padding: 2px 0px 2px 4px;
	margin: 2px 0px 10px 10% ;
	width: 79.5%;
	font-family:"trebuchet ms",Verdana, Arial, Helvetica, sans-serif;
	font-size:8pt;
	text-align:center;
}

span.export {
	padding: 0 4px 1px 20px;
	display: inline;
	display: inline-block;
}

span.excel {
	background-image: url(../images/icons/ico_file_excel.png);
	background-repeat: no-repeat;
}

span.csv {
	background-image: url(../images/icons/ico_file_csv.png);
	background-repeat: no-repeat;
}

span.xml {
	background-image: url(../images/icons/ico_file_xml.png);
	background-repeat: no-repeat;
}

span.pdf {
	background-image: url(../images/icons/ico_file_pdf.png);
	background-repeat: no-repeat;
}

span.rtf {
	background-image: url(../images/icons/ico_file_rtf.png);
	background-repeat: no-repeat;
}

span.pagebanner {
	background-color: #ffffff;
	border: 1px dotted #89B2DB;
	padding: 2px 0px 2px 4px;
	width: 79.5%;
	margin-top: 10px;
	margin-left:10%;
	display: block;
	border-bottom: none;
	font-family:"trebuchet ms",Verdana, Arial, Helvetica, sans-serif;
	font-size:8pt;
	text-align:center;
}

span.pagelinks {
	background-color: #ffffff;
	border: 1px dotted #89B2DB;
	padding: 2px 0px 2px 4px;
	width: 79.5%;
	display: block;
	border-top: none;
	margin-bottom: 5px;
	margin-left:10%;
	font-family:"trebuchet ms",Verdana, Arial, Helvetica, sans-serif;
	font-size:8pt;
	text-align:center;
}
package smos.application.userManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletShowUserTeachingForm extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2305151029867525356L;
	
	
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/showTeacherDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		
		User user = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
		
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			user = (User) session.getAttribute("user");
			
			if(!managerUser.isTeacher(user)){
				errorMessage =  "L'Utente non  un docente";
				gotoPage = "./error.jsp";
				
			}
			//int idTeacher= user.getId();
			
			Collection<Classroom> classList = managerClassroom.getClassroomsByTeacher(user);
			
			/*
			Iterator<Classroom> iteClass = classList.iterator();
			Classroom tmp = null;
			while(iteClass.hasNext()){
				tmp=iteClass.next();
				if(tmp.getAcademicYear()!= an){
					classList.remove(tmp);
				}
			}*/
			//@SuppressWarnings("unused")
			//Collection<Teaching> teachingListByClassroom=null;
			//Collection<Classroom,Teaching> list= new Vector <Classroom,Teaching>();
			
			session.setAttribute("classroomList", classList);
			
			pResponse.sendRedirect(gotoPage);
			
			return;  
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}
	
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli anni accademici presenti nel
 * db.
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletLoadClassByAccademicYear extends HttpServlet {

	private static final long serialVersionUID = -3988115259356084996L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Classroom> classroomList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			//Date oggi = new Date();
			// recuperiamo l'anno accademico selezionato
			int selectedAccademicYear = Integer.valueOf(pRequest.getParameter("accademicYear"));
			
			
			ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
			//Calcoliamo l'elenco delle classi dell'anno accademico selezionato
			classroomList = managerClassroom.getClassroomsByAcademicYear(selectedAccademicYear);
			session.setAttribute("classroomList", classroomList);
			session.setAttribute("selectedYear", selectedAccademicYear);
			//session.removeAttribute("selectedClass");
			gotoPage +=(String) session.getAttribute("goTo");
			
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.bean;

import java.io.Serializable;
import java.util.Date;

public class Justify implements Serializable {

	/**
	 * Classe che modella una giustifica per un assenza
	 * @author Nicola Pisanti
	 * @version 1.0
	 * 
	 */
	private static final long serialVersionUID = -4726381877687167661L;

	private int idJustify;
	private int idUser;
	private Date dateJustify;
	private int academicYear;
	
	/**
	 * Metodo che restituisce l'id della giustifica
	 * @return un intero che rappresenta l'id della giustifica
	 */
	public int getIdJustify() {
		return idJustify;
	}
	/**
	 * Metodo che setta l'id della giustifica
	 * @param un intero che rappresenta l'id da settare
	 */
	public void setIdJustify(int pIdJustify) {
		this.idJustify = pIdJustify;
	}
	/**
	 * Metodo restituisce l'id dello studente relativo alla giustifica
	 * @return un intero che rappresenta l'id dello studente 
	 */
	public int getIdUser() {
		return idUser;
	}
	/**
	 * Metodo che setta l'id dello studente relativo alla giustifica
	 * @param un intero che rappresenta l'id da settare
	 */
	public void setIdUser(int pIdUser) {
		this.idUser = pIdUser;
	}
	/**
	 * Metodo che restituisce la data alla quale è stata giustificata l'assenza
	 * @return una stringa che rappresenta la data giustificata
	 */
	public Date getDateJustify() {
		return dateJustify;
	}
	/**
	 * Metodo che setta la data alla quale è stata giustificata l'assenza
	 * @param una stringa che rappresenta la data da settare
	 */
	public void setDateJustify(Date pDateJustify) {
		this.dateJustify = pDateJustify;
	}
	/**
	 * Metodo che restituisce l'anno accademico relativo alla giustifica
	 * @return un intero che rappresenta l'anno in cui è iniziato l'anno accademico 
	 */
	public int getAcademicYear() {
		return academicYear;
	}
	/**
	 * Metodo che setta l'anno accademico relativo alla giustifica
	 * @param un intero che rappresenta l'anno accademico da settare
	 */
	public void setAcademicYear(int pAcademicYear) {
		this.academicYear = pAcademicYear;
	}
	
	
	
}

package smos.bean;

import java.io.Serializable;
import java.util.Date;

/**
 * Classe che modella una nota sul registro 
 * @author Nicola Pisanti
 * @version 1.0
 */


public class Note implements Serializable{

	private static final long serialVersionUID = 5953926210895315436L;
	
	private int idNote;
	private int idUser;
	private Date dateNote;
	private String description;
	private String teacher;
	private int academicYear;
	
	
	public Note(){
		
	}
	
	
	
	/**
	 * Metodo che restituisce l'id della nota
	 * @return un intero che rappresenta l'id della nota
	 */
	public int getIdNote() {
		return idNote;
	}
	/**
	 * Metodo per settare l'id della nota
	 * @param un intero che rappresenta il nuovo valore dell'id
	 */
	public void setIdNote(int pIdNote) {
		this.idNote = pIdNote;
	}
	/**
	 * Metodo che restituisce l'id dello studente che ha ricevuto la nota
	 * @return l'id dell'utente che ha ricevuto la nota
	 */
	public int getIdUser() {
		return idUser;
	}
	/**
	 * Metodo per settare l'id dello studente che ha ricevuto la nota
	 * @param un intero che rappresenta il nuovo valore dell'id
	 */
	public void setIdUser(int pIdUser) {
		this.idUser = pIdUser;
	}
	/**
	 * Metodo che restituisce una stringa che rappresenta la data in cui è stata data la nota
	 * @return una stringa che rappresenta la data della nota
	 */
	public Date getDateNote() {
		return dateNote;
	}
	/**
	 * Metodo che setta una stringa che rappresenta la data in cui è stata data la nota
	 * @param la stringa che rappresenta la nuova data
	 */
	public void setDateNote(Date pDateNote) {
		this.dateNote = pDateNote;
	}
	/**
	 * Metodo che restituisce il testo della nota 
	 * @return una stringa che rappresenta il testo della nota
	 */
	public String getDescription() {
		return description;
	}
	/**
	 * Metodo che setta la descrizione della nota
	 * @param una stringa che contiene la descrizione della nota
	 */
	public void setDescription(String pDescription) {
		this.description = pDescription;
	}
	/**
	 * Metodo che restituisce l'id dell'insegnante che ha dato la nota 
	 * @return un intero che rappresenta l'id dell'insegnante
	 */
	public String getTeacher() {
		return teacher;
	}
	/**
	 * Metodo che setta l'id dell'insegnante che ha dato la nota 
	 * @param teacher the teacher to set
	 */
	public void setTeacher(String pTeacher) {
		this.teacher = pTeacher;
	}
	/**
	 * Metodo che restituisce l'anno accademico in corso
	 * @return un intero che indica l'anno di inizio delle lezioni 
	 */
	public int getAcademicYear() {
		return academicYear;
	}
	/**
	 * Medoto che setta l'anno accademico in corso durante l'assegnazione della nota
	 * @param un intero che indica l'anno di inizio delle lezioni da inserire
	 */
	public void setAcademicYear(int academicYear) {
		this.academicYear = academicYear;
	}

	
	
	
	
	
}

/*
 * ConnectionWrapper
 *
 */

package smos.storage.connectionManagement;


import java.io.Serializable;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;

/**
 * ConnectionWrapper  una classe che aggiunge a tutti i metodi della classe
 * Connection il settaggio del tempo in cui l'operazione sulla particolare
 * connessione  avvenuta informando il pool di quanto accaduto.
 */

public class ConnectionWrapper implements Connection, Serializable {
    private static final long serialVersionUID = 1L;

    private static final Logger LOGGER = Logger
            .getLogger(ConnectionWrapper.class.getName());

    private Connection connection;

    private ConnectionPoolDataSource manager;

    private ArrayList<Statement> statements = new ArrayList<Statement>();

    /**
     * @param pConnection
     * @param pPoolManager
     */
    public ConnectionWrapper(Connection pConnection,
            ConnectionPoolDataSource pPoolManager) {
        this.connection = pConnection;
        this.manager = pPoolManager;
        LOGGER.fine("Creating ConnectionWrapper");
    }

    private PreparedStatement cachePreparedStatement(PreparedStatement pPrepSt) {
        this.manager.setLastTime(this);
        this.statements.add(pPrepSt);
        return pPrepSt;
    }

    private Statement cacheStatement(Statement pStatement) {
        this.manager.setLastTime(this);
        this.statements.add(pStatement);
        return pStatement;
    }

    /**
     * @see java.sql.Connection#clearWarnings()
     */
    public void clearWarnings() throws SQLException {
        this.connection.clearWarnings();
    }

    /**
     * @see java.sql.Connection#close()
     */
    public void close() throws SQLException {
        closeAndReleaseStatements();
        this.manager.release(this);
    }

    private synchronized void closeAndReleaseStatements() throws SQLException {
        final int n = this.statements.size();
        for (int i = 0; i < n; i++) {
            ((Statement) this.statements.get(i)).close();
        }
        this.statements.clear();
    }

    /**
     * Close the wrapped connection.
     * @throws SQLException 
     */
    void closeWrappedConnection() throws SQLException {
        closeAndReleaseStatements();
        if (!this.connection.isClosed()) {
            LOGGER.fine("Closing db connection: " + this.getClass().getName()
                    + " [" + this + "]");
        }
        this.connection.close();
    }

    /**
     * @see java.sql.Connection#commit()
     */
    public void commit() throws SQLException {
        this.manager.setLastTime(this);
        this.connection.commit();
    }

    /**
     * @see java.sql.Connection#createStatement()
     */
    public Statement createStatement() throws SQLException {
        this.manager.setLastTime(this);
        return cacheStatement(this.connection.createStatement());
    }

    /**
     * @see java.sql.Connection#createStatement(int, int)
     */
    public Statement createStatement(int pResultSetType,
            int pResultSetConcurrency) throws SQLException {
        this.manager.setLastTime(this);
        return cacheStatement(this.connection.createStatement(pResultSetType,
                pResultSetConcurrency));
    }

    /**
     * @see java.sql.Connection#createStatement(int, int, int)
     */
    public Statement createStatement(int pResultSetType,
            int pResultSetConcurrency, int pResultSetHoldability)
            throws SQLException {
        this.manager.setLastTime(this);
        return cacheStatement(this.connection.createStatement(pResultSetType,
                pResultSetConcurrency, pResultSetHoldability));
    }

    /**
     * Closes the wrapped connection.
     */
    protected void finalize() throws Throwable {
        closeWrappedConnection();
    }

    /**
     * @see java.sql.Connection#getAutoCommit()
     */
    public boolean getAutoCommit() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getAutoCommit();
    }

    /**
     * @see java.sql.Connection#getCatalog()
     */
    public String getCatalog() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getCatalog();
    }

    /**
     * @see java.sql.Connection#getHoldability()
     */
    public int getHoldability() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getHoldability();
    }

    /**
     * @see java.sql.Connection#getMetaData()
     */
    public DatabaseMetaData getMetaData() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getMetaData();
    }

    /**
     * @see java.sql.Connection#getTransactionIsolation()
     */
    public int getTransactionIsolation() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getTransactionIsolation();
    }

    /**
     * @see java.sql.Connection#getTypeMap()
     */
    @SuppressWarnings("unchecked")
	public Map getTypeMap() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getTypeMap();
    }

    /**
     * @see java.sql.Connection#getWarnings()
     */
    public SQLWarning getWarnings() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.getWarnings();
    }

    /**
     * @see java.sql.Connection#isClosed()
     */
    public boolean isClosed() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.isClosed();
    }

    /**
     * @see java.sql.Connection#isReadOnly()
     */
    public boolean isReadOnly() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.isReadOnly();
    }

    /**
     * @see java.sql.Connection#nativeSQL(java.lang.String)
     */
    public String nativeSQL(String sql) throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.nativeSQL(sql);
    }

    /**
     * @see java.sql.Connection#prepareCall(java.lang.String)
     */
    public CallableStatement prepareCall(String sql) throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.prepareCall(sql);
    }

    /**
     * @see java.sql.Connection#prepareCall(java.lang.String, int, int)
     */
    public CallableStatement prepareCall(String pStatementSql,
            int pResultSetType, int pResultSetConcurrency) throws SQLException {

        this.manager.setLastTime(this);
        return this.connection.prepareCall(pStatementSql, pResultSetType,
                pResultSetConcurrency);
    }

    /**
     * @see java.sql.Connection#prepareCall(java.lang.String, int, int, int)
     */
    public CallableStatement prepareCall(String pStatementSql,
            int pResultSetType, int pResultSetConcurrency,
            int pResultSetHoldability) throws SQLException {

        this.manager.setLastTime(this);
        return this.connection.prepareCall(pStatementSql, pResultSetType,
                pResultSetConcurrency, pResultSetHoldability);
    }

    /**
     * @see java.sql.Connection#prepareStatement(java.lang.String)
     */
    public PreparedStatement prepareStatement(String pStatementSql)
            throws SQLException {
        this.manager.setLastTime(this);
        return cachePreparedStatement(this.connection
                .prepareStatement(pStatementSql));
    }

    /**
     * @see java.sql.Connection#prepareStatement(java.lang.String, int)
     */
    public PreparedStatement prepareStatement(String pStatementSql,
            int pAutoGeneratedKeys) throws SQLException {

        this.manager.setLastTime(this);
        return cachePreparedStatement(this.connection.prepareStatement(
                pStatementSql, pAutoGeneratedKeys));
    }

    /**
     * @see java.sql.Connection#prepareStatement(java.lang.String, int, int)
     */
    public PreparedStatement prepareStatement(String pStatementSql,
            int pResultSetType, int pResultSetConcurrency) throws SQLException {

        this.manager.setLastTime(this);
        return cachePreparedStatement(this.connection.prepareStatement(
                pStatementSql, pResultSetType, pResultSetConcurrency));
    }

    /**
     * @see java.sql.Connection#prepareStatement(java.lang.String, int, int, int)
     */
    public PreparedStatement prepareStatement(String pStatementSql,
            int pResultSetType, int pResultSetConcurrency,
            int pResultSetHoldability) throws SQLException {

        this.manager.setLastTime(this);
        return cachePreparedStatement(this.connection.prepareStatement(
                pStatementSql, pResultSetType, pResultSetConcurrency,
                pResultSetHoldability));
    }

    /**
     * @see java.sql.Connection#prepareStatement(java.lang.String, int[])
     */
    public PreparedStatement prepareStatement(String pStatementSql,
            int[] columnIndexes) throws SQLException {
        this.manager.setLastTime(this);
        return cachePreparedStatement(this.connection.prepareStatement(
                pStatementSql, columnIndexes));
    }

    /**
     * @see java.sql.Connection#prepareStatement(java.lang.String, java.lang.String[])
     */
    public PreparedStatement prepareStatement(String pStatementSql,
            String[] pColumnNames) throws SQLException {
        this.manager.setLastTime(this);
        return cachePreparedStatement(this.connection.prepareStatement(
                pStatementSql, pColumnNames));
    }

    /**
     * @see java.sql.Connection#releaseSavepoint(java.sql.Savepoint)
     */
    public void releaseSavepoint(Savepoint pSavepoint) throws SQLException {
        this.manager.setLastTime(this);
        this.connection.releaseSavepoint(pSavepoint);
    }

    /**
     * @see java.sql.Connection#rollback()
     */
    public void rollback() throws SQLException {
        this.manager.setLastTime(this);
        this.connection.rollback();
    }

    /**
     * @see java.sql.Connection#rollback(java.sql.Savepoint)
     */
    public void rollback(Savepoint pSavepoint) throws SQLException {
        this.manager.setLastTime(this);
        this.connection.rollback(pSavepoint);
    }

    /**
     * @see java.sql.Connection#setAutoCommit(boolean)
     */
    public void setAutoCommit(boolean pAutoCommit) throws SQLException {
        this.manager.setLastTime(this);
        if (this.connection.getAutoCommit() != pAutoCommit) {
            this.connection.setAutoCommit(pAutoCommit);
        }
    }

    /**
     * @see java.sql.Connection#setCatalog(java.lang.String)
     */
    public void setCatalog(String pCatalog) throws SQLException {
        this.manager.setLastTime(this);
        this.connection.setCatalog(pCatalog);
    }

    /**
     * @see java.sql.Connection#setHoldability(int)
     */
    public void setHoldability(int pHoldability) throws SQLException {
        this.manager.setLastTime(this);
        this.connection.setHoldability(pHoldability);
    }

    /**
     * @see java.sql.Connection#setReadOnly(boolean)
     */
    public void setReadOnly(boolean pReadOnly) throws SQLException {
        this.manager.setLastTime(this);
        this.connection.setReadOnly(pReadOnly);
    }

    /**
     * @see java.sql.Connection#setSavepoint()
     */
    public Savepoint setSavepoint() throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.setSavepoint();
    }

    /**
     * @see java.sql.Connection#setSavepoint(java.lang.String)
     */
    public Savepoint setSavepoint(String pName) throws SQLException {
        this.manager.setLastTime(this);
        return this.connection.setSavepoint(pName);
    }

    /**
     * @see java.sql.Connection#setTransactionIsolation(int)
     */
    public void setTransactionIsolation(int pLevel) throws SQLException {
        this.manager.setLastTime(this);
        this.connection.setTransactionIsolation(pLevel);
    }

    /**
     * @see java.sql.Connection#setTypeMap(java.util.Map)
     */
    

    /**
     * @see java.lang.Object#toString()
     */
    public String toString() {
        return this.connection.toString();
    }

	public void setTypeMap(Map<String, Class<?>> arg0) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	

}

package smos.application.userManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Role;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.DeleteManagerException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletAssignStudentClassroom extends HttpServlet {

	/**
	 * 
	 */

	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./showUserList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla "
					+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}

			// Studente selezionato
			User user = (User) session.getAttribute("user");

			// anno accademico selezionato
			int academicYear = Integer.valueOf(pRequest
					.getParameter("accademicYear"));
			// id classe selezionata che e' zero se vogliamo eliminare
			// l'associazione
			int idClassroom = Integer.valueOf(pRequest.getParameter("classId"));
			Classroom p = null;
			p = managerClassroom.getClassroomByUserAcademicYear(user,academicYear);
			if (p != null)
				managerUser.removeStudentClassroom(user, p.getIdClassroom());
			if(idClassroom>0) {
				
					managerUser.assignStudentClassroom(user, idClassroom);
			}

		} catch (NumberFormatException numberFormatException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MandatoryFieldException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}
package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.DeleteAdministratorException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per eliminare un utente.
 * 
 * @author Napolitano Vincenzo.
 * 
 */
public class ServletDeleteUser extends HttpServlet {

	private static final long serialVersionUID = -7693860059069872995L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "showUserList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<UserListItem> manager = null;
		Iterator<UserListItem> it = null;
		User loggedUser = (User) session.getAttribute("loggedUser");
		ManagerUser managerUser = ManagerUser.getInstance();

		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) &&
					(!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
		
			User user = (User) session.getAttribute("user");
			//cancella utente se non  amministratore
			if(!managerUser.isAdministrator(user)) {
				managerUser.delete(user);
			}
			//controllo se l'utente  amministratore e se ce ne sono degli altri
			else {
				manager = managerUser.getAdministrators();
				it = manager.iterator();
				it.next();
				if (it.hasNext()) {
					managerUser.delete(user);
				}
				else
					throw new DeleteAdministratorException ();
			}
			
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (DeleteAdministratorException deleteAdministratorException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + deleteAdministratorException.getMessage();
			gotoPage = "./error.jsp";
			deleteAdministratorException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione generata quando non  possibile
  * ottenere una connessione al database
  */
public class ConnectionException extends Exception {
	
	private static final long serialVersionUID = -6593436034986073011L;

	/**
	 * Genera l'eccezione senza un messagio di errore associato.
	 */
	public ConnectionException() {
		super("Unable to Connect to the DataBase!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public ConnectionException(String pMessage) {
		super(pMessage);
	}
	
	
}
package smos.application.addressManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import smos.Environment;
import smos.bean.User;
import smos.bean.Address;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerAddress;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

/**
 * Servlet utilizzata per inserire un indirizzo nel database
 * 
 * @author Vecchione Giuseppe
 */
public class ServletInsertAddress extends HttpServlet {

	private static final long serialVersionUID = 8318905833953187814L;
	
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * 
	 * @param pResponse
	 * 
	 */
	
	public void doGet(HttpServletRequest pRequest, HttpServletResponse pResponse){
		String gotoPage="./showAddressList";
		String errorMessage="";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser= ManagerUser.getInstance();
		ManagerAddress managerAddress= ManagerAddress.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		try {
				if(loggedUser==null){
					pResponse.sendRedirect("./index.htm");
					return;
				}
				if(!managerUser.isAdministrator(loggedUser)){
					errorMessage= "L' utente collegato non ha accesso alla funzionalita'!";
					gotoPage="./error.jsp";
				}
				
				Address address= new Address();
				address.setName(pRequest.getParameter("name"));
				
				/**
				 * Verifichiamo che l' indirizzo non sia presente nel database
				 * e lo inseriamo
				 */
				if(!managerAddress.exists(address)){
					managerAddress.insert(address);
				}else{
					throw new DuplicatedEntityException("Indirizzo gia' esistente");
				}
				
			} catch (IOException ioException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
				gotoPage = "./error.jsp";
				ioException.printStackTrace();
			} catch (SQLException sqlException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
				gotoPage = "./error.jsp";
				sqlException.printStackTrace();
			} catch (EntityNotFoundException entityNotFoundException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
				gotoPage = "./error.jsp";
				entityNotFoundException.printStackTrace();
			} catch (ConnectionException connectionException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
				gotoPage = "./error.jsp";
				connectionException.printStackTrace();
			} catch (MandatoryFieldException mandatoryFieldException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
				gotoPage = "./error.jsp";
				mandatoryFieldException.printStackTrace();
			} catch (InvalidValueException invalidValueException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
				gotoPage = "./error.jsp";
				invalidValueException.printStackTrace();
			} catch (DuplicatedEntityException duplicatedEntityException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + duplicatedEntityException.getMessage();
				gotoPage = "./error.jsp";
				duplicatedEntityException.printStackTrace();
			}
			session.setAttribute("errorMessage", errorMessage);
			try {
				pResponse.sendRedirect(gotoPage);
			} catch (IOException ioException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
				gotoPage = "./error.jsp";
				ioException.printStackTrace();
			}
		}
	
	
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	

}

package smos.exception;

import java.lang.Exception;

/**
 * Questa classe rappresenta l'eccezione generata quando un utente
 * tenta di eliminare l'unico utente Manager nel database.
 */
public class DeleteManagerException extends Exception {

	private static final long serialVersionUID = -6441256751177339494L;
	
	/**
	 * Genera l'eccezione senza un messaggio di errore associato.
	 * 
	 */
	public DeleteManagerException() {
		super("Impossibile eliminare l'utente, l'utente selezionato e' l'unico Manager presente nel database! Creare un nuovo Manager e riprovare!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public DeleteManagerException(String pMessage) {
		super(pMessage);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Justify;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletShowJustifyDetails extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6445257206429581384L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showJustifyDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			ManagerRegister mR= ManagerRegister.getInstance();
			int idJustify = Integer.valueOf(pRequest.getParameter("idJustify"));
			String idClassroom = pRequest.getParameter("idClassroom");
			gotoPage+="?idClassroom="+idClassroom;
			Justify justify=mR.getJustifyByIdJustify(idJustify);
			
			
			session.setAttribute("justify",justify);
			session.setAttribute("idClassroom",idClassroom);
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
	}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}


package smos.storage;

import smos.bean.Teaching;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.connectionManagement.DBConnection;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Vector;
import java.sql.Connection;

/**
 * 
 * Classe manager degli insegnamenti.
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */

public class ManagerTeaching {
	private static ManagerTeaching instance;

	/**
	 * Il nome della tabella degli insegnamenti.
	 */
	public static final String TABLE_TEACHING = "teaching";

	/**
	 * Il nome della tabella che modella l'associazione molti a molti tra
	 * indirizzi ed insegnamenti.
	 */
	public static final String TABLE_ADDRESS_TEACHINGS = "address_has_teaching";

	/**
	 * Il nome della tabella che modella l'associazione molti a molti tra utenti
	 * e insegnamenti.
	 */
	public static final String TABLE_TEACHER_CLASSROOM = "teacher_has_classroom";

	/**
	 * Il costruttore della classe.
	 */
	private ManagerTeaching() {
		super();
	}

	/**
	 * Ritorna la sola istanza dell'insegnamento esistente.
	 * 
	 * @return Ritorna l'istanza della classe.
	 */
	public static synchronized ManagerTeaching getInstance() {
		if (instance == null) {
			instance = new ManagerTeaching();
		}
		return instance;
	}

	/**
	 * Verifica l'esistenza di un insegnamento nel database.
	 * 
	 * @param pTeaching
	 *            L'insegnamento da controllare.
	 * @return Ritorna true se esiste l'insegnamento passato come parametro,
	 *         false altrimenti.
	 * 
	 * @throws MandatoryFieldException
	 * @throws SQLException
	 * @throws ConnectionException
	 */
	public synchronized boolean exists(Teaching pTeaching)
			throws MandatoryFieldException, ConnectionException, SQLException {

		boolean result = false;
		Connection connect = null;

		if (pTeaching.getName() == null)
			throw new MandatoryFieldException("Specificare il nome.");
		try {
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			String sql = "SELECT * FROM " + ManagerTeaching.TABLE_TEACHING
					+ " WHERE name = " + Utility.isNull(pTeaching.getName());

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);

			if (tRs.next())
				result = true;

			return result;

		} finally {
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Inserisce un nuovo insegnamento nella tabella teaching.
	 * 
	 * @param pTeaching
	 *            L'insegnamento da inserire.
	 * 
	 * @throws SQLException
	 * @throws ConnectionException
	 * @throws MandatoryFieldException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insert(Teaching pTeaching)
			throws MandatoryFieldException, ConnectionException, SQLException,
			EntityNotFoundException, InvalidValueException {
		Connection connect = null;
		try {
			// controllo dei campi obbligatori
			if (pTeaching.getName() == null)
				throw new MandatoryFieldException("Specificare il campo nome");

			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();
			// Prepariamo la stringa Sql
			String sql = "INSERT INTO " + ManagerTeaching.TABLE_TEACHING
					+ " (name) " + "VALUES ("
					+ Utility.isNull(pTeaching.getName()) + ")";

			Utility.executeOperation(connect, sql);

			pTeaching.setId(Utility.getMaxValue("id_teaching",
					ManagerTeaching.TABLE_TEACHING));

		} finally {
			// rilascia le risorse

			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Aggiorna un insegnamento presente nella tabella teaching.
	 * 
	 * @param pTeaching
	 *            L'insegnamento da modificare
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	public synchronized void update(Teaching pTeaching)
			throws ConnectionException, SQLException, EntityNotFoundException,
			MandatoryFieldException {
		Connection connect = null;

		try {
			if (pTeaching.getId() <= 0)
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			if (pTeaching.getName() == null)
				throw new MandatoryFieldException("Specificare il campo nome");

			// Prepariamo la stringa SQL
			String sql = "UPDATE " + ManagerTeaching.TABLE_TEACHING + " SET"
					+ " name = " + Utility.isNull(pTeaching.getName())
					+ " WHERE id_teaching = "
					+ Utility.isNull(pTeaching.getId());

			// effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			Utility.executeOperation(connect, sql);
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Elimina un insegnamento dalla tabella teaching.
	 * 
	 * @param pTeaching
	 *            L'insegnamento da eliminare.
	 * 
	 * @throws MandatoryFieldException
	 * @throws EntityNotFoundException
	 * @throws SQLException
	 * @throws ConnectionException
	 * @throws InvalidValueException
	 * 
	 */
	public synchronized void delete(Teaching pTeaching)
			throws ConnectionException, SQLException, EntityNotFoundException,
			MandatoryFieldException, InvalidValueException {
		Connection connect = null;

		try {
			// ManagerTeaching.getInstance().teachingOnDeleteCascade(pTeaching);
			connect = DBConnection.getConnection();
			// Prepariamo la stringa SQL
			String sql = "DELETE FROM " + ManagerTeaching.TABLE_TEACHING
					+ " WHERE id_teaching = "
					+ Utility.isNull(pTeaching.getId());

			Utility.executeOperation(connect, sql);
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'id dell'insegnamento passato come parametro.
	 * 
	 * @param pTeaching
	 *            L'insegnamento di cui si richiede l'id.
	 * @return Ritorna l'id dell'insegnamento passato come parametro.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized int getTeachingId(Teaching pTeaching)
			throws EntityNotFoundException, ConnectionException, SQLException {
		int result = 0;
		Connection connect = null;
		try {
			if (pTeaching == null)
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti all'id dell'insegnamento passato come parametro.
			 */
			String tSql = "SELECT id_teaching FROM "
					+ ManagerTeaching.TABLE_TEACHING + " WHERE name = "
					+ Utility.isNull(pTeaching.getName());

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);

			if (tRs.next())
				result = tRs.getInt("id_teaching");

			return result;
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna il nome dell'insegnamento corrispondente all'id passato come
	 * parametro.
	 * 
	 * @param pId
	 *            L'id dell'insegnamento.
	 * @return Ritorna una stringa contenente il nome dell'insegnamento.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	public synchronized String getTeachingNameById(int pId)
			throws EntityNotFoundException, ConnectionException, SQLException {
		String result;
		Connection connect = null;
		try {
			// Se non e' stato fornito l'id restituiamo un codice di errore
			if (pId <= 0)
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti all'id dell'insegnamento passato come parametro
			 */
			String tSql = "SELECT name FROM " + ManagerTeaching.TABLE_TEACHING
					+ " WHERE id_teaching = " + Utility.isNull(pId);

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);

			if (tRs.next())
				result = tRs.getString("name");
			else
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			return result;
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'insegnamento corrispondente all'id passato come parametro.
	 * 
	 * @param pId
	 *            L'id dell'insegnamento.
	 * @return Ritorna l'insegnamento associato all'id passato come parametro.
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized Teaching getTeachingById(int pId)
			throws ConnectionException, SQLException, EntityNotFoundException,
			InvalidValueException {
		Teaching result = null;
		Connection connect = null;
		try {

			if (pId <= 0)
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Prepariamo la stringa SQL
			String sql = "SELECT * FROM " + ManagerTeaching.TABLE_TEACHING
					+ " WHERE id_teaching = " + Utility.isNull(pId);

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordFromRs(pRs);
			else
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'insieme di tutti gli insegnamenti presenti nel database.
	 * 
	 * @return Ritorna una collection di insegnamenti.
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 */
	public synchronized Collection<Teaching> getTeachings()
			throws ConnectionException, SQLException, InvalidValueException,
			EntityNotFoundException {
		Collection<Teaching> result = null;
		Connection connect = null;

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT * FROM " + ManagerTeaching.TABLE_TEACHING
					+ " ORDER BY name";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}

	}

	/**
	 * Ritorna l'insieme degli insegnamenti associati all'utente corrispondente
	 * all'id passato come paramentro.
	 * 
	 * @param pId
	 *            L'id dell'utente.
	 * @return Ritorna una collection di insegnamenti.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Teaching> getTeachingsByUserId(int pId)
			throws EntityNotFoundException, ConnectionException, SQLException,
			InvalidValueException {

		Collection<Teaching> result = null;
		Connection connect = null;

		if (pId <= 0)
			throw new EntityNotFoundException("specificare l'utente");

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT " + ManagerTeaching.TABLE_TEACHING
					+ ".* FROM " + ManagerTeaching.TABLE_TEACHER_CLASSROOM
					+ ", " + ManagerTeaching.TABLE_TEACHING + " WHERE ("
					+ ManagerTeaching.TABLE_TEACHER_CLASSROOM
					+ ".id_teaching = " + ManagerTeaching.TABLE_TEACHING
					+ ".id_teaching AND "
					+ ManagerTeaching.TABLE_TEACHER_CLASSROOM + ".id_user = "
					+ Utility.isNull(pId) + ")" + " ORDER BY name";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'insieme degli insegnamenti che il docente insegna nella classe
	 * 
	 * @param pIdTeacher
	 *            L'id dell'utente.
	 * @param pIdClass
	 *            l'id della classe
	 * @return Ritorna una collection di insegnamenti.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Teaching> getTeachingsByUserIdClassID(int pIdTeacher,int pIdClass)
			throws EntityNotFoundException, ConnectionException, SQLException,
			InvalidValueException {

		Collection<Teaching> result = null;
		Connection connect = null;

		if (pIdTeacher <= 0)
			throw new EntityNotFoundException("specificare l'utente");
		if (pIdClass <= 0)
			throw new EntityNotFoundException("specificare la classe");

		try {
			// Prepariamo la stringa SQL
			
			String sql = "SELECT DISTINCT " + ManagerTeaching.TABLE_TEACHING
					+ ".* FROM " + ManagerTeaching.TABLE_TEACHER_CLASSROOM
					+ ", " + ManagerTeaching.TABLE_TEACHING + " WHERE ("
					+ ManagerTeaching.TABLE_TEACHER_CLASSROOM + ".id_user = "
					+ Utility.isNull(pIdTeacher) +" AND "
					+ ManagerTeaching.TABLE_TEACHER_CLASSROOM 
					+ ".id_teaching= " + Utility.isNull(pIdClass)
					+ " AND "
					+ ManagerTeaching.TABLE_TEACHER_CLASSROOM
					+ ".id_teaching = " + ManagerTeaching.TABLE_TEACHING
					+ ".id_teaching "
					+") ORDER BY name";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Verifica se un insegnamento ha un professore assegnato.
	 * 
	 * @param pTeaching
	 *            L'insegnamento da controllare.
	 * @return Ritorna true se l'insegnamento ha un professore assegnato, false
	 *         altrimenti.
	 * 
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws InvalidValueException
	 */
	public synchronized boolean hasTeacher(Teaching pTeaching)
			throws SQLException, EntityNotFoundException, ConnectionException,
			InvalidValueException {
		Connection connect = null;
		boolean result = false;
		if (pTeaching.getId() <= 0)
			throw new EntityNotFoundException("Specificare l'insegnamento");

		try {
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Preparimao la stringa sql
			String sql = "SELECT * FROM "
					+ ManagerTeaching.TABLE_TEACHER_CLASSROOM
					+ " WHERE id_teaching = "
					+ Utility.isNull(pTeaching.getId());
			// Inviamo la Query al database
			ResultSet pRs = Utility.queryOperation(connect, sql);
			if (pRs.next())
				result = true;

			return result;

		} finally {
			// rilasciamo le risorse
			DBConnection.releaseConnection(connect);

		}
	}

	/**
	 * Ritorna l'insieme degli insegnamenti associati alla classe specificata
	 * 
	 * @param pId
	 *            L'id della classe.
	 * @return Ritorna una collection di insegnamenti.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Teaching> getTeachingsByClassroomId(int pId)
			throws EntityNotFoundException, ConnectionException, SQLException,
			InvalidValueException {

		Collection<Teaching> result = null;
		Connection connect = null;

		if (pId < 0)
			throw new EntityNotFoundException("specificare l'id della Classe!");

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT " + ManagerTeaching.TABLE_TEACHING
					+ ".* FROM " + ManagerClassroom.TABLE_CLASSROOM + ", "
					+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS + ", "
					+ ManagerTeaching.TABLE_TEACHING + " WHERE "
					+ ManagerClassroom.TABLE_CLASSROOM + ".id_classroom = "
					+ Utility.isNull(pId) + " AND "
					+ ManagerClassroom.TABLE_CLASSROOM + ".id_address = "
					+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS
					+ ".id_address AND " + ManagerTeaching.TABLE_TEACHING
					+ ".id_teaching= "
					+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS + ".id_teaching ";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'insieme degli insegnamenti associati alla classe specificata
	 * 
	 * @param name
	 *            Il nome della classe.
	 * @return Ritorna una collection di insegnamenti.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Teaching> getTeachingsByClassroomName(
			String name) throws EntityNotFoundException, ConnectionException,
			SQLException, InvalidValueException {

		Collection<Teaching> result = null;
		Connection connect = null;

		if ((name == null) || (name == ""))
			throw new EntityNotFoundException(
					"specificare il nome della Classe!");

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT " + ManagerTeaching.TABLE_TEACHING
					+ ".* FROM " + ManagerClassroom.TABLE_CLASSROOM + ", "
					+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS + ", "
					+ ManagerTeaching.TABLE_TEACHING + " WHERE "
					+ ManagerClassroom.TABLE_CLASSROOM + ".name = "
					+ Utility.isNull(name) + " AND "
					+ ManagerClassroom.TABLE_CLASSROOM + ".id_address = "
					+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS
					+ ".id_address AND " + ManagerTeaching.TABLE_TEACHING
					+ ".id_teaching= "
					+ ManagerTeaching.TABLE_ADDRESS_TEACHINGS + ".id_teaching ";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	
	public synchronized Collection<Teaching> getTeachingsByIdUserIdClassroom(int pUser, int pClass) throws SQLException,
	EntityNotFoundException, ConnectionException, InvalidValueException {
		
		
		Collection<Teaching> result = null;
		Connection connect = null;
		try {
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// 	Preparimao la stringa sql
			//select teaching.* from teacher_has_classroom AS THC , teaching where thc.id_user = 54 
			//&& thc.id_classroom = 64 && thc.id_teaching = teaching.id_teaching
			
			String sql = "SELECT DISTINCT "
				+ManagerTeaching.TABLE_TEACHING+".*" 
				+" FROM " 
				+ ManagerUser.TABLE_TEACHER_CLASSROOM
				+" , "
				+ManagerTeaching.TABLE_TEACHING
				+ " WHERE "
				+ ManagerUser.TABLE_TEACHER_CLASSROOM
				+ ".id_user = "  
				+ Utility.isNull(pUser)
				+ " AND "
				+ ManagerUser.TABLE_TEACHER_CLASSROOM
				+ ".id_classroom= "
				+ Utility.isNull(pClass)
				+ " AND "
				+ ManagerUser.TABLE_TEACHER_CLASSROOM
				+".id_teaching ="
				+ManagerTeaching.TABLE_TEACHING
				+".id_teaching";
				// Inviamo la Query al database
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Consente la lettura di un record dal ResultSet.
	 * 
	 * @param pRs
	 *            Il risultato della query.
	 * @return Ritorna l'insegnamento letto.
	 * 
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Teaching loadRecordFromRs(ResultSet pRs) throws SQLException,
			InvalidValueException {
		Teaching teaching = new Teaching();
		teaching.setName(pRs.getString(("name")));
		teaching.setId(pRs.getInt("id_teaching"));

		return teaching;
	}

	/**
	 * Consente la lettura dei record dal ResultSet.
	 * 
	 * @param pRs
	 *            Il risultato della query.
	 * @return Ritorna la collection di insegnamenti letti.
	 * 
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Collection<Teaching> loadRecordsFromRs(ResultSet pRs)
			throws SQLException, InvalidValueException {
		Collection<Teaching> result = new Vector<Teaching>();
		do {
			result.add(loadRecordFromRs(pRs));
		} while (pRs.next());
		return result;
	}

}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Vector;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per rimuovere Insegnamenti ad un docente
 * 
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletRemoveTeachingAsTeacher extends HttpServlet {




	/**
	 * 
	 */
	private static final long serialVersionUID = -8007609698841510837L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/teacherTeachings.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();

		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		ManagerClassroom managerClass = ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
					+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			// //Mi servono i 3 Id user class teachings(che non so quanti ne sono)
			int idTeacher = (int) ((User) session.getAttribute("user")).getId();
			User teacher = managerUser.getUserById(idTeacher); 
			int idClass = Integer.valueOf(pRequest.getParameter("classId"));
			String[] idTeachingList = pRequest.getParameterValues("unselectedTeachings");
			int nTeaching =idTeachingList.length;
			int temp;
			//Collection<Teaching> listSelcected = new Vector<Teaching>();
			if(idTeachingList==null)
				gotoPage = "./error.jsp";
			else{
				for(int i=0;i<nTeaching;i++){
					temp = Integer.valueOf(idTeachingList[i]);
					if(managerUser.hasTeaching(teacher,managerTeaching.getTeachingById(temp),managerClass.getClassroomByID(idClass))){
						managerUser.removeTeacherAtClassroomTeaching(teacher,idClass,temp);
						//listSelcected.add(managerTeaching.getTeachingById(temp));
					}
				}
			}
			//session.setAttribute("teachingListTeacher", listSelcected);
		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
			+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.bean;

import java.io.Serializable;

public class RegisterLine implements Serializable {

	/**
	 * Classe che modella una linea del registro 
	 * @author Nicola Pisanti
	 * @version 1.0 
	 */
	private static final long serialVersionUID = -6010085925185873838L;
	
	private UserListItem student;
	private Absence absence;
	private Delay delay;
	
	public RegisterLine(){
		absence=null;
		delay=null;
		
	}
	
	/**
	 * Metodo che restituisce lo studente di questa riga del registro
	 * @return un oggetto di tipo User che rappresenta lo studente
	 */
	public UserListItem getStudent() {
		return student;
	}
	/**
	 * Metodo che setta lo studente di questa riga del registro
	 * @param un oggetto di tipo User che rappresenta lo studente da inserire
	 */
	public void setStudent(UserListItem student) {
		this.student = student;
	}
	/**
	 * Metodo che restituisce l'assenza dello studente di questa riga del registro
	 * @return un oggetto di tipo Absence che rappresenta l'assenza, oppure null se lo studente era presente
	 */
	public Absence getAbsence() {
		return absence;
	}
	/**
	 * Metodo che setta l'assenza dello studente di questa riga del registro 
	 * @param un oggetto di tipo Absence da settare
	 */
	public void setAbsence(Absence absence) {
		this.absence = absence;
	}
	/**
	 * Metodo che restituisce il ritardo dello studente di questa riga del registro 
	 * @return un oggetto di tipo Delay che rappresenta il ritardo, oppure null se lo studente era arrivato in orario o era assente
	 */
	public Delay getDelay() {
		return delay;
	}
	/**
	 * Metodo che setta il ritardo dello studente di questa riga del registro 
	 * @param un oggetto di tipo Delay da settare
	 */
	public void setDelay(Delay delay) {
		this.delay = delay;
	}

}

package smos.application.teachingManagement;

import smos.Environment;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per modificare un insegnamento.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletUpdateTeaching extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 943677173076169934L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./teachingList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		Teaching teaching = (Teaching) session.getAttribute("teaching");
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}

			teaching.setName((pRequest.getParameter("name")));
			teaching.setId(teaching.getId());

			if (!managerTeaching.exists(teaching)) {
				managerTeaching.update(teaching);
			} 
			else if(teaching.getId() == managerTeaching.getTeachingId(teaching))
					managerTeaching.update(teaching);
			else {

				throw new DuplicatedEntityException(
						"Insegnamento gi esistente");
			}

		} catch (SQLException SQLException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.classroomManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

/**
 * Servlet per mostrare i dettagli di una classe
 * 
 * @author Vecchione Giuseppe
 * 
 */
public class ServletShowClassroomDetails extends HttpServlet {

	
	private static final long serialVersionUID = 5821337495655009521L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/classroomManagement/showClassroomDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		int classroomId = 0;
		Classroom classroom= null;
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			classroomId = Integer.valueOf(pRequest.getParameter("idClassroom"));
			classroom = managerClassroom.getClassroomByID(classroomId);
			session.setAttribute("classroom", classroom);
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
	} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.application.reportManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.ManagerVotes;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per inserire una pagella di uno studente.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletInsertReport extends HttpServlet {

	private static final long serialVersionUID = 8121220088758892213L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./showReports";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Teaching> teachingList = null;
		ManagerVotes managerVotes = ManagerVotes.getInstance();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla funzionalita'!";
				gotoPage = "./error.jsp";
			}
			Classroom classroom = (Classroom) session.getAttribute("classroom");
			// Lista teaching
			teachingList = managerTeaching.getTeachingsByClassroomId(classroom
					.getIdAddress());
			Iterator<Teaching> itTeaching = teachingList.iterator();
			Integer year = (Integer) session.getAttribute("selectedYear");
			UserListItem student = (UserListItem) session
					.getAttribute("student");
			// Quadrimestre
			int turn = (Integer) session.getAttribute("q");
			Teaching teachingTemp = null;
			int idTemp;
			String write, oral, lab;
			gotoPage += "?student=" + student.getId() + "&q=" + turn;
			while (itTeaching.hasNext()) {
				teachingTemp = itTeaching.next();
				idTemp = teachingTemp.getId();
				write = "scritto_" + idTemp;
				oral = "orale_" + idTemp;
				lab = "laboratorio_" + idTemp;
				write = pRequest.getParameter(write);
				oral = pRequest.getParameter(oral);
				lab = pRequest.getParameter(lab);
				Votes newVotes = new Votes();
				int writeInt=0, oralInt=0,labInt=0;
				if(write!="")
					writeInt = Integer.valueOf(write);
				if(oral!="")
					oralInt = Integer.valueOf(oral);
				if(lab!="")
					labInt = Integer.valueOf(lab);
				if (writeInt != 0 || oralInt != 0 || labInt != 0) {
					newVotes.setAccademicYear(year);
					newVotes.setId_user(student.getId());
					newVotes.setLaboratory(labInt);
					newVotes.setOral(oralInt);
					newVotes.setTeaching(idTemp);
					newVotes.setTurn(turn);
					newVotes.setWritten(writeInt);
					managerVotes.insert(newVotes);
				}

			}

			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (MandatoryFieldException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare un report degli insegnamenti di un docente
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletReportTeachings extends HttpServlet {

	

	/**
	 * 
	 */
	private static final long serialVersionUID = 9020697390947529914L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/userManagement/showTeacherDetails.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Teaching> teachingList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		User teacher = (User) session.getAttribute("user");
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			//recuperiamo l'anno accademico selezionato
			int academicYear = Integer.valueOf(pRequest.getParameter("accademicYear"));
			ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
			ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
			//Calcoliamo l'elenco delle classi in cui insegna il docente in base all'anno selezionato
			Collection<Classroom> classroomList = null;
			classroomList = managerClassroom.getClassroomsByTeacherAcademicYear(teacher, academicYear);
			session.setAttribute("classroomList", classroomList);
			session.setAttribute("selectedYear", academicYear);
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (MandatoryFieldException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.userManagement;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet utilizzata per effettuare il logout dell'utente.
 * 
 * @author napolitano Vincenzo.
 *
 */
public class ServletLogout extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, HttpServletResponse pResponse) throws ServletException, IOException {
		
		pRequest.getSession().invalidate();
		pResponse.sendRedirect("./index.htm");
	}
	
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, HttpServletResponse pResponse) throws ServletException, IOException {
		this.doGet(pRequest, pResponse);
	}
}

package smos.application.addressManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import smos.Environment;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.*;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletAddressTeachings extends HttpServlet {

	/**
	 * Servlet utilizzata per visualizzare gli insegnamenti associati ad un indirizzo.
	 * 
	 * @author Vecchione Giuseppe.
	 * 
	 */
	private static final long serialVersionUID = 239937097347087502L;

	
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/addressManagement/addressTeachings.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerTeaching managerTeaching =ManagerTeaching.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			Collection<Teaching> teachingList = managerTeaching.getTeachings();
			session.setAttribute("teachingList", teachingList);

		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
	} catch (InvalidValueException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}


	
}

package smos.application.teachingManagement;

import smos.Environment;
import smos.bean.Teaching;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerTeaching;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli insegnamenti.
 * 
 * @author Giulio D'Amora.
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletShowTeachingList extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1361713427864776624L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement/teachingManagement/showTeachingList.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Teaching> teachingList = null;
		ManagerTeaching managerTeaching = ManagerTeaching.getInstance();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");

		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage = "L'Utente collegato non ha accesso alla funzionalita'!";
				gotoPage = "./error.jsp";
			}

			teachingList = managerTeaching.getTeachings();

			session.setAttribute("teachingList", teachingList);
			pResponse.sendRedirect(gotoPage);
			return;

		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.RegisterLine;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;

public class ServletShowRegister extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4054623648928396283L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showRegister.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
		ManagerRegister  managerRegister= ManagerRegister.getInstance();
		Collection<RegisterLine> register = null;
		int year;
		int month;
		int day;
		
		String date=pRequest.getParameter("date");
		int idClass = Integer.valueOf(pRequest.getParameter("idClassroom"));
		
		String [] datevalues;
		datevalues = date.split("/");
		year = Integer.valueOf(datevalues[2]);
		month = Integer.valueOf(datevalues[1]);
		day = Integer.valueOf(datevalues[0]);
		
		try {
			register= managerRegister.getRegisterByClassIDAndDate(idClass, Utility.String2Date(date));
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			//settare le cose da passare alla session, usare session.setAttribute(String, attribute) 
			
			
			
			Classroom classroom= managerClassroom.getClassroomByID(idClass);
			
			session.setAttribute("register", register);
			session.setAttribute("year", year);
			session.setAttribute("month", month);
			session.setAttribute("day", day);
			
			
			session.setAttribute("classroom", classroom);
			
			//prendere l'academic year dalla session
			pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	
	
}

package smos.utility;

import smos.exception.EntityNotFoundException;
import smos.storage.connectionManagement.DBConnection;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.TimeZone;
import java.sql.*;
import java.text.DateFormat;

/**
 * Questa classe contiene un insieme di utility per la gestione del sistema.
 */
public class Utility {

	/**
	 * Costanti
	 */
	public static final char SLASH = (char) 47;// carattere '/' in ascii

	/**
	 * 
	 */
	public static final char BACKSLASH = (char) 92;// carattere '\' in ascii

	/**
	 * 
	 */
	public static final String[] day = { "lunedi", "martedi", "mercoledi",
			"giovedi", "venerdi", "sabato"};
	
	/**
	 * 
	 */
	public static final String[] validHour = { "08:00", "08:30", "09:00",
		"09:30", "10:00", "10:30", "11:00", "11:30", "12:00", "12:30",
		"13:00", "13:30", "14:00", "14:30", "15:00", "15:30", "16:00",
		"16:30", "17:00", "17:30", "18:00", "18:30", "19:00", "19:30",
		"20:00" };
	
	public static final String[] month = {"gen","feb","mar","apr","mag","giu","lug","ago","set","ott","nov","dic"};

	/**
	 * 
	 */
	public static final String[] requestState = { "effettuata", "rifiutata",
			"accettata", "eliminata" };
	
	//Variabili da impostare all'avvio di Tomcat
	
	//Variabili per l'aspetto grafico del programma
	private static String imageHeaderPath = "";
	private static String imageHeaderLogoPath = "";
	private static String imageLeftColumn = "";
	private static String textFooter = "";
	//server smtp per invio e-mail
	private static String serverSmtp = "smtp.tele2.it";
	//Giorni minimi di distanza dall'esame per sottoscrivere o eliminare una prenotazione
	private static int needDayBeforeExam = 0;
	//Giorni massimi di distanza dall'esame per sottoscrivere una prenotazione
	private static int maxDayBeforeExam = 0;
	//pdf path per il percorso di memorizzazione dei file pdf
	private static String pdfPath = "";
	// upload path per il percorso di memorizzazione dei file per l'importazione dei dati
	private static String uploadPath = "";
	//Variabili per la connessione al database
	private static String driverMySql = "com.mysql.jdbc.Driver";
	private static String fullPathDatabase = "jdbc:mysql://localhost:3306/smos";
	private static String userName = "root";
	private static String password = "";
	private static int maxPoolSize = 200;
	private static int waitTimeout = 120000;
	private static int activeTimeout = 600000;
	private static int poolTimeout = 27000000;	
	
	

	/**
	 * Ritorna, dati un campo e una tabella, il valore massimo del campo nella
	 * tabella.
	 * 
	 * @param pField
	 *            Il campo di cui vogliamo recuperare il valore massimo.
	 * @param pTable
	 *            La tabella in cui ricercare le informazioni richieste.
	 * @return Ritorna il valore massimo, del campo pField, passato come
	 *         parametro, presente nella tabella pTable, passata come parametro.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	synchronized static public int getMaxValue(String pField, String pTable)
			throws EntityNotFoundException, ConnectionException, SQLException {

		int value = 0;
		Connection connect = null;
		try {
			/*
			 * Se non sono stati forniti il campo e la tabella restituiamo un
			 * codice di errore
			 */
			if (pField.equals(""))
				throw new EntityNotFoundException();
			if (pTable.equals(""))
				throw new EntityNotFoundException();

			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * richieste
			 */
			String tSql = "SELECT max(" + pField + ") as new_field FROM "
					+ pTable;

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);

			if (tRs.next())
				value = tRs.getInt("new_field");
			else
				throw new EntityNotFoundException();

			return value;
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Converte una data in una stringa formattata per il database.
	 * 
	 * @param pDate
	 *            La data da convertire.
	 * @return Ritorna la data formattata per il database.
	 */
	static public String date2SQLString(java.util.Date pDate, boolean pHour) {
		
		TimeZone tz = TimeZone.getDefault();
		Calendar calendar = Calendar.getInstance(tz);
		calendar.setTime(pDate);
		
		
		int year = calendar.get(Calendar.YEAR);
		int month = calendar.get(Calendar.MONTH) + 1;
		int day = calendar.get(Calendar.DATE);
		
		String result = year + "-" + month + "-" + day ;
		
		int hour = calendar.get(Calendar.HOUR_OF_DAY);
		int min = calendar.get(Calendar.MINUTE);
		int sec = calendar.get(Calendar.SECOND);
		
		if (pHour){
			result = result + " " + hour + ":" + min + ":" + sec; 
		}
						

		return result;
	}

	/**
	 * Controlla se la stringa passata come parametro e' null.
	 * 
	 * @param pStr
	 *            La stringa da controllare.
	 * 
	 * @return <code>null</code> se la stringa e' null Altrimenti la stringa e'
	 *         passata al metodo <code>Replace</code>
	 * 
	 * @see #Replace
	 */
	static public String isNull(String pStr) {
		String tTmp;

		if (pStr == null) 
			tTmp = "null";

		else {
			pStr = ReplaceAllStrings(pStr, "'", "\\'");
			pStr = ReplaceAllStrings(pStr, "\"", "\\" + "\"");
			tTmp = "'" + pStr + "'";
		}
		return tTmp;
	}

	/**
	 * Controlla se un dato intero � null.
	 * 
	 * @param pInt
	 *            Il dato intero da controllare.
	 * @return Ritorna il dato in formato stringa se il dato � diverso da zero,
	 *         altrimenti la stringa null.
	 */
	static public String isNull(Integer pInt) {
		String tIntString;

		if (pInt == null)
			tIntString = "null";
		else
			tIntString = pInt.toString();
		return tIntString;
	}

	/**
	 * Controlla se una data e' null.
	 * 
	 * @param pDate
	 *            la data da controllare.
	 * 
	 * @return Ritorna la stringa che rappresenta la data passata in input,
	 *         formattata per il database.
	 */
	static public String isNull(java.util.Date pDate) {

		return "'" + date2SQLString(pDate,false) + "'";
	}

	static public String clear(String pString){
		int start = 0;
		int start2 = 0;
		int end = 0;
		int end2 = 0;
		String result = "";
		String result2 = "";
			
		while (end >= 0){
		end = pString.indexOf("'", start);
		
		if (end >= 0){
		
			result= result +pString.substring(start, end);
			result = result + "\\'";
			start = end+1;
			
		} else 
			result = result + pString.substring(start);
		}
		
		while (end2 >= 0){
			end2 = result.indexOf("\n", start2);
			
			if (end2 >= 0){
				
				result2= result2 +result.substring(start2, end2-1);
				result2 = result2 + " ";
				start2 = end2+1;
				
			} else 
				result2 = result2 + result.substring(start2);
			}
		return(result2);	
	}
	
	/**
	 * Converte una String in Integer.
	 * 
	 * @param pStr
	 *            La String da convertire.
	 * 
	 * @return L'Integer contenuto nella String <code>0</code> se non �
	 *         possibile la conversione.
	 * 
	 */
	static public Integer String2Integer(String pStr) {
		Integer tInteger;

		if ((pStr == null) || (pStr.compareTo("") == 0))
			tInteger = new Integer(0);
		else
			try {
				tInteger = Integer.decode(pStr);
			} catch (Exception e) {
				tInteger = new Integer(0);
			}

		return tInteger;
	}

	/**
	 * Sostituisce i caratteri ' e \ con '' nella stringa passata come 
	 * parametro.
	 * 
	 * @param pStr
	 *            La stringa da trasformare.
	 * 
	 * @return La tringa trasformata.
	 */
	static public String Replace(String pStr) {
		String tRis;

		tRis = pStr.replaceAll("\"", "'");

		tRis = tRis.replaceAll("'", "\\'");

		return tRis;
	}

	/**
	 * Sostituisce il carattere ' con la stringa " " nella stringa passata come
	 * parametro.
	 * 
	 * @param pStr
	 *            La stringa da trasformare.
	 * 
	 * @return La tringa trasformata.
	 */
	static public String ReplaceQuote(String pStr) {
		String tRis;

		tRis = pStr.replaceAll("'", " ");
		return tRis;
	}

	/**
	 * Esegue un'operazione sul database tramite una stringa SQL.
	 * 
	 * @param pConnect
	 *            La connessione al database.
	 * @param pSql
	 *            La stringa SQL.
	 * 
	 * @return Il numero di record coinvolti nell'operazione.
	 * 
	 * @throws SQLException
	 */
	static public int executeOperation(Connection pConnect, String pSql)
			throws SQLException {
		Statement stmt = pConnect.createStatement();
		int tResult = stmt.executeUpdate(pSql);
		stmt.close();
		return tResult;
	}

	/**
	 * Esegue una Query SQL sul database.
	 * 
	 * @param pConnect
	 *            La connessione al database.
	 * @param pSql
	 *            La stringa SQL.
	 * 
	 * @return Il numero di record coinvolti nell'operazione.
	 * 
	 * @throws SQLException
	 */
	static public ResultSet queryOperation(Connection pConnect, String pSql)
			throws SQLException {

		Statement stmt = pConnect.createStatement();
		return stmt.executeQuery(pSql);
	}

	/**
	 * Converte un dato booleano in intero.
	 * 
	 * @param pBol
	 *            Il valore booleano da convertire in intero.
	 * 
	 * @return Il valore intero corrispondente al valore booleano passato come
	 *         parametro.
	 */
	static public int BooleanToInt(boolean pBol) {
		if (pBol == true)
			return 1;
		else
			return 0;
	}

	/**
	 * Converte un dato intero in booleano.
	 * 
	 * @param pInt
	 *            Il valore intero da convertire in booleano.
	 * 
	 * @return Il valore booleano corrispondente al valore intero passato come
	 *         parametro.
	 */
	static public boolean IntToBoolean(int pInt) {
		if (pInt == 1)
			return true;
		else
			return false;
	}

	/**
	 * Restituisce la data corrente.
	 * 
	 * @return La data corrente.
	 */
	static public java.util.Date today() {
		Calendar calendar = Calendar.getInstance();
		java.util.Date creationDate = calendar.getTime();
		return creationDate;
		// java.util.Date creationDate = new java.util.Date();
		// Timestamp timeStamp = new Timestamp(creationDate.getTime());
		// return (java.util.Date) timeStamp;
	}

	/**
	 * Restituisce la data contenuta nella stringa in input.
	 * 
	 * @param pDate
	 *            La stringa di cui effettuare il parse in un data.
	 * 
	 * @return La data convertita.
	 */
	static public java.util.Date String2Date(String pDate) {
		try {
			DateFormat dfDate = DateFormat.getDateInstance();
			java.util.Date tDate = dfDate.parse(pDate,
					new java.text.ParsePosition(0));
			java.sql.Timestamp timeStamp = new java.sql.Timestamp(tDate
					.getTime());

			return (java.util.Date) timeStamp;
		} catch (Exception e) {
			try {
				DateFormat dfDate = DateFormat.getDateInstance(
						DateFormat.SHORT, java.util.Locale.ITALY);
				java.util.Date tDate = dfDate.parse(pDate,
						new java.text.ParsePosition(0));
				java.sql.Timestamp timeStamp = new java.sql.Timestamp(tDate
						.getTime());

				return (java.util.Date) timeStamp;
			} catch (Exception e2) {
				return null;
			}
		}
	}

	/**
	 * Restituisce la data in input in formato String.
	 * 
	 * @param pDate
	 *            La Data da convertire.
	 * @param pHour
	 * 
	 * @return La data convertita.
	 */
	static public String Date2String(java.util.Date pDate, boolean pHour) {
		try {
			DateFormat dfDate = DateFormat.getDateInstance(DateFormat.SHORT);
			DateFormat dfTime = DateFormat.getTimeInstance(DateFormat.SHORT);
			if (pHour)
				return dfDate.format(pDate) + " " + dfTime.format(pDate);
			else
				return dfDate.format(pDate);
		} catch (Exception e) {
			return "";
		}
	}

	/**
	 * @param sourceStr
	 * @param searchFor
	 * @param replaceWith
	 * @return la stringa corrispondente a searchBuffer
	 */
	public static String ReplaceAll(String sourceStr, String searchFor,
			String replaceWith) {
		StringBuffer searchBuffer = new StringBuffer(sourceStr);
		int hits = 0;

		while (searchBuffer.toString().toUpperCase().indexOf(
				searchFor.toUpperCase(), hits) >= 0) {
			int newIndex = searchBuffer.toString().toUpperCase().indexOf(
					searchFor.toUpperCase(), hits);
			searchBuffer.replace(newIndex, newIndex + searchFor.length(),
					replaceWith);
			hits++;
		}

		return searchBuffer.toString();
	}

	// La funzione precedente va in loop se sostituisco "\" con "\\"
	// usiamo allora due variabile la prima viene "consumata" ad ogni occorrenza
	// del pattern
	/**
	 * @param sourceStr
	 * @param searchFor
	 * @param replaceWith
	 * @return newStringBuffer
	 */
	public static String ReplaceAllStrings(String sourceStr, String searchFor,
			String replaceWith) {
		StringBuffer searchBuffer = new StringBuffer(sourceStr);
		StringBuffer newStringBuffer = new StringBuffer("");

		while (searchBuffer.toString().toUpperCase().indexOf(
				searchFor.toUpperCase()) >= 0) {
			int newIndex = searchBuffer.toString().toUpperCase().indexOf(
					searchFor.toUpperCase());
			newStringBuffer.append(searchBuffer.substring(0, newIndex));
			newStringBuffer.append(replaceWith);
			searchBuffer = new StringBuffer(searchBuffer.substring(newIndex
					+ searchFor.length(), searchBuffer.length()));
		}

		newStringBuffer.append(searchBuffer);
		return newStringBuffer.toString();
	}

	/**
	 * @param sourceStr
	 * @param removeStr
	 */
	public static void RemoveAll(String sourceStr, String removeStr) {
		int nextOccurence;

		while (sourceStr.toString().toUpperCase().indexOf(
				removeStr.toUpperCase()) >= 0) {
			nextOccurence = sourceStr.toString().toUpperCase().indexOf(
					removeStr.toUpperCase());
			sourceStr = sourceStr.substring(0, nextOccurence)
					+ sourceStr.substring(nextOccurence + removeStr.length(),
							sourceStr.length());
		}
	}
	
	
	/**
	 * Calcola la distanza in giorni tra 2 date passate.
	 */
	@SuppressWarnings("deprecation")
	public static int daysBetween(Date today, Date reservationDate){
		int daysBetween = 0;
		long millisecBetween = 0;
		final int millisecInADay = 86400000;
		
		GregorianCalendar firstDate = new GregorianCalendar();
		GregorianCalendar secondDate = new GregorianCalendar();
		
		firstDate.set(today.getYear()+1900, today.getMonth(), today.getDate());
		secondDate.set(reservationDate.getYear()+1900, reservationDate.getMonth(), reservationDate.getDate());
		
		millisecBetween = secondDate.getTimeInMillis() - firstDate.getTimeInMillis();
		daysBetween = (int) (millisecBetween/millisecInADay);
		
		return (daysBetween);
	}

	/**
	 * @return Il percorso impostato per i pdf.
	 */
	@SuppressWarnings("static-access")
	public static String getPdfPath() {
		return Utility.pdfPath;
	}

	/**
	 * @param pPdfPath Il path da settare per i pdf.
	 */
	public static void setPdfPath(String pPdfPath) {
		Utility.pdfPath = pPdfPath;
	}
	
	/**
	 * @return Il percorso impostato per i file utilizzati 
	 * durante l'importazione dei dati.
	 */
	@SuppressWarnings("static-access")
	public static String getUploadPath() {
		return Utility.uploadPath;
	}

	/**
	 * @param pUploadPath Il path da settare per i file utilizzati 
	 * durante l'importazione dei dati.
	 */
	public static void setUploadPath(String pUploadPath) {
		Utility.uploadPath = pUploadPath;
	}

	/**
	 * @return Il server smtp da utilizzare per l'invio
	 * 		   automatizzato delle e-mail.
	 */
	@SuppressWarnings("static-access")
	public static String getServerSmtp() {
		return Utility.serverSmtp;
	}
	
	/**
	 * @param pServerSmtp il server smtp da settare.
	 */
	public static void setServerSmtp(String pServerSmtp) {
		Utility.serverSmtp = pServerSmtp;
	}

	/**
	 * @return the activeTimeout
	 */
	public static int getActiveTimeout() {
		return Utility.activeTimeout;
	}

	/**
	 * @param activeTimeout the activeTimeout to set
	 */
	public static void setActiveTimeout(int pActiveTimeout) {
		Utility.activeTimeout = pActiveTimeout;
	}

	/**
	 * @return the driverMySql
	 */
	public static String getDriverMySql() {
		return Utility.driverMySql;
	}

	/**
	 * @param driverMySql the driverMySql to set
	 */
	public static void setDriverMySql(String pDriverMySql) {
		Utility.driverMySql = pDriverMySql;
	}

	/**
	 * @return the fullPathDatabase
	 */
	public static String getFullPathDatabase() {
		return Utility.fullPathDatabase;
	}

	/**
	 * @param fullPathDatabase the fullPathDatabase to set
	 */
	public static void setFullPathDatabase(String pFullPathDatabase) {
		Utility.fullPathDatabase = pFullPathDatabase;
	}

	/**
	 * @return the maxPoolSize
	 */
	public static int getMaxPoolSize() {
		return Utility.maxPoolSize;
	}

	/**
	 * @param maxPoolSize the maxPoolSize to set
	 */
	public static void setMaxPoolSize(int pMaxPoolSize) {
		Utility.maxPoolSize = pMaxPoolSize;
	}

	/**
	 * @return the password
	 */
	public static String getPassword() {
		return Utility.password;
	}

	/**
	 * @param password the password to set
	 */
	public static void setPassword(String pPassword) {
		Utility.password = pPassword;
	}


	/**
	 * @return the poolTimeout
	 */
	public static int getPoolTimeout() {
		return Utility.poolTimeout;
	}

	/**
	 * @param poolTimeout the poolTimeout to set
	 */
	public static void setPoolTimeout(int pPoolTimeout) {
		Utility.poolTimeout = pPoolTimeout;
	}

	/**
	 * @return the userName
	 */
	public static String getUserName() {
		return Utility.userName;
	}

	/**
	 * @param userName the userName to set
	 */
	public static void setUserName(String pUserName) {
		Utility.userName = pUserName;
	}

	/**
	 * @return the waitTimeout
	 */
	public static int getWaitTimeout() {
		return Utility.waitTimeout;
	}

	/**
	 * @param waitTimeout the waitTimeout to set
	 */
	public static void setWaitTimeout(int pWaitTimeout) {
		Utility.waitTimeout = pWaitTimeout;
	}

	/**
	 * @return the imageHeaderPath
	 */
	public static String getImageHeaderPath() {
		return Utility.imageHeaderPath;
	}

	/**
	 * @param imageHeaderPath the imageHeaderPath to set
	 */
	public static void setImageHeaderPath(String pImageHeaderPath) {
		Utility.imageHeaderPath = pImageHeaderPath;
	}

	/**
	 * @return the textFooter
	 */
	public static String getTextFooter() {
		return Utility.textFooter;
	}

	/**
	 * @param textFooter the textFooter to set
	 */
	public static void setTextFooter(String pTextFooter) {
		Utility.textFooter = pTextFooter;
	}

	/**
	 * @return the imageLeftColumn
	 */
	public static String getImageLeftColumn() {
		return Utility.imageLeftColumn;
	}

	/**
	 * @param imageLeftColumn the imageLeftColumn to set
	 */
	public static void setImageLeftColumn(String pImageLeftColumn) {
		Utility.imageLeftColumn = pImageLeftColumn;
	}
	
	public static String getImageLogoHeaderPath() {
		return Utility.imageHeaderLogoPath;
	}

	public static void setImageLogoHeaderPath(String pImageHeaderLogoPath) {
		Utility.imageHeaderLogoPath = pImageHeaderLogoPath;
	}

	/**
	 * @return the needDayBeforeExam
	 */
	public static int getNeedDayBeforeExam() {
		return Utility.needDayBeforeExam;
	}

	/**
	 * @param needDayBeforeExam the needDayBeforeExam to set
	 */
	public static void setNeedDayBeforeExam(int pNeedDayBeforeExam) {
		Utility.needDayBeforeExam = pNeedDayBeforeExam;
	}

	/**
	 * @return the maxDayBeforeExam
	 */
	public static int getMaxDayBeforeExam() {
		return Utility.maxDayBeforeExam;
	}

	/**
	 * @param maxDayBeforeExam the maxDayBeforeExam to set
	 */
	public static void setMaxDayBeforeExam(int pMaxDayBeforeExam) {
		Utility.maxDayBeforeExam = pMaxDayBeforeExam;
	}
	
	public static String getActualDate() {
		GregorianCalendar gc = new GregorianCalendar();

		String date="";
		int year=gc.get(GregorianCalendar.YEAR);
		
		int month=gc.get(GregorianCalendar.MONTH)+1;
		String months="";
		if(month<10){
			months="0"+month;
		}else{
			months= months+month;
		}
		
		int day=gc.get(GregorianCalendar.DAY_OF_MONTH);
		String days="";
		if(day<10){
			days="0"+day;
		}else{
			days= days+day;
		}
		
		date= date + days+"/"+months+"/"+year;
	
		return date;
		
	}
}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione generata quando si tenta
  * di inserire un'entit senza specificare un campo obbligatorio
  */
public class MandatoryFieldException extends Exception {
	
	private static final long serialVersionUID = -4818814194670133466L;

	/**
	 * Genera l'eccezione senza un messagio di errore associato.
	 */
	public MandatoryFieldException() {
		super("Mandatory Field Missing!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public MandatoryFieldException(String pMessage) {
		super(pMessage);
	}
	
	
}
package smos.bean;


import java.io.Serializable;
/**
 *  Classe utilizzata per modellare il ruolo di un utente.
 *
 * @author Bavota Gabriele, Carnevale Filomena.
 * 
 */
public class Role implements Serializable {
	
	private static final long serialVersionUID = 8833734317107515203L;
	
	
	
	/**
	 * L'id del ruolo amministratore
	 */
	public static final int ADMIN = 1;
	
	/**
	 * L'id del ruolo di docente
	 */
	public static final int TEACHER = 2;
	
	/**
	 * L'id del ruolo studente
	 */
	
	public static final int STUDENT	 = 3;
	
	/**
	 * L'id del ruolo geniotore
	 */
	
	public static final int PARENT = 4;
	
	/**
	 * L'id del ruolo ata
	 */
	
	public static final int ATA = 5;
	
	/**
	 * L'id del ruolo direzione
	 */
	
	public static final int DIRECTOR = 6;

}

/*
 * ConnectionPoolDataSource
 *
 */

package smos.storage.connectionManagement;

import smos.storage.connectionManagement.exception.NotImplementedYetException;

import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;
import java.util.Vector;
import javax.sql.DataSource;

/**
 * Realizzazione del pool di connessioni tramite l'implementazione
 * dell'interfaccia java.sql.DataSource. Il pool controlla periodicamente le
 * connessioni attive e quelle che sono pool, ossia quelle rilasciate ma ancora
 * utilizzabili (presenti cioe' in memoria). Il tempo di rilascio delle
 * connessioni attive e di quelle pool � rappresentato da due parametri presenti
 * all'interno della classe e che sono connectionPoolCloseTimeout e
 * inactiveMaxTimeout; tali valori cosi come tutti gli altri inerenti al pool
 * hanno un loro valore di default, parametrizzabile tramite il file di
 * properties connection.properties
 */

public class ConnectionPoolDataSource implements DataSource {

    /**
     * Thread inside della classe ConnectionPoolDataSource che stabilisce ogni
     * connectionPoolCloseTimeout millisecondi il rilascio delle connessioni
     * pool.
     */
    private class ConnectionCloser extends Thread {

        private long connectionActionTimestamp = 0;

        private int connectionPoolCloseTimeout = 300000;

        private long timeStamp = 0;

        /**
         * Costruttore che setta il tempo di rilascio delle connessioni pool
         * 
         * @author Di Giorgio Domenico, Cris Malinconico
         * @param pTime
         *            intervallo di tempo entro cui il pool svuota la lista
         *            delle connessioni pool.
         */
		private ConnectionCloser(int pTime) {
            setDaemon(true);
            setName("ConnectionPoolCloser");
            if (pTime > 0)
            	this.connectionPoolCloseTimeout = pTime;
        }

        /**
         * Ogni volta che una connessione genera un evento con un'invocazione di
         * getConnection() o release() il timestamp viene settato al valore
         * temporale corrente tramite questo metodo.
         */
		public void connectionEvent() {
			this.connectionActionTimestamp = System.currentTimeMillis();
        }

        /**
         * Controlla ogni connectionPoolCloseTimeout millisecondi se le
         * connessioni pool possono essere chiuse liberando in tal caso memoria.
         */
		public void run() {
            boolean working = true;
            while (working) {
                try {
                	this.timeStamp = System.currentTimeMillis();
                    Thread.sleep(this.connectionPoolCloseTimeout);
                    if (this.connectionActionTimestamp < this.timeStamp) {
                        closeAllConnections(ConnectionPoolDataSource.this.pool);
                    }
                } catch (InterruptedException e) {
                    working = false;
                    e.printStackTrace();
                } catch (SQLException e) {
                    working = false;
                    e.printStackTrace();
                }
            }
        }
    }

    private List<SMOSConnection> active = new Vector<SMOSConnection>();

    private Properties config = new Properties();

    private ConnectionCloser connectionCloser;

    private Driver driver;

    private String fullConnectionString;

    private long inactiveMaxTimeout = 20000;

    private int maxPoolSize;

    private List<Connection> pool = new Vector<Connection>();

    /**
     * Crea una nuova istanza del pool di connessioni.
     * 
     * @param pJdbcDriverName
     *            nome del driver jdbc
     * @param pFullConnectionString
     *            stringa di connessione con il database
     * @param pUser
     *            nome utente (amministratore del database)
     * @param pPassword
     *            password amministratore
     * @param pMaxPoolSize
     *            massimo numero di connessioni attive nel pool, deve essere
     *            maggiore di 0
     * @param pPoolTime
     *            intervallo di tempo entro il quale il pool sar� svuotato ogni
     *            volta delle sue connessioni pool (in ms).
     * @throws ClassNotFoundException
     *             se il driver jdbc non pu� essere trovato
     * @throws SQLException
     *             se occorre un problema durante la connessione al database
     * @throws IllegalArgumentException
     *             se i parametri forniti in input non sono validi
     */

    
	public ConnectionPoolDataSource(String pJdbcDriverName,
            String pFullConnectionString, String pUser, String pPassword,
            int pMaxPoolSize, int pPoolTime) throws ClassNotFoundException,
            SQLException {

        if (pMaxPoolSize < 1) {
            throw new IllegalArgumentException(
                    "maxPoolSize deve essere >0 ma �: " + pMaxPoolSize);
        }
        if (pFullConnectionString == null) {
            throw new IllegalArgumentException("fullConnectionString "
                    + "ha valore Null");
        }
        if (pUser == null) {
            throw new IllegalArgumentException("il nome utente ha valore Null");
        }
        this.maxPoolSize = pMaxPoolSize;
        this.fullConnectionString = pFullConnectionString;
        this.config.put("user", pUser);
        if (pPassword != null) {
            this.config.put("password", pPassword);
        }
        Class.forName(pJdbcDriverName);
        this.driver = DriverManager.getDriver(pFullConnectionString);
        this.connectionCloser = new ConnectionCloser(pPoolTime);
        this.connectionCloser.start();
    }

    /**
     * Restituisce la dimensione della lista delle connessioni attive.
     * 
     * @return la dimensione della lista delle connessioni attualmente attive.
     */
	public int activeSize() {
        return this.active.size();
    }

    /**
     * Svuota il pool di connessioni da quelle attive che non hanno pi� eseguito
     * operazioni per inactiveMaxTimeout millisecondi.
     * 
     */
    protected void clearActive() {
        long temp = 0;
        long TIME = System.currentTimeMillis();
        SMOSConnection adc = null;

        for (int count = 0; count < this.active.size(); count++) {
            adc = (SMOSConnection) this.active.get(count);
            temp = TIME - adc.getLastTime();
            if (temp >= this.inactiveMaxTimeout) {
                this.release(adc.getConnection());
            }
        }
    }

    /**
     * Chiude tutte le connessioni del pool sia quelle attive e sia quelle che
     * sono pool.
     * 
     * @author Di Giorgio Domenico, Cris Malinconico
     * @throws SQLException
     */
    public synchronized void closeAllConnections() throws SQLException {
        closeAllConnections(this.pool);
        closeAllConnections(this.active);
    }

    /**
     * Chiude tutte le connessioni indicate nella lista connection.
     * 
     * @author Di Giorgio Domenico, Cris Malinconico
     * @param pConnections
     *            la lista delle connesioni che devono essere chiuse.
     * @throws SQLException
     *             qualora sia impossibile chiudere una connessione.
     */
    private synchronized void closeAllConnections(List pConnections)
            throws SQLException {

        while (pConnections.size() > 0) {
            ConnectionWrapper conn = (ConnectionWrapper) pConnections.remove(0);
            conn.closeWrappedConnection();
        }
    }

    /**
     * Chiude tutte le connessioni del pool che sono nella lista pool.
     * 
     * @throws SQLException
     *             qualora sia impossibile chiudere una connessione.
     */
    public synchronized void closeAllPooledConnections() throws SQLException {
        closeAllConnections(this.pool);
    }

    /**
     * Metodo utilizzato da getConnection() per creare una nuova connessione
     * qualora nella lista delle pool non siano presenti.
     * 
     * @return una nuova connessione al DataBase.
     */
    private synchronized Connection createNewConnection() {
        Connection rawConn = null;
        try {
            rawConn = this.driver.connect(this.fullConnectionString, this.config);
            Connection conn = new ConnectionWrapper(rawConn, this);
            SMOSConnection ac = new SMOSConnection();
            ac.setConnection(conn);
            ac.setLastTime(System.currentTimeMillis());
            this.active.add(ac);
            return conn;
        } catch (SQLException e) {
            System.out.println("Creazione della connessione fallita "
                    + "in ConnectionPoolDataSource:" + e);
            return null;
        }
    }

    /**
     * Restituisce una connessione se il pool non � pieno, il controllo avviene
     * prima nella lista delle connessioni pool per evitare delle creazioni
     * inutili altrimenti una nuova connessione sar� creata.
     * 
     * @return la connessione al database qualora fosse possibile altrimenti
     *         un'eccezione viene generata
     * @see javax.sql.DataSource getConnection()
     * @throws SQLException
     *             Se un problema occorre durante la connessione al database
     *             incluso il fatto che il limite massimo delle connessioni
     *             attive venga raggiunto.
     */
    public synchronized Connection getConnection() throws SQLException {

        Connection connection = getPooledConnection(0);

        if (connection == null) {
            if (this.active.size() >= this.maxPoolSize) {
                throw new SQLException("Connection pool limit of "
                        + this.maxPoolSize + " exceeded");
            } else {
                connection = createNewConnection();
            }
        }
        this.connectionCloser.connectionEvent();
        //System.out.println("GET CONNECTION: " + active.size() + "/" + pool.size());
        return connection;
    }

    /**
     * Metodo non implementato
     * @param pArg1 
     * @param pArg2 
     * @return Connection
     * @throws SQLException 
     * 
     * @throws NotImplementedYetException
     */

    public Connection getConnection(String pArg1, String pArg2)
            throws SQLException {
        throw new NotImplementedYetException();
    }

    /**
     * Metodo non implementato
     * @return int
     * @throws SQLException 
     * 
     * @throws NotImplementedYetException
     */

    public int getLoginTimeout() throws SQLException {
        throw new NotImplementedYetException();
    }

    /**
     * Metodo non implementato
     * @return PrintWriter
     * @throws SQLException 
     * 
     * @throws NotImplementedYetException
     */

    public PrintWriter getLogWriter() throws SQLException {
        throw new NotImplementedYetException();
    }

    /**
     * Restituisce il numero massimo di connessioni attive
     * 
     * @return il numero massimo di connessioni attive.
     */

    public int getMaxPoolSize() {
        return this.maxPoolSize;
    }

    /**
     * Metodo utilizzato da getConnection() per stabilire se nella lista delle
     * connessioni pool ve ne sia qualcuna da poter riutilizzare.
     * 
     * @param pPoolIndex
     *            indice della lista delle connessioni pool (sempre 0).
     * @return una connesssione dalla lista di quelle pool qualora ne esista
     *         una.
     */
    private synchronized Connection getPooledConnection(int pPoolIndex) {
        SMOSConnection ac = new SMOSConnection();
        Connection connection = null;
        if (this.pool.size() > 0) {
            connection = (Connection) this.pool.remove(pPoolIndex);
            ac.setConnection(connection);
            ac.setLastTime(System.currentTimeMillis());
            this.active.add(ac);
        }
        return ac.getConnection();
    }

    /**
     * Restituisce la dimensione della lista delle connessioni pool
     * 
     * @return la dimensione della lista delle connessioni pool.
     */
    public int poolSize() {
        return this.pool.size();
    }

    /**
     * Rilascia una connessione, eliminandola da quelle attive ed inserendola in
     * quelle pool per poter essere successivamente riutilizzata.
     * 
     * @param pConnection
     *            La connessione che deve essere ritornata al pool.
     */
    public synchronized void release(Connection pConnection) {
        boolean exists = false;
        int activeIndex = 0;

        if (pConnection != null) {
            SMOSConnection adc = null;
            while ((activeIndex < this.active.size()) && (!exists)) {
                adc = (SMOSConnection) this.active.get(activeIndex);
                if (adc.equals(pConnection)) {
                	this.active.remove(adc);
                	this.pool.add(adc.getConnection());
                    exists = true;
                }
                activeIndex++;
            }
            this.connectionCloser.connectionEvent();
            //System.out.println("RELEASE CONNECTION: " + active.size() + "/" + pool.size());
        }
    }

    /**
     * Setta il tempo di vita delle connessioni attive in millisecondi.
     * 
     * @param pTimeOut
     *            tempo di vita della connessione.
     */

    public void setActivedTimeout(long pTimeOut) {
        if (pTimeOut > 0) {
        	this.inactiveMaxTimeout = pTimeOut;
        }
    }

    /**
     * Riazzera il tempo di vita della connessione dovutocall'esecuzione di
     * un'operazione.Da questo momento la connessione potr� essere attiva senza
     * eseguire alcuna operazione per altri inactiveMaxTimeout millisecondi.
     * 
     * @param pConnection
     *            la connessione che ha eseguito un'operazione e quindi pu�
     *            rimanere attiva.
     */

    void setLastTime(Connection pConnection) {
        boolean exists = false;
        int count = 0;
        SMOSConnection adc = null;

        while ((count < this.active.size()) && (!exists)) {
            adc = (SMOSConnection) this.active.get(count);
            count++;
            if (adc.equals(pConnection)) {
                adc.setLastTime(System.currentTimeMillis());
                exists = true;
            }
        }
    }

    /**
     * Metodo non implementato
     * @param pArg0 
     * @throws SQLException 
     * 
     * @throws NotImplementedYetException
     */
    public void setLoginTimeout(int pArg0) throws SQLException {
        throw new NotImplementedYetException();
    }

    /**
     * Metodo non implementato
     * @param pArg0 
     * @throws SQLException 
     * 
     * @throws NotImplementedYetException
     */
    public void setLogWriter(PrintWriter pArg0) throws SQLException {
        throw new NotImplementedYetException();
    }

    /**
     * Converte un oggetto della classe ConnectionPoolDataSource in String
     * 
     * @return la rappresentazione nel tipo String del pool di connessioni.
     */

    public String toString() {
        StringBuffer buf = new StringBuffer();

        buf.append("[");
        buf.append("maxPoolSize=").append(this.maxPoolSize);
        buf.append(", activeSize=").append(activeSize());
        buf.append(", poolSize=").append(poolSize());
        buf.append(", fullConnectionString=").append(this.fullConnectionString);
        buf.append("]");
        return (buf.toString());
    }

	
}

package smos.application.registerManagement;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.Note;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerRegister;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;


public class ServletShowNoteList extends HttpServlet {


	/**
	 * 
	 */
	private static final long serialVersionUID = 3700685645748508615L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "./registerManagement/showNoteList.jsp";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		//instanziare gli oggetti qua
		Collection<Note> notes= null;
		ManagerRegister managerRegister = ManagerRegister.getInstance(); 
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			} 
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			} 
			//settare le cose da passare alla session, usare session.setAttribute(String, attribute) 
			
			
			
			int idUser =Integer.valueOf(pRequest.getParameter("student")) ;
			User student = managerUser.getUserById(idUser); 	
			
		
			int year= ((Classroom) session.getAttribute("classroom")).getAcademicYear();
			
			
			
			notes= managerRegister.getNoteByIDUserAndAcademicYear(idUser, year);
			
			session.setAttribute("noteList", notes);
			session.setAttribute("student", student);
			pResponse.sendRedirect(gotoPage);
			return; 
			
		} catch (SQLException sqlException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}catch (IOException ioException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}
		
		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
	
		
	
	
	
	
}

package smos.storage;

import smos.bean.Teaching;
import smos.bean.UserListItem;
import smos.bean.Votes;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.connectionManagement.DBConnection;
import smos.storage.connectionManagement.exception.ConnectionException;
import smos.utility.Utility;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Vector;
import java.sql.Connection;

/**
 * 
 * Classe manager dei voti.
 * 
 * @author Luigi Colangelo
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */

public class ManagerVotes {
	private static ManagerVotes instance;

	/**
	 * Il nome della tabella dei voti.
	 */
	public static final String TABLE_VOTES = "votes";

	/**
	 * Il costruttore della classe.
	 */
	public ManagerVotes() {
		super();
	}

	/**
	 * Ritorna la sola istanza del voto esistente.
	 * 
	 * @return Ritorna l'istanza della classe.
	 */
	public static synchronized ManagerVotes getInstance() {
		if (instance == null) {
			instance = new ManagerVotes();
		}
		return instance;
	}

	/**
	 * Verifica l'esistenza di voto nel database.
	 * 
	 * @param pVotes
	 *            il voto da controllare.
	 * @return Ritorna true se esiste il voto passato come parametro,
	 *         false altrimenti.
	 * 
	 * @throws MandatoryFieldException
	 * @throws SQLException
	 * @throws ConnectionException
	 */
	public synchronized boolean exists(Votes pVotes)
			throws MandatoryFieldException, ConnectionException, SQLException {

		boolean result = false;
		Connection connect = null;

		if (pVotes.getId_votes() == 0)
			throw new MandatoryFieldException("Specificare l'id.");
		try {
			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			String sql = "SELECT * FROM " + ManagerVotes.TABLE_VOTES
					+ " WHERE id_votes = " + Utility.isNull(pVotes.getId_votes());

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, sql);

			if (tRs.next())
				result = true;

			return result;

		} finally {
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Inserisce un nuovo voto nella tabella Votes.
	 * 
	 * @param pVotes
	 *            il voto da inserire.
	 * 
	 * @throws SQLException
	 * @throws ConnectionException
	 * @throws MandatoryFieldException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized void insert(Votes pVotes)
			throws MandatoryFieldException, ConnectionException, SQLException,
			EntityNotFoundException, InvalidValueException {
		Connection connect = null;
		try {
			

			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();
			// Prepariamo la stringa Sql
			String sql = "INSERT INTO " + ManagerVotes.TABLE_VOTES
			        + " (id_user, id_teaching, written, oral, laboratory, AccademicYear, turn) "
					+ "VALUES ("
					+ Utility.isNull(pVotes.getId_user())
					+", "
					+ Utility.isNull(pVotes.getTeaching()) 
					+", "
					+ Utility.isNull(pVotes.getWritten())
					+", "
					+ Utility.isNull(pVotes.getOral())
					+", "
					+ Utility.isNull(pVotes.getLaboratory())
					+", "
					+ Utility.isNull(pVotes.getAccademicYear())
					+", "
					+ Utility.isNull(pVotes.getTurn())+ " )";

			Utility.executeOperation(connect, sql);

			pVotes.setId_votes(Utility.getMaxValue("id_votes",
					ManagerVotes.TABLE_VOTES));

		} finally {
			// rilascia le risorse

			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Aggiorna un voto presente nella tabella votes.
	 * 
	 * @param pVotes
	 *            Un voto da modificare
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws MandatoryFieldException
	 */
	public synchronized void update(Votes pVotes)
			throws ConnectionException, SQLException, EntityNotFoundException,
			MandatoryFieldException {
		Connection connect = null;

		try {
			if (pVotes.getId_votes() <= 0)
				throw new EntityNotFoundException(
						"Impossibile trovare il voto!");

			if (pVotes.getId_user() <= 0)
				throw new MandatoryFieldException("Specificare l'user del voto");
			if (pVotes.getTeaching() <= 0)
				throw new MandatoryFieldException("Specificare l'insegnamento del voto");
			if (pVotes.getAccademicYear() <= 0)
				throw new MandatoryFieldException("Specificare l'anno accademico");
			if (pVotes.getTurn() < 0)
				throw new MandatoryFieldException("Specificare il semestre ");
			// Prepariamo la stringa SQL
			String sql = "UPDATE " + ManagerVotes.TABLE_VOTES + " SET"
					+ " id_user = " + Utility.isNull(pVotes.getId_user())+","+" id_teaching= "
					+ Utility.isNull(pVotes.getTeaching())+","+" written= "
					+ Utility.isNull(pVotes.getWritten())+","+" oral= "
					+ Utility.isNull(pVotes.getOral())+","+" laboratory= "
					+ Utility.isNull(pVotes.getLaboratory())+","+" accademicYear= "
					+ Utility.isNull(pVotes.getAccademicYear())+","+" turn="
					+ Utility.isNull(pVotes.getTurn())
					+ " WHERE id_votes = "
					+ Utility.isNull(pVotes.getId_votes());

			// effettua una nuova connessione e invia la query
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			Utility.executeOperation(connect, sql);
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	/**
	 * Verifica se uno studente passato come parametro ha un voto assegnato nell'insegnamento passato
	 * come parametro nell'anno passato come parametro e nel quadrimestre passato come parametro
	 * 
	 * 
	 * @param pTeaching
	 *            L'insegnamento da controllare.
	 * @param pUserListItem
	 *            Lo studente da controllare
	 * 
	 * @return Ritorna l'id del voto -1 altrimenti
	 * 
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws InvalidValueException
	 */
	public synchronized int getIdVotes(Teaching pTeaching, int academicYear, int turn, UserListItem pUser)
			throws SQLException, EntityNotFoundException, ConnectionException,
			InvalidValueException {
		Connection connect = null;
		int result = -1;
		Votes v = null;
		if (pTeaching.getId() <= 0)
			throw new EntityNotFoundException("Specificare l'insegnamento");
		if (pUser.getId() <=0 )
			throw new EntityNotFoundException("Specificare l'utente");
		try {
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Preparimao la stringa sql
			String sql = "SELECT * FROM "
					+ ManagerVotes.TABLE_VOTES
					+ " WHERE id_teaching = "
					+ Utility.isNull(pTeaching.getId())
					+ " AND "
					+ ManagerVotes.TABLE_VOTES
					+ ".AccademicYear= "
					+ Utility.isNull(academicYear)
					+ " AND "
					+ ManagerVotes.TABLE_VOTES
					+ ".turn= "
					+ Utility.isNull(turn)
					+ " AND "
					+ ManagerVotes.TABLE_VOTES
					+ ".id_user= "
					+ Utility.isNull(pUser.getId());
			// Inviamo la Query al database
			ResultSet pRs = Utility.queryOperation(connect, sql);
			if (pRs.next()){
				v = this.loadRecordFromRs(pRs);
				result =v.getId_votes();
				
			}

			return result;

		} finally {
			// rilasciamo le risorse
			DBConnection.releaseConnection(connect);

		}
	}

	/**
	 * Elimina un voto dalla tabella votes.
	 * 
	 * @param pVotes
	 *            Il voto da eliminare.
	 * 
	 * @throws MandatoryFieldException
	 * @throws EntityNotFoundException
	 * @throws SQLException
	 * @throws ConnectionException
	 * @throws InvalidValueException
	 * 
	 */
	public synchronized void delete(Votes pVotes)
			throws ConnectionException, SQLException, EntityNotFoundException,
			MandatoryFieldException, InvalidValueException {
		Connection connect = null;

		try {
			// ManagerTeaching.getInstance().teachingOnDeleteCascade(pTeaching);
			connect = DBConnection.getConnection();
			// Prepariamo la stringa SQL
			String sql = "DELETE FROM " + ManagerVotes.TABLE_VOTES
					+ " WHERE id_votes = "
					+ Utility.isNull(pVotes.getId_votes());

			Utility.executeOperation(connect, sql);
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'id dell'insegnamento corrispondente all'id del voto passato come
	 * parametro.
	 * 
	 * @param pId
	 *            L'id del voto.
	 * @return Ritorna l'id dell' insegnamento.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 */
	
	/**
	 * Ritorna l'insegnamento corrispondente all'id passato come parametro.
	 * 
	 * @param pId
	 *            L'id dell'insegnamento.
	 * @return Ritorna l'insegnamento associato all'id passato come parametro.
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws EntityNotFoundException
	 * @throws InvalidValueException
	 */
	public synchronized Votes getVotesById(int pId)
			throws ConnectionException, SQLException, EntityNotFoundException,
			InvalidValueException {
		Votes result = null;
		Connection connect = null;
		try {

			if (pId <= 0)
				throw new EntityNotFoundException(
						"Impossibile trovare il voto!");

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Prepariamo la stringa SQL
			String sql = "SELECT * FROM " + ManagerVotes.TABLE_VOTES
					+ " WHERE id_votes = " + Utility.isNull(pId);

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordFromRs(pRs);
			else
				throw new EntityNotFoundException(
						"Impossibile trovare l'insegnamento!");

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	
	public synchronized String getTeachingIdByVotesId(int pId)
			throws EntityNotFoundException, ConnectionException, SQLException {
		String result;
		Connection connect = null;
		try {
			// Se non e' stato fornito l'id restituiamo un codice di errore
			if (pId <= 0)
				throw new EntityNotFoundException(
						"Impossibile trovare il voto!");

			/*
			 * Prepariamo la stringa SQL per recuperare le informazioni
			 * corrispondenti all'id dell'insegnamento passato come parametro
			 */
			String tSql = "SELECT id_teaching FROM " + ManagerVotes.TABLE_VOTES
			        
					+ " WHERE id_votes = " + Utility.isNull(pId);

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet tRs = Utility.queryOperation(connect, tSql);

			if (tRs.next())
				result = tRs.getString("id_teaching");
			else
				throw new EntityNotFoundException(
						"Impossibile trovare il voto!");

			return result;
		} finally {
			DBConnection.releaseConnection(connect);
		}
	}
	

	/**
	 * Ritorna l'insieme di tutti i voti presenti nel database.
	 * 
	 * @return Ritorna una collection di voti.
	 * 
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 * @throws EntityNotFoundException
	 */
	public synchronized Collection<Votes> getVotes()
			throws ConnectionException, SQLException, InvalidValueException,
			EntityNotFoundException {
		Collection<Votes> result = null;
		Connection connect = null;

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT * FROM " + ManagerVotes.TABLE_VOTES
					+ " ORDER BY id_votes";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}

	}

	/**
	 * Ritorna l'insieme dei voti associati all'utente corrispondente
	 * all'id passato come paramentro.
	 * 
	 * @param pId
	 *            L'id dell'utente.
	 * @return Ritorna una collection di voti.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Votes> getVotesByUserId(int pId)
			throws EntityNotFoundException, ConnectionException, SQLException,
			InvalidValueException {

		Collection<Votes> result = null;
		Connection connect = null;

		if (pId <= 0)
			throw new EntityNotFoundException("specificare l'utente");

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT " + ManagerVotes.TABLE_VOTES
					+ ".* FROM " + ManagerVotes.TABLE_VOTES
				    + " WHERE ("
					+ ManagerVotes.TABLE_VOTES + ".id_user = "
					+ Utility.isNull(pId) + ")" + " ORDER BY id_user";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}

	/**
	 * Ritorna l'insieme dei voti associati all'utente corrispondente
	 * all'id passato come paramentro.
	 * 
	 * @param pId
	 *            L'id dell'utente.
	 * @return Ritorna una collection di voti.
	 * 
	 * @throws EntityNotFoundException
	 * @throws ConnectionException
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	public synchronized Collection<Votes> getVotesByUserIdYearTurn(int pId,int pYear, int pTurn)
			throws EntityNotFoundException, ConnectionException, SQLException,
			InvalidValueException {

		Collection<Votes> result = null;
		Connection connect = null;

		if (pId <= 0)
			throw new EntityNotFoundException("specificare l'utente");

		try {
			// Prepariamo la stringa SQL
			String sql = "SELECT " + ManagerVotes.TABLE_VOTES
					+ ".* FROM " + ManagerVotes.TABLE_VOTES
				    + " WHERE ("
					+ ManagerVotes.TABLE_VOTES + ".id_user = "
					+ Utility.isNull(pId)+" AND "
					+ ManagerVotes.TABLE_VOTES + ".accademicYear = "
					+ Utility.isNull(pYear)+" AND " 
					+ManagerVotes.TABLE_VOTES + ".turn = "
					+ Utility.isNull(pTurn)+ ")" + " ORDER BY id_user";

			// Otteniamo una Connessione al DataBase
			connect = DBConnection.getConnection();
			if (connect == null)
				throw new ConnectionException();

			// Inviamo la Query al DataBase
			ResultSet pRs = Utility.queryOperation(connect, sql);

			if (pRs.next())
				result = this.loadRecordsFromRs(pRs);

			return result;
		} finally {
			// rilascia le risorse
			DBConnection.releaseConnection(connect);
		}
	}
	
	public synchronized void deleteVotesByUserIdYearTurn(int pId,int pYear, int pTurn)
	throws EntityNotFoundException, ConnectionException, SQLException,
	InvalidValueException {

Connection connect = null;

if (pId <= 0)
	throw new EntityNotFoundException("specificare l'utente");

try {
	// Prepariamo la stringa SQL
	String sql = "DELETE "+ ManagerVotes.TABLE_VOTES+" FROM " + ManagerVotes.TABLE_VOTES
		    + " WHERE ("
			+ ManagerVotes.TABLE_VOTES + ".id_user="
			+ Utility.isNull(pId)+" AND "
			+ ManagerVotes.TABLE_VOTES + ".AccademicYear="
			+ Utility.isNull(pYear)+" AND " 
			+ManagerVotes.TABLE_VOTES + ".turn="
			+ Utility.isNull(pTurn)+ ")";

	// Otteniamo una Connessione al DataBase
	connect = DBConnection.getConnection();
	if (connect == null)
		throw new ConnectionException();

	// Inviamo la Query al DataBase
	 Utility.executeOperation(connect, sql);
     
} finally {
	// rilascia le risorse
	DBConnection.releaseConnection(connect);
}
}
	
	
	/**
	 * Consente la lettura di un record dal ResultSet.
	 * 
	 * @param pRs
	 *            Il risultato della query.
	 * @return Ritorna il voto letto.
	 * 
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Votes loadRecordFromRs(ResultSet pRs) throws SQLException,
			InvalidValueException {
		Votes votes = new Votes();
		votes.setId_votes(pRs.getInt(("id_votes")));
		votes.setId_user(pRs.getInt("id_user"));
		votes.setTeaching(pRs.getInt("id_teaching"));
		votes.setWritten(pRs.getInt("written"));
		votes.setOral(pRs.getInt("oral"));
		votes.setLaboratory(pRs.getInt("laboratory"));
		votes.setAccademicYear(pRs.getInt("AccademicYear"));
		votes.setTurn(pRs.getInt("turn"));

		return votes;
	}

	/**
	 * Consente la lettura dei record dal ResultSet.
	 * 
	 * @param pRs
	 *            Il risultato della query.
	 * @return Ritorna la collection di insegnamenti letti.
	 * 
	 * @throws SQLException
	 * @throws InvalidValueException
	 */
	private Collection<Votes> loadRecordsFromRs(ResultSet pRs)
			throws SQLException, InvalidValueException {
		Collection<Votes> result = new Vector<Votes>();
		do {
			result.add(loadRecordFromRs(pRs));
		} while (pRs.next());
		return result;
	}

}

package smos.application.addressManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Address;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerAddress;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
/**
 * Servlet utilizzata per cancellare un indirizzo dal database
 * 
 * @author Vecchione Giuseppe
 */
public class ServletDeleteAddress extends HttpServlet {

	private static final long serialVersionUID = -7383336226678925533L;
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, HttpServletResponse pResponse){
		String errorMessage="";
		String gotoPage="./showAddressList";
		ManagerUser managerUser= ManagerUser.getInstance();
		ManagerAddress managerAddress= ManagerAddress.getInstance();
		HttpSession session= pRequest.getSession();
		User loggedUser= (User)session.getAttribute("loggedUser");
		Address address= null;
		try {
				if(loggedUser==null){		
					pResponse.sendRedirect("./index.htm");
					return;
				}
				if(!managerUser.isAdministrator(loggedUser)){
					errorMessage= "L' utente collegato non ha accesso alla funzionalita'!";
					gotoPage="./error.jsp";
				}
				
				address= (Address)session.getAttribute("address");
				managerAddress.delete(address);
				
		} 	  catch (IOException ioException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
				gotoPage = "./error.jsp";
				ioException.printStackTrace();
			} catch (SQLException SQLException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
				gotoPage = "./error.jsp";
				SQLException.printStackTrace();
			} catch (EntityNotFoundException entityNotFoundException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE
				+ entityNotFoundException.getMessage();
				gotoPage = "./error.jsp";
				entityNotFoundException.printStackTrace();
			} catch (ConnectionException connectionException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE
				+ connectionException.getMessage();
				gotoPage = "./error.jsp";
				connectionException.printStackTrace();
			} catch (MandatoryFieldException mandatoryFieldException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE
				+ mandatoryFieldException.getMessage();
				gotoPage = "./error.jsp";
				mandatoryFieldException.printStackTrace();
			} catch (InvalidValueException invalidValueException) {
				errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
				gotoPage = "./error.jsp";
				invalidValueException.printStackTrace();
			}
			session.setAttribute("errorMessage", errorMessage);
			
			try {
				pResponse.sendRedirect(gotoPage);
			} catch (IOException ioException) {
				errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
				gotoPage = "./error.jsp";
				ioException.printStackTrace();
			}
		}
	
	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.bean;

import java.util.ArrayList;

import smos.exception.InvalidValueException;

/**
 * 
 * Classe utilizzata per modellare una pagella.
 * 
 * @author Luigi Colangelo 
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class Report {
	public ArrayList<Votes> pagella; 
	
	/**
	 * Il costruttore della classe
	 */
	public Report(){
		pagella=new ArrayList<Votes>();
	}
	
	/**
	 * Metodo che restituisce il voto dall'indice nell'array dato in input
	 * @param pInd indice del voto nell'array
	 * @return il voto dell'indice dato
	 * @throws InvalidValueException
	 */
	public Votes getVotes(int pInd) throws InvalidValueException{
		if(pInd<0 || pInd>=pagella.size())throw new InvalidValueException("indice non valido!");
		return (pagella.get(pInd));
	}
	
	/**
	 * Metodo che aggiunge un voto all'array.
	 * @param pVotes il voto da aggiungere
	 * @throws InvalidValueException 
	 */
	public void addVotes(Votes pVotes) throws InvalidValueException{
		if(pVotes==null)throw new InvalidValueException("voto non valido!");
		else pagella.add(pVotes);
	}
	
	/**
	 * Metodo che elimina un voto dall'array
	 * @param pId l'indice del voto da eliminare dall'array.
	 * @throws InvalidValueException 
	 */
	public void remove(int pId) throws InvalidValueException{
		if(pId<0 || pId>=pagella.size())throw new InvalidValueException("indice non valido!");
		pagella.remove(pId);
	}
	
	
	public String ToString(){
		String pag="";
		for(Votes e: pagella){
			pag=pag+"\n"+e.toString();
		}
	return pag;
	}
    
}

package smos.exception;

import java.lang.Exception;

/**
  * Questa classe rappresenta l'eccezione generata quando si 
  * tenta di inserire un'entit gi presente nel database.
  */
public class DuplicatedEntityException extends Exception {
	
	private static final long serialVersionUID = 4858261134352455533L;

	/**
	 * Genera l'eccezione senza un messagio di errore associato.
	 */
	public DuplicatedEntityException() {
		super("Duplicate Key into the Repository!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public DuplicatedEntityException (String pMessage) {
		super(pMessage);
	}
	
	
}
package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per modificare un utente.
 * 
 * @author Napolitano Vincenzo.
 *
 */
public class ServletUpdateUser extends HttpServlet {

	private static final long serialVersionUID = 1316473033146481065L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		String gotoPage = "showUserList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		User user = (User) session.getAttribute("user");
		
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
			user.setFirstName((pRequest.getParameter("firstName")));
			user.setLastName((pRequest.getParameter("lastName")));
			user.setCell((pRequest.getParameter("cell")));
			/*
			 * verifichiamo che la login sia unica.
			 */
			String login = pRequest.getParameter("login");
			user.setLogin(login);
			if (managerUser.existsLogin(user))
				throw new InvalidValueException("La login inserita esiste gia'. Inserire una nuova login.");
			
			user.setPassword(pRequest.getParameter("password"));
			user.setEMail(pRequest.getParameter("eMail"));
			//aggiorniamo
			if (!managerUser.exists(user)){
				managerUser.update(user);
			}else {
				int userId = managerUser.getUserId(user);
				if (user.getId()==userId)
					managerUser.update(user);
				else 
					throw new DuplicatedEntityException("Utente gi esistente");
			}
			
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		}  catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
			
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.User;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;
import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per visualizzare tutti gli anni accademici presenti nel
 * db.
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 */
public class ServletLoadYear extends HttpServlet {

	

	/**
	 * 
	 */
	private static final long serialVersionUID = -6304881993204403909L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "./persistentDataManagement";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		Collection<Integer> yearList = null;
		ManagerUser managerUser = ManagerUser.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser)) && (!managerUser.isDirector(loggedUser))) {
				errorMessage = "L'Utente collegato non ha accesso alla "
						+ "funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
			ManagerClassroom managerClassroom = ManagerClassroom.getInstance();
			yearList = managerClassroom.getAcademicYearList();
			gotoPage +=(String) pRequest.getParameter("goTo");
			session.setAttribute("accademicYearList", yearList);
			pResponse.sendRedirect(gotoPage);
			return;
			
		} catch (SQLException sqlException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ sqlException.getMessage();
			gotoPage = "./error.jsp";
			sqlException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		}

		pRequest.getSession().setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
					+ ioException.getMessage();
			gotoPage = "./error6.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}


package smos.application.userManagement;

import javax.servlet.http.HttpServlet;

public class ServletShowUserTeachingFormByCourse extends HttpServlet {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2305151029867525356L;

}

package smos.bean;

import smos.exception.InvalidValueException;

import java.io.Serializable;

/**
 * Classe utilizzata per modellare un insegnamento.
 * 
 * @author Giulio D'Amora
 * @version 1.0
 * 
 *          2009  Copyright by SMOS
 * 
 */

public class Teaching implements Serializable {

	private static final long serialVersionUID = 2523612738702790957L;
	private int id_teaching;
	private String name;

	/**
	 * Il costruttore della classe.
	 */
	public Teaching() {
		this.id_teaching = 0;
	}

	/**
	 * Ritorna il nome dell'insegnamento
	 * 
	 * @return Ritorna il nome dell'insegnamento.
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Setta il nome dell'insegnamento.
	 * 
	 * @param pName
	 *            Il nome da settare.
	 * 
	 * @throws InvalidValueException
	 */
	public void setName(String pName) throws InvalidValueException {
		if (pName.length() <= 4)// da verificare il test
			throw new InvalidValueException();
		else
			this.name = pName;
	}

	/**
	 * Ritorna l'id dell'insegnamento.
	 * 
	 * @return l'id dell'insegnamento.
	 */
	public int getId() {
		return this.id_teaching;
	}

	/**
	 * Setta l'id dell'insegnamento.
	 * 
	 * @param pId
	 *            L'id da settare.
	 */
	public void setId(int pId) {
		this.id_teaching = pId;
	}

}

package smos.exception;
/**
 * Questa classe rappresenta l'eccezione generata quando un utente
 * tenta di eliminare l'unico utente Admin nel database.
 */

public class DeleteAdministratorException extends Exception {

	
	/**
	 * 
	 */
	private static final long serialVersionUID = -2081143475624381775L;

	/**
	 * Genera l'eccezione senza un messaggio di errore associato.
	 * 
	 */
	public DeleteAdministratorException() {
		super("Impossibile eliminare l'utente, l'utente selezionato e' l'unico Admin presente nel database! Creare un nuovo Manager e riprovare!");
	}
	
	/**
	  * Genera l'eccezione con un messagio di errore associato.
	  *
	  * @param pMessage 	Il messaggio di errore che deve essere associato
	  *						all'eccezione.
	  */
	public DeleteAdministratorException(String pMessage) {
		super(pMessage);
	}
}

package smos.application;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;

import smos.utility.Utility;

/**
 * Servlet utilizzata per inizializzare i parametri del sistema.
 * 
 * @author Bavota Gabriele, Carnevale Filomena.
 *
 */
public class ServletInitialize extends HttpServlet {

	private static final long serialVersionUID = -2542143445249797492L;
	
	@SuppressWarnings("unused")
	private ServletConfig config;
	
	 /**

     * Inizializza i parametri

     */

    public void init(ServletConfig config) throws ServletException 

    {
    	this.config = config;
    	               
        
        //Setto il server smtp specificato nel file di configurazione xml
        Utility.setServerSmtp(config.getInitParameter("serverSmtp"));
        
        //Setto i parametri necessari alla connessione al Database
        Utility.setDriverMySql(config.getInitParameter("driverMySql"));
        Utility.setFullPathDatabase(config.getInitParameter("fullPathDatabase"));
        Utility.setUserName(config.getInitParameter("userName"));
        Utility.setPassword(config.getInitParameter("password"));
        Utility.setMaxPoolSize(Integer.valueOf(config.getInitParameter("maxPoolSize")));
        Utility.setWaitTimeout(Integer.valueOf(config.getInitParameter("waitTimeout")));
        Utility.setActiveTimeout(Integer.valueOf(config.getInitParameter("activeTimeout")));
        Utility.setPoolTimeout(Integer.valueOf(config.getInitParameter("poolTimeout")));
        Utility.setTextFooter(config.getInitParameter("textFooter"));
        
        
	}

}

package smos.application.classroomManagement;

import java.io.IOException;
import java.sql.SQLException;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import smos.Environment;
import smos.bean.Classroom;
import smos.bean.User;
import smos.exception.DuplicatedEntityException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.exception.MandatoryFieldException;
import smos.storage.ManagerClassroom;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

public class ServletInsertClassroom extends HttpServlet {

	
	
	
	
	/**
	 * Servlet per inserire una classe 
	 * @author Nicola Pisanti
	 * @version 0.9
	 */
	private static final long serialVersionUID = 1355159545343902216L;

	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	public void doGet(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		int aC=Integer.valueOf(pRequest.getParameter("academicYear"));
		String gotoPage = "./showClassroomList?academicYear="+aC;
		
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		ManagerUser managerUser = ManagerUser.getInstance();
		ManagerClassroom managerClassroom= ManagerClassroom.getInstance();
		User loggedUser = (User) session.getAttribute("loggedUser");
		
		String isWizard = "yes";
		
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if (!managerUser.isAdministrator(loggedUser)) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
		
			int idAdd= (int) Integer.valueOf(pRequest.getParameter("address"));
			
			Classroom classroom= new Classroom();
			classroom.setName(pRequest.getParameter("name"));
			classroom.setAcademicYear(aC);
			classroom.setIdAddress(idAdd);
			
			if(classroom.getAcademicYear()<1970){
				throw new InvalidValueException("l'anno inserito è troppo vecchio");
			
			}
			
			if(!(managerClassroom.exists(classroom))){
				managerClassroom.insert(classroom);
				session.setAttribute("isWizard", isWizard);
			}else{
				throw new DuplicatedEntityException("la classe già esiste nel database");
			}
			
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (MandatoryFieldException mandatoryFieldException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + mandatoryFieldException.getMessage();
			gotoPage = "./error.jsp";
			mandatoryFieldException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DuplicatedEntityException duplicatedEntityException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + duplicatedEntityException.getMessage();
			gotoPage = "./error.jsp";
			duplicatedEntityException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE
				+ ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
		
		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}
	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest, 
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}
}

package smos.bean;

import java.io.Serializable;

public class Classroom implements Serializable{

	/**
	 * Classe impiegata per modellare una classe 
	 * @author Nicola Pisanti
	 * @version 1.0
	 */
	
	private static final long serialVersionUID = -8295647317972301446L; 

	private int idClassroom; //Id della classe
	private int idAddress;	//Id dell'indirizzo
	private String name;	//Nome della classe
	private int academicYear; //Anno accademico della classe, da inserire l'anno del primo semestre.
	
	
	public Classroom(){
		this.idAddress=0;
		this.idClassroom=0;
		
	}
	
	
	/**
	 * Metodo che restituisce l'anno accademico
	 * @return Un intero che rappresenta l'anno scolastico del primo semestre della classe.
	 */
	public int getAcademicYear() {
		return academicYear;
	}
	
	
	
	/**
	 * Metodo che setta l'anno accademico
	 * @param Il nuovo anno accademico da impostare
	 */
	public void setAcademicYear(int pAcademicYear) {
		this.academicYear = pAcademicYear;
	}
	
	
	/**
	 * Metodo per avere l'ID dell'indirizzo della classe
	 * @return Un intero che rappresenta l'ID dell'indirizzo della classe
	 */
	public int getIdAddress() {
		return idAddress;
	}
	
	
	/**
	 * Metodo che setta l'ID dell'indirizzo della classe
	 * @param Il nuovo ID da settare
	 */
	public void setIdAddress(int pIdAddress) {
		this.idAddress = pIdAddress;
	}
	
	
	/**
	 * Metodo che restituisce l'ID della classe 
	 * @return Un intero che rappresenta l'ID della classe
	 */
	public int getIdClassroom() {
		return idClassroom;
	}
	
	
	/**
	 * Metodo che setta l'ID della classe
	 * @param Il nuovo ID da settare
	 */
	public void setIdClassroom(int pIdClassroom) {
		this.idClassroom = pIdClassroom;
	}
	
	
	/**
	 * Metodo che restituisce il nome della classe
	 * @return Una stringa che rappresenta il nome della classe
	 */
	public String getName() {
		return name;
	}
	
	
	/**
	 * Metodo che setta il nome della classe
	 * @param Il nuovo nome da settare
	 */
	public void setName(String pName) {
		this.name = pName;
	}
	
	
	
	public String toString(){
		
		return (name + " "+ academicYear+ " ID: "+ idClassroom);
	}
	
	
}

package smos.application.userManagement;

import smos.Environment;
import smos.bean.Role;
import smos.bean.User;
import smos.bean.UserListItem;
import smos.exception.DeleteManagerException;
import smos.exception.EntityNotFoundException;
import smos.exception.InvalidValueException;
import smos.storage.ManagerUser;
import smos.storage.connectionManagement.exception.ConnectionException;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
 * Servlet utilizzata per assegnare uno o piu ruoli ad un utente.
 * 
 * @author Napolitano Vincenzo.
 * 
 */
public class ServletAssignRole extends HttpServlet {

	private static final long serialVersionUID = 537330195407987283L;
	
	/**
	 * Definizione del metodo doGet
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doGet(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		String gotoPage = "showUserList";
		String errorMessage = "";
		HttpSession session = pRequest.getSession();
		
		Collection<UserListItem> administrators = new Vector<UserListItem>();
		Iterator<UserListItem> itAdmin = null;
		
		ManagerUser managerUser = ManagerUser.getInstance();

		User loggedUser = (User) session.getAttribute("loggedUser");

		// Verifica che l'utente abbia effettuato il login
		try {
			if (loggedUser == null) {
				pResponse.sendRedirect("./index.htm");
				return;
			}
			if ((!managerUser.isAdministrator(loggedUser))) {
				errorMessage =  "L'Utente collegato non ha accesso alla " +
						"funzionalita'!";
				gotoPage = "./error.jsp";
			}
			
			User user = (User) session.getAttribute("user");
			
			administrators = managerUser.getAdministrators();
			itAdmin = administrators.iterator();
			itAdmin.next();
			
			String[] selectedRoles = pRequest.getParameterValues("selectedRoles");
			String[] unselectedRoles = pRequest.getParameterValues("unselectedRoles");
			
			if (selectedRoles != null) {
				int selectedlength = selectedRoles.length;
				for (int i = 0; i < selectedlength; i++) {
					int role = Integer.valueOf(selectedRoles[i]);
					/*
					 * controlliamo se il ruolo che stiamo assegnando e'
					 * quello di docente*/
					 
					/*if ((role == Role.TEACHER) && (!managerUser.isTeacher(user))){
						gotoPage="./loadYearForTeachings";
						
					}*/
					/*
					 * controlliamo se il ruolo che stiamo assegnando e'
					 * quello di studente*/
					/*if ((role == Role.STUDENT) && (!managerUser.isStudent(user))){
						gotoPage="./showUserList";
						
					} */
					/*
					 * controlliamo se il ruolo che stiamo assegnando e'
					 * quello di genitore*/
					/*if((role==Role.PARENT)&& (!managerUser.isParent(user))){
						gotoPage="./persistentDataManagement/userManagement/showStudentParentForm.jsp";
					}*/
					managerUser.assignRole(user, role);
				}
			} 
			
			if (unselectedRoles != null) {
				int unselectedlength = unselectedRoles.length;
				for (int i = 0; i < unselectedlength; i++) {
					int role = Integer.valueOf(unselectedRoles[i]);
					if ((managerUser.isAdministrator(user))&&(!itAdmin.hasNext())&&(role==Role.ADMIN)) {
						throw new DeleteManagerException ("Impossibile modificare il ruolo dell'utente, e' l'unico Amministratore del sistema! Creare un nuovo Amministratore e riprovare!");
					}
					managerUser.removeRole(user, role);
				}
			}
			
			session.setAttribute("user", user);
		} catch (NumberFormatException numberFormatException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + numberFormatException.getMessage();
			gotoPage = "./error.jsp";
			numberFormatException.printStackTrace();
		} catch (EntityNotFoundException entityNotFoundException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + entityNotFoundException.getMessage();
			gotoPage = "./error.jsp";
			entityNotFoundException.printStackTrace();
		} catch (SQLException SQLException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + SQLException.getMessage();
			gotoPage = "./error.jsp";
			SQLException.printStackTrace();
		} catch (ConnectionException connectionException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + connectionException.getMessage();
			gotoPage = "./error.jsp";
			connectionException.printStackTrace();
		} catch (InvalidValueException invalidValueException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + invalidValueException.getMessage();
			gotoPage = "./error.jsp";
			invalidValueException.printStackTrace();
		} catch (DeleteManagerException deleteManagerException) {
			errorMessage =  Environment.DEFAULT_ERROR_MESSAGE + deleteManagerException.getMessage();
			gotoPage = "./error.jsp";
			deleteManagerException.printStackTrace();
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

		session.setAttribute("errorMessage", errorMessage);
		try {
			pResponse.sendRedirect(gotoPage);
		} catch (IOException ioException) {
			errorMessage = Environment.DEFAULT_ERROR_MESSAGE + ioException.getMessage();
			gotoPage = "./error.jsp";
			ioException.printStackTrace();
		}

	}

	/**
	 * Definizione del metodo doPost
	 * 
	 * @param pRequest
	 * @param pResponse
	 * 
	 */
	protected void doPost(HttpServletRequest pRequest,
			HttpServletResponse pResponse) {
		this.doGet(pRequest, pResponse);
	}

}

