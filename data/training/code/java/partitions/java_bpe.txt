protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {        final Observer<? super V> observer = downstream;        final SimplePlainQueue<U> q = queue;        if (wip.get() == 0 && wip.compareAndSet(0, 1)) {            if (q.isEmpty()) {                accept(observer, value);                if (leave(-1) == 0) {                    return;                }            } else {                q.offer(value);            }        } else {            q.offer(value);            if (!enter()) {                return;            }        }        QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> amb(Iterable<? extends ObservableSource<? extends T>> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new ObservableAmb<T>(null, sources));    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> ambArray(ObservableSource<? extends T>... sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        int len = sources.length;        if (len == 0) {            return empty();        }        if (len == 1) {            return (Observable<T>)wrap(sources[0]);        }        return RxJavaPlugins.onAssembly(new ObservableAmb<T>(sources, null));    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concat(Iterable<? extends ObservableSource<? extends T>> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), bufferSize(), false);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch) {        ObjectHelper.requireNonNull(sources, "sources is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, Functions.identity(), prefetch, ErrorMode.IMMEDIATE));    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatArray(ObservableSource<? extends T>... sources) {        if (sources.length == 0) {            return empty();        } else        if (sources.length == 1) {            return wrap((ObservableSource<T>)sources[0]);        }        return RxJavaPlugins.onAssembly(new ObservableConcatMap(fromArray(sources), Functions.identity(), bufferSize(), ErrorMode.BOUNDARY));    }
@SuppressWarnings({ "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatArrayDelayError(ObservableSource<? extends T>... sources) {        if (sources.length == 0) {            return empty();        } else        if (sources.length == 1) {            return (Observable<T>)wrap(sources[0]);        }        return concatDelayError(fromArray(sources));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatArrayEager(ObservableSource<? extends T>... sources) {        return concatArrayEager(bufferSize(), bufferSize(), sources);    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatArrayEager(int maxConcurrency, int prefetch, ObservableSource<? extends T>... sources) {        return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, false);    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatArrayEagerDelayError(int maxConcurrency, int prefetch, ObservableSource<? extends T>... sources) {        return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources) {        return concatDelayError(sources, bufferSize(), true);    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch, boolean tillTheEnd) {        ObjectHelper.requireNonNull(sources, "sources is null");        ObjectHelper.verifyPositive(prefetch, "prefetch is null");        return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, Functions.identity(), prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatEager(ObservableSource<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int prefetch) {        return wrap(sources).concatMapEager((Function)Functions.identity(), maxConcurrency, prefetch);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> concatEager(Iterable<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int prefetch) {        return fromIterable(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Observable<T> empty() {        return RxJavaPlugins.onAssembly((Observable<T>) ObservableEmpty.INSTANCE);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> error(Callable<? extends Throwable> errorSupplier) {        ObjectHelper.requireNonNull(errorSupplier, "errorSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableError<T>(errorSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @NonNull    public static <T> Observable<T> fromArray(T... items) {        ObjectHelper.requireNonNull(items, "items is null");        if (items.length == 0) {            return empty();        } else        if (items.length == 1) {            return just(items[0]);        }        return RxJavaPlugins.onAssembly(new ObservableFromArray<T>(items));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> fromIterable(Iterable<? extends T> source) {        ObjectHelper.requireNonNull(source, "source is null");        return RxJavaPlugins.onAssembly(new ObservableFromIterable<T>(source));    }
@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> fromPublisher(Publisher<? extends T> publisher) {        ObjectHelper.requireNonNull(publisher, "publisher is null");        return RxJavaPlugins.onAssembly(new ObservableFromPublisher<T>(publisher));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> generate(final Consumer<Emitter<T>> generator) {        ObjectHelper.requireNonNull(generator, "generator is null");        return generate(Functions.<Object>nullSupplier(),        ObservableInternalHelper.simpleGenerator(generator), Functions.<Object>emptyConsumer());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, S> Observable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {        return generate(initialState, generator, Functions.emptyConsumer());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Observable<Long> interval(long period, TimeUnit unit) {        return interval(period, period, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {        return interval(period, period, unit, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        if (count == 0L) {            return Observable.<Long>empty().delay(initialDelay, unit, scheduler);        }        long end = start + (count - 1);        if (start > 0 && end < 0) {            throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");        }        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> just(T item) {        ObjectHelper.requireNonNull(item, "item is null");        return RxJavaPlugins.onAssembly(new ObservableJust<T>(item));    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> merge(Iterable<? extends ObservableSource<? extends T>> sources, int maxConcurrency, int bufferSize) {        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> mergeArray(int maxConcurrency, int bufferSize, ObservableSource<? extends T>... sources) {        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings({ "unchecked", "rawtypes" })    public static <T> Observable<T> merge(ObservableSource<? extends ObservableSource<? extends T>> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new ObservableFlatMap(sources, Functions.identity(), false, Integer.MAX_VALUE, bufferSize()));    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> mergeArray(ObservableSource<? extends T>... sources) {        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3) {        ObjectHelper.requireNonNull(source1, "source1 is null");        ObjectHelper.requireNonNull(source2, "source2 is null");        ObjectHelper.requireNonNull(source3, "source3 is null");        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Observable<T> never() {        return RxJavaPlugins.onAssembly((Observable<T>) ObservableNever.INSTANCE);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static Observable<Integer> range(final int start, final int count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        if (count == 0) {            return empty();        }        if (count == 1) {            return just(start);        }        if ((long)start + (count - 1) > Integer.MAX_VALUE) {            throw new IllegalArgumentException("Integer overflow");        }        return RxJavaPlugins.onAssembly(new ObservableRange(start, count));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static Observable<Long> rangeLong(long start, long count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        if (count == 0) {            return empty();        }        if (count == 1) {            return just(start);        }        long end = start + (count - 1);        if (start > 0 && end < 0) {            throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");        }        return RxJavaPlugins.onAssembly(new ObservableRangeLong(start, count));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,            BiPredicate<? super T, ? super T> isEqual) {        return sequenceEqual(source1, source2, isEqual, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,            BiPredicate<? super T, ? super T> isEqual, int bufferSize) {        ObjectHelper.requireNonNull(source1, "source1 is null");        ObjectHelper.requireNonNull(source2, "source2 is null");        ObjectHelper.requireNonNull(isEqual, "isEqual is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableSequenceEqualSingle<T>(source1, source2, isEqual, bufferSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,            int bufferSize) {        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> switchOnNext(ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize) {        ObjectHelper.requireNonNull(sources, "sources is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableSwitchMap(sources, Functions.identity(), bufferSize, false));    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> switchOnNextDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch) {        ObjectHelper.requireNonNull(sources, "sources is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableSwitchMap(sources, Functions.identity(), prefetch, true));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> unsafeCreate(ObservableSource<T> onSubscribe) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        if (onSubscribe instanceof Observable) {            throw new IllegalArgumentException("unsafeCreate(Observable) should be upgraded");        }        return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(onSubscribe));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, D> Observable<T> using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, Consumer<? super D> disposer) {        return using(resourceSupplier, sourceSupplier, disposer, true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, D> Observable<T> using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager) {        ObjectHelper.requireNonNull(resourceSupplier, "resourceSupplier is null");        ObjectHelper.requireNonNull(sourceSupplier, "sourceSupplier is null");        ObjectHelper.requireNonNull(disposer, "disposer is null");        return RxJavaPlugins.onAssembly(new ObservableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Observable<T> wrap(ObservableSource<T> source) {        ObjectHelper.requireNonNull(source, "source is null");        if (source instanceof Observable) {            return RxJavaPlugins.onAssembly((Observable<T>)source);        }        return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Observable<R> zip(Iterable<? extends ObservableSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {        ObjectHelper.requireNonNull(zipper, "zipper is null");        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(null, sources, zipper, bufferSize(), false));    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Observable<R> zip(ObservableSource<? extends ObservableSource<? extends T>> sources, final Function<? super Object[], ? extends R> zipper) {        ObjectHelper.requireNonNull(zipper, "zipper is null");        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new ObservableToList(sources, 16)                .flatMap(ObservableInternalHelper.zipIterable(zipper)));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Observable<R> zipArray(Function<? super Object[], ? extends R> zipper,            boolean delayError, int bufferSize, ObservableSource<? extends T>... sources) {        if (sources.length == 0) {            return empty();        }        ObjectHelper.requireNonNull(zipper, "zipper is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> all(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableAllSingle<T>(this, predicate));    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> ambWith(ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return ambArray(this, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> any(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableAnySingle<T>(this, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingFirst() {        BlockingFirstObserver<T> observer = new BlockingFirstObserver<T>();        subscribe(observer);        T v = observer.blockingGet();        if (v != null) {            return v;        }        throw new NoSuchElementException();    }
@SchedulerSupport(SchedulerSupport.NONE)    public final void blockingForEach(Consumer<? super T> onNext) {        Iterator<T> it = blockingIterable().iterator();        while (it.hasNext()) {            try {                onNext.accept(it.next());            } catch (Throwable e) {                Exceptions.throwIfFatal(e);                ((Disposable)it).dispose();                throw ExceptionHelper.wrapOrThrow(e);            }        }    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Iterable<T> blockingIterable(int bufferSize) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return new BlockingObservableIterable<T>(this, bufferSize);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingLast() {        BlockingLastObserver<T> observer = new BlockingLastObserver<T>();        subscribe(observer);        T v = observer.blockingGet();        if (v != null) {            return v;        }        throw new NoSuchElementException();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Iterable<T> blockingMostRecent(T initialValue) {        return new BlockingObservableMostRecent<T>(this, initialValue);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingSingle() {        T v = singleElement().blockingGet();        if (v == null) {            throw new NoSuchElementException();        }        return v;    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingSingle(T defaultItem) {        return single(defaultItem).blockingGet();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Future<T> toFuture() {        return subscribeWith(new FutureObserver<T>());    }
@SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Consumer<? super T> onNext) {        ObservableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);    }
@SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {        ObservableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);    }
@SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {        ObservableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);    }
@SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Observer<? super T> observer) {        ObservableBlockingSubscribe.subscribe(this, observer);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<List<T>> buffer(int count) {        return buffer(count, count);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<List<T>> buffer(int count, int skip) {        return buffer(count, skip, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U extends Collection<? super T>> Observable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {        ObjectHelper.verifyPositive(count, "count");        ObjectHelper.verifyPositive(skip, "skip");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableBuffer<T, U>(this, count, skip, bufferSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U extends Collection<? super T>> Observable<U> buffer(int count, Callable<U> bufferSupplier) {        return buffer(count, count, bufferSupplier);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final <U extends Collection<? super T>> Observable<U> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable<U> bufferSupplier) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<List<T>> buffer(long timespan, TimeUnit unit, int count) {        return buffer(timespan, unit, Schedulers.computation(), count);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final <U extends Collection<? super T>> Observable<U> buffer(            long timespan, TimeUnit unit,            Scheduler scheduler, int count,            Callable<U> bufferSupplier,            boolean restartTimerOnMaxSize) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        ObjectHelper.verifyPositive(count, "count");        return RxJavaPlugins.onAssembly(new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <TOpening, TClosing> Observable<List<T>> buffer(            ObservableSource<? extends TOpening> openingIndicator,            Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> closingIndicator) {        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <TOpening, TClosing, U extends Collection<? super T>> Observable<U> buffer(            ObservableSource<? extends TOpening> openingIndicator,            Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> closingIndicator,            Callable<U> bufferSupplier) {        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Observable<List<T>> buffer(ObservableSource<B> boundary) {        return buffer(boundary, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Observable<List<T>> buffer(ObservableSource<B> boundary, final int initialCapacity) {        ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");        return buffer(boundary, Functions.<T>createArrayList(initialCapacity));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <B, U extends Collection<? super T>> Observable<U> buffer(ObservableSource<B> boundary, Callable<U> bufferSupplier) {        ObjectHelper.requireNonNull(boundary, "boundary is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Observable<List<T>> buffer(Callable<? extends ObservableSource<B>> boundarySupplier) {        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> cacheWithInitialCapacity(int initialCapacity) {        ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");        return RxJavaPlugins.onAssembly(new ObservableCache<T>(this, initialCapacity));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Single<U> collect(Callable<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {        ObjectHelper.requireNonNull(initialValueSupplier, "initialValueSupplier is null");        ObjectHelper.requireNonNull(collector, "collector is null");        return RxJavaPlugins.onAssembly(new ObservableCollectSingle<T, U>(this, initialValueSupplier, collector));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Single<U> collectInto(final U initialValue, BiConsumer<? super U, ? super T> collector) {        ObjectHelper.requireNonNull(initialValue, "initialValue is null");        return collect(Functions.justCallable(initialValue), collector);    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> compose(ObservableTransformer<? super T, ? extends R> composer) {        return wrap(((ObservableTransformer<T, R>) ObjectHelper.requireNonNull(composer, "composer is null")).apply(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {        return concatMap(mapper, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        if (this instanceof ScalarCallable) {            @SuppressWarnings("unchecked")            T v = ((ScalarCallable<T>)this).call();            if (v == null) {                return empty();            }            return ObservableScalarXMap.scalarXMap(v, mapper);        }        return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {        return concatMapDelayError(mapper, bufferSize(), true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapEager(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {        return concatMapEager(mapper, Integer.MAX_VALUE, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapEager(Function<? super T, ? extends ObservableSource<? extends R>> mapper,            int maxConcurrency, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapEager<T, R>(this, mapper, ErrorMode.IMMEDIATE, maxConcurrency, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapEagerDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper,            int maxConcurrency, int prefetch, boolean tillTheEnd) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapEager<T, R>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, maxConcurrency, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable concatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {        return concatMapCompletable(mapper, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable concatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, int capacityHint) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(capacityHint, "capacityHint");        return RxJavaPlugins.onAssembly(new ObservableConcatMapCompletable<T>(this, mapper, ErrorMode.IMMEDIATE, capacityHint));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper) {        return concatMapCompletableDelayError(mapper, true, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper, boolean tillTheEnd, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapCompletable<T>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<T, U>(this, mapper));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<U> concatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return concatMap(ObservableInternalHelper.flatMapIntoIterable(mapper), prefetch);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        return concatMapMaybe(mapper, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapMaybe<T, R>(this, mapper, ErrorMode.IMMEDIATE, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapMaybeDelayError(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        return concatMapMaybeDelayError(mapper, true, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapMaybeDelayError(Function<? super T, ? extends MaybeSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapMaybe<T, R>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper) {        return concatMapSingle(mapper, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapSingle<T, R>(this, mapper, ErrorMode.IMMEDIATE, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapSingleDelayError(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean tillTheEnd) {        return concatMapSingleDelayError(mapper, tillTheEnd, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> concatMapSingleDelayError(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ObservableConcatMapSingle<T, R>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> concatWith(ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return concat(this, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> concatWith(@NonNull SingleSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableConcatWithSingle<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> concatWith(@NonNull MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableConcatWithMaybe<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> concatWith(@NonNull CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableConcatWithCompletable<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> contains(final Object element) {        ObjectHelper.requireNonNull(element, "element is null");        return any(Functions.equalsWith(element));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<T> debounce(Function<? super T, ? extends ObservableSource<U>> debounceSelector) {        ObjectHelper.requireNonNull(debounceSelector, "debounceSelector is null");        return RxJavaPlugins.onAssembly(new ObservableDebounce<T, U>(this, debounceSelector));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> debounce(long timeout, TimeUnit unit) {        return debounce(timeout, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableDebounceTimed<T>(this, timeout, unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> defaultIfEmpty(T defaultItem) {        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");        return switchIfEmpty(just(defaultItem));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<T> delay(final Function<? super T, ? extends ObservableSource<U>> itemDelay) {        ObjectHelper.requireNonNull(itemDelay, "itemDelay is null");        return flatMap(ObservableInternalHelper.itemDelay(itemDelay));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {        return delay(delay, unit, scheduler, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableDelay<T>(this, delay, unit, scheduler, delayError));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Observable<T> delay(ObservableSource<U> subscriptionDelay,            Function<? super T, ? extends ObservableSource<V>> itemDelay) {        return delaySubscription(subscriptionDelay).delay(itemDelay);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<T> delaySubscription(ObservableSource<U> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableDelaySubscriptionOther<T, U>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {        return delaySubscription(timer(delay, unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @Deprecated    @SuppressWarnings({ "unchecked", "rawtypes" })    public final <T2> Observable<T2> dematerialize() {        return RxJavaPlugins.onAssembly(new ObservableDematerialize(this, Functions.identity()));    }
@Experimental    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> dematerialize(Function<? super T, Notification<R>> selector) {        ObjectHelper.requireNonNull(selector, "selector is null");        return RxJavaPlugins.onAssembly(new ObservableDematerialize<T, R>(this, selector));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> distinct() {        return distinct(Functions.identity(), Functions.createHashSet());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Observable<T> distinct(Function<? super T, K> keySelector) {        return distinct(keySelector, Functions.createHashSet());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Observable<T> distinct(Function<? super T, K> keySelector, Callable<? extends Collection<? super K>> collectionSupplier) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableDistinct<T, K>(this, keySelector, collectionSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> distinctUntilChanged() {        return distinctUntilChanged(Functions.identity());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySelector) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {        ObjectHelper.requireNonNull(comparer, "comparer is null");        return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doAfterNext(Consumer<? super T> onAfterNext) {        ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");        return RxJavaPlugins.onAssembly(new ObservableDoAfterNext<T>(this, onAfterNext));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doAfterTerminate(Action onFinally) {        ObjectHelper.requireNonNull(onFinally, "onFinally is null");        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.EMPTY_ACTION, onFinally);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doFinally(Action onFinally) {        ObjectHelper.requireNonNull(onFinally, "onFinally is null");        return RxJavaPlugins.onAssembly(new ObservableDoFinally<T>(this, onFinally));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnDispose(Action onDispose) {        return doOnLifecycle(Functions.emptyConsumer(), onDispose);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnComplete(Action onComplete) {        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), onComplete, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");        return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {        ObjectHelper.requireNonNull(onNotification, "onNotification is null");        return doOnEach(                Functions.notificationOnNext(onNotification),                Functions.notificationOnError(onNotification),                Functions.notificationOnComplete(onNotification),                Functions.EMPTY_ACTION            );    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnEach(final Observer<? super T> observer) {        ObjectHelper.requireNonNull(observer, "observer is null");        return doOnEach(                ObservableInternalHelper.observerOnNext(observer),                ObservableInternalHelper.observerOnError(observer),                ObservableInternalHelper.observerOnComplete(observer),                Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnError(Consumer<? super Throwable> onError) {        return doOnEach(Functions.emptyConsumer(), onError, Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnLifecycle(final Consumer<? super Disposable> onSubscribe, final Action onDispose) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        ObjectHelper.requireNonNull(onDispose, "onDispose is null");        return RxJavaPlugins.onAssembly(new ObservableDoOnLifecycle<T>(this, onSubscribe, onDispose));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnNext(Consumer<? super T> onNext) {        return doOnEach(onNext, Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnSubscribe(Consumer<? super Disposable> onSubscribe) {        return doOnLifecycle(onSubscribe, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> doOnTerminate(final Action onTerminate) {        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");        return doOnEach(Functions.emptyConsumer(),                Functions.actionConsumer(onTerminate), onTerminate,                Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> elementAt(long index) {        if (index < 0) {            throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);        }        return RxJavaPlugins.onAssembly(new ObservableElementAtMaybe<T>(this, index));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> elementAt(long index, T defaultItem) {        if (index < 0) {            throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);        }        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");        return RxJavaPlugins.onAssembly(new ObservableElementAtSingle<T>(this, index, defaultItem));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> elementAtOrError(long index) {        if (index < 0) {            throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);        }        return RxJavaPlugins.onAssembly(new ObservableElementAtSingle<T>(this, index, null));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> filter(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableFilter<T>(this, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> first(T defaultItem) {        return elementAt(0L, defaultItem);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors) {        return flatMap(mapper, delayErrors, Integer.MAX_VALUE);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper,            boolean delayErrors, int maxConcurrency, int bufferSize) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        if (this instanceof ScalarCallable) {            @SuppressWarnings("unchecked")            T v = ((ScalarCallable<T>)this).call();            if (v == null) {                return empty();            }            return ObservableScalarXMap.scalarXMap(v, mapper);        }        return RxJavaPlugins.onAssembly(new ObservableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMap(            Function<? super T, ? extends ObservableSource<? extends R>> onNextMapper,            Function<? super Throwable, ? extends ObservableSource<? extends R>> onErrorMapper,            Callable<? extends ObservableSource<? extends R>> onCompleteSupplier) {        ObjectHelper.requireNonNull(onNextMapper, "onNextMapper is null");        ObjectHelper.requireNonNull(onErrorMapper, "onErrorMapper is null");        ObjectHelper.requireNonNull(onCompleteSupplier, "onCompleteSupplier is null");        return merge(new ObservableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends U>> mapper,            BiFunction<? super T, ? super U, ? extends R> resultSelector) {        return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {        return flatMapCompletable(mapper, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Observable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,            BiFunction<? super T, ? super U, ? extends V> resultSelector) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.requireNonNull(resultSelector, "resultSelector is null");        return flatMap(ObservableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        return flatMapMaybe(mapper, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper, boolean delayErrors) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableFlatMapMaybe<T, R>(this, mapper, delayErrors));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper) {        return flatMapSingle(mapper, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean delayErrors) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableFlatMapSingle<T, R>(this, mapper, delayErrors));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer<? super Throwable> onError,            final Action onComplete) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ForEachWhileObserver<T> o = new ForEachWhileObserver<T>(onNext, onError, onComplete);        subscribe(o);        return o;    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {        return groupBy(keySelector, (Function)Functions.identity(), false, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,            Function<? super T, ? extends V> valueSelector) {        return groupBy(keySelector, valueSelector, false, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,            Function<? super T, ? extends V> valueSelector,            boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        ObjectHelper.requireNonNull(valueSelector, "valueSelector is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> hide() {        return RxJavaPlugins.onAssembly(new ObservableHide<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable ignoreElements() {        return RxJavaPlugins.onAssembly(new ObservableIgnoreElementsCompletable<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> isEmpty() {        return all(Functions.alwaysFalse());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> join(            ObservableSource<? extends TRight> other,            Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd,            Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd,            BiFunction<? super T, ? super TRight, ? extends R> resultSelector                    ) {        ObjectHelper.requireNonNull(other, "other is null");        ObjectHelper.requireNonNull(leftEnd, "leftEnd is null");        ObjectHelper.requireNonNull(rightEnd, "rightEnd is null");        ObjectHelper.requireNonNull(resultSelector, "resultSelector is null");        return RxJavaPlugins.onAssembly(new ObservableJoin<T, TRight, TLeftEnd, TRightEnd, R>(                this, other, leftEnd, rightEnd, resultSelector));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> lastElement() {        return RxJavaPlugins.onAssembly(new ObservableLastMaybe<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> last(T defaultItem) {        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");        return RxJavaPlugins.onAssembly(new ObservableLastSingle<T>(this, defaultItem));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> lastOrError() {        return RxJavaPlugins.onAssembly(new ObservableLastSingle<T>(this, null));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableMap<T, R>(this, mapper));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<Notification<T>> materialize() {        return RxJavaPlugins.onAssembly(new ObservableMaterialize<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> mergeWith(ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return merge(this, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> mergeWith(@NonNull SingleSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableMergeWithSingle<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> mergeWith(@NonNull MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableMergeWithMaybe<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> mergeWith(@NonNull CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableMergeWithCompletable<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> observeOn(Scheduler scheduler) {        return observeOn(scheduler, false, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableObserveOn<T>(this, scheduler, delayError, bufferSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> onErrorResumeNext(Function<? super Throwable, ? extends ObservableSource<? extends T>> resumeFunction) {        ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");        return RxJavaPlugins.onAssembly(new ObservableOnErrorNext<T>(this, resumeFunction, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> onErrorResumeNext(final ObservableSource<? extends T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return onErrorResumeNext(Functions.justFunction(next));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {        ObjectHelper.requireNonNull(valueSupplier, "valueSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableOnErrorReturn<T>(this, valueSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> onExceptionResumeNext(final ObservableSource<? extends T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return RxJavaPlugins.onAssembly(new ObservableOnErrorNext<T>(this, Functions.justFunction(next), true));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> onTerminateDetach() {        return RxJavaPlugins.onAssembly(new ObservableDetach<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends ObservableSource<R>> selector) {        ObjectHelper.requireNonNull(selector, "selector is null");        return RxJavaPlugins.onAssembly(new ObservablePublishSelector<T, R>(this, selector));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {        ObjectHelper.requireNonNull(reducer, "reducer is null");        return RxJavaPlugins.onAssembly(new ObservableReduceMaybe<T>(this, reducer));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {        ObjectHelper.requireNonNull(seed, "seed is null");        ObjectHelper.requireNonNull(reducer, "reducer is null");        return RxJavaPlugins.onAssembly(new ObservableReduceSeedSingle<T, R>(this, seed, reducer));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {        ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");        ObjectHelper.requireNonNull(reducer, "reducer is null");        return RxJavaPlugins.onAssembly(new ObservableReduceWithSingle<T, R>(this, seedSupplier, reducer));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> repeat() {        return repeat(Long.MAX_VALUE);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> repeat(long times) {        if (times < 0) {            throw new IllegalArgumentException("times >= 0 required but it was " + times);        }        if (times == 0) {            return empty();        }        return RxJavaPlugins.onAssembly(new ObservableRepeat<T>(this, times));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> repeatUntil(BooleanSupplier stop) {        ObjectHelper.requireNonNull(stop, "stop is null");        return RxJavaPlugins.onAssembly(new ObservableRepeatUntil<T>(this, stop));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler) {        ObjectHelper.requireNonNull(handler, "handler is null");        return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends ObservableSource<R>> selector) {        ObjectHelper.requireNonNull(selector, "selector is null");        return ObservableReplay.multicastSelector(ObservableInternalHelper.replayCallable(this), selector);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends ObservableSource<R>> selector, int bufferSize, long time, TimeUnit unit) {        return replay(selector, bufferSize, time, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final <R> Observable<R> replay(final Function<? super Observable<T>, ? extends ObservableSource<R>> selector, final Scheduler scheduler) {        ObjectHelper.requireNonNull(selector, "selector is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return ObservableReplay.multicastSelector(ObservableInternalHelper.replayCallable(this),                ObservableInternalHelper.replayFunction(selector, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final ConnectableObservable<T> replay(final int bufferSize) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return ObservableReplay.create(this, bufferSize);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit) {        return replay(bufferSize, time, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final ConnectableObservable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return ObservableReplay.create(this, time, unit, scheduler, bufferSize);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final ConnectableObservable<T> replay(final int bufferSize, final Scheduler scheduler) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return ObservableReplay.observeOn(replay(bufferSize), scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final ConnectableObservable<T> replay(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return ObservableReplay.observeOn(replay(), scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> retry() {        return retry(Long.MAX_VALUE, Functions.alwaysTrue());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableRetryBiPredicate<T>(this, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> retry(long times) {        return retry(times, Functions.alwaysTrue());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> retry(long times, Predicate<? super Throwable> predicate) {        if (times < 0) {            throw new IllegalArgumentException("times >= 0 required but it was " + times);        }        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableRetryPredicate<T>(this, times, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> retry(Predicate<? super Throwable> predicate) {        return retry(Long.MAX_VALUE, predicate);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> retryWhen(            final Function<? super Observable<Throwable>, ? extends ObservableSource<?>> handler) {        ObjectHelper.requireNonNull(handler, "handler is null");        return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> sample(long period, TimeUnit unit) {        return sample(period, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableSampleTimed<T>(this, period, unit, scheduler, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<T> sample(ObservableSource<U> sampler) {        ObjectHelper.requireNonNull(sampler, "sampler is null");        return RxJavaPlugins.onAssembly(new ObservableSampleWithObservable<T>(this, sampler, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> scan(BiFunction<T, T, T> accumulator) {        ObjectHelper.requireNonNull(accumulator, "accumulator is null");        return RxJavaPlugins.onAssembly(new ObservableScan<T>(this, accumulator));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> scan(final R initialValue, BiFunction<R, ? super T, R> accumulator) {        ObjectHelper.requireNonNull(initialValue, "initialValue is null");        return scanWith(Functions.justCallable(initialValue), accumulator);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {        ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");        ObjectHelper.requireNonNull(accumulator, "accumulator is null");        return RxJavaPlugins.onAssembly(new ObservableScanSeed<T, R>(this, seedSupplier, accumulator));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> serialize() {        return RxJavaPlugins.onAssembly(new ObservableSerialized<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> singleElement() {        return RxJavaPlugins.onAssembly(new ObservableSingleMaybe<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> single(T defaultItem) {        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(this, defaultItem));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> singleOrError() {        return RxJavaPlugins.onAssembly(new ObservableSingleSingle<T>(this, null));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> skip(long count) {        if (count <= 0) {            return RxJavaPlugins.onAssembly(this);        }        return RxJavaPlugins.onAssembly(new ObservableSkip<T>(this, count));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> skip(long time, TimeUnit unit) {        return skipUntil(timer(time, unit));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {        return skipUntil(timer(time, unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> skipLast(int count) {        if (count < 0) {            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);        }        if (count == 0) {            return RxJavaPlugins.onAssembly(this);        }        return RxJavaPlugins.onAssembly(new ObservableSkipLast<T>(this, count));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.TRAMPOLINE)    public final Observable<T> skipLast(long time, TimeUnit unit) {        return skipLast(time, unit, Schedulers.trampoline(), false, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {        return skipLast(time, unit, scheduler, false, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        // the internal buffer holds pairs of (timestamp, value) so double the default buffer size        int s = bufferSize << 1;        return RxJavaPlugins.onAssembly(new ObservableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<T> skipUntil(ObservableSource<U> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableSkipUntil<T, U>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> skipWhile(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableSkipWhile<T>(this, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> sorted() {        return toList().toObservable().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> sorted(Comparator<? super T> sortFunction) {        ObjectHelper.requireNonNull(sortFunction, "sortFunction is null");        return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> startWith(Iterable<? extends T> items) {        return concatArray(fromIterable(items), this);    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> startWith(ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return concatArray(other, this);    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> startWith(T item) {        ObjectHelper.requireNonNull(item, "item is null");        return concatArray(just(item), this);    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> startWithArray(T... items) {        Observable<T> fromArray = fromArray(items);        if (fromArray == empty()) {            return RxJavaPlugins.onAssembly(this);        }        return concatArray(fromArray, this);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(Consumer<? super T> onNext) {        return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {        return subscribe(onNext, onError, Functions.EMPTY_ACTION, Functions.emptyConsumer());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError,            Action onComplete, Consumer<? super Disposable> onSubscribe) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);        subscribe(ls);        return ls;    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> subscribeOn(Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableSubscribeOn<T>(this, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> switchIfEmpty(ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchIfEmpty<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> switchMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        if (this instanceof ScalarCallable) {            @SuppressWarnings("unchecked")            T v = ((ScalarCallable<T>)this).call();            if (v == null) {                return empty();            }            return ObservableScalarXMap.scalarXMap(v, mapper);        }        return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable switchMapCompletable(@NonNull Function<? super T, ? extends CompletableSource> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchMapCompletable<T>(this, mapper, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable switchMapCompletableDelayError(@NonNull Function<? super T, ? extends CompletableSource> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchMapCompletable<T>(this, mapper, true));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> switchMapMaybe(@NonNull Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchMapMaybe<T, R>(this, mapper, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> switchMapMaybeDelayError(@NonNull Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchMapMaybe<T, R>(this, mapper, true));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @NonNull    public final <R> Observable<R> switchMapSingle(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchMapSingle<T, R>(this, mapper, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @NonNull    public final <R> Observable<R> switchMapSingleDelayError(@NonNull Function<? super T, ? extends SingleSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new ObservableSwitchMapSingle<T, R>(this, mapper, true));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> switchMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {        return switchMapDelayError(mapper, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> take(long count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        return RxJavaPlugins.onAssembly(new ObservableTake<T>(this, count));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> take(long time, TimeUnit unit) {        return takeUntil(timer(time, unit));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) {        return takeUntil(timer(time, unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> takeLast(int count) {        if (count < 0) {            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);        } else        if (count == 0) {            return RxJavaPlugins.onAssembly(new ObservableIgnoreElements<T>(this));        } else        if (count == 1) {            return RxJavaPlugins.onAssembly(new ObservableTakeLastOne<T>(this));        }        return RxJavaPlugins.onAssembly(new ObservableTakeLast<T>(this, count));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        if (count < 0) {            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);        }        return RxJavaPlugins.onAssembly(new ObservableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Observable<T> takeUntil(ObservableSource<U> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new ObservableTakeUntil<T, U>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> takeWhile(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new ObservableTakeWhile<T>(this, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> throttleFirst(long windowDuration, TimeUnit unit) {        return throttleFirst(windowDuration, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableThrottleFirstTimed<T>(this, skipDuration, unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit) {        return sample(intervalDuration, unit);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {        return sample(intervalDuration, unit, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {        return debounce(timeout, unit);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {        return debounce(timeout, unit, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<Timed<T>> timeInterval() {        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.    public final Observable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableTimeInterval<T>(this, unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <V> Observable<T> timeout(Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator) {        return timeout0(null, itemTimeoutIndicator, null);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <V> Observable<T> timeout(Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator,            ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return timeout0(null, itemTimeoutIndicator, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> timeout(long timeout, TimeUnit timeUnit) {        return timeout0(timeout, timeUnit, null, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<T> timeout(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return timeout0(timeout, timeUnit, other, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, ObservableSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return timeout0(timeout, timeUnit, other, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {        return timeout0(timeout, timeUnit, null, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.    public final Observable<Timed<T>> timestamp(Scheduler scheduler) {        return timestamp(TimeUnit.MILLISECONDS, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.    public final Observable<Timed<T>> timestamp(final TimeUnit unit, final Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return map(Functions.<T>timestampWith(unit, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<List<T>> toList(final int capacityHint) {        ObjectHelper.verifyPositive(capacityHint, "capacityHint");        return RxJavaPlugins.onAssembly(new ObservableToListSingle<T, List<T>>(this, capacityHint));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U extends Collection<? super T>> Single<U> toList(Callable<U> collectionSupplier) {        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");        return RxJavaPlugins.onAssembly(new ObservableToListSingle<T, U>(this, collectionSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Single<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {        @SuppressWarnings({ "rawtypes", "unchecked" })        Function<? super T, ? extends T> valueSelector = (Function)Functions.identity();        Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();        Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);    }
@BackpressureSupport(BackpressureKind.SPECIAL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> toFlowable(BackpressureStrategy strategy) {        Flowable<T> f = new FlowableFromObservable<T>(this);        switch (strategy) {            case DROP:                return f.onBackpressureDrop();            case LATEST:                return f.onBackpressureLatest();            case MISSING:                return f;            case ERROR:                return RxJavaPlugins.onAssembly(new FlowableOnBackpressureError<T>(f));            default:                return f.onBackpressureBuffer();        }    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<List<T>> toSortedList() {        return toSortedList(Functions.naturalOrder());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> unsubscribeOn(Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableUnsubscribeOn<T>(this, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<Observable<T>> window(long count) {        return window(count, count, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<Observable<T>> window(long count, long skip, int bufferSize) {        ObjectHelper.verifyPositive(count, "count");        ObjectHelper.verifyPositive(skip, "skip");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableWindow<T>(this, count, skip, bufferSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit) {        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {        ObjectHelper.verifyPositive(timespan, "timespan");        ObjectHelper.verifyPositive(timeskip, "timeskip");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.requireNonNull(unit, "unit is null");        return RxJavaPlugins.onAssembly(new ObservableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Observable<Observable<T>> window(long timespan, TimeUnit unit) {        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<Observable<T>> window(long timespan, TimeUnit unit,            Scheduler scheduler, long count) {        return window(timespan, unit, scheduler, count, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<Observable<T>> window(            long timespan, TimeUnit unit, Scheduler scheduler,            long count, boolean restart, int bufferSize) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.verifyPositive(count, "count");        return RxJavaPlugins.onAssembly(new ObservableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Observable<Observable<T>> window(ObservableSource<B> boundary) {        return window(boundary, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Observable<Observable<T>> window(            ObservableSource<U> openingIndicator,            Function<? super U, ? extends ObservableSource<V>> closingIndicator) {        return window(openingIndicator, closingIndicator, bufferSize());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Observable<Observable<T>> window(            ObservableSource<U> openingIndicator,            Function<? super U, ? extends ObservableSource<V>> closingIndicator, int bufferSize) {        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Observable<Observable<T>> window(Callable<? extends ObservableSource<B>> boundary, int bufferSize) {        ObjectHelper.requireNonNull(boundary, "boundary is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new ObservableWindowBoundarySupplier<T, B>(this, boundary, bufferSize));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Observable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {        ObjectHelper.requireNonNull(other, "other is null");        ObjectHelper.requireNonNull(zipper, "zipper is null");        return RxJavaPlugins.onAssembly(new ObservableZipIterable<T, U, R>(this, other, zipper));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Observable<R> zipWith(ObservableSource<? extends U> other,            BiFunction<? super T, ? super U, ? extends R> zipper) {        ObjectHelper.requireNonNull(other, "other is null");        return zip(this, other, zipper);    }
@Override    protected void subscribeActual(MaybeObserver<? super T> observer) {        source.subscribe(new LastObserver<T>(observer));    }
@NonNull    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public Observable<T> refCount() {        return RxJavaPlugins.onAssembly(new ObservableRefCount<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> refCount(int subscriberCount) {        return refCount(subscriberCount, 0, TimeUnit.NANOSECONDS, Schedulers.trampoline());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> refCount(long timeout, TimeUnit unit, Scheduler scheduler) {        return refCount(1, timeout, unit, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Observable<T> refCount(int subscriberCount, long timeout, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.verifyPositive(subscriberCount, "subscriberCount");        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new ObservableRefCount<T>(this, subscriberCount, timeout, unit, scheduler));    }
@NonNull    public Observable<T> autoConnect(int numberOfSubscribers, @NonNull Consumer<? super Disposable> connection) {        if (numberOfSubscribers <= 0) {            this.connect(connection);            return RxJavaPlugins.onAssembly(this);        }        return RxJavaPlugins.onAssembly(new ObservableAutoConnect<T>(this, numberOfSubscribers, connection));    }
protected final boolean validate(@NonNull Subscriber<?>[] subscribers) {        int p = parallelism();        if (subscribers.length != p) {            Throwable iae = new IllegalArgumentException("parallelism = " + p + ", subscribers = " + subscribers.length);            for (Subscriber<?> s : subscribers) {                EmptySubscription.error(iae, s);            }            return false;        }        return true;    }
@CheckReturnValue    public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source) {        return from(source, Runtime.getRuntime().availableProcessors(), Flowable.bufferSize());    }
@CheckReturnValue    public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source, int parallelism) {        return from(source, parallelism, Flowable.bufferSize());    }
@CheckReturnValue    @NonNull    public static <T> ParallelFlowable<T> from(@NonNull Publisher<? extends T> source,            int parallelism, int prefetch) {        ObjectHelper.requireNonNull(source, "source");        ObjectHelper.verifyPositive(parallelism, "parallelism");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelFromPublisher<T>(source, parallelism, prefetch));    }
@CheckReturnValue    @NonNull    public final <R> R as(@NonNull ParallelFlowableConverter<T, R> converter) {        return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> map(@NonNull Function<? super T, ? extends R> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper");        return RxJavaPlugins.onAssembly(new ParallelMap<T, R>(this, mapper));    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> map(@NonNull Function<? super T, ? extends R> mapper, @NonNull ParallelFailureHandling errorHandler) {        ObjectHelper.requireNonNull(mapper, "mapper");        ObjectHelper.requireNonNull(errorHandler, "errorHandler is null");        return RxJavaPlugins.onAssembly(new ParallelMapTry<T, R>(this, mapper, errorHandler));    }
@CheckReturnValue    public final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate");        return RxJavaPlugins.onAssembly(new ParallelFilter<T>(this, predicate));    }
@CheckReturnValue    public final ParallelFlowable<T> filter(@NonNull Predicate<? super T> predicate, @NonNull ParallelFailureHandling errorHandler) {        ObjectHelper.requireNonNull(predicate, "predicate");        ObjectHelper.requireNonNull(errorHandler, "errorHandler is null");        return RxJavaPlugins.onAssembly(new ParallelFilterTry<T>(this, predicate, errorHandler));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> runOn(@NonNull Scheduler scheduler) {        return runOn(scheduler, Flowable.bufferSize());    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> runOn(@NonNull Scheduler scheduler, int prefetch) {        ObjectHelper.requireNonNull(scheduler, "scheduler");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelRunOn<T>(this, scheduler, prefetch));    }
@CheckReturnValue    @NonNull    public final Flowable<T> reduce(@NonNull BiFunction<T, T, T> reducer) {        ObjectHelper.requireNonNull(reducer, "reducer");        return RxJavaPlugins.onAssembly(new ParallelReduceFull<T>(this, reducer));    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> reduce(@NonNull Callable<R> initialSupplier, @NonNull BiFunction<R, ? super T, R> reducer) {        ObjectHelper.requireNonNull(initialSupplier, "initialSupplier");        ObjectHelper.requireNonNull(reducer, "reducer");        return RxJavaPlugins.onAssembly(new ParallelReduce<T, R>(this, initialSupplier, reducer));    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    public final Flowable<T> sequential() {        return sequential(Flowable.bufferSize());    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    @NonNull    public final Flowable<T> sequential(int prefetch) {        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelJoin<T>(this, prefetch, false));    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    @NonNull    public final Flowable<T> sequentialDelayError() {        return sequentialDelayError(Flowable.bufferSize());    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    @NonNull    public final Flowable<T> sequentialDelayError(int prefetch) {        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelJoin<T>(this, prefetch, true));    }
@CheckReturnValue    @NonNull    public final Flowable<T> sorted(@NonNull Comparator<? super T> comparator) {        return sorted(comparator, 16);    }
@CheckReturnValue    @NonNull    public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator) {        return toSortedList(comparator, 16);    }
@CheckReturnValue    @NonNull    public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) {        ObjectHelper.requireNonNull(comparator, "comparator is null");        ObjectHelper.verifyPositive(capacityHint, "capacityHint");        int ch = capacityHint / parallelism() + 1;        ParallelFlowable<List<T>> railReduced = reduce(Functions.<T>createArrayList(ch), ListAddBiConsumer.<T>instance());        ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<T>(comparator));        Flowable<List<T>> merged = railSorted.reduce(new MergerBiFunction<T>(comparator));        return RxJavaPlugins.onAssembly(merged);    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                onNext,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                Functions.emptyConsumer(),                Functions.EMPTY_LONG_CONSUMER,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext, @NonNull ParallelFailureHandling errorHandler) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(errorHandler, "errorHandler is null");        return RxJavaPlugins.onAssembly(new ParallelDoOnNextTry<T>(this, onNext, errorHandler));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doAfterNext(@NonNull Consumer<? super T> onAfterNext) {        ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                onAfterNext,                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                Functions.emptyConsumer(),                Functions.EMPTY_LONG_CONSUMER,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) {        ObjectHelper.requireNonNull(onError, "onError is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                onError,                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                Functions.emptyConsumer(),                Functions.EMPTY_LONG_CONSUMER,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnComplete(@NonNull Action onComplete) {        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.emptyConsumer(),                onComplete,                Functions.EMPTY_ACTION,                Functions.emptyConsumer(),                Functions.EMPTY_LONG_CONSUMER,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doAfterTerminated(@NonNull Action onAfterTerminate) {        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                onAfterTerminate,                Functions.emptyConsumer(),                Functions.EMPTY_LONG_CONSUMER,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnSubscribe(@NonNull Consumer<? super Subscription> onSubscribe) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                onSubscribe,                Functions.EMPTY_LONG_CONSUMER,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) {        ObjectHelper.requireNonNull(onRequest, "onRequest is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                Functions.emptyConsumer(),                onRequest,                Functions.EMPTY_ACTION                ));    }
@CheckReturnValue    @NonNull    public final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) {        ObjectHelper.requireNonNull(onCancel, "onCancel is null");        return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                Functions.emptyConsumer(),                Functions.EMPTY_LONG_CONSUMER,                onCancel                ));    }
@CheckReturnValue    @NonNull    public final <C> ParallelFlowable<C> collect(@NonNull Callable<? extends C> collectionSupplier, @NonNull BiConsumer<? super C, ? super T> collector) {        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");        ObjectHelper.requireNonNull(collector, "collector is null");        return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));    }
@CheckReturnValue    @NonNull    public static <T> ParallelFlowable<T> fromArray(@NonNull Publisher<T>... publishers) {        if (publishers.length == 0) {            throw new IllegalArgumentException("Zero publishers not supported");        }        return RxJavaPlugins.onAssembly(new ParallelFromArray<T>(publishers));    }
@CheckReturnValue    @NonNull    public final <U> U to(@NonNull Function<? super ParallelFlowable<T>, U> converter) {        try {            return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);        } catch (Throwable ex) {            Exceptions.throwIfFatal(ex);            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@CheckReturnValue    @NonNull    public final <U> ParallelFlowable<U> compose(@NonNull ParallelTransformer<T, U> composer) {        return RxJavaPlugins.onAssembly(ObjectHelper.requireNonNull(composer, "composer is null").apply(this));    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> flatMap(            @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayError) {        return flatMap(mapper, delayError, Integer.MAX_VALUE, Flowable.bufferSize());    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> flatMap(            @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,            boolean delayError, int maxConcurrency, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelFlatMap<T, R>(this, mapper, delayError, maxConcurrency, prefetch));    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> concatMap(            @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper) {        return concatMap(mapper, 2);    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> concatMap(            @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,                    int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> concatMapDelayError(            @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,                    boolean tillTheEnd) {        return concatMapDelayError(mapper, 2, tillTheEnd);    }
@CheckReturnValue    @NonNull    public final <R> ParallelFlowable<R> concatMapDelayError(            @NonNull Function<? super T, ? extends Publisher<? extends R>> mapper,                    int prefetch, boolean tillTheEnd) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new ParallelConcatMap<T, R>(                this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));    }
public static <U, R> Observable<R> multicastSelector(            final Callable<? extends ConnectableObservable<U>> connectableFactory,            final Function<? super Observable<U>, ? extends ObservableSource<R>> selector) {        return RxJavaPlugins.onAssembly(new MulticastReplay<R, U>(connectableFactory, selector));    }
public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {        final Observable<T> observable = co.observeOn(scheduler);        return RxJavaPlugins.onAssembly(new Replay<T>(co, observable));    }
@SuppressWarnings("unchecked")    public static <T> ConnectableObservable<T> createFrom(ObservableSource<? extends T> source) {        return create(source, DEFAULT_UNBOUNDED_FACTORY);    }
public static <T> ConnectableObservable<T> create(ObservableSource<T> source,            final int bufferSize) {        if (bufferSize == Integer.MAX_VALUE) {            return createFrom(source);        }        return create(source, new ReplayBufferSupplier<T>(bufferSize));    }
public static <T> ConnectableObservable<T> create(ObservableSource<T> source,            long maxAge, TimeUnit unit, Scheduler scheduler) {        return create(source, maxAge, unit, scheduler, Integer.MAX_VALUE);    }
public static <T> ConnectableObservable<T> create(ObservableSource<T> source,            final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {        return create(source, new ScheduledReplaySupplier<T>(bufferSize, maxAge, unit, scheduler));    }
static <T> ConnectableObservable<T> create(ObservableSource<T> source,            final BufferSupplier<T> bufferFactory) {        // the current connection to source needs to be shared between the operator and its onSubscribe call        final AtomicReference<ReplayObserver<T>> curr = new AtomicReference<ReplayObserver<T>>();        ObservableSource<T> onSubscribe = new ReplaySource<T>(curr, bufferFactory);        return RxJavaPlugins.onAssembly(new ObservableReplay<T>(onSubscribe, source, curr, bufferFactory));    }
public boolean setResource(int index, Subscription resource) {        for (;;) {            Subscription o = get(index);            if (o == SubscriptionHelper.CANCELLED) {                if (resource != null) {                    resource.cancel();                }                return false;            }            if (compareAndSet(index, o, resource)) {                if (o != null) {                    o.cancel();                }                return true;            }        }    }
public Subscription replaceResource(int index, Subscription resource) {        for (;;) {            Subscription o = get(index);            if (o == SubscriptionHelper.CANCELLED) {                if (resource != null) {                    resource.cancel();                }                return null;            }            if (compareAndSet(index, o, resource)) {                return o;            }        }    }
@CheckReturnValue    @NonNull    public static <T> UnicastProcessor<T> create(int capacityHint) {        return new UnicastProcessor<T>(capacityHint);    }
@CheckReturnValue    @NonNull    public static <T> UnicastProcessor<T> create(boolean delayError) {        return new UnicastProcessor<T>(bufferSize(), null, delayError);    }
@CheckReturnValue    @NonNull    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {        ObjectHelper.requireNonNull(onCancelled, "onTerminate");        return new UnicastProcessor<T>(capacityHint, onCancelled);    }
@SuppressWarnings("unchecked")    public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source,            Subscriber<? super R> subscriber,            Function<? super T, ? extends Publisher<? extends R>> mapper) {        if (source instanceof Callable) {            T t;            try {                t = ((Callable<T>)source).call();            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                EmptySubscription.error(ex, subscriber);                return true;            }            if (t == null) {                EmptySubscription.complete(subscriber);                return true;            }            Publisher<? extends R> r;            try {                r = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null Publisher");            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                EmptySubscription.error(ex, subscriber);                return true;            }            if (r instanceof Callable) {                R u;                try {                    u = ((Callable<R>)r).call();                } catch (Throwable ex) {                    Exceptions.throwIfFatal(ex);                    EmptySubscription.error(ex, subscriber);                    return true;                }                if (u == null) {                    EmptySubscription.complete(subscriber);                    return true;                }                subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u));            } else {                r.subscribe(subscriber);            }            return true;        }        return false;    }
public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));    }
@NonNull    public static Disposable fromRunnable(@NonNull Runnable run) {        ObjectHelper.requireNonNull(run, "run is null");        return new RunnableDisposable(run);    }
@NonNull    public static Disposable fromAction(@NonNull Action run) {        ObjectHelper.requireNonNull(run, "run is null");        return new ActionDisposable(run);    }
@NonNull    public static Disposable fromFuture(@NonNull Future<?> future) {        ObjectHelper.requireNonNull(future, "future is null");        return fromFuture(future, true);    }
@NonNull    public static Disposable fromFuture(@NonNull Future<?> future, boolean allowInterrupt) {        ObjectHelper.requireNonNull(future, "future is null");        return new FutureDisposable(future, allowInterrupt);    }
@NonNull    public static Disposable fromSubscription(@NonNull Subscription subscription) {        ObjectHelper.requireNonNull(subscription, "subscription is null");        return new SubscriptionDisposable(subscription);    }
public final T blockingGet() {        if (getCount() != 0) {            try {                BlockingHelper.verifyNonBlocking();                await();            } catch (InterruptedException ex) {                dispose();                throw ExceptionHelper.wrapOrThrow(ex);            }        }        Throwable e = error;        if (e != null) {            throw ExceptionHelper.wrapOrThrow(e);        }        return value;    }
@NonNull    public static Scheduler initComputationScheduler(@NonNull Callable<Scheduler> defaultScheduler) {        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");        Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitComputationHandler;        if (f == null) {            return callRequireNonNull(defaultScheduler);        }        return applyRequireNonNull(f, defaultScheduler); // JIT will skip this    }
@NonNull    public static Scheduler initIoScheduler(@NonNull Callable<Scheduler> defaultScheduler) {        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");        Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitIoHandler;        if (f == null) {            return callRequireNonNull(defaultScheduler);        }        return applyRequireNonNull(f, defaultScheduler);    }
@NonNull    public static Scheduler initNewThreadScheduler(@NonNull Callable<Scheduler> defaultScheduler) {        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");        Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitNewThreadHandler;        if (f == null) {            return callRequireNonNull(defaultScheduler);        }        return applyRequireNonNull(f, defaultScheduler);    }
@NonNull    public static Scheduler initSingleScheduler(@NonNull Callable<Scheduler> defaultScheduler) {        ObjectHelper.requireNonNull(defaultScheduler, "Scheduler Callable can't be null");        Function<? super Callable<Scheduler>, ? extends Scheduler> f = onInitSingleHandler;        if (f == null) {            return callRequireNonNull(defaultScheduler);        }        return applyRequireNonNull(f, defaultScheduler);    }
@NonNull    public static Scheduler onComputationScheduler(@NonNull Scheduler defaultScheduler) {        Function<? super Scheduler, ? extends Scheduler> f = onComputationHandler;        if (f == null) {            return defaultScheduler;        }        return apply(f, defaultScheduler);    }
public static void onError(@NonNull Throwable error) {        Consumer<? super Throwable> f = errorHandler;        if (error == null) {            error = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");        } else {            if (!isBug(error)) {                error = new UndeliverableException(error);            }        }        if (f != null) {            try {                f.accept(error);                return;            } catch (Throwable e) {                // Exceptions.throwIfFatal(e); TODO decide                e.printStackTrace(); // NOPMD                uncaught(e);            }        }        error.printStackTrace(); // NOPMD        uncaught(error);    }
@NonNull    public static Scheduler onIoScheduler(@NonNull Scheduler defaultScheduler) {        Function<? super Scheduler, ? extends Scheduler> f = onIoHandler;        if (f == null) {            return defaultScheduler;        }        return apply(f, defaultScheduler);    }
@NonNull    public static Scheduler onNewThreadScheduler(@NonNull Scheduler defaultScheduler) {        Function<? super Scheduler, ? extends Scheduler> f = onNewThreadHandler;        if (f == null) {            return defaultScheduler;        }        return apply(f, defaultScheduler);    }
@NonNull    public static Runnable onSchedule(@NonNull Runnable run) {        ObjectHelper.requireNonNull(run, "run is null");        Function<? super Runnable, ? extends Runnable> f = onScheduleHandler;        if (f == null) {            return run;        }        return apply(f, run);    }
@NonNull    public static Scheduler onSingleScheduler(@NonNull Scheduler defaultScheduler) {        Function<? super Scheduler, ? extends Scheduler> f = onSingleHandler;        if (f == null) {            return defaultScheduler;        }        return apply(f, defaultScheduler);    }
public static void reset() {        setErrorHandler(null);        setScheduleHandler(null);        setComputationSchedulerHandler(null);        setInitComputationSchedulerHandler(null);        setIoSchedulerHandler(null);        setInitIoSchedulerHandler(null);        setSingleSchedulerHandler(null);        setInitSingleSchedulerHandler(null);        setNewThreadSchedulerHandler(null);        setInitNewThreadSchedulerHandler(null);        setOnFlowableAssembly(null);        setOnFlowableSubscribe(null);        setOnObservableAssembly(null);        setOnObservableSubscribe(null);        setOnSingleAssembly(null);        setOnSingleSubscribe(null);        setOnCompletableAssembly(null);        setOnCompletableSubscribe(null);        setOnConnectableFlowableAssembly(null);        setOnConnectableObservableAssembly(null);        setOnMaybeAssembly(null);        setOnMaybeSubscribe(null);        setOnParallelAssembly(null);        setFailOnNonBlockingScheduler(false);        setOnBeforeBlocking(null);    }
public static void setComputationSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onComputationHandler = handler;    }
public static void setInitComputationSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onInitComputationHandler = handler;    }
public static void setInitIoSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onInitIoHandler = handler;    }
public static void setInitNewThreadSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onInitNewThreadHandler = handler;    }
public static void setInitSingleSchedulerHandler(@Nullable Function<? super Callable<Scheduler>, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onInitSingleHandler = handler;    }
public static void setIoSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onIoHandler = handler;    }
public static void setNewThreadSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onNewThreadHandler = handler;    }
public static void setScheduleHandler(@Nullable Function<? super Runnable, ? extends Runnable> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onScheduleHandler = handler;    }
public static void setSingleSchedulerHandler(@Nullable Function<? super Scheduler, ? extends Scheduler> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onSingleHandler = handler;    }
public static void setOnCompletableAssembly(@Nullable Function<? super Completable, ? extends Completable> onCompletableAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onCompletableAssembly = onCompletableAssembly;    }
public static void setOnCompletableSubscribe(            @Nullable BiFunction<? super Completable, ? super CompletableObserver, ? extends CompletableObserver> onCompletableSubscribe) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onCompletableSubscribe = onCompletableSubscribe;    }
@SuppressWarnings("rawtypes")    public static void setOnFlowableAssembly(@Nullable Function<? super Flowable, ? extends Flowable> onFlowableAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onFlowableAssembly = onFlowableAssembly;    }
@SuppressWarnings("rawtypes")    public static void setOnMaybeAssembly(@Nullable Function<? super Maybe, ? extends Maybe> onMaybeAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onMaybeAssembly = onMaybeAssembly;    }
@SuppressWarnings("rawtypes")    public static void setOnConnectableFlowableAssembly(@Nullable Function<? super ConnectableFlowable, ? extends ConnectableFlowable> onConnectableFlowableAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onConnectableFlowableAssembly = onConnectableFlowableAssembly;    }
@SuppressWarnings("rawtypes")    public static void setOnFlowableSubscribe(@Nullable BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> onFlowableSubscribe) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onFlowableSubscribe = onFlowableSubscribe;    }
@SuppressWarnings("rawtypes")    public static void setOnMaybeSubscribe(@Nullable BiFunction<? super Maybe, MaybeObserver, ? extends MaybeObserver> onMaybeSubscribe) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onMaybeSubscribe = onMaybeSubscribe;    }
@SuppressWarnings("rawtypes")    public static void setOnObservableAssembly(@Nullable Function<? super Observable, ? extends Observable> onObservableAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onObservableAssembly = onObservableAssembly;    }
@SuppressWarnings("rawtypes")    public static void setOnConnectableObservableAssembly(@Nullable Function<? super ConnectableObservable, ? extends ConnectableObservable> onConnectableObservableAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onConnectableObservableAssembly = onConnectableObservableAssembly;    }
@SuppressWarnings("rawtypes")    public static void setOnObservableSubscribe(            @Nullable BiFunction<? super Observable, ? super Observer, ? extends Observer> onObservableSubscribe) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onObservableSubscribe = onObservableSubscribe;    }
@SuppressWarnings("rawtypes")    public static void setOnSingleAssembly(@Nullable Function<? super Single, ? extends Single> onSingleAssembly) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onSingleAssembly = onSingleAssembly;    }
@SuppressWarnings("rawtypes")    public static void setOnSingleSubscribe(@Nullable BiFunction<? super Single, ? super SingleObserver, ? extends SingleObserver> onSingleSubscribe) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        RxJavaPlugins.onSingleSubscribe = onSingleSubscribe;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> Subscriber<? super T> onSubscribe(@NonNull Flowable<T> source, @NonNull Subscriber<? super T> subscriber) {        BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> f = onFlowableSubscribe;        if (f != null) {            return apply(f, source, subscriber);        }        return subscriber;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> Observer<? super T> onSubscribe(@NonNull Observable<T> source, @NonNull Observer<? super T> observer) {        BiFunction<? super Observable, ? super Observer, ? extends Observer> f = onObservableSubscribe;        if (f != null) {            return apply(f, source, observer);        }        return observer;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> SingleObserver<? super T> onSubscribe(@NonNull Single<T> source, @NonNull SingleObserver<? super T> observer) {        BiFunction<? super Single, ? super SingleObserver, ? extends SingleObserver> f = onSingleSubscribe;        if (f != null) {            return apply(f, source, observer);        }        return observer;    }
@NonNull    public static CompletableObserver onSubscribe(@NonNull Completable source, @NonNull CompletableObserver observer) {        BiFunction<? super Completable, ? super CompletableObserver, ? extends CompletableObserver> f = onCompletableSubscribe;        if (f != null) {            return apply(f, source, observer);        }        return observer;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> MaybeObserver<? super T> onSubscribe(@NonNull Maybe<T> source, @NonNull MaybeObserver<? super T> observer) {        BiFunction<? super Maybe, ? super MaybeObserver, ? extends MaybeObserver> f = onMaybeSubscribe;        if (f != null) {            return apply(f, source, observer);        }        return observer;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> Maybe<T> onAssembly(@NonNull Maybe<T> source) {        Function<? super Maybe, ? extends Maybe> f = onMaybeAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> Flowable<T> onAssembly(@NonNull Flowable<T> source) {        Function<? super Flowable, ? extends Flowable> f = onFlowableAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> ConnectableFlowable<T> onAssembly(@NonNull ConnectableFlowable<T> source) {        Function<? super ConnectableFlowable, ? extends ConnectableFlowable> f = onConnectableFlowableAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> Observable<T> onAssembly(@NonNull Observable<T> source) {        Function<? super Observable, ? extends Observable> f = onObservableAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> ConnectableObservable<T> onAssembly(@NonNull ConnectableObservable<T> source) {        Function<? super ConnectableObservable, ? extends ConnectableObservable> f = onConnectableObservableAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> Single<T> onAssembly(@NonNull Single<T> source) {        Function<? super Single, ? extends Single> f = onSingleAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@NonNull    public static Completable onAssembly(@NonNull Completable source) {        Function<? super Completable, ? extends Completable> f = onCompletableAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
@SuppressWarnings("rawtypes")    public static void setOnParallelAssembly(@Nullable Function<? super ParallelFlowable, ? extends ParallelFlowable> handler) {        if (lockdown) {            throw new IllegalStateException("Plugins can't be changed anymore");        }        onParallelAssembly = handler;    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @NonNull    public static <T> ParallelFlowable<T> onAssembly(@NonNull ParallelFlowable<T> source) {        Function<? super ParallelFlowable, ? extends ParallelFlowable> f = onParallelAssembly;        if (f != null) {            return apply(f, source);        }        return source;    }
public static boolean onBeforeBlocking() {        BooleanSupplier f = onBeforeBlocking;        if (f != null) {            try {                return f.getAsBoolean();            } catch (Throwable ex) {                throw ExceptionHelper.wrapOrThrow(ex);            }        }        return false;    }
@NonNull    public static Scheduler createComputationScheduler(@NonNull ThreadFactory threadFactory) {        return new ComputationScheduler(ObjectHelper.requireNonNull(threadFactory, "threadFactory is null"));    }
@NonNull    static <T, R> R apply(@NonNull Function<T, R> f, @NonNull T t) {        try {            return f.apply(t);        } catch (Throwable ex) {            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@NonNull    static <T, U, R> R apply(@NonNull BiFunction<T, U, R> f, @NonNull T t, @NonNull U u) {        try {            return f.apply(t, u);        } catch (Throwable ex) {            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@NonNull    static Scheduler callRequireNonNull(@NonNull Callable<Scheduler> s) {        try {            return ObjectHelper.requireNonNull(s.call(), "Scheduler Callable result can't be null");        } catch (Throwable ex) {            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@NonNull    static Scheduler applyRequireNonNull(@NonNull Function<? super Callable<Scheduler>, ? extends Scheduler> f, Callable<Scheduler> s) {        return ObjectHelper.requireNonNull(apply(f, s), "Scheduler Callable result can't be null");    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> amb(final Iterable<? extends MaybeSource<? extends T>> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new MaybeAmb<T>(null, sources));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Maybe<T> ambArray(final MaybeSource<? extends T>... sources) {        if (sources.length == 0) {            return empty();        }        if (sources.length == 1) {            return wrap((MaybeSource<T>)sources[0]);        }        return RxJavaPlugins.onAssembly(new MaybeAmb<T>(sources, null));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concat(Publisher<? extends MaybeSource<? extends T>> sources) {        return concat(sources, 2);    }
@SuppressWarnings("unchecked")    @BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concatArrayDelayError(MaybeSource<? extends T>... sources) {        if (sources.length == 0) {            return Flowable.empty();        } else        if (sources.length == 1) {            return RxJavaPlugins.onAssembly(new MaybeToFlowable<T>((MaybeSource<T>)sources[0]));        }        return RxJavaPlugins.onAssembly(new MaybeConcatArrayDelayError<T>(sources));    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concatArrayEager(MaybeSource<? extends T>... sources) {        return Flowable.fromArray(sources).concatMapEager((Function)MaybeToPublisher.instance());    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concatEager(Iterable<? extends MaybeSource<? extends T>> sources) {        return Flowable.fromIterable(sources).concatMapEager((Function)MaybeToPublisher.instance());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> create(MaybeOnSubscribe<T> onSubscribe) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        return RxJavaPlugins.onAssembly(new MaybeCreate<T>(onSubscribe));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> defer(final Callable<? extends MaybeSource<? extends T>> maybeSupplier) {        ObjectHelper.requireNonNull(maybeSupplier, "maybeSupplier is null");        return RxJavaPlugins.onAssembly(new MaybeDefer<T>(maybeSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Maybe<T> empty() {        return RxJavaPlugins.onAssembly((Maybe<T>)MaybeEmpty.INSTANCE);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> error(Throwable exception) {        ObjectHelper.requireNonNull(exception, "exception is null");        return RxJavaPlugins.onAssembly(new MaybeError<T>(exception));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> error(Callable<? extends Throwable> supplier) {        ObjectHelper.requireNonNull(supplier, "errorSupplier is null");        return RxJavaPlugins.onAssembly(new MaybeErrorCallable<T>(supplier));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) {        ObjectHelper.requireNonNull(completableSource, "completableSource is null");        return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {        ObjectHelper.requireNonNull(singleSource, "singleSource is null");        return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> fromCallable(@NonNull final Callable<? extends T> callable) {        ObjectHelper.requireNonNull(callable, "callable is null");        return RxJavaPlugins.onAssembly(new MaybeFromCallable<T>(callable));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> fromFuture(Future<? extends T> future) {        ObjectHelper.requireNonNull(future, "future is null");        return RxJavaPlugins.onAssembly(new MaybeFromFuture<T>(future, 0L, null));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {        ObjectHelper.requireNonNull(future, "future is null");        ObjectHelper.requireNonNull(unit, "unit is null");        return RxJavaPlugins.onAssembly(new MaybeFromFuture<T>(future, timeout, unit));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> fromRunnable(final Runnable run) {        ObjectHelper.requireNonNull(run, "run is null");        return RxJavaPlugins.onAssembly(new MaybeFromRunnable<T>(run));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> just(T item) {        ObjectHelper.requireNonNull(item, "item is null");        return RxJavaPlugins.onAssembly(new MaybeJust<T>(item));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> merge(Publisher<? extends MaybeSource<? extends T>> sources) {        return merge(sources, Integer.MAX_VALUE);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> mergeArrayDelayError(MaybeSource<? extends T>... sources) {        if (sources.length == 0) {            return Flowable.empty();        }        return Flowable.fromArray(sources).flatMap((Function)MaybeToPublisher.instance(), true, sources.length);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> mergeDelayError(Iterable<? extends MaybeSource<? extends T>> sources) {        return Flowable.fromIterable(sources).flatMap((Function)MaybeToPublisher.instance(), true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Maybe<T> never() {        return RxJavaPlugins.onAssembly((Maybe<T>)MaybeNever.INSTANCE);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(MaybeSource<? extends T> source1, MaybeSource<? extends T> source2) {        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(MaybeSource<? extends T> source1, MaybeSource<? extends T> source2,            BiPredicate<? super T, ? super T> isEqual) {        ObjectHelper.requireNonNull(source1, "source1 is null");        ObjectHelper.requireNonNull(source2, "source2 is null");        ObjectHelper.requireNonNull(isEqual, "isEqual is null");        return RxJavaPlugins.onAssembly(new MaybeEqualSingle<T>(source1, source2, isEqual));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Maybe<Long> timer(long delay, TimeUnit unit) {        return timer(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Maybe<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new MaybeTimer(Math.max(0L, delay), unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> unsafeCreate(MaybeSource<T> onSubscribe) {        if (onSubscribe instanceof Maybe) {            throw new IllegalArgumentException("unsafeCreate(Maybe) should be upgraded");        }        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        return RxJavaPlugins.onAssembly(new MaybeUnsafeCreate<T>(onSubscribe));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, D> Maybe<T> using(Callable<? extends D> resourceSupplier,            Function<? super D, ? extends MaybeSource<? extends T>> sourceSupplier,                    Consumer<? super D> resourceDisposer) {        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, D> Maybe<T> using(Callable<? extends D> resourceSupplier,            Function<? super D, ? extends MaybeSource<? extends T>> sourceSupplier,                    Consumer<? super D> resourceDisposer, boolean eager) {        ObjectHelper.requireNonNull(resourceSupplier, "resourceSupplier is null");        ObjectHelper.requireNonNull(sourceSupplier, "sourceSupplier is null");        ObjectHelper.requireNonNull(resourceDisposer, "disposer is null");        return RxJavaPlugins.onAssembly(new MaybeUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Maybe<T> wrap(MaybeSource<T> source) {        if (source instanceof Maybe) {            return RxJavaPlugins.onAssembly((Maybe<T>)source);        }        ObjectHelper.requireNonNull(source, "onSubscribe is null");        return RxJavaPlugins.onAssembly(new MaybeUnsafeCreate<T>(source));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Maybe<R> zip(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {        ObjectHelper.requireNonNull(zipper, "zipper is null");        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new MaybeZipIterable<T, R>(sources, zipper));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Maybe<R> zipArray(Function<? super Object[], ? extends R> zipper,            MaybeSource<? extends T>... sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        if (sources.length == 0) {            return empty();        }        ObjectHelper.requireNonNull(zipper, "zipper is null");        return RxJavaPlugins.onAssembly(new MaybeZipArray<T, R>(sources, zipper));    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> ambWith(MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return ambArray(this, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingGet() {        BlockingMultiObserver<T> observer = new BlockingMultiObserver<T>();        subscribe(observer);        return observer.blockingGet();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingGet(T defaultValue) {        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");        BlockingMultiObserver<T> observer = new BlockingMultiObserver<T>();        subscribe(observer);        return observer.blockingGet(defaultValue);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> cache() {        return RxJavaPlugins.onAssembly(new MaybeCache<T>(this));    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Maybe<R> compose(MaybeTransformer<? super T, ? extends R> transformer) {        return wrap(((MaybeTransformer<T, R>) ObjectHelper.requireNonNull(transformer, "transformer is null")).apply(this));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Maybe<R> concatMap(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new MaybeFlatten<T, R>(this, mapper));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> concatWith(MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return concat(this, other);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> contains(final Object item) {        ObjectHelper.requireNonNull(item, "item is null");        return RxJavaPlugins.onAssembly(new MaybeContains<T>(this, item));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Long> count() {        return RxJavaPlugins.onAssembly(new MaybeCount<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Maybe<T> delay(long delay, TimeUnit unit) {        return delay(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Maybe<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new MaybeDelay<T>(this, Math.max(0L, delay), unit, scheduler));    }
@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Maybe<T> delaySubscription(Publisher<U> subscriptionIndicator) {        ObjectHelper.requireNonNull(subscriptionIndicator, "subscriptionIndicator is null");        return RxJavaPlugins.onAssembly(new MaybeDelaySubscriptionOtherPublisher<T, U>(this, subscriptionIndicator));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Maybe<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {        return delaySubscription(Flowable.timer(delay, unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> doOnError(Consumer<? super Throwable> onError) {        return RxJavaPlugins.onAssembly(new MaybePeek<T>(this,                Functions.emptyConsumer(), // onSubscribe                Functions.emptyConsumer(), // onSuccess                ObjectHelper.requireNonNull(onError, "onError is null"),                Functions.EMPTY_ACTION,    // onComplete                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)                Functions.EMPTY_ACTION     // dispose        ));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> doOnEvent(BiConsumer<? super T, ? super Throwable> onEvent) {        ObjectHelper.requireNonNull(onEvent, "onEvent is null");        return RxJavaPlugins.onAssembly(new MaybeDoOnEvent<T>(this, onEvent));    }
@Experimental    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> doOnTerminate(final Action onTerminate) {        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");        return RxJavaPlugins.onAssembly(new MaybeDoOnTerminate<T>(this, onTerminate));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Maybe<R> flatMap(Function<? super T, ? extends MaybeSource<? extends U>> mapper,            BiFunction<? super T, ? super U, ? extends R> resultSelector) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.requireNonNull(resultSelector, "resultSelector is null");        return RxJavaPlugins.onAssembly(new MaybeFlatMapBiSelector<T, U, R>(this, mapper, resultSelector));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Flowable<U> flattenAsFlowable(final Function<? super T, ? extends Iterable<? extends U>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableFlowable<T, U>(this, mapper));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> hide() {        return RxJavaPlugins.onAssembly(new MaybeHide<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable ignoreElement() {        return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> isEmpty() {        return RxJavaPlugins.onAssembly(new MaybeIsEmptySingle<T>(this));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Maybe<R> lift(final MaybeOperator<? extends R, ? super T> lift) {        ObjectHelper.requireNonNull(lift, "lift is null");        return RxJavaPlugins.onAssembly(new MaybeLift<T, R>(this, lift));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Maybe<R> map(Function<? super T, ? extends R> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new MaybeMap<T, R>(this, mapper));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Maybe<U> ofType(final Class<U> clazz) {        ObjectHelper.requireNonNull(clazz, "clazz is null");        return filter(Functions.isInstanceOf(clazz)).cast(clazz);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> R to(Function<? super Maybe<T>, R> convert) {        try {            return ObjectHelper.requireNonNull(convert, "convert is null").apply(this);        } catch (Throwable ex) {            Exceptions.throwIfFatal(ex);            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> toObservable() {        if (this instanceof FuseToObservable) {            return ((FuseToObservable<T>)this).fuseToObservable();        }        return RxJavaPlugins.onAssembly(new MaybeToObservable<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> toSingle() {        return RxJavaPlugins.onAssembly(new MaybeToSingle<T>(this, null));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> onErrorComplete() {        return onErrorComplete(Functions.alwaysTrue());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> onErrorResumeNext(final MaybeSource<? extends T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return onErrorResumeNext(Functions.justFunction(next));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> onErrorResumeNext(Function<? super Throwable, ? extends MaybeSource<? extends T>> resumeFunction) {        ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");        return RxJavaPlugins.onAssembly(new MaybeOnErrorNext<T>(this, resumeFunction, true));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {        ObjectHelper.requireNonNull(valueSupplier, "valueSupplier is null");        return RxJavaPlugins.onAssembly(new MaybeOnErrorReturn<T>(this, valueSupplier));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> onTerminateDetach() {        return RxJavaPlugins.onAssembly(new MaybeDetach<T>(this));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> repeatUntil(BooleanSupplier stop) {        return toFlowable().repeatUntil(stop);    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> repeatWhen(final Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {        return toFlowable().repeatWhen(handler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {        return toFlowable().retry(predicate).singleElement();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> retry(long count) {        return retry(count, Functions.alwaysTrue());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) {        return toFlowable().retry(times, predicate).singleElement();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> retryWhen(            final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {        return toFlowable().retryWhen(handler).singleElement();    }
@SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe() {        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(Consumer<? super T> onSuccess, Consumer<? super Throwable> onError) {        return subscribe(onSuccess, onError, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> switchIfEmpty(MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new MaybeSwitchIfEmpty<T>(this, other));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> switchIfEmpty(SingleSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new MaybeSwitchIfEmptySingle<T>(this, other));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Maybe<T> takeUntil(MaybeSource<U> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new MaybeTakeUntilMaybe<T, U>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Maybe<T> timeout(long timeout, TimeUnit timeUnit) {        return timeout(timeout, timeUnit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Maybe<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {        return timeout(timer(timeout, timeUnit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Maybe<T> timeout(MaybeSource<U> timeoutIndicator) {        ObjectHelper.requireNonNull(timeoutIndicator, "timeoutIndicator is null");        return RxJavaPlugins.onAssembly(new MaybeTimeoutMaybe<T, U>(this, timeoutIndicator, null));    }
@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Maybe<T> timeout(Publisher<U> timeoutIndicator) {        ObjectHelper.requireNonNull(timeoutIndicator, "timeoutIndicator is null");        return RxJavaPlugins.onAssembly(new MaybeTimeoutPublisher<T, U>(this, timeoutIndicator, null));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Maybe<T> unsubscribeOn(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new MaybeUnsubscribeOn<T>(this, scheduler));    }
public static <T> ConnectableFlowable<T> create(Flowable<T> source, final int bufferSize) {        // the current connection to source needs to be shared between the operator and its onSubscribe call        final AtomicReference<PublishSubscriber<T>> curr = new AtomicReference<PublishSubscriber<T>>();        Publisher<T> onSubscribe = new FlowablePublisher<T>(curr, bufferSize);        return RxJavaPlugins.onAssembly(new FlowablePublish<T>(onSubscribe, source, curr, bufferSize));    }
public static <T> SingleObserver<T> create(Observer<? super T> downstream) {        return new SingleToObservableObserver<T>(downstream);    }
public static <T> T requireNonNull(T object, String message) {        if (object == null) {            throw new NullPointerException(message);        }        return object;    }
@SuppressWarnings("unchecked")    public static <T> BiPredicate<T, T> equalsPredicate() {        return (BiPredicate<T, T>)EQUALS;    }
public static void onError(Subscriber<?> subscriber, Throwable ex,            AtomicInteger wip, AtomicThrowable error) {        if (error.addThrowable(ex)) {            if (wip.getAndIncrement() == 0) {                subscriber.onError(error.terminate());            }        } else {            RxJavaPlugins.onError(ex);        }    }
public static void onComplete(Subscriber<?> subscriber, AtomicInteger wip, AtomicThrowable error) {        if (wip.getAndIncrement() == 0) {            Throwable ex = error.terminate();            if (ex != null) {                subscriber.onError(ex);            } else {                subscriber.onComplete();            }        }    }
public static void onError(Observer<?> observer, Throwable ex,            AtomicInteger wip, AtomicThrowable error) {        if (error.addThrowable(ex)) {            if (wip.getAndIncrement() == 0) {                observer.onError(error.terminate());            }        } else {            RxJavaPlugins.onError(ex);        }    }
public static void onComplete(Observer<?> observer, AtomicInteger wip, AtomicThrowable error) {        if (wip.getAndIncrement() == 0) {            Throwable ex = error.terminate();            if (ex != null) {                observer.onError(ex);            } else {                observer.onComplete();            }        }    }
@SuppressWarnings("unchecked")    public static <T> Function<T, T> identity() {        return (Function<T, T>)IDENTITY;    }
public static <T> Callable<T> justCallable(T value) {        return new JustValue<Object, T>(value);    }
public static <T, U> Function<T, U> justFunction(U value) {        return new JustValue<T, U>(value);    }
public static <T, U> Function<T, U> castFunction(Class<U> target) {        return new CastToClass<T, U>(target);    }
private void printStackTrace(PrintStreamOrWriter s) {        StringBuilder b = new StringBuilder(128);        b.append(this).append('\n');        for (StackTraceElement myStackElement : getStackTrace()) {            b.append("\tat ").append(myStackElement).append('\n');        }        int i = 1;        for (Throwable ex : exceptions) {            b.append("  ComposedException ").append(i).append(" :\n");            appendStackTrace(b, ex, "\t");            i++;        }        s.println(b.toString());    }
Throwable getRootCause(Throwable e) {        Throwable root = e.getCause();        if (root == null || e == root) {            return e;        }        while (true) {            Throwable cause = root.getCause();            if (cause == null || cause == root) {                return root;            }            root = cause;        }    }
@CheckReturnValue    @NonNull    public static <T> UnicastSubject<T> create() {        return new UnicastSubject<T>(bufferSize(), true);    }
@CheckReturnValue    @NonNull    public static <T> UnicastSubject<T> create(int capacityHint) {        return new UnicastSubject<T>(capacityHint, true);    }
@CheckReturnValue    @NonNull    public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) {        return new UnicastSubject<T>(capacityHint, onTerminate, true);    }
@CheckReturnValue    @NonNull    public static <T> UnicastSubject<T> create(boolean delayError) {        return new UnicastSubject<T>(bufferSize(), delayError);    }
public boolean offer(T t) {        if (t == null) {            onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));            return true;        }        PublishSubscription<T>[] array = subscribers.get();        for (PublishSubscription<T> s : array) {            if (s.isFull()) {                return false;            }        }        for (PublishSubscription<T> s : array) {            s.onNext(t);        }        return true;    }
@SuppressWarnings("unchecked")    @Override    public final void onSubscribe(Disposable d) {        if (DisposableHelper.validate(this.upstream, d)) {            this.upstream = d;            if (d instanceof QueueDisposable) {                this.qd = (QueueDisposable<T>)d;            }            if (beforeDownstream()) {                downstream.onSubscribe(this);                afterDownstream();            }        }    }
@Override    public void onError(Throwable t) {        if (done) {            RxJavaPlugins.onError(t);            return;        }        done = true;        downstream.onError(t);    }
protected final void fail(Throwable t) {        Exceptions.throwIfFatal(t);        upstream.dispose();        onError(t);    }
protected final int transitiveBoundaryFusion(int mode) {        QueueDisposable<T> qd = this.qd;        if (qd != null) {            if ((mode & BOUNDARY) == 0) {                int m = qd.requestFusion(mode);                if (m != NONE) {                    sourceMode = m;                }                return m;            }        }        return NONE;    }
public Throwable blockingGetError() {        if (getCount() != 0) {            try {                BlockingHelper.verifyNonBlocking();                await();            } catch (InterruptedException ex) {                dispose();                return ex;            }        }        return error;    }
public Throwable blockingGetError(long timeout, TimeUnit unit) {        if (getCount() != 0) {            try {                BlockingHelper.verifyNonBlocking();                if (!await(timeout, unit)) {                    dispose();                    throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));                }            } catch (InterruptedException ex) {                dispose();                throw ExceptionHelper.wrapOrThrow(ex);            }        }        return error;    }
public boolean blockingAwait(long timeout, TimeUnit unit) {        if (getCount() != 0) {            try {                BlockingHelper.verifyNonBlocking();                if (!await(timeout, unit)) {                    dispose();                    return false;                }            } catch (InterruptedException ex) {                dispose();                throw ExceptionHelper.wrapOrThrow(ex);            }        }        Throwable ex = error;        if (ex != null) {            throw ExceptionHelper.wrapOrThrow(ex);        }        return true;    }
@CheckReturnValue    @NonNull    public static <T> ReplayProcessor<T> create(int capacityHint) {        return new ReplayProcessor<T>(new UnboundedReplayBuffer<T>(capacityHint));    }
@CheckReturnValue    @NonNull    public static <T> ReplayProcessor<T> createWithSize(int maxSize) {        return new ReplayProcessor<T>(new SizeBoundReplayBuffer<T>(maxSize));    }
static <T> ReplayProcessor<T> createUnbounded() {        return new ReplayProcessor<T>(new SizeBoundReplayBuffer<T>(Integer.MAX_VALUE));    }
@CheckReturnValue    @NonNull    public static <T> ReplayProcessor<T> createWithTime(long maxAge, TimeUnit unit, Scheduler scheduler) {        return new ReplayProcessor<T>(new SizeAndTimeBoundReplayBuffer<T>(Integer.MAX_VALUE, maxAge, unit, scheduler));    }
@SuppressWarnings("unchecked")    @Override    public final void onSubscribe(Subscription s) {        if (SubscriptionHelper.validate(this.upstream, s)) {            this.upstream = s;            if (s instanceof QueueSubscription) {                this.qs = (QueueSubscription<T>)s;            }            if (beforeDownstream()) {                downstream.onSubscribe(this);                afterDownstream();            }        }    }
protected final void fail(Throwable t) {        Exceptions.throwIfFatal(t);        upstream.cancel();        onError(t);    }
protected final int transitiveBoundaryFusion(int mode) {        QueueSubscription<T> qs = this.qs;        if (qs != null) {            if ((mode & BOUNDARY) == 0) {                int m = qs.requestFusion(mode);                if (m != NONE) {                    sourceMode = m;                }                return m;            }        }        return NONE;    }
@CheckReturnValue    @NonNull    public static <T> BehaviorSubject<T> createDefault(T defaultValue) {        return new BehaviorSubject<T>(defaultValue);    }
@Nullable    public T getValue() {        Object o = value.get();        if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {            return null;        }        return NotificationLite.getValue(o);    }
@Deprecated    public Object[] getValues() {        @SuppressWarnings("unchecked")        T[] a = (T[])EMPTY_ARRAY;        T[] b = getValues(a);        if (b == EMPTY_ARRAY) {            return new Object[0];        }        return b;    }
@Deprecated    @SuppressWarnings("unchecked")    public T[] getValues(T[] array) {        Object o = value.get();        if (o == null || NotificationLite.isComplete(o) || NotificationLite.isError(o)) {            if (array.length != 0) {                array[0] = null;            }            return array;        }        T v = NotificationLite.getValue(o);        if (array.length != 0) {            array[0] = v;            if (array.length != 1) {                array[1] = null;            }        } else {            array = (T[])Array.newInstance(array.getClass().getComponentType(), 1);            array[0] = v;        }        return array;    }
public boolean hasValue() {        Object o = value.get();        return o != null && !NotificationLite.isComplete(o) && !NotificationLite.isError(o);    }
public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError,            Disposable dispose, QueueDrain<T, U> qd) {        int missed = 1;        for (;;) {            for (;;) {                boolean d = qd.done();                T v = q.poll();                boolean empty = v == null;                if (checkTerminated(d, empty, a, delayError, q, qd)) {                    if (dispose != null) {                        dispose.dispose();                    }                    return;                }                if (empty) {                    break;                }                long r = qd.requested();                if (r != 0L) {                    if (qd.accept(a, v)) {                        if (r != Long.MAX_VALUE) {                            qd.produced(1);                        }                    }                } else {                    q.clear();                    if (dispose != null) {                        dispose.dispose();                    }                    a.onError(new MissingBackpressureException("Could not emit value due to lack of requests."));                    return;                }            }            missed = qd.leave(-missed);            if (missed == 0) {                break;            }        }    }
public static <T> SimpleQueue<T> createQueue(int capacityHint) {        if (capacityHint < 0) {            return new SpscLinkedArrayQueue<T>(-capacityHint);        }        return new SpscArrayQueue<T>(capacityHint);    }
public static void request(Subscription s, int prefetch) {        s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch);    }
public static <T> boolean postCompleteRequest(long n,                                                  Subscriber<? super T> actual,                                                  Queue<T> queue,                                                  AtomicLong state,                                                  BooleanSupplier isCancelled) {        for (; ; ) {            long r = state.get();            // extract the current request amount            long r0 = r & REQUESTED_MASK;            // preserve COMPLETED_MASK and calculate new requested amount            long u = (r & COMPLETED_MASK) | BackpressureHelper.addCap(r0, n);            if (state.compareAndSet(r, u)) {                // (complete, 0) -> (complete, n) transition then replay                if (r == COMPLETED_MASK) {                    postCompleteDrain(n | COMPLETED_MASK, actual, queue, state, isCancelled);                    return true;                }                // (active, r) -> (active, r + n) transition then continue with requesting from upstream                return false;            }        }    }
static <T> boolean postCompleteDrain(long n,                                         Subscriber<? super T> actual,                                         Queue<T> queue,                                         AtomicLong state,                                         BooleanSupplier isCancelled) {// TODO enable fast-path//        if (n == -1 || n == Long.MAX_VALUE) {//            for (;;) {//                if (isCancelled.getAsBoolean()) {//                    break;//                }////                T v = queue.poll();////                if (v == null) {//                    actual.onComplete();//                    break;//                }////                actual.onNext(v);//            }////            return true;//        }        long e = n & COMPLETED_MASK;        for (; ; ) {            while (e != n) {                if (isCancelled(isCancelled)) {                    return true;                }                T t = queue.poll();                if (t == null) {                    actual.onComplete();                    return true;                }                actual.onNext(t);                e++;            }            if (isCancelled(isCancelled)) {                return true;            }            if (queue.isEmpty()) {                actual.onComplete();                return true;            }            n = state.get();            if (n == e) {                n = state.addAndGet(-(e & REQUESTED_MASK));                if ((n & REQUESTED_MASK) == 0L) {                    return false;                }                e = n & COMPLETED_MASK;            }        }    }
public static <T> void postComplete(Subscriber<? super T> actual,                                        Queue<T> queue,                                        AtomicLong state,                                        BooleanSupplier isCancelled) {        if (queue.isEmpty()) {            actual.onComplete();            return;        }        if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) {            return;        }        for (; ; ) {            long r = state.get();            if ((r & COMPLETED_MASK) != 0L) {                return;            }            long u = r | COMPLETED_MASK;            // (active, r) -> (complete, r) transition            if (state.compareAndSet(r, u)) {                // if the requested amount was non-zero, drain the queue                if (r != 0L) {                    postCompleteDrain(u, actual, queue, state, isCancelled);                }                return;            }        }    }
@CheckReturnValue    @NonNull    public static <T> ReplaySubject<T> create() {        return new ReplaySubject<T>(new UnboundedReplayBuffer<T>(16));    }
@CheckReturnValue    @NonNull    public static <T> ReplaySubject<T> createWithSize(int maxSize) {        return new ReplaySubject<T>(new SizeBoundReplayBuffer<T>(maxSize));    }
static <T> ReplaySubject<T> createUnbounded() {        return new ReplaySubject<T>(new SizeBoundReplayBuffer<T>(Integer.MAX_VALUE));    }
protected final void complete(R n) {        long p = produced;        if (p != 0) {            BackpressureHelper.produced(this, p);        }        for (;;) {            long r = get();            if ((r & COMPLETE_MASK) != 0) {                onDrop(n);                return;            }            if ((r & REQUEST_MASK) != 0) {                lazySet(COMPLETE_MASK + 1);                downstream.onNext(n);                downstream.onComplete();                return;            }            value = n;            if (compareAndSet(0, COMPLETE_MASK)) {                return;            }            value = null;        }    }
@Deprecated    public Object[] getValues() {        T v = getValue();        return v != null ? new Object[] { v } : new Object[0];    }
@Deprecated    public T[] getValues(T[] array) {        T v = getValue();        if (v == null) {            if (array.length != 0) {                array[0] = null;            }            return array;        }        if (array.length == 0) {            array = Arrays.copyOf(array, 1);        }        array[0] = v;        if (array.length != 1) {            array[1] = null;        }        return array;    }
@SuppressWarnings("unchecked")    @Nullable    public T getValue() {        Object o = value;        if (o != null && !NotificationLite.isError(o)) {            return (T)value;        }        return null;    }
@Nullable    public Throwable getError() {        Object o = value;        if (NotificationLite.isError(o)) {            return NotificationLite.getError(o);        }        return null;    }
@NonNull    public static <T> Notification<T> createOnNext(@NonNull T value) {        ObjectHelper.requireNonNull(value, "value is null");        return new Notification<T>(value);    }
@NonNull    public static <T> Notification<T> createOnError(@NonNull Throwable error) {        ObjectHelper.requireNonNull(error, "error is null");        return new Notification<T>(NotificationLite.error(error));    }
public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) {        ObjectHelper.requireNonNull(next, "next is null");        if (upstream != null) {            next.dispose();            if (upstream != DisposableHelper.DISPOSED) {                reportDoubleSubscription(observer);            }            return false;        }        return true;    }
public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) {        ObjectHelper.requireNonNull(next, "next is null");        if (!upstream.compareAndSet(null, next)) {            next.dispose();            if (upstream.get() != DisposableHelper.DISPOSED) {                reportDoubleSubscription(observer);            }            return false;        }        return true;    }
public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) {        ObjectHelper.requireNonNull(next, "next is null");        if (upstream != null) {            next.cancel();            if (upstream != SubscriptionHelper.CANCELLED) {                reportDoubleSubscription(subscriber);            }            return false;        }        return true;    }
public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) {        ObjectHelper.requireNonNull(next, "next is null");        if (!upstream.compareAndSet(null, next)) {            next.cancel();            if (upstream.get() != SubscriptionHelper.CANCELLED) {                reportDoubleSubscription(subscriber);            }            return false;        }        return true;    }
void add(CacheSubscription<T> consumer) {        for (;;) {            CacheSubscription<T>[] current = subscribers.get();            if (current == TERMINATED) {                return;            }            int n = current.length;            @SuppressWarnings("unchecked")            CacheSubscription<T>[] next = new CacheSubscription[n + 1];            System.arraycopy(current, 0, next, 0, n);            next[n] = consumer;            if (subscribers.compareAndSet(current, next)) {                return;            }        }    }
@SuppressWarnings("unchecked")    void remove(CacheSubscription<T> consumer) {        for (;;) {            CacheSubscription<T>[] current = subscribers.get();            int n = current.length;            if (n == 0) {                return;            }            int j = -1;            for (int i = 0; i < n; i++) {                if (current[i] == consumer) {                    j = i;                    break;                }            }            if (j < 0) {                return;            }            CacheSubscription<T>[] next;            if (n == 1) {                next = EMPTY;            } else {                next = new CacheSubscription[n - 1];                System.arraycopy(current, 0, next, 0, j);                System.arraycopy(current, j + 1, next, j, n - j - 1);            }            if (subscribers.compareAndSet(current, next)) {                return;            }        }    }
void replay(CacheSubscription<T> consumer) {        // make sure there is only one replay going on at a time        if (consumer.getAndIncrement() != 0) {            return;        }        // see if there were more replay request in the meantime        int missed = 1;        // read out state into locals upfront to avoid being re-read due to volatile reads        long index = consumer.index;        int offset = consumer.offset;        Node<T> node = consumer.node;        AtomicLong requested = consumer.requested;        Subscriber<? super T> downstream = consumer.downstream;        int capacity = capacityHint;        for (;;) {            // first see if the source has terminated, read order matters!            boolean sourceDone = done;            // and if the number of items is the same as this consumer has received            boolean empty = size == index;            // if the source is done and we have all items so far, terminate the consumer            if (sourceDone && empty) {                // release the node object to avoid leaks through retained consumers                consumer.node = null;                // if error is not null then the source failed                Throwable ex = error;                if (ex != null) {                    downstream.onError(ex);                } else {                    downstream.onComplete();                }                return;            }            // there are still items not sent to the consumer            if (!empty) {                // see how many items the consumer has requested in total so far                long consumerRequested = requested.get();                // MIN_VALUE indicates a cancelled consumer, we stop replaying                if (consumerRequested == Long.MIN_VALUE) {                    // release the node object to avoid leaks through retained consumers                    consumer.node = null;                    return;                }                // if the consumer has requested more and there is more, we will emit an item                if (consumerRequested != index) {                    // if the offset in the current node has reached the node capacity                    if (offset == capacity) {                        // switch to the subsequent node                        node = node.next;                        // reset the in-node offset                        offset = 0;                    }                    // emit the cached item                    downstream.onNext(node.values[offset]);                    // move the node offset forward                    offset++;                    // move the total consumed item count forward                    index++;                    // retry for the next item/terminal event if any                    continue;                }            }            // commit the changed references back            consumer.index = index;            consumer.offset = offset;            consumer.node = node;            // release the changes and see if there were more replay request in the meantime            missed = consumer.addAndGet(-missed);            if (missed == 0) {                break;            }        }    }
public static long addCap(long a, long b) {        long u = a + b;        if (u < 0L) {            return Long.MAX_VALUE;        }        return u;    }
public static long multiplyCap(long a, long b) {        long u = a * b;        if (((a | b) >>> 31) != 0) {            if (u / a != b) {                return Long.MAX_VALUE;            }        }        return u;    }
public static long add(AtomicLong requested, long n) {        for (;;) {            long r = requested.get();            if (r == Long.MAX_VALUE) {                return Long.MAX_VALUE;            }            long u = addCap(r, n);            if (requested.compareAndSet(r, u)) {                return r;            }        }    }
public static long addCancel(AtomicLong requested, long n) {        for (;;) {            long r = requested.get();            if (r == Long.MIN_VALUE) {                return Long.MIN_VALUE;            }            if (r == Long.MAX_VALUE) {                return Long.MAX_VALUE;            }            long u = addCap(r, n);            if (requested.compareAndSet(r, u)) {                return r;            }        }    }
public static long produced(AtomicLong requested, long n) {        for (;;) {            long current = requested.get();            if (current == Long.MAX_VALUE) {                return Long.MAX_VALUE;            }            long update = current - n;            if (update < 0L) {                RxJavaPlugins.onError(new IllegalStateException("More produced than requested: " + update));                update = 0L;            }            if (requested.compareAndSet(current, update)) {                return update;            }        }    }
public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {        final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();        BlockingObserver<T> bs = new BlockingObserver<T>(queue);        observer.onSubscribe(bs);        o.subscribe(bs);        for (;;) {            if (bs.isDisposed()) {                break;            }            Object v = queue.poll();            if (v == null) {                try {                    v = queue.take();                } catch (InterruptedException ex) {                    bs.dispose();                    observer.onError(ex);                    return;                }            }            if (bs.isDisposed()                    || o == BlockingObserver.TERMINATED                    || NotificationLite.acceptFull(v, observer)) {                break;            }        }    }
public static <T> void subscribe(ObservableSource<? extends T> o) {        BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();        LambdaObserver<T> ls = new LambdaObserver<T>(Functions.emptyConsumer(),        callback, callback, Functions.emptyConsumer());        o.subscribe(ls);        BlockingHelper.awaitForComplete(callback, ls);        Throwable e = callback.error;        if (e != null) {            throw ExceptionHelper.wrapOrThrow(e);        }    }
public static <T> void subscribe(ObservableSource<? extends T> o, final Consumer<? super T> onNext,            final Consumer<? super Throwable> onError, final Action onComplete) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        subscribe(o, new LambdaObserver<T>(onNext, onError, onComplete, Functions.emptyConsumer()));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable concatArray(CompletableSource... sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        if (sources.length == 0) {            return complete();        } else        if (sources.length == 1) {            return wrap(sources[0]);        }        return RxJavaPlugins.onAssembly(new CompletableConcatArray(sources));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable concat(Iterable<? extends CompletableSource> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new CompletableConcatIterable(sources));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public static Completable concat(Publisher<? extends CompletableSource> sources) {        return concat(sources, 2);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public static Completable concat(Publisher<? extends CompletableSource> sources, int prefetch) {        ObjectHelper.requireNonNull(sources, "sources is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new CompletableConcat(sources, prefetch));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable create(CompletableOnSubscribe source) {        ObjectHelper.requireNonNull(source, "source is null");        return RxJavaPlugins.onAssembly(new CompletableCreate(source));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable error(final Throwable error) {        ObjectHelper.requireNonNull(error, "error is null");        return RxJavaPlugins.onAssembly(new CompletableError(error));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable fromAction(final Action run) {        ObjectHelper.requireNonNull(run, "run is null");        return RxJavaPlugins.onAssembly(new CompletableFromAction(run));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable fromCallable(final Callable<?> callable) {        ObjectHelper.requireNonNull(callable, "callable is null");        return RxJavaPlugins.onAssembly(new CompletableFromCallable(callable));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable fromFuture(final Future<?> future) {        ObjectHelper.requireNonNull(future, "future is null");        return fromAction(Functions.futureAction(future));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Completable fromMaybe(final MaybeSource<T> maybe) {        ObjectHelper.requireNonNull(maybe, "maybe is null");        return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(maybe));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable fromRunnable(final Runnable run) {        ObjectHelper.requireNonNull(run, "run is null");        return RxJavaPlugins.onAssembly(new CompletableFromRunnable(run));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Completable fromSingle(final SingleSource<T> single) {        ObjectHelper.requireNonNull(single, "single is null");        return RxJavaPlugins.onAssembly(new CompletableFromSingle<T>(single));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable mergeArray(CompletableSource... sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        if (sources.length == 0) {            return complete();        } else        if (sources.length == 1) {            return wrap(sources[0]);        }        return RxJavaPlugins.onAssembly(new CompletableMergeArray(sources));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable merge(Iterable<? extends CompletableSource> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new CompletableMergeIterable(sources));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    public static Completable merge(Publisher<? extends CompletableSource> sources) {        return merge0(sources, Integer.MAX_VALUE, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public static Completable merge(Publisher<? extends CompletableSource> sources, int maxConcurrency) {        return merge0(sources, maxConcurrency, false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    public static Completable mergeDelayError(Publisher<? extends CompletableSource> sources) {        return merge0(sources, Integer.MAX_VALUE, true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public static Completable mergeDelayError(Publisher<? extends CompletableSource> sources, int maxConcurrency) {        return merge0(sources, maxConcurrency, true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable never() {        return RxJavaPlugins.onAssembly(CompletableNever.INSTANCE);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Completable timer(long delay, TimeUnit unit) {        return timer(delay, unit, Schedulers.computation());    }
private static NullPointerException toNpe(Throwable ex) {        NullPointerException npe = new NullPointerException("Actually not, but can't pass out an exception otherwise...");        npe.initCause(ex);        return npe;    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <R> Completable using(Callable<R> resourceSupplier,            Function<? super R, ? extends CompletableSource> completableFunction,            Consumer<? super R> disposer) {        return using(resourceSupplier, completableFunction, disposer, true);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static Completable wrap(CompletableSource source) {        ObjectHelper.requireNonNull(source, "source is null");        if (source instanceof Completable) {            return RxJavaPlugins.onAssembly((Completable)source);        }        return RxJavaPlugins.onAssembly(new CompletableFromUnsafeSource(source));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable ambWith(CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return ambArray(this, other);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Observable<T> andThen(ObservableSource<T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return RxJavaPlugins.onAssembly(new CompletableAndThenObservable<T>(this, next));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Flowable<T> andThen(Publisher<T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return RxJavaPlugins.onAssembly(new CompletableAndThenPublisher<T>(this, next));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Single<T> andThen(SingleSource<T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable<T>(next, this));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Maybe<T> andThen(MaybeSource<T> next) {        ObjectHelper.requireNonNull(next, "next is null");        return RxJavaPlugins.onAssembly(new MaybeDelayWithCompletable<T>(next, this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable andThen(CompletableSource next) {        ObjectHelper.requireNonNull(next, "next is null");        return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, next));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> R as(@NonNull CompletableConverter<? extends R> converter) {        return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);    }
@SchedulerSupport(SchedulerSupport.NONE)    public final void blockingAwait() {        BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();        subscribe(observer);        observer.blockingGet();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable compose(CompletableTransformer transformer) {        return wrap(ObjectHelper.requireNonNull(transformer, "transformer is null").apply(this));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable concatWith(CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable delay(long delay, TimeUnit unit, Scheduler scheduler) {        return delay(delay, unit, scheduler, false);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable delay(final long delay, final TimeUnit unit, final Scheduler scheduler, final boolean delayError) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new CompletableDelay(this, delay, unit, scheduler, delayError));    }
@CheckReturnValue    @Experimental    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Completable delaySubscription(long delay, TimeUnit unit) {        return delaySubscription(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @Experimental    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {        return Completable.timer(delay, unit, scheduler).andThen(this);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable doOnComplete(Action onComplete) {        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),                onComplete, Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable doOnDispose(Action onDispose) {        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION, onDispose);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable doOnError(Consumer<? super Throwable> onError) {        return doOnLifecycle(Functions.emptyConsumer(), onError,                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    private Completable doOnLifecycle(            final Consumer<? super Disposable> onSubscribe,            final Consumer<? super Throwable> onError,            final Action onComplete,            final Action onTerminate,            final Action onAfterTerminate,            final Action onDispose) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");        ObjectHelper.requireNonNull(onDispose, "onDispose is null");        return RxJavaPlugins.onAssembly(new CompletablePeek(this, onSubscribe, onError, onComplete, onTerminate, onAfterTerminate, onDispose));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable doOnSubscribe(Consumer<? super Disposable> onSubscribe) {        return doOnLifecycle(onSubscribe, Functions.emptyConsumer(),                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable doOnTerminate(final Action onTerminate) {        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),                Functions.EMPTY_ACTION, onTerminate,                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable doAfterTerminate(final Action onAfterTerminate) {        return doOnLifecycle(                Functions.emptyConsumer(),                Functions.emptyConsumer(),                Functions.EMPTY_ACTION,                Functions.EMPTY_ACTION,                onAfterTerminate,                Functions.EMPTY_ACTION);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable observeOn(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new CompletableObserveOn(this, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable onErrorComplete(final Predicate<? super Throwable> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new CompletableOnErrorComplete(this, predicate));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable onErrorResumeNext(final Function<? super Throwable, ? extends CompletableSource> errorMapper) {        ObjectHelper.requireNonNull(errorMapper, "errorMapper is null");        return RxJavaPlugins.onAssembly(new CompletableResumeNext(this, errorMapper));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable repeat(long times) {        return fromPublisher(toFlowable().repeat(times));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable repeatUntil(BooleanSupplier stop) {        return fromPublisher(toFlowable().repeatUntil(stop));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {        return fromPublisher(toFlowable().repeatWhen(handler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable retry(BiPredicate<? super Integer, ? super Throwable> predicate) {        return fromPublisher(toFlowable().retry(predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable retry(long times) {        return fromPublisher(toFlowable().retry(times));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable retry(long times, Predicate<? super Throwable> predicate) {        return fromPublisher(toFlowable().retry(times, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {        return fromPublisher(toFlowable().retryWhen(handler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Observable<T> startWith(Observable<T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return other.concatWith(this.<T>toObservable());    }
@SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe() {        EmptyCompletableObserver observer = new EmptyCompletableObserver();        subscribe(observer);        return observer;    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <E extends CompletableObserver> E subscribeWith(E observer) {        subscribe(observer);        return observer;    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable subscribeOn(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new CompletableSubscribeOn(this, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable takeUntil(CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new CompletableTakeUntilCompletable(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Completable timeout(long timeout, TimeUnit unit) {        return timeout0(timeout, unit, Schedulers.computation(), null);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Completable timeout(long timeout, TimeUnit unit, CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return timeout0(timeout, unit, Schedulers.computation(), other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler) {        return timeout0(timeout, unit, scheduler, null);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return timeout0(timeout, unit, scheduler, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> U to(Function<? super Completable, U> converter) {        try {            return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);        } catch (Throwable ex) {            Exceptions.throwIfFatal(ex);            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@CheckReturnValue    @SuppressWarnings("unchecked")    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Flowable<T> toFlowable() {        if (this instanceof FuseToFlowable) {            return ((FuseToFlowable<T>)this).fuseToFlowable();        }        return RxJavaPlugins.onAssembly(new CompletableToFlowable<T>(this));    }
@CheckReturnValue    @SuppressWarnings("unchecked")    @SchedulerSupport(SchedulerSupport.NONE)    public final <T> Maybe<T> toMaybe() {        if (this instanceof FuseToMaybe) {            return ((FuseToMaybe<T>)this).fuseToMaybe();        }        return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(this));    }
static <T> boolean tryAsCompletable(Object source,            Function<? super T, ? extends CompletableSource> mapper,            CompletableObserver observer) {        if (source instanceof Callable) {            @SuppressWarnings("unchecked")            Callable<T> call = (Callable<T>) source;            CompletableSource cs = null;            try {                T item = call.call();                if (item != null) {                    cs = ObjectHelper.requireNonNull(mapper.apply(item), "The mapper returned a null CompletableSource");                }            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                EmptyDisposable.error(ex, observer);                return true;            }            if (cs == null) {                EmptyDisposable.complete(observer);            } else {                cs.subscribe(observer);            }            return true;        }        return false;    }
static <T, R> boolean tryAsMaybe(Object source,            Function<? super T, ? extends MaybeSource<? extends R>> mapper,            Observer<? super R> observer) {        if (source instanceof Callable) {            @SuppressWarnings("unchecked")            Callable<T> call = (Callable<T>) source;            MaybeSource<? extends R> cs = null;            try {                T item = call.call();                if (item != null) {                    cs = ObjectHelper.requireNonNull(mapper.apply(item), "The mapper returned a null MaybeSource");                }            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                EmptyDisposable.error(ex, observer);                return true;            }            if (cs == null) {                EmptyDisposable.complete(observer);            } else {                cs.subscribe(MaybeToObservable.create(observer));            }            return true;        }        return false;    }
public void add(Object o) {        // if no value yet, create the first array        if (size == 0) {            head = new Object[capacityHint + 1];            tail = head;            head[0] = o;            indexInTail = 1;            size = 1;        } else        // if the tail is full, create a new tail and link        if (indexInTail == capacityHint) {            Object[] t = new Object[capacityHint + 1];            t[0] = o;            tail[capacityHint] = t;            tail = t;            indexInTail = 1;            size++;        } else {            tail[indexInTail] = o;            indexInTail++;            size++;        }    }
public static void shutdown() {        ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null);        if (exec != null) {            exec.shutdownNow();        }        POOLS.clear();    }
public static ScheduledExecutorService create(ThreadFactory factory) {        final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);        tryPutIntoPool(PURGE_ENABLED, exec);        return exec;    }
public final void setSubscription(Subscription s) {        if (cancelled) {            s.cancel();            return;        }        ObjectHelper.requireNonNull(s, "s is null");        if (get() == 0 && compareAndSet(0, 1)) {            Subscription a = actual;            if (a != null && cancelOnReplace) {                a.cancel();            }            actual = s;            long r = requested;            if (decrementAndGet() != 0) {                drainLoop();            }            if (r != 0L) {                s.request(r);            }            return;        }        Subscription a = missedSubscription.getAndSet(s);        if (a != null && cancelOnReplace) {            a.cancel();        }        drain();    }
void emitLoop() {        for (;;) {            AppendOnlyLinkedArrayList<Object> q;            synchronized (this) {                q = queue;                if (q == null) {                    emitting = false;                    return;                }                queue = null;            }            q.forEachWhile(this);        }    }
@Override    protected void subscribeActual(SingleObserver<? super T> observer) {        source.subscribe(new LastSubscriber<T>(observer, defaultItem));    }
public static void throwIfFatal(@NonNull Throwable t) {        // values here derived from https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495        if (t instanceof VirtualMachineError) {            throw (VirtualMachineError) t;        } else if (t instanceof ThreadDeath) {            throw (ThreadDeath) t;        } else if (t instanceof LinkageError) {            throw (LinkageError) t;        }    }
public static RuntimeException wrapOrThrow(Throwable error) {        if (error instanceof Error) {            throw (Error)error;        }        if (error instanceof RuntimeException) {            return (RuntimeException)error;        }        return new RuntimeException(error);    }
public static List<Throwable> flatten(Throwable t) {        List<Throwable> list = new ArrayList<Throwable>();        ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>();        deque.offer(t);        while (!deque.isEmpty()) {            Throwable e = deque.removeFirst();            if (e instanceof CompositeException) {                CompositeException ce = (CompositeException) e;                List<Throwable> exceptions = ce.getExceptions();                for (int i = exceptions.size() - 1; i >= 0; i--) {                    deque.offerFirst(exceptions.get(i));                }            } else {                list.add(e);            }        }        return list;    }
@SuppressWarnings("unchecked")    public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E {        if (e instanceof Exception) {            return (Exception)e;        }        throw (E)e;    }
void add(CacheDisposable<T> consumer) {        for (;;) {            CacheDisposable<T>[] current = observers.get();            if (current == TERMINATED) {                return;            }            int n = current.length;            @SuppressWarnings("unchecked")            CacheDisposable<T>[] next = new CacheDisposable[n + 1];            System.arraycopy(current, 0, next, 0, n);            next[n] = consumer;            if (observers.compareAndSet(current, next)) {                return;            }        }    }
@SuppressWarnings("unchecked")    void remove(CacheDisposable<T> consumer) {        for (;;) {            CacheDisposable<T>[] current = observers.get();            int n = current.length;            if (n == 0) {                return;            }            int j = -1;            for (int i = 0; i < n; i++) {                if (current[i] == consumer) {                    j = i;                    break;                }            }            if (j < 0) {                return;            }            CacheDisposable<T>[] next;            if (n == 1) {                next = EMPTY;            } else {                next = new CacheDisposable[n - 1];                System.arraycopy(current, 0, next, 0, j);                System.arraycopy(current, j + 1, next, j, n - j - 1);            }            if (observers.compareAndSet(current, next)) {                return;            }        }    }
void replay(CacheDisposable<T> consumer) {        // make sure there is only one replay going on at a time        if (consumer.getAndIncrement() != 0) {            return;        }        // see if there were more replay request in the meantime        int missed = 1;        // read out state into locals upfront to avoid being re-read due to volatile reads        long index = consumer.index;        int offset = consumer.offset;        Node<T> node = consumer.node;        Observer<? super T> downstream = consumer.downstream;        int capacity = capacityHint;        for (;;) {            // if the consumer got disposed, clear the node and quit            if (consumer.disposed) {                consumer.node = null;                return;            }            // first see if the source has terminated, read order matters!            boolean sourceDone = done;            // and if the number of items is the same as this consumer has received            boolean empty = size == index;            // if the source is done and we have all items so far, terminate the consumer            if (sourceDone && empty) {                // release the node object to avoid leaks through retained consumers                consumer.node = null;                // if error is not null then the source failed                Throwable ex = error;                if (ex != null) {                    downstream.onError(ex);                } else {                    downstream.onComplete();                }                return;            }            // there are still items not sent to the consumer            if (!empty) {             // if the offset in the current node has reached the node capacity                if (offset == capacity) {                    // switch to the subsequent node                    node = node.next;                    // reset the in-node offset                    offset = 0;                }                // emit the cached item                downstream.onNext(node.values[offset]);                // move the node offset forward                offset++;                // move the total consumed item count forward                index++;                // retry for the next item/terminal event if any                continue;            }            // commit the changed references back            consumer.index = index;            consumer.offset = offset;            consumer.node = node;            // release the changes and see if there were more replay request in the meantime            missed = consumer.addAndGet(-missed);            if (missed == 0) {                break;            }        }    }
@Benchmark    public void oneStreamOfNthatMergesIn1(final InputMillion input) throws InterruptedException {        Flowable<Flowable<Integer>> os = Flowable.range(1, input.size)                .map(new Function<Integer, Flowable<Integer>>() {                    @Override                    public Flowable<Integer> apply(Integer v) {                        return Flowable.just(v);                    }                });        PerfSubscriber o = input.newLatchedObserver();        Flowable.merge(os).subscribe(o);        if (input.size == 1) {            while (o.latch.getCount() != 0) { }        } else {            o.latch.await();        }    }
@Override    public boolean add(@NonNull Disposable disposable) {        ObjectHelper.requireNonNull(disposable, "disposable is null");        if (!disposed) {            synchronized (this) {                if (!disposed) {                    OpenHashSet<Disposable> set = resources;                    if (set == null) {                        set = new OpenHashSet<Disposable>();                        resources = set;                    }                    set.add(disposable);                    return true;                }            }        }        disposable.dispose();        return false;    }
public boolean addAll(@NonNull Disposable... disposables) {        ObjectHelper.requireNonNull(disposables, "disposables is null");        if (!disposed) {            synchronized (this) {                if (!disposed) {                    OpenHashSet<Disposable> set = resources;                    if (set == null) {                        set = new OpenHashSet<Disposable>(disposables.length + 1);                        resources = set;                    }                    for (Disposable d : disposables) {                        ObjectHelper.requireNonNull(d, "A Disposable in the disposables array is null");                        set.add(d);                    }                    return true;                }            }        }        for (Disposable d : disposables) {            d.dispose();        }        return false;    }
@Override    public boolean remove(@NonNull Disposable disposable) {        if (delete(disposable)) {            disposable.dispose();            return true;        }        return false;    }
@Override    public boolean delete(@NonNull Disposable disposable) {        ObjectHelper.requireNonNull(disposable, "disposables is null");        if (disposed) {            return false;        }        synchronized (this) {            if (disposed) {                return false;            }            OpenHashSet<Disposable> set = resources;            if (set == null || !set.remove(disposable)) {                return false;            }        }        return true;    }
public void clear() {        if (disposed) {            return;        }        OpenHashSet<Disposable> set;        synchronized (this) {            if (disposed) {                return;            }            set = resources;            resources = null;        }        dispose(set);    }
public int size() {        if (disposed) {            return 0;        }        synchronized (this) {            if (disposed) {                return 0;            }            OpenHashSet<Disposable> set = resources;            return set != null ? set.size() : 0;        }    }
public static <T> void subscribe(Publisher<? extends T> o, Subscriber<? super T> subscriber) {        final BlockingQueue<Object> queue = new LinkedBlockingQueue<Object>();        BlockingSubscriber<T> bs = new BlockingSubscriber<T>(queue);        o.subscribe(bs);        try {            for (;;) {                if (bs.isCancelled()) {                    break;                }                Object v = queue.poll();                if (v == null) {                    if (bs.isCancelled()) {                        break;                    }                    BlockingHelper.verifyNonBlocking();                    v = queue.take();                }                if (bs.isCancelled()) {                    break;                }                if (v == BlockingSubscriber.TERMINATED                        || NotificationLite.acceptFull(v, subscriber)) {                    break;                }            }        } catch (InterruptedException e) {            bs.cancel();            subscriber.onError(e);        }    }
public static <T> void subscribe(Publisher<? extends T> o) {        BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(Functions.emptyConsumer(),        callback, callback, Functions.REQUEST_MAX);        o.subscribe(ls);        BlockingHelper.awaitForComplete(callback, ls);        Throwable e = callback.error;        if (e != null) {            throw ExceptionHelper.wrapOrThrow(e);        }    }
public static <T> void subscribe(Publisher<? extends T> o, final Consumer<? super T> onNext,            final Consumer<? super Throwable> onError, final Action onComplete) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        subscribe(o, new LambdaSubscriber<T>(onNext, onError, onComplete, Functions.REQUEST_MAX));    }
public static <T> void subscribe(Publisher<? extends T> o, final Consumer<? super T> onNext,        final Consumer<? super Throwable> onError, final Action onComplete, int bufferSize) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ObjectHelper.verifyPositive(bufferSize, "number > 0 required");        subscribe(o, new BoundedSubscriber<T>(onNext, onError, onComplete, Functions.boundedConsumer(bufferSize),                bufferSize));    }
public final void add(@NonNull Disposable resource) {        ObjectHelper.requireNonNull(resource, "resource is null");        resources.add(resource);    }
@SuppressWarnings("unchecked")    public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source,            Observer<? super R> observer,            Function<? super T, ? extends ObservableSource<? extends R>> mapper) {        if (source instanceof Callable) {            T t;            try {                t = ((Callable<T>)source).call();            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                EmptyDisposable.error(ex, observer);                return true;            }            if (t == null) {                EmptyDisposable.complete(observer);                return true;            }            ObservableSource<? extends R> r;            try {                r = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null ObservableSource");            } catch (Throwable ex) {                Exceptions.throwIfFatal(ex);                EmptyDisposable.error(ex, observer);                return true;            }            if (r instanceof Callable) {                R u;                try {                    u = ((Callable<R>)r).call();                } catch (Throwable ex) {                    Exceptions.throwIfFatal(ex);                    EmptyDisposable.error(ex, observer);                    return true;                }                if (u == null) {                    EmptyDisposable.complete(observer);                    return true;                }                ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u);                observer.onSubscribe(sd);                sd.run();            } else {                r.subscribe(observer);            }            return true;        }        return false;    }
public static <T, U> Observable<U> scalarXMap(T value,            Function<? super T, ? extends ObservableSource<? extends U>> mapper) {        return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper));    }
public static <T> MaybeObserver<T> create(Observer<? super T> downstream) {        return new MaybeToObservableObserver<T>(downstream);    }
@NonNull    @Experimental    public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker) {        return new ExecutorScheduler(executor, interruptibleWorker);    }
public static void shutdown() {        computation().shutdown();        io().shutdown();        newThread().shutdown();        single().shutdown();        trampoline().shutdown();        SchedulerPoolFactory.shutdown();    }
public void add(T value) {        final int c = capacity;        int o = offset;        if (o == c) {            Object[] next = new Object[c + 1];            tail[c] = next;            tail = next;            o = 0;        }        tail[o] = value;        offset = o + 1;    }
@SuppressWarnings("unchecked")    public void forEachWhile(NonThrowingPredicate<? super T> consumer) {        Object[] a = head;        final int c = capacity;        while (a != null) {            for (int i = 0; i < c; i++) {                Object o = a[i];                if (o == null) {                    break;                }                if (consumer.test((T)o)) {                    return;                }            }            a = (Object[])a[c];        }    }
public <U> boolean accept(Subscriber<? super U> subscriber) {        Object[] a = head;        final int c = capacity;        while (a != null) {            for (int i = 0; i < c; i++) {                Object o = a[i];                if (o == null) {                    break;                }                if (NotificationLite.acceptFull(o, subscriber)) {                    return true;                }            }            a = (Object[])a[c];        }        return false;    }
public <U> boolean accept(Observer<? super U> observer) {        Object[] a = head;        final int c = capacity;        while (a != null) {            for (int i = 0; i < c; i++) {                Object o = a[i];                if (o == null) {                    break;                }                if (NotificationLite.acceptFull(o, observer)) {                    return true;                }            }            a = (Object[])a[c];        }        return false;    }
@SuppressWarnings("unchecked")    public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Exception {        Object[] a = head;        final int c = capacity;        for (;;) {            for (int i = 0; i < c; i++) {                Object o = a[i];                if (o == null) {                    return;                }                if (consumer.test(state, (T)o)) {                    return;                }            }            a = (Object[])a[c];        }    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> amb(final Iterable<? extends SingleSource<? extends T>> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new SingleAmb<T>(null, sources));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Single<T> ambArray(final SingleSource<? extends T>... sources) {        if (sources.length == 0) {            return error(SingleInternalHelper.<T>emptyThrower());        }        if (sources.length == 1) {            return wrap((SingleSource<T>)sources[0]);        }        return RxJavaPlugins.onAssembly(new SingleAmb<T>(sources, null));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings({ "unchecked", "rawtypes" })    public static <T> Flowable<T> concatArray(SingleSource<? extends T>... sources) {        return RxJavaPlugins.onAssembly(new FlowableConcatMap(Flowable.fromArray(sources), SingleInternalHelper.toFlowable(), 2, ErrorMode.BOUNDARY));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> defer(final Callable<? extends SingleSource<? extends T>> singleSupplier) {        ObjectHelper.requireNonNull(singleSupplier, "singleSupplier is null");        return RxJavaPlugins.onAssembly(new SingleDefer<T>(singleSupplier));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> error(final Callable<? extends Throwable> errorSupplier) {        ObjectHelper.requireNonNull(errorSupplier, "errorSupplier is null");        return RxJavaPlugins.onAssembly(new SingleError<T>(errorSupplier));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> fromCallable(final Callable<? extends T> callable) {        ObjectHelper.requireNonNull(callable, "callable is null");        return RxJavaPlugins.onAssembly(new SingleFromCallable<T>(callable));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> fromFuture(Future<? extends T> future) {        return toSingle(Flowable.<T>fromFuture(future));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {        return toSingle(Flowable.<T>fromFuture(future, timeout, unit));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static <T> Single<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {        return toSingle(Flowable.<T>fromFuture(future, timeout, unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings({ "unchecked", "rawtypes" })    public static <T> Single<T> merge(SingleSource<? extends SingleSource<? extends T>> source) {        ObjectHelper.requireNonNull(source, "source is null");        return RxJavaPlugins.onAssembly(new SingleFlatMap<SingleSource<? extends T>, T>(source, (Function)Functions.identity()));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings({ "unchecked", "rawtypes" })    public static <T> Flowable<T> mergeDelayError(Publisher<? extends SingleSource<? extends T>> sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, SingleInternalHelper.toFlowable(), true, Integer.MAX_VALUE, Flowable.bufferSize()));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Single<T> never() {        return RxJavaPlugins.onAssembly((Single<T>) SingleNever.INSTANCE);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Single<Long> timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new SingleTimer(delay, unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<T> unsafeCreate(SingleSource<T> onSubscribe) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        if (onSubscribe instanceof Single) {            throw new IllegalArgumentException("unsafeCreate(Single) should be upgraded");        }        return RxJavaPlugins.onAssembly(new SingleFromUnsafeSource<T>(onSubscribe));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, U> Single<T> using(Callable<U> resourceSupplier,                                         Function<? super U, ? extends SingleSource<? extends T>> singleFunction,                                         Consumer<? super U> disposer) {        return using(resourceSupplier, singleFunction, disposer, true);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> R as(@NonNull SingleConverter<T, ? extends R> converter) {        return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> hide() {        return RxJavaPlugins.onAssembly(new SingleHide<T>(this));    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> compose(SingleTransformer<? super T, ? extends R> transformer) {        return wrap(((SingleTransformer<T, R>) ObjectHelper.requireNonNull(transformer, "transformer is null")).apply(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> cache() {        return RxJavaPlugins.onAssembly(new SingleCache<T>(this));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> concatWith(SingleSource<? extends T> other) {        return concat(this, other);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Single<T> delay(long time, TimeUnit unit) {        return delay(time, unit, Schedulers.computation(), false);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler) {        return delay(time, unit, scheduler, false);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> delay(final long time, final TimeUnit unit, final Scheduler scheduler, boolean delayError) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new SingleDelay<T>(this, time, unit, scheduler, delayError));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> delaySubscription(CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable<T>(this, other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Single<T> delaySubscription(long time, TimeUnit unit) {        return delaySubscription(time, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> delaySubscription(long time, TimeUnit unit, Scheduler scheduler) {        return delaySubscription(Observable.timer(time, unit, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    @Experimental    public final <R> Maybe<R> dematerialize(Function<? super T, Notification<R>> selector) {        ObjectHelper.requireNonNull(selector, "selector is null");        return RxJavaPlugins.onAssembly(new SingleDematerialize<T, R>(this, selector));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doAfterSuccess(Consumer<? super T> onAfterSuccess) {        ObjectHelper.requireNonNull(onAfterSuccess, "onAfterSuccess is null");        return RxJavaPlugins.onAssembly(new SingleDoAfterSuccess<T>(this, onAfterSuccess));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doAfterTerminate(Action onAfterTerminate) {        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");        return RxJavaPlugins.onAssembly(new SingleDoAfterTerminate<T>(this, onAfterTerminate));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doFinally(Action onFinally) {        ObjectHelper.requireNonNull(onFinally, "onFinally is null");        return RxJavaPlugins.onAssembly(new SingleDoFinally<T>(this, onFinally));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doOnSubscribe(final Consumer<? super Disposable> onSubscribe) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        return RxJavaPlugins.onAssembly(new SingleDoOnSubscribe<T>(this, onSubscribe));    }
@Experimental    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doOnTerminate(final Action onTerminate) {        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");        return RxJavaPlugins.onAssembly(new SingleDoOnTerminate<T>(this, onTerminate));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doOnSuccess(final Consumer<? super T> onSuccess) {        ObjectHelper.requireNonNull(onSuccess, "onSuccess is null");        return RxJavaPlugins.onAssembly(new SingleDoOnSuccess<T>(this, onSuccess));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doOnError(final Consumer<? super Throwable> onError) {        ObjectHelper.requireNonNull(onError, "onError is null");        return RxJavaPlugins.onAssembly(new SingleDoOnError<T>(this, onError));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> doOnDispose(final Action onDispose) {        ObjectHelper.requireNonNull(onDispose, "onDispose is null");        return RxJavaPlugins.onAssembly(new SingleDoOnDispose<T>(this, onDispose));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> flatMap(Function<? super T, ? extends SingleSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new SingleFlatMap<T, R>(this, mapper));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Maybe<R> flatMapMaybe(final Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new SingleFlatMapMaybe<T, R>(this, mapper));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Observable<R> flatMapObservable(Function<? super T, ? extends ObservableSource<? extends R>> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new SingleFlatMapObservable<T, R>(this, mapper));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> lift(final SingleOperator<? extends R, ? super T> lift) {        ObjectHelper.requireNonNull(lift, "lift is null");        return RxJavaPlugins.onAssembly(new SingleLift<T, R>(this, lift));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> map(Function<? super T, ? extends R> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new SingleMap<T, R>(this, mapper));    }
@Experimental    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Notification<T>> materialize() {        return RxJavaPlugins.onAssembly(new SingleMaterialize<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> contains(Object value) {        return contains(value, ObjectHelper.equalsPredicate());    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> mergeWith(SingleSource<? extends T> other) {        return merge(this, other);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> observeOn(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new SingleObserveOn<T>(this, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> onErrorReturn(final Function<Throwable, ? extends T> resumeFunction) {        ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");        return RxJavaPlugins.onAssembly(new SingleOnErrorReturn<T>(this, resumeFunction, null));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> onTerminateDetach() {        return RxJavaPlugins.onAssembly(new SingleDetach<T>(this));    }
@BackpressureSupport(BackpressureKind.FULL)    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> repeat() {        return toFlowable().repeat();    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> retry() {        return toSingle(toFlowable().retry());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {        return toSingle(toFlowable().retry(predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> retry(long times, Predicate<? super Throwable> predicate) {        return toSingle(toFlowable().retry(times, predicate));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {        return toSingle(toFlowable().retryWhen(handler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(Consumer<? super T> onSuccess) {        return subscribe(onSuccess, Functions.ON_ERROR_MISSING);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(final Consumer<? super T> onSuccess, final Consumer<? super Throwable> onError) {        ObjectHelper.requireNonNull(onSuccess, "onSuccess is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ConsumerSingleObserver<T> observer = new ConsumerSingleObserver<T>(onSuccess, onError);        subscribe(observer);        return observer;    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <E extends SingleObserver<? super T>> E subscribeWith(E observer) {        subscribe(observer);        return observer;    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> subscribeOn(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new SingleSubscribeOn<T>(this, scheduler));    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> takeUntil(final CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return takeUntil(new CompletableToFlowable<T>(other));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Single<T> timeout(long timeout, TimeUnit unit) {        return timeout0(timeout, unit, Schedulers.computation(), null);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> timeout(long timeout, TimeUnit unit, Scheduler scheduler) {        return timeout0(timeout, unit, scheduler, null);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @Deprecated    public final Completable toCompletable() {        return RxJavaPlugins.onAssembly(new CompletableFromSingle<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final Future<T> toFuture() {        return subscribeWith(new FutureSingleObserver<T>());    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Single<T> unsubscribeOn(final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new SingleUnsubscribeOn<T>(this, scheduler));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Single<R> zipWith(SingleSource<U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {        return zip(this, other, zipper);    }
@CheckReturnValue    @NonNull    public static <T> MulticastProcessor<T> create() {        return new MulticastProcessor<T>(bufferSize(), false);    }
@CheckReturnValue    @NonNull    public static <T> MulticastProcessor<T> create(boolean refCount) {        return new MulticastProcessor<T>(bufferSize(), refCount);    }
public void start() {        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {            queue = new SpscArrayQueue<T>(bufferSize);        }    }
public void startUnbounded() {        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {            queue = new SpscLinkedArrayQueue<T>(bufferSize);        }    }
public boolean offer(T t) {        if (once.get()) {            return false;        }        ObjectHelper.requireNonNull(t, "offer called with null. Null values are generally not allowed in 2.x operators and sources.");        if (fusionMode == QueueSubscription.NONE) {            if (queue.offer(t)) {                drain();                return true;            }        }        return false;    }
@Override    public boolean offer(final T e) {        if (null == e) {            throw new NullPointerException("Null is not a valid element");        }        // local load of field to avoid repeated loads after volatile reads        final AtomicReferenceArray<Object> buffer = producerBuffer;        final long index = lpProducerIndex();        final int mask = producerMask;        final int offset = calcWrappedOffset(index, mask);        if (index < producerLookAhead) {            return writeToQueue(buffer, e, index, offset);        } else {            final int lookAheadStep = producerLookAheadStep;            // go around the buffer or resize if full (unless we hit max capacity)            int lookAheadElementOffset = calcWrappedOffset(index + lookAheadStep, mask);            if (null == lvElement(buffer, lookAheadElementOffset)) { // LoadLoad                producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room                return writeToQueue(buffer, e, index, offset);            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full                return writeToQueue(buffer, e, index, offset);            } else {                resize(buffer, index, offset, e, mask); // add a buffer and link old to new                return true;            }        }    }
@Nullable    @SuppressWarnings("unchecked")    @Override    public T poll() {        // local load of field to avoid repeated loads after volatile reads        final AtomicReferenceArray<Object> buffer = consumerBuffer;        final long index = lpConsumerIndex();        final int mask = consumerMask;        final int offset = calcWrappedOffset(index, mask);        final Object e = lvElement(buffer, offset); // LoadLoad        boolean isNextBuffer = e == HAS_NEXT;        if (null != e && !isNextBuffer) {            soElement(buffer, offset, null); // StoreStore            soConsumerIndex(index + 1); // this ensures correctness on 32bit platforms            return (T) e;        } else if (isNextBuffer) {            return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);        }        return null;    }
@Override    public boolean offer(T first, T second) {        final AtomicReferenceArray<Object> buffer = producerBuffer;        final long p = lvProducerIndex();        final int m = producerMask;        int pi = calcWrappedOffset(p + 2, m);        if (null == lvElement(buffer, pi)) {            pi = calcWrappedOffset(p, m);            soElement(buffer, pi + 1, second);            soElement(buffer, pi, first);            soProducerIndex(p + 2);        } else {            final int capacity = buffer.length();            final AtomicReferenceArray<Object> newBuffer = new AtomicReferenceArray<Object>(capacity);            producerBuffer = newBuffer;            pi = calcWrappedOffset(p, m);            soElement(newBuffer, pi + 1, second); // StoreStore            soElement(newBuffer, pi, first);            soNext(buffer, newBuffer);            soElement(buffer, pi, HAS_NEXT); // new buffer is visible after element is            soProducerIndex(p + 2); // this ensures correctness on 32bit platforms        }        return true;    }
@Nullable    public Disposable get() {        Disposable d = resource.get();        if (d == DisposableHelper.DISPOSED) {            return Disposables.disposed();        }        return d;    }
public static <T> ConnectableObservable<T> create(ObservableSource<T> source) {        // the current connection to source needs to be shared between the operator and its onSubscribe call        final AtomicReference<PublishObserver<T>> curr = new AtomicReference<PublishObserver<T>>();        ObservableSource<T> onSubscribe = new PublishSource<T>(curr);        return RxJavaPlugins.onAssembly(new ObservablePublish<T>(onSubscribe, source, curr));    }
public final void complete(T value) {        int state = get();        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {            return;        }        Observer<? super T> a = downstream;        if (state == FUSED_EMPTY) {            this.value = value;            lazySet(FUSED_READY);            a.onNext(null);        } else {            lazySet(TERMINATED);            a.onNext(value);        }        if (get() != DISPOSED) {            a.onComplete();        }    }
public final void error(Throwable t) {        int state = get();        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {            RxJavaPlugins.onError(t);            return;        }        lazySet(TERMINATED);        downstream.onError(t);    }
public final void complete() {        int state = get();        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {            return;        }        lazySet(TERMINATED);        downstream.onComplete();    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {        return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) {        if (sources.length == 0) {            return empty();        } else        if (sources.length == 1) {            return fromPublisher(sources[0]);        }        return RxJavaPlugins.onAssembly(new FlowableConcatArray<T>(sources, false));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings({ "rawtypes", "unchecked" })    public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {        ObjectHelper.requireNonNull(sources, "sources is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public static <T> Flowable<T> concatArrayEagerDelayError(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {        return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, true);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {        return concatDelayError(sources, bufferSize(), true);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, BackpressureStrategy mode) {        ObjectHelper.requireNonNull(source, "source is null");        ObjectHelper.requireNonNull(mode, "mode is null");        return RxJavaPlugins.onAssembly(new FlowableCreate<T>(source, mode));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Flowable<T> empty() {        return RxJavaPlugins.onAssembly((Flowable<T>) FlowableEmpty.INSTANCE);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {        ObjectHelper.requireNonNull(supplier, "supplier is null");        return RxJavaPlugins.onAssembly(new FlowableError<T>(supplier));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> fromIterable(Iterable<? extends T> source) {        ObjectHelper.requireNonNull(source, "source is null");        return RxJavaPlugins.onAssembly(new FlowableFromIterable<T>(source));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, S> Flowable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator) {        return generate(initialState, generator, Functions.emptyConsumer());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Flowable<Long> interval(long period, TimeUnit unit) {        return interval(period, period, unit, Schedulers.computation());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Flowable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {        return interval(period, period, unit, scheduler);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {        if (count < 0L) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        if (count == 0L) {            return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);        }        long end = start + (count - 1);        if (start > 0 && end < 0) {            throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");        }        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> just(T item) {        ObjectHelper.requireNonNull(item, "item is null");        return RxJavaPlugins.onAssembly(new FlowableJust<T>(item));    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> merge(            Publisher<? extends T> source1, Publisher<? extends T> source2,            Publisher<? extends T> source3, Publisher<? extends T> source4) {        ObjectHelper.requireNonNull(source1, "source1 is null");        ObjectHelper.requireNonNull(source2, "source2 is null");        ObjectHelper.requireNonNull(source3, "source3 is null");        ObjectHelper.requireNonNull(source4, "source4 is null");        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {        return fromIterable(sources).flatMap((Function)Functions.identity(), true);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    @SuppressWarnings("unchecked")    public static <T> Flowable<T> never() {        return RxJavaPlugins.onAssembly((Flowable<T>) FlowableNever.INSTANCE);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static Flowable<Integer> range(int start, int count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        } else        if (count == 0) {            return empty();        } else        if (count == 1) {            return just(start);        } else        if ((long)start + (count - 1) > Integer.MAX_VALUE) {            throw new IllegalArgumentException("Integer overflow");        }        return RxJavaPlugins.onAssembly(new FlowableRange(start, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static Flowable<Long> rangeLong(long start, long count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        if (count == 0) {            return empty();        }        if (count == 1) {            return just(start);        }        long end = start + (count - 1);        if (start > 0 && end < 0) {            throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");        }        return RxJavaPlugins.onAssembly(new FlowableRangeLong(start, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,            BiPredicate<? super T, ? super T> isEqual) {        return sequenceEqual(source1, source2, isEqual, bufferSize());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,            BiPredicate<? super T, ? super T> isEqual, int bufferSize) {        ObjectHelper.requireNonNull(source1, "source1 is null");        ObjectHelper.requireNonNull(source2, "source2 is null");        ObjectHelper.requireNonNull(isEqual, "isEqual is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new FlowableSequenceEqualSingle<T>(source1, source2, isEqual, bufferSize));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);    }
@SuppressWarnings({ "unchecked", "rawtypes" })    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public static Flowable<Long> timer(long delay, TimeUnit unit) {        return timer(delay, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.NONE)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T> Flowable<T> unsafeCreate(Publisher<T> onSubscribe) {        ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null");        if (onSubscribe instanceof Flowable) {            throw new IllegalArgumentException("unsafeCreate(Flowable) should be upgraded");        }        return RxJavaPlugins.onAssembly(new FlowableFromPublisher<T>(onSubscribe));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier,            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Flowable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {        ObjectHelper.requireNonNull(zipper, "zipper is null");        ObjectHelper.requireNonNull(sources, "sources is null");        return RxJavaPlugins.onAssembly(new FlowableZip<T, R>(null, sources, zipper, bufferSize(), false));    }
@SuppressWarnings({ "rawtypes", "unchecked", "cast" })    @CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public static <T, R> Flowable<R> zip(Publisher<? extends Publisher<? extends T>> sources,            final Function<? super Object[], ? extends R> zipper) {        ObjectHelper.requireNonNull(zipper, "zipper is null");        return fromPublisher(sources).toList().flatMapPublisher((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> R as(@NonNull FlowableConverter<T, ? extends R> converter) {        return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingFirst() {        BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();        subscribe(s);        T v = s.blockingGet();        if (v != null) {            return v;        }        throw new NoSuchElementException();    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Iterable<T> blockingIterable() {        return blockingIterable(bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Iterable<T> blockingIterable(int bufferSize) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return new BlockingFlowableIterable<T>(this, bufferSize);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingLast() {        BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();        subscribe(s);        T v = s.blockingGet();        if (v != null) {            return v;        }        throw new NoSuchElementException();    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Iterable<T> blockingMostRecent(T initialItem) {        return new BlockingFlowableMostRecent<T>(this, initialItem);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Iterable<T> blockingNext() {        return new BlockingFlowableNext<T>(this);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingSingle() {        return singleOrError().blockingGet();    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final T blockingSingle(T defaultItem) {        return single(defaultItem).blockingGet();    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Future<T> toFuture() {        return subscribeWith(new FutureSubscriber<T>());    }
@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Consumer<? super T> onNext) {        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete,        int bufferSize) {        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete, bufferSize);    }
@BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public final void blockingSubscribe(Subscriber<? super T> subscriber) {        FlowableBlockingSubscribe.subscribe(this, subscriber);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<List<T>> buffer(int count) {        return buffer(count, count);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<List<T>> buffer(int count, int skip) {        return buffer(count, skip, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {        ObjectHelper.verifyPositive(count, "count");        ObjectHelper.verifyPositive(skip, "skip");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new FlowableBuffer<T, U>(this, count, skip, bufferSupplier));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U extends Collection<? super T>> Flowable<U> buffer(int count, Callable<U> bufferSupplier) {        return buffer(count, count, bufferSupplier);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final <U extends Collection<? super T>> Flowable<U> buffer(long timespan, long timeskip, TimeUnit unit,            Scheduler scheduler, Callable<U> bufferSupplier) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit) {        return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final <U extends Collection<? super T>> Flowable<U> buffer(            long timespan, TimeUnit unit,            Scheduler scheduler, int count,            Callable<U> bufferSupplier,            boolean restartTimerOnMaxSize) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        ObjectHelper.verifyPositive(count, "count");        return RxJavaPlugins.onAssembly(new FlowableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <TOpening, TClosing> Flowable<List<T>> buffer(            Flowable<? extends TOpening> openingIndicator,            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(            Flowable<? extends TOpening> openingIndicator,            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,            Callable<U> bufferSupplier) {        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {        return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {        ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");        return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {        ObjectHelper.requireNonNull(boundaryIndicator, "boundaryIndicator is null");        ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");        return RxJavaPlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> cache() {        return cacheWithInitialCapacity(16);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> cacheWithInitialCapacity(int initialCapacity) {        ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");        return RxJavaPlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Single<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {        ObjectHelper.requireNonNull(initialItemSupplier, "initialItemSupplier is null");        ObjectHelper.requireNonNull(collector, "collector is null");        return RxJavaPlugins.onAssembly(new FlowableCollectSingle<T, U>(this, initialItemSupplier, collector));    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {        return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, "composer is null")).apply(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public final Completable concatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {        return concatMapCompletable(mapper, 2);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper, boolean tillTheEnd) {        return concatMapCompletableDelayError(mapper, tillTheEnd, 2);    }
@CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.FULL)    public final Completable concatMapCompletableDelayError(Function<? super T, ? extends CompletableSource> mapper, boolean tillTheEnd, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new FlowableConcatMapCompletable<T>(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {        return concatMapDelayError(mapper, 2, true);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper,            int maxConcurrency, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {        return concatMapIterable(mapper, 2);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> concatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        return concatMapMaybe(mapper, 2);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> concatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, int prefetch) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(prefetch, "prefetch");        return RxJavaPlugins.onAssembly(new FlowableConcatMapSingle<T, R>(this, mapper, ErrorMode.IMMEDIATE, prefetch));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> concatMapSingleDelayError(Function<? super T, ? extends SingleSource<? extends R>> mapper) {        return concatMapSingleDelayError(mapper, true, 2);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> concatWith(@NonNull SingleSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableConcatWithSingle<T>(this, other));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> concatWith(@NonNull MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableConcatWithMaybe<T>(this, other));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> concatWith(@NonNull CompletableSource other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableConcatWithCompletable<T>(this, other));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> contains(final Object item) {        ObjectHelper.requireNonNull(item, "item is null");        return any(Functions.equalsWith(item));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Long> count() {        return RxJavaPlugins.onAssembly(new FlowableCountSingle<T>(this));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {        ObjectHelper.requireNonNull(debounceIndicator, "debounceIndicator is null");        return RxJavaPlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableDebounceTimed<T>(this, timeout, unit, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<T> delay(long delay, TimeUnit unit, boolean delayError) {        return delay(delay, unit, Schedulers.computation(), delayError);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {        return delay(delay, unit, scheduler, false);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,            Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @Deprecated    @SuppressWarnings({ "unchecked", "rawtypes" })    public final <T2> Flowable<T2> dematerialize() {        return RxJavaPlugins.onAssembly(new FlowableDematerialize(this, Functions.identity()));    }
@Experimental    @CheckReturnValue    @NonNull    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    public final <R> Flowable<R> dematerialize(Function<? super T, Notification<R>> selector) {        ObjectHelper.requireNonNull(selector, "selector is null");        return RxJavaPlugins.onAssembly(new FlowableDematerialize<T, R>(this, selector));    }
@SuppressWarnings({ "rawtypes", "unchecked" })    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> distinct() {        return distinct((Function)Functions.identity(), Functions.<T>createHashSet());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector) {        return distinct(keySelector, Functions.<K>createHashSet());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Flowable<T> distinct(Function<? super T, K> keySelector,            Callable<? extends Collection<? super K>> collectionSupplier) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");        return RxJavaPlugins.onAssembly(new FlowableDistinct<T, K>(this, keySelector, collectionSupplier));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> distinctUntilChanged() {        return distinctUntilChanged(Functions.identity());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Flowable<T> distinctUntilChanged(Function<? super T, K> keySelector) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {        ObjectHelper.requireNonNull(comparer, "comparer is null");        return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doFinally(Action onFinally) {        ObjectHelper.requireNonNull(onFinally, "onFinally is null");        return RxJavaPlugins.onAssembly(new FlowableDoFinally<T>(this, onFinally));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doAfterNext(Consumer<? super T> onAfterNext) {        ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");        return RxJavaPlugins.onAssembly(new FlowableDoAfterNext<T>(this, onAfterNext));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),                Functions.EMPTY_ACTION, onAfterTerminate);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnCancel(Action onCancel) {        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnComplete(Action onComplete) {        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),                onComplete, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError,            Action onComplete, Action onAfterTerminate) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");        return RxJavaPlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {        ObjectHelper.requireNonNull(onNotification, "onNotification is null");        return doOnEach(                Functions.notificationOnNext(onNotification),                Functions.notificationOnError(onNotification),                Functions.notificationOnComplete(onNotification),                Functions.EMPTY_ACTION            );    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {        ObjectHelper.requireNonNull(subscriber, "subscriber is null");        return doOnEach(                FlowableInternalHelper.subscriberOnNext(subscriber),                FlowableInternalHelper.subscriberOnError(subscriber),                FlowableInternalHelper.subscriberOnComplete(subscriber),                Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnError(Consumer<? super Throwable> onError) {        return doOnEach(Functions.emptyConsumer(), onError,                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnNext(Consumer<? super T> onNext) {        return doOnEach(onNext, Functions.emptyConsumer(),                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnRequest(LongConsumer onRequest) {        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> doOnTerminate(final Action onTerminate) {        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),                onTerminate, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> elementAt(long index) {        if (index < 0) {            throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);        }        return RxJavaPlugins.onAssembly(new FlowableElementAtMaybe<T>(this, index));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> elementAtOrError(long index) {        if (index < 0) {            throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);        }        return RxJavaPlugins.onAssembly(new FlowableElementAtSingle<T>(this, index, null));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> filter(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new FlowableFilter<T>(this, predicate));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> firstElement() {        return elementAt(0);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> first(T defaultItem) {        return elementAt(0, defaultItem);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> firstOrError() {        return elementAtOrError(0);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,            boolean delayErrors, int maxConcurrency, int bufferSize) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        if (this instanceof ScalarCallable) {            @SuppressWarnings("unchecked")            T v = ((ScalarCallable<T>)this).call();            if (v == null) {                return empty();            }            return FlowableScalarXMap.scalarXMap(v, mapper);        }        return RxJavaPlugins.onAssembly(new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> flatMap(            Function<? super T, ? extends Publisher<? extends R>> onNextMapper,            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,            Callable<? extends Publisher<? extends R>> onCompleteSupplier) {        ObjectHelper.requireNonNull(onNextMapper, "onNextMapper is null");        ObjectHelper.requireNonNull(onErrorMapper, "onErrorMapper is null");        ObjectHelper.requireNonNull(onCompleteSupplier, "onCompleteSupplier is null");        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Flowable<R> flatMap(final Function<? super T, ? extends Publisher<? extends U>> mapper,            final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.requireNonNull(combiner, "combiner is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper) {        return flatMapCompletable(mapper, false, Integer.MAX_VALUE);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors, int maxConcurrency) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        return RxJavaPlugins.onAssembly(new FlowableFlatMapCompletableCompletable<T>(this, mapper, delayErrors, maxConcurrency));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper) {        return flatMapMaybe(mapper, false, Integer.MAX_VALUE);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper) {        return flatMapSingle(mapper, false, Integer.MAX_VALUE);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");        return RxJavaPlugins.onAssembly(new FlowableFlatMapSingle<T, R>(this, mapper, delayErrors, maxConcurrency));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.NONE)    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable forEach(Consumer<? super T> onNext) {        return subscribe(onNext);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.NONE)    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable forEachWhile(Predicate<? super T> onNext) {        return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.NONE)    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {        return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.NONE)    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable forEachWhile(final Predicate<? super T> onNext, final Consumer<? super Throwable> onError,            final Action onComplete) {        ObjectHelper.requireNonNull(onNext, "onNext is null");        ObjectHelper.requireNonNull(onError, "onError is null");        ObjectHelper.requireNonNull(onComplete, "onComplete is null");        ForEachWhileSubscriber<T> s = new ForEachWhileSubscriber<T>(onNext, onError, onComplete);        subscribe(s);        return s;    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K> Flowable<GroupedFlowable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {        return groupBy(keySelector, Functions.<T>identity(), false, bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,            Function<? super T, ? extends V> valueSelector) {        return groupBy(keySelector, valueSelector, false, bufferSize());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector,            Function<? super T, ? extends V> valueSelector,            boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        ObjectHelper.requireNonNull(valueSelector, "valueSelector is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError, null));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> hide() {        return RxJavaPlugins.onAssembly(new FlowableHide<T>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable ignoreElements() {        return RxJavaPlugins.onAssembly(new FlowableIgnoreElementsCompletable<T>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<Boolean> isEmpty() {        return all(Functions.alwaysFalse());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> lastElement() {        return RxJavaPlugins.onAssembly(new FlowableLastMaybe<T>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> lastOrError() {        return RxJavaPlugins.onAssembly(new FlowableLastSingle<T>(this, null));    }
@BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    public final Flowable<T> limit(long count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        return RxJavaPlugins.onAssembly(new FlowableLimit<T>(this, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<Notification<T>> materialize() {        return RxJavaPlugins.onAssembly(new FlowableMaterialize<T>(this));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> mergeWith(Publisher<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return merge(this, other);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> mergeWith(@NonNull SingleSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableMergeWithSingle<T>(this, other));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> mergeWith(@NonNull MaybeSource<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableMergeWithMaybe<T>(this, other));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> observeOn(Scheduler scheduler) {        return observeOn(scheduler, false, bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> onBackpressureBuffer() {        return onBackpressureBuffer(bufferSize(), false, true);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> onBackpressureBuffer(int capacity) {        return onBackpressureBuffer(capacity, false, false);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> onBackpressureDrop() {        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> onBackpressureDrop(Consumer<? super T> onDrop) {        ObjectHelper.requireNonNull(onDrop, "onDrop is null");        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureDrop<T>(this, onDrop));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {        ObjectHelper.requireNonNull(resumeFunction, "resumeFunction is null");        return RxJavaPlugins.onAssembly(new FlowableOnErrorNext<T>(this, resumeFunction, false));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> onTerminateDetach() {        return RxJavaPlugins.onAssembly(new FlowableDetach<T>(this));    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    public final ParallelFlowable<T> parallel() {        return ParallelFlowable.from(this);    }
@BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    @CheckReturnValue    public final ParallelFlowable<T> parallel(int parallelism) {        ObjectHelper.verifyPositive(parallelism, "parallelism");        return ParallelFlowable.from(this, parallelism);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final ConnectableFlowable<T> publish() {        return publish(bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector) {        return publish(selector, bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final ConnectableFlowable<T> publish(int bufferSize) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return FlowablePublish.create(this, bufferSize);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> rebatchRequests(int n) {        return observeOn(ImmediateThinScheduler.INSTANCE, true, n);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {        ObjectHelper.requireNonNull(reducer, "reducer is null");        return RxJavaPlugins.onAssembly(new FlowableReduceMaybe<T>(this, reducer));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {        ObjectHelper.requireNonNull(seed, "seed is null");        ObjectHelper.requireNonNull(reducer, "reducer is null");        return RxJavaPlugins.onAssembly(new FlowableReduceSeedSingle<T, R>(this, seed, reducer));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Single<R> reduceWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {        ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");        ObjectHelper.requireNonNull(reducer, "reducer is null");        return RxJavaPlugins.onAssembly(new FlowableReduceWithSingle<T, R>(this, seedSupplier, reducer));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> repeat() {        return repeat(Long.MAX_VALUE);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> repeat(long times) {        if (times < 0) {            throw new IllegalArgumentException("times >= 0 required but it was " + times);        }        if (times == 0) {            return empty();        }        return RxJavaPlugins.onAssembly(new FlowableRepeat<T>(this, times));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final ConnectableFlowable<T> replay() {        return FlowableReplay.createFrom(this);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {        return replay(selector, bufferSize, time, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final <R> Flowable<R> replay(final Function<? super Flowable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {        ObjectHelper.requireNonNull(selector, "selector is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),                FlowableInternalHelper.replayFunction(selector, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final ConnectableFlowable<T> replay(final int bufferSize) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return FlowableReplay.create(this, bufferSize);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final ConnectableFlowable<T> replay(int bufferSize, long time, TimeUnit unit) {        return replay(bufferSize, time, unit, Schedulers.computation());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final ConnectableFlowable<T> replay(final int bufferSize, final Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return FlowableReplay.observeOn(replay(bufferSize), scheduler);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> retry() {        return retry(Long.MAX_VALUE, Functions.alwaysTrue());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> retry(long count) {        return retry(count, Functions.alwaysTrue());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> retry(Predicate<? super Throwable> predicate) {        return retry(Long.MAX_VALUE, predicate);    }
@BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final void safeSubscribe(Subscriber<? super T> s) {        ObjectHelper.requireNonNull(s, "s is null");        if (s instanceof SafeSubscriber) {            subscribe((SafeSubscriber<? super T>)s);        } else {            subscribe(new SafeSubscriber<T>(s));        }    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<T> sample(long period, TimeUnit unit) {        return sample(period, unit, Schedulers.computation());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableSampleTimed<T>(this, period, unit, scheduler, false));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Flowable<T> sample(Publisher<U> sampler) {        ObjectHelper.requireNonNull(sampler, "sampler is null");        return RxJavaPlugins.onAssembly(new FlowableSamplePublisher<T>(this, sampler, false));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {        ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");        ObjectHelper.requireNonNull(accumulator, "accumulator is null");        return RxJavaPlugins.onAssembly(new FlowableScanSeed<T, R>(this, seedSupplier, accumulator));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> serialize() {        return RxJavaPlugins.onAssembly(new FlowableSerialized<T>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> share() {        return publish().refCount();    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Maybe<T> singleElement() {        return RxJavaPlugins.onAssembly(new FlowableSingleMaybe<T>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<T> singleOrError() {        return RxJavaPlugins.onAssembly(new FlowableSingleSingle<T>(this, null));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> skip(long count) {        if (count <= 0L) {            return RxJavaPlugins.onAssembly(this);        }        return RxJavaPlugins.onAssembly(new FlowableSkip<T>(this, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> skip(long time, TimeUnit unit) {        return skipUntil(timer(time, unit));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {        return skipUntil(timer(time, unit, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> skipLast(int count) {        if (count < 0) {            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);        }        if (count == 0) {            return RxJavaPlugins.onAssembly(this);        }        return RxJavaPlugins.onAssembly(new FlowableSkipLast<T>(this, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> skipLast(long time, TimeUnit unit) {        return skipLast(time, unit, Schedulers.computation(), false, bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {        return skipLast(time, unit, scheduler, false, bufferSize());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> skipWhile(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new FlowableSkipWhile<T>(this, predicate));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> sorted() {        return toList().toFlowable().map(Functions.listSorter(Functions.<T>naturalComparator())).flatMapIterable(Functions.<List<T>>identity());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> sorted(Comparator<? super T> sortFunction) {        ObjectHelper.requireNonNull(sortFunction, "sortFunction");        return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity());    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> startWith(Iterable<? extends T> items) {        return concatArray(fromIterable(items), this);    }
@SuppressWarnings("unchecked")    @CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> startWithArray(T... items) {        Flowable<T> fromArray = fromArray(items);        if (fromArray == empty()) {            return RxJavaPlugins.onAssembly(this);        }        return concatArray(fromArray, this);    }
@BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe() {        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Disposable subscribe(Consumer<? super T> onNext) {        return subscribe(onNext, Functions.ON_ERROR_MISSING,                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);    }
@BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public final void subscribe(FlowableSubscriber<? super T> s) {        ObjectHelper.requireNonNull(s, "s is null");        try {            Subscriber<? super T> z = RxJavaPlugins.onSubscribe(this, s);            ObjectHelper.requireNonNull(z, "The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");            subscribeActual(z);        } catch (NullPointerException e) { // NOPMD            throw e;        } catch (Throwable e) {            Exceptions.throwIfFatal(e);            // can't call onError because no way to know if a Subscription has been set or not            // can't call onSubscribe because the call might have set a Subscription already            RxJavaPlugins.onError(e);            NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS");            npe.initCause(e);            throw npe;        }    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <E extends Subscriber<? super T>> E subscribeWith(E subscriber) {        subscribe(subscriber);        return subscriber;    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, requestOn));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> switchIfEmpty(Publisher<? extends T> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableSwitchIfEmpty<T>(this, other));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Completable switchMapCompletable(@NonNull Function<? super T, ? extends CompletableSource> mapper) {        ObjectHelper.requireNonNull(mapper, "mapper is null");        return RxJavaPlugins.onAssembly(new FlowableSwitchMapCompletable<T>(this, mapper, false));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> Flowable<R> switchMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) {        return switchMapDelayError(mapper, bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> take(long count) {        if (count < 0) {            throw new IllegalArgumentException("count >= 0 required but it was " + count);        }        return RxJavaPlugins.onAssembly(new FlowableTake<T>(this, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<T> take(long time, TimeUnit unit) {        return takeUntil(timer(time, unit));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> take(long time, TimeUnit unit, Scheduler scheduler) {        return takeUntil(timer(time, unit, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> takeLast(int count) {        if (count < 0) {            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);        } else        if (count == 0) {            return RxJavaPlugins.onAssembly(new FlowableIgnoreElements<T>(this));        } else        if (count == 1) {            return RxJavaPlugins.onAssembly(new FlowableTakeLastOne<T>(this));        }        return RxJavaPlugins.onAssembly(new FlowableTakeLast<T>(this, count));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> takeLast(long count, long time, TimeUnit unit) {        return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        if (count < 0) {            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);        }        return RxJavaPlugins.onAssembly(new FlowableTakeLastTimed<T>(this, count, time, unit, scheduler, bufferSize, delayError));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> takeUntil(Predicate<? super T> stopPredicate) {        ObjectHelper.requireNonNull(stopPredicate, "stopPredicate is null");        return RxJavaPlugins.onAssembly(new FlowableTakeUntilPredicate<T>(this, stopPredicate));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U> Flowable<T> takeUntil(Publisher<U> other) {        ObjectHelper.requireNonNull(other, "other is null");        return RxJavaPlugins.onAssembly(new FlowableTakeUntil<T, U>(this, other));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<T> takeWhile(Predicate<? super T> predicate) {        ObjectHelper.requireNonNull(predicate, "predicate is null");        return RxJavaPlugins.onAssembly(new FlowableTakeWhile<T>(this, predicate));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<T> throttleFirst(long windowDuration, TimeUnit unit) {        return throttleFirst(windowDuration, unit, Schedulers.computation());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit) {        return sample(intervalDuration, unit);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {        return sample(intervalDuration, unit, scheduler);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {        return debounce(timeout, unit, scheduler);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<Timed<T>> timeInterval(TimeUnit unit) {        return timeInterval(unit, Schedulers.computation());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.    public final Flowable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableTimeInterval<T>(this, unit, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {        return timeout0(null, itemTimeoutIndicator, null);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit) {        return timeout0(timeout, timeUnit, null, Schedulers.computation());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {        return timeout0(timeout, timeUnit, null, scheduler);    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,            Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {        ObjectHelper.requireNonNull(firstTimeoutIndicator, "firstTimeoutIndicator is null");        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.    public final Flowable<Timed<T>> timestamp(Scheduler scheduler) {        return timestamp(TimeUnit.MILLISECONDS, scheduler);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.SPECIAL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <R> R to(Function<? super Flowable<T>, R> converter) {        try {            return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);        } catch (Throwable ex) {            Exceptions.throwIfFatal(ex);            throw ExceptionHelper.wrapOrThrow(ex);        }    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<List<T>> toList() {        return RxJavaPlugins.onAssembly(new FlowableToListSingle<T, List<T>>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<List<T>> toList(final int capacityHint) {        ObjectHelper.verifyPositive(capacityHint, "capacityHint");        return RxJavaPlugins.onAssembly(new FlowableToListSingle<T, List<T>>(this, Functions.<T>createArrayList(capacityHint)));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U extends Collection<? super T>> Single<U> toList(Callable<U> collectionSupplier) {        ObjectHelper.requireNonNull(collectionSupplier, "collectionSupplier is null");        return RxJavaPlugins.onAssembly(new FlowableToListSingle<T, U>(this, collectionSupplier));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final <K, V> Single<Map<K, Collection<V>>> toMultimap(            final Function<? super T, ? extends K> keySelector,            final Function<? super T, ? extends V> valueSelector,            final Callable<? extends Map<K, Collection<V>>> mapSupplier,            final Function<? super K, ? extends Collection<? super V>> collectionFactory) {        ObjectHelper.requireNonNull(keySelector, "keySelector is null");        ObjectHelper.requireNonNull(valueSelector, "valueSelector is null");        ObjectHelper.requireNonNull(mapSupplier, "mapSupplier is null");        ObjectHelper.requireNonNull(collectionFactory, "collectionFactory is null");        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Observable<T> toObservable() {        return RxJavaPlugins.onAssembly(new ObservableFromPublisher<T>(this));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)    @SchedulerSupport(SchedulerSupport.NONE)    public final Single<List<T>> toSortedList() {        return toSortedList(Functions.naturalComparator());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<T> unsubscribeOn(Scheduler scheduler) {        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableUnsubscribeOn<T>(this, scheduler));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<Flowable<T>> window(long count) {        return window(count, count, bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final Flowable<Flowable<T>> window(long count, long skip, int bufferSize) {        ObjectHelper.verifyPositive(skip, "skip");        ObjectHelper.verifyPositive(count, "count");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new FlowableWindow<T>(this, count, skip, bufferSize));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit) {        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.COMPUTATION)    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,            long count) {        return window(timespan, unit, Schedulers.computation(), count, false);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.CUSTOM)    public final Flowable<Flowable<T>> window(long timespan, TimeUnit unit,            Scheduler scheduler) {        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Flowable<Flowable<T>> window(            Publisher<U> openingIndicator,            Function<? super U, ? extends Publisher<V>> closingIndicator) {        return window(openingIndicator, closingIndicator, bufferSize());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, V> Flowable<Flowable<T>> window(            Publisher<U> openingIndicator,            Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {        return window(boundaryIndicatorSupplier, bufferSize());    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.ERROR)    @SchedulerSupport(SchedulerSupport.NONE)    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, "boundaryIndicatorSupplier is null");        ObjectHelper.verifyPositive(bufferSize, "bufferSize");        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));    }
@CheckReturnValue    @NonNull    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Flowable<R> zipWith(Iterable<U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {        ObjectHelper.requireNonNull(other, "other is null");        ObjectHelper.requireNonNull(zipper, "zipper is null");        return RxJavaPlugins.onAssembly(new FlowableZipIterable<T, U, R>(this, other, zipper));    }
@CheckReturnValue    @BackpressureSupport(BackpressureKind.FULL)    @SchedulerSupport(SchedulerSupport.NONE)    public final <U, R> Flowable<R> zipWith(Publisher<? extends U> other,            BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {        return zip(this, other, zipper, delayError);    }
@Override    public boolean offer(final T e) {        if (null == e) {            throw new NullPointerException("Null is not a valid element");        }        final LinkedQueueNode<T> nextNode = new LinkedQueueNode<T>(e);        final LinkedQueueNode<T> prevProducerNode = xchgProducerNode(nextNode);        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed        // and completes the store in prev.next.        prevProducerNode.soNext(nextNode); // StoreStore        return true;    }
@Nullable    @Override    public T poll() {        LinkedQueueNode<T> currConsumerNode = lpConsumerNode(); // don't load twice, it's alright        LinkedQueueNode<T> nextNode = currConsumerNode.lvNext();        if (nextNode != null) {            // we have to null out the value because we are going to hang on to the node            final T nextValue = nextNode.getAndNullValue();            spConsumerNode(nextNode);            return nextValue;        }        else if (currConsumerNode != lvProducerNode()) {            // spin, we are no longer wait free            while ((nextNode = currConsumerNode.lvNext()) == null) { } // NOPMD            // got the next node...            // we have to null out the value because we are going to hang on to the node            final T nextValue = nextNode.getAndNullValue();            spConsumerNode(nextNode);            return nextValue;        }        return null;    }
@NonNull    public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);        if (parent != null) {            if (!parent.add(sr)) {                return sr;            }        }        Future<?> f;        try {            if (delayTime <= 0) {                f = executor.submit((Callable<Object>)sr);            } else {                f = executor.schedule((Callable<Object>)sr, delayTime, unit);            }            sr.setFuture(f);        } catch (RejectedExecutionException ex) {            if (parent != null) {                parent.remove(sr);            }            RxJavaPlugins.onError(ex);        }        return sr;    }
public PerfAsyncConsumer await(int count) {        if (count <= 1000) {            while (getCount() != 0) { }        } else {            try {                await();            } catch (InterruptedException ex) {                throw new RuntimeException(ex);            }        }        return this;    }
public final void complete(T v) {        int state = get();        for (;;) {            if (state == FUSED_EMPTY) {                value = v;                lazySet(FUSED_READY);                Subscriber<? super T> a = downstream;                a.onNext(v);                if (get() != CANCELLED) {                    a.onComplete();                }                return;            }            // if state is >= CANCELLED or bit zero is set (*_HAS_VALUE) case, return            if ((state & ~HAS_REQUEST_NO_VALUE) != 0) {                return;            }            if (state == HAS_REQUEST_NO_VALUE) {                lazySet(HAS_REQUEST_HAS_VALUE);                Subscriber<? super T> a = downstream;                a.onNext(v);                if (get() != CANCELLED) {                    a.onComplete();                }                return;            }            value = v;            if (compareAndSet(NO_REQUEST_NO_VALUE, NO_REQUEST_HAS_VALUE)) {                return;            }            state = get();            if (state == CANCELLED) {                value = null;                return;            }        }    }
@CheckReturnValue    @NonNull    public static <T> BehaviorProcessor<T> createDefault(T defaultValue) {        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");        return new BehaviorProcessor<T>(defaultValue);    }
public boolean offer(T t) {        if (t == null) {            onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));            return true;        }        BehaviorSubscription<T>[] array = subscribers.get();        for (BehaviorSubscription<T> s : array) {            if (s.isFull()) {                return false;            }        }        Object o = NotificationLite.next(t);        setCurrent(o);        for (BehaviorSubscription<T> bs : array) {            bs.emitNext(o, index);        }        return true;    }
@Override    protected void subscribeActual(MaybeObserver<? super T> observer) {        source.subscribe(new LastSubscriber<T>(observer));    }
public static void verifyNonBlocking() {        if (RxJavaPlugins.isFailOnNonBlockingScheduler()                && (Thread.currentThread() instanceof NonBlockingThread                        || RxJavaPlugins.onBeforeBlocking())) {            throw new IllegalStateException("Attempt to block on a Scheduler " + Thread.currentThread().getName() + " that doesn't support blocking operators as they may lead to deadlock");        }    }
@NonNull    @CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    public Flowable<T> refCount() {        return RxJavaPlugins.onAssembly(new FlowableRefCount<T>(this));    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.NONE)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    public final Flowable<T> refCount(int subscriberCount) {        return refCount(subscriberCount, 0, TimeUnit.NANOSECONDS, Schedulers.trampoline());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.COMPUTATION)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    public final Flowable<T> refCount(long timeout, TimeUnit unit) {        return refCount(1, timeout, unit, Schedulers.computation());    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    public final Flowable<T> refCount(long timeout, TimeUnit unit, Scheduler scheduler) {        return refCount(1, timeout, unit, scheduler);    }
@CheckReturnValue    @SchedulerSupport(SchedulerSupport.CUSTOM)    @BackpressureSupport(BackpressureKind.PASS_THROUGH)    public final Flowable<T> refCount(int subscriberCount, long timeout, TimeUnit unit, Scheduler scheduler) {        ObjectHelper.verifyPositive(subscriberCount, "subscriberCount");        ObjectHelper.requireNonNull(unit, "unit is null");        ObjectHelper.requireNonNull(scheduler, "scheduler is null");        return RxJavaPlugins.onAssembly(new FlowableRefCount<T>(this, subscriberCount, timeout, unit, scheduler));    }
@NonNull    public Flowable<T> autoConnect(int numberOfSubscribers, @NonNull Consumer<? super Disposable> connection) {        if (numberOfSubscribers <= 0) {            this.connect(connection);            return RxJavaPlugins.onAssembly(this);        }        return RxJavaPlugins.onAssembly(new FlowableAutoConnect<T>(this, numberOfSubscribers, connection));    }
protected final void request(long n) {        Subscription s = this.upstream;        if (s != null) {            s.request(n);        }    }
public boolean setResource(int index, Disposable resource) {        for (;;) {            Disposable o = get(index);            if (o == DisposableHelper.DISPOSED) {                resource.dispose();                return false;            }            if (compareAndSet(index, o, resource)) {                if (o != null) {                    o.dispose();                }                return true;            }        }    }
public Disposable replaceResource(int index, Disposable resource) {        for (;;) {            Disposable o = get(index);            if (o == DisposableHelper.DISPOSED) {                resource.dispose();                return null;            }            if (compareAndSet(index, o, resource)) {                return o;            }        }    }
public final T blockingGet() {        if (getCount() != 0) {            try {                BlockingHelper.verifyNonBlocking();                await();            } catch (InterruptedException ex) {                Subscription s = this.upstream;                this.upstream = SubscriptionHelper.CANCELLED;                if (s != null) {                    s.cancel();                }                throw ExceptionHelper.wrapOrThrow(ex);            }        }        Throwable e = error;        if (e != null) {            throw ExceptionHelper.wrapOrThrow(e);        }        return value;    }
boolean add(PublishDisposable<T> ps) {        for (;;) {            PublishDisposable<T>[] a = subscribers.get();            if (a == TERMINATED) {                return false;            }            int n = a.length;            @SuppressWarnings("unchecked")            PublishDisposable<T>[] b = new PublishDisposable[n + 1];            System.arraycopy(a, 0, b, 0, n);            b[n] = ps;            if (subscribers.compareAndSet(a, b)) {                return true;            }        }    }
@SuppressWarnings("unchecked")    void remove(PublishDisposable<T> ps) {        for (;;) {            PublishDisposable<T>[] a = subscribers.get();            if (a == TERMINATED || a == EMPTY) {                return;            }            int n = a.length;            int j = -1;            for (int i = 0; i < n; i++) {                if (a[i] == ps) {                    j = i;                    break;                }            }            if (j < 0) {                return;            }            PublishDisposable<T>[] b;            if (n == 1) {                b = EMPTY;            } else {                b = new PublishDisposable[n - 1];                System.arraycopy(a, 0, b, 0, j);                System.arraycopy(a, j + 1, b, j, n - j - 1);            }            if (subscribers.compareAndSet(a, b)) {                return;            }        }    }
public static <U, R> Flowable<R> multicastSelector(            final Callable<? extends ConnectableFlowable<U>> connectableFactory,            final Function<? super Flowable<U>, ? extends Publisher<R>> selector) {        return new MulticastFlowable<R, U>(connectableFactory, selector);    }
public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) {        final Flowable<T> flowable = cf.observeOn(scheduler);        return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable));    }
@SuppressWarnings("unchecked")    public static <T> ConnectableFlowable<T> createFrom(Flowable<? extends T> source) {        return create(source, DEFAULT_UNBOUNDED_FACTORY);    }
public static <T> ConnectableFlowable<T> create(Flowable<T> source,            final int bufferSize) {        if (bufferSize == Integer.MAX_VALUE) {            return createFrom(source);        }        return create(source, new ReplayBufferTask<T>(bufferSize));    }
public static <T> ConnectableFlowable<T> create(Flowable<T> source,            long maxAge, TimeUnit unit, Scheduler scheduler) {        return create(source, maxAge, unit, scheduler, Integer.MAX_VALUE);    }
public static <T> ConnectableFlowable<T> create(Flowable<T> source,            final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {        return create(source, new ScheduledReplayBufferTask<T>(bufferSize, maxAge, unit, scheduler));    }
static <T> ConnectableFlowable<T> create(Flowable<T> source,            final Callable<? extends ReplayBuffer<T>> bufferFactory) {        // the current connection to source needs to be shared between the operator and its onSubscribe call        final AtomicReference<ReplaySubscriber<T>> curr = new AtomicReference<ReplaySubscriber<T>>();        Publisher<T> onSubscribe = new ReplayPublisher<T>(curr, bufferFactory);        return RxJavaPlugins.onAssembly(new FlowableReplay<T>(onSubscribe, source, curr, bufferFactory));    }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static MoshiConverterFactory create(Moshi moshi) {    if (moshi == null) throw new NullPointerException("moshi == null");    return new MoshiConverterFactory(moshi, false, false, false);  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {    if (scheduler == null) throw new NullPointerException("scheduler == null");    return new RxJava2CallAdapterFactory(scheduler, false);  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static SimpleXmlConverterFactory createNonStrict(Serializer serializer) {    if (serializer == null) throw new NullPointerException("serializer == null");    return new SimpleXmlConverterFactory(serializer, false);  }
static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {    if (toResolve == rawType) return context;    // We skip searching through interfaces if unknown is an interface.    if (toResolve.isInterface()) {      Class<?>[] interfaces = rawType.getInterfaces();      for (int i = 0, length = interfaces.length; i < length; i++) {        if (interfaces[i] == toResolve) {          return rawType.getGenericInterfaces()[i];        } else if (toResolve.isAssignableFrom(interfaces[i])) {          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);        }      }    }    // Check our supertypes.    if (!rawType.isInterface()) {      while (rawType != Object.class) {        Class<?> rawSupertype = rawType.getSuperclass();        if (rawSupertype == toResolve) {          return rawType.getGenericSuperclass();        } else if (toResolve.isAssignableFrom(rawSupertype)) {          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);        }        rawType = rawSupertype;      }    }    // We can't resolve this further.    return toResolve;  }
public static <T> Call<T> defer(Callable<Call<T>> callable) {    return new DeferredCall<>(callable);  }
@SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.  public <T> T create(final Class<T> service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {      eagerlyValidateMethods(service);    }    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },        new InvocationHandler() {          private final Platform platform = Platform.get();          private final Object[] emptyArgs = new Object[0];          @Override public @Nullable Object invoke(Object proxy, Method method,              @Nullable Object[] args) throws Throwable {            // If the method is a method from Object then defer to normal invocation.            if (method.getDeclaringClass() == Object.class) {              return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {              return platform.invokeDefaultMethod(method, service, proxy, args);            }            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);          }        });  }
public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {    return nextCallAdapter(null, returnType, annotations);  }
public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,      Annotation[] annotations) {    checkNotNull(returnType, "returnType == null");    checkNotNull(annotations, "annotations == null");    int start = callAdapterFactories.indexOf(skipPast) + 1;    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {      CallAdapter<?, ?> adapter = callAdapterFactories.get(i).get(returnType, annotations, this);      if (adapter != null) {        return adapter;      }    }    StringBuilder builder = new StringBuilder("Could not locate call adapter for ")        .append(returnType)        .append(".\n");    if (skipPast != null) {      builder.append("  Skipped:");      for (int i = 0; i < start; i++) {        builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());      }      builder.append('\n');    }    builder.append("  Tried:");    for (int i = start, count = callAdapterFactories.size(); i < count; i++) {      builder.append("\n   * ").append(callAdapterFactories.get(i).getClass().getName());    }    throw new IllegalArgumentException(builder.toString());  }
public <T> Converter<T, RequestBody> requestBodyConverter(Type type,      Annotation[] parameterAnnotations, Annotation[] methodAnnotations) {    return nextRequestBodyConverter(null, type, parameterAnnotations, methodAnnotations);  }
public <T> Converter<T, RequestBody> nextRequestBodyConverter(      @Nullable Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations,      Annotation[] methodAnnotations) {    checkNotNull(type, "type == null");    checkNotNull(parameterAnnotations, "parameterAnnotations == null");    checkNotNull(methodAnnotations, "methodAnnotations == null");    int start = converterFactories.indexOf(skipPast) + 1;    for (int i = start, count = converterFactories.size(); i < count; i++) {      Converter.Factory factory = converterFactories.get(i);      Converter<?, RequestBody> converter =          factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, this);      if (converter != null) {        //noinspection unchecked        return (Converter<T, RequestBody>) converter;      }    }    StringBuilder builder = new StringBuilder("Could not locate RequestBody converter for ")        .append(type)        .append(".\n");    if (skipPast != null) {      builder.append("  Skipped:");      for (int i = 0; i < start; i++) {        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());      }      builder.append('\n');    }    builder.append("  Tried:");    for (int i = start, count = converterFactories.size(); i < count; i++) {      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());    }    throw new IllegalArgumentException(builder.toString());  }
public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] annotations) {    return nextResponseBodyConverter(null, type, annotations);  }
public <T> Converter<ResponseBody, T> nextResponseBodyConverter(      @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {    checkNotNull(type, "type == null");    checkNotNull(annotations, "annotations == null");    int start = converterFactories.indexOf(skipPast) + 1;    for (int i = start, count = converterFactories.size(); i < count; i++) {      Converter<ResponseBody, ?> converter =          converterFactories.get(i).responseBodyConverter(type, annotations, this);      if (converter != null) {        //noinspection unchecked        return (Converter<ResponseBody, T>) converter;      }    }    StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ")        .append(type)        .append(".\n");    if (skipPast != null) {      builder.append("  Skipped:");      for (int i = 0; i < start; i++) {        builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());      }      builder.append('\n');    }    builder.append("  Tried:");    for (int i = start, count = converterFactories.size(); i < count; i++) {      builder.append("\n   * ").append(converterFactories.get(i).getClass().getName());    }    throw new IllegalArgumentException(builder.toString());  }
public <T> Converter<T, String> stringConverter(Type type, Annotation[] annotations) {    checkNotNull(type, "type == null");    checkNotNull(annotations, "annotations == null");    for (int i = 0, count = converterFactories.size(); i < count; i++) {      Converter<?, String> converter =          converterFactories.get(i).stringConverter(type, annotations, this);      if (converter != null) {        //noinspection unchecked        return (Converter<T, String>) converter;      }    }    // Nothing matched. Resort to default converter which just calls toString().    //noinspection unchecked    return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static JaxbConverterFactory create(JAXBContext context) {    if (context == null) throw new NullPointerException("context == null");    return new JaxbConverterFactory(context);  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static GsonConverterFactory create(Gson gson) {    if (gson == null) throw new NullPointerException("gson == null");    return new GsonConverterFactory(gson);  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static RxJavaCallAdapterFactory createWithScheduler(Scheduler scheduler) {    if (scheduler == null) throw new NullPointerException("scheduler == null");    return new RxJavaCallAdapterFactory(scheduler, false);  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static JacksonConverterFactory create(ObjectMapper mapper) {    if (mapper == null) throw new NullPointerException("mapper == null");    return new JacksonConverterFactory(mapper);  }
static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(      Retrofit retrofit, Method method, RequestFactory requestFactory) {    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;    boolean continuationWantsResponse = false;    boolean continuationBodyNullable = false;    Annotation[] annotations = method.getAnnotations();    Type adapterType;    if (isKotlinSuspendFunction) {      Type[] parameterTypes = method.getGenericParameterTypes();      Type responseType = Utils.getParameterLowerBound(0,          (ParameterizedType) parameterTypes[parameterTypes.length - 1]);      if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {        // Unwrap the actual body type from Response<T>.        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);        continuationWantsResponse = true;      } else {        // TODO figure out if type is nullable or not        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)        // Find the entry for method        // Determine if return type is nullable or not      }      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);    } else {      adapterType = method.getGenericReturnType();    }    CallAdapter<ResponseT, ReturnT> callAdapter =        createCallAdapter(retrofit, method, adapterType, annotations);    Type responseType = callAdapter.responseType();    if (responseType == okhttp3.Response.class) {      throw methodError(method, "'"          + getRawType(responseType).getName()          + "' is not a valid response body type. Did you mean ResponseBody?");    }    if (responseType == Response.class) {      throw methodError(method, "Response must include generic type (e.g., Response<String>)");    }    // TODO support Unit for Kotlin?    if (requestFactory.httpMethod.equals("HEAD") && !Void.class.equals(responseType)) {      throw methodError(method, "HEAD method must use Void as response type.");    }    Converter<ResponseBody, ResponseT> responseConverter =        createResponseConverter(retrofit, method, responseType);    okhttp3.Call.Factory callFactory = retrofit.callFactory;    if (!isKotlinSuspendFunction) {      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);    } else if (continuationWantsResponse) {      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);    } else {      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,          continuationBodyNullable);    }  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public static NetworkBehavior create(Random random) {    if (random == null) throw new NullPointerException("random == null");    return new NetworkBehavior(random);  }
public void setDelay(long amount, TimeUnit unit) {    if (amount < 0) {      throw new IllegalArgumentException("Amount must be positive value.");    }    this.delayMs = unit.toMillis(amount);  }
@SuppressWarnings("ConstantConditions") // Guarding public API nullability.  public void setErrorFactory(Callable<Response<?>> errorFactory) {    if (errorFactory == null) {      throw new NullPointerException("errorFactory == null");    }    this.errorFactory = errorFactory;  }
public Response<?> createErrorResponse() {    Response<?> call;    try {      call = errorFactory.call();    } catch (Exception e) {      throw new IllegalStateException("Error factory threw an exception.", e);    }    if (call == null) {      throw new IllegalStateException("Error factory returned null.");    }    if (call.isSuccessful()) {      throw new IllegalStateException("Error factory returned successful response.");    }    return call;  }
public long calculateDelay(TimeUnit unit) {    float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f    float lowerBound = 1f - delta; // 0.2f --> 0.8f    float upperBound = 1f + delta; // 0.2f --> 1.2f    float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f    float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4)    long callDelayMs = (long) (delayMs * delayPercent);    return MILLISECONDS.convert(callDelayMs, unit);  }
public static <T> Response<T> success(@Nullable T body) {    return success(body, new okhttp3.Response.Builder() //        .code(200)        .message("OK")        .protocol(Protocol.HTTP_1_1)        .request(new Request.Builder().url("http://localhost/").build())        .build());  }
public static <T> Response<T> success(@Nullable T body, okhttp3.Response rawResponse) {    checkNotNull(rawResponse, "rawResponse == null");    if (!rawResponse.isSuccessful()) {      throw new IllegalArgumentException("rawResponse must be successful response");    }    return new Response<>(rawResponse, body, null);  }
public static <T> Response<T> error(int code, ResponseBody body) {    if (code < 400) throw new IllegalArgumentException("code < 400: " + code);    return error(body, new okhttp3.Response.Builder() //        .code(code)        .message("Response.error()")        .protocol(Protocol.HTTP_1_1)        .request(new Request.Builder().url("http://localhost/").build())        .build());  }
public static <T> Response<T> error(ResponseBody body, okhttp3.Response rawResponse) {    checkNotNull(body, "body == null");    checkNotNull(rawResponse, "rawResponse == null");    if (rawResponse.isSuccessful()) {      throw new IllegalArgumentException("rawResponse should not be successful response");    }    return new Response<>(rawResponse, null, body);  }
private boolean processMixLetter(AnalyzeContext context){		boolean needLock = false;				if(this.start == -1){//当前的分词器尚未开始处理字符			if(CharacterUtil.CHAR_ARABIC == context.getCurrentCharType()					|| CharacterUtil.CHAR_ENGLISH == context.getCurrentCharType()){				//记录起始指针的位置,标明分词器进入处理状态				this.start = context.getCursor();				this.end = start;			}					}else{//当前的分词器正在处理字符						if(CharacterUtil.CHAR_ARABIC == context.getCurrentCharType()					|| CharacterUtil.CHAR_ENGLISH == context.getCurrentCharType()){				//记录下可能的结束位置				this.end = context.getCursor();							}else if(CharacterUtil.CHAR_USELESS == context.getCurrentCharType()						&& this.isLetterConnector(context.getCurrentChar())){				//记录下可能的结束位置				this.end = context.getCursor();			}else{				//遇到非Letter字符，输出词元				Lexeme newLexeme = new Lexeme(context.getBufferOffset() , this.start , this.end - this.start + 1 , Lexeme.TYPE_LETTER);				context.addLexeme(newLexeme);				this.start = -1;				this.end = -1;			}					}				//判断缓冲区是否已经读完		if(context.isBufferConsumed() && (this.start != -1 && this.end != -1)){            //缓冲以读完，输出词元            Lexeme newLexeme = new Lexeme(context.getBufferOffset() , this.start , this.end - this.start + 1 , Lexeme.TYPE_LETTER);            context.addLexeme(newLexeme);            this.start = -1;            this.end = -1;		}				//判断是否锁定缓冲区		if(this.start == -1 && this.end == -1){			//对缓冲区解锁			needLock = false;		}else{			needLock = true;		}		return needLock;	}
static int identifyCharType(char input){		if(input >= '0' && input <= '9'){			return CHAR_ARABIC;					}else if((input >= 'a' && input <= 'z')				|| (input >= 'A' && input <= 'Z')){			return CHAR_ENGLISH;					}else {			Character.UnicodeBlock ub = Character.UnicodeBlock.of(input);						if(ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS  					|| ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS  					|| ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A){				//目前已知的中文字符UTF-8集合				return CHAR_CHINESE;							}else if(ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS //全角数字字符和日韩字符					//韩文字符集					|| ub == Character.UnicodeBlock.HANGUL_SYLLABLES 					|| ub == Character.UnicodeBlock.HANGUL_JAMO					|| ub == Character.UnicodeBlock.HANGUL_COMPATIBILITY_JAMO					//日文字符集					|| ub == Character.UnicodeBlock.HIRAGANA //平假名					|| ub == Character.UnicodeBlock.KATAKANA //片假名					|| ub == Character.UnicodeBlock.KATAKANA_PHONETIC_EXTENSIONS){				return CHAR_OTHER_CJK;							}		}		//其他的不做处理的字符		return CHAR_USELESS;	}
static char regularize(char input,boolean lowercase){        if (input == 12288) {            input = (char) 32;                    }else if (input > 65280 && input < 65375) {            input = (char) (input - 65248);                    }else if (input >= 'A' && input <= 'Z' && lowercase) {        	input += 32;		}                return input;	}
private List<ISegmenter> loadSegmenters(){		List<ISegmenter> segmenters = new ArrayList<ISegmenter>(4);		//处理字母的子分词器		segmenters.add(new LetterSegmenter()); 		//处理中文数量词的子分词器		segmenters.add(new CN_QuantifierSegmenter());		//处理中文词的子分词器		segmenters.add(new CJKSegmenter());		return segmenters;	}
public synchronized Lexeme next()throws IOException{		Lexeme l = null;		while((l = context.getNextLexeme()) == null ){			/*			 * 从reader中读取数据，填充buffer			 * 如果reader是分次读入buffer的，那么buffer要  进行移位处理			 * 移位处理上次读入的但未处理的数据			 */			int available = context.fillBuffer(this.input);			if(available <= 0){				//reader已经读完				context.reset();				return null;							}else{				//初始化指针				context.initCursor();				do{        			//遍历子分词器        			for(ISegmenter segmenter : segmenters){        				segmenter.analyze(context);        			}        			//字符缓冲区接近读完，需要读入新的字符        			if(context.needRefillBuffer()){        				break;        			}   				//向前移动指针				}while(context.moveCursor());				//重置子分词器，为下轮循环进行初始化				for(ISegmenter segmenter : segmenters){					segmenter.reset();				}			}			//对分词进行歧义处理			this.arbitrator.process(context, configuration.isUseSmart());			//将分词结果输出到结果集，并处理未切分的单个CJK字符			context.outputToResult();			//记录本次分词的缓冲区位移			context.markBufferOffset();					}		return l;	}
public synchronized void reset(Reader input) {		this.input = input;		context.reset();		for(ISegmenter segmenter : segmenters){			segmenter.reset();		}	}
void process(AnalyzeContext context , boolean useSmart){		QuickSortSet orgLexemes = context.getOrgLexemes();		Lexeme orgLexeme = orgLexemes.pollFirst();				LexemePath crossPath = new LexemePath();		while(orgLexeme != null){			if(!crossPath.addCrossLexeme(orgLexeme)){				//找到与crossPath不相交的下一个crossPath					if(crossPath.size() == 1 || !useSmart){					//crossPath没有歧义 或者 不做歧义处理					//直接输出当前crossPath					context.addLexemePath(crossPath);				}else{					//对当前的crossPath进行歧义处理					QuickSortSet.Cell headCell = crossPath.getHead();					LexemePath judgeResult = this.judge(headCell, crossPath.getPathLength());					//输出歧义处理结果judgeResult					context.addLexemePath(judgeResult);				}								//把orgLexeme加入新的crossPath中				crossPath = new LexemePath();				crossPath.addCrossLexeme(orgLexeme);			}			orgLexeme = orgLexemes.pollFirst();		}						//处理最后的path		if(crossPath.size() == 1 || !useSmart){			//crossPath没有歧义 或者 不做歧义处理			//直接输出当前crossPath			context.addLexemePath(crossPath);		}else{			//对当前的crossPath进行歧义处理			QuickSortSet.Cell headCell = crossPath.getHead();			LexemePath judgeResult = this.judge(headCell, crossPath.getPathLength());			//输出歧义处理结果judgeResult			context.addLexemePath(judgeResult);		}	}
private LexemePath judge(QuickSortSet.Cell lexemeCell , int fullTextLength){		//候选路径集合		TreeSet<LexemePath> pathOptions = new TreeSet<LexemePath>();		//候选结果路径		LexemePath option = new LexemePath();				//对crossPath进行一次遍历,同时返回本次遍历中有冲突的Lexeme栈		Stack<QuickSortSet.Cell> lexemeStack = this.forwardPath(lexemeCell , option);				//当前词元链并非最理想的，加入候选路径集合		pathOptions.add(option.copy());				//存在歧义词，处理		QuickSortSet.Cell c = null;		while(!lexemeStack.isEmpty()){			c = lexemeStack.pop();			//回滚词元链			this.backPath(c.getLexeme() , option);			//从歧义词位置开始，递归，生成可选方案			this.forwardPath(c , option);			pathOptions.add(option.copy());		}				//返回集合中的最优方案		return pathOptions.first();	}
private Stack<QuickSortSet.Cell> forwardPath(QuickSortSet.Cell lexemeCell , LexemePath option){		//发生冲突的Lexeme栈		Stack<QuickSortSet.Cell> conflictStack = new Stack<QuickSortSet.Cell>();		QuickSortSet.Cell c = lexemeCell;		//迭代遍历Lexeme链表		while(c != null && c.getLexeme() != null){			if(!option.addNotCrossLexeme(c.getLexeme())){				//词元交叉，添加失败则加入lexemeStack栈				conflictStack.push(c);			}			c = c.getNext();		}		return conflictStack;	}
private void backPath(Lexeme l  , LexemePath option){		while(option.checkCross(l)){			option.removeTail();		}			}
@Override	protected TokenStreamComponents createComponents(String fieldName) {        Tokenizer _IKTokenizer = new IKTokenizer(configuration);		return new TokenStreamComponents(_IKTokenizer);    }
int fillBuffer(Reader reader) throws IOException{    	int readCount = 0;    	if(this.buffOffset == 0){    		//首次读取reader    		readCount = reader.read(segmentBuff);    	}else{    		int offset = this.available - this.cursor;    		if(offset > 0){    			//最近一次读取的>最近一次处理的，将未处理的字串拷贝到segmentBuff头部    			System.arraycopy(this.segmentBuff , this.cursor , this.segmentBuff , 0 , offset);    			readCount = offset;    		}    		//继续读取reader ，以onceReadIn - onceAnalyzed为起始位置，继续填充segmentBuff剩余的部分    		readCount += reader.read(this.segmentBuff , offset , BUFF_SIZE - offset);    	}            	    	//记录最后一次从Reader中读入的可用字符长度    	this.available = readCount;    	//重置当前指针    	this.cursor = 0;    	return readCount;    }
void initCursor(){    	this.cursor = 0;    	this.segmentBuff[this.cursor] = CharacterUtil.regularize(this.segmentBuff[this.cursor],cfg.isEnableLowercase());    	this.charTypes[this.cursor] = CharacterUtil.identifyCharType(this.segmentBuff[this.cursor]);    }
void addLexemePath(LexemePath path){		if(path != null){			this.pathMap.put(path.getPathBegin(), path);		}	}
void outputToResult(){		int index = 0;		for( ; index <= this.cursor ;){			//跳过非CJK字符			if(CharacterUtil.CHAR_USELESS == this.charTypes[index]){				index++;				continue;			}			//从pathMap找出对应index位置的LexemePath			LexemePath path = this.pathMap.get(index);			if(path != null){				//输出LexemePath中的lexeme到results集合				Lexeme l = path.pollFirst();				while(l != null){					this.results.add(l);					//字典中无单字，但是词元冲突了，切分出相交词元的前一个词元中的单字					int innerIndex = index + 1;					for (; innerIndex < index + l.getLength(); innerIndex++) {						Lexeme innerL = path.peekFirst();						if (innerL != null && innerIndex == innerL.getBegin()) {							this.outputSingleCJK(innerIndex - 1);						}					}										//将index移至lexeme后					index = l.getBegin() + l.getLength();										l = path.pollFirst();					if(l != null){						//输出path内部，词元间遗漏的单字						for(;index < l.getBegin();index++){							this.outputSingleCJK(index);						}					}				}			}else{//pathMap中找不到index对应的LexemePath				//单字输出				this.outputSingleCJK(index);				index++;			}		}		//清空当前的Map		this.pathMap.clear();	}
private void outputSingleCJK(int index){		if(CharacterUtil.CHAR_CHINESE == this.charTypes[index]){						Lexeme singleCharLexeme = new Lexeme(this.buffOffset , index , 1 , Lexeme.TYPE_CNCHAR);			this.results.add(singleCharLexeme);		}else if(CharacterUtil.CHAR_OTHER_CJK == this.charTypes[index]){			Lexeme singleCharLexeme = new Lexeme(this.buffOffset , index , 1 , Lexeme.TYPE_OTHER_CJK);			this.results.add(singleCharLexeme);		}	}
Lexeme getNextLexeme(){		//从结果集取出，并移除第一个Lexme		Lexeme result = this.results.pollFirst();		while(result != null){    		//数量词合并    		this.compound(result);    		if(Dictionary.getSingleton().isStopWord(this.segmentBuff ,  result.getBegin() , result.getLength())){       			//是停止词继续取列表的下一个    			result = this.results.pollFirst(); 				    		}else{	 			//不是停止词, 生成lexeme的词元文本,输出	    		result.setLexemeText(String.valueOf(segmentBuff , result.getBegin() , result.getLength()));	    		break;    		}		}		return result;	}
void reset(){				this.buffLocker.clear();        this.orgLexemes = new QuickSortSet();        this.available =0;        this.buffOffset = 0;    	this.charTypes = new int[BUFF_SIZE];    	this.cursor = 0;    	this.results.clear();    	this.segmentBuff = new char[BUFF_SIZE];    	this.pathMap.clear();	}
private void compound(Lexeme result){		if(!this.cfg.isUseSmart()){			return ;		}   		//数量词合并处理		if(!this.results.isEmpty()){			if(Lexeme.TYPE_ARABIC == result.getLexemeType()){				Lexeme nextLexeme = this.results.peekFirst();				boolean appendOk = false;				if(Lexeme.TYPE_CNUM == nextLexeme.getLexemeType()){					//合并英文数词+中文数词					appendOk = result.append(nextLexeme, Lexeme.TYPE_CNUM);				}else if(Lexeme.TYPE_COUNT == nextLexeme.getLexemeType()){					//合并英文数词+中文量词					appendOk = result.append(nextLexeme, Lexeme.TYPE_CQUAN);				}				if(appendOk){					//弹出					this.results.pollFirst(); 				}			}						//可能存在第二轮合并			if(Lexeme.TYPE_CNUM == result.getLexemeType() && !this.results.isEmpty()){				Lexeme nextLexeme = this.results.peekFirst();				boolean appendOk = false;				 if(Lexeme.TYPE_COUNT == nextLexeme.getLexemeType()){					 //合并中文数词+中文量词 					appendOk = result.append(nextLexeme, Lexeme.TYPE_CQUAN); 				}  				if(appendOk){					//弹出					this.results.pollFirst();   								}			}		}	}
boolean addCrossLexeme(Lexeme lexeme){		if(this.isEmpty()){			this.addLexeme(lexeme);			this.pathBegin = lexeme.getBegin();			this.pathEnd = lexeme.getBegin() + lexeme.getLength();			this.payloadLength += lexeme.getLength();			return true;					}else if(this.checkCross(lexeme)){			this.addLexeme(lexeme);			if(lexeme.getBegin() + lexeme.getLength() > this.pathEnd){				this.pathEnd = lexeme.getBegin() + lexeme.getLength();			}			this.payloadLength = this.pathEnd - this.pathBegin;			return true;					}else{			return  false;					}	}
boolean addNotCrossLexeme(Lexeme lexeme){		if(this.isEmpty()){			this.addLexeme(lexeme);			this.pathBegin = lexeme.getBegin();			this.pathEnd = lexeme.getBegin() + lexeme.getLength();			this.payloadLength += lexeme.getLength();			return true;					}else if(this.checkCross(lexeme)){			return  false;					}else{			this.addLexeme(lexeme);			this.payloadLength += lexeme.getLength();			Lexeme head = this.peekFirst();			this.pathBegin = head.getBegin();			Lexeme tail = this.peekLast();			this.pathEnd = tail.getBegin() + tail.getLength();			return true;					}	}
Lexeme removeTail(){		Lexeme tail = this.pollLast();		if(this.isEmpty()){			this.pathBegin = -1;			this.pathEnd = -1;			this.payloadLength = 0;					}else{					this.payloadLength -= tail.getLength();			Lexeme newTail = this.peekLast();			this.pathEnd = newTail.getBegin() + newTail.getLength();		}		return tail;	}
boolean checkCross(Lexeme lexeme){		return (lexeme.getBegin() >= this.pathBegin && lexeme.getBegin() < this.pathEnd)				|| (this.pathBegin >= lexeme.getBegin() && this.pathBegin < lexeme.getBegin()+ lexeme.getLength());	}
int getXWeight(){		int product = 1;		Cell c = this.getHead();		while( c != null && c.getLexeme() != null){			product *= c.getLexeme().getLength();			c = c.getNext();		}		return product;	}
int getPWeight(){		int pWeight = 0;		int p = 0;		Cell c = this.getHead();		while( c != null && c.getLexeme() != null){			p++;			pWeight += p * c.getLexeme().getLength() ;			c = c.getNext();		}		return pWeight;			}
public static synchronized void initial(Configuration cfg) {		if (singleton == null) {			synchronized (Dictionary.class) {				if (singleton == null) {					singleton = new Dictionary(cfg);					singleton.loadMainDict();					singleton.loadSurnameDict();					singleton.loadQuantifierDict();					singleton.loadSuffixDict();					singleton.loadPrepDict();					singleton.loadStopWordDict();					if(cfg.isEnableRemoteDict()){						// 建立监控线程						for (String location : singleton.getRemoteExtDictionarys()) {							// 10 秒是初始延迟可以修改的 60是间隔时间 单位秒							pool.scheduleAtFixedRate(new Monitor(location), 10, 60, TimeUnit.SECONDS);						}						for (String location : singleton.getRemoteExtStopWordDictionarys()) {							pool.scheduleAtFixedRate(new Monitor(location), 10, 60, TimeUnit.SECONDS);						}					}				}			}		}	}
public void disableWords(Collection<String> words) {		if (words != null) {			for (String word : words) {				if (word != null) {					// 批量屏蔽词条					singleton._MainDict.disableSegment(word.trim().toCharArray());				}			}		}	}
public Hit matchInMainDict(char[] charArray, int begin, int length) {		return singleton._MainDict.match(charArray, begin, length);	}
public Hit matchInQuantifierDict(char[] charArray, int begin, int length) {		return singleton._QuantifierDict.match(charArray, begin, length);	}
public Hit matchWithHit(char[] charArray, int currentIndex, Hit matchedHit) {		DictSegment ds = matchedHit.getMatchedDictSegment();		return ds.match(charArray, currentIndex, 1, matchedHit);	}
public boolean isStopWord(char[] charArray, int begin, int length) {		return singleton._StopWords.match(charArray, begin, length).isMatch();	}
private void loadMainDict() {		// 建立一个主词典实例		_MainDict = new DictSegment((char) 0);		// 读取主词典文件		Path file = PathUtils.get(getDictRoot(), Dictionary.PATH_DIC_MAIN);		loadDictFile(_MainDict, file, false, "Main Dict");		// 加载扩展词典		this.loadExtDict();		// 加载远程自定义词库		this.loadRemoteExtDict();	}
private void loadExtDict() {		// 加载扩展词典配置		List<String> extDictFiles = getExtDictionarys();		if (extDictFiles != null) {			for (String extDictName : extDictFiles) {				// 读取扩展词典文件				logger.info("[Dict Loading] " + extDictName);				Path file = PathUtils.get(extDictName);				loadDictFile(_MainDict, file, false, "Extra Dict");			}		}	}
private void loadRemoteExtDict() {		List<String> remoteExtDictFiles = getRemoteExtDictionarys();		for (String location : remoteExtDictFiles) {			logger.info("[Dict Loading] " + location);			List<String> lists = getRemoteWords(location);			// 如果找不到扩展的字典，则忽略			if (lists == null) {				logger.error("[Dict Loading] " + location + "加载失败");				continue;			}			for (String theWord : lists) {				if (theWord != null && !"".equals(theWord.trim())) {					// 加载扩展词典数据到主内存词典中					logger.info(theWord);					_MainDict.fillSegment(theWord.trim().toLowerCase().toCharArray());				}			}		}	}
private static List<String> getRemoteWordsUnprivileged(String location) {		List<String> buffer = new ArrayList<String>();		RequestConfig rc = RequestConfig.custom().setConnectionRequestTimeout(10 * 1000).setConnectTimeout(10 * 1000)				.setSocketTimeout(60 * 1000).build();		CloseableHttpClient httpclient = HttpClients.createDefault();		CloseableHttpResponse response;		BufferedReader in;		HttpGet get = new HttpGet(location);		get.setConfig(rc);		try {			response = httpclient.execute(get);			if (response.getStatusLine().getStatusCode() == 200) {				String charset = "UTF-8";				// 获取编码，默认为utf-8				HttpEntity entity = response.getEntity();				if(entity!=null){					Header contentType = entity.getContentType();					if(contentType!=null&&contentType.getValue()!=null){						String typeValue = contentType.getValue();						if(typeValue!=null&&typeValue.contains("charset=")){							charset = typeValue.substring(typeValue.lastIndexOf("=") + 1);						}					}					if (entity.getContentLength() > 0) {						in = new BufferedReader(new InputStreamReader(entity.getContent(), charset));						String line;						while ((line = in.readLine()) != null) {							buffer.add(line);						}						in.close();						response.close();						return buffer;					}			}			}			response.close();		} catch (IllegalStateException | IOException e) {			logger.error("getRemoteWords {} error", e, location);		}		return buffer;	}
private void loadStopWordDict() {		// 建立主词典实例		_StopWords = new DictSegment((char) 0);		// 读取主词典文件		Path file = PathUtils.get(getDictRoot(), Dictionary.PATH_DIC_STOP);		loadDictFile(_StopWords, file, false, "Main Stopwords");		// 加载扩展停止词典		List<String> extStopWordDictFiles = getExtStopWordDictionarys();		if (extStopWordDictFiles != null) {			for (String extStopWordDictName : extStopWordDictFiles) {				logger.info("[Dict Loading] " + extStopWordDictName);				// 读取扩展词典文件				file = PathUtils.get(extStopWordDictName);				loadDictFile(_StopWords, file, false, "Extra Stopwords");			}		}		// 加载远程停用词典		List<String> remoteExtStopWordDictFiles = getRemoteExtStopWordDictionarys();		for (String location : remoteExtStopWordDictFiles) {			logger.info("[Dict Loading] " + location);			List<String> lists = getRemoteWords(location);			// 如果找不到扩展的字典，则忽略			if (lists == null) {				logger.error("[Dict Loading] " + location + "加载失败");				continue;			}			for (String theWord : lists) {				if (theWord != null && !"".equals(theWord.trim())) {					// 加载远程词典数据到主内存中					logger.info(theWord);					_StopWords.fillSegment(theWord.trim().toLowerCase().toCharArray());				}			}		}	}
private void loadQuantifierDict() {		// 建立一个量词典实例		_QuantifierDict = new DictSegment((char) 0);		// 读取量词词典文件		Path file = PathUtils.get(getDictRoot(), Dictionary.PATH_DIC_QUANTIFIER);		loadDictFile(_QuantifierDict, file, false, "Quantifier");	}
public void analyze(AnalyzeContext context) {		if(CharacterUtil.CHAR_USELESS != context.getCurrentCharType()){						//优先处理tmpHits中的hit			if(!this.tmpHits.isEmpty()){				//处理词段队列				Hit[] tmpArray = this.tmpHits.toArray(new Hit[this.tmpHits.size()]);				for(Hit hit : tmpArray){					hit = Dictionary.getSingleton().matchWithHit(context.getSegmentBuff(), context.getCursor() , hit);					if(hit.isMatch()){						//输出当前的词						Lexeme newLexeme = new Lexeme(context.getBufferOffset() , hit.getBegin() , context.getCursor() - hit.getBegin() + 1 , Lexeme.TYPE_CNWORD);						context.addLexeme(newLexeme);												if(!hit.isPrefix()){//不是词前缀，hit不需要继续匹配，移除							this.tmpHits.remove(hit);						}											}else if(hit.isUnmatch()){						//hit不是词，移除						this.tmpHits.remove(hit);					}									}			}									//*********************************			//再对当前指针位置的字符进行单字匹配			Hit singleCharHit = Dictionary.getSingleton().matchInMainDict(context.getSegmentBuff(), context.getCursor(), 1);			if(singleCharHit.isMatch()){//首字成词				//输出当前的词				Lexeme newLexeme = new Lexeme(context.getBufferOffset() , context.getCursor() , 1 , Lexeme.TYPE_CNWORD);				context.addLexeme(newLexeme);				//同时也是词前缀				if(singleCharHit.isPrefix()){					//前缀匹配则放入hit列表					this.tmpHits.add(singleCharHit);				}			}else if(singleCharHit.isPrefix()){//首字为词前缀				//前缀匹配则放入hit列表				this.tmpHits.add(singleCharHit);			}					}else{			//遇到CHAR_USELESS字符			//清空队列			this.tmpHits.clear();		}				//判断缓冲区是否已经读完		if(context.isBufferConsumed()){			//清空队列			this.tmpHits.clear();		}				//判断是否锁定缓冲区		if(this.tmpHits.size() == 0){			context.unlockBuffer(SEGMENTER_NAME);					}else{			context.lockBuffer(SEGMENTER_NAME);		}	}
public void runUnprivileged() {		//超时设置		RequestConfig rc = RequestConfig.custom().setConnectionRequestTimeout(10*1000)				.setConnectTimeout(10*1000).setSocketTimeout(15*1000).build();		HttpHead head = new HttpHead(location);		head.setConfig(rc);		//设置请求头		if (last_modified != null) {			head.setHeader("If-Modified-Since", last_modified);		}		if (eTags != null) {			head.setHeader("If-None-Match", eTags);		}		CloseableHttpResponse response = null;		try {			response = httpclient.execute(head);			//返回200 才做操作			if(response.getStatusLine().getStatusCode()==200){				if (((response.getLastHeader("Last-Modified")!=null) && !response.getLastHeader("Last-Modified").getValue().equalsIgnoreCase(last_modified))						||((response.getLastHeader("ETag")!=null) && !response.getLastHeader("ETag").getValue().equalsIgnoreCase(eTags))) {					// 远程词库有更新,需要重新加载词典，并修改last_modified,eTags					Dictionary.getSingleton().reLoadMainDict();					last_modified = response.getLastHeader("Last-Modified")==null?null:response.getLastHeader("Last-Modified").getValue();					eTags = response.getLastHeader("ETag")==null?null:response.getLastHeader("ETag").getValue();				}			}else if (response.getStatusLine().getStatusCode()==304) {				//没有修改，不做操作				//noop			}else{				logger.info("remote_ext_dict {} return bad code {}" , location , response.getStatusLine().getStatusCode() );			}		} catch (Exception e) {			logger.error("remote_ext_dict {} error!",e , location);		}finally{			try {				if (response != null) {					response.close();				}			} catch (IOException e) {				logger.error(e.getMessage(), e);			}		}	}
boolean addLexeme(Lexeme lexeme){		Cell newCell = new Cell(lexeme); 		if(this.size == 0){			this.head = newCell;			this.tail = newCell;			this.size++;			return true;					}else{			if(this.tail.compareTo(newCell) == 0){//词元与尾部词元相同，不放入集合				return false;							}else if(this.tail.compareTo(newCell) < 0){//词元接入链表尾部				this.tail.next = newCell;				newCell.prev = this.tail;				this.tail = newCell;				this.size++;				return true;							}else if(this.head.compareTo(newCell) > 0){//词元接入链表头部				this.head.prev = newCell;				newCell.next = this.head;				this.head = newCell;				this.size++;				return true;							}else{									//从尾部上逆				Cell index = this.tail;				while(index != null && index.compareTo(newCell) > 0){					index = index.prev;				}				if(index.compareTo(newCell) == 0){//词元与集合中的词元重复，不放入集合					return false;									}else if(index.compareTo(newCell) < 0){//词元插入链表中的某个位置					newCell.prev = index;					newCell.next = index.next;					index.next.prev = newCell;					index.next = newCell;					this.size++;					return true;									}			}		}		return false;	}
Lexeme pollFirst(){		if(this.size == 1){			Lexeme first = this.head.lexeme;			this.head = null;			this.tail = null;			this.size--;			return first;		}else if(this.size > 1){			Lexeme first = this.head.lexeme;			this.head = this.head.next;			this.size --;			return first;		}else{			return null;		}	}
Lexeme pollLast(){		if(this.size == 1){			Lexeme last = this.head.lexeme;			this.head = null;			this.tail = null;			this.size--;			return last;					}else if(this.size > 1){			Lexeme last = this.tail.lexeme;			this.tail = this.tail.prev;			this.size--;			return last;					}else{			return null;		}	}
public void analyze(AnalyzeContext context) {		//处理中文数词		this.processCNumber(context);		//处理中文量词		this.processCount(context);				//判断是否锁定缓冲区		if(this.nStart == -1 && this.nEnd == -1	&& countHits.isEmpty()){			//对缓冲区解锁			context.unlockBuffer(SEGMENTER_NAME);		}else{			context.lockBuffer(SEGMENTER_NAME);		}	}
private void processCount(AnalyzeContext context){		// 判断是否需要启动量词扫描		if(!this.needCountScan(context)){			return;		}				if(CharacterUtil.CHAR_CHINESE == context.getCurrentCharType()){						//优先处理countHits中的hit			if(!this.countHits.isEmpty()){				//处理词段队列				Hit[] tmpArray = this.countHits.toArray(new Hit[this.countHits.size()]);				for(Hit hit : tmpArray){					hit = Dictionary.getSingleton().matchWithHit(context.getSegmentBuff(), context.getCursor() , hit);					if(hit.isMatch()){						//输出当前的词						Lexeme newLexeme = new Lexeme(context.getBufferOffset() , hit.getBegin() , context.getCursor() - hit.getBegin() + 1 , Lexeme.TYPE_COUNT);						context.addLexeme(newLexeme);												if(!hit.isPrefix()){//不是词前缀，hit不需要继续匹配，移除							this.countHits.remove(hit);						}											}else if(hit.isUnmatch()){						//hit不是词，移除						this.countHits.remove(hit);					}									}			}							//*********************************			//对当前指针位置的字符进行单字匹配			Hit singleCharHit = Dictionary.getSingleton().matchInQuantifierDict(context.getSegmentBuff(), context.getCursor(), 1);			if(singleCharHit.isMatch()){//首字成量词词				//输出当前的词				Lexeme newLexeme = new Lexeme(context.getBufferOffset() , context.getCursor() , 1 , Lexeme.TYPE_COUNT);				context.addLexeme(newLexeme);				//同时也是词前缀				if(singleCharHit.isPrefix()){					//前缀匹配则放入hit列表					this.countHits.add(singleCharHit);				}			}else if(singleCharHit.isPrefix()){//首字为量词前缀				//前缀匹配则放入hit列表				this.countHits.add(singleCharHit);			}								}else{			//输入的不是中文字符			//清空未成形的量词			this.countHits.clear();		}				//缓冲区数据已经读完，还有尚未输出的量词		if(context.isBufferConsumed()){			//清空未成形的量词			this.countHits.clear();		}	}
private boolean needCountScan(AnalyzeContext context){		if((nStart != -1 && nEnd != -1 ) || !countHits.isEmpty()){			//正在处理中文数词,或者正在处理量词			return true;		}else{			//找到一个相邻的数词			if(!context.getOrgLexemes().isEmpty()){				Lexeme l = context.getOrgLexemes().peekLast();				if((Lexeme.TYPE_CNUM == l.getLexemeType() ||  Lexeme.TYPE_ARABIC == l.getLexemeType())					&& (l.getBegin() + l.getLength() == context.getCursor())){					return true;				}			}		}		return false;	}
private void outputNumLexeme(AnalyzeContext context){		if(nStart > -1 && nEnd > -1){			//输出数词			Lexeme newLexeme = new Lexeme(context.getBufferOffset() , nStart , nEnd - nStart + 1 , Lexeme.TYPE_CNUM);			context.addLexeme(newLexeme);					}	}
Hit match(char[] charArray , int begin , int length){		return this.match(charArray , begin , length , null);	}
private synchronized void fillSegment(char[] charArray , int begin , int length , int enabled){		//获取字典表中的汉字对象		Character beginChar = Character.valueOf(charArray[begin]);		Character keyChar = charMap.get(beginChar);		//字典中没有该字，则将其添加入字典		if(keyChar == null){			charMap.put(beginChar, beginChar);			keyChar = beginChar;		}				//搜索当前节点的存储，查询对应keyChar的keyChar，如果没有则创建		DictSegment ds = lookforSegment(keyChar , enabled);		if(ds != null){			//处理keyChar对应的segment			if(length > 1){				//词元还没有完全加入词典树				ds.fillSegment(charArray, begin + 1, length - 1 , enabled);			}else if (length == 1){				//已经是词元的最后一个char,设置当前节点状态为enabled，				//enabled=1表明一个完整的词，enabled=0表示从词典中屏蔽当前词				ds.nodeState = enabled;			}		}	}
private DictSegment lookforSegment(Character keyChar ,  int create){				DictSegment ds = null;		if(this.storeSize <= ARRAY_LENGTH_LIMIT){			//获取数组容器，如果数组未创建则创建数组			DictSegment[] segmentArray = getChildrenArray();						//搜寻数组			DictSegment keySegment = new DictSegment(keyChar);			int position = Arrays.binarySearch(segmentArray, 0 , this.storeSize, keySegment);			if(position >= 0){				ds = segmentArray[position];			}					//遍历数组后没有找到对应的segment			if(ds == null && create == 1){				ds = keySegment;				if(this.storeSize < ARRAY_LENGTH_LIMIT){					//数组容量未满，使用数组存储					segmentArray[this.storeSize] = ds;					//segment数目+1					this.storeSize++;					Arrays.sort(segmentArray , 0 , this.storeSize);									}else{					//数组容量已满，切换Map存储					//获取Map容器，如果Map未创建,则创建Map					Map<Character , DictSegment> segmentMap = getChildrenMap();					//将数组中的segment迁移到Map中					migrate(segmentArray ,  segmentMap);					//存储新的segment					segmentMap.put(keyChar, ds);					//segment数目+1 ，  必须在释放数组前执行storeSize++ ， 确保极端情况下，不会取到空的数组					this.storeSize++;					//释放当前的数组引用					this.childrenArray = null;				}			}								}else{			//获取Map容器，如果Map未创建,则创建Map			Map<Character , DictSegment> segmentMap = getChildrenMap();			//搜索Map			ds = (DictSegment)segmentMap.get(keyChar);			if(ds == null && create == 1){				//构造新的segment				ds = new DictSegment(keyChar);				segmentMap.put(keyChar , ds);				//当前节点存储segment数目+1				this.storeSize ++;			}		}		return ds;	}
private Map<Character , DictSegment> getChildrenMap(){		synchronized(this){			if(this.childrenMap == null){				this.childrenMap = new ConcurrentHashMap<Character, DictSegment>(ARRAY_LENGTH_LIMIT * 2,0.8f);			}		}		return this.childrenMap;	}
private void migrate(DictSegment[] segmentArray , Map<Character , DictSegment> segmentMap){		for(DictSegment segment : segmentArray){			if(segment != null){				segmentMap.put(segment.nodeChar, segment);			}		}	}
public int compareTo(Lexeme other) {		//起始位置优先        if(this.begin < other.getBegin()){            return -1;        }else if(this.begin == other.getBegin()){        	//词元长度优先        	if(this.length > other.getLength()){        		return -1;        	}else if(this.length == other.getLength()){        		return 0;        	}else {//this.length < other.getLength()        		return 1;        	}        	        }else{//this.begin > other.getBegin()        	return 1;        }	}
public String getLexemeTypeString(){		switch(lexemeType) {		case TYPE_ENGLISH :			return "ENGLISH";					case TYPE_ARABIC :			return "ARABIC";					case TYPE_LETTER :			return "LETTER";					case TYPE_CNWORD : 			return "CN_WORD";					case TYPE_CNCHAR : 			return "CN_CHAR";					case TYPE_OTHER_CJK :			return "OTHER_CJK";					case TYPE_COUNT :			return "COUNT";					case TYPE_CNUM :			return "TYPE_CNUM";					case TYPE_CQUAN:				return "TYPE_CQUAN";					default :			return "UNKONW";		}	}
public boolean append(Lexeme l , int lexemeType){		if(l != null && this.getEndPosition() == l.getBeginPosition()){			this.length += l.getLength();			this.lexemeType = lexemeType;			return true;		}else {			return false;		}	}
public final void setErrorConverter(Converter<Map<String, String>, OAuth2Error> errorConverter) {		Assert.notNull(errorConverter, "errorConverter cannot be null");		this.errorConverter = errorConverter;	}
public final void setErrorParametersConverter(Converter<OAuth2Error, Map<String, String>> errorParametersConverter) {		Assert.notNull(errorParametersConverter, "errorParametersConverter cannot be null");		this.errorParametersConverter = errorParametersConverter;	}
public void logout(HttpServletRequest request, HttpServletResponse response,			Authentication authentication) {		this.csrfTokenRepository.saveToken(null, request, response);	}
public final void setClockSkew(Duration clockSkew) {		Assert.notNull(clockSkew, "clockSkew cannot be null");		Assert.isTrue(clockSkew.getSeconds() >= 0, "clockSkew must be >= 0");		this.clockSkew = clockSkew;	}
public void setJwtGrantedAuthoritiesConverter(Converter<Jwt, Collection<GrantedAuthority>> jwtGrantedAuthoritiesConverter) {		Assert.notNull(jwtGrantedAuthoritiesConverter, "jwtGrantedAuthoritiesConverter cannot be null");		this.jwtGrantedAuthoritiesConverter = jwtGrantedAuthoritiesConverter;	}
public void setPortMappings(Map<String, String> newMappings) {		Assert.notNull(newMappings,				"A valid list of HTTPS port mappings must be provided");		this.httpsPortMappings.clear();		for (Map.Entry<String, String> entry : newMappings.entrySet()) {			Integer httpPort = Integer.valueOf(entry.getKey());			Integer httpsPort = Integer.valueOf(entry.getValue());			if ((httpPort.intValue() < 1) || (httpPort.intValue() > 65535)					|| (httpsPort.intValue() < 1) || (httpsPort.intValue() > 65535)) {				throw new IllegalArgumentException(						"one or both ports out of legal range: " + httpPort + ", "								+ httpsPort);			}			this.httpsPortMappings.put(httpPort, httpsPort);		}		if (this.httpsPortMappings.size() < 1) {			throw new IllegalArgumentException("must map at least one port");		}	}
private void createSampleData(String username, String password) {		Assert.notNull(documentDao, "DocumentDao required");		Assert.hasText(username, "Username required");		Authentication auth = new UsernamePasswordAuthenticationToken(username, password);		try {			// Set the SecurityContextHolder ThreadLocal so any subclasses			// automatically know which user is operating			SecurityContextHolder.getContext().setAuthentication(auth);			// Create the home directory first			Directory home = new Directory(username, Directory.ROOT_DIRECTORY);			documentDao.create(home);			addPermission(documentDao, home, username, LEVEL_GRANT_ADMIN);			addPermission(documentDao, home, "ROLE_USER", LEVEL_GRANT_READ);			createFiles(documentDao, home);			// Now create the confidential directory			Directory confid = new Directory("confidential", home);			documentDao.create(confid);			addPermission(documentDao, confid, "ROLE_USER", LEVEL_NEGATE_READ);			createFiles(documentDao, confid);			// Now create the shared directory			Directory shared = new Directory("shared", home);			documentDao.create(shared);			addPermission(documentDao, shared, "ROLE_USER", LEVEL_GRANT_READ);			addPermission(documentDao, shared, "ROLE_USER", LEVEL_GRANT_WRITE);			createFiles(documentDao, shared);		}		finally {			// Clear the SecurityContextHolder ThreadLocal so future calls are			// guaranteed to be clean			SecurityContextHolder.clearContext();		}	}
public void setAlgorithm(SecretKeyFactoryAlgorithm secretKeyFactoryAlgorithm) {		if (secretKeyFactoryAlgorithm == null) {			throw new IllegalArgumentException("secretKeyFactoryAlgorithm cannot be null");		}		String algorithmName = secretKeyFactoryAlgorithm.name();		try {			SecretKeyFactory.getInstance(algorithmName);		}		catch (NoSuchAlgorithmException e) {			throw new IllegalArgumentException("Invalid algorithm '" + algorithmName + "'.", e);		}		this.algorithm = algorithmName;	}
public void handle(Callback callback, Authentication auth) throws IOException,			UnsupportedCallbackException {		if (callback instanceof PasswordCallback) {			PasswordCallback pc = (PasswordCallback) callback;			pc.setPassword(auth.getCredentials().toString().toCharArray());		}	}
private static HttpMethod valueOf(String method) {		try {			return HttpMethod.valueOf(method);		}		catch (IllegalArgumentException e) {		}		return null;	}
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)			throws IOException, ServletException {		HttpServletRequest request = (HttpServletRequest) req;		HttpServletResponse response = (HttpServletResponse) res;		if (requiresLogout(request, response)) {			Authentication auth = SecurityContextHolder.getContext().getAuthentication();			if (logger.isDebugEnabled()) {				logger.debug("Logging out user '" + auth						+ "' and transferring to logout destination");			}			this.handler.logout(request, response, auth);			logoutSuccessHandler.onLogoutSuccess(request, response, auth);			return;		}		chain.doFilter(request, response);	}
@Override	public DirContextOperations searchForUser(String username) {		if (logger.isDebugEnabled()) {			logger.debug("Searching for user '" + username + "', with user search "					+ this);		}		SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate(				contextSource);		template.setSearchControls(searchControls);		try {			return template.searchForSingleEntry(searchBase, searchFilter,					new String[] { username });		}		catch (IncorrectResultSizeDataAccessException notFound) {			if (notFound.getActualSize() == 0) {				throw new UsernameNotFoundException("User " + username						+ " not found in directory.");			}			// Search should never return multiple results if properly configured, so just			// rethrow			throw notFound;		}	}
public String beginConsumption(HttpServletRequest req, String identityUrl,			String returnToUrl, String realm) throws OpenIDConsumerException {		List<DiscoveryInformation> discoveries;		try {			discoveries = consumerManager.discover(identityUrl);		}		catch (DiscoveryException e) {			throw new OpenIDConsumerException("Error during discovery", e);		}		DiscoveryInformation information = consumerManager.associate(discoveries);		req.getSession().setAttribute(DISCOVERY_INFO_KEY, information);		AuthRequest authReq;		try {			authReq = consumerManager.authenticate(information, returnToUrl, realm);			logger.debug("Looking up attribute fetch list for identifier: " + identityUrl);			List<OpenIDAttribute> attributesToFetch = attributesToFetchFactory					.createAttributeList(identityUrl);			if (!attributesToFetch.isEmpty()) {				req.getSession().setAttribute(ATTRIBUTE_LIST_KEY, attributesToFetch);				FetchRequest fetchRequest = FetchRequest.createFetchRequest();				for (OpenIDAttribute attr : attributesToFetch) {					if (logger.isDebugEnabled()) {						logger.debug("Adding attribute " + attr.getType()								+ " to fetch request");					}					fetchRequest.addAttribute(attr.getName(), attr.getType(),							attr.isRequired(), attr.getCount());				}				authReq.addExtension(fetchRequest);			}		}		catch (MessageException e) {			throw new OpenIDConsumerException(					"Error processing ConsumerManager authentication", e);		}		catch (ConsumerException e) {			throw new OpenIDConsumerException(					"Error processing ConsumerManager authentication", e);		}		return authReq.getDestinationUrl(true);	}
public String encode(CharSequence rawPassword) {		String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX;		return digest(salt, rawPassword);	}
public boolean matches(CharSequence rawPassword, String encodedPassword) {		String salt = extractSalt(encodedPassword);		String rawPasswordEncoded = digest(salt, rawPassword);		return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded);	}
private static void performVersionChecks(String minSpringVersion) {		if (minSpringVersion == null) {			return;		}		// Check Spring Compatibility		String springVersion = SpringVersion.getVersion();		String version = getVersion();		if (disableChecks(springVersion, version)) {			return;		}		logger.info("You are running with Spring Security Core " + version);		if (new ComparableVersion(springVersion)				.compareTo(new ComparableVersion(minSpringVersion)) < 0) {			logger.warn("**** You are advised to use Spring " + minSpringVersion					+ " or later with this version. You are running: " + springVersion);		}	}
private static boolean disableChecks(String springVersion,			String springSecurityVersion) {		if (springVersion == null || springVersion.equals(springSecurityVersion)) {			return true;		}		return Boolean.getBoolean(DISABLE_CHECKS);	}
private static String getSpringVersion() {		Properties properties = new Properties();		try {			properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream("META-INF/spring-security.versions"));		} catch (IOException | NullPointerException e) {			return null;		}		return properties.getProperty("org.springframework:spring-core");	}
private Mono<String> clientRegistrationId(Mono<Authentication> authentication) {		return authentication				.filter(t -> this.defaultOAuth2AuthorizedClient && t instanceof OAuth2AuthenticationToken)				.cast(OAuth2AuthenticationToken.class)				.map(OAuth2AuthenticationToken::getAuthorizedClientRegistrationId);	}
public boolean supports(Class<?> clazz) {		for (AfterInvocationProvider provider : providers) {			if (!provider.supports(clazz)) {				return false;			}		}		return true;	}
public X509Configurer<H> userDetailsService(UserDetailsService userDetailsService) {		UserDetailsByNameServiceWrapper<PreAuthenticatedAuthenticationToken> authenticationUserDetailsService = new UserDetailsByNameServiceWrapper<>();		authenticationUserDetailsService.setUserDetailsService(userDetailsService);		return authenticationUserDetailsService(authenticationUserDetailsService);	}
public X509Configurer<H> subjectPrincipalRegex(String subjectPrincipalRegex) {		SubjectDnX509PrincipalExtractor principalExtractor = new SubjectDnX509PrincipalExtractor();		principalExtractor.setSubjectDnRegex(subjectPrincipalRegex);		this.x509PrincipalExtractor = principalExtractor;		return this;	}
public final O build() throws Exception {		if (this.building.compareAndSet(false, true)) {			this.object = doBuild();			return this.object;		}		throw new AlreadyBuiltException("This object has already been built");	}
public final Collection<ConfigAttribute> getAttributes(Object object) {		if (object instanceof MethodInvocation) {			MethodInvocation mi = (MethodInvocation) object;			Object target = mi.getThis();			Class<?> targetClass = null;			if (target != null) {				targetClass = target instanceof Class<?> ? (Class<?>) target						: AopProxyUtils.ultimateTargetClass(target);			}			Collection<ConfigAttribute> attrs = getAttributes(mi.getMethod(), targetClass);			if (attrs != null && !attrs.isEmpty()) {				return attrs;			}			if (target != null && !(target instanceof Class<?>)) {				attrs = getAttributes(mi.getMethod(), target.getClass());			}			return attrs;		}		throw new IllegalArgumentException("Object must be a non-null MethodInvocation");	}
private Map<String, OAuth2AuthorizationRequest> getAuthorizationRequests(HttpServletRequest request) {		HttpSession session = request.getSession(false);		Map<String, OAuth2AuthorizationRequest> authorizationRequests = session == null ? null :				(Map<String, OAuth2AuthorizationRequest>) session.getAttribute(this.sessionAttributeName);		if (authorizationRequests == null) {			return new HashMap<>();		}		return authorizationRequests;	}
public void logIfNeeded(boolean granted, AccessControlEntry ace) {		Assert.notNull(ace, "AccessControlEntry required");		if (ace instanceof AuditableAccessControlEntry) {			AuditableAccessControlEntry auditableAce = (AuditableAccessControlEntry) ace;			if (granted && auditableAce.isAuditSuccess()) {				System.out.println("GRANTED due to ACE: " + ace);			}			else if (!granted && auditableAce.isAuditFailure()) {				System.out.println("DENIED due to ACE: " + ace);			}		}	}
public AttributeExchangeConfigurer attributeExchange(String identifierPattern) {		AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer(				identifierPattern);		this.attributeExchangeConfigurers.add(attributeExchangeConfigurer);		return attributeExchangeConfigurer;	}
private OpenIDConsumer getConsumer() throws ConsumerException {		if (this.openIDConsumer == null) {			this.openIDConsumer = new OpenID4JavaConsumer(getConsumerManager(),					attributesToFetchFactory());		}		return this.openIDConsumer;	}
private AxFetchListFactory attributesToFetchFactory() {		Map<String, List<OpenIDAttribute>> identityToAttrs = new HashMap<String, List<OpenIDAttribute>>();		for (AttributeExchangeConfigurer conf : this.attributeExchangeConfigurers) {			identityToAttrs.put(conf.identifier, conf.getAttributes());		}		return new RegexBasedAxFetchListFactory(identityToAttrs);	}
private AuthenticationUserDetailsService<OpenIDAuthenticationToken> getAuthenticationUserDetailsService(			H http) {		if (this.authenticationUserDetailsService != null) {			return this.authenticationUserDetailsService;		}		return new UserDetailsByNameServiceWrapper<>(				http.getSharedObject(UserDetailsService.class));	}
private void initDefaultLoginFilter(H http) {		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http				.getSharedObject(DefaultLoginPageGeneratingFilter.class);		if (loginPageGeneratingFilter != null && !isCustomLoginPage()) {			loginPageGeneratingFilter.setOpenIdEnabled(true);			loginPageGeneratingFilter.setOpenIDauthenticationUrl(getLoginProcessingUrl());			String loginPageUrl = loginPageGeneratingFilter.getLoginPageUrl();			if (loginPageUrl == null) {				loginPageGeneratingFilter.setLoginPageUrl(getLoginPage());				loginPageGeneratingFilter.setFailureUrl(getFailureUrl());			}			loginPageGeneratingFilter.setOpenIDusernameParameter(					OpenIDAuthenticationFilter.DEFAULT_CLAIMED_IDENTITY_FIELD);		}	}
public ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry authorizeRequests()			throws Exception {		ApplicationContext context = getContext();		return getOrApply(new ExpressionUrlAuthorizationConfigurer<>(context))				.getRegistry();	}
public CsrfConfigurer<HttpSecurity> csrf() throws Exception {		ApplicationContext context = getContext();		return getOrApply(new CsrfConfigurer<>(context));	}
public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception {		OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>());		this.postProcess(configurer);		return configurer;	}
public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception {		OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext()));		this.postProcess(configurer);		return configurer;	}
public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel()			throws Exception {		ApplicationContext context = getContext();		return getOrApply(new ChannelSecurityConfigurer<>(context))				.getRegistry();	}
public HttpSecurity addFilterAfter(Filter filter, Class<? extends Filter> afterFilter) {		comparator.registerAfter(filter.getClass(), afterFilter);		return addFilter(filter);	}
public HttpSecurity addFilterBefore(Filter filter,			Class<? extends Filter> beforeFilter) {		comparator.registerBefore(filter.getClass(), beforeFilter);		return addFilter(filter);	}
public HttpSecurity addFilter(Filter filter) {		Class<? extends Filter> filterClass = filter.getClass();		if (!comparator.isRegistered(filterClass)) {			throw new IllegalArgumentException(					"The Filter class "							+ filterClass.getName()							+ " does not have a registered order and cannot be added without a specified order. Consider using addFilterBefore or addFilterAfter instead.");		}		this.filters.add(filter);		return this;	}
public HttpSecurity addFilterAt(Filter filter, Class<? extends Filter> atFilter) {		this.comparator.registerAt(filter.getClass(), atFilter);		return addFilter(filter);	}
public HttpSecurity mvcMatcher(String mvcPattern) {		HandlerMappingIntrospector introspector = new HandlerMappingIntrospector(getContext());		return requestMatcher(new MvcRequestMatcher(introspector, mvcPattern));	}
@SuppressWarnings("unchecked")	private <C extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity>> C getOrApply(			C configurer) throws Exception {		C existingConfig = (C) getConfigurer(configurer.getClass());		if (existingConfig != null) {			return existingConfig;		}		return apply(configurer);	}
public T pathMatchers(HttpMethod method, String... antPatterns) {		return matcher(ServerWebExchangeMatchers.pathMatchers(method, antPatterns));	}
public boolean compare(final String dn, final String attributeName, final Object value) {		final String comparisonFilter = "(" + attributeName + "={0})";		class LdapCompareCallback implements ContextExecutor {			public Object executeWithContext(DirContext ctx) throws NamingException {				SearchControls ctls = new SearchControls();				ctls.setReturningAttributes(NO_ATTRS);				ctls.setSearchScope(SearchControls.OBJECT_SCOPE);				NamingEnumeration<SearchResult> results = ctx.search(dn,						comparisonFilter, new Object[] { value }, ctls);				Boolean match = Boolean.valueOf(results.hasMore());				LdapUtils.closeEnumeration(results);				return match;			}		}		Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback());		return matches.booleanValue();	}
public DirContextOperations retrieveEntry(final String dn,			final String[] attributesToRetrieve) {		return (DirContextOperations) executeReadOnly(new ContextExecutor() {			public Object executeWithContext(DirContext ctx) throws NamingException {				Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve);				// Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx));				return new DirContextAdapter(attrs, new DistinguishedName(dn),						new DistinguishedName(ctx.getNameInNamespace()));			}		});	}
public Set<String> searchForSingleAttributeValues(final String base,			final String filter, final Object[] params, final String attributeName) {		String[] attributeNames = new String[] { attributeName };		Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues(				base, filter, params, attributeNames);		Set<String> result = new HashSet<>();		for (Map<String, List<String>> map : multipleAttributeValues) {			List<String> values = map.get(attributeName);			if (values != null) {				result.addAll(values);			}		}		return result;	}
public Set<Map<String, List<String>>> searchForMultipleAttributeValues(			final String base, final String filter, final Object[] params,			final String[] attributeNames) {		// Escape the params acording to RFC2254		Object[] encodedParams = new String[params.length];		for (int i = 0; i < params.length; i++) {			encodedParams[i] = LdapEncoder.filterEncode(params[i].toString());		}		String formattedFilter = MessageFormat.format(filter, encodedParams);		logger.debug("Using filter: " + formattedFilter);		final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>();		ContextMapper roleMapper = new ContextMapper() {			public Object mapFromContext(Object ctx) {				DirContextAdapter adapter = (DirContextAdapter) ctx;				Map<String, List<String>> record = new HashMap<String, List<String>>();				if (attributeNames == null || attributeNames.length == 0) {					try {						for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae								.hasMore();) {							Attribute attr = (Attribute) ae.next();							extractStringAttributeValues(adapter, record, attr.getID());						}					}					catch (NamingException x) {						org.springframework.ldap.support.LdapUtils								.convertLdapException(x);					}				}				else {					for (String attributeName : attributeNames) {						extractStringAttributeValues(adapter, record, attributeName);					}				}				record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter)));				set.add(record);				return null;			}		};		SearchControls ctls = new SearchControls();		ctls.setSearchScope(searchControls.getSearchScope());		ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames				: null);		search(base, formattedFilter, ctls, roleMapper);		return set;	}
private void extractStringAttributeValues(DirContextAdapter adapter,			Map<String, List<String>> record, String attributeName) {		Object[] values = adapter.getObjectAttributes(attributeName);		if (values == null || values.length == 0) {			if (logger.isDebugEnabled()) {				logger.debug("No attribute value found for '" + attributeName + "'");			}			return;		}		List<String> svalues = new ArrayList<>();		for (Object o : values) {			if (o != null) {				if (String.class.isAssignableFrom(o.getClass())) {					svalues.add((String) o);				}				else {					if (logger.isDebugEnabled()) {						logger.debug("Attribute:" + attributeName								+ " contains a non string value of type[" + o.getClass()								+ "]");					}					svalues.add(o.toString());				}			}		}		record.put(attributeName, svalues);	}
public DirContextOperations searchForSingleEntry(final String base,			final String filter, final Object[] params) {		return (DirContextOperations) executeReadOnly(new ContextExecutor() {			public Object executeWithContext(DirContext ctx) throws NamingException {				return searchForSingleEntryInternal(ctx, searchControls, base, filter,						params);			}		});	}
public static DirContextOperations searchForSingleEntryInternal(DirContext ctx,			SearchControls searchControls, String base, String filter, Object[] params)			throws NamingException {		final DistinguishedName ctxBaseDn = new DistinguishedName(				ctx.getNameInNamespace());		final DistinguishedName searchBaseDn = new DistinguishedName(base);		final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn,				filter, params, buildControls(searchControls));		if (logger.isDebugEnabled()) {			logger.debug("Searching for entry under DN '" + ctxBaseDn + "', base = '"					+ searchBaseDn + "', filter = '" + filter + "'");		}		Set<DirContextOperations> results = new HashSet<>();		try {			while (resultsEnum.hasMore()) {				SearchResult searchResult = resultsEnum.next();				DirContextAdapter dca = (DirContextAdapter) searchResult.getObject();				Assert.notNull(dca,						"No object returned by search, DirContext is not correctly configured");				if (logger.isDebugEnabled()) {					logger.debug("Found DN: " + dca.getDn());				}				results.add(dca);			}		}		catch (PartialResultException e) {			LdapUtils.closeEnumeration(resultsEnum);			logger.info("Ignoring PartialResultException");		}		if (results.size() == 0) {			throw new IncorrectResultSizeDataAccessException(1, 0);		}		if (results.size() > 1) {			throw new IncorrectResultSizeDataAccessException(1, results.size());		}		return results.iterator().next();	}
private static SearchControls buildControls(SearchControls originalControls) {		return new SearchControls(originalControls.getSearchScope(),				originalControls.getCountLimit(), originalControls.getTimeLimit(),				originalControls.getReturningAttributes(), RETURN_OBJECT,				originalControls.getDerefLinkFlag());	}
private String computeRepeatingSql(String repeatingSql, int requiredRepetitions) {		assert requiredRepetitions > 0 : "requiredRepetitions must be > 0";		final String startSql = selectClause;		final String endSql = orderByClause;		StringBuilder sqlStringBldr = new StringBuilder(startSql.length()				+ endSql.length() + requiredRepetitions * (repeatingSql.length() + 4));		sqlStringBldr.append(startSql);		for (int i = 1; i <= requiredRepetitions; i++) {			sqlStringBldr.append(repeatingSql);			if (i != requiredRepetitions) {				sqlStringBldr.append(" or ");			}		}		sqlStringBldr.append(endSql);		return sqlStringBldr.toString();	}
private void lookupPrimaryKeys(final Map<Serializable, Acl> acls,			final Set<Long> findNow, final List<Sid> sids) {		Assert.notNull(acls, "ACLs are required");		Assert.notEmpty(findNow, "Items to find now required");		String sql = computeRepeatingSql(lookupPrimaryKeysWhereClause, findNow.size());		Set<Long> parentsToLookup = jdbcTemplate.query(sql,				new PreparedStatementSetter() {					public void setValues(PreparedStatement ps) throws SQLException {						int i = 0;						for (Long toFind : findNow) {							i++;							ps.setLong(i, toFind);						}					}				}, new ProcessResultSet(acls, sids));		// Lookup the parents, now that our JdbcTemplate has released the database		// connection (SEC-547)		if (parentsToLookup.size() > 0) {			lookupPrimaryKeys(acls, parentsToLookup, sids);		}	}
public final Map<ObjectIdentity, Acl> readAclsById(List<ObjectIdentity> objects,			List<Sid> sids) {		Assert.isTrue(batchSize >= 1, "BatchSize must be >= 1");		Assert.notEmpty(objects, "Objects to lookup required");		// Map<ObjectIdentity,Acl>		Map<ObjectIdentity, Acl> result = new HashMap<>(); // contains																				// FULLY																				// loaded																				// Acl																				// objects		Set<ObjectIdentity> currentBatchToLoad = new HashSet<>();		for (int i = 0; i < objects.size(); i++) {			final ObjectIdentity oid = objects.get(i);			boolean aclFound = false;			// Check we don't already have this ACL in the results			if (result.containsKey(oid)) {				aclFound = true;			}			// Check cache for the present ACL entry			if (!aclFound) {				Acl acl = aclCache.getFromCache(oid);				// Ensure any cached element supports all the requested SIDs				// (they should always, as our base impl doesn't filter on SID)				if (acl != null) {					if (acl.isSidLoaded(sids)) {						result.put(acl.getObjectIdentity(), acl);						aclFound = true;					}					else {						throw new IllegalStateException(								"Error: SID-filtered element detected when implementation does not perform SID filtering "										+ "- have you added something to the cache manually?");					}				}			}			// Load the ACL from the database			if (!aclFound) {				currentBatchToLoad.add(oid);			}			// Is it time to load from JDBC the currentBatchToLoad?			if ((currentBatchToLoad.size() == this.batchSize)					|| ((i + 1) == objects.size())) {				if (currentBatchToLoad.size() > 0) {					Map<ObjectIdentity, Acl> loadedBatch = lookupObjectIdentities(							currentBatchToLoad, sids);					// Add loaded batch (all elements 100% initialized) to results					result.putAll(loadedBatch);					// Add the loaded batch to the cache					for (Acl loadedAcl : loadedBatch.values()) {						aclCache.putInCache((AclImpl) loadedAcl);					}					currentBatchToLoad.clear();				}			}		}		return result;	}
private Map<ObjectIdentity, Acl> lookupObjectIdentities(			final Collection<ObjectIdentity> objectIdentities, List<Sid> sids) {		Assert.notEmpty(objectIdentities, "Must provide identities to lookup");		final Map<Serializable, Acl> acls = new HashMap<>(); // contains																				// Acls																				// with																				// StubAclParents		// Make the "acls" map contain all requested objectIdentities		// (including markers to each parent in the hierarchy)		String sql = computeRepeatingSql(lookupObjectIdentitiesWhereClause,				objectIdentities.size());		Set<Long> parentsToLookup = jdbcTemplate.query(sql,				new PreparedStatementSetter() {					public void setValues(PreparedStatement ps) throws SQLException {						int i = 0;						for (ObjectIdentity oid : objectIdentities) {							// Determine prepared statement values for this iteration							String type = oid.getType();							// No need to check for nulls, as guaranteed non-null by							// ObjectIdentity.getIdentifier() interface contract							String identifier = oid.getIdentifier().toString();							// Inject values							ps.setString((2 * i) + 1, identifier);							ps.setString((2 * i) + 2, type);							i++;						}					}				}, new ProcessResultSet(acls, sids));		// Lookup the parents, now that our JdbcTemplate has released the database		// connection (SEC-547)		if (parentsToLookup.size() > 0) {			lookupPrimaryKeys(acls, parentsToLookup, sids);		}		// Finally, convert our "acls" containing StubAclParents into true Acls		Map<ObjectIdentity, Acl> resultMap = new HashMap<>();		for (Acl inputAcl : acls.values()) {			Assert.isInstanceOf(AclImpl.class, inputAcl,					"Map should have contained an AclImpl");			Assert.isInstanceOf(Long.class, ((AclImpl) inputAcl).getId(),					"Acl.getId() must be Long");			Acl result = convert(acls, (Long) ((AclImpl) inputAcl).getId());			resultMap.put(result.getObjectIdentity(), result);		}		return resultMap;	}
private AclImpl convert(Map<Serializable, Acl> inputMap, Long currentIdentity) {		Assert.notEmpty(inputMap, "InputMap required");		Assert.notNull(currentIdentity, "CurrentIdentity required");		// Retrieve this Acl from the InputMap		Acl uncastAcl = inputMap.get(currentIdentity);		Assert.isInstanceOf(AclImpl.class, uncastAcl,				"The inputMap contained a non-AclImpl");		AclImpl inputAcl = (AclImpl) uncastAcl;		Acl parent = inputAcl.getParentAcl();		if ((parent != null) && parent instanceof StubAclParent) {			// Lookup the parent			StubAclParent stubAclParent = (StubAclParent) parent;			parent = convert(inputMap, stubAclParent.getId());		}		// Now we have the parent (if there is one), create the true AclImpl		AclImpl result = new AclImpl(inputAcl.getObjectIdentity(),				(Long) inputAcl.getId(), aclAuthorizationStrategy, grantingStrategy,				parent, null, inputAcl.isEntriesInheriting(), inputAcl.getOwner());		// Copy the "aces" from the input to the destination		// Obtain the "aces" from the input ACL		List<AccessControlEntryImpl> aces = readAces(inputAcl);		// Create a list in which to store the "aces" for the "result" AclImpl instance		List<AccessControlEntryImpl> acesNew = new ArrayList<>();		// Iterate over the "aces" input and replace each nested		// AccessControlEntryImpl.getAcl() with the new "result" AclImpl instance		// This ensures StubAclParent instances are removed, as per SEC-951		for (AccessControlEntryImpl ace : aces) {			setAclOnAce(ace, result);			acesNew.add(ace);		}		// Finally, now that the "aces" have been converted to have the "result" AclImpl		// instance, modify the "result" AclImpl instance		setAces(result, acesNew);		return result;	}
protected Sid createSid(boolean isPrincipal, String sid) {		if (isPrincipal) {			return new PrincipalSid(sid);		}		else {			return new GrantedAuthoritySid(sid);		}	}
protected Collection<String> getUserRoles(HttpServletRequest request) {		ArrayList<String> j2eeUserRolesList = new ArrayList<>();		for (String role : j2eeMappableRoles) {			if (request.isUserInRole(role)) {				j2eeUserRolesList.add(role);			}		}		return j2eeUserRolesList;	}
public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails(			HttpServletRequest context) {		Collection<String> j2eeUserRoles = getUserRoles(context);		Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper				.getGrantedAuthorities(j2eeUserRoles);		if (logger.isDebugEnabled()) {			logger.debug("J2EE roles [" + j2eeUserRoles					+ "] mapped to Granted Authorities: [" + userGas + "]");		}		PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails(				context, userGas);		return result;	}
public final void setJwtValidatorFactory(Function<ClientRegistration, OAuth2TokenValidator<Jwt>> jwtValidatorFactory) {		Assert.notNull(jwtValidatorFactory, "jwtValidatorFactory cannot be null");		this.jwtValidatorFactory = jwtValidatorFactory;	}
public final void setJwsAlgorithmResolver(Function<ClientRegistration, JwsAlgorithm> jwsAlgorithmResolver) {		Assert.notNull(jwsAlgorithmResolver, "jwsAlgorithmResolver cannot be null");		this.jwsAlgorithmResolver = jwsAlgorithmResolver;	}
private RootBeanDefinition createEmbeddedServer(Element element,			ParserContext parserContext) {		Object source = parserContext.extractSource(element);		String suffix = element.getAttribute(ATT_ROOT_SUFFIX);		if (!StringUtils.hasText(suffix)) {			suffix = OPT_DEFAULT_ROOT_SUFFIX;		}		String port = element.getAttribute(ATT_PORT);		if (!StringUtils.hasText(port)) {			port = getDefaultPort();			if (logger.isDebugEnabled()) {				logger.debug("Using default port of " + port);			}		}		String url = "ldap://127.0.0.1:" + port + "/" + suffix;		BeanDefinitionBuilder contextSource = BeanDefinitionBuilder				.rootBeanDefinition(CONTEXT_SOURCE_CLASS);		contextSource.addConstructorArgValue(url);		contextSource.addPropertyValue("userDn", "uid=admin,ou=system");		contextSource.addPropertyValue("password", "secret");		RootBeanDefinition apacheContainer = new RootBeanDefinition(				"org.springframework.security.ldap.server.ApacheDSContainer", null, null);		apacheContainer.setSource(source);		apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix);		String ldifs = element.getAttribute(ATT_LDIF_FILE);		if (!StringUtils.hasText(ldifs)) {			ldifs = OPT_DEFAULT_LDIF_FILE;		}		apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs);		apacheContainer.getPropertyValues().addPropertyValue("port", port);		logger.info("Embedded LDAP server bean definition created for URL: " + url);		if (parserContext.getRegistry()				.containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) {			parserContext.getReaderContext().error(					"Only one embedded server bean is allowed per application context",					element);		}		parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS,				apacheContainer);		return (RootBeanDefinition) contextSource.getBeanDefinition();	}
@Override	public Mono<Void> writeHttpHeaders(ServerWebExchange exchange) {		return isSecure(exchange) ? delegate.writeHttpHeaders(exchange) : Mono.empty();	}
private void createServletApiFilter(BeanReference authenticationManager) {		final String ATT_SERVLET_API_PROVISION = "servlet-api-provision";		final String DEF_SERVLET_API_PROVISION = "true";		String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION);		if (!StringUtils.hasText(provideServletApi)) {			provideServletApi = DEF_SERVLET_API_PROVISION;		}		if ("true".equals(provideServletApi)) {			servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class);			servApiFilter.getPropertyValues().add("authenticationManager",					authenticationManager);		}	}
private void createJaasApiFilter() {		final String ATT_JAAS_API_PROVISION = "jaas-api-provision";		final String DEF_JAAS_API_PROVISION = "false";		String provideJaasApi = httpElt.getAttribute(ATT_JAAS_API_PROVISION);		if (!StringUtils.hasText(provideJaasApi)) {			provideJaasApi = DEF_JAAS_API_PROVISION;		}		if ("true".equals(provideJaasApi)) {			jaasApiFilter = new RootBeanDefinition(JaasApiIntegrationFilter.class);		}	}
private ManagedMap<BeanMetadataElement, BeanDefinition> parseInterceptUrlsForChannelSecurity() {		ManagedMap<BeanMetadataElement, BeanDefinition> channelRequestMap = new ManagedMap<>();		for (Element urlElt : interceptUrls) {			String path = urlElt.getAttribute(ATT_PATH_PATTERN);			String method = urlElt.getAttribute(ATT_HTTP_METHOD);			String matcherRef = urlElt.getAttribute(ATT_REQUEST_MATCHER_REF);			boolean hasMatcherRef = StringUtils.hasText(matcherRef);			if (!hasMatcherRef && !StringUtils.hasText(path)) {				pc.getReaderContext().error("pattern attribute cannot be empty or null",						urlElt);			}			String requiredChannel = urlElt.getAttribute(ATT_REQUIRES_CHANNEL);			if (StringUtils.hasText(requiredChannel)) {				BeanMetadataElement matcher = hasMatcherRef ? new RuntimeBeanReference(matcherRef) : matcherType.createMatcher(pc, path, method);				RootBeanDefinition channelAttributes = new RootBeanDefinition(						ChannelAttributeFactory.class);				channelAttributes.getConstructorArgumentValues().addGenericArgumentValue(						requiredChannel);				channelAttributes.setFactoryMethodName("createChannelAttributes");				channelRequestMap.put(matcher, channelAttributes);			}		}		return channelRequestMap;	}
public void writeHeaders(HttpServletRequest request, HttpServletResponse response) {		if (this.requestMatcher.matches(request)) {			if (!response.containsHeader(HSTS_HEADER_NAME)) {				response.setHeader(HSTS_HEADER_NAME, this.hstsHeaderValue);			}		}		else if (this.logger.isDebugEnabled()) {			this.logger					.debug("Not injecting HSTS header since it did not match the requestMatcher "							+ this.requestMatcher);		}	}
public String[] selectImports(AnnotationMetadata importingClassMetadata) {		boolean webmvcPresent = ClassUtils.isPresent(				"org.springframework.web.servlet.DispatcherServlet",				getClass().getClassLoader());		return webmvcPresent				? new String[] {						"org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration" }				: new String[] {};	}
public Object invoke(Object targetObject) throws NoSuchMethodException,			IllegalAccessException, InvocationTargetException {		if (principal != null) {			Authentication request = createAuthenticationRequest(principal, credentials);			request.setAuthenticated(false);			SecurityContextHolder.getContext().setAuthentication(request);			if (logger.isDebugEnabled()) {				logger.debug("Set SecurityContextHolder to contain: " + request);			}		}		try {			return super.invoke(targetObject);		}		finally {			SecurityContextHolder.clearContext();			if (logger.isDebugEnabled()) {				logger.debug("Cleared SecurityContextHolder.");			}		}	}
public void afterPropertiesSet() throws Exception {		Resource webXml = resourceLoader.getResource("/WEB-INF/web.xml");		Document doc = getDocument(webXml.getInputStream());		NodeList webApp = doc.getElementsByTagName("web-app");		if (webApp.getLength() != 1) {			throw new IllegalArgumentException(					"Failed to find 'web-app' element in resource" + webXml);		}		NodeList securityRoles = ((Element) webApp.item(0))				.getElementsByTagName("security-role");		ArrayList<String> roleNames = new ArrayList<>();		for (int i = 0; i < securityRoles.getLength(); i++) {			Element secRoleElt = (Element) securityRoles.item(i);			NodeList roles = secRoleElt.getElementsByTagName("role-name");			if (roles.getLength() > 0) {				String roleName = ((Element) roles.item(0)).getTextContent().trim();				roleNames.add(roleName);				logger.info("Retrieved role-name '" + roleName + "' from web.xml");			}			else {				logger.info("No security-role elements found in " + webXml);			}		}		mappableAttributes = Collections.unmodifiableSet(new HashSet<>(roleNames));	}
public List<Sid> getSids(Authentication authentication) {		Collection<? extends GrantedAuthority> authorities = roleHierarchy				.getReachableGrantedAuthorities(authentication.getAuthorities());		List<Sid> sids = new ArrayList<>(authorities.size() + 1);		sids.add(new PrincipalSid(authentication));		for (GrantedAuthority authority : authorities) {			sids.add(new GrantedAuthoritySid(authority));		}		return sids;	}
private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() {		TypeResolverBuilder<? extends TypeResolverBuilder>  result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);		result = result.init(JsonTypeInfo.Id.CLASS, null);		result = result.inclusion(JsonTypeInfo.As.PROPERTY);		return result;	}
public final void onStartup(ServletContext servletContext) throws ServletException {		beforeSpringSecurityFilterChain(servletContext);		if (this.configurationClasses != null) {			AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext();			rootAppContext.register(this.configurationClasses);			servletContext.addListener(new ContextLoaderListener(rootAppContext));		}		if (enableHttpSessionEventPublisher()) {			servletContext.addListener(					"org.springframework.security.web.session.HttpSessionEventPublisher");		}		servletContext.setSessionTrackingModes(getSessionTrackingModes());		insertSpringSecurityFilterChain(servletContext);		afterSpringSecurityFilterChain(servletContext);	}
private void insertSpringSecurityFilterChain(ServletContext servletContext) {		String filterName = DEFAULT_FILTER_NAME;		DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy(				filterName);		String contextAttribute = getWebApplicationContextAttribute();		if (contextAttribute != null) {			springSecurityFilterChain.setContextAttribute(contextAttribute);		}		registerFilter(servletContext, true, filterName, springSecurityFilterChain);	}
private void registerFilters(ServletContext servletContext,			boolean insertBeforeOtherFilters, Filter... filters) {		Assert.notEmpty(filters, "filters cannot be null or empty");		for (Filter filter : filters) {			if (filter == null) {				throw new IllegalArgumentException(						"filters cannot contain null values. Got "								+ Arrays.asList(filters));			}			String filterName = Conventions.getVariableName(filter);			registerFilter(servletContext, insertBeforeOtherFilters, filterName, filter);		}	}
private final void registerFilter(ServletContext servletContext,			boolean insertBeforeOtherFilters, String filterName, Filter filter) {		Dynamic registration = servletContext.addFilter(filterName, filter);		if (registration == null) {			throw new IllegalStateException(					"Duplicate Filter registration for '" + filterName							+ "'. Check to ensure the Filter is only configured once.");		}		registration.setAsyncSupported(isAsyncSecuritySupported());		EnumSet<DispatcherType> dispatcherTypes = getSecurityDispatcherTypes();		registration.addMappingForUrlPatterns(dispatcherTypes, !insertBeforeOtherFilters,				"/*");	}
private String getWebApplicationContextAttribute() {		String dispatcherServletName = getDispatcherWebApplicationContextSuffix();		if (dispatcherServletName == null) {			return null;		}		return SERVLET_CONTEXT_PREFIX + dispatcherServletName;	}
protected EnumSet<DispatcherType> getSecurityDispatcherTypes() {		return EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR,				DispatcherType.ASYNC);	}
public PersistentRememberMeToken getTokenForSeries(String seriesId) {		try {			return getJdbcTemplate().queryForObject(tokensBySeriesSql,					new RowMapper<PersistentRememberMeToken>() {						public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum)								throws SQLException {							return new PersistentRememberMeToken(rs.getString(1), rs									.getString(2), rs.getString(3), rs.getTimestamp(4));						}					}, seriesId);		}		catch (EmptyResultDataAccessException zeroResults) {			if (logger.isDebugEnabled()) {				logger.debug("Querying token for series '" + seriesId						+ "' returned no results.", zeroResults);			}		}		catch (IncorrectResultSizeDataAccessException moreThanOne) {			logger.error("Querying token for series '" + seriesId					+ "' returned more than one value. Series" + " should be unique");		}		catch (DataAccessException e) {			logger.error("Failed to load token for series " + seriesId, e);		}		return null;	}
protected void registerPublicPermissions(Class<? extends Permission> clazz) {		Assert.notNull(clazz, "Class required");		Field[] fields = clazz.getFields();		for (Field field : fields) {			try {				Object fieldValue = field.get(null);				if (Permission.class.isAssignableFrom(fieldValue.getClass())) {					// Found a Permission static field					Permission perm = (Permission) fieldValue;					String permissionName = field.getName();					registerPermission(perm, permissionName);				}			}			catch (Exception ignore) {			}		}	}
@Override	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)			throws ServletException, IOException {		final boolean debug = this.logger.isDebugEnabled();		String token;		try {			token = this.bearerTokenResolver.resolve(request);		} catch ( OAuth2AuthenticationException invalid ) {			this.authenticationEntryPoint.commence(request, response, invalid);			return;		}		if (token == null) {			filterChain.doFilter(request, response);			return;		}		BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);		authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));		try {			AuthenticationManager authenticationManager = this.authenticationManagerResolver.resolve(request);			Authentication authenticationResult = authenticationManager.authenticate(authenticationRequest);			SecurityContext context = SecurityContextHolder.createEmptyContext();			context.setAuthentication(authenticationResult);			SecurityContextHolder.setContext(context);			filterChain.doFilter(request, response);		} catch (AuthenticationException failed) {			SecurityContextHolder.clearContext();			if (debug) {				this.logger.debug("Authentication request for failed: " + failed);			}			this.authenticationEntryPoint.commence(request, response, failed);		}	}
public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) {		List<GrantedAuthority> result = new ArrayList<>(attributes.size());		for (String attribute : attributes) {			result.add(getGrantedAuthority(attribute));		}		return result;	}
private GrantedAuthority getGrantedAuthority(String attribute) {		if (isConvertAttributeToLowerCase()) {			attribute = attribute.toLowerCase(Locale.getDefault());		}		else if (isConvertAttributeToUpperCase()) {			attribute = attribute.toUpperCase(Locale.getDefault());		}		if (isAddPrefixIfAlreadyExisting() || !attribute.startsWith(getAttributePrefix())) {			return new SimpleGrantedAuthority(getAttributePrefix() + attribute);		}		else {			return new SimpleGrantedAuthority(attribute);		}	}
private void initDefaultLoginFilter(H http) {		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http				.getSharedObject(DefaultLoginPageGeneratingFilter.class);		if (loginPageGeneratingFilter != null && !isCustomLoginPage()) {			loginPageGeneratingFilter.setFormLoginEnabled(true);			loginPageGeneratingFilter.setUsernameParameter(getUsernameParameter());			loginPageGeneratingFilter.setPasswordParameter(getPasswordParameter());			loginPageGeneratingFilter.setLoginPageUrl(getLoginPage());			loginPageGeneratingFilter.setFailureUrl(getFailureUrl());			loginPageGeneratingFilter.setAuthenticationUrl(getLoginProcessingUrl());		}	}
@Override	public OAuth2TokenValidatorResult validate(Jwt token) {		Assert.notNull(token, "token cannot be null");		String tokenIssuer = token.getClaimAsString(JwtClaimNames.ISS);		if (this.issuer.equals(tokenIssuer)) {			return OAuth2TokenValidatorResult.success();		} else {			return OAuth2TokenValidatorResult.failure(INVALID_ISSUER);		}	}
public SessionManagementConfigurer<H> invalidSessionStrategy(			InvalidSessionStrategy invalidSessionStrategy) {		Assert.notNull(invalidSessionStrategy, "invalidSessionStrategy");		this.invalidSessionStrategy = invalidSessionStrategy;		return this;	}
public SessionManagementConfigurer<H> sessionCreationPolicy(			SessionCreationPolicy sessionCreationPolicy) {		Assert.notNull(sessionCreationPolicy, "sessionCreationPolicy cannot be null");		this.sessionPolicy = sessionCreationPolicy;		return this;	}
InvalidSessionStrategy getInvalidSessionStrategy() {		if (this.invalidSessionStrategy != null) {			return this.invalidSessionStrategy;		}		if (this.invalidSessionUrl != null) {			this.invalidSessionStrategy = new SimpleRedirectInvalidSessionStrategy(					this.invalidSessionUrl);		}		if (this.invalidSessionUrl == null) {			return null;		}		if (this.invalidSessionStrategy == null) {			this.invalidSessionStrategy = new SimpleRedirectInvalidSessionStrategy(					this.invalidSessionUrl);		}		return this.invalidSessionStrategy;	}
SessionCreationPolicy getSessionCreationPolicy() {		if (this.sessionPolicy != null) {			return this.sessionPolicy;		}		SessionCreationPolicy sessionPolicy =				getBuilder().getSharedObject(SessionCreationPolicy.class);		return sessionPolicy == null ?				SessionCreationPolicy.IF_REQUIRED : sessionPolicy;	}
private boolean isAllowSessionCreation() {		SessionCreationPolicy sessionPolicy = getSessionCreationPolicy();		return SessionCreationPolicy.ALWAYS == sessionPolicy				|| SessionCreationPolicy.IF_REQUIRED == sessionPolicy;	}
private SessionAuthenticationStrategy getSessionAuthenticationStrategy(H http) {		if (this.sessionAuthenticationStrategy != null) {			return this.sessionAuthenticationStrategy;		}		List<SessionAuthenticationStrategy> delegateStrategies = this.sessionAuthenticationStrategies;		SessionAuthenticationStrategy defaultSessionAuthenticationStrategy;		if (this.providedSessionAuthenticationStrategy == null) {			// If the user did not provide a SessionAuthenticationStrategy			// then default to sessionFixationAuthenticationStrategy			defaultSessionAuthenticationStrategy = postProcess(					this.sessionFixationAuthenticationStrategy);		}		else {			defaultSessionAuthenticationStrategy = this.providedSessionAuthenticationStrategy;		}		if (isConcurrentSessionControlEnabled()) {			SessionRegistry sessionRegistry = getSessionRegistry(http);			ConcurrentSessionControlAuthenticationStrategy concurrentSessionControlStrategy = new ConcurrentSessionControlAuthenticationStrategy(					sessionRegistry);			concurrentSessionControlStrategy.setMaximumSessions(this.maximumSessions);			concurrentSessionControlStrategy					.setExceptionIfMaximumExceeded(this.maxSessionsPreventsLogin);			concurrentSessionControlStrategy = postProcess(					concurrentSessionControlStrategy);			RegisterSessionAuthenticationStrategy registerSessionStrategy = new RegisterSessionAuthenticationStrategy(					sessionRegistry);			registerSessionStrategy = postProcess(registerSessionStrategy);			delegateStrategies.addAll(Arrays.asList(concurrentSessionControlStrategy,					defaultSessionAuthenticationStrategy, registerSessionStrategy));		}		else {			delegateStrategies.add(defaultSessionAuthenticationStrategy);		}		this.sessionAuthenticationStrategy = postProcess(				new CompositeSessionAuthenticationStrategy(delegateStrategies));		return this.sessionAuthenticationStrategy;	}
public void afterPropertiesSet() throws Exception {		Assert.hasLength(this.service, "service cannot be empty.");		Assert.hasLength(this.artifactParameter, "artifactParameter cannot be empty.");		Assert.hasLength(this.serviceParameter, "serviceParameter cannot be empty.");	}
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)			throws IOException, ServletException {		HttpServletRequest request = (HttpServletRequest) req;		HttpServletResponse response = (HttpServletResponse) res;		if (!requiresAuthentication(request, response)) {			chain.doFilter(request, response);			return;		}		if (logger.isDebugEnabled()) {			logger.debug("Request is to process authentication");		}		Authentication authResult;		try {			authResult = attemptAuthentication(request, response);			if (authResult == null) {				// return immediately as subclass has indicated that it hasn't completed				// authentication				return;			}			sessionStrategy.onAuthentication(authResult, request, response);		}		catch (InternalAuthenticationServiceException failed) {			logger.error(					"An internal error occurred while trying to authenticate the user.",					failed);			unsuccessfulAuthentication(request, response, failed);			return;		}		catch (AuthenticationException failed) {			// Authentication failed			unsuccessfulAuthentication(request, response, failed);			return;		}		// Authentication success		if (continueChainBeforeSuccessfulAuthentication) {			chain.doFilter(request, response);		}		successfulAuthentication(request, response, chain, authResult);	}
protected void successfulAuthentication(HttpServletRequest request,			HttpServletResponse response, FilterChain chain, Authentication authResult)			throws IOException, ServletException {		if (logger.isDebugEnabled()) {			logger.debug("Authentication success. Updating SecurityContextHolder to contain: "					+ authResult);		}		SecurityContextHolder.getContext().setAuthentication(authResult);		rememberMeServices.loginSuccess(request, response, authResult);		// Fire event		if (this.eventPublisher != null) {			eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(					authResult, this.getClass()));		}		successHandler.onAuthenticationSuccess(request, response, authResult);	}
protected void unsuccessfulAuthentication(HttpServletRequest request,			HttpServletResponse response, AuthenticationException failed)			throws IOException, ServletException {		SecurityContextHolder.clearContext();		if (logger.isDebugEnabled()) {			logger.debug("Authentication request failed: " + failed.toString(), failed);			logger.debug("Updated SecurityContextHolder to contain null Authentication");			logger.debug("Delegating to authentication failure handler " + failureHandler);		}		rememberMeServices.loginFail(request, response);		failureHandler.onAuthenticationFailure(request, response, failed);	}
void initAccessDeniedHandler(BeanDefinition invalidSessionStrategy,			BeanMetadataElement defaultDeniedHandler) {		BeanMetadataElement accessDeniedHandler = createAccessDeniedHandler(				invalidSessionStrategy, defaultDeniedHandler);		this.csrfFilter.getPropertyValues().addPropertyValue("accessDeniedHandler",				accessDeniedHandler);	}
private BeanMetadataElement createAccessDeniedHandler(			BeanDefinition invalidSessionStrategy,			BeanMetadataElement defaultDeniedHandler) {		if (invalidSessionStrategy == null) {			return defaultDeniedHandler;		}		ManagedMap<Class<? extends AccessDeniedException>, BeanDefinition> handlers = new ManagedMap<Class<? extends AccessDeniedException>, BeanDefinition>();		BeanDefinitionBuilder invalidSessionHandlerBldr = BeanDefinitionBuilder				.rootBeanDefinition(InvalidSessionAccessDeniedHandler.class);		invalidSessionHandlerBldr.addConstructorArgValue(invalidSessionStrategy);		handlers.put(MissingCsrfTokenException.class,				invalidSessionHandlerBldr.getBeanDefinition());		BeanDefinitionBuilder deniedBldr = BeanDefinitionBuilder				.rootBeanDefinition(DelegatingAccessDeniedHandler.class);		deniedBldr.addConstructorArgValue(handlers);		deniedBldr.addConstructorArgValue(defaultDeniedHandler);		return deniedBldr.getBeanDefinition();	}
public static SecretKey newSecretKey(String algorithm, String password) {		return newSecretKey(algorithm, new PBEKeySpec(password.toCharArray()));	}
public static SecretKey newSecretKey(String algorithm, PBEKeySpec keySpec) {		try {			SecretKeyFactory factory = SecretKeyFactory.getInstance(algorithm);			return factory.generateSecret(keySpec);		}		catch (NoSuchAlgorithmException e) {			throw new IllegalArgumentException("Not a valid encryption algorithm", e);		}		catch (InvalidKeySpecException e) {			throw new IllegalArgumentException("Not a valid secret key", e);		}	}
public static Cipher newCipher(String algorithm) {		try {			return Cipher.getInstance(algorithm);		}		catch (NoSuchAlgorithmException e) {			throw new IllegalArgumentException("Not a valid encryption algorithm", e);		}		catch (NoSuchPaddingException e) {			throw new IllegalStateException("Should not happen", e);		}	}
public static <T extends AlgorithmParameterSpec> T getParameterSpec(Cipher cipher,			Class<T> parameterSpecClass) {		try {			return cipher.getParameters().getParameterSpec(parameterSpecClass);		}		catch (InvalidParameterSpecException e) {			throw new IllegalArgumentException("Unable to access parameter", e);		}	}
public static void initCipher(Cipher cipher, int mode, SecretKey secretKey) {		initCipher(cipher, mode, secretKey, null);	}
public static void initCipher(Cipher cipher, int mode, SecretKey secretKey,			byte[] salt, int iterationCount) {		initCipher(cipher, mode, secretKey, new PBEParameterSpec(salt, iterationCount));	}
public static void initCipher(Cipher cipher, int mode, SecretKey secretKey,			AlgorithmParameterSpec parameterSpec) {		try {			if (parameterSpec != null) {				cipher.init(mode, secretKey, parameterSpec);			}			else {				cipher.init(mode, secretKey);			}		}		catch (InvalidKeyException e) {			throw new IllegalArgumentException(					"Unable to initialize due to invalid secret key", e);		}		catch (InvalidAlgorithmParameterException e) {			throw new IllegalStateException(					"Unable to initialize due to invalid decryption parameter spec", e);		}	}
public static byte[] doFinal(Cipher cipher, byte[] input) {		try {			return cipher.doFinal(input);		}		catch (IllegalBlockSizeException e) {			throw new IllegalStateException(					"Unable to invoke Cipher due to illegal block size", e);		}		catch (BadPaddingException e) {			throw new IllegalStateException("Unable to invoke Cipher due to bad padding",					e);		}	}
@Override	public void afterPropertiesSet() {		try {			super.afterPropertiesSet();		}		catch (ServletException e) {			// convert to RuntimeException for passivity on afterPropertiesSet signature			throw new RuntimeException(e);		}		Assert.notNull(authenticationManager, "An AuthenticationManager must be set");	}
public void doFilter(ServletRequest request, ServletResponse response,			FilterChain chain) throws IOException, ServletException {		if (logger.isDebugEnabled()) {			logger.debug("Checking secure context token: "					+ SecurityContextHolder.getContext().getAuthentication());		}		if (requiresAuthentication((HttpServletRequest) request)) {			doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response);		}		chain.doFilter(request, response);	}
protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) {		Object principal = getPreAuthenticatedPrincipal(request);		if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) {			return false;		}		if (principal != null && principal.equals(currentAuthentication.getPrincipal())) {			return false;		}		if (logger.isDebugEnabled()) {			logger.debug("Pre-authenticated principal has changed to " + principal + " and will be reauthenticated");		}		return true;	}
private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {		Authentication authResult;		Object principal = getPreAuthenticatedPrincipal(request);		Object credentials = getPreAuthenticatedCredentials(request);		if (principal == null) {			if (logger.isDebugEnabled()) {				logger.debug("No pre-authenticated principal found in request");			}			return;		}		if (logger.isDebugEnabled()) {			logger.debug("preAuthenticatedPrincipal = " + principal					+ ", trying to authenticate");		}		try {			PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken(					principal, credentials);			authRequest.setDetails(authenticationDetailsSource.buildDetails(request));			authResult = authenticationManager.authenticate(authRequest);			successfulAuthentication(request, response, authResult);		}		catch (AuthenticationException failed) {			unsuccessfulAuthentication(request, response, failed);			if (!continueFilterChainOnUnsuccessfulAuthentication) {				throw failed;			}		}	}
protected void successfulAuthentication(HttpServletRequest request,			HttpServletResponse response, Authentication authResult) throws IOException, ServletException {		if (logger.isDebugEnabled()) {			logger.debug("Authentication success: " + authResult);		}		SecurityContextHolder.getContext().setAuthentication(authResult);		// Fire event		if (this.eventPublisher != null) {			eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(					authResult, this.getClass()));		}		if (authenticationSuccessHandler != null) {			authenticationSuccessHandler.onAuthenticationSuccess(request, response, authResult);		}	}
protected void unsuccessfulAuthentication(HttpServletRequest request,			HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {		SecurityContextHolder.clearContext();		if (logger.isDebugEnabled()) {			logger.debug("Cleared security context due to exception", failed);		}		request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, failed);		if (authenticationFailureHandler != null) {			authenticationFailureHandler.onAuthenticationFailure(request, response, failed);		}	}
@Override	public final void sendError(int sc, String msg) throws IOException {		doOnResponseCommitted();		super.sendError(sc, msg);	}
private void checkContentLength(long contentLengthToWrite) {		this.contentWritten += contentLengthToWrite;		boolean isBodyFullyWritten = this.contentLength > 0				&& this.contentWritten >= this.contentLength;		int bufferSize = getBufferSize();		boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize;		if (isBodyFullyWritten || requiresFlush) {			doOnResponseCommitted();		}	}
private ExpressionParser getParser() {		if (this.parser != null) {			return this.parser;		}		synchronized (parserLock) {			this.parser = handler.getExpressionParser();			this.handler = null;		}		return this.parser;	}
public void setAllowedHttpMethods(Collection<String> allowedHttpMethods) {		if (allowedHttpMethods == null) {			throw new IllegalArgumentException("allowedHttpMethods cannot be null");		}		if (allowedHttpMethods == ALLOW_ANY_HTTP_METHOD) {			this.allowedHttpMethods = ALLOW_ANY_HTTP_METHOD;		} else {			this.allowedHttpMethods = new HashSet<>(allowedHttpMethods);		}	}
public void setAllowUrlEncodedPercent(boolean allowUrlEncodedPercent) {		if (allowUrlEncodedPercent) {			this.encodedUrlBlacklist.remove(ENCODED_PERCENT);			this.decodedUrlBlacklist.remove(PERCENT);		} else {			this.encodedUrlBlacklist.add(ENCODED_PERCENT);			this.decodedUrlBlacklist.add(PERCENT);		}	}
public Set<GrantedAuthority> mapAuthorities(			Collection<? extends GrantedAuthority> authorities) {		HashSet<GrantedAuthority> mapped = new HashSet<>(				authorities.size());		for (GrantedAuthority authority : authorities) {			mapped.add(mapAuthority(authority.getAuthority()));		}		if (defaultAuthority != null) {			mapped.add(defaultAuthority);		}		return mapped;	}
public final T defaultSuccessUrl(String defaultSuccessUrl, boolean alwaysUse) {		SavedRequestAwareAuthenticationSuccessHandler handler = new SavedRequestAwareAuthenticationSuccessHandler();		handler.setDefaultTargetUrl(defaultSuccessUrl);		handler.setAlwaysUseDefaultTargetUrl(alwaysUse);		this.defaultSuccessHandler = handler;		return successHandler(handler);	}
public T loginProcessingUrl(String loginProcessingUrl) {		this.loginProcessingUrl = loginProcessingUrl;		authFilter				.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl));		return getSelf();	}
public final T failureUrl(String authenticationFailureUrl) {		T result = failureHandler(new SimpleUrlAuthenticationFailureHandler(				authenticationFailureUrl));		this.failureUrl = authenticationFailureUrl;		return result;	}
protected T loginPage(String loginPage) {		setLoginPage(loginPage);		updateAuthenticationDefaults();		this.customLoginPage = true;		return getSelf();	}
protected final void updateAuthenticationDefaults() {		if (loginProcessingUrl == null) {			loginProcessingUrl(loginPage);		}		if (failureHandler == null) {			failureUrl(loginPage + "?error");		}		final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer(				LogoutConfigurer.class);		if (logoutConfigurer != null && !logoutConfigurer.isCustomLogoutSuccess()) {			logoutConfigurer.logoutSuccessUrl(loginPage + "?logout");		}	}
protected final void updateAccessDefaults(B http) {		if (permitAll) {			PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl);		}	}
public OAuth2LoginConfigurer<B> clientRegistrationRepository(ClientRegistrationRepository clientRegistrationRepository) {		Assert.notNull(clientRegistrationRepository, "clientRegistrationRepository cannot be null");		this.getBuilder().setSharedObject(ClientRegistrationRepository.class, clientRegistrationRepository);		return this;	}
public OAuth2LoginConfigurer<B> authorizedClientRepository(OAuth2AuthorizedClientRepository authorizedClientRepository) {		Assert.notNull(authorizedClientRepository, "authorizedClientRepository cannot be null");		this.getBuilder().setSharedObject(OAuth2AuthorizedClientRepository.class, authorizedClientRepository);		return this;	}
public OAuth2LoginConfigurer<B> authorizedClientService(OAuth2AuthorizedClientService authorizedClientService) {		Assert.notNull(authorizedClientService, "authorizedClientService cannot be null");		this.authorizedClientRepository(new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService));		return this;	}
private void interceptUrl(Iterable<? extends RequestMatcher> requestMatchers,			Collection<ConfigAttribute> configAttributes) {		for (RequestMatcher requestMatcher : requestMatchers) {			REGISTRY.addMapping(new AbstractConfigAttributeRequestMatcherRegistry.UrlMapping(					requestMatcher, configAttributes));		}	}
@Override	public OAuth2TokenValidatorResult validate(Jwt jwt) {		Assert.notNull(jwt, "jwt cannot be null");		Instant expiry = jwt.getExpiresAt();		if (expiry != null) {			if (Instant.now(this.clock).minus(clockSkew).isAfter(expiry)) {				OAuth2Error error = new OAuth2Error(						OAuth2ErrorCodes.INVALID_REQUEST,						String.format("Jwt expired at %s", jwt.getExpiresAt()),						"https://tools.ietf.org/html/rfc6750#section-3.1");				return OAuth2TokenValidatorResult.failure(error);			}		}		Instant notBefore = jwt.getNotBefore();		if (notBefore != null) {			if (Instant.now(this.clock).plus(clockSkew).isBefore(notBefore)) {				OAuth2Error error = new OAuth2Error(						OAuth2ErrorCodes.INVALID_REQUEST,						String.format("Jwt used before %s", jwt.getNotBefore()),						"https://tools.ietf.org/html/rfc6750#section-3.1");				return OAuth2TokenValidatorResult.failure(error);			}		}		return OAuth2TokenValidatorResult.success();	}
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,			BeanDefinitionRegistry registry) {		BeanDefinition interceptor = registry				.getBeanDefinition("methodSecurityInterceptor");		BeanDefinitionBuilder aspect = BeanDefinitionBuilder				.rootBeanDefinition("org.springframework.security.access.intercept.aspectj.aspect.AnnotationSecurityAspect");		aspect.setFactoryMethod("aspectOf");		aspect.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);		aspect.addPropertyValue("securityInterceptor", interceptor);		registry.registerBeanDefinition("annotationSecurityAspect$0",				aspect.getBeanDefinition());	}
@Override	public UserDetails mapUserFromContext(DirContextOperations ctx, String username,			Collection<? extends GrantedAuthority> authorities) {		String dn = ctx.getNameInNamespace();		this.logger.debug("Mapping user details from context with DN: " + dn);		LdapUserDetailsImpl.Essence essence = new LdapUserDetailsImpl.Essence();		essence.setDn(dn);		Object passwordValue = ctx.getObjectAttribute(this.passwordAttributeName);		if (passwordValue != null) {			essence.setPassword(mapPassword(passwordValue));		}		essence.setUsername(username);		// Map the roles		for (int i = 0; (this.roleAttributes != null)				&& (i < this.roleAttributes.length); i++) {			String[] rolesForAttribute = ctx.getStringAttributes(this.roleAttributes[i]);			if (rolesForAttribute == null) {				this.logger.debug("Couldn't read role attribute '"						+ this.roleAttributes[i] + "' for user " + dn);				continue;			}			for (String role : rolesForAttribute) {				GrantedAuthority authority = createAuthority(role);				if (authority != null) {					essence.addAuthority(authority);				}			}		}		// Add the supplied authorities		for (GrantedAuthority authority : authorities) {			essence.addAuthority(authority);		}		// Check for PPolicy data		PasswordPolicyResponseControl ppolicy = (PasswordPolicyResponseControl) ctx				.getObjectAttribute(PasswordPolicyControl.OID);		if (ppolicy != null) {			essence.setTimeBeforeExpiration(ppolicy.getTimeBeforeExpiration());			essence.setGraceLoginsRemaining(ppolicy.getGraceLoginsRemaining());		}		return essence.createUserDetails();	}
protected String mapPassword(Object passwordValue) {		if (!(passwordValue instanceof String)) {			// Assume it's binary			passwordValue = new String((byte[]) passwordValue);		}		return (String) passwordValue;	}
protected GrantedAuthority createAuthority(Object role) {		if (role instanceof String) {			if (this.convertToUpperCase) {				role = ((String) role).toUpperCase();			}			return new SimpleGrantedAuthority(this.rolePrefix + role);		}		return null;	}
public void setJwtValidator(OAuth2TokenValidator<Jwt> jwtValidator) {		Assert.notNull(jwtValidator, "jwtValidator cannot be null");		this.jwtValidator = jwtValidator;		this.delegate.setJwtValidator(jwtValidator);	}
public final void setRestOperations(RestOperations restOperations) {		Assert.notNull(restOperations, "restOperations cannot be null");		this.jwtDecoderBuilder = this.jwtDecoderBuilder.restOperations(restOperations);		this.delegate = makeDelegate();	}
public Object resolveArgument(MethodParameter parameter,				ModelAndViewContainer mavContainer, NativeWebRequest webRequest,				WebDataBinderFactory binderFactory) throws Exception {		SecurityContext securityContext = SecurityContextHolder.getContext();		if (securityContext == null) {			return null;		}		Object securityContextResult = securityContext;		CurrentSecurityContext securityContextAnnotation = findMethodAnnotation(				CurrentSecurityContext.class, parameter);		String expressionToParse = securityContextAnnotation.expression();		if (StringUtils.hasLength(expressionToParse)) {			StandardEvaluationContext context = new StandardEvaluationContext();			context.setRootObject(securityContext);			context.setVariable("this", securityContext);			Expression expression = this.parser.parseExpression(expressionToParse);			securityContextResult = expression.getValue(context);		}		if (securityContextResult != null				&& !parameter.getParameterType().isAssignableFrom(securityContextResult.getClass())) {			if (securityContextAnnotation.errorOnInvalidType()) {				throw new ClassCastException(securityContextResult + " is not assignable to "						+ parameter.getParameterType());			}			else {				return null;			}		}		return securityContextResult;	}
private <T extends Annotation> T findMethodAnnotation(Class<T> annotationClass,			MethodParameter parameter) {		T annotation = parameter.getParameterAnnotation(annotationClass);		if (annotation != null) {			return annotation;		}		Annotation[] annotationsToSearch = parameter.getParameterAnnotations();		for (Annotation toSearch : annotationsToSearch) {			annotation = AnnotationUtils.findAnnotation(toSearch.annotationType(),					annotationClass);			if (annotation != null) {				return annotation;			}		}		return null;	}
public Object resolveArgument(MethodParameter parameter,			ModelAndViewContainer mavContainer, NativeWebRequest webRequest,			WebDataBinderFactory binderFactory) throws Exception {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (authentication == null) {			return null;		}		Object principal = authentication.getPrincipal();		AuthenticationPrincipal authPrincipal = findMethodAnnotation(				AuthenticationPrincipal.class, parameter);		String expressionToParse = authPrincipal.expression();		if (StringUtils.hasLength(expressionToParse)) {			StandardEvaluationContext context = new StandardEvaluationContext();			context.setRootObject(principal);			context.setVariable("this", principal);			context.setBeanResolver(beanResolver);			Expression expression = this.parser.parseExpression(expressionToParse);			principal = expression.getValue(context);		}		if (principal != null				&& !parameter.getParameterType().isAssignableFrom(principal.getClass())) {			if (authPrincipal.errorOnInvalidType()) {				throw new ClassCastException(principal + " is not assignable to "						+ parameter.getParameterType());			}			else {				return null;			}		}		return principal;	}
public static OAuth2TokenValidator<Jwt> createDefaultWithIssuer(String issuer) {		List<OAuth2TokenValidator<Jwt>> validators = new ArrayList<>();		validators.add(new JwtTimestampValidator());		validators.add(new JwtIssuerValidator(issuer));		return new DelegatingOAuth2TokenValidator<>(validators);	}
@Override	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {		if (hasUserDefinedConversionService(beanFactory)) {			return;		}		Converter<String, RSAPrivateKey> pkcs8 = pkcs8();		Converter<String, RSAPublicKey> x509 = x509();		ConversionService service = beanFactory.getConversionService();		if (service instanceof ConverterRegistry) {			ConverterRegistry registry = (ConverterRegistry) service;			registry.addConverter(String.class, RSAPrivateKey.class, pkcs8);			registry.addConverter(String.class, RSAPublicKey.class, x509);		} else {			beanFactory.addPropertyEditorRegistrar(registry -> {				registry.registerCustomEditor(RSAPublicKey.class, new ConverterPropertyEditorAdapter<>(x509));				registry.registerCustomEditor(RSAPrivateKey.class, new ConverterPropertyEditorAdapter<>(pkcs8));			});		}	}
@Override	public final Authentication autoLogin(HttpServletRequest request,			HttpServletResponse response) {		String rememberMeCookie = extractRememberMeCookie(request);		if (rememberMeCookie == null) {			return null;		}		logger.debug("Remember-me cookie detected");		if (rememberMeCookie.length() == 0) {			logger.debug("Cookie was empty");			cancelCookie(request, response);			return null;		}		UserDetails user = null;		try {			String[] cookieTokens = decodeCookie(rememberMeCookie);			user = processAutoLoginCookie(cookieTokens, request, response);			userDetailsChecker.check(user);			logger.debug("Remember-me cookie accepted");			return createSuccessfulAuthentication(request, user);		}		catch (CookieTheftException cte) {			cancelCookie(request, response);			throw cte;		}		catch (UsernameNotFoundException noUser) {			logger.debug("Remember-me login was valid but corresponding user not found.",					noUser);		}		catch (InvalidCookieException invalidCookie) {			logger.debug("Invalid remember-me cookie: " + invalidCookie.getMessage());		}		catch (AccountStatusException statusInvalid) {			logger.debug("Invalid UserDetails: " + statusInvalid.getMessage());		}		catch (RememberMeAuthenticationException e) {			logger.debug(e.getMessage());		}		cancelCookie(request, response);		return null;	}
protected String extractRememberMeCookie(HttpServletRequest request) {		Cookie[] cookies = request.getCookies();		if ((cookies == null) || (cookies.length == 0)) {			return null;		}		for (Cookie cookie : cookies) {			if (cookieName.equals(cookie.getName())) {				return cookie.getValue();			}		}		return null;	}
protected Authentication createSuccessfulAuthentication(HttpServletRequest request,			UserDetails user) {		RememberMeAuthenticationToken auth = new RememberMeAuthenticationToken(key, user,				authoritiesMapper.mapAuthorities(user.getAuthorities()));		auth.setDetails(authenticationDetailsSource.buildDetails(request));		return auth;	}
protected String[] decodeCookie(String cookieValue) throws InvalidCookieException {		for (int j = 0; j < cookieValue.length() % 4; j++) {			cookieValue = cookieValue + "=";		}		try {			Base64.getDecoder().decode(cookieValue.getBytes());		}		catch (IllegalArgumentException e) {			throw new InvalidCookieException(					"Cookie token was not Base64 encoded; value was '" + cookieValue							+ "'");		}		String cookieAsPlainText = new String(Base64.getDecoder().decode(cookieValue.getBytes()));		String[] tokens = StringUtils.delimitedListToStringArray(cookieAsPlainText,				DELIMITER);		for (int i = 0; i < tokens.length; i++)		{			try			{				tokens[i] = URLDecoder.decode(tokens[i], StandardCharsets.UTF_8.toString());			}			catch (UnsupportedEncodingException e)			{				logger.error(e.getMessage(), e);			}		}		return tokens;	}
protected String encodeCookie(String[] cookieTokens) {		StringBuilder sb = new StringBuilder();		for (int i = 0; i < cookieTokens.length; i++) {			try			{				sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString()));			}			catch (UnsupportedEncodingException e)			{				logger.error(e.getMessage(), e);			}			if (i < cookieTokens.length - 1) {				sb.append(DELIMITER);			}		}		String value = sb.toString();		sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes())));		while (sb.charAt(sb.length() - 1) == '=') {			sb.deleteCharAt(sb.length() - 1);		}		return sb.toString();	}
@Override	public final void loginSuccess(HttpServletRequest request,			HttpServletResponse response, Authentication successfulAuthentication) {		if (!rememberMeRequested(request, parameter)) {			logger.debug("Remember-me login not requested.");			return;		}		onLoginSuccess(request, response, successfulAuthentication);	}
protected boolean rememberMeRequested(HttpServletRequest request, String parameter) {		if (alwaysRemember) {			return true;		}		String paramValue = request.getParameter(parameter);		if (paramValue != null) {			if (paramValue.equalsIgnoreCase("true") || paramValue.equalsIgnoreCase("on")					|| paramValue.equalsIgnoreCase("yes") || paramValue.equals("1")) {				return true;			}		}		if (logger.isDebugEnabled()) {			logger.debug("Did not send remember-me cookie (principal did not set parameter '"					+ parameter + "')");		}		return false;	}
protected void cancelCookie(HttpServletRequest request, HttpServletResponse response) {		logger.debug("Cancelling cookie");		Cookie cookie = new Cookie(cookieName, null);		cookie.setMaxAge(0);		cookie.setPath(getCookiePath(request));		if (cookieDomain != null) {			cookie.setDomain(cookieDomain);		}		response.addCookie(cookie);	}
protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request,			HttpServletResponse response) {		String cookieValue = encodeCookie(tokens);		Cookie cookie = new Cookie(cookieName, cookieValue);		cookie.setMaxAge(maxAge);		cookie.setPath(getCookiePath(request));		if (cookieDomain != null) {			cookie.setDomain(cookieDomain);		}		if (maxAge < 1) {			cookie.setVersion(1);		}		if (useSecureCookie == null) {			cookie.setSecure(request.isSecure());		}		else {			cookie.setSecure(useSecureCookie);		}		cookie.setHttpOnly(true);		response.addCookie(cookie);	}
@Override	public void logout(HttpServletRequest request, HttpServletResponse response,			Authentication authentication) {		if (logger.isDebugEnabled()) {			logger.debug("Logout of user "					+ (authentication == null ? "Unknown" : authentication.getName()));		}		cancelCookie(request, response);	}
public static Converter<InputStream, RSAPrivateKey> pkcs8() {		KeyFactory keyFactory = rsaFactory();		return source -> {			List<String> lines = readAllLines(source);			Assert.isTrue(!lines.isEmpty() && lines.get(0).startsWith(PKCS8_PEM_HEADER),					"Key is not in PEM-encoded PKCS#8 format, " +							"please check that the header begins with -----" + PKCS8_PEM_HEADER + "-----");			String base64Encoded = lines.stream()					.filter(RsaKeyConverters::isNotPkcs8Wrapper)					.collect(Collectors.joining());			byte[] pkcs8 = Base64.getDecoder().decode(base64Encoded);			try {				return (RSAPrivateKey) keyFactory.generatePrivate(						new PKCS8EncodedKeySpec(pkcs8));			} catch (Exception e) {				throw new IllegalArgumentException(e);			}		};	}
public static Converter<InputStream, RSAPublicKey> x509() {		KeyFactory keyFactory = rsaFactory();		return source -> {			List<String> lines = readAllLines(source);			Assert.isTrue(!lines.isEmpty() && lines.get(0).startsWith(X509_PEM_HEADER),					"Key is not in PEM-encoded X.509 format, " +							"please check that the header begins with -----" + X509_PEM_HEADER + "-----");			String base64Encoded = lines.stream()					.filter(RsaKeyConverters::isNotX509Wrapper)					.collect(Collectors.joining());			byte[] x509 = Base64.getDecoder().decode(base64Encoded);			try {				return (RSAPublicKey) keyFactory.generatePublic(						new X509EncodedKeySpec(x509));			} catch (Exception e) {				throw new IllegalArgumentException(e);			}		};	}
@Override	public Mono<Void> writeHttpHeaders(ServerWebExchange exchange) {		HttpHeaders headers = exchange.getResponse().getHeaders();		boolean containsOneHeaderToAdd = Collections.disjoint(headers.keySet(), this.headersToAdd.keySet());		if (containsOneHeaderToAdd) {			this.headersToAdd.forEach((name, values) -> {				headers.put(name, values);			});		}		return Mono.empty();	}
protected List<UserDetails> loadUsersByUsername(String username) {		return getJdbcTemplate().query(this.usersByUsernameQuery,				new String[] { username }, new RowMapper<UserDetails>() {					@Override					public UserDetails mapRow(ResultSet rs, int rowNum)							throws SQLException {						String username = rs.getString(1);						String password = rs.getString(2);						boolean enabled = rs.getBoolean(3);						return new User(username, password, enabled, true, true, true,								AuthorityUtils.NO_AUTHORITIES);					}				});	}
protected List<GrantedAuthority> loadUserAuthorities(String username) {		return getJdbcTemplate().query(this.authoritiesByUsernameQuery,				new String[] { username }, new RowMapper<GrantedAuthority>() {					@Override					public GrantedAuthority mapRow(ResultSet rs, int rowNum)							throws SQLException {						String roleName = JdbcDaoImpl.this.rolePrefix + rs.getString(2);						return new SimpleGrantedAuthority(roleName);					}				});	}
protected List<GrantedAuthority> loadGroupAuthorities(String username) {		return getJdbcTemplate().query(this.groupAuthoritiesByUsernameQuery,				new String[] { username }, new RowMapper<GrantedAuthority>() {					@Override					public GrantedAuthority mapRow(ResultSet rs, int rowNum)							throws SQLException {						String roleName = getRolePrefix() + rs.getString(3);						return new SimpleGrantedAuthority(roleName);					}				});	}
protected UserDetails createUserDetails(String username,			UserDetails userFromUserQuery, List<GrantedAuthority> combinedAuthorities) {		String returnUsername = userFromUserQuery.getUsername();		if (!this.usernameBasedPrimaryKey) {			returnUsername = username;		}		return new User(returnUsername, userFromUserQuery.getPassword(),				userFromUserQuery.isEnabled(), userFromUserQuery.isAccountNonExpired(),				userFromUserQuery.isCredentialsNonExpired(), userFromUserQuery.isAccountNonLocked(), combinedAuthorities);	}
@Override	public void onAuthentication(Authentication authentication,			HttpServletRequest request, HttpServletResponse response)					throws SessionAuthenticationException {		boolean containsToken = this.csrfTokenRepository.loadToken(request) != null;		if (containsToken) {			this.csrfTokenRepository.saveToken(null, request, response);			CsrfToken newToken = this.csrfTokenRepository.generateToken(request);			this.csrfTokenRepository.saveToken(newToken, request, response);			request.setAttribute(CsrfToken.class.getName(), newToken);			request.setAttribute(newToken.getParameterName(), newToken);		}	}
public void decide(Authentication authentication, Object object,			Collection<ConfigAttribute> configAttributes) throws AccessDeniedException {		int deny = 0;		for (AccessDecisionVoter voter : getDecisionVoters()) {			int result = voter.vote(authentication, object, configAttributes);			if (logger.isDebugEnabled()) {				logger.debug("Voter: " + voter + ", returned: " + result);			}			switch (result) {			case AccessDecisionVoter.ACCESS_GRANTED:				return;			case AccessDecisionVoter.ACCESS_DENIED:				deny++;				break;			default:				break;			}		}		if (deny > 0) {			throw new AccessDeniedException(messages.getMessage(					"AbstractAccessDecisionManager.accessDenied", "Access is denied"));		}		// To get this far, every AccessDecisionVoter abstained		checkAllowIfAllAbstainDecisions();	}
public void handle(HttpServletRequest request, HttpServletResponse response,			AccessDeniedException accessDeniedException) throws IOException,			ServletException {		if (!response.isCommitted()) {			if (errorPage != null) {				// Put exception into request scope (perhaps of use to a view)				request.setAttribute(WebAttributes.ACCESS_DENIED_403,						accessDeniedException);				// Set the 403 status code.				response.setStatus(HttpStatus.FORBIDDEN.value());				// forward to error page.				RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage);				dispatcher.forward(request, response);			}			else {				response.sendError(HttpStatus.FORBIDDEN.value(),					HttpStatus.FORBIDDEN.getReasonPhrase());			}		}	}
public void setErrorPage(String errorPage) {		if ((errorPage != null) && !errorPage.startsWith("/")) {			throw new IllegalArgumentException("errorPage must begin with '/'");		}		this.errorPage = errorPage;	}
@Override	public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext,			ServerWebExchange exchange) {		ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType());		Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext();		if (reactiveSecurityContext == null) {			return null;		}		return reactiveSecurityContext.flatMap( a -> {			Object p = resolveSecurityContext(parameter, a);			Mono<Object> o = Mono.justOrEmpty(p);			return adapter == null ? o : Mono.just(adapter.fromPublisher(o));		});	}
private Object resolveSecurityContext(MethodParameter parameter, SecurityContext securityContext) {		CurrentSecurityContext securityContextAnnotation = findMethodAnnotation(				CurrentSecurityContext.class, parameter);		Object securityContextResult = securityContext;		String expressionToParse = securityContextAnnotation.expression();		if (StringUtils.hasLength(expressionToParse)) {			StandardEvaluationContext context = new StandardEvaluationContext();			context.setRootObject(securityContext);			context.setVariable("this", securityContext);			context.setBeanResolver(beanResolver);			Expression expression = this.parser.parseExpression(expressionToParse);			securityContextResult = expression.getValue(context);		}		if (isInvalidType(parameter, securityContextResult)) {			if (securityContextAnnotation.errorOnInvalidType()) {				throw new ClassCastException(securityContextResult + " is not assignable to "						+ parameter.getParameterType());			}			else {				return null;			}		}		return securityContextResult;	}
private String getQueryString(final HttpServletRequest request,			final Pattern artifactPattern) {		final String query = request.getQueryString();		if (query == null) {			return null;		}		final String result = artifactPattern.matcher(query).replaceFirst("");		if (result.length() == 0) {			return null;		}		// strip off the trailing & only if the artifact was the first query param		return result.startsWith("&") ? result.substring(1) : result;	}
static Pattern createArtifactPattern(String artifactParameterName) {		Assert.hasLength(artifactParameterName, "artifactParameterName is expected to have a length");		return Pattern.compile("&?" + Pattern.quote(artifactParameterName) + "=[^&]*");	}
private static int getServicePort(URL casServiceUrl) {		int port = casServiceUrl.getPort();		if (port == -1) {			port = casServiceUrl.getDefaultPort();		}		return port;	}
public String getPrincipal() {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (authentication == null) {			log.warn("No Authentication object set in SecurityContext - returning empty String as Principal");			return "";		}		Object principal = authentication.getPrincipal();		if (principal instanceof LdapUserDetails) {			LdapUserDetails details = (LdapUserDetails) principal;			return details.getDn();		}		else if (authentication instanceof AnonymousAuthenticationToken) {			if (log.isDebugEnabled()) {				log.debug("Anonymous Authentication, returning empty String as Principal");			}			return "";		}		else {			throw new IllegalArgumentException(					"The principal property of the authentication object"							+ "needs to be an LdapUserDetails.");		}	}
public Object resolveArgument(MethodParameter parameter,			ModelAndViewContainer mavContainer, NativeWebRequest webRequest,			WebDataBinderFactory binderFactory) throws Exception {		CsrfToken token = (CsrfToken) webRequest.getAttribute(CsrfToken.class.getName(),				NativeWebRequest.SCOPE_REQUEST);		return token;	}
public void onApplicationEvent(AbstractAuthenticationEvent event) {		if (!logInteractiveAuthenticationSuccessEvents				&& event instanceof InteractiveAuthenticationSuccessEvent) {			return;		}		if (logger.isWarnEnabled()) {			final StringBuilder builder = new StringBuilder();			builder.append("Authentication event ");			builder.append(ClassUtils.getShortName(event.getClass()));			builder.append(": ");			builder.append(event.getAuthentication().getName());			builder.append("; details: ");			builder.append(event.getAuthentication().getDetails());			if (event instanceof AbstractAuthenticationFailureEvent) {				builder.append("; exception: ");				builder.append(((AbstractAuthenticationFailureEvent) event)						.getException().getMessage());			}			logger.warn(builder.toString());		}	}
@Bean	public MethodInterceptor methodSecurityInterceptor() throws Exception {		this.methodSecurityInterceptor = isAspectJ()				? new AspectJMethodSecurityInterceptor()				: new MethodSecurityInterceptor();		methodSecurityInterceptor.setAccessDecisionManager(accessDecisionManager());		methodSecurityInterceptor.setAfterInvocationManager(afterInvocationManager());		methodSecurityInterceptor				.setSecurityMetadataSource(methodSecurityMetadataSource());		RunAsManager runAsManager = runAsManager();		if (runAsManager != null) {			methodSecurityInterceptor.setRunAsManager(runAsManager);		}		return this.methodSecurityInterceptor;	}
@Override	public void afterSingletonsInstantiated() {		try {			initializeMethodSecurityInterceptor();		}		catch (Exception e) {			throw new RuntimeException(e);		}		PermissionEvaluator permissionEvaluator = getSingleBeanOrNull(				PermissionEvaluator.class);		if (permissionEvaluator != null) {			this.defaultMethodExpressionHandler					.setPermissionEvaluator(permissionEvaluator);		}		RoleHierarchy roleHierarchy = getSingleBeanOrNull(RoleHierarchy.class);		if (roleHierarchy != null) {			this.defaultMethodExpressionHandler.setRoleHierarchy(roleHierarchy);		}		AuthenticationTrustResolver trustResolver = getSingleBeanOrNull(				AuthenticationTrustResolver.class);		if (trustResolver != null) {			this.defaultMethodExpressionHandler.setTrustResolver(trustResolver);		}		GrantedAuthorityDefaults grantedAuthorityDefaults = getSingleBeanOrNull(				GrantedAuthorityDefaults.class);		if (grantedAuthorityDefaults != null) {			this.defaultMethodExpressionHandler.setDefaultRolePrefix(					grantedAuthorityDefaults.getRolePrefix());		}	}
protected AfterInvocationManager afterInvocationManager() {		if (prePostEnabled()) {			AfterInvocationProviderManager invocationProviderManager = new AfterInvocationProviderManager();			ExpressionBasedPostInvocationAdvice postAdvice = new ExpressionBasedPostInvocationAdvice(					getExpressionHandler());			PostInvocationAdviceProvider postInvocationAdviceProvider = new PostInvocationAdviceProvider(					postAdvice);			List<AfterInvocationProvider> afterInvocationProviders = new ArrayList<>();			afterInvocationProviders.add(postInvocationAdviceProvider);			invocationProviderManager.setProviders(afterInvocationProviders);			return invocationProviderManager;		}		return null;	}
protected AccessDecisionManager accessDecisionManager() {		List<AccessDecisionVoter<? extends Object>> decisionVoters = new ArrayList<AccessDecisionVoter<? extends Object>>();		ExpressionBasedPreInvocationAdvice expressionAdvice = new ExpressionBasedPreInvocationAdvice();		expressionAdvice.setExpressionHandler(getExpressionHandler());		if (prePostEnabled()) {			decisionVoters					.add(new PreInvocationAuthorizationAdviceVoter(expressionAdvice));		}		if (jsr250Enabled()) {			decisionVoters.add(new Jsr250Voter());		}		RoleVoter roleVoter = new RoleVoter();		GrantedAuthorityDefaults grantedAuthorityDefaults =				getSingleBeanOrNull(GrantedAuthorityDefaults.class);		if (grantedAuthorityDefaults != null) {			roleVoter.setRolePrefix(grantedAuthorityDefaults.getRolePrefix());		}		decisionVoters.add(roleVoter);		decisionVoters.add(new AuthenticatedVoter());		return new AffirmativeBased(decisionVoters);	}
protected AuthenticationManager authenticationManager() throws Exception {		if (authenticationManager == null) {			DefaultAuthenticationEventPublisher eventPublisher = objectPostProcessor					.postProcess(new DefaultAuthenticationEventPublisher());			auth = new AuthenticationManagerBuilder(objectPostProcessor);			auth.authenticationEventPublisher(eventPublisher);			configure(auth);			if (disableAuthenticationRegistry) {				authenticationManager = getAuthenticationConfiguration()						.getAuthenticationManager();			}			else {				authenticationManager = auth.build();			}		}		return authenticationManager;	}
@Bean	public MethodSecurityMetadataSource methodSecurityMetadataSource() {		List<MethodSecurityMetadataSource> sources = new ArrayList<>();		ExpressionBasedAnnotationAttributeFactory attributeFactory = new ExpressionBasedAnnotationAttributeFactory(				getExpressionHandler());		MethodSecurityMetadataSource customMethodSecurityMetadataSource = customMethodSecurityMetadataSource();		if (customMethodSecurityMetadataSource != null) {			sources.add(customMethodSecurityMetadataSource);		}		boolean hasCustom = customMethodSecurityMetadataSource != null;		boolean isPrePostEnabled = prePostEnabled();		boolean isSecuredEnabled = securedEnabled();		boolean isJsr250Enabled = jsr250Enabled();		if (!isPrePostEnabled && !isSecuredEnabled && !isJsr250Enabled && !hasCustom) {			throw new IllegalStateException("In the composition of all global method configuration, " +					"no annotation support was actually activated");		}		if (isPrePostEnabled) {			sources.add(new PrePostAnnotationSecurityMetadataSource(attributeFactory));		}		if (isSecuredEnabled) {			sources.add(new SecuredAnnotationSecurityMetadataSource());		}		if (isJsr250Enabled) {			GrantedAuthorityDefaults grantedAuthorityDefaults =					getSingleBeanOrNull(GrantedAuthorityDefaults.class);			Jsr250MethodSecurityMetadataSource jsr250MethodSecurityMetadataSource = this.context.getBean(Jsr250MethodSecurityMetadataSource.class);			if (grantedAuthorityDefaults != null) {				jsr250MethodSecurityMetadataSource.setDefaultRolePrefix(						grantedAuthorityDefaults.getRolePrefix());			}			sources.add(jsr250MethodSecurityMetadataSource);		}		return new DelegatingMethodSecurityMetadataSource(sources);	}
@Bean	public PreInvocationAuthorizationAdvice preInvocationAuthorizationAdvice() {		ExpressionBasedPreInvocationAdvice preInvocationAdvice = new ExpressionBasedPreInvocationAdvice();		preInvocationAdvice.setExpressionHandler(getExpressionHandler());		return preInvocationAdvice;	}
public final void setImportMetadata(AnnotationMetadata importMetadata) {		Map<String, Object> annotationAttributes = importMetadata				.getAnnotationAttributes(EnableGlobalMethodSecurity.class.getName());		enableMethodSecurity = AnnotationAttributes.fromMap(annotationAttributes);	}
@Override	public AppConfigurationEntry[] getAppConfigurationEntry(String name) {		AppConfigurationEntry[] mappedResult = this.mappedConfigurations.get(name);		return mappedResult == null ? this.defaultConfiguration : mappedResult;	}
@Override	public String resolve(HttpServletRequest request) {		String authorizationHeaderToken = resolveFromAuthorizationHeader(request);		String parameterToken = resolveFromRequestParameters(request);		if (authorizationHeaderToken != null) {			if (parameterToken != null) {				BearerTokenError error = new BearerTokenError(BearerTokenErrorCodes.INVALID_REQUEST,						HttpStatus.BAD_REQUEST,						"Found multiple bearer tokens in the request",						"https://tools.ietf.org/html/rfc6750#section-3.1");				throw new OAuth2AuthenticationException(error);			}			return authorizationHeaderToken;		}		else if (parameterToken != null && isParameterTokenSupportedForRequest(request)) {			return parameterToken;		}		return null;	}
public static MappedJwtClaimSetConverter withDefaults			(Map<String, Converter<Object, ?>> claimConverters) {		Assert.notNull(claimConverters, "claimConverters cannot be null");		Map<String, Converter<Object, ?>> claimNameToConverter = new HashMap<>();		claimNameToConverter.put(JwtClaimNames.AUD, AUDIENCE_CONVERTER);		claimNameToConverter.put(JwtClaimNames.EXP, TEMPORAL_CONVERTER);		claimNameToConverter.put(JwtClaimNames.IAT, TEMPORAL_CONVERTER);		claimNameToConverter.put(JwtClaimNames.ISS, ISSUER_CONVERTER);		claimNameToConverter.put(JwtClaimNames.JTI, STRING_CONVERTER);		claimNameToConverter.put(JwtClaimNames.NBF, TEMPORAL_CONVERTER);		claimNameToConverter.put(JwtClaimNames.SUB, STRING_CONVERTER);		claimNameToConverter.putAll(claimConverters);		return new MappedJwtClaimSetConverter(claimNameToConverter);	}
@Override	public Map<String, Object> convert(Map<String, Object> claims) {		Assert.notNull(claims, "claims cannot be null");		Map<String, Object> mappedClaims = new HashMap<>(claims);		for (Map.Entry<String, Converter<Object, ?>> entry : this.claimConverters.entrySet()) {			String claimName = entry.getKey();			Converter<Object, ?> converter = entry.getValue();			if (converter != null) {				Object claim = claims.get(claimName);				Object mappedClaim = converter.convert(claim);				mappedClaims.compute(claimName, (key, value) -> mappedClaim);			}		}		Instant issuedAt = (Instant) mappedClaims.get(JwtClaimNames.IAT);		Instant expiresAt = (Instant) mappedClaims.get(JwtClaimNames.EXP);		if (issuedAt == null && expiresAt != null) {			mappedClaims.put(JwtClaimNames.IAT, expiresAt.minusSeconds(1));		}		return mappedClaims;	}
@Override	public boolean matches(HttpServletRequest request) {		if (this.httpMethod != null && StringUtils.hasText(request.getMethod())				&& this.httpMethod != valueOf(request.getMethod())) {			if (logger.isDebugEnabled()) {				logger.debug("Request '" + request.getMethod() + " "						+ getRequestPath(request) + "'" + " doesn't match '"						+ this.httpMethod + " " + this.pattern + "'");			}			return false;		}		if (this.pattern.equals(MATCH_ALL)) {			if (logger.isDebugEnabled()) {				logger.debug("Request '" + getRequestPath(request)						+ "' matched by universal pattern '/**'");			}			return true;		}		String url = getRequestPath(request);		if (logger.isDebugEnabled()) {			logger.debug("Checking match of request : '" + url + "'; against '"					+ this.pattern + "'");		}		return this.matcher.matches(url);	}
public void doFilter(ServletRequest request, ServletResponse response,			FilterChain chain) throws IOException, ServletException {		FilterInvocation fi = new FilterInvocation(request, response, chain);		invoke(fi);	}
public void setExceptionMappings(Map<?, ?> failureUrlMap) {		this.failureUrlMap.clear();		for (Map.Entry<?, ?> entry : failureUrlMap.entrySet()) {			Object exception = entry.getKey();			Object url = entry.getValue();			Assert.isInstanceOf(String.class, exception,					"Exception key must be a String (the exception classname).");			Assert.isInstanceOf(String.class, url, "URL must be a String");			Assert.isTrue(UrlUtils.isValidRedirectUrl((String) url),					() -> "Not a valid redirect URL: " + url);			this.failureUrlMap.put((String) exception, (String) url);		}	}
public ServerHttpSecurity addFilterAfter(WebFilter webFilter, SecurityWebFiltersOrder order) {		this.webFilters.add(new OrderedWebFilter(webFilter, order.getOrder() + 1));		return this;	}
public SecurityWebFilterChain build() {		if (this.built != null) {			throw new IllegalStateException("This has already been built with the following stacktrace. " + buildToString());		}		this.built = new RuntimeException("First Build Invocation").fillInStackTrace();		if (this.headers != null) {			this.headers.configure(this);		}		WebFilter securityContextRepositoryWebFilter = securityContextRepositoryWebFilter();		if (securityContextRepositoryWebFilter != null) {			this.webFilters.add(securityContextRepositoryWebFilter);		}		if (this.httpsRedirectSpec != null) {			this.httpsRedirectSpec.configure(this);		}		if (this.x509 != null) {			this.x509.configure(this);		}		if (this.csrf != null) {			this.csrf.configure(this);		}		if (this.cors != null) {			this.cors.configure(this);		}		if (this.httpBasic != null) {			this.httpBasic.authenticationManager(this.authenticationManager);			this.httpBasic.configure(this);		}		if (this.formLogin != null) {			this.formLogin.authenticationManager(this.authenticationManager);			if (this.securityContextRepository != null) {				this.formLogin.securityContextRepository(this.securityContextRepository);			}			this.formLogin.configure(this);		}		if (this.oauth2Login != null) {			this.oauth2Login.configure(this);		}		if (this.resourceServer != null) {			this.resourceServer.configure(this);		}		if (this.client != null) {			this.client.configure(this);		}		if (this.anonymous != null) {			this.anonymous.configure(this);		}		this.loginPage.configure(this);		if (this.logout != null) {			this.logout.configure(this);		}		this.requestCache.configure(this);		this.addFilterAt(new SecurityContextServerWebExchangeWebFilter(), SecurityWebFiltersOrder.SECURITY_CONTEXT_SERVER_WEB_EXCHANGE);		if (this.authorizeExchange != null) {			ServerAuthenticationEntryPoint authenticationEntryPoint = getAuthenticationEntryPoint();			ExceptionTranslationWebFilter exceptionTranslationWebFilter = new ExceptionTranslationWebFilter();			if (authenticationEntryPoint != null) {				exceptionTranslationWebFilter.setAuthenticationEntryPoint(					authenticationEntryPoint);			}			ServerAccessDeniedHandler accessDeniedHandler = getAccessDeniedHandler();			if (accessDeniedHandler != null) {				exceptionTranslationWebFilter.setAccessDeniedHandler(						accessDeniedHandler);			}			this.addFilterAt(exceptionTranslationWebFilter, SecurityWebFiltersOrder.EXCEPTION_TRANSLATION);			this.authorizeExchange.configure(this);		}		AnnotationAwareOrderComparator.sort(this.webFilters);		List<WebFilter> sortedWebFilters = new ArrayList<>();		this.webFilters.forEach( f -> {			if (f instanceof OrderedWebFilter) {				f = ((OrderedWebFilter) f).webFilter;			}			sortedWebFilters.add(f);		});		sortedWebFilters.add(0, new ServerWebExchangeReactorContextWebFilter());		return new MatcherSecurityWebFilterChain(getSecurityMatcher(), sortedWebFilters);	}
public void logout(HttpServletRequest request, HttpServletResponse response,			Authentication authentication) {		Assert.notNull(request, "HttpServletRequest required");		if (invalidateHttpSession) {			HttpSession session = request.getSession(false);			if (session != null) {				logger.debug("Invalidating session: " + session.getId());				session.invalidate();			}		}		if (clearAuthentication) {			SecurityContext context = SecurityContextHolder.getContext();			context.setAuthentication(null);		}		SecurityContextHolder.clearContext();	}
@Override	public Mono<Void> onLogoutSuccess(WebFilterExchange exchange, Authentication authentication) {		return Mono.fromRunnable(() -> exchange.getExchange().getResponse().setStatusCode(this.httpStatusToReturn));	}
public void afterPropertiesSet() throws Exception {		Assert.hasLength(this.loginContextName,				"loginContextName cannot be null or empty");		Assert.notEmpty(this.authorityGranters,				"authorityGranters cannot be null or empty");		if (ObjectUtils.isEmpty(this.callbackHandlers)) {			setCallbackHandlers(new JaasAuthenticationCallbackHandler[] {					new JaasNameCallbackHandler(), new JaasPasswordCallbackHandler() });		}		Assert.notNull(this.loginExceptionResolver,				"loginExceptionResolver cannot be null");	}
public Authentication authenticate(Authentication auth)			throws AuthenticationException {		if (!(auth instanceof UsernamePasswordAuthenticationToken)) {			return null;		}		UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth;		Set<GrantedAuthority> authorities;		try {			// Create the LoginContext object, and pass our InternallCallbackHandler			LoginContext loginContext = createLoginContext(					new InternalCallbackHandler(auth));			// Attempt to login the user, the LoginContext will call our			// InternalCallbackHandler at this point.			loginContext.login();			// Create a set to hold the authorities, and add any that have already been			// applied.			authorities = new HashSet<>();			// Get the subject principals and pass them to each of the AuthorityGranters			Set<Principal> principals = loginContext.getSubject().getPrincipals();			for (Principal principal : principals) {				for (AuthorityGranter granter : this.authorityGranters) {					Set<String> roles = granter.grant(principal);					// If the granter doesn't wish to grant any authorities, it should					// return null.					if ((roles != null) && !roles.isEmpty()) {						for (String role : roles) {							authorities.add(new JaasGrantedAuthority(role, principal));						}					}				}			}			// Convert the authorities set back to an array and apply it to the token.			JaasAuthenticationToken result = new JaasAuthenticationToken(					request.getPrincipal(), request.getCredentials(),					new ArrayList<>(authorities), loginContext);			// Publish the success event			publishSuccessEvent(result);			// we're done, return the token.			return result;		}		catch (LoginException loginException) {			AuthenticationException ase = this.loginExceptionResolver					.resolveException(loginException);			publishFailureEvent(request, ase);			throw ase;		}	}
protected void handleLogout(SessionDestroyedEvent event) {		List<SecurityContext> contexts = event.getSecurityContexts();		if (contexts.isEmpty()) {			this.log.debug("The destroyed session has no SecurityContexts");			return;		}		for (SecurityContext context : contexts) {			Authentication auth = context.getAuthentication();			if ((auth != null) && (auth instanceof JaasAuthenticationToken)) {				JaasAuthenticationToken token = (JaasAuthenticationToken) auth;				try {					LoginContext loginContext = token.getLoginContext();					boolean debug = this.log.isDebugEnabled();					if (loginContext != null) {						if (debug) {							this.log.debug("Logging principal: [" + token.getPrincipal()									+ "] out of LoginContext");						}						loginContext.logout();					}					else if (debug) {						this.log.debug("Cannot logout principal: [" + token.getPrincipal()								+ "] from LoginContext. "								+ "The LoginContext is unavailable");					}				}				catch (LoginException e) {					this.log.warn("Error error logging out of LoginContext", e);				}			}		}	}
protected void publishFailureEvent(UsernamePasswordAuthenticationToken token,			AuthenticationException ase) {		if (this.applicationEventPublisher != null) {			this.applicationEventPublisher					.publishEvent(new JaasAuthenticationFailedEvent(token, ase));		}	}
public static Runnable create(Runnable delegate, SecurityContext securityContext) {		Assert.notNull(delegate, "delegate cannot be  null");		return securityContext == null ? new DelegatingSecurityContextRunnable(delegate)				: new DelegatingSecurityContextRunnable(delegate, securityContext);	}
public Collection<ConfigAttribute> getAllConfigAttributes() {		Set<ConfigAttribute> allAttributes = new HashSet<>();		for (Map.Entry<RequestMatcher, Collection<ConfigAttribute>> entry : requestMap				.entrySet()) {			allAttributes.addAll(entry.getValue());		}		return allAttributes;	}
public void setAuthoritiesAsString(List<String> authoritiesAsStrings) {		setAuthorities(new ArrayList<>(authoritiesAsStrings.size()));		for (String authority : authoritiesAsStrings) {			addAuthority(new SimpleGrantedAuthority(authority));		}	}
public static Consumer<HttpHeaders> bearerToken(String bearerTokenValue) {		Assert.hasText(bearerTokenValue, "bearerTokenValue cannot be null");		return headers -> headers.set(HttpHeaders.AUTHORIZATION, "Bearer " + bearerTokenValue);	}
private static String buildProviderUrl(List<String> urls, String baseDn) {		Assert.notNull(baseDn, "The Base DN for the LDAP server must not be null.");		Assert.notEmpty(urls, "At least one LDAP server URL must be provided.");		String trimmedBaseDn = baseDn.trim();		StringBuilder providerUrl = new StringBuilder();		for (String serverUrl : urls) {			String trimmedUrl = serverUrl.trim();			if ("".equals(trimmedUrl)) {				continue;			}			providerUrl.append(trimmedUrl);			if (!trimmedUrl.endsWith("/")) {				providerUrl.append("/");			}			providerUrl.append(trimmedBaseDn);			providerUrl.append(" ");		}		return providerUrl.toString();	}
@Override	protected Collection<? extends GrantedAuthority> loadUserAuthorities(			DirContextOperations userData, String username, String password) {		String[] groups = userData.getStringAttributes("memberOf");		if (groups == null) {			logger.debug("No values for 'memberOf' attribute.");			return AuthorityUtils.NO_AUTHORITIES;		}		if (logger.isDebugEnabled()) {			logger.debug("'memberOf' attribute values: " + Arrays.asList(groups));		}		ArrayList<GrantedAuthority> authorities = new ArrayList<>(				groups.length);		for (String group : groups) {			authorities.add(new SimpleGrantedAuthority(new DistinguishedName(group)					.removeLast().getValue()));		}		return authorities;	}
public void setContextEnvironmentProperties(Map<String, Object> environment) {		Assert.notEmpty(environment, "environment must not be empty");		this.contextEnvironmentProperties = new Hashtable<>(environment);	}
private String getStateParameter(ServerWebExchange exchange) {		Assert.notNull(exchange, "exchange cannot be null");		return exchange.getRequest().getQueryParams().getFirst(OAuth2ParameterNames.STATE);	}
public boolean doesRequestMatch(HttpServletRequest request, PortResolver portResolver) {		if (!propertyEquals("pathInfo", this.pathInfo, request.getPathInfo())) {			return false;		}		if (!propertyEquals("queryString", this.queryString, request.getQueryString())) {			return false;		}		if (!propertyEquals("requestURI", this.requestURI, request.getRequestURI())) {			return false;		}		if (!"GET".equals(request.getMethod()) && "GET".equals(method)) {			// A save GET should not match an incoming non-GET method			return false;		}		if (!propertyEquals("serverPort", Integer.valueOf(this.serverPort),				Integer.valueOf(portResolver.getServerPort(request)))) {			return false;		}		if (!propertyEquals("requestURL", this.requestURL, request.getRequestURL()				.toString())) {			return false;		}		if (!propertyEquals("scheme", this.scheme, request.getScheme())) {			return false;		}		if (!propertyEquals("serverName", this.serverName, request.getServerName())) {			return false;		}		if (!propertyEquals("contextPath", this.contextPath, request.getContextPath())) {			return false;		}		return propertyEquals("servletPath", this.servletPath, request.getServletPath());	}
@Override	public String getRedirectUrl() {		return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI,				queryString);	}
public void setClaimSetConverter(Converter<Map<String, Object>, Map<String, Object>> claimSetConverter) {		Assert.notNull(claimSetConverter, "claimSetConverter cannot be null");		this.claimSetConverter = claimSetConverter;	}
public final void setRequestEntityConverter(Converter<OAuth2UserRequest, RequestEntity<?>> requestEntityConverter) {		Assert.notNull(requestEntityConverter, "requestEntityConverter cannot be null");		this.requestEntityConverter = requestEntityConverter;	}
public Object resolveArgument(MethodParameter parameter,			ModelAndViewContainer mavContainer, NativeWebRequest webRequest,			WebDataBinderFactory binderFactory) throws Exception {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (authentication == null) {			return null;		}		Object principal = authentication.getPrincipal();		if (principal != null				&& !parameter.getParameterType().isAssignableFrom(principal.getClass())) {			AuthenticationPrincipal authPrincipal = findMethodAnnotation(					AuthenticationPrincipal.class, parameter);			if (authPrincipal.errorOnInvalidType()) {				throw new ClassCastException(principal + " is not assignable to "						+ parameter.getParameterType());			}			else {				return null;			}		}		return principal;	}
public static JwtDecoder fromOidcIssuerLocation(String oidcIssuerLocation) {		Map<String, Object> openidConfiguration = getOpenidConfiguration(oidcIssuerLocation);		String metadataIssuer = "(unavailable)";		if (openidConfiguration.containsKey("issuer")) {			metadataIssuer = openidConfiguration.get("issuer").toString();		}		if (!oidcIssuerLocation.equals(metadataIssuer)) {			throw new IllegalStateException("The Issuer \"" + metadataIssuer + "\" provided in the OpenID Configuration " +					"did not match the requested issuer \"" + oidcIssuerLocation + "\"");		}		OAuth2TokenValidator<Jwt> jwtValidator =				JwtValidators.createDefaultWithIssuer(oidcIssuerLocation);		NimbusJwtDecoder jwtDecoder = withJwkSetUri(openidConfiguration.get("jwks_uri").toString()).build();		jwtDecoder.setJwtValidator(jwtValidator);		return jwtDecoder;	}
@SuppressWarnings({ "unchecked" })	@Override	public BeanDefinition parse(Element element, ParserContext pc) {		CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(				element.getTagName(), pc.extractSource(element));		pc.pushContainingComponent(compositeDef);		registerFilterChainProxyIfNecessary(pc, pc.extractSource(element));		// Obtain the filter chains and add the new chain to it		BeanDefinition listFactoryBean = pc.getRegistry().getBeanDefinition(				BeanIds.FILTER_CHAINS);		List<BeanReference> filterChains = (List<BeanReference>) listFactoryBean				.getPropertyValues().getPropertyValue("sourceList").getValue();		filterChains.add(createFilterChain(element, pc));		pc.popAndRegisterContainingComponent();		return null;	}
private BeanReference createFilterChain(Element element, ParserContext pc) {		boolean secured = !OPT_SECURITY_NONE.equals(element.getAttribute(ATT_SECURED));		if (!secured) {			if (!StringUtils.hasText(element.getAttribute(ATT_PATH_PATTERN))					&& !StringUtils.hasText(ATT_REQUEST_MATCHER_REF)) {				pc.getReaderContext().error(						"The '" + ATT_SECURED								+ "' attribute must be used in combination with"								+ " the '" + ATT_PATH_PATTERN + "' or '"								+ ATT_REQUEST_MATCHER_REF + "' attributes.",						pc.extractSource(element));			}			for (int n = 0; n < element.getChildNodes().getLength(); n++) {				if (element.getChildNodes().item(n) instanceof Element) {					pc.getReaderContext().error(							"If you are using <http> to define an unsecured pattern, "									+ "it cannot contain child elements.",							pc.extractSource(element));				}			}			return createSecurityFilterChainBean(element, pc, Collections.emptyList());		}		final BeanReference portMapper = createPortMapper(element, pc);		final BeanReference portResolver = createPortResolver(portMapper, pc);		ManagedList<BeanReference> authenticationProviders = new ManagedList<>();		BeanReference authenticationManager = createAuthenticationManager(element, pc,				authenticationProviders);		boolean forceAutoConfig = isDefaultHttpConfig(element);		HttpConfigurationBuilder httpBldr = new HttpConfigurationBuilder(element,				forceAutoConfig, pc, portMapper, portResolver, authenticationManager);		AuthenticationConfigBuilder authBldr = new AuthenticationConfigBuilder(element,				forceAutoConfig, pc, httpBldr.getSessionCreationPolicy(),				httpBldr.getRequestCache(), authenticationManager,				httpBldr.getSessionStrategy(), portMapper, portResolver,				httpBldr.getCsrfLogoutHandler());		httpBldr.setLogoutHandlers(authBldr.getLogoutHandlers());		httpBldr.setEntryPoint(authBldr.getEntryPointBean());		httpBldr.setAccessDeniedHandler(authBldr.getAccessDeniedHandlerBean());		authenticationProviders.addAll(authBldr.getProviders());		List<OrderDecorator> unorderedFilterChain = new ArrayList<>();		unorderedFilterChain.addAll(httpBldr.getFilters());		unorderedFilterChain.addAll(authBldr.getFilters());		unorderedFilterChain.addAll(buildCustomFilterList(element, pc));		Collections.sort(unorderedFilterChain, new OrderComparator());		checkFilterChainOrder(unorderedFilterChain, pc, pc.extractSource(element));		// The list of filter beans		List<BeanMetadataElement> filterChain = new ManagedList<>();		for (OrderDecorator od : unorderedFilterChain) {			filterChain.add(od.bean);		}		return createSecurityFilterChainBean(element, pc, filterChain);	}
private BeanReference createAuthenticationManager(Element element, ParserContext pc,			ManagedList<BeanReference> authenticationProviders) {		String parentMgrRef = element.getAttribute(ATT_AUTHENTICATION_MANAGER_REF);		BeanDefinitionBuilder authManager = BeanDefinitionBuilder				.rootBeanDefinition(ProviderManager.class);		authManager.addConstructorArgValue(authenticationProviders);		if (StringUtils.hasText(parentMgrRef)) {			RuntimeBeanReference parentAuthManager = new RuntimeBeanReference(					parentMgrRef);			authManager.addConstructorArgValue(parentAuthManager);			RootBeanDefinition clearCredentials = new RootBeanDefinition(					ClearCredentialsMethodInvokingFactoryBean.class);			clearCredentials.getPropertyValues().addPropertyValue("targetObject",					parentAuthManager);			clearCredentials.getPropertyValues().addPropertyValue("targetMethod",					"isEraseCredentialsAfterAuthentication");			authManager.addPropertyValue("eraseCredentialsAfterAuthentication",					clearCredentials);		}		else {			RootBeanDefinition amfb = new RootBeanDefinition(					AuthenticationManagerFactoryBean.class);			amfb.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);			String amfbId = pc.getReaderContext().generateBeanName(amfb);			pc.registerBeanComponent(new BeanComponentDefinition(amfb, amfbId));			RootBeanDefinition clearCredentials = new RootBeanDefinition(					MethodInvokingFactoryBean.class);			clearCredentials.getPropertyValues().addPropertyValue("targetObject",					new RuntimeBeanReference(amfbId));			clearCredentials.getPropertyValues().addPropertyValue("targetMethod",					"isEraseCredentialsAfterAuthentication");			authManager.addConstructorArgValue(new RuntimeBeanReference(amfbId));			authManager.addPropertyValue("eraseCredentialsAfterAuthentication",					clearCredentials);		}		authManager.getRawBeanDefinition().setSource(pc.extractSource(element));		BeanDefinition authMgrBean = authManager.getBeanDefinition();		String id = pc.getReaderContext().generateBeanName(authMgrBean);		pc.registerBeanComponent(new BeanComponentDefinition(authMgrBean, id));		return new RuntimeBeanReference(id);	}
@Override	public OAuth2TokenValidatorResult validate(T token) {		Collection<OAuth2Error> errors = new ArrayList<>();		for ( OAuth2TokenValidator<T> validator : this.tokenValidators) {			errors.addAll(validator.validate(token).getErrors());		}		return OAuth2TokenValidatorResult.failure(errors);	}
public int doStartTag() throws JspException {		try {			authorized = super.authorize();			if (!authorized && TagLibConfig.isUiSecurityDisabled()) {				pageContext.getOut().write(TagLibConfig.getSecuredUiPrefix());			}			if (var != null) {				pageContext.setAttribute(var, authorized, PageContext.PAGE_SCOPE);			}			return TagLibConfig.evalOrSkip(authorized);		}		catch (IOException e) {			throw new JspException(e);		}	}
public int doEndTag() throws JspException {		try {			if (!authorized && TagLibConfig.isUiSecurityDisabled()) {				pageContext.getOut().write(TagLibConfig.getSecuredUiSuffix());			}		}		catch (IOException e) {			throw new JspException(e);		}		return EVAL_PAGE;	}
@Override	protected void initUserDetailsService() throws Exception {		for (UserDetailsBuilder userBuilder : userBuilders) {			getUserDetailsService().createUser(userBuilder.build());		}		for (UserDetails userDetails : this.users) {			getUserDetailsService().createUser(userDetails);		}	}
@SuppressWarnings("unchecked")	public final C withUser(User.UserBuilder userBuilder) {		this.users.add(userBuilder.build());		return (C) this;	}
@SuppressWarnings("unchecked")	public final UserDetailsBuilder withUser(String username) {		UserDetailsBuilder userBuilder = new UserDetailsBuilder((C) this);		userBuilder.username(username);		this.userBuilders.add(userBuilder);		return userBuilder;	}
private SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {		http			.authorizeExchange()				.anyExchange().authenticated();		if (isOAuth2Present && OAuth2ClasspathGuard.shouldConfigure(this.context)) {			OAuth2ClasspathGuard.configure(this.context, http);		} else {			http				.httpBasic().and()				.formLogin();		}		SecurityWebFilterChain result = http.build();		return result;	}
static void validateHttpRedirect(String url, ParserContext pc, Object source) {		if (!StringUtils.hasText(url) || UrlUtils.isValidRedirectUrl(url)				|| url.startsWith("$") || url.startsWith("#")) {			return;		}		pc.getReaderContext().warning(				url + " is not a valid redirect URL (must start with '/' or http(s))",				source);	}
static String generateDigest(boolean passwordAlreadyEncoded, String username,			String realm, String password, String httpMethod, String uri, String qop,			String nonce, String nc, String cnonce) throws IllegalArgumentException {		String a1Md5;		String a2 = httpMethod + ":" + uri;		String a2Md5 = md5Hex(a2);		if (passwordAlreadyEncoded) {			a1Md5 = password;		}		else {			a1Md5 = DigestAuthUtils.encodePasswordInA1Format(username, realm, password);		}		String digest;		if (qop == null) {			// as per RFC 2069 compliant clients (also reaffirmed by RFC 2617)			digest = a1Md5 + ":" + nonce + ":" + a2Md5;		}		else if ("auth".equals(qop)) {			// As per RFC 2617 compliant clients			digest = a1Md5 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":"					+ a2Md5;		}		else {			throw new IllegalArgumentException("This method does not support a qop: '"					+ qop + "'");		}		return md5Hex(digest);	}
static Map<String, String> splitEachArrayElementAndCreateMap(String[] array,			String delimiter, String removeCharacters) {		if ((array == null) || (array.length == 0)) {			return null;		}		Map<String, String> map = new HashMap<>();		for (String s : array) {			String postRemove;			if (removeCharacters == null) {				postRemove = s;			}			else {				postRemove = StringUtils.replace(s, removeCharacters, "");			}			String[] splitThisArrayElement = split(postRemove, delimiter);			if (splitThisArrayElement == null) {				continue;			}			map.put(splitThisArrayElement[0].trim(), splitThisArrayElement[1].trim());		}		return map;	}
static String[] split(String toSplit, String delimiter) {		Assert.hasLength(toSplit, "Cannot split a null or empty string");		Assert.hasLength(delimiter,				"Cannot use a null or empty delimiter to split a string");		if (delimiter.length() != 1) {			throw new IllegalArgumentException(					"Delimiter can only be one character in length");		}		int offset = toSplit.indexOf(delimiter);		if (offset < 0) {			return null;		}		String beforeDelimiter = toSplit.substring(0, offset);		String afterDelimiter = toSplit.substring(offset + 1);		return new String[] { beforeDelimiter, afterDelimiter };	}
public void afterPropertiesSet() throws Exception {		Assert.notNull(getSecureObjectClass(),				"Subclass must provide a non-null response to getSecureObjectClass()");		Assert.notNull(this.messages, "A message source must be set");		Assert.notNull(this.authenticationManager, "An AuthenticationManager is required");		Assert.notNull(this.accessDecisionManager, "An AccessDecisionManager is required");		Assert.notNull(this.runAsManager, "A RunAsManager is required");		Assert.notNull(this.obtainSecurityMetadataSource(),				"An SecurityMetadataSource is required");		Assert.isTrue(this.obtainSecurityMetadataSource()				.supports(getSecureObjectClass()),				() -> "SecurityMetadataSource does not support secure object class: "						+ getSecureObjectClass());		Assert.isTrue(this.runAsManager.supports(getSecureObjectClass()),				() -> "RunAsManager does not support secure object class: "						+ getSecureObjectClass());		Assert.isTrue(this.accessDecisionManager.supports(getSecureObjectClass()),				() -> "AccessDecisionManager does not support secure object class: "						+ getSecureObjectClass());		if (this.afterInvocationManager != null) {			Assert.isTrue(this.afterInvocationManager.supports(getSecureObjectClass()),					() -> "AfterInvocationManager does not support secure object class: "							+ getSecureObjectClass());		}		if (this.validateConfigAttributes) {			Collection<ConfigAttribute> attributeDefs = this					.obtainSecurityMetadataSource().getAllConfigAttributes();			if (attributeDefs == null) {				logger.warn("Could not validate configuration attributes as the SecurityMetadataSource did not return "						+ "any attributes from getAllConfigAttributes()");				return;			}			Set<ConfigAttribute> unsupportedAttrs = new HashSet<>();			for (ConfigAttribute attr : attributeDefs) {				if (!this.runAsManager.supports(attr)						&& !this.accessDecisionManager.supports(attr)						&& ((this.afterInvocationManager == null) || !this.afterInvocationManager								.supports(attr))) {					unsupportedAttrs.add(attr);				}			}			if (unsupportedAttrs.size() != 0) {				throw new IllegalArgumentException(						"Unsupported configuration attributes: " + unsupportedAttrs);			}			logger.debug("Validated configuration attributes");		}	}
protected void finallyInvocation(InterceptorStatusToken token) {		if (token != null && token.isContextHolderRefreshRequired()) {			if (logger.isDebugEnabled()) {				logger.debug("Reverting to original Authentication: "						+ token.getSecurityContext().getAuthentication());			}			SecurityContextHolder.setContext(token.getSecurityContext());		}	}
protected Object afterInvocation(InterceptorStatusToken token, Object returnedObject) {		if (token == null) {			// public object			return returnedObject;		}		finallyInvocation(token); // continue to clean in this method for passivity		if (afterInvocationManager != null) {			// Attempt after invocation handling			try {				returnedObject = afterInvocationManager.decide(token.getSecurityContext()						.getAuthentication(), token.getSecureObject(), token						.getAttributes(), returnedObject);			}			catch (AccessDeniedException accessDeniedException) {				AuthorizationFailureEvent event = new AuthorizationFailureEvent(						token.getSecureObject(), token.getAttributes(), token								.getSecurityContext().getAuthentication(),						accessDeniedException);				publishEvent(event);				throw accessDeniedException;			}		}		return returnedObject;	}
private Authentication authenticateIfRequired() {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (authentication.isAuthenticated() && !alwaysReauthenticate) {			if (logger.isDebugEnabled()) {				logger.debug("Previously Authenticated: " + authentication);			}			return authentication;		}		authentication = authenticationManager.authenticate(authentication);		// We don't authenticated.setAuthentication(true), because each provider should do		// that		if (logger.isDebugEnabled()) {			logger.debug("Successfully Authenticated: " + authentication);		}		SecurityContextHolder.getContext().setAuthentication(authentication);		return authentication;	}
private void credentialsNotFound(String reason, Object secureObject,			Collection<ConfigAttribute> configAttribs) {		AuthenticationCredentialsNotFoundException exception = new AuthenticationCredentialsNotFoundException(				reason);		AuthenticationCredentialsNotFoundEvent event = new AuthenticationCredentialsNotFoundEvent(				secureObject, configAttribs, exception);		publishEvent(event);		throw exception;	}
private UserDetailsService getUserDetailsService() {		Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class);		if (beans.size() == 0) {			beans = getBeansOfType(UserDetailsService.class);		}		if (beans.size() == 0) {			throw new ApplicationContextException("No UserDetailsService registered.");		}		else if (beans.size() > 1) {			throw new ApplicationContextException(					"More than one UserDetailsService registered. Please "							+ "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.");		}		return (UserDetailsService) beans.values().toArray()[0];	}
private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) {		String codeVerifier = this.codeVerifierGenerator.generateKey();		attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier);		try {			String codeChallenge = createCodeChallenge(codeVerifier);			additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge);			additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, "S256");		} catch (NoSuchAlgorithmException e) {			additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier);		}	}
@Override	protected final void successfulAuthentication(HttpServletRequest request,			HttpServletResponse response, FilterChain chain, Authentication authResult)			throws IOException, ServletException {		boolean continueFilterChain = proxyTicketRequest(				serviceTicketRequest(request, response), request);		if (!continueFilterChain) {			super.successfulAuthentication(request, response, chain, authResult);			return;		}		if (logger.isDebugEnabled()) {			logger.debug("Authentication success. Updating SecurityContextHolder to contain: "					+ authResult);		}		SecurityContextHolder.getContext().setAuthentication(authResult);		// Fire event		if (this.eventPublisher != null) {			eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(					authResult, this.getClass()));		}		chain.doFilter(request, response);	}
protected boolean requiresAuthentication(final HttpServletRequest request,			final HttpServletResponse response) {		final boolean serviceTicketRequest = serviceTicketRequest(request, response);		final boolean result = serviceTicketRequest || proxyReceptorRequest(request)				|| (proxyTicketRequest(serviceTicketRequest, request));		if (logger.isDebugEnabled()) {			logger.debug("requiresAuthentication = " + result);		}		return result;	}
private boolean serviceTicketRequest(final HttpServletRequest request,			final HttpServletResponse response) {		boolean result = super.requiresAuthentication(request, response);		if (logger.isDebugEnabled()) {			logger.debug("serviceTicketRequest = " + result);		}		return result;	}
private boolean proxyTicketRequest(final boolean serviceTicketRequest,			final HttpServletRequest request) {		if (serviceTicketRequest) {			return false;		}		final boolean result = authenticateAllArtifacts				&& obtainArtifact(request) != null && !authenticated();		if (logger.isDebugEnabled()) {			logger.debug("proxyTicketRequest = " + result);		}		return result;	}
private boolean authenticated() {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		return authentication != null && authentication.isAuthenticated()				&& !(authentication instanceof AnonymousAuthenticationToken);	}
private boolean proxyReceptorRequest(final HttpServletRequest request) {		final boolean result = proxyReceptorConfigured()				&& proxyReceptorMatcher.matches(request);		if (logger.isDebugEnabled()) {			logger.debug("proxyReceptorRequest = " + result);		}		return result;	}
private boolean proxyReceptorConfigured() {		final boolean result = this.proxyGrantingTicketStorage != null				&& proxyReceptorMatcher != null;		if (logger.isDebugEnabled()) {			logger.debug("proxyReceptorConfigured = " + result);		}		return result;	}
protected List<UserDetails> loadUsersByUsername(String username) {		return getJdbcTemplate().query(getUsersByUsernameQuery(), new String[]{username},				(rs, rowNum) -> {					String userName = rs.getString(1);					String password = rs.getString(2);					boolean enabled = rs.getBoolean(3);					boolean accLocked = false;					boolean accExpired = false;					boolean credsExpired = false;					if (rs.getMetaData().getColumnCount() > 3) {						//NOTE: acc_locked, acc_expired and creds_expired are also to be loaded						accLocked = rs.getBoolean(4);						accExpired = rs.getBoolean(5);						credsExpired = rs.getBoolean(6);					}					return new User(userName, password, enabled, !accExpired, !credsExpired, !accLocked,							AuthorityUtils.NO_AUTHORITIES);				});	}
public static WebApplicationContext findRequiredWebApplicationContext(ServletContext servletContext) {		WebApplicationContext wac = _findWebApplicationContext(servletContext);		if (wac == null) {			throw new IllegalStateException("No WebApplicationContext found: no ContextLoaderListener registered?");		}		return wac;	}
private static WebApplicationContext _findWebApplicationContext(ServletContext sc) {		WebApplicationContext wac = getWebApplicationContext(sc);		if (wac == null) {			Enumeration<String> attrNames = sc.getAttributeNames();			while (attrNames.hasMoreElements()) {				String attrName = attrNames.nextElement();				Object attrValue = sc.getAttribute(attrName);				if (attrValue instanceof WebApplicationContext) {					if (wac != null) {						throw new IllegalStateException("No unique WebApplicationContext found: more than one " +								"DispatcherServlet registered with publishContext=true?");					}					wac = (WebApplicationContext) attrValue;				}			}		}		return wac;	}
public StandardEvaluationContext createEvaluationContextInternal(Authentication auth,			MethodInvocation mi) {		return new MethodSecurityEvaluationContext(auth, mi, getParameterNameDiscoverer());	}
protected MethodSecurityExpressionOperations createSecurityExpressionRoot(			Authentication authentication, MethodInvocation invocation) {		MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot(				authentication);		root.setThis(invocation.getThis());		root.setPermissionEvaluator(getPermissionEvaluator());		root.setTrustResolver(getTrustResolver());		root.setRoleHierarchy(getRoleHierarchy());		root.setDefaultRolePrefix(getDefaultRolePrefix());		return root;	}
@SuppressWarnings("unchecked")	public Object filter(Object filterTarget, Expression filterExpression,			EvaluationContext ctx) {		MethodSecurityExpressionOperations rootObject = (MethodSecurityExpressionOperations) ctx				.getRootObject().getValue();		final boolean debug = logger.isDebugEnabled();		List retainList;		if (debug) {			logger.debug("Filtering with expression: "					+ filterExpression.getExpressionString());		}		if (filterTarget instanceof Collection) {			Collection collection = (Collection) filterTarget;			retainList = new ArrayList(collection.size());			if (debug) {				logger.debug("Filtering collection with " + collection.size()						+ " elements");			}			if (permissionCacheOptimizer != null) {				permissionCacheOptimizer.cachePermissionsFor(						rootObject.getAuthentication(), collection);			}			for (Object filterObject : (Collection) filterTarget) {				rootObject.setFilterObject(filterObject);				if (ExpressionUtils.evaluateAsBoolean(filterExpression, ctx)) {					retainList.add(filterObject);				}			}			if (debug) {				logger.debug("Retaining elements: " + retainList);			}			collection.clear();			collection.addAll(retainList);			return filterTarget;		}		if (filterTarget.getClass().isArray()) {			Object[] array = (Object[]) filterTarget;			retainList = new ArrayList(array.length);			if (debug) {				logger.debug("Filtering array with " + array.length + " elements");			}			if (permissionCacheOptimizer != null) {				permissionCacheOptimizer.cachePermissionsFor(						rootObject.getAuthentication(), Arrays.asList(array));			}			for (Object o : array) {				rootObject.setFilterObject(o);				if (ExpressionUtils.evaluateAsBoolean(filterExpression, ctx)) {					retainList.add(o);				}			}			if (debug) {				logger.debug("Retaining elements: " + retainList);			}			Object[] filtered = (Object[]) Array.newInstance(filterTarget.getClass()					.getComponentType(), retainList.size());			for (int i = 0; i < retainList.size(); i++) {				filtered[i] = retainList.get(i);			}			return filtered;		}		if (filterTarget instanceof Stream) {			final Stream<?> original = (Stream<?>) filterTarget;			return original.filter(filterObject -> {				rootObject.setFilterObject(filterObject);				return ExpressionUtils.evaluateAsBoolean(filterExpression, ctx);			})					.onClose(original::close);		}		throw new IllegalArgumentException(				"Filter target must be a collection, array, or stream type, but was "						+ filterTarget);	}
private Mono<JWKSet> getJWKSet() {		return this.webClient.get()				.uri(this.jwkSetURL)				.retrieve()				.bodyToMono(String.class)				.map(this::parse)				.doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet)))				.cache();	}
protected static String getFirstSpecifiedKeyID(final JWKMatcher jwkMatcher) {		Set<String> keyIDs = jwkMatcher.getKeyIDs();		if (keyIDs == null || keyIDs.isEmpty()) {			return null;		}		for (String id: keyIDs) {			if (id != null) {				return id;			}		}		return null; // No kid in matcher	}
public void sendRedirect(HttpServletRequest request, HttpServletResponse response,			String url) throws IOException {		String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);		redirectUrl = response.encodeRedirectURL(redirectUrl);		if (logger.isDebugEnabled()) {			logger.debug("Redirecting to '" + redirectUrl + "'");		}		response.sendRedirect(redirectUrl);	}
public Authentication authenticate(final Authentication authentication)			throws AuthenticationException {		if (!supports(authentication.getClass())) {			return null;		}		if (authentication instanceof OpenIDAuthenticationToken) {			OpenIDAuthenticationToken response = (OpenIDAuthenticationToken) authentication;			OpenIDAuthenticationStatus status = response.getStatus();			// handle the various possibilities			if (status == OpenIDAuthenticationStatus.SUCCESS) {				// Lookup user details				UserDetails userDetails = this.userDetailsService						.loadUserDetails(response);				return createSuccessfulAuthentication(userDetails, response);			}			else if (status == OpenIDAuthenticationStatus.CANCELLED) {				throw new AuthenticationCancelledException("Log in cancelled");			}			else if (status == OpenIDAuthenticationStatus.ERROR) {				throw new AuthenticationServiceException(						"Error message from server: " + response.getMessage());			}			else if (status == OpenIDAuthenticationStatus.FAILURE) {				throw new BadCredentialsException(						"Log in failed - identity could not be verified");			}			else if (status == OpenIDAuthenticationStatus.SETUP_NEEDED) {				throw new AuthenticationServiceException(						"The server responded setup was needed, which shouldn't happen");			}			else {				throw new AuthenticationServiceException(						"Unrecognized return value " + status.toString());			}		}		return null;	}
protected Authentication createSuccessfulAuthentication(UserDetails userDetails,			OpenIDAuthenticationToken auth) {		return new OpenIDAuthenticationToken(userDetails,				this.authoritiesMapper.mapAuthorities(userDetails.getAuthorities()),				auth.getIdentityUrl(), auth.getAttributes());	}
public int vote(Authentication authentication, Object object,			Collection<ConfigAttribute> definition) {		boolean jsr250AttributeFound = false;		for (ConfigAttribute attribute : definition) {			if (Jsr250SecurityConfig.PERMIT_ALL_ATTRIBUTE.equals(attribute)) {				return ACCESS_GRANTED;			}			if (Jsr250SecurityConfig.DENY_ALL_ATTRIBUTE.equals(attribute)) {				return ACCESS_DENIED;			}			if (supports(attribute)) {				jsr250AttributeFound = true;				// Attempt to find a matching granted authority				for (GrantedAuthority authority : authentication.getAuthorities()) {					if (attribute.getAttribute().equals(authority.getAuthority())) {						return ACCESS_GRANTED;					}				}			}		}		return jsr250AttributeFound ? ACCESS_DENIED : ACCESS_ABSTAIN;	}
@Override	public void afterPropertiesSet() {		super.afterPropertiesSet();		if (consumer == null) {			try {				consumer = new OpenID4JavaConsumer();			}			catch (ConsumerException e) {				throw new IllegalArgumentException("Failed to initialize OpenID", e);			}		}		if (returnToUrlParameters.isEmpty()				&& getRememberMeServices() instanceof AbstractRememberMeServices) {			returnToUrlParameters = new HashSet<>();			returnToUrlParameters					.add(((AbstractRememberMeServices) getRememberMeServices())							.getParameter());		}	}
@Override	public Authentication attemptAuthentication(HttpServletRequest request,			HttpServletResponse response) throws AuthenticationException, IOException {		OpenIDAuthenticationToken token;		String identity = request.getParameter("openid.identity");		if (!StringUtils.hasText(identity)) {			String claimedIdentity = obtainUsername(request);			try {				String returnToUrl = buildReturnToUrl(request);				String realm = lookupRealm(returnToUrl);				String openIdUrl = consumer.beginConsumption(request, claimedIdentity,						returnToUrl, realm);				if (logger.isDebugEnabled()) {					logger.debug("return_to is '" + returnToUrl + "', realm is '" + realm							+ "'");					logger.debug("Redirecting to " + openIdUrl);				}				response.sendRedirect(openIdUrl);				// Indicate to parent class that authentication is continuing.				return null;			}			catch (OpenIDConsumerException e) {				logger.debug("Failed to consume claimedIdentity: " + claimedIdentity, e);				throw new AuthenticationServiceException(						"Unable to process claimed identity '" + claimedIdentity + "'");			}		}		if (logger.isDebugEnabled()) {			logger.debug("Supplied OpenID identity is " + identity);		}		try {			token = consumer.endConsumption(request);		}		catch (OpenIDConsumerException oice) {			throw new AuthenticationServiceException("Consumer error", oice);		}		token.setDetails(authenticationDetailsSource.buildDetails(request));		// delegate to the authentication provider		Authentication authentication = this.getAuthenticationManager().authenticate(				token);		return authentication;	}
protected String buildReturnToUrl(HttpServletRequest request) {		StringBuffer sb = request.getRequestURL();		Iterator<String> iterator = returnToUrlParameters.iterator();		boolean isFirst = true;		while (iterator.hasNext()) {			String name = iterator.next();			// Assume for simplicity that there is only one value			String value = request.getParameter(name);			if (value == null) {				continue;			}			if (isFirst) {				sb.append("?");				isFirst = false;			}			sb.append(utf8UrlEncode(name)).append("=").append(utf8UrlEncode(value));			if (iterator.hasNext()) {				sb.append("&");			}		}		return sb.toString();	}
protected String obtainUsername(HttpServletRequest req) {		String claimedIdentity = req.getParameter(claimedIdentityFieldName);		if (!StringUtils.hasText(claimedIdentity)) {			logger.error("No claimed identity supplied in authentication request");			return "";		}		return claimedIdentity.trim();	}
private String utf8UrlEncode(String value) {		try {			return URLEncoder.encode(value, "UTF-8");		}		catch (UnsupportedEncodingException e) {			Error err = new AssertionError(					"The Java platform guarantees UTF-8 support, but it seemingly is not present.");			err.initCause(e);			throw err;		}	}
public UserDetails getUserFromCache(String username) {		Cache.ValueWrapper element = username != null ? cache.get(username) : null;		if (logger.isDebugEnabled()) {			logger.debug("Cache hit: " + (element != null) + "; username: " + username);		}		if (element == null) {			return null;		}		else {			return (UserDetails) element.get();		}	}
private Authentication getAuthentication() {		Authentication auth = SecurityContextHolder.getContext().getAuthentication();		if (!trustResolver.isAnonymous(auth)) {			return auth;		}		return null;	}
@Override	public String getRemoteUser() {		Authentication auth = getAuthentication();		if ((auth == null) || (auth.getPrincipal() == null)) {			return null;		}		if (auth.getPrincipal() instanceof UserDetails) {			return ((UserDetails) auth.getPrincipal()).getUsername();		}		return auth.getPrincipal().toString();	}
@Override	public Principal getUserPrincipal() {		Authentication auth = getAuthentication();		if ((auth == null) || (auth.getPrincipal() == null)) {			return null;		}		return auth;	}
private LdapAuthoritiesPopulator getLdapAuthoritiesPopulator() {		if (ldapAuthoritiesPopulator != null) {			return ldapAuthoritiesPopulator;		}		DefaultLdapAuthoritiesPopulator defaultAuthoritiesPopulator = new DefaultLdapAuthoritiesPopulator(				contextSource, groupSearchBase);		defaultAuthoritiesPopulator.setGroupRoleAttribute(groupRoleAttribute);		defaultAuthoritiesPopulator.setGroupSearchFilter(groupSearchFilter);		defaultAuthoritiesPopulator.setRolePrefix(this.rolePrefix);		this.ldapAuthoritiesPopulator = defaultAuthoritiesPopulator;		return defaultAuthoritiesPopulator;	}
protected GrantedAuthoritiesMapper getAuthoritiesMapper() throws Exception {		if (authoritiesMapper != null) {			return authoritiesMapper;		}		SimpleAuthorityMapper simpleAuthorityMapper = new SimpleAuthorityMapper();		simpleAuthorityMapper.setPrefix(this.rolePrefix);		simpleAuthorityMapper.afterPropertiesSet();		this.authoritiesMapper = simpleAuthorityMapper;		return simpleAuthorityMapper;	}
private LdapAuthenticator createLdapAuthenticator(			BaseLdapPathContextSource contextSource) {		AbstractLdapAuthenticator ldapAuthenticator = passwordEncoder == null ? createBindAuthenticator(contextSource)				: createPasswordCompareAuthenticator(contextSource);		LdapUserSearch userSearch = createUserSearch();		if (userSearch != null) {			ldapAuthenticator.setUserSearch(userSearch);		}		if (userDnPatterns != null && userDnPatterns.length > 0) {			ldapAuthenticator.setUserDnPatterns(userDnPatterns);		}		return postProcess(ldapAuthenticator);	}
private PasswordComparisonAuthenticator createPasswordCompareAuthenticator(			BaseLdapPathContextSource contextSource) {		PasswordComparisonAuthenticator ldapAuthenticator = new PasswordComparisonAuthenticator(				contextSource);		if (passwordAttribute != null) {			ldapAuthenticator.setPasswordAttributeName(passwordAttribute);		}		ldapAuthenticator.setPasswordEncoder(passwordEncoder);		return ldapAuthenticator;	}
public LdapAuthenticationProviderConfigurer<B> passwordEncoder(			final org.springframework.security.crypto.password.PasswordEncoder passwordEncoder) {		Assert.notNull(passwordEncoder, "passwordEncoder must not be null.");		this.passwordEncoder = passwordEncoder;		return this;	}
public void setRequestEntityConverter(Converter<OAuth2ClientCredentialsGrantRequest, RequestEntity<?>> requestEntityConverter) {		Assert.notNull(requestEntityConverter, "requestEntityConverter cannot be null");		this.requestEntityConverter = requestEntityConverter;	}
@Override	public Mono<Void> onLogoutSuccess(WebFilterExchange exchange, Authentication authentication) {		return Mono.just(authentication)				.filter(OAuth2AuthenticationToken.class::isInstance)				.filter(token -> authentication.getPrincipal() instanceof OidcUser)				.map(OAuth2AuthenticationToken.class::cast)				.flatMap(this::endSessionEndpoint)				.map(endSessionEndpoint -> endpointUri(endSessionEndpoint, authentication))				.switchIfEmpty(this.serverLogoutSuccessHandler						.onLogoutSuccess(exchange, authentication).then(Mono.empty()))				.flatMap(endpointUri -> this.redirectStrategy.sendRedirect(exchange.getExchange(), endpointUri));	}
public void commence(HttpServletRequest request, HttpServletResponse response)			throws IOException, ServletException {		String queryString = request.getQueryString();		String redirectUrl = request.getRequestURI()				+ ((queryString == null) ? "" : ("?" + queryString));		Integer currentPort = Integer.valueOf(portResolver.getServerPort(request));		Integer redirectPort = getMappedPort(currentPort);		if (redirectPort != null) {			boolean includePort = redirectPort.intValue() != standardPort;			redirectUrl = scheme + request.getServerName()					+ ((includePort) ? (":" + redirectPort) : "") + redirectUrl;		}		if (logger.isDebugEnabled()) {			logger.debug("Redirecting to: " + redirectUrl);		}		redirectStrategy.sendRedirect(request, response, redirectUrl);	}
public final void setTokenResponseConverter(Converter<Map<String, String>, OAuth2AccessTokenResponse> tokenResponseConverter) {		Assert.notNull(tokenResponseConverter, "tokenResponseConverter cannot be null");		this.tokenResponseConverter = tokenResponseConverter;	}
public final void setTokenResponseParametersConverter(Converter<OAuth2AccessTokenResponse, Map<String, String>> tokenResponseParametersConverter) {		Assert.notNull(tokenResponseParametersConverter, "tokenResponseParametersConverter cannot be null");		this.tokenResponseParametersConverter = tokenResponseParametersConverter;	}
private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() {		List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser();		Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper				.getGrantedAuthorities(webSphereGroups);		if (logger.isDebugEnabled()) {			logger.debug("WebSphere groups: " + webSphereGroups					+ " mapped to Granted Authorities: " + userGas);		}		return userGas;	}
public Control getControlInstance(Control ctl) {		if (ctl.getID().equals(PasswordPolicyControl.OID)) {			return new PasswordPolicyResponseControl(ctl.getEncodedValue());		}		return null;	}
public void afterPropertiesSet() throws Exception {		Assert.notNull(this.authenticationUserDetailsService,				"An authenticationUserDetailsService must be set");		Assert.notNull(this.ticketValidator, "A ticketValidator must be set");		Assert.notNull(this.statelessTicketCache, "A statelessTicketCache must be set");		Assert.hasText(				this.key,				"A Key is required so CasAuthenticationProvider can identify tokens it previously authenticated");		Assert.notNull(this.messages, "A message source must be set");	}
private String getServiceUrl(Authentication authentication) {		String serviceUrl;		if (authentication.getDetails() instanceof ServiceAuthenticationDetails) {			serviceUrl = ((ServiceAuthenticationDetails) authentication.getDetails())					.getServiceUrl();		}		else if (serviceProperties == null) {			throw new IllegalStateException(					"serviceProperties cannot be null unless Authentication.getDetails() implements ServiceAuthenticationDetails.");		}		else if (serviceProperties.getService() == null) {			throw new IllegalStateException(					"serviceProperties.getService() cannot be null unless Authentication.getDetails() implements ServiceAuthenticationDetails.");		}		else {			serviceUrl = serviceProperties.getService();		}		if (logger.isDebugEnabled()) {			logger.debug("serviceUrl = " + serviceUrl);		}		return serviceUrl;	}
protected UserDetails loadUserByAssertion(final Assertion assertion) {		final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken(				assertion, "");		return this.authenticationUserDetailsService.loadUserDetails(token);	}
public OAuth2ClientConfigurer<B> clientRegistrationRepository(ClientRegistrationRepository clientRegistrationRepository) {		Assert.notNull(clientRegistrationRepository, "clientRegistrationRepository cannot be null");		this.getBuilder().setSharedObject(ClientRegistrationRepository.class, clientRegistrationRepository);		return this;	}
public OAuth2ClientConfigurer<B> authorizedClientRepository(OAuth2AuthorizedClientRepository authorizedClientRepository) {		Assert.notNull(authorizedClientRepository, "authorizedClientRepository cannot be null");		this.getBuilder().setSharedObject(OAuth2AuthorizedClientRepository.class, authorizedClientRepository);		return this;	}
public OAuth2ClientConfigurer<B> authorizedClientService(OAuth2AuthorizedClientService authorizedClientService) {		Assert.notNull(authorizedClientService, "authorizedClientService cannot be null");		this.authorizedClientRepository(new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService));		return this;	}
private String getUrl() {		MockWebServer mockWebServer = getSource();		if (!this.started) {			intializeMockWebServer(mockWebServer);		}		String url = mockWebServer.url("").url().toExternalForm();		return url.substring(0, url.length() - 1);	}
protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {		Object principal = wasHelper.getCurrentUserName();		if (logger.isDebugEnabled()) {			logger.debug("PreAuthenticated WebSphere principal: " + principal);		}		return principal;	}
public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {		UserDetails user = registeredUsers.get(id);		if (user == null) {			throw new UsernameNotFoundException(id);		}		return user;	}
public UserDetails loadUserDetails(OpenIDAuthenticationToken token) {		String id = token.getIdentityUrl();		CustomUserDetails user = registeredUsers.get(id);		if (user != null) {			return user;		}		String email = null;		String firstName = null;		String lastName = null;		String fullName = null;		List<OpenIDAttribute> attributes = token.getAttributes();		for (OpenIDAttribute attribute : attributes) {			if (attribute.getName().equals("email")) {				email = attribute.getValues().get(0);			}			if (attribute.getName().equals("firstname")) {				firstName = attribute.getValues().get(0);			}			if (attribute.getName().equals("lastname")) {				lastName = attribute.getValues().get(0);			}			if (attribute.getName().equals("fullname")) {				fullName = attribute.getValues().get(0);			}		}		if (fullName == null) {			StringBuilder fullNameBldr = new StringBuilder();			if (firstName != null) {				fullNameBldr.append(firstName);			}			if (lastName != null) {				fullNameBldr.append(" ").append(lastName);			}			fullName = fullNameBldr.toString();		}		user = new CustomUserDetails(id, DEFAULT_AUTHORITIES);		user.setEmail(email);		user.setName(fullName);		registeredUsers.put(id, user);		user = new CustomUserDetails(id, DEFAULT_AUTHORITIES);		user.setEmail(email);		user.setName(fullName);		user.setNewUser(true);		return user;	}
public Consumer<WebClient.RequestHeadersSpec<?>> defaultRequest() {		return spec -> {			spec.attributes(attrs -> {				populateDefaultRequestResponse(attrs);				populateDefaultAuthentication(attrs);				populateDefaultOAuth2AuthorizedClient(attrs);			});		};	}
public static Consumer<Map<String, Object>> oauth2AuthorizedClient(OAuth2AuthorizedClient authorizedClient) {		return attributes -> {			if (authorizedClient == null) {				attributes.remove(OAUTH2_AUTHORIZED_CLIENT_ATTR_NAME);			} else {				attributes.put(OAUTH2_AUTHORIZED_CLIENT_ATTR_NAME, authorizedClient);			}		};	}
public static Consumer<Map<String, Object>> clientRegistrationId(String clientRegistrationId) {		return attributes -> attributes.put(CLIENT_REGISTRATION_ID_ATTR_NAME, clientRegistrationId);	}
public static Consumer<Map<String, Object>> authentication(Authentication authentication) {		return attributes -> attributes.put(AUTHENTICATION_ATTR_NAME, authentication);	}
public static Consumer<Map<String, Object>> httpServletRequest(HttpServletRequest request) {		return attributes -> attributes.put(HTTP_SERVLET_REQUEST_ATTR_NAME, request);	}
public static Consumer<Map<String, Object>> httpServletResponse(HttpServletResponse response) {		return attributes -> attributes.put(HTTP_SERVLET_RESPONSE_ATTR_NAME, response);	}
public boolean hasPermission(Authentication authentication, Object domainObject,			Object permission) {		if (domainObject == null) {			return false;		}		ObjectIdentity objectIdentity = objectIdentityRetrievalStrategy				.getObjectIdentity(domainObject);		return checkPermission(authentication, objectIdentity, permission);	}
@Override	protected UserDetails processAutoLoginCookie(String[] cookieTokens,			HttpServletRequest request, HttpServletResponse response) {		if (cookieTokens.length != 3) {			throw new InvalidCookieException("Cookie token did not contain 3"					+ " tokens, but contained '" + Arrays.asList(cookieTokens) + "'");		}		long tokenExpiryTime;		try {			tokenExpiryTime = new Long(cookieTokens[1]).longValue();		}		catch (NumberFormatException nfe) {			throw new InvalidCookieException(					"Cookie token[1] did not contain a valid number (contained '"							+ cookieTokens[1] + "')");		}		if (isTokenExpired(tokenExpiryTime)) {			throw new InvalidCookieException("Cookie token[1] has expired (expired on '"					+ new Date(tokenExpiryTime) + "'; current time is '" + new Date()					+ "')");		}		// Check the user exists.		// Defer lookup until after expiry time checked, to possibly avoid expensive		// database call.		UserDetails userDetails = getUserDetailsService().loadUserByUsername(				cookieTokens[0]);		// Check signature of token matches remaining details.		// Must do this after user lookup, as we need the DAO-derived password.		// If efficiency was a major issue, just add in a UserCache implementation,		// but recall that this method is usually only called once per HttpSession - if		// the token is valid,		// it will cause SecurityContextHolder population, whilst if invalid, will cause		// the cookie to be cancelled.		String expectedTokenSignature = makeTokenSignature(tokenExpiryTime,				userDetails.getUsername(), userDetails.getPassword());		if (!equals(expectedTokenSignature, cookieTokens[2])) {			throw new InvalidCookieException("Cookie token[2] contained signature '"					+ cookieTokens[2] + "' but expected '" + expectedTokenSignature + "'");		}		return userDetails;	}
protected String makeTokenSignature(long tokenExpiryTime, String username,			String password) {		String data = username + ":" + tokenExpiryTime + ":" + password + ":" + getKey();		MessageDigest digest;		try {			digest = MessageDigest.getInstance("MD5");		}		catch (NoSuchAlgorithmException e) {			throw new IllegalStateException("No MD5 algorithm available!");		}		return new String(Hex.encode(digest.digest(data.getBytes())));	}
public static byte[] concatenate(byte[]... arrays) {		int length = 0;		for (byte[] array : arrays) {			length += array.length;		}		byte[] newArray = new byte[length];		int destPos = 0;		for (byte[] array : arrays) {			System.arraycopy(array, 0, newArray, destPos, array.length);			destPos += array.length;		}		return newArray;	}
public static byte[] subArray(byte[] array, int beginIndex, int endIndex) {		int length = endIndex - beginIndex;		byte[] subarray = new byte[length];		System.arraycopy(array, beginIndex, subarray, 0, length);		return subarray;	}
public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) {		ArrayList<GrantedAuthority> gaList = new ArrayList<>();		for (String attribute : attributes) {			Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap					.get(attribute);			if (c != null) {				gaList.addAll(c);			}		}		gaList.trimToSize();		return gaList;	}
private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) {		Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>(				orgMap.size());		for (Map.Entry<?, ?> entry : orgMap.entrySet()) {			Assert.isInstanceOf(String.class, entry.getKey(),					"attributes2grantedAuthoritiesMap contains non-String objects as keys");			result.put((String) entry.getKey(),					getGrantedAuthorityCollection(entry.getValue()));		}		return result;	}
private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) {		Collection<GrantedAuthority> result = new ArrayList<>();		addGrantedAuthorityCollection(result, value);		return result;	}
private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result,			Object value) {		if (value == null) {			return;		}		if (value instanceof Collection<?>) {			addGrantedAuthorityCollection(result, (Collection<?>) value);		}		else if (value instanceof Object[]) {			addGrantedAuthorityCollection(result, (Object[]) value);		}		else if (value instanceof String) {			addGrantedAuthorityCollection(result, (String) value);		}		else if (value instanceof GrantedAuthority) {			result.add((GrantedAuthority) value);		}		else {			throw new IllegalArgumentException("Invalid object type: "					+ value.getClass().getName());		}	}
protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {		Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest				.getUserPrincipal().getName();		if (logger.isDebugEnabled()) {			logger.debug("PreAuthenticated J2EE principal: " + principal);		}		return principal;	}
public O getOrBuild() {		if (isUnbuilt()) {			try {				return build();			}			catch (Exception e) {				logger.debug("Failed to perform build. Returning null", e);				return null;			}		}		else {			return getObject();		}	}
@SuppressWarnings("unchecked")	public <C extends SecurityConfigurerAdapter<O, B>> C apply(C configurer)			throws Exception {		configurer.addObjectPostProcessor(objectPostProcessor);		configurer.setBuilder((B) this);		add(configurer);		return configurer;	}
public <C extends SecurityConfigurer<O, B>> C apply(C configurer) throws Exception {		add(configurer);		return configurer;	}
@SuppressWarnings("unchecked")	public <C> void setSharedObject(Class<C> sharedType, C object) {		this.sharedObjects.put(sharedType, object);	}
@SuppressWarnings("unchecked")	public <C> C getSharedObject(Class<C> sharedType) {		return (C) this.sharedObjects.get(sharedType);	}
@SuppressWarnings("unchecked")	private <C extends SecurityConfigurer<O, B>> void add(C configurer) throws Exception {		Assert.notNull(configurer, "configurer cannot be null");		Class<? extends SecurityConfigurer<O, B>> clazz = (Class<? extends SecurityConfigurer<O, B>>) configurer				.getClass();		synchronized (configurers) {			if (buildState.isConfigured()) {				throw new IllegalStateException("Cannot apply " + configurer						+ " to already built object");			}			List<SecurityConfigurer<O, B>> configs = allowConfigurersOfSameType ? this.configurers					.get(clazz) : null;			if (configs == null) {				configs = new ArrayList<SecurityConfigurer<O, B>>(1);			}			configs.add(configurer);			this.configurers.put(clazz, configs);			if (buildState.isInitializing()) {				this.configurersAddedInInitializing.add(configurer);			}		}	}
@SuppressWarnings("unchecked")	public <C extends SecurityConfigurer<O, B>> List<C> getConfigurers(Class<C> clazz) {		List<C> configs = (List<C>) this.configurers.get(clazz);		if (configs == null) {			return new ArrayList<>();		}		return new ArrayList<>(configs);	}
@SuppressWarnings("unchecked")	public <C extends SecurityConfigurer<O, B>> List<C> removeConfigurers(Class<C> clazz) {		List<C> configs = (List<C>) this.configurers.remove(clazz);		if (configs == null) {			return new ArrayList<>();		}		return new ArrayList<>(configs);	}
@SuppressWarnings("unchecked")	public <C extends SecurityConfigurer<O, B>> C removeConfigurer(Class<C> clazz) {		List<SecurityConfigurer<O, B>> configs = this.configurers.remove(clazz);		if (configs == null) {			return null;		}		if (configs.size() != 1) {			throw new IllegalStateException("Only one configurer expected for type "					+ clazz + ", but got " + configs);		}		return (C) configs.get(0);	}
@SuppressWarnings("unchecked")	public O objectPostProcessor(ObjectPostProcessor<Object> objectPostProcessor) {		Assert.notNull(objectPostProcessor, "objectPostProcessor cannot be null");		this.objectPostProcessor = objectPostProcessor;		return (O) this;	}
@Override	protected final O doBuild() throws Exception {		synchronized (configurers) {			buildState = BuildState.INITIALIZING;			beforeInit();			init();			buildState = BuildState.CONFIGURING;			beforeConfigure();			configure();			buildState = BuildState.BUILDING;			O result = performBuild();			buildState = BuildState.BUILT;			return result;		}	}
protected Object getDomainObjectInstance(MethodInvocation invocation) {		Object[] args;		Class<?>[] params;		params = invocation.getMethod().getParameterTypes();		args = invocation.getArguments();		for (int i = 0; i < params.length; i++) {			if (processDomainObjectClass.isAssignableFrom(params[i])) {				return args[i];			}		}		throw new AuthorizationServiceException("MethodInvocation: " + invocation				+ " did not provide any argument of type: " + processDomainObjectClass);	}
public void afterPropertiesSet() throws Exception {		Assert.isTrue(				StringUtils.hasText(loginFormUrl)						&& UrlUtils.isValidRedirectUrl(loginFormUrl),				"loginFormUrl must be specified and must be a valid redirect URL");		if (useForward && UrlUtils.isAbsoluteUrl(loginFormUrl)) {			throw new IllegalArgumentException(					"useForward must be false if using an absolute loginFormURL");		}		Assert.notNull(portMapper, "portMapper must be specified");		Assert.notNull(portResolver, "portResolver must be specified");	}
public void commence(HttpServletRequest request, HttpServletResponse response,			AuthenticationException authException) throws IOException, ServletException {		String redirectUrl = null;		if (useForward) {			if (forceHttps && "http".equals(request.getScheme())) {				// First redirect the current request to HTTPS.				// When that request is received, the forward to the login page will be				// used.				redirectUrl = buildHttpsRedirectUrlForRequest(request);			}			if (redirectUrl == null) {				String loginForm = determineUrlToUseForThisRequest(request, response,						authException);				if (logger.isDebugEnabled()) {					logger.debug("Server side forward to: " + loginForm);				}				RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);				dispatcher.forward(request, response);				return;			}		}		else {			// redirect to login page. Use https if forceHttps true			redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);		}		redirectStrategy.sendRedirect(request, response, redirectUrl);	}
protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request)			throws IOException, ServletException {		int serverPort = portResolver.getServerPort(request);		Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort));		if (httpsPort != null) {			RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder();			urlBuilder.setScheme("https");			urlBuilder.setServerName(request.getServerName());			urlBuilder.setPort(httpsPort.intValue());			urlBuilder.setContextPath(request.getContextPath());			urlBuilder.setServletPath(request.getServletPath());			urlBuilder.setPathInfo(request.getPathInfo());			urlBuilder.setQuery(request.getQueryString());			return urlBuilder.getUrl();		}		// Fall through to server-side forward with warning message		logger.warn("Unable to redirect to HTTPS as no port mapping found for HTTP port "				+ serverPort);		return null;	}
public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) {		InterceptorStatusToken token = super				.beforeInvocation(new MethodInvocationAdapter(jp));		Object result;		try {			result = advisorProceed.proceedWithObject();		}		finally {			super.finallyInvocation(token);		}		return super.afterInvocation(token, result);	}
@Override	@SuppressWarnings("rawtypes")	final List<AccessDecisionVoter<? extends Object>> getDecisionVoters(H http) {		List<AccessDecisionVoter<? extends Object>> decisionVoters = new ArrayList<AccessDecisionVoter<? extends Object>>();		decisionVoters.add(new RoleVoter());		decisionVoters.add(new AuthenticatedVoter());		return decisionVoters;	}
private static String hasRole(String role) {		Assert.isTrue(				!role.startsWith("ROLE_"),				() -> role						+ " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.");		return "ROLE_" + role;	}
private static String[] hasAnyRole(String... roles) {		for (int i = 0; i < roles.length; i++) {			roles[i] = "ROLE_" + roles[i];		}		return roles;	}
public void setSubjectDnRegex(String subjectDnRegex) {		Assert.hasText(subjectDnRegex, "Regular expression may not be null or empty");		subjectDnPattern = Pattern.compile(subjectDnRegex, Pattern.CASE_INSENSITIVE);	}
@Override	public Mono<MatchResult> matches(ServerWebExchange exchange) {		return Mono.defer(() -> {			Map<String, Object> variables = new HashMap<>();			return Flux.fromIterable(matchers)				.flatMap(matcher -> matcher.matches(exchange))				.doOnNext(matchResult -> variables.putAll(matchResult.getVariables()))				.all(MatchResult::isMatch)				.flatMap(allMatch -> allMatch ? MatchResult.match(variables) : MatchResult.notMatch());		});	}
protected UserDetails processAutoLoginCookie(String[] cookieTokens,			HttpServletRequest request, HttpServletResponse response) {		if (cookieTokens.length != 2) {			throw new InvalidCookieException("Cookie token did not contain " + 2					+ " tokens, but contained '" + Arrays.asList(cookieTokens) + "'");		}		final String presentedSeries = cookieTokens[0];		final String presentedToken = cookieTokens[1];		PersistentRememberMeToken token = tokenRepository				.getTokenForSeries(presentedSeries);		if (token == null) {			// No series match, so we can't authenticate using this cookie			throw new RememberMeAuthenticationException(					"No persistent token found for series id: " + presentedSeries);		}		// We have a match for this user/series combination		if (!presentedToken.equals(token.getTokenValue())) {			// Token doesn't match series value. Delete all logins for this user and throw			// an exception to warn them.			tokenRepository.removeUserTokens(token.getUsername());			throw new CookieTheftException(					messages.getMessage(							"PersistentTokenBasedRememberMeServices.cookieStolen",							"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack."));		}		if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L < System				.currentTimeMillis()) {			throw new RememberMeAuthenticationException("Remember-me login has expired");		}		// Token also matches, so login is valid. Update the token value, keeping the		// *same* series number.		if (logger.isDebugEnabled()) {			logger.debug("Refreshing persistent login token for user '"					+ token.getUsername() + "', series '" + token.getSeries() + "'");		}		PersistentRememberMeToken newToken = new PersistentRememberMeToken(				token.getUsername(), token.getSeries(), generateTokenData(), new Date());		try {			tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(),					newToken.getDate());			addCookie(newToken, request, response);		}		catch (Exception e) {			logger.error("Failed to update token: ", e);			throw new RememberMeAuthenticationException(					"Autologin failed due to data access problem");		}		return getUserDetailsService().loadUserByUsername(token.getUsername());	}
protected void onLoginSuccess(HttpServletRequest request,			HttpServletResponse response, Authentication successfulAuthentication) {		String username = successfulAuthentication.getName();		logger.debug("Creating new persistent login for user " + username);		PersistentRememberMeToken persistentToken = new PersistentRememberMeToken(				username, generateSeriesData(), generateTokenData(), new Date());		try {			tokenRepository.createNewToken(persistentToken);			addCookie(persistentToken, request, response);		}		catch (Exception e) {			logger.error("Failed to save persistent token ", e);		}	}
@Override	public void afterPropertiesSet() {		Assert.notNull(this.userDetailsService, "userDetailsService must be specified");		Assert.isTrue(this.successHandler != null || this.targetUrl != null,				"You must set either a successHandler or the targetUrl");		if (this.targetUrl != null) {			Assert.isNull(this.successHandler,					"You cannot set both successHandler and targetUrl");			this.successHandler = new SimpleUrlAuthenticationSuccessHandler(					this.targetUrl);		}		if (this.failureHandler == null) {			this.failureHandler = this.switchFailureUrl == null					? new SimpleUrlAuthenticationFailureHandler()					: new SimpleUrlAuthenticationFailureHandler(this.switchFailureUrl);		}		else {			Assert.isNull(this.switchFailureUrl,					"You cannot set both a switchFailureUrl and a failureHandler");		}	}
protected Authentication attemptSwitchUser(HttpServletRequest request)			throws AuthenticationException {		UsernamePasswordAuthenticationToken targetUserRequest;		String username = request.getParameter(this.usernameParameter);		if (username == null) {			username = "";		}		if (this.logger.isDebugEnabled()) {			this.logger.debug("Attempt to switch to user [" + username + "]");		}		UserDetails targetUser = this.userDetailsService.loadUserByUsername(username);		this.userDetailsChecker.check(targetUser);		// OK, create the switch user token		targetUserRequest = createSwitchUserToken(request, targetUser);		if (this.logger.isDebugEnabled()) {			this.logger.debug("Switch User Token [" + targetUserRequest + "]");		}		// publish event		if (this.eventPublisher != null) {			this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent(					SecurityContextHolder.getContext().getAuthentication(), targetUser));		}		return targetUserRequest;	}
protected Authentication attemptExitUser(HttpServletRequest request)			throws AuthenticationCredentialsNotFoundException {		// need to check to see if the current user has a SwitchUserGrantedAuthority		Authentication current = SecurityContextHolder.getContext().getAuthentication();		if (null == current) {			throw new AuthenticationCredentialsNotFoundException(					this.messages.getMessage("SwitchUserFilter.noCurrentUser",							"No current user associated with this request"));		}		// check to see if the current user did actual switch to another user		// if so, get the original source user so we can switch back		Authentication original = getSourceAuthentication(current);		if (original == null) {			this.logger.debug("Could not find original user Authentication object!");			throw new AuthenticationCredentialsNotFoundException(					this.messages.getMessage("SwitchUserFilter.noOriginalAuthentication",							"Could not find original Authentication object"));		}		// get the source user details		UserDetails originalUser = null;		Object obj = original.getPrincipal();		if ((obj != null) && obj instanceof UserDetails) {			originalUser = (UserDetails) obj;		}		// publish event		if (this.eventPublisher != null) {			this.eventPublisher.publishEvent(					new AuthenticationSwitchUserEvent(current, originalUser));		}		return original;	}
private UsernamePasswordAuthenticationToken createSwitchUserToken(			HttpServletRequest request, UserDetails targetUser) {		UsernamePasswordAuthenticationToken targetUserRequest;		// grant an additional authority that contains the original Authentication object		// which will be used to 'exit' from the current switched user.		Authentication currentAuth;		try {			// SEC-1763. Check first if we are already switched.			currentAuth = attemptExitUser(request);		}		catch (AuthenticationCredentialsNotFoundException e) {			currentAuth = SecurityContextHolder.getContext().getAuthentication();		}		GrantedAuthority switchAuthority = new SwitchUserGrantedAuthority(				this.switchAuthorityRole, currentAuth);		// get the original authorities		Collection<? extends GrantedAuthority> orig = targetUser.getAuthorities();		// Allow subclasses to change the authorities to be granted		if (this.switchUserAuthorityChanger != null) {			orig = this.switchUserAuthorityChanger.modifyGrantedAuthorities(targetUser,					currentAuth, orig);		}		// add the new switch user authority		List<GrantedAuthority> newAuths = new ArrayList<>(orig);		newAuths.add(switchAuthority);		// create the new authentication token		targetUserRequest = new UsernamePasswordAuthenticationToken(targetUser,				targetUser.getPassword(), newAuths);		// set details		targetUserRequest				.setDetails(this.authenticationDetailsSource.buildDetails(request));		return targetUserRequest;	}
private Authentication getSourceAuthentication(Authentication current) {		Authentication original = null;		// iterate over granted authorities and find the 'switch user' authority		Collection<? extends GrantedAuthority> authorities = current.getAuthorities();		for (GrantedAuthority auth : authorities) {			// check for switch user type of authority			if (auth instanceof SwitchUserGrantedAuthority) {				original = ((SwitchUserGrantedAuthority) auth).getSource();				this.logger.debug("Found original switch user granted authority ["						+ original + "]");			}		}		return original;	}
public void setExitUserUrl(String exitUserUrl) {		Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl),				"exitUserUrl cannot be empty and must be a valid redirect URL");		this.exitUserMatcher = createMatcher(exitUserUrl);	}
public void setSwitchUserUrl(String switchUserUrl) {		Assert.isTrue(UrlUtils.isValidRedirectUrl(switchUserUrl),				"switchUserUrl cannot be empty and must be a valid redirect URL");		this.switchUserMatcher = createMatcher(switchUserUrl);	}
public void setSwitchFailureUrl(String switchFailureUrl) {		Assert.isTrue(UrlUtils.isValidRedirectUrl(switchFailureUrl),				"switchFailureUrl must be a valid redirect URL");		this.switchFailureUrl = switchFailureUrl;	}
@RequestMapping(value = "/hello.htm", method = RequestMethod.GET)	public ModelAndView displayPublicIndex() {		Contact rnd = contactManager.getRandomContact();		return new ModelAndView("hello", "contact", rnd);	}
@RequestMapping(value = "/secure/index.htm", method = RequestMethod.GET)	public ModelAndView displayUserContacts() {		List<Contact> myContactsList = contactManager.getAll();		Map<Contact, Boolean> hasDelete = new HashMap<>(				myContactsList.size());		Map<Contact, Boolean> hasAdmin = new HashMap<>(				myContactsList.size());		Authentication user = SecurityContextHolder.getContext().getAuthentication();		for (Contact contact : myContactsList) {			hasDelete.put(contact, Boolean.valueOf(permissionEvaluator.hasPermission(					user, contact, HAS_DELETE)));			hasAdmin.put(contact, Boolean.valueOf(permissionEvaluator.hasPermission(user,					contact, HAS_ADMIN)));		}		Map<String, Object> model = new HashMap<>();		model.put("contacts", myContactsList);		model.put("hasDeletePermission", hasDelete);		model.put("hasAdminPermission", hasAdmin);		return new ModelAndView("index", "model", model);	}
private String strip(String path) {		if (path == null) {			return null;		}		int scIndex = path.indexOf(';');		if (scIndex < 0) {			int doubleSlashIndex = path.indexOf("//");			if (doubleSlashIndex < 0) {				// Most likely case, no parameters in any segment and no '//', so no				// stripping required				return path;			}		}		StringTokenizer st = new StringTokenizer(path, "/");		StringBuilder stripped = new StringBuilder(path.length());		if (path.charAt(0) == '/') {			stripped.append('/');		}		while (st.hasMoreTokens()) {			String segment = st.nextToken();			scIndex = segment.indexOf(';');			if (scIndex >= 0) {				segment = segment.substring(0, scIndex);			}			stripped.append(segment).append('/');		}		// Remove the trailing slash if the original path didn't have one		if (path.charAt(path.length() - 1) != '/') {			stripped.deleteCharAt(stripped.length() - 1);		}		return stripped.toString();	}
@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)	public Filter springSecurityFilterChain() throws Exception {		boolean hasConfigurers = webSecurityConfigurers != null				&& !webSecurityConfigurers.isEmpty();		if (!hasConfigurers) {			WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor					.postProcess(new WebSecurityConfigurerAdapter() {					});			webSecurity.apply(adapter);		}		return webSecurity.build();	}
@Autowired(required = false)	public void setFilterChainProxySecurityConfigurer(			ObjectPostProcessor<Object> objectPostProcessor,			@Value("#{@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()}") List<SecurityConfigurer<Filter, WebSecurity>> webSecurityConfigurers)			throws Exception {		webSecurity = objectPostProcessor				.postProcess(new WebSecurity(objectPostProcessor));		if (debugEnabled != null) {			webSecurity.debug(debugEnabled);		}		Collections.sort(webSecurityConfigurers, AnnotationAwareOrderComparator.INSTANCE);		Integer previousOrder = null;		Object previousConfig = null;		for (SecurityConfigurer<Filter, WebSecurity> config : webSecurityConfigurers) {			Integer order = AnnotationAwareOrderComparator.lookupOrder(config);			if (previousOrder != null && previousOrder.equals(order)) {				throw new IllegalStateException(						"@Order on WebSecurityConfigurers must be unique. Order of "								+ order + " was already used on " + previousConfig + ", so it cannot be used on "								+ config + " too.");			}			previousOrder = order;			previousConfig = config;		}		for (SecurityConfigurer<Filter, WebSecurity> webSecurityConfigurer : webSecurityConfigurers) {			webSecurity.apply(webSecurityConfigurer);		}		this.webSecurityConfigurers = webSecurityConfigurers;	}
public void setImportMetadata(AnnotationMetadata importMetadata) {		Map<String, Object> enableWebSecurityAttrMap = importMetadata				.getAnnotationAttributes(EnableWebSecurity.class.getName());		AnnotationAttributes enableWebSecurityAttrs = AnnotationAttributes				.fromMap(enableWebSecurityAttrMap);		debugEnabled = enableWebSecurityAttrs.getBoolean("debug");		if (webSecurity != null) {			webSecurity.debug(debugEnabled);		}	}
public static MessageSecurityMetadataSource createExpressionMessageMetadataSource(			LinkedHashMap<MessageMatcher<?>, String> matcherToExpression, SecurityExpressionHandler<Message<Object>> handler) {		LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();		for (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {			MessageMatcher<?> matcher = entry.getKey();			String rawExpression = entry.getValue();			Expression expression = handler.getExpressionParser().parseExpression(					rawExpression);			ConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);			matcherToAttrs.put(matcher, Arrays.asList(attribute));		}		return new DefaultMessageSecurityMetadataSource(matcherToAttrs);	}
@Override	public Jwt decode(String token) throws JwtException {		JWT jwt = parse(token);		if (jwt instanceof SignedJWT) {			Jwt createdJwt = createJwt(token, jwt);			return validateJwt(createdJwt);		}		throw new JwtException("Unsupported algorithm of " + jwt.getHeader().getAlgorithm());	}
@Override	public void onAuthenticationFailure(HttpServletRequest request,			HttpServletResponse response, AuthenticationException exception)			throws IOException, ServletException {		for (Map.Entry<Class<? extends AuthenticationException>, AuthenticationFailureHandler> entry : handlers				.entrySet()) {			Class<? extends AuthenticationException> handlerMappedExceptionClass = entry					.getKey();			if (handlerMappedExceptionClass.isAssignableFrom(exception.getClass())) {				AuthenticationFailureHandler handler = entry.getValue();				handler.onAuthenticationFailure(request, response, exception);				return;			}		}		defaultHandler.onAuthenticationFailure(request, response, exception);	}
public boolean supports(Class<?> clazz) {		for (AccessDecisionVoter voter : this.decisionVoters) {			if (!voter.supports(clazz)) {				return false;			}		}		return true;	}
@Override	public Mono<Map<String, Object>> introspect(String token) {		return Mono.just(token)				.flatMap(this::makeRequest)				.flatMap(this::adaptToNimbusResponse)				.map(this::parseNimbusResponse)				.map(this::castToNimbusSuccess)				.doOnNext(response -> validate(token, response))				.map(this::convertClaimsSet)				.onErrorMap(e -> !(e instanceof OAuth2IntrospectionException), this::onError);	}
public boolean authorize() throws IOException {		boolean isAuthorized;		if (StringUtils.hasText(getAccess())) {			isAuthorized = authorizeUsingAccessExpression();		}		else if (StringUtils.hasText(getUrl())) {			isAuthorized = authorizeUsingUrlCheck();		}		else {			isAuthorized = false;		}		return isAuthorized;	}
public boolean authorizeUsingAccessExpression() throws IOException {		if (SecurityContextHolder.getContext().getAuthentication() == null) {			return false;		}		SecurityExpressionHandler<FilterInvocation> handler = getExpressionHandler();		Expression accessExpression;		try {			accessExpression = handler.getExpressionParser().parseExpression(getAccess());		}		catch (ParseException e) {			IOException ioException = new IOException();			ioException.initCause(e);			throw ioException;		}		return ExpressionUtils.evaluateAsBoolean(accessExpression,				createExpressionEvaluationContext(handler));	}
protected EvaluationContext createExpressionEvaluationContext(			SecurityExpressionHandler<FilterInvocation> handler) {		FilterInvocation f = new FilterInvocation(getRequest(), getResponse(),				new FilterChain() {					public void doFilter(ServletRequest request, ServletResponse response)							throws IOException, ServletException {						throw new UnsupportedOperationException();					}				});		return handler.createEvaluationContext(SecurityContextHolder.getContext()				.getAuthentication(), f);	}
public boolean authorizeUsingUrlCheck() throws IOException {		String contextPath = ((HttpServletRequest) getRequest()).getContextPath();		Authentication currentUser = SecurityContextHolder.getContext()				.getAuthentication();		return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(),				currentUser);	}
@SuppressWarnings({ "unchecked", "rawtypes" })	private SecurityExpressionHandler<FilterInvocation> getExpressionHandler()			throws IOException {		ApplicationContext appContext = SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(getServletContext());		Map<String, SecurityExpressionHandler> handlers = appContext				.getBeansOfType(SecurityExpressionHandler.class);		for (SecurityExpressionHandler h : handlers.values()) {			if (FilterInvocation.class.equals(GenericTypeResolver.resolveTypeArgument(					h.getClass(), SecurityExpressionHandler.class))) {				return h;			}		}		throw new IOException(				"No visible WebSecurityExpressionHandler instance could be found in the application "						+ "context. There must be at least one in order to support expressions in JSP 'authorize' tags.");	}
@Override	public UsernamePasswordAuthenticationToken deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {		UsernamePasswordAuthenticationToken token = null;		ObjectMapper mapper = (ObjectMapper) jp.getCodec();		JsonNode jsonNode = mapper.readTree(jp);		Boolean authenticated = readJsonNode(jsonNode, "authenticated").asBoolean();		JsonNode principalNode = readJsonNode(jsonNode, "principal");		Object principal = null;		if (principalNode.isObject()) {			principal = mapper.readValue(principalNode.traverse(mapper), Object.class);		} else {			principal = principalNode.asText();		}		JsonNode credentialsNode = readJsonNode(jsonNode, "credentials");		Object credentials;		if (credentialsNode.isNull() || credentialsNode.isMissingNode()) {			credentials = null;		} else {			credentials = credentialsNode.asText();		}		List<GrantedAuthority> authorities = mapper.readValue(				readJsonNode(jsonNode, "authorities").traverse(mapper), new TypeReference<List<GrantedAuthority>>() {		});		if (authenticated) {			token = new UsernamePasswordAuthenticationToken(principal, credentials, authorities);		} else {			token = new UsernamePasswordAuthenticationToken(principal, credentials);		}		JsonNode detailsNode = readJsonNode(jsonNode, "details");		if (detailsNode.isNull() || detailsNode.isMissingNode()) {			token.setDetails(null);		} else {			token.setDetails(detailsNode);		}		return token;	}
private void initDefaultLoginFilter(H http) {		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http				.getSharedObject(DefaultLoginPageGeneratingFilter.class);		if (loginPageGeneratingFilter != null) {			loginPageGeneratingFilter.setRememberMeParameter(getRememberMeParameter());		}	}
private RememberMeServices getRememberMeServices(H http, String key)			throws Exception {		if (this.rememberMeServices != null) {			if (this.rememberMeServices instanceof LogoutHandler					&& this.logoutHandler == null) {				this.logoutHandler = (LogoutHandler) this.rememberMeServices;			}			return this.rememberMeServices;		}		AbstractRememberMeServices tokenRememberMeServices = createRememberMeServices(				http, key);		tokenRememberMeServices.setParameter(this.rememberMeParameter);		tokenRememberMeServices.setCookieName(this.rememberMeCookieName);		if (this.rememberMeCookieDomain != null) {			tokenRememberMeServices.setCookieDomain(this.rememberMeCookieDomain);		}		if (this.tokenValiditySeconds != null) {			tokenRememberMeServices.setTokenValiditySeconds(this.tokenValiditySeconds);		}		if (this.useSecureCookie != null) {			tokenRememberMeServices.setUseSecureCookie(this.useSecureCookie);		}		if (this.alwaysRemember != null) {			tokenRememberMeServices.setAlwaysRemember(this.alwaysRemember);		}		tokenRememberMeServices.afterPropertiesSet();		this.logoutHandler = tokenRememberMeServices;		this.rememberMeServices = tokenRememberMeServices;		return tokenRememberMeServices;	}
private AbstractRememberMeServices createRememberMeServices(H http, String key)			throws Exception {		return this.tokenRepository == null				? createTokenBasedRememberMeServices(http, key)				: createPersistentRememberMeServices(http, key);	}
private AbstractRememberMeServices createTokenBasedRememberMeServices(H http,			String key) {		UserDetailsService userDetailsService = getUserDetailsService(http);		return new TokenBasedRememberMeServices(key, userDetailsService);	}
private AbstractRememberMeServices createPersistentRememberMeServices(H http,			String key) {		UserDetailsService userDetailsService = getUserDetailsService(http);		return new PersistentTokenBasedRememberMeServices(key, userDetailsService,				this.tokenRepository);	}
private UserDetailsService getUserDetailsService(H http) {		if (this.userDetailsService == null) {			this.userDetailsService = http.getSharedObject(UserDetailsService.class);		}		if (this.userDetailsService == null) {			throw new IllegalStateException("userDetailsService cannot be null. Invoke "					+ RememberMeConfigurer.class.getSimpleName()					+ "#userDetailsService(UserDetailsService) or see its javadoc for alternative approaches.");		}		return this.userDetailsService;	}
@Deprecated	public void setAuthenticationConverter(Function<ServerWebExchange, Mono<Authentication>> authenticationConverter) {		Assert.notNull(authenticationConverter, "authenticationConverter cannot be null");		setServerAuthenticationConverter(authenticationConverter::apply);	}
public void afterPropertiesSet() throws Exception {		Assert.notNull(mutableAclService, "mutableAclService required");		Assert.notNull(template, "dataSource required");		Assert.notNull(tt, "platformTransactionManager required");		// Set a user account that will initially own all the created data		Authentication authRequest = new UsernamePasswordAuthenticationToken("rod",				"koala", AuthorityUtils.createAuthorityList("ROLE_IGNORED"));		SecurityContextHolder.getContext().setAuthentication(authRequest);		try {			template.execute("DROP TABLE CONTACTS");			template.execute("DROP TABLE AUTHORITIES");			template.execute("DROP TABLE USERS");			template.execute("DROP TABLE ACL_ENTRY");			template.execute("DROP TABLE ACL_OBJECT_IDENTITY");			template.execute("DROP TABLE ACL_CLASS");			template.execute("DROP TABLE ACL_SID");		}		catch (Exception e) {			System.out.println("Failed to drop tables: " + e.getMessage());		}		template.execute("CREATE TABLE ACL_SID("				+ "ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,"				+ "PRINCIPAL BOOLEAN NOT NULL," + "SID VARCHAR_IGNORECASE(100) NOT NULL,"				+ "CONSTRAINT UNIQUE_UK_1 UNIQUE(SID,PRINCIPAL));");		template.execute("CREATE TABLE ACL_CLASS("				+ "ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,"				+ "CLASS VARCHAR_IGNORECASE(100) NOT NULL,"				+ "CLASS_ID_TYPE VARCHAR_IGNORECASE(100),"				+ "CONSTRAINT UNIQUE_UK_2 UNIQUE(CLASS));");		template.execute("CREATE TABLE ACL_OBJECT_IDENTITY("				+ "ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,"				+ "OBJECT_ID_CLASS BIGINT NOT NULL,"				+ "OBJECT_ID_IDENTITY VARCHAR_IGNORECASE(36) NOT NULL,"				+ "PARENT_OBJECT BIGINT,"				+ "OWNER_SID BIGINT,"				+ "ENTRIES_INHERITING BOOLEAN NOT NULL,"				+ "CONSTRAINT UNIQUE_UK_3 UNIQUE(OBJECT_ID_CLASS,OBJECT_ID_IDENTITY),"				+ "CONSTRAINT FOREIGN_FK_1 FOREIGN KEY(PARENT_OBJECT)REFERENCES ACL_OBJECT_IDENTITY(ID),"				+ "CONSTRAINT FOREIGN_FK_2 FOREIGN KEY(OBJECT_ID_CLASS)REFERENCES ACL_CLASS(ID),"				+ "CONSTRAINT FOREIGN_FK_3 FOREIGN KEY(OWNER_SID)REFERENCES ACL_SID(ID));");		template.execute("CREATE TABLE ACL_ENTRY("				+ "ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 100) NOT NULL PRIMARY KEY,"				+ "ACL_OBJECT_IDENTITY BIGINT NOT NULL,ACE_ORDER INT NOT NULL,SID BIGINT NOT NULL,"				+ "MASK INTEGER NOT NULL,GRANTING BOOLEAN NOT NULL,AUDIT_SUCCESS BOOLEAN NOT NULL,"				+ "AUDIT_FAILURE BOOLEAN NOT NULL,CONSTRAINT UNIQUE_UK_4 UNIQUE(ACL_OBJECT_IDENTITY,ACE_ORDER),"				+ "CONSTRAINT FOREIGN_FK_4 FOREIGN KEY(ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY(ID),"				+ "CONSTRAINT FOREIGN_FK_5 FOREIGN KEY(SID) REFERENCES ACL_SID(ID));");		template.execute("CREATE TABLE USERS(USERNAME VARCHAR_IGNORECASE(50) NOT NULL PRIMARY KEY,PASSWORD VARCHAR_IGNORECASE(500) NOT NULL,ENABLED BOOLEAN NOT NULL);");		template.execute("CREATE TABLE AUTHORITIES(USERNAME VARCHAR_IGNORECASE(50) NOT NULL,AUTHORITY VARCHAR_IGNORECASE(50) NOT NULL,CONSTRAINT FK_AUTHORITIES_USERS FOREIGN KEY(USERNAME) REFERENCES USERS(USERNAME));");		template.execute("CREATE UNIQUE INDEX IX_AUTH_USERNAME ON AUTHORITIES(USERNAME,AUTHORITY);");		template.execute("CREATE TABLE CONTACTS(ID BIGINT NOT NULL PRIMARY KEY, CONTACT_NAME VARCHAR_IGNORECASE(50) NOT NULL, EMAIL VARCHAR_IGNORECASE(50) NOT NULL)");		/*		 * Passwords encoded using MD5, NOT in Base64 format, with null as salt Encoded		 * password for rod is "koala" Encoded password for dianne is "emu" Encoded		 * password for scott is "wombat" Encoded password for peter is "opal" (but user		 * is disabled) Encoded password for bill is "wombat" Encoded password for bob is		 * "wombat" Encoded password for jane is "wombat"		 */		template.execute("INSERT INTO USERS VALUES('rod','$2a$10$75pBjapg4Nl8Pzd.3JRnUe7PDJmk9qBGwNEJDAlA3V.dEJxcDKn5O',TRUE);");		template.execute("INSERT INTO USERS VALUES('dianne','$2a$04$bCMEyxrdF/7sgfUiUJ6Ose2vh9DAMaVBldS1Bw2fhi1jgutZrr9zm',TRUE);");		template.execute("INSERT INTO USERS VALUES('scott','$2a$06$eChwvzAu3TSexnC3ynw4LOSw1qiEbtNItNeYv5uI40w1i3paoSfLu',TRUE);");		template.execute("INSERT INTO USERS VALUES('peter','$2a$04$8.H8bCMROLF4CIgd7IpeQ.tcBXLP5w8iplO0n.kCIkISwrIgX28Ii',FALSE);");		template.execute("INSERT INTO USERS VALUES('bill','$2a$04$8.H8bCMROLF4CIgd7IpeQ.3khQlPVNWbp8kzSQqidQHGFurim7P8O',TRUE);");		template.execute("INSERT INTO USERS VALUES('bob','$2a$06$zMgxlMf01SfYNcdx7n4NpeFlAGU8apCETz/i2C7VlYWu6IcNyn4Ay',TRUE);");		template.execute("INSERT INTO USERS VALUES('jane','$2a$05$ZrdS7yMhCZ1J.AAidXZhCOxdjD8LO/dhlv4FJzkXA6xh9gdEbBT/u',TRUE);");		template.execute("INSERT INTO AUTHORITIES VALUES('rod','ROLE_USER');");		template.execute("INSERT INTO AUTHORITIES VALUES('rod','ROLE_SUPERVISOR');");		template.execute("INSERT INTO AUTHORITIES VALUES('dianne','ROLE_USER');");		template.execute("INSERT INTO AUTHORITIES VALUES('scott','ROLE_USER');");		template.execute("INSERT INTO AUTHORITIES VALUES('peter','ROLE_USER');");		template.execute("INSERT INTO AUTHORITIES VALUES('bill','ROLE_USER');");		template.execute("INSERT INTO AUTHORITIES VALUES('bob','ROLE_USER');");		template.execute("INSERT INTO AUTHORITIES VALUES('jane','ROLE_USER');");		template.execute("INSERT INTO contacts VALUES (1, 'John Smith', 'john@somewhere.com');");		template.execute("INSERT INTO contacts VALUES (2, 'Michael Citizen', 'michael@xyz.com');");		template.execute("INSERT INTO contacts VALUES (3, 'Joe Bloggs', 'joe@demo.com');");		template.execute("INSERT INTO contacts VALUES (4, 'Karen Sutherland', 'karen@sutherland.com');");		template.execute("INSERT INTO contacts VALUES (5, 'Mitchell Howard', 'mitchell@abcdef.com');");		template.execute("INSERT INTO contacts VALUES (6, 'Rose Costas', 'rose@xyz.com');");		template.execute("INSERT INTO contacts VALUES (7, 'Amanda Smith', 'amanda@abcdef.com');");		template.execute("INSERT INTO contacts VALUES (8, 'Cindy Smith', 'cindy@smith.com');");		template.execute("INSERT INTO contacts VALUES (9, 'Jonathan Citizen', 'jonathan@xyz.com');");		for (int i = 10; i < createEntities; i++) {			String[] person = selectPerson();			template.execute("INSERT INTO contacts VALUES (" + i + ", '" + person[2]					+ "', '" + person[0].toLowerCase() + "@" + person[1].toLowerCase()					+ ".com');");		}		// Create acl_object_identity rows (and also acl_class rows as needed		for (int i = 1; i < createEntities; i++) {			final ObjectIdentity objectIdentity = new ObjectIdentityImpl(Contact.class,					Long.valueOf(i));			tt.execute(new TransactionCallback<Object>() {				public Object doInTransaction(TransactionStatus arg0) {					mutableAclService.createAcl(objectIdentity);					return null;				}			});		}		// Now grant some permissions		grantPermissions(1, "rod", BasePermission.ADMINISTRATION);		grantPermissions(2, "rod", BasePermission.READ);		grantPermissions(3, "rod", BasePermission.READ);		grantPermissions(3, "rod", BasePermission.WRITE);		grantPermissions(3, "rod", BasePermission.DELETE);		grantPermissions(4, "rod", BasePermission.ADMINISTRATION);		grantPermissions(4, "dianne", BasePermission.ADMINISTRATION);		grantPermissions(4, "scott", BasePermission.READ);		grantPermissions(5, "dianne", BasePermission.ADMINISTRATION);		grantPermissions(5, "dianne", BasePermission.READ);		grantPermissions(6, "dianne", BasePermission.READ);		grantPermissions(6, "dianne", BasePermission.WRITE);		grantPermissions(6, "dianne", BasePermission.DELETE);		grantPermissions(6, "scott", BasePermission.READ);		grantPermissions(7, "scott", BasePermission.ADMINISTRATION);		grantPermissions(8, "dianne", BasePermission.ADMINISTRATION);		grantPermissions(8, "dianne", BasePermission.READ);		grantPermissions(8, "scott", BasePermission.READ);		grantPermissions(9, "scott", BasePermission.ADMINISTRATION);		grantPermissions(9, "scott", BasePermission.READ);		grantPermissions(9, "scott", BasePermission.WRITE);		grantPermissions(9, "scott", BasePermission.DELETE);		// Now expressly change the owner of the first ten contacts		// We have to do this last, because "rod" owns all of them (doing it sooner would		// prevent ACL updates)		// Note that ownership has no impact on permissions - they're separate (ownership		// only allows ACl editing)		changeOwner(5, "dianne");		changeOwner(6, "dianne");		changeOwner(7, "scott");		changeOwner(8, "dianne");		changeOwner(9, "scott");		String[] users = { "bill", "bob", "jane" }; // don't want to mess around with													// consistent sample data		Permission[] permissions = { BasePermission.ADMINISTRATION, BasePermission.READ,				BasePermission.DELETE };		for (int i = 10; i < createEntities; i++) {			String user = users[rnd.nextInt(users.length)];			Permission permission = permissions[rnd.nextInt(permissions.length)];			grantPermissions(i, user, permission);			String user2 = users[rnd.nextInt(users.length)];			Permission permission2 = permissions[rnd.nextInt(permissions.length)];			grantPermissions(i, user2, permission2);		}		SecurityContextHolder.clearContext();	}
public JeeConfigurer<H> mappableAuthorities(String... mappableRoles) {		this.mappableRoles.clear();		for (String role : mappableRoles) {			this.mappableRoles.add(role);		}		return this;	}
@Override	public void init(H http) throws Exception {		PreAuthenticatedAuthenticationProvider authenticationProvider = new PreAuthenticatedAuthenticationProvider();		authenticationProvider				.setPreAuthenticatedUserDetailsService(getUserDetailsService());		authenticationProvider = postProcess(authenticationProvider);		// @formatter:off		http			.authenticationProvider(authenticationProvider)			.setSharedObject(AuthenticationEntryPoint.class, new Http403ForbiddenEntryPoint());		// @formatter:on	}
private J2eePreAuthenticatedProcessingFilter getFilter(			AuthenticationManager authenticationManager) {		if (j2eePreAuthenticatedProcessingFilter == null) {			j2eePreAuthenticatedProcessingFilter = new J2eePreAuthenticatedProcessingFilter();			j2eePreAuthenticatedProcessingFilter					.setAuthenticationManager(authenticationManager);			j2eePreAuthenticatedProcessingFilter					.setAuthenticationDetailsSource(createWebAuthenticationDetailsSource());			j2eePreAuthenticatedProcessingFilter = postProcess(j2eePreAuthenticatedProcessingFilter);		}		return j2eePreAuthenticatedProcessingFilter;	}
private J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource createWebAuthenticationDetailsSource() {		J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource detailsSource = new J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource();		SimpleMappableAttributesRetriever rolesRetriever = new SimpleMappableAttributesRetriever();		rolesRetriever.setMappableAttributes(mappableRoles);		detailsSource.setMappableRolesRetriever(rolesRetriever);		detailsSource = postProcess(detailsSource);		return detailsSource;	}
public void writeHeaders(HttpServletRequest request, HttpServletResponse response) {		if (this.requestMatcher.matches(request)) {			this.delegateHeaderWriter.writeHeaders(request, response);		}	}
public HeadersConfigurer<H> addHeaderWriter(HeaderWriter headerWriter) {		Assert.notNull(headerWriter, "headerWriter cannot be null");		this.headerWriters.add(headerWriter);		return this;	}
public HeadersConfigurer<H> defaultsDisabled() {		contentTypeOptions.disable();		xssProtection.disable();		cacheControl.disable();		hsts.disable();		frameOptions.disable();		return this;	}
private HeaderWriterFilter createHeaderWriterFilter() {		List<HeaderWriter> writers = getHeaderWriters();		if (writers.isEmpty()) {			throw new IllegalStateException(					"Headers security is enabled, but no headers will be added. Either add headers or disable headers security");		}		HeaderWriterFilter headersFilter = new HeaderWriterFilter(writers);		headersFilter = postProcess(headersFilter);		return headersFilter;	}
private List<HeaderWriter> getHeaderWriters() {		List<HeaderWriter> writers = new ArrayList<>();		addIfNotNull(writers, contentTypeOptions.writer);		addIfNotNull(writers, xssProtection.writer);		addIfNotNull(writers, cacheControl.writer);		addIfNotNull(writers, hsts.writer);		addIfNotNull(writers, frameOptions.writer);		addIfNotNull(writers, hpkp.writer);		addIfNotNull(writers, contentSecurityPolicy.writer);		addIfNotNull(writers, referrerPolicy.writer);		addIfNotNull(writers, featurePolicy.writer);		writers.addAll(headerWriters);		return writers;	}
public void registerAfter(Class<? extends Filter> filter,			Class<? extends Filter> afterFilter) {		Integer position = getOrder(afterFilter);		if (position == null) {			throw new IllegalArgumentException(					"Cannot register after unregistered Filter " + afterFilter);		}		put(filter, position + 1);	}
public void registerAt(Class<? extends Filter> filter,			Class<? extends Filter> atFilter) {		Integer position = getOrder(atFilter);		if (position == null) {			throw new IllegalArgumentException(					"Cannot register after unregistered Filter " + atFilter);		}		put(filter, position);	}
public void registerBefore(Class<? extends Filter> filter,			Class<? extends Filter> beforeFilter) {		Integer position = getOrder(beforeFilter);		if (position == null) {			throw new IllegalArgumentException(					"Cannot register after unregistered Filter " + beforeFilter);		}		put(filter, position - 1);	}
private Integer getOrder(Class<?> clazz) {		while (clazz != null) {			Integer result = filterToOrder.get(clazz.getName());			if (result != null) {				return result;			}			clazz = clazz.getSuperclass();		}		return null;	}
@Override	public Collection<GrantedAuthority> convert(Jwt jwt) {		return getScopes(jwt)				.stream()				.map(authority -> SCOPE_AUTHORITY_PREFIX + authority)				.map(SimpleGrantedAuthority::new)				.collect(Collectors.toList());	}
private Collection<String> getScopes(Jwt jwt) {		for ( String attributeName : WELL_KNOWN_SCOPE_ATTRIBUTE_NAMES ) {			Object scopes = jwt.getClaims().get(attributeName);			if (scopes instanceof String) {				if (StringUtils.hasText((String) scopes)) {					return Arrays.asList(((String) scopes).split(" "));				} else {					return Collections.emptyList();				}			} else if (scopes instanceof Collection) {				return (Collection<String>) scopes;			}		}		return Collections.emptyList();	}
public AuthenticationManagerBuilder parentAuthenticationManager(			AuthenticationManager authenticationManager) {		if (authenticationManager instanceof ProviderManager) {			eraseCredentials(((ProviderManager) authenticationManager)					.isEraseCredentialsAfterAuthentication());		}		this.parentAuthenticationManager = authenticationManager;		return this;	}
public <T extends UserDetailsService> DaoAuthenticationConfigurer<AuthenticationManagerBuilder, T> userDetailsService(			T userDetailsService) throws Exception {		this.defaultUserDetailsService = userDetailsService;		return apply(new DaoAuthenticationConfigurer<>(				userDetailsService));	}
private <C extends UserDetailsAwareConfigurer<AuthenticationManagerBuilder, ? extends UserDetailsService>> C apply(			C configurer) throws Exception {		this.defaultUserDetailsService = configurer.getUserDetailsService();		return (C) super.apply(configurer);	}
@Override	public CsrfToken generateToken(HttpServletRequest request) {		return wrap(request, this.delegate.generateToken(request));	}
@Override	public void saveToken(CsrfToken token, HttpServletRequest request,			HttpServletResponse response) {		if (token == null) {			this.delegate.saveToken(token, request, response);		}	}
@RequestMapping(value = "/secure/adminPermission.htm", method = RequestMethod.GET)	public ModelAndView displayAdminPage(@RequestParam("contactId") int contactId) {		Contact contact = contactManager.getById(Long.valueOf(contactId));		Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact));		Map<String, Object> model = new HashMap<>();		model.put("contact", contact);		model.put("acl", acl);		return new ModelAndView("adminPermission", "model", model);	}
@RequestMapping(value = "/secure/addPermission.htm", method = RequestMethod.GET)	public ModelAndView displayAddPermissionPageForContact(			@RequestParam("contactId") long contactId) {		Contact contact = contactManager.getById(contactId);		AddPermission addPermission = new AddPermission();		addPermission.setContact(contact);		Map<String, Object> model = new HashMap<>();		model.put("addPermission", addPermission);		model.put("recipients", listRecipients());		model.put("permissions", listPermissions());		return new ModelAndView("addPermission", model);	}
@RequestMapping(value = "/secure/addPermission.htm", method = RequestMethod.POST)	public String addPermission(AddPermission addPermission, BindingResult result,			ModelMap model) {		addPermissionValidator.validate(addPermission, result);		if (result.hasErrors()) {			model.put("recipients", listRecipients());			model.put("permissions", listPermissions());			return "addPermission";		}		PrincipalSid sid = new PrincipalSid(addPermission.getRecipient());		Permission permission = permissionFactory.buildFromMask(addPermission				.getPermission());		try {			contactManager.addPermission(addPermission.getContact(), sid, permission);		}		catch (DataAccessException existingPermission) {			existingPermission.printStackTrace();			result.rejectValue("recipient", "err.recipientExistsForContact",					"Addition failure.");			model.put("recipients", listRecipients());			model.put("permissions", listPermissions());			return "addPermission";		}		return "redirect:/secure/index.htm";	}
@RequestMapping(value = "/secure/deletePermission.htm")	public ModelAndView deletePermission(@RequestParam("contactId") long contactId,			@RequestParam("sid") String sid, @RequestParam("permission") int mask) {		Contact contact = contactManager.getById(contactId);		Sid sidObject = new PrincipalSid(sid);		Permission permission = permissionFactory.buildFromMask(mask);		contactManager.deletePermission(contact, sidObject, permission);		Map<String, Object> model = new HashMap<>();		model.put("contact", contact);		model.put("sid", sidObject);		model.put("permission", permission);		return new ModelAndView("deletePermission", "model", model);	}
private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) {		if (role == null) {			return role;		}		if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) {			return role;		}		if (role.startsWith(defaultRolePrefix)) {			return role;		}		return defaultRolePrefix + role;	}
@Override	public void afterPropertiesSet() {		Assert.notNull(this.securityMetadataSource,				"securityMetadataSource must be specified");		Assert.notNull(this.channelDecisionManager,				"channelDecisionManager must be specified");		Collection<ConfigAttribute> attrDefs = this.securityMetadataSource				.getAllConfigAttributes();		if (attrDefs == null) {			if (this.logger.isWarnEnabled()) {				this.logger						.warn("Could not validate configuration attributes as the FilterInvocationSecurityMetadataSource did "								+ "not return any attributes");			}			return;		}		Set<ConfigAttribute> unsupportedAttributes = new HashSet<>();		for (ConfigAttribute attr : attrDefs) {			if (!this.channelDecisionManager.supports(attr)) {				unsupportedAttributes.add(attr);			}		}		if (unsupportedAttributes.size() == 0) {			if (this.logger.isInfoEnabled()) {				this.logger.info("Validated configuration attributes");			}		}		else {			throw new IllegalArgumentException(					"Unsupported configuration attributes: " + unsupportedAttributes);		}	}
public static Builder success(String code) {		Assert.hasText(code, "code cannot be empty");		return new Builder().code(code);	}
public static Builder error(String errorCode) {		Assert.hasText(errorCode, "errorCode cannot be empty");		return new Builder().errorCode(errorCode);	}
@Override	public Mono<MatchResult> matches(ServerWebExchange exchange) {		return matcher.matches(exchange)			.flatMap(m -> m.isMatch() ? MatchResult.notMatch() : MatchResult.match());	}
public static ReactiveUserDetailsServiceResourceFactoryBean fromResourceLocation(String resourceLocation) {		ReactiveUserDetailsServiceResourceFactoryBean result = new ReactiveUserDetailsServiceResourceFactoryBean();		result.setResourceLocation(resourceLocation);		return result;	}
public static ReactiveUserDetailsServiceResourceFactoryBean fromResource(Resource propertiesResource) {		ReactiveUserDetailsServiceResourceFactoryBean result = new ReactiveUserDetailsServiceResourceFactoryBean();		result.setResource(propertiesResource);		return result;	}
public static ReactiveUserDetailsServiceResourceFactoryBean fromString(String users) {		ReactiveUserDetailsServiceResourceFactoryBean result = new ReactiveUserDetailsServiceResourceFactoryBean();		result.setResource(new InMemoryResource(users));		return result;	}
@Override	public User deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {		ObjectMapper mapper = (ObjectMapper) jp.getCodec();		JsonNode jsonNode = mapper.readTree(jp);		Set<GrantedAuthority> authorities = mapper.convertValue(jsonNode.get("authorities"), new TypeReference<Set<SimpleGrantedAuthority>>() {		});		JsonNode password = readJsonNode(jsonNode, "password");		User result =  new User(				readJsonNode(jsonNode, "username").asText(), password.asText(""),				readJsonNode(jsonNode, "enabled").asBoolean(), readJsonNode(jsonNode, "accountNonExpired").asBoolean(),				readJsonNode(jsonNode, "credentialsNonExpired").asBoolean(),				readJsonNode(jsonNode, "accountNonLocked").asBoolean(), authorities		);		if (password.asText(null) == null) {			result.eraseCredentials();		}		return result;	}
private AccessDecisionManager createDefaultAccessDecisionManager(H http) {		AffirmativeBased result = new AffirmativeBased(getDecisionVoters(http));		return postProcess(result);	}
private AccessDecisionManager getAccessDecisionManager(H http) {		if (accessDecisionManager == null) {			accessDecisionManager = createDefaultAccessDecisionManager(http);		}		return accessDecisionManager;	}
private FilterSecurityInterceptor createFilterSecurityInterceptor(H http,			FilterInvocationSecurityMetadataSource metadataSource,			AuthenticationManager authenticationManager) throws Exception {		FilterSecurityInterceptor securityInterceptor = new FilterSecurityInterceptor();		securityInterceptor.setSecurityMetadataSource(metadataSource);		securityInterceptor.setAccessDecisionManager(getAccessDecisionManager(http));		securityInterceptor.setAuthenticationManager(authenticationManager);		securityInterceptor.afterPropertiesSet();		return securityInterceptor;	}
public static UserDetailsResourceFactoryBean fromResourceLocation(String resourceLocation) {		UserDetailsResourceFactoryBean result = new UserDetailsResourceFactoryBean();		result.setResourceLocation(resourceLocation);		return result;	}
public static UserDetailsResourceFactoryBean fromResource(Resource propertiesResource) {		UserDetailsResourceFactoryBean result = new UserDetailsResourceFactoryBean();		result.setResource(propertiesResource);		return result;	}
public static UserDetailsResourceFactoryBean fromString(String users) {		InMemoryResource resource = new InMemoryResource(users);		return fromResource(resource);	}
public static SimpDestinationMessageMatcher createSubscribeMatcher(String pattern,			PathMatcher matcher) {		return new SimpDestinationMessageMatcher(pattern, SimpMessageType.SUBSCRIBE,				matcher);	}
public static SimpDestinationMessageMatcher createMessageMatcher(String pattern,			PathMatcher matcher) {		return new SimpDestinationMessageMatcher(pattern, SimpMessageType.MESSAGE,				matcher);	}
public List<String> getAttributeValues(String name) {		List<String> result = null;		if (attributes != null) {			result = attributes.get(name);		}		if (result == null) {			result = Collections.emptyList();		}		return result;	}
public String getFirstAttributeValue(String name) {		List<String> result = getAttributeValues(name);		if (result.isEmpty()) {			return null;		}		else {			return result.get(0);		}	}
public void handle(Callback callback, Authentication authentication)			throws IOException, UnsupportedCallbackException {		if (callback instanceof NameCallback) {			NameCallback ncb = (NameCallback) callback;			String username;			Object principal = authentication.getPrincipal();			if (principal instanceof UserDetails) {				username = ((UserDetails) principal).getUsername();			}			else {				username = principal.toString();			}			ncb.setName(username);		}	}
public static byte[] encode(CharSequence string) {		try {			ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string));			byte[] bytesCopy = new byte[bytes.limit()];			System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit());			return bytesCopy;		}		catch (CharacterCodingException e) {			throw new IllegalArgumentException("Encoding failed", e);		}	}
public static String decode(byte[] bytes) {		try {			return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString();		}		catch (CharacterCodingException e) {			throw new IllegalArgumentException("Decoding failed", e);		}	}
public CasAuthenticationToken getByTicketId(final String serviceTicket) {		final Cache.ValueWrapper element = serviceTicket != null ? cache				.get(serviceTicket) : null;		if (logger.isDebugEnabled()) {			logger.debug("Cache hit: " + (element != null) + "; service ticket: "					+ serviceTicket);		}		return element == null ? null : (CasAuthenticationToken) element.get();	}
public String[] getParameterNames(Method method) {		Method originalMethod = BridgeMethodResolver.findBridgedMethod(method);		String[] paramNames = lookupParameterNames(METHOD_METHODPARAM_FACTORY,				originalMethod);		if (paramNames != null) {			return paramNames;		}		Class<?> declaringClass = method.getDeclaringClass();		Class<?>[] interfaces = declaringClass.getInterfaces();		for (Class<?> intrfc : interfaces) {			Method intrfcMethod = ReflectionUtils.findMethod(intrfc, method.getName(),					method.getParameterTypes());			if (intrfcMethod != null) {				return lookupParameterNames(METHOD_METHODPARAM_FACTORY, intrfcMethod);			}		}		return paramNames;	}
private <T extends AccessibleObject> String[] lookupParameterNames(			ParameterNameFactory<T> parameterNameFactory, T t) {		Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t);		int parameterCount = parameterAnnotations.length;		String[] paramNames = new String[parameterCount];		boolean found = false;		for (int i = 0; i < parameterCount; i++) {			Annotation[] annotations = parameterAnnotations[i];			String parameterName = findParameterName(annotations);			if (parameterName != null) {				found = true;				paramNames[i] = parameterName;			}		}		return found ? paramNames : null;	}
private String findParameterName(Annotation[] parameterAnnotations) {		for (Annotation paramAnnotation : parameterAnnotations) {			if (annotationClassesToUse.contains(paramAnnotation.annotationType()					.getName())) {				return (String) AnnotationUtils.getValue(paramAnnotation, "value");			}		}		return null;	}
@RequestMapping(value = "/secure/add.htm", method = RequestMethod.POST)	public String addContact(WebContact form, BindingResult result) {		validator.validate(form, result);		if (result.hasErrors()) {			return "add";		}		Contact contact = new Contact(form.getName(), form.getEmail());		contactManager.create(contact);		return "redirect:/secure/index.htm";	}
public void writeHeaders(HttpServletRequest request, HttpServletResponse response) {		if (requestMatcher.matches(request)) {			if (!pins.isEmpty()) {				String headerName = reportOnly ? HPKP_RO_HEADER_NAME : HPKP_HEADER_NAME;				if (!response.containsHeader(headerName)) {					response.setHeader(headerName, hpkpHeaderValue);				}			} if (logger.isDebugEnabled()) {				logger.debug("Not injecting HPKP header since there aren't any pins");			}		}		else if (logger.isDebugEnabled()) {			logger.debug("Not injecting HPKP header since it wasn't a secure connection");		}	}
public void setPins(Map<String, String> pins) {		Assert.notNull(pins, "pins cannot be null");		this.pins = pins;		updateHpkpHeaderValue();	}
public void addSha256Pins(String ... pins) {		for (String pin : pins) {			Assert.notNull(pin, "pin cannot be null");			this.pins.put(pin, "sha256");		}		updateHpkpHeaderValue();	}
public void setReportUri(String reportUri) {		try {			this.reportUri = new URI(reportUri);		} catch (URISyntaxException e) {			throw new IllegalArgumentException(e);		}		updateHpkpHeaderValue();	}
@Override	protected Collection<ConfigAttribute> findAttributes(Method method,			Class<?> targetClass) {		if (targetClass == null) {			return null;		}		return findAttributesSpecifiedAgainst(method, targetClass);	}
private void addSecureMethod(String name, List<ConfigAttribute> attr) {		int lastDotIndex = name.lastIndexOf(".");		if (lastDotIndex == -1) {			throw new IllegalArgumentException("'" + name					+ "' is not a valid method name: format is FQN.methodName");		}		String methodName = name.substring(lastDotIndex + 1);		Assert.hasText(methodName, () -> "Method not found for '" + name + "'");		String typeName = name.substring(0, lastDotIndex);		Class<?> type = ClassUtils.resolveClassName(typeName, this.beanClassLoader);		addSecureMethod(type, methodName, attr);	}
public void addSecureMethod(Class<?> javaType, String mappedName,			List<ConfigAttribute> attr) {		String name = javaType.getName() + '.' + mappedName;		if (logger.isDebugEnabled()) {			logger.debug("Request to add secure method [" + name + "] with attributes ["					+ attr + "]");		}		Method[] methods = javaType.getMethods();		List<Method> matchingMethods = new ArrayList<>();		for (Method m : methods) {			if (m.getName().equals(mappedName) || isMatch(m.getName(), mappedName)) {				matchingMethods.add(m);			}		}		if (matchingMethods.isEmpty()) {			throw new IllegalArgumentException("Couldn't find method '" + mappedName					+ "' on '" + javaType + "'");		}		// register all matching methods		for (Method method : matchingMethods) {			RegisteredMethod registeredMethod = new RegisteredMethod(method, javaType);			String regMethodName = (String) this.nameMap.get(registeredMethod);			if ((regMethodName == null)					|| (!regMethodName.equals(name) && (regMethodName.length() <= name							.length()))) {				// no already registered method name, or more specific				// method name specification now -> (re-)register method				if (regMethodName != null) {					logger.debug("Replacing attributes for secure method [" + method							+ "]: current name [" + name + "] is more specific than ["							+ regMethodName + "]");				}				this.nameMap.put(registeredMethod, name);				addSecureMethod(registeredMethod, attr);			}			else {				logger.debug("Keeping attributes for secure method [" + method						+ "]: current name [" + name + "] is not more specific than ["						+ regMethodName + "]");			}		}	}
public void addSecureMethod(Class<?> javaType, Method method,			List<ConfigAttribute> attr) {		RegisteredMethod key = new RegisteredMethod(method, javaType);		if (methodMap.containsKey(key)) {			logger.debug("Method [" + method					+ "] is already registered with attributes [" + methodMap.get(key)					+ "]");			return;		}		methodMap.put(key, attr);	}
private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) {		Assert.notNull(method, "RegisteredMethod required");		Assert.notNull(attr, "Configuration attribute required");		if (logger.isInfoEnabled()) {			logger.info("Adding secure method [" + method + "] with attributes [" + attr					+ "]");		}		this.methodMap.put(method, attr);	}
@Override	public Collection<ConfigAttribute> getAllConfigAttributes() {		Set<ConfigAttribute> allAttributes = new HashSet<>();		for (List<ConfigAttribute> attributeList : methodMap.values()) {			allAttributes.addAll(attributeList);		}		return allAttributes;	}
private boolean isMatch(String methodName, String mappedName) {		return (mappedName.endsWith("*") && methodName.startsWith(mappedName.substring(0,				mappedName.length() - 1)))				|| (mappedName.startsWith("*") && methodName.endsWith(mappedName						.substring(1, mappedName.length())));	}
private PortMapper getPortMapper() {		if (portMapper == null) {			PortMapperImpl portMapper = new PortMapperImpl();			portMapper.setPortMappings(httpsPortMappings);			this.portMapper = portMapper;		}		return portMapper;	}
public void saveToken(CsrfToken token, HttpServletRequest request,			HttpServletResponse response) {		if (token == null) {			HttpSession session = request.getSession(false);			if (session != null) {				session.removeAttribute(this.sessionAttributeName);			}		}		else {			HttpSession session = request.getSession();			session.setAttribute(this.sessionAttributeName, token);		}	}
public CsrfToken loadToken(HttpServletRequest request) {		HttpSession session = request.getSession(false);		if (session == null) {			return null;		}		return (CsrfToken) session.getAttribute(this.sessionAttributeName);	}
public static ReactiveJwtDecoder fromOidcIssuerLocation(String oidcIssuerLocation) {		Map<String, Object> openidConfiguration = getOpenidConfiguration(oidcIssuerLocation);		String metadataIssuer = "(unavailable)";		if (openidConfiguration.containsKey("issuer")) {			metadataIssuer = openidConfiguration.get("issuer").toString();		}		if (!oidcIssuerLocation.equals(metadataIssuer)) {			throw new IllegalStateException("The Issuer \"" + metadataIssuer + "\" provided in the OpenID Configuration " +					"did not match the requested issuer \"" + oidcIssuerLocation + "\"");		}		OAuth2TokenValidator<Jwt> jwtValidator =				JwtValidators.createDefaultWithIssuer(oidcIssuerLocation);		NimbusReactiveJwtDecoder jwtDecoder =				new NimbusReactiveJwtDecoder(openidConfiguration.get("jwks_uri").toString());		jwtDecoder.setJwtValidator(jwtValidator);		return jwtDecoder;	}
@Override	public Mono<MatchResult> matches(ServerWebExchange exchange) {		return Flux.fromIterable(matchers)			.flatMap(m -> m.matches(exchange))			.filter(m -> m.isMatch())			.next()			.switchIfEmpty(MatchResult.notMatch());	}
public static <T> AuthorityReactiveAuthorizationManager<T> hasAuthority(String authority) {		Assert.notNull(authority, "authority cannot be null");		return new AuthorityReactiveAuthorizationManager<>(authority);	}
public static <T> AuthorityReactiveAuthorizationManager<T> hasAnyAuthority(String... authorities) {		Assert.notNull(authorities, "authorities cannot be null");		for (String authority : authorities) {			Assert.notNull(authority, "authority cannot be null");		}		return new AuthorityReactiveAuthorizationManager<>(authorities);	}
public static <T> AuthorityReactiveAuthorizationManager<T> hasRole(String role) {		Assert.notNull(role, "role cannot be null");		return hasAuthority("ROLE_" + role);	}
public static <T> AuthorityReactiveAuthorizationManager<T> hasAnyRole(String... roles) {		Assert.notNull(roles, "roles cannot be null");		for (String role : roles) {			Assert.notNull(role, "role cannot be null");		}		return hasAnyAuthority(Stream.of(roles)				.map(r -> "ROLE_" + r)				.toArray(String[]::new)		);	}
public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {		HttpServletRequest request = requestResponseHolder.getRequest();		HttpServletResponse response = requestResponseHolder.getResponse();		HttpSession httpSession = request.getSession(false);		SecurityContext context = readSecurityContextFromSession(httpSession);		if (context == null) {			if (logger.isDebugEnabled()) {				logger.debug("No SecurityContext was available from the HttpSession: "						+ httpSession + ". " + "A new one will be created.");			}			context = generateNewContext();		}		SaveToSessionResponseWrapper wrappedResponse = new SaveToSessionResponseWrapper(				response, request, httpSession != null, context);		requestResponseHolder.setResponse(wrappedResponse);		requestResponseHolder.setRequest(new SaveToSessionRequestWrapper(				request, wrappedResponse));		return context;	}
public C anyRequest() {		Assert.state(!this.anyRequestConfigured, "Can't configure anyRequest after itself");		C configurer = requestMatchers(ANY_REQUEST);		this.anyRequestConfigured = true;		return configurer;	}
public C antMatchers(String... antPatterns) {		Assert.state(!this.anyRequestConfigured, "Can't configure antMatchers after anyRequest");		return chainRequestMatchers(RequestMatchers.antMatchers(antPatterns));	}
protected final List<MvcRequestMatcher> createMvcMatchers(HttpMethod method,			String... mvcPatterns) {		Assert.state(!this.anyRequestConfigured, "Can't configure mvcMatchers after anyRequest");		ObjectPostProcessor<Object> opp = this.context.getBean(ObjectPostProcessor.class);		if (!this.context.containsBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME)) {			throw new NoSuchBeanDefinitionException("A Bean named " + HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME +" of type " + HandlerMappingIntrospector.class.getName()				+ " is required to use MvcRequestMatcher. Please ensure Spring Security & Spring MVC are configured in a shared ApplicationContext.");		}		HandlerMappingIntrospector introspector = this.context.getBean(HANDLER_MAPPING_INTROSPECTOR_BEAN_NAME,			HandlerMappingIntrospector.class);		List<MvcRequestMatcher> matchers = new ArrayList<>(				mvcPatterns.length);		for (String mvcPattern : mvcPatterns) {			MvcRequestMatcher matcher = new MvcRequestMatcher(introspector, mvcPattern);			opp.postProcess(matcher);			if (method != null) {				matcher.setMethod(method);			}			matchers.add(matcher);		}		return matchers;	}
public C regexMatchers(HttpMethod method, String... regexPatterns) {		Assert.state(!this.anyRequestConfigured, "Can't configure regexMatchers after anyRequest");		return chainRequestMatchers(RequestMatchers.regexMatchers(method, regexPatterns));	}
public C requestMatchers(RequestMatcher... requestMatchers) {		Assert.state(!this.anyRequestConfigured, "Can't configure requestMatchers after anyRequest");		return chainRequestMatchers(Arrays.asList(requestMatchers));	}
public Object resolveArgument(MethodParameter parameter, Message<?> message)			throws Exception {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (authentication == null) {			return null;		}		Object principal = authentication.getPrincipal();		AuthenticationPrincipal authPrincipal = findMethodAnnotation(				AuthenticationPrincipal.class, parameter);		String expressionToParse = authPrincipal.expression();		if (StringUtils.hasLength(expressionToParse)) {			StandardEvaluationContext context = new StandardEvaluationContext();			context.setRootObject(principal);			context.setVariable("this", principal);			Expression expression = this.parser.parseExpression(expressionToParse);			principal = expression.getValue(context);		}		if (principal != null				&& !parameter.getParameterType().isAssignableFrom(principal.getClass())) {			if (authPrincipal.errorOnInvalidType()) {				throw new ClassCastException(principal + " is not assignable to "						+ parameter.getParameterType());			}			else {				return null;			}		}		return principal;	}
@Override	protected LoginContext createLoginContext(CallbackHandler handler)			throws LoginException {		return new LoginContext(getLoginContextName(), null, handler, getConfiguration());	}
public DirContextOperations authenticate(Authentication authentication) {		DirContextOperations user = null;		Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,				"Can only process UsernamePasswordAuthenticationToken objects");		String username = authentication.getName();		String password = (String) authentication.getCredentials();		if (!StringUtils.hasLength(password)) {			logger.debug("Rejecting empty password for user " + username);			throw new BadCredentialsException(messages.getMessage(					"BindAuthenticator.emptyPassword", "Empty Password"));		}		// If DN patterns are configured, try authenticating with them directly		for (String dn : getUserDns(username)) {			user = bindWithDn(dn, username, password);			if (user != null) {				break;			}		}		// Otherwise use the configured search object to find the user and authenticate		// with the returned DN.		if (user == null && getUserSearch() != null) {			DirContextOperations userFromSearch = getUserSearch().searchForUser(username);			user = bindWithDn(userFromSearch.getDn().toString(), username, password,					userFromSearch.getAttributes());		}		if (user == null) {			throw new BadCredentialsException(messages.getMessage(					"BindAuthenticator.badCredentials", "Bad credentials"));		}		return user;	}
protected void handleBindException(String userDn, String username, Throwable cause) {		if (logger.isDebugEnabled()) {			logger.debug("Failed to bind as " + userDn + ": " + cause);		}	}
@Override	public RequestEntity<?> convert(OAuth2UserRequest userRequest) {		ClientRegistration clientRegistration = userRequest.getClientRegistration();		HttpMethod httpMethod = HttpMethod.GET;		if (AuthenticationMethod.FORM.equals(clientRegistration.getProviderDetails().getUserInfoEndpoint().getAuthenticationMethod())) {			httpMethod = HttpMethod.POST;		}		HttpHeaders headers = new HttpHeaders();		headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));		URI uri = UriComponentsBuilder.fromUriString(clientRegistration.getProviderDetails().getUserInfoEndpoint().getUri())				.build()				.toUri();		RequestEntity<?> request;		if (HttpMethod.POST.equals(httpMethod)) {			headers.setContentType(DEFAULT_CONTENT_TYPE);			MultiValueMap<String, String> formParameters = new LinkedMultiValueMap<>();			formParameters.add(OAuth2ParameterNames.ACCESS_TOKEN, userRequest.getAccessToken().getTokenValue());			request = new RequestEntity<>(formParameters, headers, httpMethod, uri);		} else {			headers.setBearerAuth(userRequest.getAccessToken().getTokenValue());			request = new RequestEntity<>(headers, httpMethod, uri);		}		return request;	}
@Override	protected void doFilterInternal(HttpServletRequest request,			HttpServletResponse response, FilterChain filterChain)					throws ServletException, IOException {		request.setAttribute(HttpServletResponse.class.getName(), response);		CsrfToken csrfToken = this.tokenRepository.loadToken(request);		final boolean missingToken = csrfToken == null;		if (missingToken) {			csrfToken = this.tokenRepository.generateToken(request);			this.tokenRepository.saveToken(csrfToken, request, response);		}		request.setAttribute(CsrfToken.class.getName(), csrfToken);		request.setAttribute(csrfToken.getParameterName(), csrfToken);		if (!this.requireCsrfProtectionMatcher.matches(request)) {			filterChain.doFilter(request, response);			return;		}		String actualToken = request.getHeader(csrfToken.getHeaderName());		if (actualToken == null) {			actualToken = request.getParameter(csrfToken.getParameterName());		}		if (!csrfToken.getToken().equals(actualToken)) {			if (this.logger.isDebugEnabled()) {				this.logger.debug("Invalid CSRF token found for "						+ UrlUtils.buildFullRequestUrl(request));			}			if (missingToken) {				this.accessDeniedHandler.handle(request, response,						new MissingCsrfTokenException(actualToken));			}			else {				this.accessDeniedHandler.handle(request, response,						new InvalidCsrfTokenException(csrfToken, actualToken));			}			return;		}		filterChain.doFilter(request, response);	}
public void onAuthentication(Authentication authentication,			HttpServletRequest request, HttpServletResponse response)					throws SessionAuthenticationException {		for (SessionAuthenticationStrategy delegate : this.delegateStrategies) {			if (this.logger.isDebugEnabled()) {				this.logger.debug("Delegating to " + delegate);			}			delegate.onAuthentication(authentication, request, response);		}	}
protected List<String> getUserDns(String username) {		if (userDnFormat == null) {			return Collections.emptyList();		}		List<String> userDns = new ArrayList<>(userDnFormat.length);		String[] args = new String[] { LdapEncoder.nameEncode(username) };		synchronized (userDnFormat) {			for (MessageFormat formatter : userDnFormat) {				userDns.add(formatter.format(args));			}		}		return userDns;	}
public void setUserDnPatterns(String[] dnPattern) {		Assert.notNull(dnPattern, "The array of DN patterns cannot be set to null");		// this.userDnPattern = dnPattern;		userDnFormat = new MessageFormat[dnPattern.length];		for (int i = 0; i < dnPattern.length; i++) {			userDnFormat[i] = new MessageFormat(dnPattern[i]);		}	}
public void onApplicationEvent(AbstractAuthorizationEvent event) {		if (event instanceof AuthenticationCredentialsNotFoundEvent) {			AuthenticationCredentialsNotFoundEvent authEvent = (AuthenticationCredentialsNotFoundEvent) event;			if (logger.isWarnEnabled()) {				logger.warn("Security interception failed due to: "						+ authEvent.getCredentialsNotFoundException()						+ "; secure object: " + authEvent.getSource()						+ "; configuration attributes: "						+ authEvent.getConfigAttributes());			}		}		if (event instanceof AuthorizationFailureEvent) {			AuthorizationFailureEvent authEvent = (AuthorizationFailureEvent) event;			if (logger.isWarnEnabled()) {				logger.warn("Security authorization failed due to: "						+ authEvent.getAccessDeniedException()						+ "; authenticated principal: " + authEvent.getAuthentication()						+ "; secure object: " + authEvent.getSource()						+ "; configuration attributes: "						+ authEvent.getConfigAttributes());			}		}		if (event instanceof AuthorizedEvent) {			AuthorizedEvent authEvent = (AuthorizedEvent) event;			if (logger.isInfoEnabled()) {				logger.info("Security authorized for authenticated principal: "						+ authEvent.getAuthentication() + "; secure object: "						+ authEvent.getSource() + "; configuration attributes: "						+ authEvent.getConfigAttributes());			}		}		if (event instanceof PublicInvocationEvent) {			PublicInvocationEvent authEvent = (PublicInvocationEvent) event;			if (logger.isInfoEnabled()) {				logger.info("Security interception not required for public secure object: "						+ authEvent.getSource());			}		}	}
final LinkedHashMap<RequestMatcher, Collection<ConfigAttribute>> createRequestMap() {		if (unmappedMatchers != null) {			throw new IllegalStateException(					"An incomplete mapping was found for "							+ unmappedMatchers							+ ". Try completing it with something like requestUrls().<something>.hasRole('USER')");		}		LinkedHashMap<RequestMatcher, Collection<ConfigAttribute>> requestMap = new LinkedHashMap<RequestMatcher, Collection<ConfigAttribute>>();		for (UrlMapping mapping : getUrlMappings()) {			RequestMatcher matcher = mapping.getRequestMatcher();			Collection<ConfigAttribute> configAttrs = mapping.getConfigAttrs();			requestMap.put(matcher, configAttrs);		}		return requestMap;	}
public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,			Authentication authentication) throws IOException, ServletException {		response.setStatus(this.httpStatusToReturn.value());		response.getWriter().flush();	}
public boolean isAllowed(String uri, Authentication authentication) {		return isAllowed(null, uri, null, authentication);	}
public boolean isAllowed(String contextPath, String uri, String method,			Authentication authentication) {		Assert.notNull(uri, "uri parameter is required");		FilterInvocation fi = new FilterInvocation(contextPath, uri, method);		Collection<ConfigAttribute> attrs = securityInterceptor				.obtainSecurityMetadataSource().getAttributes(fi);		if (attrs == null) {			if (securityInterceptor.isRejectPublicInvocations()) {				return false;			}			return true;		}		if (authentication == null) {			return false;		}		try {			securityInterceptor.getAccessDecisionManager().decide(authentication, fi,					attrs);		}		catch (AccessDeniedException unauthorized) {			if (logger.isDebugEnabled()) {				logger.debug(fi.toString() + " denied for " + authentication.toString(),						unauthorized);			}			return false;		}		return true;	}
@Override	public Map<String, String> extractUriTemplateVariables(HttpServletRequest request) {		MatchableHandlerMapping mapping = getMapping(request);		if (mapping == null) {			return this.defaultMatcher.extractUriTemplateVariables(request);		}		RequestMatchResult result = mapping.match(request, this.pattern);		return result == null ? Collections.<String, String>emptyMap()				: result.extractUriTemplateVariables();	}
@Override	public void init() throws ServletException {		super.init();		String casServiceHost = System.getProperty("cas.service.host", "localhost:8443");		targetUrl = "https://" + casServiceHost + "/cas-sample/secure/";	}
@Override	public long getDateHeader(String name) {		String value = getHeader(name);		if (value == null) {			return -1L;		}		// Attempt to convert the date header in a variety of formats		long result = FastHttpDateFormat.parseDate(value, formats);		if (result != -1L) {			return result;		}		throw new IllegalArgumentException(value);	}
@Override	public String getParameter(String name) {		String value = super.getParameter(name);		if (value != null) {			return value;		}		String[] values = savedRequest.getParameterValues(name);		if (values == null || values.length == 0) {			return null;		}		return values[0];	}
protected Object getPreAuthenticatedPrincipal(HttpServletRequest request) {		String principal = (String) request.getAttribute(principalEnvironmentVariable);		if (principal == null && exceptionIfVariableMissing) {			throw new PreAuthenticatedCredentialsNotFoundException(					principalEnvironmentVariable + " variable not found in request.");		}		return principal;	}
public void onAuthentication(Authentication authentication,			HttpServletRequest request, HttpServletResponse response) {		sessionRegistry.registerNewSession(request.getSession().getId(),				authentication.getPrincipal());	}
public Object invoke(MethodInvocation mi) throws Throwable {		InterceptorStatusToken token = super.beforeInvocation(mi);		Object result;		try {			result = mi.proceed();		}		finally {			super.finallyInvocation(token);		}		return super.afterInvocation(token, result);	}
@Transactional(readOnly = true)	public Contact getRandomContact() {		logger.debug("Returning random contact");		Random rnd = new Random();		List<Contact> contacts = contactDao.findAll();		int getNumber = rnd.nextInt(contacts.size());		return contacts.get(getNumber);	}
public void evictFromCache(Serializable pk) {		Assert.notNull(pk, "Primary key (identifier) required");		MutableAcl acl = getFromCache(pk);		if (acl != null) {			cache.remove(acl.getId());			cache.remove(acl.getObjectIdentity());		}	}
@SuppressWarnings("unchecked")	protected <T> T postProcess(T object) {		return (T) this.objectPostProcessor.postProcess(object);	}
public void onAuthenticationSuccess(HttpServletRequest request,			HttpServletResponse response, Authentication authentication)			throws IOException, ServletException {		handle(request, response, authentication);		clearAuthenticationAttributes(request);	}
protected final void clearAuthenticationAttributes(HttpServletRequest request) {		HttpSession session = request.getSession(false);		if (session == null) {			return;		}		session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);	}
public static Field getField(Class<?> clazz, String fieldName)			throws IllegalStateException {		Assert.notNull(clazz, "Class required");		Assert.hasText(fieldName, "Field name required");		try {			return clazz.getDeclaredField(fieldName);		}		catch (NoSuchFieldException nsf) {			// Try superclass			if (clazz.getSuperclass() != null) {				return getField(clazz.getSuperclass(), fieldName);			}			throw new IllegalStateException("Could not locate field '" + fieldName					+ "' on class " + clazz);		}	}
public static Object getFieldValue(Object bean, String fieldName)			throws IllegalAccessException {		Assert.notNull(bean, "Bean cannot be null");		Assert.hasText(fieldName, "Field name required");		String[] nestedFields = StringUtils.tokenizeToStringArray(fieldName, ".");		Class<?> componentClass = bean.getClass();		Object value = bean;		for (String nestedField : nestedFields) {			Field field = getField(componentClass, nestedField);			field.setAccessible(true);			value = field.get(value);			if (value != null) {				componentClass = value.getClass();			}		}		return value;	}
public void afterPropertiesSet() throws Exception {		Assert.hasLength(this.loginUrl, "loginUrl must be specified");		Assert.notNull(this.serviceProperties, "serviceProperties must be specified");		Assert.notNull(this.serviceProperties.getService(),				"serviceProperties.getService() cannot be null.");	}
protected String createServiceUrl(final HttpServletRequest request,			final HttpServletResponse response) {		return CommonUtils.constructServiceUrl(null, response,				this.serviceProperties.getService(), null,				this.serviceProperties.getArtifactParameter(),				this.encodeServiceUrlWithSessionId);	}
protected String createRedirectUrl(final String serviceUrl) {		return CommonUtils.constructRedirectUrl(this.loginUrl,				this.serviceProperties.getServiceParameter(), serviceUrl,				this.serviceProperties.isSendRenew(), false);	}
public void setHierarchy(String roleHierarchyStringRepresentation) {		this.roleHierarchyStringRepresentation = roleHierarchyStringRepresentation;		logger.debug("setHierarchy() - The following role hierarchy was set: "				+ roleHierarchyStringRepresentation);		buildRolesReachableInOneStepMap();		buildRolesReachableInOneOrMoreStepsMap();	}
private void addReachableRoles(Set<GrantedAuthority> reachableRoles,			GrantedAuthority authority) {		for (GrantedAuthority testAuthority : reachableRoles) {			String testKey = testAuthority.getAuthority();			if ((testKey != null) && (testKey.equals(authority.getAuthority()))) {				return;			}		}		reachableRoles.add(authority);	}
private Set<GrantedAuthority> getRolesReachableInOneOrMoreSteps(			GrantedAuthority authority) {		if (authority.getAuthority() == null) {			return null;		}		for (GrantedAuthority testAuthority : this.rolesReachableInOneOrMoreStepsMap				.keySet()) {			String testKey = testAuthority.getAuthority();			if ((testKey != null) && (testKey.equals(authority.getAuthority()))) {				return this.rolesReachableInOneOrMoreStepsMap.get(testAuthority);			}		}		return null;	}
private void buildRolesReachableInOneStepMap() {		this.rolesReachableInOneStepMap = new HashMap<GrantedAuthority, Set<GrantedAuthority>>();		try (BufferedReader bufferedReader = new BufferedReader(				new StringReader(this.roleHierarchyStringRepresentation))) {			for (String readLine; (readLine = bufferedReader.readLine()) != null;) {				String[] roles = readLine.split(" > ");				for (int i = 1; i < roles.length; i++) {					GrantedAuthority higherRole = new SimpleGrantedAuthority(							roles[i - 1].replaceAll("^\\s+|\\s+$", ""));					GrantedAuthority lowerRole = new SimpleGrantedAuthority(roles[i].replaceAll("^\\s+|\\s+$", ""));					Set<GrantedAuthority> rolesReachableInOneStepSet;					if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) {						rolesReachableInOneStepSet = new HashSet<GrantedAuthority>();						this.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet);					} else {						rolesReachableInOneStepSet = this.rolesReachableInOneStepMap.get(higherRole);					}					addReachableRoles(rolesReachableInOneStepSet, lowerRole);					if (logger.isDebugEnabled()) {						logger.debug("buildRolesReachableInOneStepMap() - From role " + higherRole								+ " one can reach role " + lowerRole + " in one step.");					}				}			}		} catch (IOException e) {			throw new IllegalStateException(e);		}	}
private void buildRolesReachableInOneOrMoreStepsMap() {		this.rolesReachableInOneOrMoreStepsMap = new HashMap<>();		// iterate over all higher roles from rolesReachableInOneStepMap		for (GrantedAuthority role : this.rolesReachableInOneStepMap.keySet()) {			Set<GrantedAuthority> rolesToVisitSet = new HashSet<>();			if (this.rolesReachableInOneStepMap.containsKey(role)) {				rolesToVisitSet.addAll(this.rolesReachableInOneStepMap.get(role));			}			Set<GrantedAuthority> visitedRolesSet = new HashSet<>();			while (!rolesToVisitSet.isEmpty()) {				// take a role from the rolesToVisit set				GrantedAuthority aRole = rolesToVisitSet.iterator().next();				rolesToVisitSet.remove(aRole);				addReachableRoles(visitedRolesSet, aRole);				if (this.rolesReachableInOneStepMap.containsKey(aRole)) {					Set<GrantedAuthority> newReachableRoles = this.rolesReachableInOneStepMap							.get(aRole);					// definition of a cycle: you can reach the role you are starting from					if (rolesToVisitSet.contains(role)							|| visitedRolesSet.contains(role)) {						throw new CycleInRoleHierarchyException();					}					else {						// no cycle						rolesToVisitSet.addAll(newReachableRoles);					}				}			}			this.rolesReachableInOneOrMoreStepsMap.put(role, visitedRolesSet);			logger.debug("buildRolesReachableInOneOrMoreStepsMap() - From role " + role					+ " one can reach " + visitedRolesSet + " in one or more steps.");		}	}
private byte[] iv(byte[] encrypted) {		return this.ivGenerator != NULL_IV_GENERATOR ? subArray(encrypted, 0,				this.ivGenerator.getKeyLength()) : NULL_IV_GENERATOR.generateKey();	}
public LogoutConfigurer<H> addLogoutHandler(LogoutHandler logoutHandler) {		Assert.notNull(logoutHandler, "logoutHandler cannot be null");		this.logoutHandlers.add(logoutHandler);		return this;	}
public LogoutConfigurer<H> logoutSuccessHandler(			LogoutSuccessHandler logoutSuccessHandler) {		this.logoutSuccessUrl = null;		this.customLogoutSuccess = true;		this.logoutSuccessHandler = logoutSuccessHandler;		return this;	}
public LogoutConfigurer<H> defaultLogoutSuccessHandlerFor(			LogoutSuccessHandler handler, RequestMatcher preferredMatcher) {		Assert.notNull(handler, "handler cannot be null");		Assert.notNull(preferredMatcher, "preferredMatcher cannot be null");		this.defaultLogoutSuccessHandlerMappings.put(preferredMatcher, handler);		return this;	}
private LogoutSuccessHandler getLogoutSuccessHandler() {		LogoutSuccessHandler handler = this.logoutSuccessHandler;		if (handler == null) {			handler = createDefaultSuccessHandler();		}		return handler;	}
private LogoutFilter createLogoutFilter(H http) throws Exception {		logoutHandlers.add(contextLogoutHandler);		LogoutHandler[] handlers = logoutHandlers				.toArray(new LogoutHandler[logoutHandlers.size()]);		LogoutFilter result = new LogoutFilter(getLogoutSuccessHandler(), handlers);		result.setLogoutRequestMatcher(getLogoutRequestMatcher(http));		result = postProcess(result);		return result;	}
public Collection<ConfigAttribute> getAttributes(Method method, Class<?> targetClass) {		DefaultCacheKey cacheKey = new DefaultCacheKey(method, targetClass);		synchronized (attributeCache) {			Collection<ConfigAttribute> cached = attributeCache.get(cacheKey);			// Check for canonical value indicating there is no config attribute,			if (cached != null) {				return cached;			}			// No cached value, so query the sources to find a result			Collection<ConfigAttribute> attributes = null;			for (MethodSecurityMetadataSource s : methodSecurityMetadataSources) {				attributes = s.getAttributes(method, targetClass);				if (attributes != null && !attributes.isEmpty()) {					break;				}			}			// Put it in the cache.			if (attributes == null || attributes.isEmpty()) {				this.attributeCache.put(cacheKey, NULL_CONFIG_ATTRIBUTE);				return NULL_CONFIG_ATTRIBUTE;			}			if (logger.isDebugEnabled()) {				logger.debug("Caching method [" + cacheKey + "] with attributes "						+ attributes);			}			this.attributeCache.put(cacheKey, attributes);			return attributes;		}	}
private byte[] combineHashAndSalt(byte[] hash, byte[] salt) {		if (salt == null) {			return hash;		}		byte[] hashAndSalt = new byte[hash.length + salt.length];		System.arraycopy(hash, 0, hashAndSalt, 0, hash.length);		System.arraycopy(salt, 0, hashAndSalt, hash.length, salt.length);		return hashAndSalt;	}
public String encode(CharSequence rawPass) {		byte[] salt = this.saltGenerator.generateKey();		return encode(rawPass, salt);	}
public boolean matches(CharSequence rawPassword, String encodedPassword) {		return matches(rawPassword == null ? null : rawPassword.toString(), encodedPassword);	}
private String extractPrefix(String encPass) {		if (!encPass.startsWith("{")) {			return null;		}		int secondBrace = encPass.lastIndexOf('}');		if (secondBrace < 0) {			throw new IllegalArgumentException(					"Couldn't find closing brace for SHA prefix");		}		return encPass.substring(0, secondBrace + 1);	}
@RequestMapping("/authenticate")	public String authenticate(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException {		boolean authenticate = request.authenticate(response);		return authenticate ? "index" : null;	}
@RequestMapping(value = "/login", method = RequestMethod.POST)	public String login(HttpServletRequest request, HttpServletResponse response,			@ModelAttribute LoginForm loginForm, BindingResult result)			throws ServletException {		try {			request.login(loginForm.getUsername(), loginForm.getPassword());		}		catch (ServletException authenticationFailed) {			result.rejectValue(null, "authentication.failed",					authenticationFailed.getMessage());			return "login";		}		return "redirect:/";	}
@RequestMapping("/logout")	public String logout(HttpServletRequest request, HttpServletResponse response,			RedirectAttributes redirect) throws ServletException {		request.logout();		return "redirect:/";	}
@RequestMapping("/async")	public void asynch(HttpServletRequest request, HttpServletResponse response) {		final AsyncContext async = request.startAsync();		async.start(new Runnable() {			public void run() {				Authentication authentication = SecurityContextHolder.getContext()						.getAuthentication();				try {					final HttpServletResponse asyncResponse = (HttpServletResponse) async							.getResponse();					asyncResponse.setStatus(HttpServletResponse.SC_OK);					asyncResponse.getWriter().write(String.valueOf(authentication));					async.complete();				}				catch (Exception e) {					throw new RuntimeException(e);				}			}		});	}
public void commence(HttpServletRequest request, HttpServletResponse response,			AuthenticationException arg2) throws IOException, ServletException {		if (logger.isDebugEnabled()) {			logger.debug("Pre-authenticated entry point called. Rejecting access");		}		response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");	}
@SuppressWarnings("unchecked")	public Object decide(Authentication authentication, Object object,			Collection<ConfigAttribute> config, Object returnedObject)			throws AccessDeniedException {		if (returnedObject == null) {			logger.debug("Return object is null, skipping");			return null;		}		for (ConfigAttribute attr : config) {			if (!this.supports(attr)) {				continue;			}			// Need to process the Collection for this invocation			Filterer filterer;			if (returnedObject instanceof Collection) {				filterer = new CollectionFilterer((Collection) returnedObject);			}			else if (returnedObject.getClass().isArray()) {				filterer = new ArrayFilterer((Object[]) returnedObject);			}			else {				throw new AuthorizationServiceException(						"A Collection or an array (or null) was required as the "								+ "returnedObject, but the returnedObject was: "								+ returnedObject);			}			// Locate unauthorised Collection elements			for (Object domainObject : filterer) {				// Ignore nulls or entries which aren't instances of the configured domain				// object class				if (domainObject == null						|| !getProcessDomainObjectClass().isAssignableFrom(								domainObject.getClass())) {					continue;				}				if (!hasPermission(authentication, domainObject)) {					filterer.remove(domainObject);					if (logger.isDebugEnabled()) {						logger.debug("Principal is NOT authorised for element: "								+ domainObject);					}				}			}			return filterer.getFilteredObject();		}		return returnedObject;	}
private boolean isNormalized(String path) {		if (path == null) {			return true;		}		for (int j = path.length(); j > 0;) {			int i = path.lastIndexOf('/', j - 1);			int gap = j - i;			if (gap == 2 && path.charAt(i + 1) == '.') {				// ".", "/./" or "/."				return false;			} else if (gap == 3 && path.charAt(i + 1) == '.' && path.charAt(i + 2) == '.') {				return false;			}			j = i;		}		return true;	}
private void checkFilterStack(List<Filter> filters) {		checkForDuplicates(SecurityContextPersistenceFilter.class, filters);		checkForDuplicates(UsernamePasswordAuthenticationFilter.class, filters);		checkForDuplicates(SessionManagementFilter.class, filters);		checkForDuplicates(BasicAuthenticationFilter.class, filters);		checkForDuplicates(SecurityContextHolderAwareRequestFilter.class, filters);		checkForDuplicates(JaasApiIntegrationFilter.class, filters);		checkForDuplicates(ExceptionTranslationFilter.class, filters);		checkForDuplicates(FilterSecurityInterceptor.class, filters);	}
private void checkLoginPageIsntProtected(FilterChainProxy fcp,			List<Filter> filterStack) {		ExceptionTranslationFilter etf = getFilter(ExceptionTranslationFilter.class,				filterStack);		if (etf == null				|| !(etf.getAuthenticationEntryPoint() instanceof LoginUrlAuthenticationEntryPoint)) {			return;		}		String loginPage = ((LoginUrlAuthenticationEntryPoint) etf				.getAuthenticationEntryPoint()).getLoginFormUrl();		logger.info("Checking whether login URL '" + loginPage				+ "' is accessible with your configuration");		FilterInvocation loginRequest = new FilterInvocation(loginPage, "POST");		List<Filter> filters = null;		try {			filters = fcp.getFilters(loginPage);		}		catch (Exception e) {			// May happen legitimately if a filter-chain request matcher requires more			// request data than that provided			// by the dummy request used when creating the filter invocation.			logger.info("Failed to obtain filter chain information for the login page. Unable to complete check.");		}		if (filters == null || filters.isEmpty()) {			logger.debug("Filter chain is empty for the login page");			return;		}		if (getFilter(DefaultLoginPageGeneratingFilter.class, filters) != null) {			logger.debug("Default generated login page is in use");			return;		}		FilterSecurityInterceptor fsi = getFilter(FilterSecurityInterceptor.class,				filters);		FilterInvocationSecurityMetadataSource fids = fsi.getSecurityMetadataSource();		Collection<ConfigAttribute> attributes = fids.getAttributes(loginRequest);		if (attributes == null) {			logger.debug("No access attributes defined for login page URL");			if (fsi.isRejectPublicInvocations()) {				logger.warn("FilterSecurityInterceptor is configured to reject public invocations."						+ " Your login page may not be accessible.");			}			return;		}		AnonymousAuthenticationFilter anonPF = getFilter(				AnonymousAuthenticationFilter.class, filters);		if (anonPF == null) {			logger.warn("The login page is being protected by the filter chain, but you don't appear to have"					+ " anonymous authentication enabled. This is almost certainly an error.");			return;		}		// Simulate an anonymous access with the supplied attributes.		AnonymousAuthenticationToken token = new AnonymousAuthenticationToken("key",				anonPF.getPrincipal(), anonPF.getAuthorities());		try {			fsi.getAccessDecisionManager().decide(token, loginRequest, attributes);		}		catch (AccessDeniedException e) {			logger.warn("Anonymous access to the login page doesn't appear to be enabled. This is almost certainly "					+ "an error. Please check your configuration allows unauthenticated access to the configured "					+ "login page. (Simulated access was rejected: " + e + ")");		}		catch (Exception e) {			// May happen legitimately if a filter-chain request matcher requires more			// request data than that provided			// by the dummy request used when creating the filter invocation. See SEC-1878			logger.info(					"Unable to check access to the login page to determine if anonymous access is allowed. This might be an error, but can happen under normal circumstances.",					e);		}	}
protected final void registerExtractor(Class<? extends Throwable> throwableType,			ThrowableCauseExtractor extractor) {		Assert.notNull(extractor, "Invalid extractor: null");		this.extractorMap.put(throwableType, extractor);	}
@SuppressWarnings("unchecked")	final Class<? extends Throwable>[] getRegisteredTypes() {		Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet();		return typeList.toArray(new Class[typeList.size()]);	}
public final Throwable[] determineCauseChain(Throwable throwable) {		if (throwable == null) {			throw new IllegalArgumentException("Invalid throwable: null");		}		List<Throwable> chain = new ArrayList<>();		Throwable currentThrowable = throwable;		while (currentThrowable != null) {			chain.add(currentThrowable);			currentThrowable = extractCause(currentThrowable);		}		return chain.toArray(new Throwable[chain.size()]);	}
private Throwable extractCause(Throwable throwable) {		for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap				.entrySet()) {			Class<? extends Throwable> throwableType = entry.getKey();			if (throwableType.isInstance(throwable)) {				ThrowableCauseExtractor extractor = entry.getValue();				return extractor.extractCause(throwable);			}		}		return null;	}
public final Throwable getFirstThrowableOfType(			Class<? extends Throwable> throwableType, Throwable[] chain) {		if (chain != null) {			for (Throwable t : chain) {				if ((t != null) && throwableType.isInstance(t)) {					return t;				}			}		}		return null;	}
public static void verifyThrowableHierarchy(Throwable throwable,			Class<? extends Throwable> expectedBaseType) {		if (expectedBaseType == null) {			return;		}		if (throwable == null) {			throw new IllegalArgumentException("Invalid throwable: null");		}		Class<? extends Throwable> throwableType = throwable.getClass();		if (!expectedBaseType.isAssignableFrom(throwableType)) {			throw new IllegalArgumentException("Invalid type: '"					+ throwableType.getName() + "'. Has to be a subclass of '"					+ expectedBaseType.getName() + "'");		}	}
private String[] getProxyImports() {		List<String> result = new ArrayList<>();		result.add(AutoProxyRegistrar.class.getName());		result.add(ReactiveMethodSecurityConfiguration.class.getName());		return result.toArray(new String[result.size()]);	}
@SuppressWarnings({ "unchecked", "rawtypes" })	private String registerAccessManager(ParserContext pc, boolean jsr250Enabled,			BeanDefinition expressionVoter) {		BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder				.rootBeanDefinition(AffirmativeBased.class);		ManagedList voters = new ManagedList(4);		if (expressionVoter != null) {			voters.add(expressionVoter);		}		voters.add(new RootBeanDefinition(RoleVoter.class));		voters.add(new RootBeanDefinition(AuthenticatedVoter.class));		if (jsr250Enabled) {			voters.add(new RootBeanDefinition(Jsr250Voter.class));		}		accessMgrBuilder.addConstructorArgValue(voters);		BeanDefinition accessManager = accessMgrBuilder.getBeanDefinition();		String id = pc.getReaderContext().generateBeanName(accessManager);		pc.registerBeanComponent(new BeanComponentDefinition(accessManager, id));		return id;	}
public void setPolicyDirectives(String policyDirectives) {		Assert.hasLength(policyDirectives, "policyDirectives must not be null or empty");		this.policyDirectives = policyDirectives;		this.delegate = createDelegate();	}
public void setRequestEntityConverter(Converter<OAuth2AuthorizationCodeGrantRequest, RequestEntity<?>> requestEntityConverter) {		Assert.notNull(requestEntityConverter, "requestEntityConverter cannot be null");		this.requestEntityConverter = requestEntityConverter;	}
@SuppressWarnings({ "unchecked" })	public void setAdditionalExceptionMappings(Properties additionalExceptionMappings) {		Assert.notNull(additionalExceptionMappings,				"The exceptionMappings object must not be null");		for (Object exceptionClass : additionalExceptionMappings.keySet()) {			String eventClass = (String) additionalExceptionMappings.get(exceptionClass);			try {				Class<?> clazz = getClass().getClassLoader().loadClass(eventClass);				Assert.isAssignable(AbstractAuthenticationFailureEvent.class, clazz);				addMapping((String) exceptionClass,						(Class<? extends AbstractAuthenticationFailureEvent>) clazz);			}			catch (ClassNotFoundException e) {				throw new RuntimeException("Failed to load authentication event class "						+ eventClass);			}		}	}
public static Consumer<Map<String, Object>> serverWebExchange(ServerWebExchange serverWebExchange) {		return attributes -> attributes.put(SERVER_WEB_EXCHANGE_ATTR_NAME, serverWebExchange);	}
public void sessionCreated(HttpSessionEvent event) {		HttpSessionCreatedEvent e = new HttpSessionCreatedEvent(event.getSession());		Log log = LogFactory.getLog(LOGGER_NAME);		if (log.isDebugEnabled()) {			log.debug("Publishing event: " + e);		}		getContext(event.getSession().getServletContext()).publishEvent(e);	}
public void sessionDestroyed(HttpSessionEvent event) {		HttpSessionDestroyedEvent e = new HttpSessionDestroyedEvent(event.getSession());		Log log = LogFactory.getLog(LOGGER_NAME);		if (log.isDebugEnabled()) {			log.debug("Publishing event: " + e);		}		getContext(event.getSession().getServletContext()).publishEvent(e);	}
public static Set<String> authorityListToSet(			Collection<? extends GrantedAuthority> userAuthorities) {		Assert.notNull(userAuthorities, "userAuthorities cannot be null");		Set<String> set = new HashSet<>(userAuthorities.size());		for (GrantedAuthority authority : userAuthorities) {			set.add(authority.getAuthority());		}		return set;	}
private boolean matches(byte[] expected, byte[] actual) {		if (expected.length != actual.length) {			return false;		}		int result = 0;		for (int i = 0; i < expected.length; i++) {			result |= expected[i] ^ actual[i];		}		return result == 0;	}
@Override	public RequestEntity<?> convert(OAuth2AuthorizationCodeGrantRequest authorizationCodeGrantRequest) {		ClientRegistration clientRegistration = authorizationCodeGrantRequest.getClientRegistration();		HttpHeaders headers = OAuth2AuthorizationGrantRequestEntityUtils.getTokenRequestHeaders(clientRegistration);		MultiValueMap<String, String> formParameters = this.buildFormParameters(authorizationCodeGrantRequest);		URI uri = UriComponentsBuilder.fromUriString(clientRegistration.getProviderDetails().getTokenUri())				.build()				.toUri();		return new RequestEntity<>(formParameters, headers, HttpMethod.POST, uri);	}
private MultiValueMap<String, String> buildFormParameters(OAuth2AuthorizationCodeGrantRequest authorizationCodeGrantRequest) {		ClientRegistration clientRegistration = authorizationCodeGrantRequest.getClientRegistration();		OAuth2AuthorizationExchange authorizationExchange = authorizationCodeGrantRequest.getAuthorizationExchange();		MultiValueMap<String, String> formParameters = new LinkedMultiValueMap<>();		formParameters.add(OAuth2ParameterNames.GRANT_TYPE, authorizationCodeGrantRequest.getGrantType().getValue());		formParameters.add(OAuth2ParameterNames.CODE, authorizationExchange.getAuthorizationResponse().getCode());		String redirectUri = authorizationExchange.getAuthorizationRequest().getRedirectUri();		String codeVerifier = authorizationExchange.getAuthorizationRequest().getAttribute(PkceParameterNames.CODE_VERIFIER);		if (redirectUri != null) {			formParameters.add(OAuth2ParameterNames.REDIRECT_URI, redirectUri);		}		if (!ClientAuthenticationMethod.BASIC.equals(clientRegistration.getClientAuthenticationMethod())) {			formParameters.add(OAuth2ParameterNames.CLIENT_ID, clientRegistration.getClientId());		}		if (ClientAuthenticationMethod.POST.equals(clientRegistration.getClientAuthenticationMethod())) {			formParameters.add(OAuth2ParameterNames.CLIENT_SECRET, clientRegistration.getClientSecret());		}		if (codeVerifier != null) {			formParameters.add(PkceParameterNames.CODE_VERIFIER, codeVerifier);		}		return formParameters;	}
public ImplicitGrantConfigurer<B> authorizationRequestBaseUri(String authorizationRequestBaseUri) {		Assert.hasText(authorizationRequestBaseUri, "authorizationRequestBaseUri cannot be empty");		this.authorizationRequestBaseUri = authorizationRequestBaseUri;		return this;	}
public ImplicitGrantConfigurer<B> clientRegistrationRepository(ClientRegistrationRepository clientRegistrationRepository) {		Assert.notNull(clientRegistrationRepository, "clientRegistrationRepository cannot be null");		this.getBuilder().setSharedObject(ClientRegistrationRepository.class, clientRegistrationRepository);		return this;	}
public void onAuthenticationFailure(HttpServletRequest request,			HttpServletResponse response, AuthenticationException exception)			throws IOException, ServletException {		if (defaultFailureUrl == null) {			logger.debug("No failure URL set, sending 401 Unauthorized error");			response.sendError(HttpStatus.UNAUTHORIZED.value(),				HttpStatus.UNAUTHORIZED.getReasonPhrase());		}		else {			saveException(request, exception);			if (forwardToDestination) {				logger.debug("Forwarding to " + defaultFailureUrl);				request.getRequestDispatcher(defaultFailureUrl)						.forward(request, response);			}			else {				logger.debug("Redirecting to " + defaultFailureUrl);				redirectStrategy.sendRedirect(request, response, defaultFailureUrl);			}		}	}
protected final void saveException(HttpServletRequest request,			AuthenticationException exception) {		if (forwardToDestination) {			request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);		}		else {			HttpSession session = request.getSession(false);			if (session != null || allowSessionCreation) {				request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,						exception);			}		}	}
public void setDefaultFailureUrl(String defaultFailureUrl) {		Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl),				() -> "'" + defaultFailureUrl + "' is not a valid redirect URL");		this.defaultFailureUrl = defaultFailureUrl;	}
public Authentication authenticate(Authentication authentication)			throws AuthenticationException {		if (!supports(authentication.getClass())) {			return null;		}		if (logger.isDebugEnabled()) {			logger.debug("PreAuthenticated authentication request: " + authentication);		}		if (authentication.getPrincipal() == null) {			logger.debug("No pre-authenticated principal found in request.");			if (throwExceptionWhenTokenRejected) {				throw new BadCredentialsException(						"No pre-authenticated principal found in request.");			}			return null;		}		if (authentication.getCredentials() == null) {			logger.debug("No pre-authenticated credentials found in request.");			if (throwExceptionWhenTokenRejected) {				throw new BadCredentialsException(						"No pre-authenticated credentials found in request.");			}			return null;		}		UserDetails ud = preAuthenticatedUserDetailsService				.loadUserDetails((PreAuthenticatedAuthenticationToken) authentication);		userDetailsChecker.check(ud);		PreAuthenticatedAuthenticationToken result = new PreAuthenticatedAuthenticationToken(				ud, authentication.getCredentials(), ud.getAuthorities());		result.setDetails(authentication.getDetails());		return result;	}
public void setResolveHiddenInputs(			Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) {		Assert.notNull(resolveHiddenInputs, "resolveHiddenInputs cannot be null");		this.resolveHiddenInputs = resolveHiddenInputs;	}
@Override	public Authentication authenticate(Authentication authentication) throws AuthenticationException {		if (!(authentication instanceof BearerTokenAuthenticationToken)) {			return null;		}		BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken) authentication;		Map<String, Object> claims;		try {			claims = this.introspectionClient.introspect(bearer.getToken());		} catch (OAuth2IntrospectionException failed) {			OAuth2Error invalidToken = invalidToken(failed.getMessage());			throw new OAuth2AuthenticationException(invalidToken);		}		AbstractAuthenticationToken result = convert(bearer.getToken(), claims);		result.setDetails(bearer.getDetails());		return result;	}
public final UserDetails loadUserDetails(PreAuthenticatedAuthenticationToken token)			throws AuthenticationException {		Assert.notNull(token.getDetails(), "token.getDetails() cannot be null");		Assert.isInstanceOf(GrantedAuthoritiesContainer.class, token.getDetails());		Collection<? extends GrantedAuthority> authorities = ((GrantedAuthoritiesContainer) token				.getDetails()).getGrantedAuthorities();		return createUserDetails(token, authorities);	}
protected UserDetails createUserDetails(Authentication token,			Collection<? extends GrantedAuthority> authorities) {		return new User(token.getName(), "N/A", true, true, true, true, authorities);	}
public static OAuth2TokenValidatorResult failure(Collection<OAuth2Error> errors) {		if (errors.isEmpty()) {			return NO_ERRORS;		}		return new OAuth2TokenValidatorResult(errors);	}
private RequestCache getRequestCache(H http) {		RequestCache result = http.getSharedObject(RequestCache.class);		if (result != null) {			return result;		}		result = getBeanOrNull(RequestCache.class);		if (result != null) {			return result;		}		HttpSessionRequestCache defaultCache = new HttpSessionRequestCache();		defaultCache.setRequestMatcher(createDefaultSavedRequestMatcher(http));		return defaultCache;	}
public static String buildFullRequestUrl(HttpServletRequest r) {		return buildFullRequestUrl(r.getScheme(), r.getServerName(), r.getServerPort(),				r.getRequestURI(), r.getQueryString());	}
public static String buildFullRequestUrl(String scheme, String serverName,			int serverPort, String requestURI, String queryString) {		scheme = scheme.toLowerCase();		StringBuilder url = new StringBuilder();		url.append(scheme).append("://").append(serverName);		// Only add port if not default		if ("http".equals(scheme)) {			if (serverPort != 80) {				url.append(":").append(serverPort);			}		}		else if ("https".equals(scheme)) {			if (serverPort != 443) {				url.append(":").append(serverPort);			}		}		// Use the requestURI as it is encoded (RFC 3986) and hence suitable for		// redirects.		url.append(requestURI);		if (queryString != null) {			url.append("?").append(queryString);		}		return url.toString();	}
public static String buildRequestUrl(HttpServletRequest r) {		return buildRequestUrl(r.getServletPath(), r.getRequestURI(), r.getContextPath(),				r.getPathInfo(), r.getQueryString());	}
private static String buildRequestUrl(String servletPath, String requestURI,			String contextPath, String pathInfo, String queryString) {		StringBuilder url = new StringBuilder();		if (servletPath != null) {			url.append(servletPath);			if (pathInfo != null) {				url.append(pathInfo);			}		}		else {			url.append(requestURI.substring(contextPath.length()));		}		if (queryString != null) {			url.append("?").append(queryString);		}		return url.toString();	}
public static boolean isAbsoluteUrl(String url) {		if (url == null) {			return false;		}		final Pattern ABSOLUTE_URL = Pattern.compile("\\A[a-z0-9.+-]+://.*",				Pattern.CASE_INSENSITIVE);		return ABSOLUTE_URL.matcher(url).matches();	}
public List<OpenIDAttribute> createAttributeList(String identifier) {		for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) {			if (entry.getKey().matcher(identifier).matches()) {				return entry.getValue();			}		}		return Collections.emptyList();	}
@Override	public void afterPropertiesSet() {		Assert.hasLength(key, "key must have length");		Assert.notNull(principal, "Anonymous authentication principal must be set");		Assert.notNull(authorities, "Anonymous authorities must be set");	}
public static String printBinary(int mask, char code) {		Assert.doesNotContain(Character.toString(code),				Character.toString(Permission.RESERVED_ON),				() -> Permission.RESERVED_ON + " is a reserved character code");		Assert.doesNotContain(Character.toString(code),				Character.toString(Permission.RESERVED_OFF),				() -> Permission.RESERVED_OFF + " is a reserved character code");		return printBinary(mask, Permission.RESERVED_ON, Permission.RESERVED_OFF)				.replace(Permission.RESERVED_ON, code);	}
Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException {		if (isString(identifier) && hasValidClassIdType(resultSet)			&& canConvertFromStringTo(classIdTypeFrom(resultSet))) {			identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet));		} else {			// Assume it should be a Long type			identifier = convertToLong(identifier);		}		return identifier;	}
private Long convertToLong(Serializable identifier) {		Long idAsLong;		if (canConvertFromStringTo(Long.class)) {			idAsLong = conversionService.convert(identifier, Long.class);		} else {			idAsLong = Long.valueOf(identifier.toString());		}		return idAsLong;	}
@Deprecated	public static UserBuilder withDefaultPasswordEncoder() {		logger.warn("User.withDefaultPasswordEncoder() is considered unsafe for production and is only intended for sample applications.");		PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();		return builder().passwordEncoder(encoder::encode);	}
public static ClientRegistration.Builder fromOidcIssuerLocation(String issuer) {		String openidConfiguration = getOpenidConfiguration(issuer);		OIDCProviderMetadata metadata = parse(openidConfiguration);		String metadataIssuer = metadata.getIssuer().getValue();		if (!issuer.equals(metadataIssuer)) {			throw new IllegalStateException("The Issuer \"" + metadataIssuer + "\" provided in the OpenID Configuration did not match the requested issuer \"" + issuer + "\"");		}		String name = URI.create(issuer).getHost();		ClientAuthenticationMethod method = getClientAuthenticationMethod(issuer, metadata.getTokenEndpointAuthMethods());		List<GrantType> grantTypes = metadata.getGrantTypes();		// If null, the default includes authorization_code		if (grantTypes != null && !grantTypes.contains(GrantType.AUTHORIZATION_CODE)) {			throw new IllegalArgumentException("Only AuthorizationGrantType.AUTHORIZATION_CODE is supported. The issuer \"" + issuer + "\" returned a configuration of " + grantTypes);		}		List<String> scopes = getScopes(metadata);		Map<String, Object> configurationMetadata = new LinkedHashMap<>(metadata.toJSONObject());		return ClientRegistration.withRegistrationId(name)				.userNameAttributeName(IdTokenClaimNames.SUB)				.scope(scopes)				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)				.clientAuthenticationMethod(method)				.redirectUriTemplate("{baseUrl}/{action}/oauth2/code/{registrationId}")				.authorizationUri(metadata.getAuthorizationEndpointURI().toASCIIString())				.jwkSetUri(metadata.getJWKSetURI().toASCIIString())				.providerConfigurationMetadata(configurationMetadata)				.userInfoUri(metadata.getUserInfoEndpointURI().toASCIIString())				.tokenUri(metadata.getTokenEndpointURI().toASCIIString())				.clientName(issuer);	}
public Authentication buildRunAs(Authentication authentication, Object object,			Collection<ConfigAttribute> config) {		return null;	}
@Override	public Mono<Void> logout(WebFilterExchange exchange, Authentication authentication) {		return this.csrfTokenRepository.saveToken(exchange.getExchange(), null);	}
public ExceptionHandlingConfigurer<H> accessDeniedPage(String accessDeniedUrl) {		AccessDeniedHandlerImpl accessDeniedHandler = new AccessDeniedHandlerImpl();		accessDeniedHandler.setErrorPage(accessDeniedUrl);		return accessDeniedHandler(accessDeniedHandler);	}
public ExceptionHandlingConfigurer<H> defaultAccessDeniedHandlerFor(			AccessDeniedHandler deniedHandler, RequestMatcher preferredMatcher) {		this.defaultDeniedHandlerMappings.put(preferredMatcher, deniedHandler);		return this;	}
public ExceptionHandlingConfigurer<H> defaultAuthenticationEntryPointFor(			AuthenticationEntryPoint entryPoint, RequestMatcher preferredMatcher) {		this.defaultEntryPointMappings.put(preferredMatcher, entryPoint);		return this;	}
AccessDeniedHandler getAccessDeniedHandler(H http) {		AccessDeniedHandler deniedHandler = this.accessDeniedHandler;		if (deniedHandler == null) {			deniedHandler = createDefaultDeniedHandler(http);		}		return deniedHandler;	}
AuthenticationEntryPoint getAuthenticationEntryPoint(H http) {		AuthenticationEntryPoint entryPoint = this.authenticationEntryPoint;		if (entryPoint == null) {			entryPoint = createDefaultEntryPoint(http);		}		return entryPoint;	}
private RequestCache getRequestCache(H http) {		RequestCache result = http.getSharedObject(RequestCache.class);		if (result != null) {			return result;		}		return new HttpSessionRequestCache();	}
public static String roleHierarchyFromMap(Map<String, List<String>> roleHierarchyMap) {		Assert.notEmpty(roleHierarchyMap, "roleHierarchyMap cannot be empty");		StringWriter roleHierarchyBuffer = new StringWriter();		PrintWriter roleHierarchyWriter = new PrintWriter(roleHierarchyBuffer);		for (Map.Entry<String, List<String>> roleHierarchyEntry : roleHierarchyMap.entrySet()) {			String role = roleHierarchyEntry.getKey();			List<String> impliedRoles = roleHierarchyEntry.getValue();			Assert.hasLength(role, "role name must be supplied");			Assert.notEmpty(impliedRoles, "implied role name(s) cannot be empty");			for (String impliedRole : impliedRoles) {				String roleMapping = role + " > " + impliedRole;				roleHierarchyWriter.println(roleMapping);			}		}		return roleHierarchyBuffer.toString();	}
public MutableAcl createAcl(ObjectIdentity objectIdentity)			throws AlreadyExistsException {		Assert.notNull(objectIdentity, "Object Identity required");		// Check this object identity hasn't already been persisted		if (retrieveObjectIdentityPrimaryKey(objectIdentity) != null) {			throw new AlreadyExistsException("Object identity '" + objectIdentity					+ "' already exists");		}		// Need to retrieve the current principal, in order to know who "owns" this ACL		// (can be changed later on)		Authentication auth = SecurityContextHolder.getContext().getAuthentication();		PrincipalSid sid = new PrincipalSid(auth);		// Create the acl_object_identity row		createObjectIdentity(objectIdentity, sid);		// Retrieve the ACL via superclass (ensures cache registration, proper retrieval		// etc)		Acl acl = readAclById(objectIdentity);		Assert.isInstanceOf(MutableAcl.class, acl, "MutableAcl should be been returned");		return (MutableAcl) acl;	}
protected void createEntries(final MutableAcl acl) {		if (acl.getEntries().isEmpty()) {			return;		}		jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() {			public int getBatchSize() {				return acl.getEntries().size();			}			public void setValues(PreparedStatement stmt, int i) throws SQLException {				AccessControlEntry entry_ = acl.getEntries().get(i);				Assert.isTrue(entry_ instanceof AccessControlEntryImpl,						"Unknown ACE class");				AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_;				stmt.setLong(1, ((Long) acl.getId()).longValue());				stmt.setInt(2, i);				stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true)						.longValue());				stmt.setInt(4, entry.getPermission().getMask());				stmt.setBoolean(5, entry.isGranting());				stmt.setBoolean(6, entry.isAuditSuccess());				stmt.setBoolean(7, entry.isAuditFailure());			}		});	}
protected void createObjectIdentity(ObjectIdentity object, Sid owner) {		Long sidId = createOrRetrieveSidPrimaryKey(owner, true);		Long classId = createOrRetrieveClassPrimaryKey(object.getType(), true, object.getIdentifier().getClass());		jdbcOperations.update(insertObjectIdentity, classId, object.getIdentifier().toString(), sidId,				Boolean.TRUE);	}
protected Long createOrRetrieveClassPrimaryKey(String type, boolean allowCreate, Class idType) {		List<Long> classIds = jdbcOperations.queryForList(selectClassPrimaryKey,				new Object[] { type }, Long.class);		if (!classIds.isEmpty()) {			return classIds.get(0);		}		if (allowCreate) {			if (!isAclClassIdSupported()) {				jdbcOperations.update(insertClass, type);			} else {				jdbcOperations.update(insertClass, type, idType.getCanonicalName());			}			Assert.isTrue(TransactionSynchronizationManager.isSynchronizationActive(),					"Transaction must be running");			return jdbcOperations.queryForObject(classIdentityQuery, Long.class);		}		return null;	}
protected Long createOrRetrieveSidPrimaryKey(Sid sid, boolean allowCreate) {		Assert.notNull(sid, "Sid required");		String sidName;		boolean sidIsPrincipal = true;		if (sid instanceof PrincipalSid) {			sidName = ((PrincipalSid) sid).getPrincipal();		}		else if (sid instanceof GrantedAuthoritySid) {			sidName = ((GrantedAuthoritySid) sid).getGrantedAuthority();			sidIsPrincipal = false;		}		else {			throw new IllegalArgumentException("Unsupported implementation of Sid");		}		return createOrRetrieveSidPrimaryKey(sidName, sidIsPrincipal, allowCreate);	}
protected Long createOrRetrieveSidPrimaryKey(String sidName, boolean sidIsPrincipal,			boolean allowCreate) {		List<Long> sidIds = jdbcOperations.queryForList(selectSidPrimaryKey, new Object[] {				Boolean.valueOf(sidIsPrincipal), sidName }, Long.class);		if (!sidIds.isEmpty()) {			return sidIds.get(0);		}		if (allowCreate) {			jdbcOperations.update(insertSid, Boolean.valueOf(sidIsPrincipal), sidName);			Assert.isTrue(TransactionSynchronizationManager.isSynchronizationActive(),					"Transaction must be running");			return jdbcOperations.queryForObject(sidIdentityQuery, Long.class);		}		return null;	}
protected Long retrieveObjectIdentityPrimaryKey(ObjectIdentity oid) {		try {			return jdbcOperations.queryForObject(selectObjectIdentityPrimaryKey, Long.class,					oid.getType(), oid.getIdentifier().toString());		}		catch (DataAccessException notFound) {			return null;		}	}
public MutableAcl updateAcl(MutableAcl acl) throws NotFoundException {		Assert.notNull(acl.getId(), "Object Identity doesn't provide an identifier");		// Delete this ACL's ACEs in the acl_entry table		deleteEntries(retrieveObjectIdentityPrimaryKey(acl.getObjectIdentity()));		// Create this ACL's ACEs in the acl_entry table		createEntries(acl);		// Change the mutable columns in acl_object_identity		updateObjectIdentity(acl);		// Clear the cache, including children		clearCacheIncludingChildren(acl.getObjectIdentity());		// Retrieve the ACL via superclass (ensures cache registration, proper retrieval		// etc)		return (MutableAcl) super.readAclById(acl.getObjectIdentity());	}
protected void updateObjectIdentity(MutableAcl acl) {		Long parentId = null;		if (acl.getParentAcl() != null) {			Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl()					.getObjectIdentity(),					"Implementation only supports ObjectIdentityImpl");			ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl()					.getObjectIdentity();			parentId = retrieveObjectIdentityPrimaryKey(oii);		}		Assert.notNull(acl.getOwner(), "Owner is required in this implementation");		Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true);		int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid,				Boolean.valueOf(acl.isEntriesInheriting()), acl.getId());		if (count != 1) {			throw new NotFoundException("Unable to locate ACL to update");		}	}
public void saveRequest(HttpServletRequest request, HttpServletResponse response) {		if (requestMatcher.matches(request)) {			DefaultSavedRequest savedRequest = new DefaultSavedRequest(request,					portResolver);			if (createSessionAllowed || request.getSession(false) != null) {				// Store the HTTP request itself. Used by				// AbstractAuthenticationProcessingFilter				// for redirection after successful authentication (SEC-29)				request.getSession().setAttribute(this.sessionAttrName, savedRequest);				logger.debug("DefaultSavedRequest added to Session: " + savedRequest);			}		}		else {			logger.debug("Request not saved as configured RequestMatcher did not match");		}	}
public static <V> Callable<V> create(Callable<V> delegate,			SecurityContext securityContext) {		return securityContext == null ? new DelegatingSecurityContextCallable<>(				delegate) : new DelegatingSecurityContextCallable<>(delegate,				securityContext);	}
public void setLogoutHandlers(List<LogoutHandler> logoutHandlers) {		this.logoutHandler = CollectionUtils.isEmpty(logoutHandlers) ? null : new CompositeLogoutHandler(logoutHandlers);	}
public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) {		List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length);		for (String pattern : patterns) {			matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method));		}		return new OrServerWebExchangeMatcher(matchers);	}
public static ServerWebExchangeMatcher anyExchange() {		// we don't use a lambda to ensure a unique equals and hashcode		// which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap		return new ServerWebExchangeMatcher() {			@Override			public Mono<MatchResult> matches(ServerWebExchange exchange) {				return ServerWebExchangeMatcher.MatchResult.match();			}		};	}
public static BytesEncryptor stronger(CharSequence password, CharSequence salt) {		return new AesBytesEncryptor(password.toString(), salt,				KeyGenerators.secureRandom(16), CipherAlgorithm.GCM);	}
public static BytesEncryptor standard(CharSequence password, CharSequence salt) {		return new AesBytesEncryptor(password.toString(), salt,				KeyGenerators.secureRandom(16));	}
public static TextEncryptor delux(CharSequence password, CharSequence salt) {		return new HexEncodingTextEncryptor(stronger(password, salt));	}
public static TextEncryptor text(CharSequence password, CharSequence salt) {		return new HexEncodingTextEncryptor(standard(password, salt));	}
public static TextEncryptor queryableText(CharSequence password, CharSequence salt) {		return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(),				salt));	}
public WebSecurity expressionHandler(			SecurityExpressionHandler<FilterInvocation> expressionHandler) {		Assert.notNull(expressionHandler, "expressionHandler cannot be null");		this.expressionHandler = expressionHandler;		return this;	}
public WebInvocationPrivilegeEvaluator getPrivilegeEvaluator() {		if (privilegeEvaluator != null) {			return privilegeEvaluator;		}		return filterSecurityInterceptor == null ? null				: new DefaultWebInvocationPrivilegeEvaluator(filterSecurityInterceptor);	}
public void decide(Authentication authentication, Object object,			Collection<ConfigAttribute> attributes) throws AccessDeniedException {		int grant = 0;		List<ConfigAttribute> singleAttributeList = new ArrayList<>(1);		singleAttributeList.add(null);		for (ConfigAttribute attribute : attributes) {			singleAttributeList.set(0, attribute);			for (AccessDecisionVoter voter : getDecisionVoters()) {				int result = voter.vote(authentication, object, singleAttributeList);				if (logger.isDebugEnabled()) {					logger.debug("Voter: " + voter + ", returned: " + result);				}				switch (result) {				case AccessDecisionVoter.ACCESS_GRANTED:					grant++;					break;				case AccessDecisionVoter.ACCESS_DENIED:					throw new AccessDeniedException(messages.getMessage(							"AbstractAccessDecisionManager.accessDenied",							"Access is denied"));				default:					break;				}			}		}		// To get this far, there were no deny votes		if (grant > 0) {			return;		}		// To get this far, every AccessDecisionVoter abstained		checkAllowIfAllAbstainDecisions();	}
@SuppressWarnings("deprecation")	public static PasswordEncoder createDelegatingPasswordEncoder() {		String encodingId = "bcrypt";		Map<String, PasswordEncoder> encoders = new HashMap<>();		encoders.put(encodingId, new BCryptPasswordEncoder());		encoders.put("ldap", new org.springframework.security.crypto.password.LdapShaPasswordEncoder());		encoders.put("MD4", new org.springframework.security.crypto.password.Md4PasswordEncoder());		encoders.put("MD5", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder("MD5"));		encoders.put("noop", org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());		encoders.put("pbkdf2", new Pbkdf2PasswordEncoder());		encoders.put("scrypt", new SCryptPasswordEncoder());		encoders.put("SHA-1", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder("SHA-1"));		encoders.put("SHA-256", new org.springframework.security.crypto.password.MessageDigestPasswordEncoder("SHA-256"));		encoders.put("sha256", new org.springframework.security.crypto.password.StandardPasswordEncoder());		return new DelegatingPasswordEncoder(encodingId, encoders);	}
@Override	public void handle(			HttpServletRequest request, HttpServletResponse response,			AccessDeniedException accessDeniedException)			throws IOException, ServletException {		Map<String, String> parameters = new LinkedHashMap<>();		if (this.realmName != null) {			parameters.put("realm", this.realmName);		}		if (request.getUserPrincipal() instanceof AbstractOAuth2TokenAuthenticationToken) {			AbstractOAuth2TokenAuthenticationToken token =					(AbstractOAuth2TokenAuthenticationToken) request.getUserPrincipal();			String scope = getScope(token);			parameters.put("error", BearerTokenErrorCodes.INSUFFICIENT_SCOPE);			parameters.put("error_description",					String.format("The token provided has insufficient scope [%s] for this request", scope));			parameters.put("error_uri", "https://tools.ietf.org/html/rfc6750#section-3.1");			if (StringUtils.hasText(scope)) {				parameters.put("scope", scope);			}		}		String wwwAuthenticate = computeWWWAuthenticateHeaderValue(parameters);		response.addHeader(HttpHeaders.WWW_AUTHENTICATE, wwwAuthenticate);		response.setStatus(HttpStatus.FORBIDDEN.value());	}
public void writeHeaders(HttpServletRequest request, HttpServletResponse response) {		if (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) {			String allowFromValue = this.allowFromStrategy.getAllowFromValue(request);			if (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) {				if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) {					response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode());				}			} else if (allowFromValue != null) {				if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) {					response.setHeader(XFRAME_OPTIONS_HEADER,							XFrameOptionsMode.ALLOW_FROM.getMode() + " " + allowFromValue);				}			}		}		else {			response.setHeader(XFRAME_OPTIONS_HEADER, frameOptionsMode.getMode());		}	}
public final void doFilter(final ServletRequest request,			final ServletResponse response, final FilterChain chain)			throws ServletException, IOException {		Subject subject = obtainSubject(request);		if (subject == null && createEmptySubject) {			if (logger.isDebugEnabled()) {				logger.debug("Subject returned was null and createEmtpySubject is true; creating new empty subject to run as.");			}			subject = new Subject();		}		if (subject == null) {			if (logger.isDebugEnabled()) {				logger.debug("Subject is null continue running with no Subject.");			}			chain.doFilter(request, response);			return;		}		final PrivilegedExceptionAction<Object> continueChain = new PrivilegedExceptionAction<Object>() {			public Object run() throws IOException, ServletException {				chain.doFilter(request, response);				return null;			}		};		if (logger.isDebugEnabled()) {			logger.debug("Running as Subject " + subject);		}		try {			Subject.doAs(subject, continueChain);		}		catch (PrivilegedActionException e) {			throw new ServletException(e.getMessage(), e);		}	}
protected Subject obtainSubject(ServletRequest request) {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (logger.isDebugEnabled()) {			logger.debug("Attempting to obtainSubject using authentication : "					+ authentication);		}		if (authentication == null) {			return null;		}		if (!authentication.isAuthenticated()) {			return null;		}		if (!(authentication instanceof JaasAuthenticationToken)) {			return null;		}		JaasAuthenticationToken token = (JaasAuthenticationToken) authentication;		LoginContext loginContext = token.getLoginContext();		if (loginContext == null) {			return null;		}		return loginContext.getSubject();	}
public CsrfConfigurer<H> csrfTokenRepository(			CsrfTokenRepository csrfTokenRepository) {		Assert.notNull(csrfTokenRepository, "csrfTokenRepository cannot be null");		this.csrfTokenRepository = csrfTokenRepository;		return this;	}
public CsrfConfigurer<H> requireCsrfProtectionMatcher(			RequestMatcher requireCsrfProtectionMatcher) {		Assert.notNull(requireCsrfProtectionMatcher,				"requireCsrfProtectionMatcher cannot be null");		this.requireCsrfProtectionMatcher = requireCsrfProtectionMatcher;		return this;	}
public CsrfConfigurer<H> ignoringAntMatchers(String... antPatterns) {		return new IgnoreCsrfProtectionRegistry(this.context).antMatchers(antPatterns)				.and();	}
public CsrfConfigurer<H> ignoringRequestMatchers(RequestMatcher... requestMatchers) {		return new IgnoreCsrfProtectionRegistry(this.context).requestMatchers(requestMatchers)				.and();	}
private RequestMatcher getRequireCsrfProtectionMatcher() {		if (this.ignoredCsrfProtectionMatchers.isEmpty()) {			return this.requireCsrfProtectionMatcher;		}		return new AndRequestMatcher(this.requireCsrfProtectionMatcher,				new NegatedRequestMatcher(						new OrRequestMatcher(this.ignoredCsrfProtectionMatchers)));	}
@SuppressWarnings("unchecked")	private AccessDeniedHandler getDefaultAccessDeniedHandler(H http) {		ExceptionHandlingConfigurer<H> exceptionConfig = http				.getConfigurer(ExceptionHandlingConfigurer.class);		AccessDeniedHandler handler = null;		if (exceptionConfig != null) {			handler = exceptionConfig.getAccessDeniedHandler();		}		if (handler == null) {			handler = new AccessDeniedHandlerImpl();		}		return handler;	}
@SuppressWarnings("unchecked")	private InvalidSessionStrategy getInvalidSessionStrategy(H http) {		SessionManagementConfigurer<H> sessionManagement = http				.getConfigurer(SessionManagementConfigurer.class);		if (sessionManagement == null) {			return null;		}		return sessionManagement.getInvalidSessionStrategy();	}
private AccessDeniedHandler createAccessDeniedHandler(H http) {		InvalidSessionStrategy invalidSessionStrategy = getInvalidSessionStrategy(http);		AccessDeniedHandler defaultAccessDeniedHandler = getDefaultAccessDeniedHandler(				http);		if (invalidSessionStrategy == null) {			return defaultAccessDeniedHandler;		}		InvalidSessionAccessDeniedHandler invalidSessionDeniedHandler = new InvalidSessionAccessDeniedHandler(				invalidSessionStrategy);		LinkedHashMap<Class<? extends AccessDeniedException>, AccessDeniedHandler> handlers = new LinkedHashMap<Class<? extends AccessDeniedException>, AccessDeniedHandler>();		handlers.put(MissingCsrfTokenException.class, invalidSessionDeniedHandler);		return new DelegatingAccessDeniedHandler(handlers, defaultAccessDeniedHandler);	}
protected void handle(HttpServletRequest request, HttpServletResponse response,			Authentication authentication) throws IOException, ServletException {		String targetUrl = determineTargetUrl(request, response, authentication);		if (response.isCommitted()) {			logger.debug("Response has already been committed. Unable to redirect to "					+ targetUrl);			return;		}		redirectStrategy.sendRedirect(request, response, targetUrl);	}
protected String determineTargetUrl(HttpServletRequest request,			HttpServletResponse response, Authentication authentication) {		return determineTargetUrl(request, response);	}
protected String determineTargetUrl(HttpServletRequest request,			HttpServletResponse response) {		if (isAlwaysUseDefaultTargetUrl()) {			return defaultTargetUrl;		}		// Check for the parameter and use that if available		String targetUrl = null;		if (targetUrlParameter != null) {			targetUrl = request.getParameter(targetUrlParameter);			if (StringUtils.hasText(targetUrl)) {				logger.debug("Found targetUrlParameter in request: " + targetUrl);				return targetUrl;			}		}		if (useReferer && !StringUtils.hasLength(targetUrl)) {			targetUrl = request.getHeader("Referer");			logger.debug("Using Referer header: " + targetUrl);		}		if (!StringUtils.hasText(targetUrl)) {			targetUrl = defaultTargetUrl;			logger.debug("Using default Url: " + targetUrl);		}		return targetUrl;	}
public void setDefaultTargetUrl(String defaultTargetUrl) {		Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultTargetUrl),				"defaultTarget must start with '/' or with 'http(s)'");		this.defaultTargetUrl = defaultTargetUrl;	}
public void setTargetUrlParameter(String targetUrlParameter) {		if (targetUrlParameter != null) {			Assert.hasText(targetUrlParameter, "targetUrlParameter cannot be empty");		}		this.targetUrlParameter = targetUrlParameter;	}
private Directory getDirectoryWithImmediateParentPopulated(final Long id) {		return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE,				new Object[] { id }, new RowMapper<Directory>() {					public Directory mapRow(ResultSet rs, int rowNumber)							throws SQLException {						Long parentDirectoryId = new Long(rs								.getLong("parent_directory_id"));						Directory parentDirectory = Directory.ROOT_DIRECTORY;						if (parentDirectoryId != null								&& !parentDirectoryId.equals(new Long(-1))) {							// Need to go and lookup the parent, so do that first							parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId);						}						Directory directory = new Directory(rs								.getString("directory_name"), parentDirectory);						FieldUtils.setProtectedFieldValue("id", directory,								new Long(rs.getLong("id")));						return directory;					}				});	}
protected Object getPreAuthenticatedPrincipal(HttpServletRequest request) {		String principal = request.getHeader(principalRequestHeader);		if (principal == null && exceptionIfHeaderMissing) {			throw new PreAuthenticatedCredentialsNotFoundException(principalRequestHeader					+ " header not found in request.");		}		return principal;	}
public void invokeContactManager(Authentication authentication, int nrOfCalls) {		StopWatch stopWatch = new StopWatch(nrOfCalls + " ContactManager call(s)");		Map<String, ContactManager> contactServices = this.beanFactory.getBeansOfType(				ContactManager.class, true, true);		SecurityContextHolder.getContext().setAuthentication(authentication);		for (Map.Entry<String, ContactManager> entry : contactServices.entrySet()) {			String beanName = entry.getKey();			ContactManager remoteContactManager = entry.getValue();			Object object = this.beanFactory.getBean("&" + beanName);			try {				System.out.println("Trying to find setUsername(String) method on: "						+ object.getClass().getName());				Method method = object.getClass().getMethod("setUsername",						new Class[] { String.class });				System.out.println("Found; Trying to setUsername(String) to "						+ authentication.getPrincipal());				method.invoke(object, authentication.getPrincipal());			}			catch (NoSuchMethodException ignored) {				System.out						.println("This client proxy factory does not have a setUsername(String) method");			}			catch (IllegalAccessException ignored) {				ignored.printStackTrace();			}			catch (InvocationTargetException ignored) {				ignored.printStackTrace();			}			try {				System.out.println("Trying to find setPassword(String) method on: "						+ object.getClass().getName());				Method method = object.getClass().getMethod("setPassword",						new Class[] { String.class });				method.invoke(object, authentication.getCredentials());				System.out.println("Found; Trying to setPassword(String) to "						+ authentication.getCredentials());			}			catch (NoSuchMethodException ignored) {				System.out						.println("This client proxy factory does not have a setPassword(String) method");			}			catch (IllegalAccessException ignored) {			}			catch (InvocationTargetException ignored) {			}			System.out.println("Calling ContactManager '" + beanName + "'");			stopWatch.start(beanName);			List<Contact> contacts = null;			for (int i = 0; i < nrOfCalls; i++) {				contacts = remoteContactManager.getAll();			}			stopWatch.stop();			if (contacts.size() != 0) {				for (Contact contact : contacts) {					System.out.println("Contact: " + contact);				}			}			else {				System.out.println("No contacts found which this user has permission to");			}			System.out.println();			System.out.println(stopWatch.prettyPrint());		}		SecurityContextHolder.clearContext();	}
public DistinguishedName buildDn(String username) {		DistinguishedName dn = new DistinguishedName(userDnBase);		dn.add(usernameAttribute, username);		return dn;	}
public static Builder from(OAuth2AuthorizationRequest authorizationRequest) {		Assert.notNull(authorizationRequest, "authorizationRequest cannot be null");		return new Builder(authorizationRequest.getGrantType())				.authorizationUri(authorizationRequest.getAuthorizationUri())				.clientId(authorizationRequest.getClientId())				.redirectUri(authorizationRequest.getRedirectUri())				.scopes(authorizationRequest.getScopes())				.state(authorizationRequest.getState())				.additionalParameters(authorizationRequest.getAdditionalParameters())				.attributes(authorizationRequest.getAttributes());	}
@Override	public Map<String, Object> introspect(String token) {		TokenIntrospectionSuccessResponse response = Optional.of(token)				.map(this::buildRequest)				.map(this::makeRequest)				.map(this::adaptToNimbusResponse)				.map(this::parseNimbusResponse)				.map(this::castToNimbusSuccess)				// relying solely on the authorization server to validate this token (not checking 'exp', for example)				.filter(TokenIntrospectionSuccessResponse::isActive)				.orElseThrow(() -> new OAuth2IntrospectionException("Provided token [" + token + "] isn't active"));		return convertClaimsSet(response);	}
@SuppressWarnings({ "rawtypes", "unchecked" })	protected final HttpSecurity getHttp() throws Exception {		if (http != null) {			return http;		}		DefaultAuthenticationEventPublisher eventPublisher = objectPostProcessor				.postProcess(new DefaultAuthenticationEventPublisher());		localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);		AuthenticationManager authenticationManager = authenticationManager();		authenticationBuilder.parentAuthenticationManager(authenticationManager);		authenticationBuilder.authenticationEventPublisher(eventPublisher);		Map<Class<? extends Object>, Object> sharedObjects = createSharedObjects();		http = new HttpSecurity(objectPostProcessor, authenticationBuilder,				sharedObjects);		if (!disableDefaults) {			// @formatter:off			http				.csrf().and()				.addFilter(new WebAsyncManagerIntegrationFilter())				.exceptionHandling().and()				.headers().and()				.sessionManagement().and()				.securityContext().and()				.requestCache().and()				.anonymous().and()				.servletApi().and()				.apply(new DefaultLoginPageConfigurer<>()).and()				.logout();			// @formatter:on			ClassLoader classLoader = this.context.getClassLoader();			List<AbstractHttpConfigurer> defaultHttpConfigurers =					SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);			for (AbstractHttpConfigurer configurer : defaultHttpConfigurers) {				http.apply(configurer);			}		}		configure(http);		return http;	}
protected AuthenticationManager authenticationManager() throws Exception {		if (!authenticationManagerInitialized) {			configure(localConfigureAuthenticationBldr);			if (disableLocalConfigureAuthenticationBldr) {				authenticationManager = authenticationConfiguration						.getAuthenticationManager();			}			else {				authenticationManager = localConfigureAuthenticationBldr.build();			}			authenticationManagerInitialized = true;		}		return authenticationManager;	}
public UserDetailsService userDetailsServiceBean() throws Exception {		AuthenticationManagerBuilder globalAuthBuilder = context				.getBean(AuthenticationManagerBuilder.class);		return new UserDetailsServiceDelegator(Arrays.asList(				localConfigureAuthenticationBldr, globalAuthBuilder));	}
protected UserDetailsService userDetailsService() {		AuthenticationManagerBuilder globalAuthBuilder = context				.getBean(AuthenticationManagerBuilder.class);		return new UserDetailsServiceDelegator(Arrays.asList(				localConfigureAuthenticationBldr, globalAuthBuilder));	}
private Map<Class<? extends Object>, Object> createSharedObjects() {		Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>();		sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects());		sharedObjects.put(UserDetailsService.class, userDetailsService());		sharedObjects.put(ApplicationContext.class, context);		sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy);		sharedObjects.put(AuthenticationTrustResolver.class, trustResolver);		return sharedObjects;	}
@Override	public void afterPropertiesSet() throws Exception {		// the superclass is not called because it does additional checks that are		// non-passive		Assert.hasLength(getLoginContextName(),				() -> "loginContextName must be set on " + getClass());		Assert.notNull(this.loginConfig,				() -> "loginConfig must be set on " + getClass());		configureJaas(this.loginConfig);		Assert.notNull(Configuration.getConfiguration(),				"As per https://java.sun.com/j2se/1.5.0/docs/api/javax/security/auth/login/Configuration.html "						+ "\"If a Configuration object was set via the Configuration.setConfiguration method, then that object is "						+ "returned. Otherwise, a default Configuration object is returned\". Your JRE returned null to "						+ "Configuration.getConfiguration().");	}
private void configureJaasUsingLoop() throws IOException {		String loginConfigUrl = convertLoginConfigToUrl();		boolean alreadySet = false;		int n = 1;		final String prefix = "login.config.url.";		String existing;		while ((existing = Security.getProperty(prefix + n)) != null) {			alreadySet = existing.equals(loginConfigUrl);			if (alreadySet) {				break;			}			n++;		}		if (!alreadySet) {			String key = prefix + n;			log.debug("Setting security property [" + key + "] to: " + loginConfigUrl);			Security.setProperty(key, loginConfigUrl);		}	}
@Override	protected void publishFailureEvent(UsernamePasswordAuthenticationToken token,			AuthenticationException ase) {		// exists for passivity (the superclass does a null check before publishing)		getApplicationEventPublisher()				.publishEvent(new JaasAuthenticationFailedEvent(token, ase));	}
public final EvaluationContext createEvaluationContext(Authentication authentication,			T invocation) {		SecurityExpressionOperations root = createSecurityExpressionRoot(authentication,				invocation);		StandardEvaluationContext ctx = createEvaluationContextInternal(authentication,				invocation);		ctx.setBeanResolver(br);		ctx.setRootObject(root);		return ctx;	}
public String resolveServiceEntry(String serviceType, String domain) {		return resolveServiceEntry(serviceType, domain, this.ctxFactory.getCtx());	}
public String resolveServiceIpAddress(String serviceType, String domain) {		DirContext ctx = this.ctxFactory.getCtx();		String hostname = resolveServiceEntry(serviceType, domain, ctx);		return resolveIpAddress(hostname, ctx);	}
private String resolveIpAddress(String hostname, DirContext ctx) {		try {			Attribute dnsRecord = lookup(hostname, ctx, "A");			// There should be only one A record, therefore it is save to return			// only the first.			return dnsRecord.get().toString();		}		catch (NamingException e) {			throw new DnsLookupException("DNS lookup failed for: " + hostname, e);		}	}
private String resolveServiceEntry(String serviceType, String domain,			DirContext ctx) {		String result = null;		try {			String query = new StringBuilder("_").append(serviceType).append("._tcp.")					.append(domain).toString();			Attribute dnsRecord = lookup(query, ctx, "SRV");			// There are maybe more records defined, we will return the one			// with the highest priority (lowest number) and the highest weight			// (highest number)			int highestPriority = -1;			int highestWeight = -1;			for (NamingEnumeration<?> recordEnum = dnsRecord.getAll(); recordEnum					.hasMoreElements();) {				String[] record = recordEnum.next().toString().split(" ");				if (record.length != 4) {					throw new DnsLookupException("Wrong service record for query " + query							+ ": [" + Arrays.toString(record) + "]");				}				int priority = Integer.parseInt(record[0]);				int weight = Integer.parseInt(record[1]);				// we have a new highest Priority, so forget also the highest weight				if (priority < highestPriority || highestPriority == -1) {					highestPriority = priority;					highestWeight = weight;					result = record[3].trim();				}				// same priority, but higher weight				if (priority == highestPriority && weight > highestWeight) {					highestWeight = weight;					result = record[3].trim();				}			}		}		catch (NamingException e) {			throw new DnsLookupException(					"DNS lookup failed for service " + serviceType + " at " + domain, e);		}		// remove the "." at the end		if (result.endsWith(".")) {			result = result.substring(0, result.length() - 1);		}		return result;	}
protected void prepareConnection(HttpURLConnection con, int contentLength)			throws IOException {		super.prepareConnection(con, contentLength);		Authentication auth = SecurityContextHolder.getContext().getAuthentication();		if ((auth != null) && (auth.getName() != null) && (auth.getCredentials() != null)				&& !trustResolver.isAnonymous(auth)) {			String base64 = auth.getName() + ":" + auth.getCredentials().toString();			con.setRequestProperty("Authorization",					"Basic " + new String(Base64.getEncoder().encode(base64.getBytes())));			if (logger.isDebugEnabled()) {				logger.debug("HttpInvocation now presenting via BASIC authentication SecurityContextHolder-derived: "						+ auth.toString());			}		}		else {			if (logger.isDebugEnabled()) {				logger.debug("Unable to set BASIC authentication header as SecurityContext did not provide "						+ "valid Authentication: " + auth);			}		}		doPrepareConnection(con, contentLength);	}
public static Mono<SecurityContext> getContext() {		return Mono.subscriberContext()			.filter( c -> c.hasKey(SECURITY_CONTEXT_KEY))			.flatMap( c-> c.<Mono<SecurityContext>>get(SECURITY_CONTEXT_KEY));	}
@SuppressWarnings("unchecked")	public <T> T postProcess(T object) {		if (object == null) {			return null;		}		T result = null;		try {			result = (T) this.autowireBeanFactory.initializeBean(object,					object.toString());		}		catch (RuntimeException e) {			Class<?> type = object.getClass();			throw new RuntimeException(					"Could not postProcess " + object + " of type " + type, e);		}		this.autowireBeanFactory.autowireBean(object);		if (result instanceof DisposableBean) {			this.disposableBeans.add((DisposableBean) result);		}		if (result instanceof SmartInitializingSingleton) {			this.smartSingletons.add((SmartInitializingSingleton) result);		}		return result;	}
public void destroy() throws Exception {		for (DisposableBean disposable : this.disposableBeans) {			try {				disposable.destroy();			}			catch (Exception error) {				this.logger.error(error);			}		}	}
public void setAsText(String s) throws IllegalArgumentException {		if (StringUtils.hasText(s)) {			String[] tokens = StringUtils.commaDelimitedListToStringArray(s);			UserAttribute userAttrib = new UserAttribute();			List<String> authoritiesAsStrings = new ArrayList<>();			for (int i = 0; i < tokens.length; i++) {				String currentToken = tokens[i].trim();				if (i == 0) {					userAttrib.setPassword(currentToken);				}				else {					if (currentToken.toLowerCase().equals("enabled")) {						userAttrib.setEnabled(true);					}					else if (currentToken.toLowerCase().equals("disabled")) {						userAttrib.setEnabled(false);					}					else {						authoritiesAsStrings.add(currentToken);					}				}			}			userAttrib.setAuthoritiesAsString(authoritiesAsStrings);			if (userAttrib.isValid()) {				setValue(userAttrib);			}			else {				setValue(null);			}		}		else {			setValue(null);		}	}
public final void setOauth2UserService(OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService) {		Assert.notNull(oauth2UserService, "oauth2UserService cannot be null");		this.oauth2UserService = oauth2UserService;	}
public static String formatDate(long value, DateFormat threadLocalformat) {		String cachedDate = null;		Long longValue = Long.valueOf(value);		try {			cachedDate = formatCache.get(longValue);		}		catch (Exception ignored) {		}		if (cachedDate != null) {			return cachedDate;		}		String newDate;		Date dateValue = new Date(value);		if (threadLocalformat != null) {			newDate = threadLocalformat.format(dateValue);			synchronized (formatCache) {				updateCache(formatCache, longValue, newDate);			}		}		else {			synchronized (formatCache) {				newDate = format.format(dateValue);				updateCache(formatCache, longValue, newDate);			}		}		return newDate;	}
public static String getCurrentDate() {		long now = System.currentTimeMillis();		if ((now - currentDateGenerated) > 1000) {			synchronized (format) {				if ((now - currentDateGenerated) > 1000) {					currentDateGenerated = now;					currentDate = format.format(new Date(now));				}			}		}		return currentDate;	}
private static Long internalParseDate(String value, DateFormat[] formats) {		Date date = null;		for (int i = 0; (date == null) && (i < formats.length); i++) {			try {				date = formats[i].parse(value);			}			catch (ParseException ignored) {			}		}		if (date == null) {			return null;		}		return new Long(date.getTime());	}
public static long parseDate(String value, DateFormat[] threadLocalformats) {		Long cachedDate = null;		try {			cachedDate = (Long) parseCache.get(value);		}		catch (Exception ignored) {		}		if (cachedDate != null) {			return cachedDate.longValue();		}		Long date;		if (threadLocalformats != null) {			date = internalParseDate(value, threadLocalformats);			synchronized (parseCache) {				updateCache(parseCache, value, date);			}		}		else {			synchronized (parseCache) {				date = internalParseDate(value, formats);				updateCache(parseCache, value, date);			}		}		if (date == null) {			return (-1L);		}		else {			return date.longValue();		}	}
@SuppressWarnings("unchecked")	private static void updateCache(HashMap cache, Object key, Object value) {		if (value == null) {			return;		}		if (cache.size() > 1000) {			cache.clear();		}		cache.put(key, value);	}
public static MethodInvocation create(Object object, String methodName,			Object... args) {		Assert.notNull(object, "Object required");		Class<?>[] classArgs = null;		if (args != null) {			classArgs = new Class<?>[args.length];			for (int i = 0; i < args.length; i++) {				classArgs[i] = args[i].getClass();			}		}		// Determine the type that declares the requested method, taking into account		// proxies		Class<?> target = AopUtils.getTargetClass(object);		if (object instanceof Advised) {			Advised a = (Advised) object;			if (!a.isProxyTargetClass()) {				Class<?>[] possibleInterfaces = a.getProxiedInterfaces();				for (Class<?> possibleInterface : possibleInterfaces) {					try {						possibleInterface.getMethod(methodName, classArgs);						// to get here means no exception happened						target = possibleInterface;						break;					}					catch (Exception ignored) {						// try the next one					}				}			}		}		return createFromClass(object, target, methodName, classArgs, args);	}
public static MethodInvocation createFromClass(Class<?> clazz, String methodName) {		MethodInvocation mi = createFromClass(null, clazz, methodName, null, null);		if (mi == null) {			for (Method m : clazz.getDeclaredMethods()) {				if (m.getName().equals(methodName)) {					if (mi != null) {						throw new IllegalArgumentException("The class " + clazz								+ " has more than one method named" + " '" + methodName								+ "'");					}					mi = new SimpleMethodInvocation(null, m);				}			}		}		return mi;	}
public static MethodInvocation createFromClass(Object targetObject, Class<?> clazz,			String methodName, Class<?>[] classArgs, Object[] args) {		Assert.notNull(clazz, "Class required");		Assert.hasText(methodName, "MethodName required");		Method method;		try {			method = clazz.getMethod(methodName, classArgs);		}		catch (NoSuchMethodException e) {			return null;		}		return new SimpleMethodInvocation(targetObject, method, args);	}
public Authentication attemptAuthentication(HttpServletRequest request,			HttpServletResponse response) throws AuthenticationException {		if (postOnly && !request.getMethod().equals("POST")) {			throw new AuthenticationServiceException(					"Authentication method not supported: " + request.getMethod());		}		String username = obtainUsername(request);		String password = obtainPassword(request);		if (username == null) {			username = "";		}		if (password == null) {			password = "";		}		username = username.trim();		UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(				username, password);		// Allow subclasses to set the "details" property		setDetails(request, authRequest);		return this.getAuthenticationManager().authenticate(authRequest);	}
protected void setDetails(HttpServletRequest request,			UsernamePasswordAuthenticationToken authRequest) {		authRequest.setDetails(authenticationDetailsSource.buildDetails(request));	}
public Constraint simpTypeMatchers(SimpMessageType... typesToMatch) {		MessageMatcher<?>[] typeMatchers = new MessageMatcher<?>[typesToMatch.length];		for (int i = 0; i < typesToMatch.length; i++) {			SimpMessageType typeToMatch = typesToMatch[i];			typeMatchers[i] = new SimpMessageTypeMatcher(typeToMatch);		}		return matchers(typeMatchers);	}
private Constraint simpDestMatchers(SimpMessageType type, String... patterns) {		List<MatcherBuilder> matchers = new ArrayList<>(patterns.length);		for (String pattern : patterns) {			matchers.add(new PathMatcherMessageMatcherBuilder(pattern, type));		}		return new Constraint(matchers);	}
public MessageSecurityMetadataSourceRegistry simpDestPathMatcher(			PathMatcher pathMatcher) {		Assert.notNull(pathMatcher, "pathMatcher cannot be null");		this.pathMatcher.setPathMatcher(pathMatcher);		this.defaultPathMatcher = false;		return this;	}
public Constraint matchers(MessageMatcher<?>... matchers) {		List<MatcherBuilder> builders = new ArrayList<>(matchers.length);		for (MessageMatcher<?> matcher : matchers) {			builders.add(new PreBuiltMatcherBuilder(matcher));		}		return new Constraint(builders);	}
public MessageSecurityMetadataSourceRegistry expressionHandler(SecurityExpressionHandler<Message<Object>> expressionHandler) {		Assert.notNull(expressionHandler, "expressionHandler cannot be null");		this.expressionHandler = expressionHandler;		return this;	}
protected MessageSecurityMetadataSource createMetadataSource() {		LinkedHashMap<MessageMatcher<?>, String> matcherToExpression = new LinkedHashMap<MessageMatcher<?>, String>();		for (Map.Entry<MatcherBuilder, String> entry : this.matcherToExpression				.entrySet()) {			matcherToExpression.put(entry.getKey().build(), entry.getValue());		}		return ExpressionBasedMessageSecurityMetadataSourceFactory				.createExpressionMessageMetadataSource(matcherToExpression, expressionHandler);	}
protected Authentication createSuccessAuthentication(Object principal,			Authentication authentication, UserDetails user) {		// Ensure we return the original credentials the user supplied,		// so subsequent attempts are successful even with encoded passwords.		// Also ensure we return the original getDetails(), so that future		// authentication events after cache expiry contain the details		UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(				principal, authentication.getCredentials(),				authoritiesMapper.mapAuthorities(user.getAuthorities()));		result.setDetails(authentication.getDetails());		return result;	}
public HttpBasicConfigurer<B> realmName(String realmName) throws Exception {		this.basicAuthEntryPoint.setRealmName(realmName);		this.basicAuthEntryPoint.afterPropertiesSet();		return this;	}
public JdbcUserDetailsManagerConfigurer<B> dataSource(DataSource dataSource)			throws Exception {		this.dataSource = dataSource;		getUserDetailsService().setDataSource(dataSource);		return this;	}
public JdbcUserDetailsManagerConfigurer<B> groupAuthoritiesByUsername(String query)			throws Exception {		JdbcUserDetailsManager userDetailsService = getUserDetailsService();		userDetailsService.setEnableGroups(true);		userDetailsService.setGroupAuthoritiesByUsernameQuery(query);		return this;	}
public void setKeyStoreFile(File keyStoreFile) {		Assert.notNull(keyStoreFile, "The keyStoreFile must not be null.");		Assert.isTrue(keyStoreFile.isFile(), "The keyStoreFile must be a file.");		this.keyStoreFile = keyStoreFile;	}
@SuppressWarnings("deprecation")	protected void additionalAuthenticationChecks(UserDetails userDetails,			UsernamePasswordAuthenticationToken authentication)			throws AuthenticationException {		if (authentication.getCredentials() == null) {			logger.debug("Authentication failed: no credentials provided");			throw new BadCredentialsException(messages.getMessage(					"AbstractUserDetailsAuthenticationProvider.badCredentials",					"Bad credentials"));		}		String presentedPassword = authentication.getCredentials().toString();		if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {			logger.debug("Authentication failed: password does not match stored value");			throw new BadCredentialsException(messages.getMessage(					"AbstractUserDetailsAuthenticationProvider.badCredentials",					"Bad credentials"));		}	}
public void setPasswordEncoder(PasswordEncoder passwordEncoder) {		Assert.notNull(passwordEncoder, "passwordEncoder cannot be null");		this.passwordEncoder = passwordEncoder;		this.userNotFoundEncodedPassword = null;	}
public boolean commit() throws LoginException {		if (authen == null) {			return false;		}		subject.getPrincipals().add(authen);		return true;	}
@SuppressWarnings("unchecked")	public void initialize(Subject subject, CallbackHandler callbackHandler,			Map sharedState, Map options) {		this.subject = subject;		if (options != null) {			ignoreMissingAuthentication = "true".equals(options					.get("ignoreMissingAuthentication"));		}	}
public boolean login() throws LoginException {		authen = SecurityContextHolder.getContext().getAuthentication();		if (authen == null) {			String msg = "Login cannot complete, authentication not found in security context";			if (ignoreMissingAuthentication) {				log.warn(msg);				return false;			}			else {				throw new LoginException(msg);			}		}		return true;	}
public boolean logout() throws LoginException {		if (authen == null) {			return false;		}		subject.getPrincipals().remove(authen);		authen = null;		return true;	}
public static UserDetailsManagerResourceFactoryBean fromResourceLocation(String resourceLocation) {		UserDetailsManagerResourceFactoryBean result = new UserDetailsManagerResourceFactoryBean();		result.setResourceLocation(resourceLocation);		return result;	}
public static UserDetailsManagerResourceFactoryBean fromResource(Resource resource) {		UserDetailsManagerResourceFactoryBean result = new UserDetailsManagerResourceFactoryBean();		result.setResource(resource);		return result;	}
public static UserDetailsManagerResourceFactoryBean fromString(String users) {		UserDetailsManagerResourceFactoryBean result = new UserDetailsManagerResourceFactoryBean();		result.setResource(new InMemoryResource(users));		return result;	}
@Override	public void deleteAce(int aceIndex) throws NotFoundException {		aclAuthorizationStrategy.securityCheck(this,				AclAuthorizationStrategy.CHANGE_GENERAL);		verifyAceIndexExists(aceIndex);		synchronized (aces) {			this.aces.remove(aceIndex);		}	}
@Override	public boolean isGranted(List<Permission> permission, List<Sid> sids,			boolean administrativeMode) throws NotFoundException, UnloadedSidException {		Assert.notEmpty(permission, "Permissions required");		Assert.notEmpty(sids, "SIDs required");		if (!this.isSidLoaded(sids)) {			throw new UnloadedSidException("ACL was not loaded for one or more SID");		}		return permissionGrantingStrategy.isGranted(this, permission, sids,				administrativeMode);	}
private <A extends Annotation> A findAnnotation(Method method, Class<?> targetClass,			Class<A> annotationClass) {		// The method may be on an interface, but we need attributes from the target		// class.		// If the target class is null, the method will be unchanged.		Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);		A annotation = AnnotationUtils.findAnnotation(specificMethod, annotationClass);		if (annotation != null) {			logger.debug(annotation + " found on specific method: " + specificMethod);			return annotation;		}		// Check the original (e.g. interface) method		if (specificMethod != method) {			annotation = AnnotationUtils.findAnnotation(method, annotationClass);			if (annotation != null) {				logger.debug(annotation + " found on: " + method);				return annotation;			}		}		// Check the class-level (note declaringClass, not targetClass, which may not		// actually implement the method)		annotation = AnnotationUtils.findAnnotation(specificMethod.getDeclaringClass(),				annotationClass);		if (annotation != null) {			logger.debug(annotation + " found on: "					+ specificMethod.getDeclaringClass().getName());			return annotation;		}		return null;	}
private static String getSecurityName(final Subject subject) {		if (logger.isDebugEnabled()) {			logger.debug("Determining Websphere security name for subject " + subject);		}		String userSecurityName = null;		if (subject != null) {			// SEC-803			Object credential = subject.getPublicCredentials(getWSCredentialClass())					.iterator().next();			if (credential != null) {				userSecurityName = (String) invokeMethod(getSecurityNameMethod(),						credential);			}		}		if (logger.isDebugEnabled()) {			logger.debug("Websphere security name is " + userSecurityName					+ " for subject " + subject);		}		return userSecurityName;	}
@SuppressWarnings("unchecked")	private static List<String> getWebSphereGroups(final String securityName) {		Context ic = null;		try {			// TODO: Cache UserRegistry object			ic = new InitialContext();			Object objRef = ic.lookup(USER_REGISTRY);			Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName("com.ibm.websphere.security.UserRegistry"));			if (logger.isDebugEnabled()) {				logger.debug("Determining WebSphere groups for user " + securityName						+ " using WebSphere UserRegistry " + userReg);			}			final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(),					userReg, new Object[] { securityName });			if (logger.isDebugEnabled()) {				logger.debug("Groups for user " + securityName + ": " + groups.toString());			}			return new ArrayList(groups);		}		catch (Exception e) {			logger.error("Exception occured while looking up groups for user", e);			throw new RuntimeException(					"Exception occured while looking up groups for user", e);		}		finally {			try {				if (ic != null) {					ic.close();				}			}			catch (NamingException e) {				logger.debug("Exception occured while closing context", e);			}		}	}
public void changePassword(final String oldPassword, final String newPassword) {		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		Assert.notNull(				authentication,				"No authentication object found in security context. Can't change current user's password!");		String username = authentication.getName();		logger.debug("Changing password for user '" + username);		DistinguishedName userDn = usernameMapper.buildDn(username);		if (usePasswordModifyExtensionOperation) {			changePasswordUsingExtensionOperation(userDn, oldPassword, newPassword);		} else {			changePasswordUsingAttributeModification(userDn, oldPassword, newPassword);		}	}
protected DistinguishedName buildGroupDn(String group) {		DistinguishedName dn = new DistinguishedName(groupSearchBase);		dn.add(groupRoleAttributeName, group.toLowerCase());		return dn;	}
public void setGroupMemberAttributeName(String groupMemberAttributeName) {		Assert.hasText(groupMemberAttributeName, "groupMemberAttributeName should have text");		this.groupMemberAttributeName = groupMemberAttributeName;		this.groupSearchFilter = "(" + groupMemberAttributeName + "={0})";	}
public List<ObjectIdentity> findChildren(ObjectIdentity parentIdentity) {		Object[] args = { parentIdentity.getIdentifier().toString(), parentIdentity.getType() };		List<ObjectIdentity> objects = jdbcOperations.query(findChildrenSql, args,				new RowMapper<ObjectIdentity>() {					public ObjectIdentity mapRow(ResultSet rs, int rowNum)							throws SQLException {						String javaType = rs.getString("class");						Serializable identifier = (Serializable) rs.getObject("obj_id");						identifier = aclClassIdUtils.identifierFrom(identifier, rs);						return new ObjectIdentityImpl(javaType, identifier);					}				});		if (objects.size() == 0) {			return null;		}		return objects;	}
public Object decide(Authentication authentication, Object object,			Collection<ConfigAttribute> config, Object returnedObject)			throws AccessDeniedException {		if (returnedObject == null) {			// AclManager interface contract prohibits nulls			// As they have permission to null/nothing, grant access			logger.debug("Return object is null, skipping");			return null;		}		if (!getProcessDomainObjectClass().isAssignableFrom(returnedObject.getClass())) {			logger.debug("Return object is not applicable for this provider, skipping");			return returnedObject;		}		for (ConfigAttribute attr : config) {			if (!this.supports(attr)) {				continue;			}			// Need to make an access decision on this invocation			if (hasPermission(authentication, returnedObject)) {				return returnedObject;			}			logger.debug("Denying access");			throw new AccessDeniedException(messages.getMessage(					"AclEntryAfterInvocationProvider.noPermission", new Object[] {							authentication.getName(), returnedObject },					"Authentication {0} has NO permissions to the domain object {1}"));		}		return returnedObject;	}
public void onAuthentication(Authentication authentication,			HttpServletRequest request, HttpServletResponse response) {		final List<SessionInformation> sessions = sessionRegistry.getAllSessions(				authentication.getPrincipal(), false);		int sessionCount = sessions.size();		int allowedSessions = getMaximumSessionsForThisUser(authentication);		if (sessionCount < allowedSessions) {			// They haven't got too many login sessions running at present			return;		}		if (allowedSessions == -1) {			// We permit unlimited logins			return;		}		if (sessionCount == allowedSessions) {			HttpSession session = request.getSession(false);			if (session != null) {				// Only permit it though if this request is associated with one of the				// already registered sessions				for (SessionInformation si : sessions) {					if (si.getSessionId().equals(session.getId())) {						return;					}				}			}			// If the session is null, a new one will be created by the parent class,			// exceeding the allowed number		}		allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);	}
protected void allowableSessionsExceeded(List<SessionInformation> sessions,			int allowableSessions, SessionRegistry registry)			throws SessionAuthenticationException {		if (exceptionIfMaximumExceeded || (sessions == null)) {			throw new SessionAuthenticationException(messages.getMessage(					"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed",					new Object[] { Integer.valueOf(allowableSessions) },					"Maximum sessions of {0} for this principal exceeded"));		}		// Determine least recently used session, and mark it for invalidation		SessionInformation leastRecentlyUsed = null;		for (SessionInformation session : sessions) {			if ((leastRecentlyUsed == null)					|| session.getLastRequest()							.before(leastRecentlyUsed.getLastRequest())) {				leastRecentlyUsed = session;			}		}		leastRecentlyUsed.expireNow();	}
@Override	public void commence(			HttpServletRequest request, HttpServletResponse response,			AuthenticationException authException)			throws IOException, ServletException {		HttpStatus status = HttpStatus.UNAUTHORIZED;		Map<String, String> parameters = new LinkedHashMap<>();		if (this.realmName != null) {			parameters.put("realm", this.realmName);		}		if (authException instanceof OAuth2AuthenticationException) {			OAuth2Error error = ((OAuth2AuthenticationException) authException).getError();			parameters.put("error", error.getErrorCode());			if (StringUtils.hasText(error.getDescription())) {				parameters.put("error_description", error.getDescription());			}			if (StringUtils.hasText(error.getUri())) {				parameters.put("error_uri", error.getUri());			}			if (error instanceof BearerTokenError) {				BearerTokenError bearerTokenError = (BearerTokenError) error;				if (StringUtils.hasText(bearerTokenError.getScope())) {					parameters.put("scope", bearerTokenError.getScope());				}				status = ((BearerTokenError) error).getHttpStatus();			}		}		String wwwAuthenticate = computeWWWAuthenticateHeaderValue(parameters);		response.addHeader(HttpHeaders.WWW_AUTHENTICATE, wwwAuthenticate);		response.setStatus(status.value());	}
@Override	public Authentication authenticate(Authentication authentication) throws AuthenticationException {		BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken) authentication;		Jwt jwt;		try {			jwt = this.jwtDecoder.decode(bearer.getToken());		} catch (JwtException failed) {			OAuth2Error invalidToken = invalidToken(failed.getMessage());			throw new OAuth2AuthenticationException(invalidToken, invalidToken.getDescription(), failed);		}		AbstractAuthenticationToken token = this.jwtAuthenticationConverter.convert(jwt);		token.setDetails(bearer.getDetails());		return token;	}
private MultiValueMap<String, String> buildFormParameters(OAuth2ClientCredentialsGrantRequest clientCredentialsGrantRequest) {		ClientRegistration clientRegistration = clientCredentialsGrantRequest.getClientRegistration();		MultiValueMap<String, String> formParameters = new LinkedMultiValueMap<>();		formParameters.add(OAuth2ParameterNames.GRANT_TYPE, clientCredentialsGrantRequest.getGrantType().getValue());		if (!CollectionUtils.isEmpty(clientRegistration.getScopes())) {			formParameters.add(OAuth2ParameterNames.SCOPE,					StringUtils.collectionToDelimitedString(clientRegistration.getScopes(), " "));		}		if (ClientAuthenticationMethod.POST.equals(clientRegistration.getClientAuthenticationMethod())) {			formParameters.add(OAuth2ParameterNames.CLIENT_ID, clientRegistration.getClientId());			formParameters.add(OAuth2ParameterNames.CLIENT_SECRET, clientRegistration.getClientSecret());		}		return formParameters;	}
public Authentication authenticate(Authentication authentication)			throws AuthenticationException {		Class<? extends Authentication> toTest = authentication.getClass();		AuthenticationException lastException = null;		AuthenticationException parentException = null;		Authentication result = null;		Authentication parentResult = null;		boolean debug = logger.isDebugEnabled();		for (AuthenticationProvider provider : getProviders()) {			if (!provider.supports(toTest)) {				continue;			}			if (debug) {				logger.debug("Authentication attempt using "						+ provider.getClass().getName());			}			try {				result = provider.authenticate(authentication);				if (result != null) {					copyDetails(authentication, result);					break;				}			}			catch (AccountStatusException e) {				prepareException(e, authentication);				// SEC-546: Avoid polling additional providers if auth failure is due to				// invalid account status				throw e;			}			catch (InternalAuthenticationServiceException e) {				prepareException(e, authentication);				throw e;			}			catch (AuthenticationException e) {				lastException = e;			}		}		if (result == null && parent != null) {			// Allow the parent to try.			try {				result = parentResult = parent.authenticate(authentication);			}			catch (ProviderNotFoundException e) {				// ignore as we will throw below if no other exception occurred prior to				// calling parent and the parent				// may throw ProviderNotFound even though a provider in the child already				// handled the request			}			catch (AuthenticationException e) {				lastException = parentException = e;			}		}		if (result != null) {			if (eraseCredentialsAfterAuthentication					&& (result instanceof CredentialsContainer)) {				// Authentication is complete. Remove credentials and other secret data				// from authentication				((CredentialsContainer) result).eraseCredentials();			}			// If the parent AuthenticationManager was attempted and successful than it will publish an AuthenticationSuccessEvent			// This check prevents a duplicate AuthenticationSuccessEvent if the parent AuthenticationManager already published it			if (parentResult == null) {				eventPublisher.publishAuthenticationSuccess(result);			}			return result;		}		// Parent was null, or didn't authenticate (or throw an exception).		if (lastException == null) {			lastException = new ProviderNotFoundException(messages.getMessage(					"ProviderManager.providerNotFound",					new Object[] { toTest.getName() },					"No AuthenticationProvider found for {0}"));		}		// If the parent AuthenticationManager was attempted and failed than it will publish an AbstractAuthenticationFailureEvent		// This check prevents a duplicate AbstractAuthenticationFailureEvent if the parent AuthenticationManager already published it		if (parentException == null) {			prepareException(lastException, authentication);		}		throw lastException;	}
private void copyDetails(Authentication source, Authentication dest) {		if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) {			AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest;			token.setDetails(source.getDetails());		}	}
public void onAuthentication(Authentication authentication,			HttpServletRequest request, HttpServletResponse response) {		boolean hadSessionAlready = request.getSession(false) != null;		if (!hadSessionAlready && !alwaysCreateSession) {			// Session fixation isn't a problem if there's no session			return;		}		// Create new session if necessary		HttpSession session = request.getSession();		if (hadSessionAlready && request.isRequestedSessionIdValid()) {			String originalSessionId;			String newSessionId;			Object mutex = WebUtils.getSessionMutex(session);			synchronized (mutex) {				// We need to migrate to a new session				originalSessionId = session.getId();				session = applySessionFixation(request);				newSessionId = session.getId();			}			if (originalSessionId.equals(newSessionId)) {				logger.warn("Your servlet container did not change the session ID when a new session was created. You will"						+ " not be adequately protected against session-fixation attacks");			}			onSessionChange(originalSessionId, session, authentication);		}	}
protected void onSessionChange(String originalSessionId, HttpSession newSession,			Authentication auth) {		applicationEventPublisher.publishEvent(new SessionFixationProtectionEvent(auth,				originalSessionId, newSession.getId()));	}
@Override	Collection<? extends GrantedAuthority> extractAuthorities(			Authentication authentication) {		return roleHierarchy.getReachableGrantedAuthorities(authentication				.getAuthorities());	}
private List<Filter> getFilters(HttpServletRequest request) {		for (SecurityFilterChain chain : filterChains) {			if (chain.matches(request)) {				return chain.getFilters();			}		}		return null;	}
public List<Filter> getFilters(String url) {		return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, "GET")				.getRequest())));	}
public int doStartTag() throws JspException {		if ((null == hasPermission) || "".equals(hasPermission)) {			return skipBody();		}		initializeIfRequired();		if (domainObject == null) {			if (logger.isDebugEnabled()) {				logger.debug("domainObject resolved to null, so including tag body");			}			// Of course they have access to a null object!			return evalBody();		}		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		if (authentication == null) {			if (logger.isDebugEnabled()) {				logger.debug("SecurityContextHolder did not return a non-null Authentication object, so skipping tag body");			}			return skipBody();		}		List<Object> requiredPermissions = parseHasPermission(hasPermission);		for (Object requiredPermission : requiredPermissions) {			if (!permissionEvaluator.hasPermission(authentication, domainObject,					requiredPermission)) {				return skipBody();			}		}		return evalBody();	}
protected ApplicationContext getContext(PageContext pageContext) {		ServletContext servletContext = pageContext.getServletContext();		return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext);	}
protected Authentication createSuccessfulAuthentication(			UsernamePasswordAuthenticationToken authentication, UserDetails user) {		Object password = this.useAuthenticationRequestCredentials				? authentication.getCredentials() : user.getPassword();		UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(				user, password,				this.authoritiesMapper.mapAuthorities(user.getAuthorities()));		result.setDetails(authentication.getDetails());		return result;	}
public void securityCheck(Acl acl, int changeType) {		if ((SecurityContextHolder.getContext() == null)				|| (SecurityContextHolder.getContext().getAuthentication() == null)				|| !SecurityContextHolder.getContext().getAuthentication()						.isAuthenticated()) {			throw new AccessDeniedException(					"Authenticated principal required to operate with ACLs");		}		Authentication authentication = SecurityContextHolder.getContext()				.getAuthentication();		// Check if authorized by virtue of ACL ownership		Sid currentUser = createCurrentUser(authentication);		if (currentUser.equals(acl.getOwner())				&& ((changeType == CHANGE_GENERAL) || (changeType == CHANGE_OWNERSHIP))) {			return;		}		// Not authorized by ACL ownership; try via adminstrative permissions		GrantedAuthority requiredAuthority;		if (changeType == CHANGE_AUDITING) {			requiredAuthority = this.gaModifyAuditing;		}		else if (changeType == CHANGE_GENERAL) {			requiredAuthority = this.gaGeneralChanges;		}		else if (changeType == CHANGE_OWNERSHIP) {			requiredAuthority = this.gaTakeOwnership;		}		else {			throw new IllegalArgumentException("Unknown change type");		}		// Iterate this principal's authorities to determine right		Set<String> authorities = AuthorityUtils.authorityListToSet(authentication.getAuthorities());		if (authorities.contains(requiredAuthority.getAuthority())) {			return;		}		// Try to get permission via ACEs within the ACL		List<Sid> sids = sidRetrievalStrategy.getSids(authentication);		if (acl.isGranted(Arrays.asList(BasePermission.ADMINISTRATION), sids, false)) {			return;		}		throw new AccessDeniedException(				"Principal does not have required ACL permissions to perform requested operation");	}
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,			BeanDefinitionRegistry registry) {		BeanDefinitionBuilder advisor = BeanDefinitionBuilder				.rootBeanDefinition(MethodSecurityMetadataSourceAdvisor.class);		advisor.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);		advisor.addConstructorArgValue("methodSecurityInterceptor");		advisor.addConstructorArgReference("methodSecurityMetadataSource");		advisor.addConstructorArgValue("methodSecurityMetadataSource");		MultiValueMap<String, Object> attributes = importingClassMetadata.getAllAnnotationAttributes(EnableGlobalMethodSecurity.class.getName());		Integer order = (Integer) attributes.getFirst("order");		if (order != null) {			advisor.addPropertyValue("order", order);		}		registry.registerBeanDefinition("metaDataSourceAdvisor",				advisor.getBeanDefinition());	}
public static void closeContext(Context ctx) {		if (ctx instanceof DirContextAdapter) {			return;		}		try {			if (ctx != null) {				ctx.close();			}		}		catch (NamingException e) {			logger.error("Failed to close context.", e);		}	}
public static String getRelativeName(String fullDn, Context baseCtx)			throws NamingException {		String baseDn = baseCtx.getNameInNamespace();		if (baseDn.length() == 0) {			return fullDn;		}		DistinguishedName base = new DistinguishedName(baseDn);		DistinguishedName full = new DistinguishedName(fullDn);		if (base.equals(full)) {			return "";		}		Assert.isTrue(full.startsWith(base), "Full DN does not start with base DN");		full.removeFirst(base);		return full.toString();	}
public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx)			throws NamingException {		DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace());		if (dn.contains(baseDn)) {			return dn;		}		baseDn.append(dn);		return baseDn;	}
public void setJwtGrantedAuthoritiesConverter(Converter<Jwt, Flux<GrantedAuthority>> jwtGrantedAuthoritiesConverter) {		Assert.notNull(jwtGrantedAuthoritiesConverter, "jwtGrantedAuthoritiesConverter cannot be null");		this.jwtGrantedAuthoritiesConverter = jwtGrantedAuthoritiesConverter;	}
@Override	public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {		return Mono.just(exchange)				.filter(this::isInsecure)				.flatMap(this.requiresHttpsRedirectMatcher::matches)				.filter(matchResult -> matchResult.isMatch())				.switchIfEmpty(chain.filter(exchange).then(Mono.empty()))				.map(matchResult -> createRedirectUri(exchange))				.flatMap(uri -> this.redirectStrategy.sendRedirect(exchange, uri));	}
public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) {        notNull(sessionAttributes, "sessionAttributes");        parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes);        return this;    }
public MockMvcRequestSpecification sessionAttr(String name, Object value) {        notNull(name, "Session attribute name");        parameterUpdater.updateZeroToManyParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, name, value);        return this;    }
public FormAuthConfig withCsrfFieldName(String fieldName) {        notNull(fieldName, "CSRF field name");        if (autoDetectCsrfFieldName) {            throw new IllegalStateException("Cannot defined a CSRF field name since the CSRF field name has been marked as auto-detected.");        }        return new FormAuthConfig(formAction, userInputTagName, passwordInputTagName, logDetail, logConfig, fieldName, false, sendCsrfTokenAsFormParam, additionalInputFieldNames);    }
public FormAuthConfig withAdditionalField(String fieldName) {        notNull(fieldName, "Additional field name");        List<String> list = new ArrayList<String>(additionalInputFieldNames);        list.add(fieldName);        return new FormAuthConfig(formAction, userInputTagName, passwordInputTagName, logDetail, logConfig, csrfFieldName, autoDetectCsrfFieldName, sendCsrfTokenAsFormParam, list);    }
public FormAuthConfig withAdditionalFields(String firstFieldName, String secondFieldName, String... additionalFieldNames) {        notNull(firstFieldName, "First additional field name");        notNull(secondFieldName, "Second additional field name");        List<String> list = new ArrayList<String>(additionalInputFieldNames);        list.add(firstFieldName);        list.add(secondFieldName);        if (additionalFieldNames != null && additionalFieldNames.length > 0) {            list.addAll(Arrays.asList(additionalFieldNames));        }        return new FormAuthConfig(formAction, userInputTagName, passwordInputTagName, logDetail, logConfig, csrfFieldName, autoDetectCsrfFieldName, sendCsrfTokenAsFormParam, list);    }
public FormAuthConfig withAutoDetectionOfCsrf() {        if (hasCsrfFieldName()) {            throw new IllegalStateException(format("Cannot use auto-detection of CSRF field name since a CSRF field name was already defined as '%s'", csrfFieldName));        }        return new FormAuthConfig(formAction, userInputTagName, passwordInputTagName, logDetail, logConfig, csrfFieldName, true, sendCsrfTokenAsFormParam, additionalInputFieldNames);    }
public FormAuthConfig withLoggingEnabled(LogDetail logDetail, LogConfig logConfig) {        notNull(logDetail, LogDetail.class);        notNull(logConfig, LogConfig.class);        return new FormAuthConfig(formAction, userInputTagName, passwordInputTagName, logDetail, logConfig, csrfFieldName, autoDetectCsrfFieldName, sendCsrfTokenAsFormParam, additionalInputFieldNames);    }
public AuthenticationScheme basic(String userName, String password) {        final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme();        preemptiveBasicAuthScheme.setUserName(userName);        preemptiveBasicAuthScheme.setPassword(password);        return preemptiveBasicAuthScheme;    }
public static void filters(List<Filter> filters) {        Validate.notNull(filters, "Filter list cannot be null");        RestAssured.filters.addAll(filters);    }
public static void filters(Filter filter, Filter... additionalFilters) {        Validate.notNull(filter, "Filter cannot be null");        RestAssured.filters.add(filter);        if (additionalFilters != null) {            Collections.addAll(RestAssured.filters, additionalFilters);        }    }
public static void replaceFiltersWith(List<Filter> filters) {        Validate.notNull(filters, "Filter list cannot be null");        RestAssured.filters.clear();        filters(filters);    }
public static void replaceFiltersWith(Filter filter, Filter... additionalFilters) {        Validate.notNull(filter, "Filter cannot be null");        RestAssured.filters.clear();        filters(filter, additionalFilters);    }
public static void objectMapper(ObjectMapper objectMapper) {        Validate.notNull(objectMapper, "Default object mapper cannot be null");        config = config().objectMapperConfig(ObjectMapperConfig.objectMapperConfig().defaultObjectMapper(objectMapper));    }
public static List<Argument> withArgs(Object firstArgument, Object... additionalArguments) {        Validate.notNull(firstArgument, "You need to supply at least one argument");        final List<Argument> arguments = new LinkedList<Argument>();        arguments.add(Argument.arg(firstArgument));        if (additionalArguments != null && additionalArguments.length > 0) {            for (Object additionalArgument : additionalArguments) {                arguments.add(Argument.arg(additionalArgument));            }        }        return Collections.unmodifiableList(arguments);    }
public static Response get(String path, Object... pathParams) {        return given().get(path, pathParams);    }
public static Response get(String path, Map<String, ?> pathParams) {        return given().get(path, pathParams);    }
public static Response post(String path, Object... pathParams) {        return given().post(path, pathParams);    }
public static Response post(String path, Map<String, ?> pathParams) {        return given().post(path, pathParams);    }
public static Response put(String path, Object... pathParams) {        return given().put(path, pathParams);    }
public static Response delete(String path, Object... pathParams) {        return given().delete(path, pathParams);    }
public static Response delete(String path, Map<String, ?> pathParams) {        return given().delete(path, pathParams);    }
public static Response head(String path, Object... pathParams) {        return given().head(path, pathParams);    }
public static Response head(String path, Map<String, ?> pathParams) {        return given().head(path, pathParams);    }
public static Response patch(String path, Object... pathParams) {        return given().patch(path, pathParams);    }
public static Response patch(String path, Map<String, ?> pathParams) {        return given().patch(path, pathParams);    }
public static Response options(String path, Object... pathParams) {        return given().options(path, pathParams);    }
public static Response options(String path, Map<String, ?> pathParams) {        return given().options(path, pathParams);    }
public static Response request(Method method, URI uri) {        return given().request(method, uri);    }
public static Response request(Method method, URL url) {        return given().request(method, url);    }
public static Response request(String method, URI uri) {        return given().request(method, uri);    }
public static Response request(String method, URL url) {        return given().request(method, url);    }
public static AuthenticationScheme basic(String userName, String password) {        final BasicAuthScheme scheme = new BasicAuthScheme();        scheme.setUserName(userName);        scheme.setPassword(password);        return scheme;    }
public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) {        final NTLMAuthScheme scheme = new NTLMAuthScheme();        scheme.setUserName(userName);        scheme.setPassword(password);        scheme.setWorkstation(workstation);        scheme.setDomain(domain);        return scheme;    }
public static AuthenticationScheme form(String userName, String password) {        return form(userName, password, null);    }
public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) {        if (userName == null) {            throw new IllegalArgumentException("Username cannot be null");        }        if (password == null) {            throw new IllegalArgumentException("Password cannot be null");        }        final FormAuthScheme scheme = new FormAuthScheme();        scheme.setUserName(userName);        scheme.setPassword(password);        scheme.setConfig(config);        return scheme;    }
public static AuthenticationScheme certificate(String certURL, String password) {        SSLConfig sslConfig = config().getSSLConfig();        return certificate(certURL, password, CertificateAuthSettings.certAuthSettings().keyStoreType(sslConfig.getKeyStoreType()).trustStore(sslConfig.getTrustStore()).                keyStore(sslConfig.getKeyStore()).trustStoreType(sslConfig.getTrustStoreType()).x509HostnameVerifier(sslConfig.getX509HostnameVerifier()).                port(sslConfig.getPort()).sslSocketFactory(sslConfig.getSSLSocketFactory()));    }
public static AuthenticationScheme certificate(String certURL, String password, CertificateAuthSettings certificateAuthSettings) {        return certificate(certURL, password, "", "", certificateAuthSettings);    }
public static AuthenticationScheme certificate(String trustStorePath, String trustStorePassword,                                                   String keyStorePath, String keyStorePassword,                                                   CertificateAuthSettings certificateAuthSettings) {        AssertParameter.notNull(keyStorePath, "Keystore path");        AssertParameter.notNull(keyStorePassword, "Keystore password");        AssertParameter.notNull(trustStorePath, "Trust store path");        AssertParameter.notNull(trustStorePassword, "Keystore password");        AssertParameter.notNull(certificateAuthSettings, CertificateAuthSettings.class);        final CertAuthScheme scheme = new CertAuthScheme();        scheme.setPathToKeyStore(keyStorePath);        scheme.setKeyStorePassword(keyStorePassword);        scheme.setKeystoreType(certificateAuthSettings.getKeyStoreType());        scheme.setKeyStore(certificateAuthSettings.getKeyStore());        scheme.setPort(certificateAuthSettings.getPort());        scheme.setTrustStore(certificateAuthSettings.getTrustStore());        scheme.setTrustStoreType(certificateAuthSettings.getTrustStoreType());        scheme.setPathToTrustStore(trustStorePath);        scheme.setTrustStorePassword(trustStorePassword);        scheme.setX509HostnameVerifier(certificateAuthSettings.getX509HostnameVerifier());        scheme.setSslSocketFactory(certificateAuthSettings.getSSLSocketFactory());        return scheme;    }
public static AuthenticationScheme oauth(String consumerKey, String consumerSecret, String accessToken, String secretToken, OAuthSignature signature) {        OAuthScheme scheme = new OAuthScheme();        scheme.setConsumerKey(consumerKey);        scheme.setConsumerSecret(consumerSecret);        scheme.setAccessToken(accessToken);        scheme.setSecretToken(secretToken);        scheme.setSignature(signature);        return scheme;    }
public static AuthenticationScheme oauth2(String accessToken) {        PreemptiveOAuth2HeaderScheme myScheme = new PreemptiveOAuth2HeaderScheme();        myScheme.setAccessToken(accessToken);        return myScheme;    }
public static AuthenticationScheme oauth2(String accessToken, OAuthSignature signature) {        OAuth2Scheme scheme = new OAuth2Scheme();        scheme.setAccessToken(accessToken);        scheme.setSignature(signature);        return scheme;    }
public static void reset() {        baseURI = DEFAULT_URI;        port = UNDEFINED_PORT;        basePath = DEFAULT_PATH;        authentication = DEFAULT_AUTH;        rootPath = DEFAULT_BODY_ROOT_PATH;        filters = new LinkedList<Filter>();        requestSpecification = null;        responseSpecification = null;        urlEncodingEnabled = DEFAULT_URL_ENCODING_ENABLED;        RESPONSE_PARSER_REGISTRAR = new ResponseParserRegistrar();        defaultParser = null;        config = new RestAssuredConfig();        sessionId = DEFAULT_SESSION_ID_VALUE;        proxy = null;    }
public static void useRelaxedHTTPSValidation(String protocol) {        config = RestAssured.config().sslConfig(SSLConfig.sslConfig().relaxedHTTPSValidation(protocol));    }
public static void enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) {        LogConfig logConfig = LogConfig.logConfig().enableLoggingOfRequestAndResponseIfValidationFails(logDetail);        config = RestAssured.config().logConfig(logConfig);        // Update request specification if already defined otherwise it'll override the configs.        // Note that request spec also influence response spec when it comes to logging if validation fails due to the way filters work        if (requestSpecification != null && requestSpecification instanceof RequestSpecificationImpl) {            RestAssuredConfig restAssuredConfig = ((RequestSpecificationImpl) requestSpecification).getConfig();            if (restAssuredConfig == null) {                restAssuredConfig = config;            } else {                LogConfig logConfigForRequestSpec = restAssuredConfig.getLogConfig().enableLoggingOfRequestAndResponseIfValidationFails(logDetail);                restAssuredConfig = restAssuredConfig.logConfig(logConfigForRequestSpec);            }            requestSpecification.config(restAssuredConfig);        }    }
public static void keyStore(String pathToJks, String password) {        Validate.notEmpty(password, "Password cannot be empty");        applyKeyStore(pathToJks, password);    }
public static void trustStore(String pathToJks, String password) {        Validate.notEmpty(password, "Password cannot be empty");        applyTrustStore(pathToJks, password);    }
public static void trustStore(KeyStore truststore) {        Validate.notNull(truststore, "Truststore cannot be null");        config = config().sslConfig(SSLConfig.sslConfig().trustStore(truststore));    }
public static void keyStore(File pathToJks, String password) {        Validate.notNull(pathToJks, "Path to JKS on the file system cannot be null");        applyKeyStore(pathToJks, password);    }
public static void trustStore(File pathToJks, String password) {        Validate.notNull(pathToJks, "Path to JKS on the file system cannot be null");        applyTrustStore(pathToJks, password);    }
public static void proxy(String host) {        if (UriValidator.isUri(host)) {            try {                proxy(new URI(host));            } catch (URISyntaxException e) {                throw new RuntimeException("Internal error in REST Assured when constructing URI for Proxy.", e);            }        } else {            proxy(host(host));        }    }
public static void proxy(String host, int port, String scheme) {        proxy(new ProxySpecification(host, port, scheme));    }
public static void proxy(URI uri) {        if (uri == null) {            throw new IllegalArgumentException("Proxy URI cannot be null");        }        proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme()));    }
public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) {        final StringBuilder builder = new StringBuilder();        if (logDetail == ALL || logDetail == STATUS) {            builder.append(responseOptions.statusLine());        }        if (logDetail == ALL || logDetail == HEADERS) {            final Headers headers = responseOptions.headers();            if (headers.exist()) {                appendNewLineIfAll(logDetail, builder).append(toString(headers));            }        } else if (logDetail == COOKIES) {            final Cookies cookies = responseOptions.detailedCookies();            if (cookies.exist()) {                appendNewLineIfAll(logDetail, builder).append(cookies.toString());            }        }        if (logDetail == ALL || logDetail == BODY) {            String responseBodyToAppend;            if (shouldPrettyPrint) {                responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody);            } else {                responseBodyToAppend = responseBody.asString();            }            if (logDetail == ALL && !isBlank(responseBodyToAppend)) {                builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR);            }            builder.append(responseBodyToAppend);        }        String response = builder.toString();        stream.println(response);        return response;    }
public RestAssuredConfig redirect(RedirectConfig redirectConfig) {        notNull(redirectConfig, "Redirect config");        return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class),                conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class),                conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class),                conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class));    }
public EncoderConfig defaultCharsetForContentType(String charset, String contentType) {        notNull(charset, "Charset");        notNull(contentType, "ContentType");        Map<String, String> map = new HashMap<String, String>(contentTypeToDefaultCharset);        map.put(trim(contentType).toLowerCase(), trim(charset));        return new EncoderConfig(charset, defaultQueryParameterCharset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, map, true);    }
public EncoderConfig defaultCharsetForContentType(Charset charset, ContentType contentType) {        notNull(charset, "Charset");        return defaultCharsetForContentType(charset.toString(), contentType);    }
public EncoderConfig defaultCharsetForContentType(Charset charset, String contentType) {        notNull(charset, "Charset");        return defaultCharsetForContentType(charset.toString(), contentType);    }
public EncoderConfig defaultContentCharset(Charset charset) {        String charsetAsString = notNull(charset, Charset.class).toString();        return new EncoderConfig(charsetAsString, defaultQueryParameterCharset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true);    }
public EncoderConfig defaultQueryParameterCharset(String charset) {        return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true);    }
public EncoderConfig appendDefaultContentCharsetToContentTypeIfUndefined(boolean shouldAddDefaultContentCharsetToContentTypeIfMissing) {        return new EncoderConfig(defaultContentCharset, defaultQueryParameterCharset, shouldAddDefaultContentCharsetToContentTypeIfMissing, contentEncoders, contentTypeToDefaultCharset, true);    }
public EncoderConfig encodeContentTypeAs(String contentType, ContentType encoder) {        notNull(contentType, "Content-Type to encode");        notNull(encoder, ContentType.class);        Map<String, ContentType> newMap = new HashMap<String, ContentType>(contentEncoders);        newMap.put(contentType, encoder);        return new EncoderConfig(defaultContentCharset, defaultQueryParameterCharset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, newMap, contentTypeToDefaultCharset, true);    }
public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) {        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory,                     johnzonObjectMapperFactory, true);    }
public ObjectMapperConfig gsonObjectMapperFactory(GsonObjectMapperFactory gsonObjectMapperFactory) {        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory,                     johnzonObjectMapperFactory, true);    }
public ObjectMapperConfig jackson1ObjectMapperFactory(Jackson1ObjectMapperFactory jackson1ObjectMapperFactory) {        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory,                     johnzonObjectMapperFactory, true);    }
public ObjectMapperConfig jackson2ObjectMapperFactory(Jackson2ObjectMapperFactory jackson2ObjectMapperFactory) {        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory,                    johnzonObjectMapperFactory, true);    }
public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) {        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory,                     johnzonObjectMapperFactory, true);    }
public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) {        notNull(logConfig, "Log config");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) {        notNull(sessionConfig, "Session config");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) {        notNull(objectMapperConfig, "Object mapper config");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) {        notNull(jsonConfig, "JsonConfig");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) {        notNull(xmlConfig, "XmlConfig");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) {        notNull(encoderConfig, "EncoderConfig");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) {        notNull(headerConfig, "HeaderConfig");        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) {        notNull(asyncConfig, AsyncConfig.class);        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) {        notNull(mockMvcConfig, MockMvcConfig.class);        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) {        notNull(multiPartConfig, MultiPartConfig.class);        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) {        notNull(paramConfig, MultiPartConfig.class);        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) {        notNull(matcherConfig, MatcherConfig.class);        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);    }
public static String urlDecode(final String content, final Charset charset, final boolean plusAsBlank) {		if (content == null) {			return null;		}		final ByteBuffer bb = ByteBuffer.allocate(content.length());		final CharBuffer cb = CharBuffer.wrap(content);		while (cb.hasRemaining()) {			final char c = cb.get();			if (c == '%' && cb.remaining() >= 2) {				final char uc = cb.get();				final char lc = cb.get();				final int u = Character.digit(uc, 16);				final int l = Character.digit(lc, 16);				if (u != -1 && l != -1) {					bb.put((byte) ((u << 4) + l));				} else {					bb.put((byte) '%');					bb.put((byte) uc);					bb.put((byte) lc);				}			} else if (plusAsBlank && c == '+') {				bb.put((byte) ' ');			} else {				bb.put((byte) c);			}		}		bb.flip();		return charset.decode(bb).toString();	}
private Response cloneResponseIfNeeded(Response response, byte[] responseAsString) {        if (responseAsString != null && response instanceof RestAssuredResponseImpl && !((RestAssuredResponseImpl) response).getHasExpectations()) {            final Response build = new ResponseBuilder().clone(response).setBody(responseAsString).build();            ((RestAssuredResponseImpl) build).setHasExpectations(true);            return build;        }        return response;    }
public CertificateAuthSettings strictHostnames() {        return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, STRICT_HOSTNAME_VERIFIER, sslSocketFactory);    }
public CertificateAuthSettings allowAllHostnames() {        return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory);    }
public CertificateAuthSettings x509HostnameVerifier(X509HostnameVerifier x509HostnameVerifier) {        return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, x509HostnameVerifier, sslSocketFactory);    }
public XmlPathConfig features(Map<String, Boolean> features) {        Validate.notNull(features, "Features cannot be null");        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, declaredNamespaces,                properties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig feature(String uri, boolean enabled) {        Validate.notEmpty(uri, "URI cannot be empty");        Map<String, Boolean> newFeatures = new HashMap<String, Boolean>(features);        newFeatures.put(uri, enabled);        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, newFeatures, declaredNamespaces, properties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig properties(Map<String, Object> properties) {        Validate.notNull(properties, "Properties cannot be null");        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, declaredNamespaces,                properties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig property(String name, Object value) {        Validate.notEmpty(name, "Name cannot be empty");        Map<String, Object> newProperties = new HashMap<String, Object>(properties);        newProperties.put(name, value);        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, declaredNamespaces,                newProperties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig disableLoadingOfExternalDtd() {        Map<String, Boolean> newFeatures = new HashMap<String, Boolean>(features);        newFeatures.put("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);        newFeatures.put("http://apache.org/xml/features/disallow-doctype-decl", false);        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, newFeatures, declaredNamespaces,                properties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig defaultObjectDeserializer(XmlPathObjectDeserializer defaultObjectDeserializer) {        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultObjectDeserializer, charset, features, declaredNamespaces,                properties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) {        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare,                properties, validating, namespaceAware, allowDocTypeDeclaration);    }
public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) {        Validate.notEmpty(prefix, "Prefix cannot be empty");        Validate.notEmpty(namespaceURI, "Namespace URI cannot be empty");        Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces);        updatedNamespaces.put(prefix, namespaceURI);        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces,                properties, validating, true, allowDocTypeDeclaration);    }
public Object get(Map<String, ?> args)            throws ClientProtocolException, IOException, URISyntaxException {        return this.get(args, null);    }
public Object get(Map<String, ?> args, Closure responseClosure)            throws ClientProtocolException, IOException, URISyntaxException {        RequestConfigDelegate delegate = new RequestConfigDelegate(new HttpGet(),                this.defaultContentType,                this.defaultRequestHeaders,                this.defaultResponseHandlers);        delegate.setPropertiesFromMap(args);        if (responseClosure != null) delegate.getResponse().put(                Status.SUCCESS, responseClosure);        return this.doRequest(delegate);    }
public Object post(Map<String, ?> args)            throws ClientProtocolException, URISyntaxException, IOException {        return this.post(args, null);    }
public Object patch(Map<String, ?> args)            throws ClientProtocolException, URISyntaxException, IOException {        return this.patch(args, null);    }
public Object patch(Map<String, ?> args, Closure responseClosure)            throws URISyntaxException, ClientProtocolException, IOException {        RequestConfigDelegate delegate = new RequestConfigDelegate(new HttpPatch(),                this.defaultContentType,                this.defaultRequestHeaders,                this.defaultResponseHandlers);        /* by default assume the request body will be URLEncoded, but allow             the 'requestContentType' named argument to override this if it is             given */        delegate.setRequestContentType(ContentType.URLENC.toString());        delegate.setPropertiesFromMap(args);        if (responseClosure != null) {            delegate.getResponse().put(Status.SUCCESS.toString(), responseClosure);            delegate.getResponse().put(Status.FAILURE.toString(), responseClosure);        }        return this.doRequest(delegate);    }
public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException {        return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure);    }
public Object request(Object uri, String method, Object contentType, boolean hasBody, Closure configClosure)            throws ClientProtocolException, IOException, URISyntaxException {        return this.doRequest(URIBuilder.convertToURI(uri), method, contentType, hasBody, configClosure);    }
protected Object doRequest(URI uri, String method, Object contentType, boolean hasBody, Closure configClosure) throws IOException {        HttpRequestBase reqMethod = HttpRequestFactory.createHttpRequest(uri, method, hasBody);        RequestConfigDelegate delegate = new RequestConfigDelegate(reqMethod, contentType,                this.defaultRequestHeaders,                this.defaultResponseHandlers);        configClosure.setDelegate(delegate);        configClosure.setResolveStrategy(Closure.DELEGATE_FIRST);        configClosure.call(reqMethod);        return this.doRequest(delegate);    }
protected Object parseResponse(HttpResponse resp, Object contentType)            throws IOException {        // For HEAD or OPTIONS requests, there should be no response entity.        if (resp.getEntity() == null) {            log.debug("Response contains no entity.  Parsed data is null.");            return null;        }        // first, start with the _given_ content-type        String responseContentType = contentType.toString();        // if the given content-type is ANY ("*/*") then use the response content-type        try {            if (ContentType.ANY.toString().equals(responseContentType))                responseContentType = HttpResponseContentTypeFinder.findContentType(resp);        } catch (RuntimeException ex) {            /* if for whatever reason we can't determine the content-type, but                * still want to attempt to parse the data, use the BINARY                * content-type so that the response will be buffered into a                * ByteArrayInputStream. */            responseContentType = ContentType.BINARY.toString();        }        Object parsedData = null;        log.debug("Parsing response as: " + responseContentType);        parsedData = resp.getEntity().getContent();        if (parsedData == null) log.debug("Parser returned null!");        else log.debug("Parsed data to instance of: " + parsedData.getClass());        return parsedData;    }
protected Map<Object, Closure> buildDefaultResponseHandlers() {        Map<Object, Closure> map = new StringHashMap<Closure>();        map.put(Status.SUCCESS,                new MethodClosure(this, "defaultSuccessHandler"));        map.put(Status.FAILURE,                new MethodClosure(this, "defaultFailureHandler"));        return map;    }
protected Object defaultSuccessHandler(HttpResponseDecorator resp, Object parsedData)            throws ResponseParseException {        try {            //If response is streaming, buffer it in a byte array:            if (parsedData instanceof InputStream) {                ByteArrayOutputStream buffer = new ByteArrayOutputStream();                DefaultGroovyMethods.leftShift(buffer, (InputStream) parsedData);                parsedData = new ByteArrayInputStream(buffer.toByteArray());            } else if (parsedData instanceof Reader) {                StringWriter buffer = new StringWriter();                DefaultGroovyMethods.leftShift(buffer, (Reader) parsedData);                parsedData = new StringReader(buffer.toString());            } else if (parsedData instanceof Closeable)                log.debug("Parsed data is streaming, but will be accessible after " +                        "the network connection is closed.  Use at your own risk!");            return parsedData;        } catch (IOException ex) {            throw new ResponseParseException(resp, ex);        }    }
public void setUri(Object uri) throws URISyntaxException {        this.defaultURI = new URIBuilder(URIBuilder.convertToURI(uri), urlEncodingEnabled, encoderConfig);    }
public void setHeaders(Map<?, ?> headers) {        this.defaultRequestHeaders.clear();        if (headers == null) return;        for (Object key : headers.keySet()) {            Object val = headers.get(key);            if (val == null) continue;            this.defaultRequestHeaders.put(key.toString(), val.toString());        }    }
public void setProxy(String host, int port, String scheme) {        getClient().getParams().setParameter(                ConnRoutePNames.DEFAULT_PROXY,                new HttpHost(host, port, scheme));    }
public MultiPartSpecBuilder controlName(String controlName) {        Validate.notEmpty(controlName, "Control name cannot be empty");        this.controlName = controlName;        this.isControlNameExplicit = true;        return this;    }
public MultiPartSpecBuilder header(String name, String value) {        Validate.notEmpty(name, "Header name cannot be empty");        Validate.notEmpty(value, "Header value cannot be empty");        // Replace previous header if exists        final Set<String> headerNames = headers.keySet();        final String trimmedName = name.trim();        for (String headerName : headerNames) {            if (headerName.equalsIgnoreCase(trimmedName)) {                headers.remove(headerName);            }        }        // Put the name header in the header list        headers.put(name, value);        return this;    }
public MultiPartSpecBuilder headers(Map<String, String> headers) {        if (headers == null) {            this.headers = new HashMap<String, String>();        } else {            this.headers = new HashMap<String, String>(headers);        }        return this;    }
public MultiPartSpecBuilder charset(String charset) {        Validate.notEmpty(charset, "Charset cannot be empty");        if (content instanceof byte[] || content instanceof InputStream) {            throw new IllegalArgumentException("Cannot specify charset input streams or byte arrays.");        }        this.charset = charset;        return this;    }
public MultiPartSpecBuilder charset(Charset charset) {        Validate.notNull(charset, "Charset cannot be null");        this.charset = charset.toString();        return this;    }
protected Map<String, ContentEncoding> getDefaultEncoders() {        Map<String, ContentEncoding> map = new HashMap<String, ContentEncoding>();        map.put(Type.GZIP.toString(), new GZIPEncoding());        map.put(Type.DEFLATE.toString(), new DeflateEncoding(useNoWrapForInflateDecoding));        return map;    }
void setInterceptors(final AbstractHttpClient client, Object... encodings) {        // remove any encoding interceptors that are already set        client.removeRequestInterceptorByClass(ContentEncoding.RequestInterceptor.class);        client.removeResponseInterceptorByClass(ContentEncoding.ResponseInterceptor.class);        for (Object encName : encodings) {            ContentEncoding enc = availableEncoders.get(encName.toString());            if (enc == null) continue;            client.addRequestInterceptor(enc.getRequestInterceptor());            client.addResponseInterceptor(enc.getResponseInterceptor());        }    }
public void basic(String user, String pass) {        URI uri = ((URIBuilder) builder.getUri()).toURI();        if (uri == null) throw new IllegalStateException("a default URI must be set");        this.basic(uri.getHost(), uri.getPort(), user, pass);    }
public void basic(String host, int port, String user, String pass) {        builder.getClient().getCredentialsProvider().setCredentials(                new AuthScope(host, port),                new UsernamePasswordCredentials(user, pass)        );    }
public void ntlm(String user, String pass, String workstation, String domain) {        URI uri = ((URIBuilder) builder.getUri()).toURI();        if (uri == null) throw new IllegalStateException("a default URI must be set");        this.ntlm(uri.getHost(), uri.getPort(), user, pass,workstation,domain);    }
public void ntlm(String host, int port, String user, String pass, String workstation, String domain) {        builder.getClient().getCredentialsProvider().setCredentials(                new AuthScope(host, port),                new NTCredentials(user, pass, workstation, domain)        );    }
public void certificate(Object keyStorePath, String keyStorePassword, String keyStoreType, KeyStore keyStore,                            Object trustStorePath, String trustStorePassword, String trustStoreType, KeyStore trustStore,                            int port, X509HostnameVerifier hostnameVerifier, SSLSocketFactory sslConnectionSocketFactory) {        TrustAndKeystoreSpecImpl spec = new TrustAndKeystoreSpecImpl();        URI uri = ((URIBuilder) builder.getUri()).toURI();        if (uri == null) throw new IllegalStateException("a default URI must be set");        spec.setKeyStoreType(keyStoreType);        spec.setKeyStorePassword(keyStorePassword);        spec.setKeyStorePath(keyStorePath);        spec.setKeyStore(keyStore);        spec.setTrustStoreType(trustStoreType);        spec.setTrustStorePassword(trustStorePassword);        spec.setTrustStorePath(trustStorePath);        spec.setTrustStore(trustStore);        spec.setPort(port);        spec.setX509HostnameVerifier(hostnameVerifier);        spec.setFactory(sslConnectionSocketFactory);        int portSpecifiedInUri = uri.getPort();        spec.apply(builder, portSpecifiedInUri == UNDEFINED_PORT ? DEFAULT_HTTPS_PORT : portSpecifiedInUri);    }
public void oauth(String consumerKey, String consumerSecret,                      String accessToken, String secretToken) {        this.builder.client.removeRequestInterceptorByClass(OAuthSigner.class);        if (consumerKey != null) {            this.builder.client.addRequestInterceptor(new OAuthSigner(                    consumerKey, consumerSecret, accessToken, secretToken, OAuthSignature.HEADER,                    raOAuthConfig.shouldAddEmptyAccessOAuthTokenToBaseString()));        }    }
public void oauth2(String accessToken) {        this.builder.client.removeRequestInterceptorByClass(OAuthSigner.class);        if (accessToken != null) {            this.builder.client.addRequestInterceptor(new OAuthSigner(accessToken, OAuthSignature.HEADER));        }    }
public static String findContentType(HttpResponse resp) {        Header contentTypeHeader = resp.getFirstHeader(HttpHeaders.CONTENT_TYPE);        if ( contentTypeHeader == null )            throw new IllegalArgumentException( "Response does not have a content-type header" );        try {            return contentTypeHeader.getValue();        }        catch ( RuntimeException ex ) {  // NPE or OOB Exceptions            throw new IllegalArgumentException( "Could not parse content-type from response" );        }    }
public static Headers headers(Header header, Header... additionalHeaders) {        notNull(header, "Header");        final List<Header> headerList = new LinkedList<Header>();        headerList.add(header);        if (additionalHeaders != null) {            Collections.addAll(headerList, additionalHeaders);        }        return new Headers(headerList);    }
public static MockMvcRequestSpecification given() {        return new MockMvcRequestSpecificationImpl(mockMvcFactory, config, resultHandlers, requestPostProcessors, basePath, requestSpecification, responseSpecification, authentication);    }
public static void reset() {        mockMvcFactory = null;        config = null;        basePath = "/";        resultHandlers.clear();        requestPostProcessors.clear();        responseSpecification = null;        requestSpecification = null;        authentication = null;    }
public static MockMvcResponse get(String path, Object... pathParams) {        return given().get(path, pathParams);    }
public static MockMvcResponse get(String path, Map<String, ?> pathParams) {        return given().get(path, pathParams);    }
public static MockMvcResponse post(String path, Object... pathParams) {        return given().post(path, pathParams);    }
public static MockMvcResponse post(String path, Map<String, ?> pathParams) {        return given().post(path, pathParams);    }
public static MockMvcResponse put(String path, Object... pathParams) {        return given().put(path, pathParams);    }
public static MockMvcResponse delete(String path, Object... pathParams) {        return given().delete(path, pathParams);    }
public static MockMvcResponse delete(String path, Map<String, ?> pathParams) {        return given().delete(path, pathParams);    }
public static MockMvcResponse head(String path, Object... pathParams) {        return given().head(path, pathParams);    }
public static MockMvcResponse head(String path, Map<String, ?> pathParams) {        return given().head(path, pathParams);    }
public static MockMvcResponse patch(String path, Object... pathParams) {        return given().patch(path, pathParams);    }
public static MockMvcResponse patch(String path, Map<String, ?> pathParams) {        return given().patch(path, pathParams);    }
public static MockMvcResponse options(String path, Object... pathParams) {        return given().options(path, pathParams);    }
public static MockMvcResponse options(String path, Map<String, ?> pathParams) {        return given().options(path, pathParams);    }
public static MockMvcResponse request(Method method, URI uri) {            return given().request(method, uri);        }
public static MockMvcResponse request(Method method, URL url) {            return given().request(method, url);        }
public static MockMvcResponse request(String method, URI uri) {            return given().request(method, uri);        }
public static MockMvcResponse request(String method, URL url) {            return given().request(method, url);        }
public static MockMvcAuthenticationScheme principal(final Principal principal) {        return new MockMvcAuthenticationScheme() {            public void authenticate(MockMvcRequestSpecification mockMvcRequestSpecification) {                mockMvcRequestSpecification.auth().principal(principal);            }        };    }
public static MockMvcAuthenticationScheme principal(final Object principal) {        return new MockMvcAuthenticationScheme() {            public void authenticate(MockMvcRequestSpecification mockMvcRequestSpecification) {                mockMvcRequestSpecification.auth().principal(principal);            }        };    }
public static MockMvcAuthenticationScheme principalWithCredentials(final Object principal, final Object credentials, final String... authorities) {        return new MockMvcAuthenticationScheme() {            public void authenticate(MockMvcRequestSpecification mockMvcRequestSpecification) {                mockMvcRequestSpecification.auth().principalWithCredentials(principal, credentials, authorities);            }        };    }
public static MockMvcAuthenticationScheme authentication(final Object authentication) {        return new MockMvcAuthenticationScheme() {            public void authenticate(MockMvcRequestSpecification mockMvcRequestSpecification) {                mockMvcRequestSpecification.auth().authentication(authentication);            }        };    }
public static MockMvcAuthenticationScheme with(final RequestPostProcessor requestPostProcessor, final RequestPostProcessor... additionalRequestPostProcessor) {        return new MockMvcAuthenticationScheme() {            public void authenticate(MockMvcRequestSpecification mockMvcRequestSpecification) {                mockMvcRequestSpecification.auth().with(requestPostProcessor, additionalRequestPostProcessor);            }        };    }
public static void enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) {        config = config == null ? new RestAssuredMockMvcConfig() : config;        config = config.logConfig(logConfig().enableLoggingOfRequestAndResponseIfValidationFails(logDetail));        // Update request specification if already defined otherwise it'll override the configs.        // Note that request spec also influence response spec when it comes to logging if validation fails due to the way filters work        if (requestSpecification != null && requestSpecification instanceof MockMvcRequestSpecificationImpl) {            RestAssuredMockMvcConfig restAssuredConfig = ((MockMvcRequestSpecificationImpl) requestSpecification).getRestAssuredMockMvcConfig();            if (restAssuredConfig == null) {                restAssuredConfig = config;            } else {                LogConfig logConfigForRequestSpec = restAssuredConfig.getLogConfig().enableLoggingOfRequestAndResponseIfValidationFails(logDetail);                restAssuredConfig = restAssuredConfig.logConfig(logConfigForRequestSpec);            }            requestSpecification.config(restAssuredConfig);        }    }
public static ResponseAwareMatcher<MockMvcResponse> equalToPath(final String path) {        return new ResponseAwareMatcher<MockMvcResponse>() {            public Matcher<?> matcher(MockMvcResponse response) {                return equalTo(response.path(path));            }        };    }
public static ResponseAwareMatcher<MockMvcResponse> endsWithPath(final String path) {        return new ResponseAwareMatcher<MockMvcResponse>() {            public Matcher<?> matcher(MockMvcResponse response) {                return endsWith(response.<String>path(path));            }        };    }
public static ResponseAwareMatcher<MockMvcResponse> startsWithPath(final String path) {        return new ResponseAwareMatcher<MockMvcResponse>() {            public Matcher<?> matcher(MockMvcResponse response) {                return startsWith(response.<String>path(path));            }        };    }
public static ResponseAwareMatcher<MockMvcResponse> containsPath(final String path) {        return new ResponseAwareMatcher<MockMvcResponse>() {            public Matcher<?> matcher(MockMvcResponse response) {                return containsString(response.<String>path(path));            }        };    }
public ResponseBuilder setContentType(String contentType) {        notNull(contentType, "Content type");        restAssuredResponse.setContentType(contentType);        setHeader(CONTENT_TYPE, contentType);        return this;    }
public ResponseBuilder setContentType(ContentType contentType) {        notNull(contentType, ContentType.class);        return setContentType(contentType.toString());    }
public ResponseBuilder setHeader(String name, String value) {        notNull(name, "Header name");        notNull(value, "Header value");        List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList());        newHeaders.add(new Header(name, value));        restAssuredResponse.setResponseHeaders(new Headers(newHeaders));        if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) {            restAssuredResponse.setContentType(value);        }        return this;    }
public Response build() {        final int statusCode = restAssuredResponse.statusCode();        if (statusCode < 100 || statusCode >= 600) {            throw new IllegalArgumentException(format("Status code must be greater than 100 and less than 600, was %d.", statusCode));        }        if (StringUtils.isBlank(restAssuredResponse.statusLine())) {            restAssuredResponse.setStatusLine(restAssuredResponse.statusCode());        }        restAssuredResponse.setRpr(new ResponseParserRegistrar());        return restAssuredResponse;    }
public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("value", valueMatcher)));    }
public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("comment", commentMatcher)));    }
public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("expiryDate", expiryDateMatcher)));    }
public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("domain", domainMatcher)));    }
public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("path", pathMatcher)));    }
public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("secured", securedMatcher)));    }
public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("httpOnly", httpOnlyMatcher)));    }
public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("version", versionMatcher)));    }
public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) {        return new DetailedCookieMatcher(and(Matchers.hasProperty("maxAge", maxAgeMatcher)));    }
public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) {        spec.header(headerName, expectedValueMatcher);        return this;    }
public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) {        spec.header(headerName, expectedValue);        return this;    }
public ResponseSpecBuilder expectCookie(String cookieName, Matcher<String> expectedValueMatcher) {        spec.cookie(cookieName, expectedValueMatcher);        return this;    }
public ResponseSpecBuilder expectCookie(String cookieName, DetailedCookieMatcher detailedCookieMatcher) {        spec.cookie(cookieName, detailedCookieMatcher);        return this;    }
public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {        spec.cookie(cookieName, expectedValue);        return this;    }
public ResponseSpecBuilder expectResponseTime(Matcher<Long> matcher, TimeUnit timeUnit) {        spec.time(matcher, timeUnit);        return this;    }
public ResponseSpecBuilder rootPath(String rootPath, List<Argument> arguments) {        spec.root(rootPath, arguments);        return this;    }
public ResponseSpecBuilder appendRootPath(String pathToAppend, List<Argument> arguments) {        spec.appendRootPath(pathToAppend, arguments);        return this;    }
public ResponseSpecBuilder expectBody(String path, Matcher<?> matcher) {        spec.body(path, matcher);        return this;    }
public ResponseSpecBuilder expectBody(String path, List<Argument> arguments, Matcher<?> matcher) {        spec.body(path, arguments, matcher);        return this;    }
public ResponseSpecBuilder addResponseSpecification(ResponseSpecification specification) {        if (!(specification instanceof ResponseSpecificationImpl)) {            throw new IllegalArgumentException("specification must be of type " + ResponseSpecificationImpl.class.getClass() + ".");        }        ResponseSpecificationImpl rs = (ResponseSpecificationImpl) specification;        SpecificationMerger.merge((ResponseSpecificationImpl) spec, rs);        return this;    }
public ResponseSpecBuilder log(LogDetail logDetail) {        notNull(logDetail, LogDetail.class);        spec.logDetail(logDetail);        return this;    }
public ResponseSpecBuilder registerParser(String contentType, Parser parser) {        spec.parser(contentType, parser);        return this;    }
public static JsonSchemaValidator matchesJsonSchema(String schema) {        return new JsonSchemaValidatorFactory<String>() {            @Override            JsonNode createSchemaInstance(String input) throws IOException {                return JsonLoader.fromString(input);            }        }.create(schema);    }
public static JsonSchemaValidator matchesJsonSchemaInClasspath(String pathToSchemaInClasspath) {        return matchesJsonSchema(Thread.currentThread().getContextClassLoader().getResource(pathToSchemaInClasspath));    }
public static JsonSchemaValidator matchesJsonSchema(Reader schema) {        return new JsonSchemaValidatorFactory<Reader>() {            @Override            JsonNode createSchemaInstance(Reader input) throws IOException {                return JsonLoader.fromReader(input);            }        }.create(schema);    }
public static JsonSchemaValidator matchesJsonSchema(File file) {        return new JsonSchemaValidatorFactory<File>() {            @Override            JsonNode createSchemaInstance(File input) throws IOException {                return JsonLoader.fromFile(input);            }        }.create(file);    }
@SuppressWarnings("unchecked")    public static <T extends ResponseBody<T> & ResponseOptions<T>> ResponseAwareMatcher<T> and(            final ResponseAwareMatcher<T> matcher1, final ResponseAwareMatcher<T> matcher2) {        return and(matcher1, matcher2, new ResponseAwareMatcher[0]);    }
@SuppressWarnings("unchecked")    public static <T extends ResponseBody<T> & ResponseOptions<T>> ResponseAwareMatcher<T> and(            final ResponseAwareMatcher<T> matcher1, final ResponseAwareMatcher<T> matcher2,            final ResponseAwareMatcher<T>... additionalMatchers) {        return response -> {            Matcher<?>[] matchers = toHamcrestMatchers(response, matcher1, matcher2, additionalMatchers);            return allOf((Matcher<? super Object>[]) matchers);        };    }
@SuppressWarnings("unchecked")    public static <T extends ResponseBody<T> & ResponseOptions<T>> ResponseAwareMatcher<T> or(            final ResponseAwareMatcher<T> matcher1, final ResponseAwareMatcher<T> matcher2,            final ResponseAwareMatcher<T>... additionalMatchers) {        return response -> {            Matcher<?>[] matchers = toHamcrestMatchers(response, matcher1, matcher2, additionalMatchers);            return anyOf((Matcher<? super Object>[]) matchers);        };    }
public T get(String entityName) {        notNull(entityName, "Entity name");        List<T> copyOfEntities = reverse();        for (T entity : copyOfEntities) {            if(entity.getName().equalsIgnoreCase(entityName)) {                return entity;            }        }        return null;    }
public String getValue(String entityName) {        notNull(entityName, "Entity name");        final T entity = get(entityName);        if(entity == null) {            return null;        }        return entity.getValue();    }
public List<T> getList(String entityName) {        notNull(entityName, "Entity name");        final List<T> entityList = new ArrayList<T>();        for (T entity : entities) {            if(entity.getName().equalsIgnoreCase(entityName)) {                entityList.add(entity);            }        }        return Collections.unmodifiableList(entityList);    }
public List<String> getValues(String entityName) {        final List<T> list = getList(entityName);        final List<String> stringList = new LinkedList<String>();        for (T entity : list) {            stringList.add(entity.getValue());        }        return Collections.unmodifiableList(stringList);    }
public static ProxySpecification host(String host) {        return new ProxySpecification(host, DEFAULT_PORT, DEFAULT_SCHEME, DEFAULT_USERNAME, DEFAULT_PASSWORD);    }
public static ProxySpecification auth(String username, String password) {        AssertParameter.notNull(username, "username");        AssertParameter.notNull(password, "password");        return new ProxySpecification(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_SCHEME, username, password);    }
public ProxySpecification withHost(String host) {        return new ProxySpecification(host, port, scheme, username, password);    }
public ProxySpecification withAuth(String username, String password) {        AssertParameter.notNull(username, "username");        AssertParameter.notNull(password, "password");        return new ProxySpecification(host, port, scheme, username, password);    }
public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) {        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory,                     johnzonObjectMapperFactory, defaultDeserializer, charset);    }
public JsonPathConfig defaultParserType(JsonParserType defaultParserType) {        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory,                     johnzonObjectMapperFactory, defaultDeserializer, charset);    }
public JsonPathConfig defaultObjectDeserializer(JsonPathObjectDeserializer defaultObjectDeserializer) {        return new JsonPathConfig(numberReturnType, null, gsonObjectMapperFactory, jackson1ObjectMapperFactory,                jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultObjectDeserializer, charset);    }
public JsonPathConfig gsonObjectMapperFactory(GsonObjectMapperFactory gsonObjectMapperFactory) {        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory,                     johnzonObjectMapperFactory, defaultDeserializer, charset);    }
public JsonPathConfig jackson1ObjectMapperFactory(Jackson1ObjectMapperFactory jackson1ObjectMapperFactory) {        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory,                     johnzonObjectMapperFactory, defaultDeserializer, charset);    }
public JsonPathConfig jackson2ObjectMapperFactory(Jackson2ObjectMapperFactory jackson2ObjectMapperFactory) {        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory,                jackson1ObjectMapperFactory, jackson2ObjectMapperFactory,                     johnzonObjectMapperFactory, defaultDeserializer, charset);    }
public static boolean isUri(String potentialUri) {        if (StringUtils.isBlank(potentialUri)) {            return false;        }        try {            URI uri = new URI(potentialUri);            return uri.getScheme() != null && uri.getHost() != null;        } catch (URISyntaxException e) {            return false;        }    }
public LogConfig defaultStream(PrintStream printStream) {        return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true);    }
public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) {        return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true);    }
public static String findContentType(Headers headers, List<Object> multiParts, SpecificationConfig config) {        String requestContentType = headers.getValue(CONTENT_TYPE);        if (StringUtils.isBlank(requestContentType) && !multiParts.isEmpty()) {            requestContentType = "multipart/" + config.getMultiPartConfig().defaultSubtype();        }        EncoderConfig encoderConfig = config.getEncoderConfig();        if (requestContentType != null && encoderConfig.shouldAppendDefaultContentCharsetToContentTypeIfUndefined() && !StringUtils.containsIgnoreCase(requestContentType, CHARSET)) {            // Append default charset to request content type            requestContentType += "; charset=";            if (encoderConfig.hasDefaultCharsetForContentType(requestContentType)) {                requestContentType += encoderConfig.defaultCharsetForContentType(requestContentType);            } else {                requestContentType += encoderConfig.defaultContentCharset();            }        }        return requestContentType;    }
static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) {        String method = notNull(upperCase(trimToNull(httpMethod)), "Http method");        Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method);        final HttpRequestBase httpRequest;        // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents        // us from including it, however we chose to allow deviations from standard if user wants so,        // so it needs custom handling - hence the second condition below.        // Otherwise we should use standard implementation found in the map        if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) {            httpRequest = new CustomHttpMethod(method, uri);        } else {            try {                httpRequest = type.newInstance();            } catch (Exception e) {                throw new RuntimeException(e);            }            httpRequest.setURI(uri);        }        return httpRequest;    }
public static MockMvcFactory of(Object[] controllerOrMockMvcConfigurers) {        List<Object> controllers = new ArrayList<Object>();        List<MockMvcConfigurer> configurers = new ArrayList<MockMvcConfigurer>();        for (Object object : controllerOrMockMvcConfigurers) {            if (object instanceof MockMvcConfigurer) {                configurers.add((MockMvcConfigurer) object);            } else {                controllers.add(object);            }        }        StandaloneMockMvcBuilder mockMvc = MockMvcBuilders.standaloneSetup(controllers.toArray());        if (!configurers.isEmpty()) {            for (MockMvcConfigurer configurer : configurers) {                mockMvc.apply(configurer);            }        }        return new MockMvcFactory(mockMvc);    }
public HeaderConfig overwriteHeadersWithName(String headerName, String... additionalHeaderNames) {        notNull(headerName, "Header name");        Map<String, Boolean> map = newHashMapReturningFalseByDefault(headerName);        if (additionalHeaderNames != null && additionalHeaderNames.length > 0) {            for (String additionalHeaderName : additionalHeaderNames) {                map.put(additionalHeaderName.toUpperCase(), true);            }        }        return new HeaderConfig(map, true);    }
public MultiPartConfig defaultControlName(String defaultControlName) {        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true);    }
public MultiPartConfig defaultFileName(String defaultFileName) {        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true);    }
public MultiPartConfig defaultSubtype(String defaultSubtype) {        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true);    }
public MultiPartConfig defaultBoundary(String defaultBoundary) {        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true);    }
public MultiPartConfig defaultCharset(String defaultCharset) {        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true);    }
public MultiPartConfig defaultCharset(Charset defaultCharset) {        String charsetAsString = AssertParameter.notNull(defaultCharset, Charset.class).toString();        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, charsetAsString, true);    }
public MockMvcRequestSpecBuilder setBody(Object object, ObjectMapper mapper) {        spec.body(object, mapper);        return this;    }
public MockMvcRequestSpecBuilder setBody(Object object, ObjectMapperType mapperType) {        spec.body(object, mapperType);        return this;    }
MockMvcRequestSpecBuilder addSessionAttr(String name, Object value) {        spec.sessionAttr(name, value);        return this;    }
public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) {        spec.attribute(attributeName, attributeValue);        return this;    }
public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) {        spec.header(headerName, headerValue);        return this;    }
public MockMvcRequestSpecBuilder addMultiPart(String controlName, File file) {        spec.multiPart(controlName, file);        return this;    }
public MockMvcRequestSpecBuilder addMultiPart(String controlName, String fileName, byte[] bytes) {        spec.multiPart(controlName, fileName, bytes);        return this;    }
public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody) {        spec.multiPart(controlName, contentBody);        return this;    }
public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) {        spec.multiPart(controlName, mimeType);        return this;    }
public MockMvcRequestSpecBuilder setSessionId(String sessionIdName, String sessionIdValue) {        spec.sessionId(sessionIdName, sessionIdValue);        return this;    }
public MockMvcRequestSpecBuilder setWebAppContextSetup(WebApplicationContext context, MockMvcConfigurer... mockMvcConfigurers) {        spec.webAppContextSetup(context, mockMvcConfigurers);        return this;    }
public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) {        spec.resultHandlers(resultHandler, additionalResultHandlers);        return this;    }
public MockMvcRequestSpecBuilder log(LogDetail logDetail) {        notNull(logDetail, LogDetail.class);        LogConfig logConfig = spec.getRestAssuredMockMvcConfig().getLogConfig();        PrintStream printStream = logConfig.defaultStream();        boolean prettyPrintingEnabled = logConfig.isPrettyPrintingEnabled();        boolean shouldUrlEncodeRequestUri = logConfig.shouldUrlEncodeRequestUri();        spec.setRequestLoggingFilter(new RequestLoggingFilter(logDetail, prettyPrintingEnabled, printStream, shouldUrlEncodeRequestUri));        return this;    }
public <T> HttpClientConfig setParam(String parameterName, T parameterValue) {        notNull(parameterName, "Parameter name");        final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams);        newParams.put(parameterName, parameterValue);        return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);    }
public HttpClientConfig withParams(Map<String, ?> httpClientParams) {        return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);    }
public HttpClientConfig addParams(Map<String, ?> httpClientParams) {        notNull(httpClientParams, "httpClientParams");        final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams);        newParams.putAll(httpClientParams);        return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);    }
public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) {        return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);    }
public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) {        return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true);    }
public <T> T get(String path) {        final JSONAssertion jsonAssertion = createJsonAssertion(path, params);        final Object json = jsonParser.parseWith(createConfigurableJsonSlurper());        return (T) jsonAssertion.getResult(json, null);    }
public int getInt(String path) {        //The type returned from Groovy depends on the input, so we need to handle different numerical types.        Object value = get(path);        if (value instanceof Integer) {            return (Integer) value;        } else if (value instanceof Short) {            return ((Short) value).intValue();        } else if (value instanceof Long) {            return ((Long) value).intValue();        } else {            return ObjectConverter.convertObjectTo(value, Integer.class);        }    }
public byte getByte(String path) {        //The type returned from Groovy depends on the input, so we need to handle different numerical types.        Object value = get(path);        if (value instanceof Byte) {            return (Byte) value;        } else if (value instanceof Long) {            return ((Long) value).byteValue();        } else if (value instanceof Integer) {            return ((Integer) value).byteValue();        } else {            return ObjectConverter.convertObjectTo(value, Byte.class);        }    }
public short getShort(String path) {        //The type returned from Groovy depends on the input, so we need to handle different numerical types.        Object value = get(path);        if (value instanceof Short) {            return (Short) value;        } else if (value instanceof Long) {            return ((Long) value).shortValue();        } else if (value instanceof Integer) {            return ((Integer) value).shortValue();        } else {            return ObjectConverter.convertObjectTo(value, Short.class);        }    }
public float getFloat(String path) {        final Object value = get(path);        //Groovy will always return a Double for floating point values.        if (value instanceof Double) {            return ((Double) value).floatValue();        } else {            return ObjectConverter.convertObjectTo(value, Float.class);        }    }
public double getDouble(String path) {        final Object value = get(path);        if (value instanceof Double) {            return (Double) value;        }        return ObjectConverter.convertObjectTo(value, Double.class);    }
public long getLong(String path) {        //The type returned from Groovy depends on the input, so we need to handle different numerical types.        Object value = get(path);        if (value instanceof Long) {            return (Long) value;        } else if (value instanceof Short) {            return ((Short) value).longValue();        } else if (value instanceof Integer) {            return ((Integer) value).longValue();        } else {            return ObjectConverter.convertObjectTo(value, Long.class);        }    }
public <T> List<T> getList(String path, Class<T> genericType) {        if (genericType == null) {            throw new IllegalArgumentException("Generic type cannot be null");        }        final List<T> original = get(path);        final List<T> newList = new LinkedList<T>();        if (original != null) {            for (T t : original) {                T e;                if (t instanceof Map && !genericType.isAssignableFrom(Map.class)) {                    // TODO Avoid double parsing                    String str = objectToString(t);                    //noinspection unchecked                    e = (T) jsonStringToObject(str, genericType);                } else {                    e = ObjectConverter.convertObjectTo(t, genericType);                }                newList.add(e);            }        }        return Collections.unmodifiableList(newList);    }
public <K, V> Map<K, V> getMap(String path) {        return get(path);    }
public <T> T getObject(String path, Class<T> objectType) {        Object object = getJsonObject(path);        if (object == null) {            return null;        } else if (object instanceof List || object instanceof Map) {            // TODO Avoid double parsing            object = objectToString(object);        } else {            return ObjectConverter.convertObjectTo(object, objectType);        }        if (!(object instanceof String)) {            throw new IllegalStateException("Internal error: Json object was not an instance of String, please report to the REST Assured mailing-list.");        }        return (T) jsonStringToObject((String) object, objectType);    }
public <T> T getObject(String path, TypeRef<T> typeRef) {        AssertParameter.notNull("objectType", "Type ref");        return getObject(path, typeRef.getTypeAsClass());    }
public JsonPath param(String key, Object value) {        JsonPath newP = new JsonPath(this, config);        if (newP.params == null) {            newP.params = new HashMap<String, Object>();        }        newP.params.put(key, value);        return newP;    }
public String prettyPrint() {        final String pretty = prettify();        System.out.println(pretty);        return pretty;    }
public XmlConfig features(Map<String, Boolean> features) {        return new XmlConfig(features, declaredNamespaces, properties, validating, namespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig properties(Map<String, Object> properties) {        return new XmlConfig(features, declaredNamespaces, this.properties, validating, namespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig feature(String uri, boolean enabled) {        Validate.notEmpty(uri, "URI cannot be empty");        Map<String, Boolean> newFeatures = new HashMap<String, Boolean>(features);        newFeatures.put(uri, enabled);        return new XmlConfig(newFeatures, declaredNamespaces, properties, validating, namespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig property(String name, Object value) {        Validate.notEmpty(name, "Name cannot be empty");        Map<String, Object> newProperties = new HashMap<String, Object>(properties);        newProperties.put(name, value);        return new XmlConfig(features, declaredNamespaces, newProperties, validating, namespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig declareNamespaces(Map<String, String> namespacesToDeclare) {        final boolean shouldBeNamespaceAware = namespacesToDeclare == null ? namespaceAware : !namespacesToDeclare.isEmpty();        return new XmlConfig(features, namespacesToDeclare, properties, validating, shouldBeNamespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig declareNamespace(String prefix, String namespaceURI) {        Validate.notEmpty(prefix, "Prefix cannot be empty");        Validate.notEmpty(namespaceURI, "Namespace URI cannot be empty");        Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces);        updatedNamespaces.put(prefix, namespaceURI);        return new XmlConfig(features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration, true);    }
public XmlConfig disableLoadingOfExternalDtd() {        Map<String, Boolean> newFeatures = new HashMap<String, Boolean>(features);        newFeatures.put("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);        return new XmlConfig(newFeatures, declaredNamespaces, properties, validating, namespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig validating(boolean isValidating) {        return new XmlConfig(features, declaredNamespaces, properties, isValidating, namespaceAware, allowDocTypeDeclaration, true);    }
public XmlConfig namespaceAware(boolean shouldBeAwareOfNamespaces) {        return new XmlConfig(features, declaredNamespaces, properties, validating, shouldBeAwareOfNamespaces, allowDocTypeDeclaration, true);    }
public XmlConfig allowDocTypeDeclaration(boolean allowDocTypeDeclaration) {        return new XmlConfig(features, declaredNamespaces, properties, validating, namespaceAware, allowDocTypeDeclaration, true);    }
public DecoderConfig defaultCharsetForContentType(String charset, String contentType) {        notNull(charset, "Charset");        notNull(contentType, "ContentType");        Map<String, String> map = new HashMap<String, String>(contentTypeToDefaultCharset);        map.put(trim(contentType).toLowerCase(), trim(charset));        return new DecoderConfig(charset, useNoWrapForInflateDecoding, true, contentDecoders, map);    }
public DecoderConfig defaultCharsetForContentType(Charset charset, String contentType) {        notNull(charset, "Charset");        return defaultCharsetForContentType(charset.toString(), contentType);    }
public DecoderConfig defaultCharsetForContentType(Charset charset, ContentType contentType) {        notNull(charset, "Charset");        return defaultCharsetForContentType(charset.toString(), contentType);    }
@SuppressWarnings("UnusedDeclaration")    public DecoderConfig defaultContentCharset(String charset) {        return new DecoderConfig(charset, useNoWrapForInflateDecoding, true, contentDecoders, contentTypeToDefaultCharset);    }
@SuppressWarnings("UnusedDeclaration")    public DecoderConfig defaultContentCharset(Charset charset) {        String charsetAsString = notNull(charset, Charset.class).toString();        return new DecoderConfig(charsetAsString, useNoWrapForInflateDecoding, true, contentDecoders, contentTypeToDefaultCharset);    }
public DecoderConfig contentDecoders(ContentDecoder contentDecoder, ContentDecoder... additionalContentDecoders) {        return new DecoderConfig(defaultContentCharset, useNoWrapForInflateDecoding, true, contentTypeToDefaultCharset, merge(contentDecoder, additionalContentDecoders));    }
public <T> T get(String path) {        AssertParameter.notNull(path, "path");        return getFromPath(path, true);    }
public <T> List<T> getList(String path, Class<T> genericType) {        return getAsList(path, genericType);    }
public <K, V> Map<K, V> getMap(String path, Class<K> keyType, Class<V> valueType) {        final Map<K, V> originalMap = get(path);        final Map<K, V> newMap = new HashMap<K, V>();        for (Entry<K, V> entry : originalMap.entrySet()) {            final K key = entry.getKey() == null ? null : convertObjectTo(entry.getKey(), keyType);            final V value = entry.getValue() == null ? null : convertObjectTo(entry.getValue(), valueType);            newMap.put(key, value);        }        return Collections.unmodifiableMap(newMap);    }
public <T> T getObject(String path, Class<T> objectType) {        Object object = getFromPath(path, false);        return getObjectAsType(object, objectType);    }
public int getInt(String path) {        final Object object = get(path);        return convertObjectTo(object, Integer.class);    }
public boolean getBoolean(String path) {        Object object = get(path);        return convertObjectTo(object, Boolean.class);    }
public char getChar(String path) {        Object object = get(path);        return convertObjectTo(object, Character.class);    }
public byte getByte(String path) {        Object object = get(path);        return convertObjectTo(object, Byte.class);    }
public short getShort(String path) {        Object object = get(path);        return convertObjectTo(object, Short.class);    }
public float getFloat(String path) {        Object object = get(path);        return convertObjectTo(object, Float.class);    }
public double getDouble(String path) {        Object object = get(path);        return convertObjectTo(object, Double.class);    }
public long getLong(String path) {        Object object = get(path);        return convertObjectTo(object, Long.class);    }
public String getString(String path) {        Object object = get(path);        return convertObjectTo(object, String.class);    }
public UUID getUUID(String path) {        Object object = get(path);        return convertObjectTo(object, UUID.class);    }
public XmlPath param(String key, Object value) {        XmlPath newP = new XmlPath(this, getXmlPathConfig());        if (newP.params == null) {            newP.params = new HashMap<String, Object>();        }        newP.params.put(key, value);        return newP;    }
public XmlPath peek() {        final GPathResult result = lazyXmlParser.invoke();        final String render = XmlRenderer.render(result);        System.out.println(render);        return this;    }
public XmlPath prettyPeek() {        final GPathResult result = lazyXmlParser.invoke();        final String prettify = XmlPrettifier.prettify(result);        System.out.println(prettify);        return this;    }
public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) {        spec.body(object, mapper);        return this;    }
public RequestSpecBuilder setBody(Object object, ObjectMapperType mapperType) {        spec.body(object, mapperType);        return this;    }
public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) {        spec.cookie(key, value, cookieNameValuePairs);        return this;    }
public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) {        spec.param(parameterName, parameterValues);        return this;    }
public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) {        spec.param(parameterName, parameterValues);        return this;    }
public RequestSpecBuilder addQueryParam(String parameterName, Collection<?> parameterValues) {        spec.queryParam(parameterName, parameterValues);        return this;    }
public RequestSpecBuilder addQueryParam(String parameterName, Object... parameterValues) {        spec.queryParam(parameterName, parameterValues);        return this;    }
public RequestSpecBuilder addFormParam(String parameterName, Collection<?> parameterValues) {        spec.formParam(parameterName, parameterValues);        return this;    }
public RequestSpecBuilder addFormParam(String parameterName, Object... parameterValues) {        spec.formParam(parameterName, parameterValues);        return this;    }
public RequestSpecBuilder addPathParam(String parameterName, Object parameterValue) {        spec.pathParam(parameterName, parameterValue);        return this;    }
public RequestSpecBuilder addPathParams(String firstParameterName, Object firstParameterValue, Object... parameterNameValuePairs) {        spec.pathParams(firstParameterName, firstParameterValue, parameterNameValuePairs);        return this;    }
public RequestSpecBuilder setKeyStore(String pathToJks, String password) {        spec.keyStore(pathToJks, password);        return this;    }
public RequestSpecBuilder setTrustStore(String pathToJks, String password) {        spec.trustStore(pathToJks, password);        return this;    }
public RequestSpecBuilder addHeader(String headerName, String headerValue) {        spec.header(headerName, headerValue);        return this;    }
public RequestSpecBuilder addMultiPart(String controlName, String fileName, InputStream stream) {        spec.multiPart(controlName, fileName, stream);        return this;    }
public RequestSpecBuilder addMultiPart(String controlName, String contentBody) {        spec.multiPart(controlName, contentBody);        return this;    }
public RequestSpecBuilder setSessionId(String sessionIdName, String sessionIdValue) {        spec.sessionId(sessionIdName, sessionIdValue);        return this;    }
public RequestSpecBuilder addRequestSpecification(RequestSpecification specification) {        if (!(specification instanceof RequestSpecificationImpl)) {            throw new IllegalArgumentException("Specification must be of type " + RequestSpecificationImpl.class.getClass() + ".");        }        RequestSpecificationImpl rs = (RequestSpecificationImpl) specification;        SpecificationMerger.merge((RequestSpecificationImpl) spec, rs);        return this;    }
public RequestSpecBuilder log(LogDetail logDetail) {        notNull(logDetail, LogDetail.class);        RestAssuredConfig restAssuredConfig = spec.getConfig();        LogConfig logConfig;        if (restAssuredConfig == null) {            logConfig = new RestAssuredConfig().getLogConfig();        } else {            logConfig = restAssuredConfig.getLogConfig();        }        PrintStream printStream = logConfig.defaultStream();        boolean prettyPrintingEnabled = logConfig.isPrettyPrintingEnabled();        boolean shouldUrlEncodeRequestUri = logConfig.shouldUrlEncodeRequestUri();        spec.filter(new RequestLoggingFilter(logDetail, prettyPrintingEnabled, printStream, shouldUrlEncodeRequestUri));        return this;    }
public RequestSpecBuilder setProxy(String host, int port, String scheme) {        spec.proxy(host, port, scheme);        return this;    }
public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) {        return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true);    }
public static ResponseAwareMatcher<Response> equalToPath(final String path) {        return response -> equalTo(response.path(path));    }
public static ResponseAwareMatcher<Response> endsWithPath(final String path) {        return response -> endsWith(response.<String>path(path));    }
public static ResponseAwareMatcher<Response> startsWithPath(final String path) {        return response -> startsWith(response.<String>path(path));    }
public static ResponseAwareMatcher<Response> containsPath(final String path) {        return response -> containsString(response.<String>path(path));    }
public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) {        return new ResponseLoggingFilter(stream, matcher);    }
public SSLConfig keyStore(File pathToJks, String password) {        Validate.notNull(pathToJks, "Path to JKS on the file system cannot be null");        Validate.notEmpty(password, "Password cannot be empty");        return new SSLConfig(pathToJks, pathToTrustStore, password, trustStorePassword, keyStoreType, trustStoreType, port, keyStore, trustStore, x509HostnameVerifier, sslSocketFactory, true);    }
public SSLConfig keyStore(String password) {        Validate.notEmpty(password, "Password cannot be empty");        return keyStore(System.getProperty("user.home") + File.separatorChar + ".keystore", password);    }
public SSLConfig keystoreType(String keystoreType) {        return new SSLConfig(pathToKeyStore, pathToTrustStore, keyStorePassword, trustStorePassword, keystoreType, trustStoreType, port, keyStore, trustStore, x509HostnameVerifier, sslSocketFactory, true);    }
public SSLConfig relaxedHTTPSValidation(String protocol) {        AssertParameter.notNull(protocol, "Protocol");        SSLContext sslContext;        try {            sslContext = SSLContext.getInstance(protocol);        } catch (NoSuchAlgorithmException e) {            return SafeExceptionRethrower.safeRethrow(e);        }        // Set up a TrustManager that trusts everything        try {            sslContext.init(null, new TrustManager[]{new X509TrustManager() {                public X509Certificate[] getAcceptedIssuers() {                    return null;                }                public void checkClientTrusted(X509Certificate[] certs, String authType) {                }                public void checkServerTrusted(X509Certificate[] certs, String authType) {                }            }}, new SecureRandom());        } catch (KeyManagementException e) {            return SafeExceptionRethrower.safeRethrow(e);        }        SSLSocketFactory sf = new SSLSocketFactory(sslContext, ALLOW_ALL_HOSTNAME_VERIFIER);        return sslSocketFactory(sf);    }
public SSLConfig sslSocketFactory(SSLSocketFactory sslSocketFactory) {        AssertParameter.notNull(sslSocketFactory, SSLSocketFactory.class);        return new SSLConfig(pathToKeyStore, pathToTrustStore, keyStorePassword, trustStorePassword, keyStoreType, trustStoreType, port, keyStore, trustStore, x509HostnameVerifier, sslSocketFactory, true);    }
public Cookie get(String cookieName) {        AssertParameter.notNull(cookieName, "Cookie name");        return cookies.get(cookieName);    }
public String getValue(String cookieName) {        AssertParameter.notNull(cookieName, "Cookie name");        return cookies.getValue(cookieName);    }
public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) {        AssertParameter.notNull(cookie, "Cookie");        final List<Cookie> cookieList = new LinkedList<Cookie>();        cookieList.add(cookie);        Collections.addAll(cookieList, additionalCookies);        return new Cookies(cookieList);    }
public static <T> Provider<T> fromJndi(Class<T> type, String name) {    return new JndiProvider<T>(type, name);  }
private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) {    synchronized (lock) {      for (KeyAndSource keyAndSource : keysAndSources) {        Multiset<Object> set = backingMap.get(keyAndSource.key);        if (set != null) {          set.remove(keyAndSource.source);          if (set.isEmpty()) {            backingMap.remove(keyAndSource.key);          }        }      }    }  }
void index() {    for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) {      bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding);    }  }
@Override  public <T> BindingImpl<T> getBinding(Key<T> key) {    Errors errors = new Errors(checkNotNull(key, "key"));    try {      BindingImpl<T> result = getBindingOrThrow(key, errors, JitLimitation.EXISTING_JIT);      errors.throwConfigurationExceptionIfErrorsExist();      return result;    } catch (ErrorsException e) {      throw new ConfigurationException(errors.merge(e.getErrors()).getMessages());    }  }
<T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType)      throws ErrorsException {    // Check explicit bindings, i.e. bindings created by modules.    BindingImpl<T> binding = state.getExplicitBinding(key);    if (binding != null) {      return binding;    }    // Look for an on-demand binding.    return getJustInTimeBinding(key, errors, jitType);  }
private <T> BindingImpl<T> getJustInTimeBinding(Key<T> key, Errors errors, JitLimitation jitType)      throws ErrorsException {    boolean jitOverride = isProvider(key) || isTypeLiteral(key) || isMembersInjector(key);    synchronized (state.lock()) {      // first try to find a JIT binding that we've already created      for (InjectorImpl injector = this; injector != null; injector = injector.parent) {        @SuppressWarnings("unchecked") // we only store bindings that match their key        BindingImpl<T> binding = (BindingImpl<T>) injector.jitBindings.get(key);        if (binding != null) {          // If we found a JIT binding and we don't allow them,          // fail.  (But allow bindings created through TypeConverters.)          if (options.jitDisabled              && jitType == JitLimitation.NO_JIT              && !jitOverride              && !(binding instanceof ConvertedConstantBindingImpl)) {            throw errors.jitDisabled(key).toException();          } else {            return binding;          }        }      }      // If we previously failed creating this JIT binding and our Errors has      // already recorded an error, then just directly throw that error.      // We need to do this because it's possible we already cleaned up the      // entry in jitBindings (during cleanup), and we may be trying      // to create it again (in the case of a recursive JIT binding).      // We need both of these guards for different reasons      // failedJitBindings.contains: We want to continue processing if we've never      //   failed before, so that our initial error message contains      //   as much useful information as possible about what errors exist.      // errors.hasErrors: If we haven't already failed, then it's OK to      //   continue processing, to make sure the ultimate error message      //   is the correct one.      // See: ImplicitBindingsTest#testRecursiveJitBindingsCleanupCorrectly      // for where this guard compes into play.      if (failedJitBindings.contains(key) && errors.hasErrors()) {        throw errors.toException();      }      return createJustInTimeBindingRecursive(key, errors, options.jitDisabled, jitType);    } // end synchronized(state.lock())  }
private static boolean isMembersInjector(Key<?> key) {    return key.getTypeLiteral().getRawType().equals(MembersInjector.class)        && key.getAnnotationType() == null;  }
private <T> BindingImpl<Provider<T>> createProviderBinding(Key<Provider<T>> key, Errors errors)      throws ErrorsException {    Key<T> providedKey = getProvidedKey(key, errors);    BindingImpl<T> delegate = getBindingOrThrow(providedKey, errors, JitLimitation.NO_JIT);    return new ProviderBindingImpl<T>(this, key, delegate);  }
private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors)      throws ErrorsException {    // Find a constant string binding.    Key<String> stringKey = key.ofType(STRING_TYPE);    BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey);    if (stringBinding == null || !stringBinding.isConstant()) {      return null;    }    // We can't call getProvider().get() because this InstanceBinding may not have been inintialized    // yet (because we may have been called during InternalInjectorCreator.initializeStatically and    // instance binding validation hasn't happened yet.)    @SuppressWarnings("unchecked")    String stringValue = ((InstanceBinding<String>) stringBinding).getInstance();    Object source = stringBinding.getSource();    // Find a matching type converter.    TypeLiteral<T> type = key.getTypeLiteral();    TypeConverterBinding typeConverterBinding =        state.getConverter(stringValue, type, errors, source);    if (typeConverterBinding == null) {      // No converter can handle the given type.      return null;    }    // Try to convert the string. A failed conversion results in an error.    try {      @SuppressWarnings("unchecked") // This cast is safe because we double check below.      T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);      if (converted == null) {        throw errors            .converterReturnedNull(stringValue, source, type, typeConverterBinding)            .toException();      }      if (!type.getRawType().isInstance(converted)) {        throw errors            .conversionTypeError(stringValue, source, type, typeConverterBinding, converted)            .toException();      }      return new ConvertedConstantBindingImpl<T>(          this, key, converted, stringBinding, typeConverterBinding);    } catch (ErrorsException e) {      throw e;    } catch (RuntimeException e) {      throw errors          .conversionError(stringValue, source, type, typeConverterBinding, e)          .toException();    }  }
private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) {    boolean bindingFailed = false;    Set<Dependency<?>> deps = getInternalDependencies(binding);    for (Dependency dep : deps) {      Key<?> depKey = dep.getKey();      InjectionPoint ip = dep.getInjectionPoint();      if (encountered.add(depKey)) { // only check if we haven't looked at this key yet        BindingImpl depBinding = jitBindings.get(depKey);        if (depBinding != null) { // if the binding still exists, validate          boolean failed = cleanup(depBinding, encountered); // if children fail, we fail          if (depBinding instanceof ConstructorBindingImpl) {            ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding;            ip = ctorBinding.getInternalConstructor();            if (!ctorBinding.isInitialized()) {              failed = true;            }          }          if (failed) {            removeFailedJitBinding(depBinding, ip);            bindingFailed = true;          }        } else if (state.getExplicitBinding(depKey) == null) {          // ignore keys if they were explicitly bound, but if neither JIT          // nor explicit, it's also invalid & should let parent know.          bindingFailed = true;        }      }    }    return bindingFailed;  }
private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) {    failedJitBindings.add(binding.getKey());    jitBindings.remove(binding.getKey());    membersInjectorStore.remove(binding.getKey().getTypeLiteral());    provisionListenerStore.remove(binding);    if (ip != null) {      constructors.remove(ip);    }  }
@SuppressWarnings("unchecked")  private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) {    if (binding instanceof ConstructorBindingImpl) {      return ((ConstructorBindingImpl) binding).getInternalDependencies();    } else if (binding instanceof HasDependencies) {      return ((HasDependencies) binding).getDependencies();    } else {      return ImmutableSet.of();    }  }
<T> BindingImpl<T> createUninitializedBinding(      Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding)      throws ErrorsException {    Class<?> rawType = key.getTypeLiteral().getRawType();    ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class);    // Don't try to inject arrays or enums annotated with @ImplementedBy.    if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) {      throw errors.missingImplementationWithHint(key, this).toException();    }    // Handle TypeLiteral<T> by binding the inner type    if (rawType == TypeLiteral.class) {      @SuppressWarnings("unchecked") // we have to fudge the inner type as Object      BindingImpl<T> binding =          (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors);      return binding;    }    // Handle @ImplementedBy    if (implementedBy != null) {      Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors);      return createImplementedByBinding(key, scoping, implementedBy, errors);    }    // Handle @ProvidedBy.    ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class);    if (providedBy != null) {      Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors);      return createProvidedByBinding(key, scoping, providedBy, errors);    }    return ConstructorBindingImpl.create(        this,        key,        null, /* use default constructor */        source,        scoping,        errors,        jitBinding && options.jitDisabled,        options.atInjectRequired);  }
private <T> BindingImpl<TypeLiteral<T>> createTypeLiteralBinding(      Key<TypeLiteral<T>> key, Errors errors) throws ErrorsException {    Type typeLiteralType = key.getTypeLiteral().getType();    if (!(typeLiteralType instanceof ParameterizedType)) {      throw errors.cannotInjectRawTypeLiteral().toException();    }    ParameterizedType parameterizedType = (ParameterizedType) typeLiteralType;    Type innerType = parameterizedType.getActualTypeArguments()[0];    // this is unforunate. We don't support building TypeLiterals for type variable like 'T'. If    // this proves problematic, we can probably fix TypeLiteral to support type variables    if (!(innerType instanceof Class)        && !(innerType instanceof GenericArrayType)        && !(innerType instanceof ParameterizedType)) {      throw errors.cannotInjectTypeLiteralOf(innerType).toException();    }    @SuppressWarnings("unchecked") // by definition, innerType == T, so this is safe    TypeLiteral<T> value = (TypeLiteral<T>) TypeLiteral.get(innerType);    InternalFactory<TypeLiteral<T>> factory =        new ConstantFactory<TypeLiteral<T>>(Initializables.of(value));    return new InstanceBindingImpl<TypeLiteral<T>>(        this,        key,        SourceProvider.UNKNOWN_SOURCE,        factory,        ImmutableSet.<InjectionPoint>of(),        value);  }
<T> BindingImpl<T> createProvidedByBinding(      Key<T> key, Scoping scoping, ProvidedBy providedBy, Errors errors) throws ErrorsException {    Class<?> rawType = key.getTypeLiteral().getRawType();    Class<? extends javax.inject.Provider<?>> providerType = providedBy.value();    // Make sure it's not the same type. TODO: Can we check for deeper loops?    if (providerType == rawType) {      throw errors.recursiveProviderType().toException();    }    // Assume the provider provides an appropriate type. We double check at runtime.    @SuppressWarnings("unchecked")    Key<? extends Provider<T>> providerKey = (Key<? extends Provider<T>>) Key.get(providerType);    ProvidedByInternalFactory<T> internalFactory =        new ProvidedByInternalFactory<T>(rawType, providerType, providerKey);    Object source = rawType;    BindingImpl<T> binding =        LinkedProviderBindingImpl.createWithInitializer(            this,            key,            source,            Scoping.<T>scope(key, this, internalFactory, source, scoping),            scoping,            providerKey,            internalFactory);    internalFactory.setProvisionListenerCallback(provisionListenerStore.get(binding));    return binding;  }
private <T> BindingImpl<T> createImplementedByBinding(      Key<T> key, Scoping scoping, ImplementedBy implementedBy, Errors errors)      throws ErrorsException {    Class<?> rawType = key.getTypeLiteral().getRawType();    Class<?> implementationType = implementedBy.value();    // Make sure it's not the same type. TODO: Can we check for deeper cycles?    if (implementationType == rawType) {      throw errors.recursiveImplementationType().toException();    }    // Make sure implementationType extends type.    if (!rawType.isAssignableFrom(implementationType)) {      throw errors.notASubtype(implementationType, rawType).toException();    }    @SuppressWarnings("unchecked") // After the preceding check, this cast is safe.    Class<? extends T> subclass = (Class<? extends T>) implementationType;    // Look up the target binding.    final Key<? extends T> targetKey = Key.get(subclass);    Object source = rawType;    FactoryProxy<T> factory = new FactoryProxy<>(this, key, targetKey, source);    factory.notify(errors); // causes the factory to initialize itself internally    return new LinkedBindingImpl<T>(        this,        key,        source,        Scoping.<T>scope(key, this, factory, source, scoping),        scoping,        targetKey);  }
private <T> BindingImpl<T> createJustInTimeBindingRecursive(      Key<T> key, Errors errors, boolean jitDisabled, JitLimitation jitType)      throws ErrorsException {    // ask the parent to create the JIT binding    if (parent != null) {      if (jitType == JitLimitation.NEW_OR_EXISTING_JIT          && jitDisabled          && !parent.options.jitDisabled) {        // If the binding would be forbidden here but allowed in a parent, report an error instead        throw errors.jitDisabledInParent(key).toException();      }      try {        return parent.createJustInTimeBindingRecursive(            key,            new Errors(),            jitDisabled,            parent.options.jitDisabled ? JitLimitation.NO_JIT : jitType);      } catch (ErrorsException ignored) {      }    }    // Retrieve the sources before checking for blacklisting to guard against sources becoming null    // due to a full GC happening after calling state.isBlacklisted and    // state.getSourcesForBlacklistedKey.    // TODO(user): Consolidate these two APIs.    Set<Object> sources = state.getSourcesForBlacklistedKey(key);    if (state.isBlacklisted(key)) {      throw errors.childBindingAlreadySet(key, sources).toException();    }    key = MoreTypes.canonicalizeKey(key); // before storing the key long-term, canonicalize it.    BindingImpl<T> binding = createJustInTimeBinding(key, errors, jitDisabled, jitType);    state.parent().blacklist(key, state, binding.getSource());    jitBindings.put(key, binding);    return binding;  }
private <T> BindingImpl<T> createJustInTimeBinding(      Key<T> key, Errors errors, boolean jitDisabled, JitLimitation jitType)      throws ErrorsException {    int numErrorsBefore = errors.size();    // Retrieve the sources before checking for blacklisting to guard against sources becoming null    // due to a full GC happening after calling state.isBlacklisted and    // state.getSourcesForBlacklistedKey.    // TODO(user): Consolidate these two APIs.    Set<Object> sources = state.getSourcesForBlacklistedKey(key);    if (state.isBlacklisted(key)) {      throw errors.childBindingAlreadySet(key, sources).toException();    }    // Handle cases where T is a Provider<?>.    if (isProvider(key)) {      // These casts are safe. We know T extends Provider<X> and that given Key<Provider<X>>,      // createProviderBinding() will return BindingImpl<Provider<X>>.      @SuppressWarnings({"unchecked", "cast"})      BindingImpl<T> binding = (BindingImpl<T>) createProviderBinding((Key) key, errors);      return binding;    }    // Handle cases where T is a MembersInjector<?>    if (isMembersInjector(key)) {      // These casts are safe. T extends MembersInjector<X> and that given Key<MembersInjector<X>>,      // createMembersInjectorBinding() will return BindingImpl<MembersInjector<X>>.      @SuppressWarnings({"unchecked", "cast"})      BindingImpl<T> binding = (BindingImpl<T>) createMembersInjectorBinding((Key) key, errors);      return binding;    }    // Try to convert a constant string binding to the requested type.    BindingImpl<T> convertedBinding = convertConstantStringBinding(key, errors);    if (convertedBinding != null) {      return convertedBinding;    }    if (!isTypeLiteral(key) && jitDisabled && jitType != JitLimitation.NEW_OR_EXISTING_JIT) {      throw errors.jitDisabled(key).toException();    }    // If the key has an annotation...    if (key.getAnnotationType() != null) {      // Look for a binding without annotation attributes or return null.      if (key.hasAttributes() && !options.exactBindingAnnotationsRequired) {        try {          Errors ignored = new Errors();          return getBindingOrThrow(key.withoutAttributes(), ignored, JitLimitation.NO_JIT);        } catch (ErrorsException ignored) {          // throw with a more appropriate message below        }      }      throw errors.missingImplementationWithHint(key, this).toException();    }    Object source = key.getTypeLiteral().getRawType();    BindingImpl<T> binding =        createUninitializedBinding(key, Scoping.UNSCOPED, source, errors, true);    errors.throwIfNewErrors(numErrorsBefore);    initializeJitBinding(binding, errors);    return binding;  }
SingleParameterInjector<?>[] getParametersInjectors(List<Dependency<?>> parameters, Errors errors)      throws ErrorsException {    if (parameters.isEmpty()) {      return null;    }    int numErrorsBefore = errors.size();    SingleParameterInjector<?>[] result = new SingleParameterInjector<?>[parameters.size()];    int i = 0;    for (Dependency<?> parameter : parameters) {      try {        result[i++] = createParameterInjector(parameter, errors.withSource(parameter));      } catch (ErrorsException rethrownBelow) {        // rethrown below      }    }    errors.throwIfNewErrors(numErrorsBefore);    return result;  }
InternalContext enterContext() {    Object[] reference = localContext.get();    if (reference == null) {      reference = new Object[1];      localContext.set(reference);    }    InternalContext ctx = (InternalContext) reference[0];    if (ctx == null) {      reference[0] = ctx = new InternalContext(options, reference);    } else {      ctx.enter();    }    return ctx;  }
static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors)      throws InternalProvisionException {    if (parameterInjectors == null) {      return NO_ARGUMENTS;    }    int size = parameterInjectors.length;    Object[] parameters = new Object[size];    // optimization: use manual for/each to save allocating an iterator here    for (int i = 0; i < size; i++) {      parameters[i] = parameterInjectors[i].inject(context);    }    return parameters;  }
protected String getNodeLabel(GraphvizNode node) {    String cellborder = node.getStyle() == NodeStyle.INVISIBLE ? "1" : "0";    StringBuilder html = new StringBuilder();    html.append("<");    html.append("<table cellspacing=\"0\" cellpadding=\"5\" cellborder=\"");    html.append(cellborder).append("\" border=\"0\">");    html.append("<tr>").append("<td align=\"left\" port=\"header\" ");    html.append("bgcolor=\"" + node.getHeaderBackgroundColor() + "\">");    String subtitle = Joiner.on("<br align=\"left\"/>").join(node.getSubtitles());    if (subtitle.length() != 0) {      html.append("<font color=\"").append(node.getHeaderTextColor());      html.append("\" point-size=\"10\">");      html.append(subtitle).append("<br align=\"left\"/>").append("</font>");    }    html.append("<font color=\"" + node.getHeaderTextColor() + "\">");    html.append(htmlEscape(node.getTitle())).append("<br align=\"left\"/>");    html.append("</font>").append("</td>").append("</tr>");    for (Map.Entry<String, String> field : node.getFields().entrySet()) {      html.append("<tr>");      html.append("<td align=\"left\" port=\"").append(htmlEscape(field.getKey())).append("\">");      html.append(htmlEscape(field.getValue()));      html.append("</td>").append("</tr>");    }    html.append("</table>");    html.append(">");    return html.toString();  }
public static <T> Multibinder<T> newSetBinder(Binder binder, Key<T> key) {    return new Multibinder<T>(newRealSetBinder(binder.skipSources(Multibinder.class), key));  }
public static <T> Multibinder<T> newSetBinder(      Binder binder, Class<T> type, Class<? extends Annotation> annotationType) {    return newSetBinder(binder, Key.get(type, annotationType));  }
public <T> FactoryModuleBuilder implement(Class<T> source, Class<? extends T> target) {    return implement(source, TypeLiteral.get(target));  }
public <F> Module build(Class<F> factoryInterface) {    return build(TypeLiteral.get(factoryInterface));  }
public <F> Module build(TypeLiteral<F> factoryInterface) {    return build(Key.get(factoryInterface));  }
private static void bindInjector(InjectorImpl injector) {    Key<Injector> key = Key.get(Injector.class);    InjectorFactory injectorFactory = new InjectorFactory(injector);    injector.state.putBinding(        key,        new ProviderInstanceBindingImpl<Injector>(            injector,            key,            SourceProvider.UNKNOWN_SOURCE,            injectorFactory,            Scoping.UNSCOPED,            injectorFactory,            ImmutableSet.<InjectionPoint>of()));  }
private static void bindLogger(InjectorImpl injector) {    Key<Logger> key = Key.get(Logger.class);    LoggerFactory loggerFactory = new LoggerFactory();    injector.state.putBinding(        key,        new ProviderInstanceBindingImpl<Logger>(            injector,            key,            SourceProvider.UNKNOWN_SOURCE,            loggerFactory,            Scoping.UNSCOPED,            loggerFactory,            ImmutableSet.<InjectionPoint>of()));  }
private <T> Dependency<T> newDependency(Key<T> key, boolean allowsNull, int parameterIndex) {    return new Dependency<T>(this, key, allowsNull, parameterIndex);  }
public static <T> InjectionPoint forConstructor(Constructor<T> constructor) {    return new InjectionPoint(TypeLiteral.get(constructor.getDeclaringClass()), constructor);  }
public static <T> InjectionPoint forConstructor(      Constructor<T> constructor, TypeLiteral<? extends T> type) {    if (type.getRawType() != constructor.getDeclaringClass()) {      new Errors(type)          .constructorNotDefinedByType(constructor, type)          .throwConfigurationExceptionIfErrorsExist();    }    return new InjectionPoint(type, constructor);  }
public static InjectionPoint forConstructorOf(TypeLiteral<?> type) {    Class<?> rawType = getRawType(type.getType());    Errors errors = new Errors(rawType);    Constructor<?> injectableConstructor = null;    for (Constructor<?> constructor : rawType.getDeclaredConstructors()) {      boolean optional;      Inject guiceInject = constructor.getAnnotation(Inject.class);      if (guiceInject == null) {        javax.inject.Inject javaxInject = constructor.getAnnotation(javax.inject.Inject.class);        if (javaxInject == null) {          continue;        }        optional = false;      } else {        optional = guiceInject.optional();      }      if (optional) {        errors.optionalConstructor(constructor);      }      if (injectableConstructor != null) {        errors.tooManyConstructors(rawType);      }      injectableConstructor = constructor;      checkForMisplacedBindingAnnotations(injectableConstructor, errors);    }    errors.throwConfigurationExceptionIfErrorsExist();    if (injectableConstructor != null) {      return new InjectionPoint(type, injectableConstructor);    }    // If no annotated constructor is found, look for a no-arg constructor instead.    try {      Constructor<?> noArgConstructor = rawType.getDeclaredConstructor();      // Disallow private constructors on non-private classes (unless they have @Inject)      if (Modifier.isPrivate(noArgConstructor.getModifiers())          && !Modifier.isPrivate(rawType.getModifiers())) {        errors.missingConstructor(rawType);        throw new ConfigurationException(errors.getMessages());      }      checkForMisplacedBindingAnnotations(noArgConstructor, errors);      return new InjectionPoint(type, noArgConstructor);    } catch (NoSuchMethodException e) {      errors.missingConstructor(rawType);      throw new ConfigurationException(errors.getMessages());    }  }
public static <T> InjectionPoint forMethod(Method method, TypeLiteral<T> type) {    return new InjectionPoint(type, method, false);  }
public static Set<InjectionPoint> forStaticMethodsAndFields(TypeLiteral<?> type) {    Errors errors = new Errors();    Set<InjectionPoint> result;    if (type.getRawType().isInterface()) {      errors.staticInjectionOnInterface(type.getRawType());      result = null;    } else {      result = getInjectionPoints(type, true, errors);    }    if (errors.hasErrors()) {      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);    }    return result;  }
public static Set<InjectionPoint> forInstanceMethodsAndFields(TypeLiteral<?> type) {    Errors errors = new Errors();    Set<InjectionPoint> result = getInjectionPoints(type, false, errors);    if (errors.hasErrors()) {      throw new ConfigurationException(errors.getMessages()).withPartialValue(result);    }    return result;  }
private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) {    Annotation misplacedBindingAnnotation =        Annotations.findBindingAnnotation(            errors, member, ((AnnotatedElement) member).getAnnotations());    if (misplacedBindingAnnotation == null) {      return false;    }    // don't warn about misplaced binding annotations on methods when there's a field with the same    // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242.    if (member instanceof Method) {      try {        if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) {          return false;        }      } catch (NoSuchFieldException ignore) {      }    }    errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation);    return true;  }
private static Set<InjectionPoint> getInjectionPoints(      final TypeLiteral<?> type, boolean statics, Errors errors) {    InjectableMembers injectableMembers = new InjectableMembers();    OverrideIndex overrideIndex = null;    List<TypeLiteral<?>> hierarchy = hierarchyFor(type);    int topIndex = hierarchy.size() - 1;    for (int i = topIndex; i >= 0; i--) {      if (overrideIndex != null && i < topIndex) {        // Knowing the position within the hierarchy helps us make optimizations.        if (i == 0) {          overrideIndex.position = Position.BOTTOM;        } else {          overrideIndex.position = Position.MIDDLE;        }      }      TypeLiteral<?> current = hierarchy.get(i);      for (Field field : getDeclaredFields(current)) {        if (Modifier.isStatic(field.getModifiers()) == statics) {          Annotation atInject = getAtInject(field);          if (atInject != null) {            InjectableField injectableField = new InjectableField(current, field, atInject);            if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {              errors.cannotInjectFinalField(field);            }            injectableMembers.add(injectableField);          }        }      }      for (Method method : getDeclaredMethods(current)) {        if (isEligibleForInjection(method, statics)) {          Annotation atInject = getAtInject(method);          if (atInject != null) {            InjectableMethod injectableMethod = new InjectableMethod(current, method, atInject);            if (checkForMisplacedBindingAnnotations(method, errors)                || !isValidMethod(injectableMethod, errors)) {              if (overrideIndex != null) {                boolean removed =                    overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);                if (removed) {                  logger.log(                      Level.WARNING,                      "Method: {0} is not a valid injectable method ("                          + "because it either has misplaced binding annotations "                          + "or specifies type parameters) but is overriding a method that is "                          + "valid. Because it is not valid, the method will not be injected. "                          + "To fix this, make the method a valid injectable method.",                      method);                }              }              continue;            }            if (statics) {              injectableMembers.add(injectableMethod);            } else {              if (overrideIndex == null) {                /*                 * Creating the override index lazily means that the first type in the hierarchy                 * with injectable methods (not necessarily the top most type) will be treated as                 * the TOP position and will enjoy the same optimizations (no checks for overridden                 * methods, etc.).                 */                overrideIndex = new OverrideIndex(injectableMembers);              } else {                // Forcibly remove the overridden method, otherwise we'll inject                // it twice.                overrideIndex.removeIfOverriddenBy(method, true, injectableMethod);              }              overrideIndex.add(injectableMethod);            }          } else {            if (overrideIndex != null) {              boolean removed = overrideIndex.removeIfOverriddenBy(method, false, null);              if (removed) {                logger.log(                    Level.WARNING,                    "Method: {0} is not annotated with @Inject but "                        + "is overriding a method that is annotated with @javax.inject.Inject."                        + "Because it is not annotated with @Inject, the method will not be "                        + "injected. To fix this, annotate the method with @Inject.",                    method);              }            }          }        }      }    }    if (injectableMembers.isEmpty()) {      return Collections.emptySet();    }    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();    for (InjectableMember im = injectableMembers.head; im != null; im = im.next) {      try {        builder.add(im.toInjectionPoint());      } catch (ConfigurationException ignorable) {        if (!im.optional) {          errors.merge(ignorable.getErrorMessages());        }      }    }    return builder.build();  }
private static boolean isEligibleForInjection(Method method, boolean statics) {    return Modifier.isStatic(method.getModifiers()) == statics        && !method.isBridge()        && !method.isSynthetic();  }
private static boolean overrides(Method a, Method b) {    // See JLS section 8.4.8.1    int modifiers = b.getModifiers();    if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {      return true;    }    if (Modifier.isPrivate(modifiers)) {      return false;    }    // b must be package-private    return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage());  }
public void initializeDelegate(MembersInjector<T> delegate) {    checkState(this.delegate == null, "delegate already initialized");    this.delegate = checkNotNull(delegate, "delegate");  }
public MembersInjector<T> getMembersInjector() {    return new MembersInjector<T>() {      @Override      public void injectMembers(T instance) {        MembersInjector<T> local = delegate;        if (local == null) {          throw new IllegalStateException(              "This MembersInjector cannot be used until the Injector has been created.");        }        local.injectMembers(instance);      }      @Override      public String toString() {        return "MembersInjector<" + type + ">";      }    };  }
public static <T, P extends CheckedProvider<? super T>> P of(      TypeLiteral<P> providerType, @Nullable T instance) {    return generateProvider(        providerType, Optional.fromNullable(instance), new ReturningHandler<T>(instance));  }
public static <T, P extends CheckedProvider<? super T>> P of(      Class<P> providerType, @Nullable T instance) {    return of(TypeLiteral.get(providerType), instance);  }
public static <T, P extends CheckedProvider<? super T>> P throwing(      TypeLiteral<P> providerType, Class<? extends Throwable> throwable) {    // TODO(eatnumber1): Understand why TypeLiteral#getRawType returns a Class<? super T> rather    // than a Class<T> and remove this unsafe cast.    Class<P> providerRaw = (Class) providerType.getRawType();    checkThrowable(providerRaw, throwable);    return generateProvider(        providerType, Optional.<T>absent(), ThrowingHandler.forClass(throwable));  }
public static <T, P extends CheckedProvider<? super T>> P throwing(      Class<P> providerType, Class<? extends Throwable> throwable) {    return throwing(TypeLiteral.get(providerType), throwable);  }
static Type getSuperclassTypeParameter(Class<?> subclass) {    Type superclass = subclass.getGenericSuperclass();    if (superclass instanceof Class) {      throw new RuntimeException("Missing type parameter.");    }    ParameterizedType parameterized = (ParameterizedType) superclass;    return canonicalize(parameterized.getActualTypeArguments()[0]);  }
@SuppressWarnings("unchecked")  final TypeLiteral<Provider<T>> providerType() {    // This cast is safe and wouldn't generate a warning if Type had a type    // parameter.    return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType()));  }
public static <T> TypeLiteral<T> get(Class<T> type) {    return new TypeLiteral<T>(type);  }
private List<TypeLiteral<?>> resolveAll(Type[] types) {    TypeLiteral<?>[] result = new TypeLiteral<?>[types.length];    for (int t = 0; t < types.length; t++) {      result[t] = resolve(types[t]);    }    return ImmutableList.copyOf(result);  }
public TypeLiteral<?> getSupertype(Class<?> supertype) {    checkArgument(        supertype.isAssignableFrom(rawType), "%s is not a supertype of %s", supertype, this.type);    return resolve(MoreTypes.getGenericSupertype(type, rawType, supertype));  }
public TypeLiteral<?> getFieldType(Field field) {    checkArgument(        field.getDeclaringClass().isAssignableFrom(rawType),        "%s is not defined by a supertype of %s",        field,        type);    return resolve(field.getGenericType());  }
public List<TypeLiteral<?>> getParameterTypes(Member methodOrConstructor) {    Type[] genericParameterTypes;    if (methodOrConstructor instanceof Method) {      Method method = (Method) methodOrConstructor;      checkArgument(          method.getDeclaringClass().isAssignableFrom(rawType),          "%s is not defined by a supertype of %s",          method,          type);      genericParameterTypes = method.getGenericParameterTypes();    } else if (methodOrConstructor instanceof Constructor) {      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;      checkArgument(          constructor.getDeclaringClass().isAssignableFrom(rawType),          "%s does not construct a supertype of %s",          constructor,          type);      genericParameterTypes = constructor.getGenericParameterTypes();    } else {      throw new IllegalArgumentException("Not a method or a constructor: " + methodOrConstructor);    }    return resolveAll(genericParameterTypes);  }
public List<TypeLiteral<?>> getExceptionTypes(Member methodOrConstructor) {    Type[] genericExceptionTypes;    if (methodOrConstructor instanceof Method) {      Method method = (Method) methodOrConstructor;      checkArgument(          method.getDeclaringClass().isAssignableFrom(rawType),          "%s is not defined by a supertype of %s",          method,          type);      genericExceptionTypes = method.getGenericExceptionTypes();    } else if (methodOrConstructor instanceof Constructor) {      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;      checkArgument(          constructor.getDeclaringClass().isAssignableFrom(rawType),          "%s does not construct a supertype of %s",          constructor,          type);      genericExceptionTypes = constructor.getGenericExceptionTypes();    } else {      throw new IllegalArgumentException("Not a method or a constructor: " + methodOrConstructor);    }    return resolveAll(genericExceptionTypes);  }
public TypeLiteral<?> getReturnType(Method method) {    checkArgument(        method.getDeclaringClass().isAssignableFrom(rawType),        "%s is not defined by a supertype of %s",        method,        type);    return resolve(method.getGenericReturnType());  }
public static <T> Key<T> canonicalizeKey(Key<T> key) {    // If we know this isn't a subclass, return as-is.    // Otherwise, recreate the key to avoid the subclass    if (key.getClass() == Key.class) {      return key;    } else if (key.getAnnotation() != null) {      return Key.get(key.getTypeLiteral(), key.getAnnotation());    } else if (key.getAnnotationType() != null) {      return Key.get(key.getTypeLiteral(), key.getAnnotationType());    } else {      return Key.get(key.getTypeLiteral());    }  }
public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) {    Type type = typeLiteral.getType();    if (!isFullySpecified(type)) {      Errors errors = new Errors().keyNotFullySpecified(typeLiteral);      throw new ConfigurationException(errors.getMessages());    }    if (typeLiteral.getRawType() == javax.inject.Provider.class) {      ParameterizedType parameterizedType = (ParameterizedType) type;      // the following casts are generally unsafe, but com.google.inject.Provider extends      // javax.inject.Provider and is covariant      @SuppressWarnings("unchecked")      TypeLiteral<T> guiceProviderType =          (TypeLiteral<T>)              TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0]));      return guiceProviderType;    }    @SuppressWarnings("unchecked")    TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral);    if (wrappedPrimitives != null) {      return wrappedPrimitives;    }    // If we know this isn't a subclass, return as-is.    if (typeLiteral.getClass() == TypeLiteral.class) {      return typeLiteral;    }    // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their    // surrounding classes.    @SuppressWarnings("unchecked")    TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType());    return recreated;  }
private static boolean isFullySpecified(Type type) {    if (type instanceof Class) {      return true;    } else if (type instanceof CompositeType) {      return ((CompositeType) type).isFullySpecified();    } else if (type instanceof TypeVariable) {      return false;    } else {      return ((CompositeType) canonicalize(type)).isFullySpecified();    }  }
public static Type canonicalize(Type type) {    if (type instanceof Class) {      Class<?> c = (Class<?>) type;      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;    } else if (type instanceof CompositeType) {      return type;    } else if (type instanceof ParameterizedType) {      ParameterizedType p = (ParameterizedType) type;      return new ParameterizedTypeImpl(          p.getOwnerType(), p.getRawType(), p.getActualTypeArguments());    } else if (type instanceof GenericArrayType) {      GenericArrayType g = (GenericArrayType) type;      return new GenericArrayTypeImpl(g.getGenericComponentType());    } else if (type instanceof WildcardType) {      WildcardType w = (WildcardType) type;      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());    } else {      // type is either serializable as-is or unsupported      return type;    }  }
private static Class<?> declaringClassOf(TypeVariable typeVariable) {    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;  }
private ServletDefinition[] collectServletDefinitions(Injector injector) {    List<ServletDefinition> servletDefinitions = Lists.newArrayList();    for (Binding<ServletDefinition> entry : injector.findBindingsByType(SERVLET_DEFS)) {      servletDefinitions.add(entry.getProvider().get());    }    // Copy to a fixed size array for speed.    return servletDefinitions.toArray(new ServletDefinition[servletDefinitions.size()]);  }
static void prepareBuiltInConverters(InjectorImpl injector) {    // Configure type converters.    convertToPrimitiveType(injector, int.class, Integer.class);    convertToPrimitiveType(injector, long.class, Long.class);    convertToPrimitiveType(injector, boolean.class, Boolean.class);    convertToPrimitiveType(injector, byte.class, Byte.class);    convertToPrimitiveType(injector, short.class, Short.class);    convertToPrimitiveType(injector, float.class, Float.class);    convertToPrimitiveType(injector, double.class, Double.class);    convertToClass(        injector,        Character.class,        new TypeConverter() {          @Override          public Object convert(String value, TypeLiteral<?> toType) {            value = value.trim();            if (value.length() != 1) {              throw new RuntimeException("Length != 1.");            }            return value.charAt(0);          }          @Override          public String toString() {            return "TypeConverter<Character>";          }        });    convertToClasses(        injector,        Matchers.subclassesOf(Enum.class),        new TypeConverter() {          @Override          @SuppressWarnings("unchecked")          public Object convert(String value, TypeLiteral<?> toType) {            return Enum.valueOf((Class) toType.getRawType(), value);          }          @Override          public String toString() {            return "TypeConverter<E extends Enum<E>>";          }        });    internalConvertToTypes(        injector,        new AbstractMatcher<TypeLiteral<?>>() {          @Override          public boolean matches(TypeLiteral<?> typeLiteral) {            return typeLiteral.getRawType() == Class.class;          }          @Override          public String toString() {            return "Class<?>";          }        },        new TypeConverter() {          @Override          @SuppressWarnings("unchecked")          public Object convert(String value, TypeLiteral<?> toType) {            try {              return Class.forName(value);            } catch (ClassNotFoundException e) {              throw new RuntimeException(e.getMessage());            }          }          @Override          public String toString() {            return "TypeConverter<Class<?>>";          }        });  }
private static ClassLoader canonicalize(ClassLoader classLoader) {    return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent();  }
public static net.sf.cglib.reflect.FastClass newFastClassForMember(Member member) {    return newFastClassForMember(member.getDeclaringClass(), member);  }
public static net.sf.cglib.reflect.FastClass newFastClassForMember(Class<?> type, Member member) {    if (!new net.sf.cglib.core.VisibilityPredicate(type, false).evaluate(member)) {      // the member cannot be indexed by fast class.  Bail out.      return null;    }    boolean publiclyCallable = isPubliclyCallable(member);    if (!publiclyCallable && !hasSameVersionOfCglib(type.getClassLoader())) {      // The type is in a classloader with a different version of cglib and is not publicly visible      // (so we can't use the bridge classloader to work around).  Bail out.      return null;    }    net.sf.cglib.reflect.FastClass.Generator generator =        new net.sf.cglib.reflect.FastClass.Generator();    if (publiclyCallable) {      // Use the bridge classloader if we can      generator.setClassLoader(getClassLoader(type));    }    generator.setType(type);    generator.setNamingPolicy(FASTCLASS_NAMING_POLICY);    if (logger.isLoggable(Level.FINE)) {      logger.fine("Loading " + type + " FastClass with " + generator.getClassLoader());    }    return generator.create();  }
private static boolean hasSameVersionOfCglib(ClassLoader classLoader) {    Class<?> fc = net.sf.cglib.reflect.FastClass.class;    try {      return classLoader.loadClass(fc.getName()) == fc;    } catch (ClassNotFoundException e) {      return false;    }  }
private static boolean isPubliclyCallable(Member member) {    if (!Modifier.isPublic(member.getModifiers())) {      return false;    }    Class<?>[] parameterTypes;    if (member instanceof Constructor) {      parameterTypes = ((Constructor) member).getParameterTypes();    } else {      Method method = (Method) member;      if (!Modifier.isPublic(method.getReturnType().getModifiers())) {        return false;      }      parameterTypes = method.getParameterTypes();    }    for (Class<?> type : parameterTypes) {      if (!Modifier.isPublic(type.getModifiers())) {        return false;      }    }    return true;  }
static <T> ProviderMethod<T> create(      Key<T> key,      Method method,      Object instance,      ImmutableSet<Dependency<?>> dependencies,      Class<? extends Annotation> scopeAnnotation,      boolean skipFastClassGeneration,      Annotation annotation) {    int modifiers = method.getModifiers();    /*if[AOP]*/    if (!skipFastClassGeneration) {      try {        net.sf.cglib.reflect.FastClass fc = BytecodeGen.newFastClassForMember(method);        if (fc != null) {          return new FastClassProviderMethod<T>(              key, fc, method, instance, dependencies, scopeAnnotation, annotation);        }      } catch (net.sf.cglib.core.CodeGenerationException e) {        /* fall-through */      }    }    /*end[AOP]*/    if (!Modifier.isPublic(modifiers)        || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {      method.setAccessible(true);    }    return new ReflectionProviderMethod<T>(        key, method, instance, dependencies, scopeAnnotation, annotation);  }
public Object getValue(Injector injector) {    if (null == provider) {      synchronized (this) {        if (null == provider) {          provider =              isProvider                  ? injector.getProvider(getBindingForType(getProvidedType(type)))                  : injector.getProvider(getPrimaryBindingKey());        }      }    }    return isProvider ? provider : provider.get();  }
public Key<?> fixAnnotations(Key<?> key) {    return key.getAnnotation() == null        ? key        : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType());  }
private Annotation getBindingAnnotation(Annotation[] annotations) {    Annotation bindingAnnotation = null;    for (Annotation annotation : annotations) {      if (Annotations.isBindingAnnotation(annotation.annotationType())) {        checkArgument(            bindingAnnotation == null,            "Parameter has multiple binding annotations: %s and %s",            bindingAnnotation,            annotation);        bindingAnnotation = annotation;      }    }    return bindingAnnotation;  }
<T> Initializable<T> requestInjection(      InjectorImpl injector,      T instance,      Binding<T> binding,      Object source,      Set<InjectionPoint> injectionPoints) {    checkNotNull(source);    Preconditions.checkState(        !validationStarted, "Member injection could not be requested after validation is started");    ProvisionListenerStackCallback<T> provisionCallback =        binding == null ? null : injector.provisionListenerStore.get(binding);    // short circuit if the object has no injections or listeners.    if (instance == null        || (injectionPoints.isEmpty()            && !injector.membersInjectorStore.hasTypeListeners()            && provisionCallback == null)) {      return Initializables.of(instance);    }    if (initializablesCache.containsKey(instance)) {      @SuppressWarnings("unchecked") // Map from T to InjectableReference<T>      Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance);      return cached;    }    InjectableReference<T> injectableReference =        new InjectableReference<T>(            injector,            instance,            binding == null ? null : binding.getKey(),            provisionCallback,            source,            cycleDetectingLockFactory.create(instance.getClass()));    initializablesCache.put(instance, injectableReference);    pendingInjections.add(injectableReference);    return injectableReference;  }
void validateOustandingInjections(Errors errors) {    validationStarted = true;    initializablesCache.clear();    for (InjectableReference<?> reference : pendingInjections) {      try {        reference.validate(errors);      } catch (ErrorsException e) {        errors.merge(e.getErrors());      }    }  }
void injectAll(final Errors errors) {    Preconditions.checkState(validationStarted, "Validation should be done before injection");    for (InjectableReference<?> reference : pendingInjections) {      try {        reference.get();      } catch (InternalProvisionException ipe) {        errors.merge(ipe);      }    }    pendingInjections.clear();  }
public T newInstance(Object[] args) throws Throwable {    constructor.setAccessible(true);    try {      return constructor.newInstance(args);    } catch (InvocationTargetException e) {      throw e.getCause();    }  }
private FilterDefinition[] collectFilterDefinitions(Injector injector) {    List<FilterDefinition> filterDefinitions = Lists.newArrayList();    for (Binding<FilterDefinition> entry : injector.findBindingsByType(FILTER_DEFS)) {      filterDefinitions.add(entry.getProvider().get());    }    // Copy to a fixed-size array for speed of iteration.    return filterDefinitions.toArray(new FilterDefinition[filterDefinitions.size()]);  }
@SuppressWarnings({"JavaDoc", "deprecation"})  private ServletRequest withDispatcher(      ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) {    // don't wrap the request if there are no servlets mapped. This prevents us from inserting our    // wrapper unless it's actually going to be used. This is necessary for compatibility for apps    // that downcast their HttpServletRequests to a concrete implementation.    if (!servletPipeline.hasServletsMapped()) {      return servletRequest;    }    HttpServletRequest request = (HttpServletRequest) servletRequest;    //noinspection OverlyComplexAnonymousInnerClass    return new HttpServletRequestWrapper(request) {      @Override      public RequestDispatcher getRequestDispatcher(String path) {        final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path);        return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path);      }    };  }
private Map<NodeId, NodeId> resolveAliases(Iterable<Alias> aliases) {    Map<NodeId, NodeId> resolved = Maps.newHashMap();    SetMultimap<NodeId, NodeId> inverse = HashMultimap.create();    for (Alias alias : aliases) {      NodeId from = alias.getFromId();      NodeId to = alias.getToId();      if (resolved.containsKey(to)) {        to = resolved.get(to);      }      resolved.put(from, to);      inverse.put(to, from);      Set<NodeId> prev = inverse.get(from);      if (prev != null) {        for (NodeId id : prev) {          resolved.remove(id);          inverse.remove(from, id);          resolved.put(id, to);          inverse.put(to, id);        }      }    }    return resolved;  }
public boolean isEagerSingleton(Stage stage) {    if (this == EAGER_SINGLETON) {      return true;    }    if (stage == Stage.PRODUCTION) {      return this == SINGLETON_ANNOTATION || this == SINGLETON_INSTANCE;    }    return false;  }
static <T> InternalFactory<? extends T> scope(      Key<T> key,      InjectorImpl injector,      InternalFactory<? extends T> creator,      Object source,      Scoping scoping) {    if (scoping.isNoScope()) {      return creator;    }    Scope scope = scoping.getScopeInstance();    // NOTE: SingletonScope relies on the fact that we are passing a    // ProviderToInternalFactoryAdapter here.  If you change the type make sure to update    // SingletonScope as well.    Provider<T> scoped =        scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));    return new InternalFactoryToProviderAdapter<T>(scoped, source);  }
static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) {    Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation();    if (scopeAnnotation == null) {      return scoping;    }    ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation);    if (scope != null) {      return forInstance(scope.getScope());    }    errors.scopeNotFound(scopeAnnotation);    return UNSCOPED;  }
static String normalizePath(String path) {    StringBuilder sb = new StringBuilder(path.length());    int queryStart = path.indexOf('?');    String query = null;    if (queryStart != -1) {      query = path.substring(queryStart);      path = path.substring(0, queryStart);    }    // Normalize the path.  we need to decode path segments, normalize and rejoin in order to    // 1. decode and normalize safe percent escaped characters.  e.g. %70 -> 'p'    // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/'    // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F'    List<String> segments = new ArrayList<>();    for (String segment : SLASH_SPLITTER.split(path)) {      // This decodes all non-special characters from the path segment.  so if someone passes      // /%2E/foo we will normalize it to /./foo and then /foo      String normalized =          UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false));      if (".".equals(normalized)) {        // skip      } else if ("..".equals(normalized)) {        if (segments.size() > 1) {          segments.remove(segments.size() - 1);        }      } else {        segments.add(normalized);      }    }    SLASH_JOINER.appendTo(sb, segments);    if (query != null) {      sb.append(query);    }    return sb.toString();  }
private static String lenientDecode(String string, Charset encoding, boolean decodePlus) {    checkNotNull(string);    checkNotNull(encoding);    if (decodePlus) {      string = string.replace('+', ' ');    }    int firstPercentPos = string.indexOf('%');    if (firstPercentPos < 0) {      return string;    }    ByteAccumulator accumulator = new ByteAccumulator(string.length(), encoding);    StringBuilder builder = new StringBuilder(string.length());    if (firstPercentPos > 0) {      builder.append(string, 0, firstPercentPos);    }    for (int srcPos = firstPercentPos; srcPos < string.length(); srcPos++) {      char c = string.charAt(srcPos);      if (c < 0x80) { // ASCII        boolean processed = false;        if (c == '%' && string.length() >= srcPos + 3) {          String hex = string.substring(srcPos + 1, srcPos + 3);          try {            int encoded = Integer.parseInt(hex, 16);            if (encoded >= 0) {              accumulator.append((byte) encoded);              srcPos += 2;              processed = true;            }          } catch (NumberFormatException ignore) {            // Expected case (badly formatted % group)          }        }        if (!processed) {          if (accumulator.isEmpty()) {            // We're not accumulating elements of a multibyte encoded            // char, so just toss it right into the result string.            builder.append(c);          } else {            accumulator.append((byte) c);          }        }      } else { // Non-ASCII        // A non-ASCII char marks the end of a multi-char encoding sequence,        // if one is in progress.        accumulator.dumpTo(builder);        builder.append(c);      }    }    accumulator.dumpTo(builder);    return builder.toString();  }
private boolean isOkayDuplicate(BindingImpl<?> original, BindingImpl<?> binding, State state) {    if (original instanceof ExposedBindingImpl) {      ExposedBindingImpl exposed = (ExposedBindingImpl) original;      InjectorImpl exposedFrom = (InjectorImpl) exposed.getPrivateElements().getInjector();      return (exposedFrom == binding.getInjector());    } else {      original = (BindingImpl<?>) state.getExplicitBindingsThisLevel().get(binding.getKey());      // If no original at this level, the original was on a parent, and we don't      // allow deduplication between parents & children.      if (original == null) {        return false;      } else {        return original.equals(binding);      }    }  }
public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) {    Preconditions.checkState(        isAllDefaultMethods(annotationType), "%s is not all default methods", annotationType);    return (T) cache.getUnchecked(annotationType);  }
private static boolean annotationEquals(      Class<? extends Annotation> type, Map<String, Object> members, Object other)      throws Exception {    if (!type.isInstance(other)) {      return false;    }    for (Method method : type.getDeclaredMethods()) {      String name = method.getName();      if (!Arrays.deepEquals(          new Object[] {method.invoke(other)}, new Object[] {members.get(name)})) {        return false;      }    }    return true;  }
private static int annotationHashCode(      Class<? extends Annotation> type, Map<String, Object> members) throws Exception {    int result = 0;    for (Method method : type.getDeclaredMethods()) {      String name = method.getName();      Object value = members.get(name);      result += (127 * name.hashCode()) ^ (Arrays.deepHashCode(new Object[] {value}) - 31);    }    return result;  }
private static String annotationToString(      Class<? extends Annotation> type, Map<String, Object> members) throws Exception {    StringBuilder sb = new StringBuilder().append("@").append(type.getName()).append("(");    JOINER.appendTo(        sb,        Maps.transformValues(            members,            arg -> {              String s = Arrays.deepToString(new Object[] {arg});              return s.substring(1, s.length() - 1); // cut off brackets            }));    return sb.append(")").toString();  }
public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) {    Retention retention = annotationType.getAnnotation(Retention.class);    return retention != null && retention.value() == RetentionPolicy.RUNTIME;  }
public static Class<? extends Annotation> findScopeAnnotation(      Errors errors, Class<?> implementation) {    return findScopeAnnotation(errors, implementation.getAnnotations());  }
public static Class<? extends Annotation> findScopeAnnotation(      Errors errors, Annotation[] annotations) {    Class<? extends Annotation> found = null;    for (Annotation annotation : annotations) {      Class<? extends Annotation> annotationType = annotation.annotationType();      if (isScopeAnnotation(annotationType)) {        if (found != null) {          errors.duplicateScopeAnnotations(found, annotationType);        } else {          found = annotationType;        }      }    }    return found;  }
public static void checkForMisplacedScopeAnnotations(      Class<?> type, Object source, Errors errors) {    if (Classes.isConcrete(type)) {      return;    }    Class<? extends Annotation> scopeAnnotation = findScopeAnnotation(errors, type);    if (scopeAnnotation != null        // We let Dagger Components through to aid migrations.        && !containsComponentAnnotation(type.getAnnotations())) {      errors.withSource(type).scopeAnnotationOnAbstractType(scopeAnnotation, type, source);    }  }
public static Key<?> getKey(      TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors)      throws ErrorsException {    int numErrorsBefore = errors.size();    Annotation found = findBindingAnnotation(errors, member, annotations);    errors.throwIfNewErrors(numErrorsBefore);    return found == null ? Key.get(type) : Key.get(type, found);  }
public static Annotation findBindingAnnotation(      Errors errors, Member member, Annotation[] annotations) {    Annotation found = null;    for (Annotation annotation : annotations) {      Class<? extends Annotation> annotationType = annotation.annotationType();      if (isBindingAnnotation(annotationType)) {        if (found != null) {          errors.duplicateBindingAnnotations(member, found.annotationType(), annotationType);        } else {          found = annotation;        }      }    }    return found;  }
public static Annotation canonicalizeIfNamed(Annotation annotation) {    if (annotation instanceof javax.inject.Named) {      return Names.named(((javax.inject.Named) annotation).value());    } else {      return annotation;    }  }
public static Class<? extends Annotation> canonicalizeIfNamed(      Class<? extends Annotation> annotationType) {    if (annotationType == javax.inject.Named.class) {      return Named.class;    } else {      return annotationType;    }  }
public static String nameOf(Key<?> key) {    Annotation annotation = key.getAnnotation();    Class<? extends Annotation> annotationType = key.getAnnotationType();    if (annotation != null && !isMarker(annotationType)) {      return key.getAnnotation().toString();    } else if (key.getAnnotationType() != null) {      return "@" + key.getAnnotationType().getName();    } else {      return "";    }  }
public void initializeDelegate(Provider<T> delegate) {    checkState(this.delegate == null, "delegate already initialized");    this.delegate = checkNotNull(delegate, "delegate");  }
public Provider<T> getProvider() {    return new ProviderWithDependencies<T>() {      @Override      public T get() {        Provider<T> local = delegate;        if (local == null) {          throw new IllegalStateException(              "This Provider cannot be used until the Injector has been created.");        }        return local.get();      }      @Override      public Set<Dependency<?>> getDependencies() {        // We depend on Provider<T>, not T directly.  This is an important distinction        // for dependency analysis tools that short-circuit on providers.        Key<?> providerKey = getKey().ofType(Types.providerOf(getKey().getTypeLiteral().getType()));        return ImmutableSet.<Dependency<?>>of(Dependency.get(providerKey));      }      @Override      public String toString() {        return "Provider<" + getKey().getTypeLiteral() + ">";      }    };  }
public static Class<? extends Member> memberType(Member member) {    checkNotNull(member, "member");    if (member instanceof Field) {      return Field.class;    } else if (member instanceof Method) {      return Method.class;    } else if (member instanceof Constructor) {      return Constructor.class;    } else {      throw new IllegalArgumentException(          "Unsupported implementation class for Member, " + member.getClass());    }  }
public static <K, V> MapBinder<K, V> newMapBinder(      Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType) {    return new MapBinder<K, V>(        newMapRealBinder(binder.skipSources(MapBinder.class), keyType, valueType));  }
public static <K, V> MapBinder<K, V> newMapBinder(      Binder binder, Class<K> keyType, Class<V> valueType) {    return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType));  }
public static <K, V> MapBinder<K, V> newMapBinder(      Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, Annotation annotation) {    return new MapBinder<K, V>(        newRealMapBinder(binder.skipSources(MapBinder.class), keyType, valueType, annotation));  }
private void addDirectTypeBinding(Binder binder) {    binder        .bind(bindingSelection.getDirectKey())        .toProvider(new RealDirectTypeProvider<T>(bindingSelection));  }
public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors)      throws ErrorsException {    return cache.get(constructorInjector, errors);  }
private static boolean hasScope(Class<? extends Interceptor> interceptorClass) {    for (Annotation annotation : interceptorClass.getAnnotations()) {      if (Annotations.isScopeAnnotation(annotation.annotationType())) {        return true;      }    }    return false;  }
public static <K, V> RealMapBinder<K, V> newRealMapBinder(      Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, Annotation annotation) {    binder = binder.skipSources(RealMapBinder.class);    return newRealMapBinder(        binder,        keyType,        valueType,        Key.get(mapOf(keyType, valueType), annotation),        RealMultibinder.newRealSetBinder(            binder, Key.get(entryOfProviderOf(keyType, valueType), annotation)));  }
@SuppressWarnings("unchecked")  static <K, V> TypeLiteral<Map<K, javax.inject.Provider<V>>> mapOfJavaxProviderOf(      TypeLiteral<K> keyType, TypeLiteral<V> valueType) {    return (TypeLiteral<Map<K, javax.inject.Provider<V>>>)        TypeLiteral.get(            Types.mapOf(                keyType.getType(),                newParameterizedType(javax.inject.Provider.class, valueType.getType())));  }
@SuppressWarnings("unchecked")  private static <T> Key<Provider<T>> getKeyOfProvider(Key<T> valueKey) {    return (Key<Provider<T>>)        valueKey.ofType(Types.providerOf(valueKey.getTypeLiteral().getType()));  }
static <K, V> RealMapBinder<K, V> newRealMapBinder(      Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) {    binder = binder.skipSources(RealMapBinder.class);    TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral();    return newRealMapBinder(        binder,        keyType,        valueType,        valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)),        RealMultibinder.newRealSetBinder(            binder, valueTypeAndAnnotation.ofType(entryOfProviderOf(keyType, valueType))));  }
Key<V> getKeyForNewValue(K key) {    checkNotNull(key, "key");    checkConfiguration(!bindingSelection.isInitialized(), "MapBinder was already initialized");    RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder =        bindingSelection.getEntrySetBinder();    Key<V> valueKey =        Key.get(            bindingSelection.getValueType(),            new RealElement(                entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString()));    entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey));    return valueKey;  }
public static DynamicFinder from(Method method) {    return method.isAnnotationPresent(Finder.class) ? new DynamicFinder(method) : null;  }
static void onNullInjectedIntoNonNullableDependency(Object source, Dependency<?> dependency)      throws InternalProvisionException {    // Hack to allow null parameters to @Provides methods, for backwards compatibility.    if (dependency.getInjectionPoint().getMember() instanceof Method) {      Method annotated = (Method) dependency.getInjectionPoint().getMember();      if (annotated.isAnnotationPresent(Provides.class)) {        switch (InternalFlags.getNullableProvidesOption()) {          case ERROR:            break; // break out & let the below exception happen          case IGNORE:            return; // user doesn't care about injecting nulls to non-@Nullables.          case WARN:            // Warn only once, otherwise we spam logs too much.            if (warnedDependencies.add(dependency)) {              logger.log(                  Level.WARNING,                  "Guice injected null into {0} (a {1}), please mark it @Nullable."                      + " Use -Dguice_check_nullable_provides_params=ERROR to turn this into an"                      + " error.",                  new Object[] {                    Messages.formatParameter(dependency), Messages.convert(dependency.getKey())                  });            }            return;        }      }    }    Object formattedDependency =        (dependency.getParameterIndex() != -1)            ? Messages.formatParameter(dependency)            : StackTraceElements.forMember(dependency.getInjectionPoint().getMember());    throw InternalProvisionException.create(            "null returned by binding at %s%n but %s is not @Nullable", source, formattedDependency)        .addSource(source);  }
InternalProvisionException addSource(Object source) {    if (source == SourceProvider.UNKNOWN_SOURCE) {      return this;    }    int sz = sourcesToPrepend.size();    if (sz > 0 && sourcesToPrepend.get(sz - 1) == source) {      // This is for when there are two identical sources added in a row.  This behavior is copied      // from Errors.withSource where it can happen when an constructor/provider method throws an      // exception      return this;    }    sourcesToPrepend.add(source);    return this;  }
Object construct(      final InternalContext context,      Dependency<?> dependency,      /* @Nullable */ ProvisionListenerStackCallback<T> provisionCallback)      throws InternalProvisionException {    final ConstructionContext<T> constructionContext = context.getConstructionContext(this);    // We have a circular reference between constructors. Return a proxy.    if (constructionContext.isConstructing()) {      // TODO (crazybob): if we can't proxy this object, can we proxy the other object?      return constructionContext.createProxy(          context.getInjectorOptions(), dependency.getKey().getTypeLiteral().getRawType());    }    // If we're re-entering this factory while injecting fields or methods,    // return the same instance. This prevents infinite loops.    T t = constructionContext.getCurrentReference();    if (t != null) {      if (context.getInjectorOptions().disableCircularProxies) {        throw InternalProvisionException.circularDependenciesDisabled(            dependency.getKey().getTypeLiteral().getRawType());      } else {        return t;      }    }    constructionContext.startConstruction();    try {      // Optimization: Don't go through the callback stack if we have no listeners.      if (provisionCallback == null) {        return provision(context, constructionContext);      } else {        return provisionCallback.provision(            context,            new ProvisionCallback<T>() {              @Override              public T call() throws InternalProvisionException {                return provision(context, constructionContext);              }            });      }    } finally {      constructionContext.finishConstruction();    }  }
private T provision(InternalContext context, ConstructionContext<T> constructionContext)      throws InternalProvisionException {    try {      T t;      try {        Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors);        t = constructionProxy.newInstance(parameters);        constructionContext.setProxyDelegates(t);      } finally {        constructionContext.finishConstruction();      }      // Store reference. If an injector re-enters this factory, they'll get the same reference.      constructionContext.setCurrentReference(t);      MembersInjectorImpl<T> localMembersInjector = membersInjector;      localMembersInjector.injectMembers(t, context, false);      localMembersInjector.notifyListeners(t);      return t;    } catch (InvocationTargetException userException) {      Throwable cause = userException.getCause() != null ? userException.getCause() : userException;      throw InternalProvisionException.errorInjectingConstructor(cause)          .addSource(constructionProxy.getInjectionPoint());    } finally {      constructionContext.removeCurrentReference();    }  }
protected BindingImpl<T> annotatedWithInternal(Class<? extends Annotation> annotationType) {    checkNotNull(annotationType, "annotationType");    checkNotAnnotated();    return setBinding(        binding.withKey(Key.get(this.binding.getKey().getTypeLiteral(), annotationType)));  }
protected BindingImpl<T> annotatedWithInternal(Annotation annotation) {    checkNotNull(annotation, "annotation");    checkNotAnnotated();    return setBinding(binding.withKey(Key.get(this.binding.getKey().getTypeLiteral(), annotation)));  }
private Object writeReplace() throws ObjectStreamException {    Object[] sourcesAsStrings = sources.toArray();    for (int i = 0; i < sourcesAsStrings.length; i++) {      sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString();    }    return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause);  }
static Module forModule(Module module) {    // avoid infinite recursion, since installing a module always installs itself    if (module instanceof CheckedProviderMethodsModule) {      return Modules.EMPTY_MODULE;    }    return new CheckedProviderMethodsModule(module);  }
@Override  @SuppressWarnings("unchecked")  public Collection<AssistedMethod> getAssistedMethods() {    return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values();  }
private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) {    Collection<Message> messages = ce.getErrorMessages();    if (messages.size() == 1) {      Message msg =          Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages());      return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage());    } else {      return false;    }  }
private <T> InjectionPoint findMatchingConstructorInjectionPoint(      Method method, Key<?> returnType, TypeLiteral<T> implementation, List<Key<?>> paramList)      throws ErrorsException {    Errors errors = new Errors(method);    if (returnType.getTypeLiteral().equals(implementation)) {      errors = errors.withSource(implementation);    } else {      errors = errors.withSource(returnType).withSource(implementation);    }    Class<?> rawType = implementation.getRawType();    if (Modifier.isInterface(rawType.getModifiers())) {      errors.addMessage(          "%s is an interface, not a concrete class.  Unable to create AssistedInject factory.",          implementation);      throw errors.toException();    } else if (Modifier.isAbstract(rawType.getModifiers())) {      errors.addMessage(          "%s is abstract, not a concrete class.  Unable to create AssistedInject factory.",          implementation);      throw errors.toException();    } else if (Classes.isInnerClass(rawType)) {      errors.cannotInjectInnerClass(rawType);      throw errors.toException();    }    Constructor<?> matchingConstructor = null;    boolean anyAssistedInjectConstructors = false;    // Look for AssistedInject constructors...    for (Constructor<?> constructor : rawType.getDeclaredConstructors()) {      if (constructor.isAnnotationPresent(AssistedInject.class)) {        anyAssistedInjectConstructors = true;        if (constructorHasMatchingParams(implementation, constructor, paramList, errors)) {          if (matchingConstructor != null) {            errors.addMessage(                "%s has more than one constructor annotated with @AssistedInject"                    + " that matches the parameters in method %s.  Unable to create "                    + "AssistedInject factory.",                implementation, method);            throw errors.toException();          } else {            matchingConstructor = constructor;          }        }      }    }    if (!anyAssistedInjectConstructors) {      // If none existed, use @Inject.      try {        return InjectionPoint.forConstructorOf(implementation);      } catch (ConfigurationException e) {        errors.merge(e.getErrorMessages());        throw errors.toException();      }    } else {      // Otherwise, use it or fail with a good error message.      if (matchingConstructor != null) {        // safe because we got the constructor from this implementation.        @SuppressWarnings("unchecked")        InjectionPoint ip =            InjectionPoint.forConstructor(                (Constructor<? super T>) matchingConstructor, implementation);        return ip;      } else {        errors.addMessage(            "%s has @AssistedInject constructors, but none of them match the"                + " parameters in method %s.  Unable to create AssistedInject factory.",            implementation, method);        throw errors.toException();      }    }  }
private boolean constructorHasMatchingParams(      TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors)      throws ErrorsException {    List<TypeLiteral<?>> params = type.getParameterTypes(constructor);    Annotation[][] paramAnnotations = constructor.getParameterAnnotations();    int p = 0;    List<Key<?>> constructorKeys = Lists.newArrayList();    for (TypeLiteral<?> param : params) {      Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors);      constructorKeys.add(paramKey);    }    // Require that every key exist in the constructor to match up exactly.    for (Key<?> key : paramList) {      // If it didn't exist in the constructor set, we can't use it.      if (!constructorKeys.remove(key)) {        return false;      }    }    // If any keys remain and their annotation is Assisted, we can't use it.    for (Key<?> key : constructorKeys) {      if (key.getAnnotationType() == Assisted.class) {        return false;      }    }    // All @Assisted params match up to the method's parameters.    return true;  }
private Set<Dependency<?>> getDependencies(      InjectionPoint ctorPoint, TypeLiteral<?> implementation) {    ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();    builder.addAll(ctorPoint.getDependencies());    if (!implementation.getRawType().isInterface()) {      for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) {        builder.addAll(ip.getDependencies());      }    }    return builder.build();  }
private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) {    ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();    for (Dependency<?> dep : deps) {      Class<?> annotationType = dep.getKey().getAnnotationType();      if (annotationType == null || !annotationType.equals(Assisted.class)) {        builder.add(dep);      }    }    return builder.build();  }
private boolean isValidForOptimizedAssistedInject(      Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) {    Set<Dependency<?>> badDeps = null; // optimization: create lazily    for (Dependency<?> dep : dependencies) {      if (isInjectorOrAssistedProvider(dep)) {        if (badDeps == null) {          badDeps = Sets.newHashSet();        }        badDeps.add(dep);      }    }    if (badDeps != null && !badDeps.isEmpty()) {      logger.log(          Level.WARNING,          "AssistedInject factory {0} will be slow "              + "because {1} has assisted Provider dependencies or injects the Injector. "              + "Stop injecting @Assisted Provider<T> (instead use @Assisted T) "              + "or Injector to speed things up. (It will be a ~6500% speed bump!)  "              + "The exact offending deps are: {2}",          new Object[] {factoryType, implementation, badDeps});      return false;    }    return true;  }
private boolean isInjectorOrAssistedProvider(Dependency<?> dependency) {    Class<?> annotationType = dependency.getKey().getAnnotationType();    if (annotationType != null && annotationType.equals(Assisted.class)) { // If it's assisted..      if (dependency          .getKey()          .getTypeLiteral()          .getRawType()          .equals(Provider.class)) { // And a Provider...        return true;      }    } else if (dependency        .getKey()        .getTypeLiteral()        .getRawType()        .equals(Injector.class)) { // If it's the Injector...      return true;    }    return false;  }
@Inject  @Toolable  void initialize(Injector injector) {    if (this.injector != null) {      throw new ConfigurationException(          ImmutableList.of(              new Message(                  FactoryProvider2.class,                  "Factories.create() factories may only be used in one Injector!")));    }    this.injector = injector;    for (Map.Entry<Method, AssistData> entry : assistDataByMethod.entrySet()) {      Method method = entry.getKey();      AssistData data = entry.getValue();      Object[] args;      if (!data.optimized) {        args = new Object[method.getParameterTypes().length];        Arrays.fill(args, "dummy object for validating Factories");      } else {        args = null; // won't be used -- instead will bind to data.providers.      }      getBindingFromNewInjector(          method, args, data); // throws if the binding isn't properly configured    }  }
public Binding<?> getBindingFromNewInjector(      final Method method, final Object[] args, final AssistData data) {    checkState(        injector != null,        "Factories.create() factories cannot be used until they're initialized by Guice.");    final Key<?> returnType = data.returnType;    // We ignore any pre-existing binding annotation.    final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION);    Module assistedModule =        new AbstractModule() {          @Override          @SuppressWarnings({            "unchecked",            "rawtypes"          }) // raw keys are necessary for the args array and return value          protected void configure() {            Binder binder = binder().withSource(method);            int p = 0;            if (!data.optimized) {              for (Key<?> paramKey : data.paramTypes) {                // Wrap in a Provider to cover null, and to prevent Guice from injecting the                // parameter                binder.bind((Key) paramKey).toProvider(Providers.of(args[p++]));              }            } else {              for (Key<?> paramKey : data.paramTypes) {                // Bind to our ThreadLocalProviders.                binder.bind((Key) paramKey).toProvider(data.providers.get(p++));              }            }            Constructor constructor = data.constructor;            // Constructor *should* always be non-null here,            // but if it isn't, we'll end up throwing a fairly good error            // message for the user.            if (constructor != null) {              binder                  .bind(returnKey)                  .toConstructor(constructor, (TypeLiteral) data.implementationType)                  .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type            }          }        };    Injector forCreate = injector.createChildInjector(assistedModule);    Binding<?> binding = forCreate.getBinding(returnKey);    // If we have providers cached in data, cache the binding for future optimizations.    if (data.optimized) {      data.cachedBinding = binding;    }    return binding;  }
@Override  public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {    // If we setup a method handle earlier for this method, call it.    // This is necessary for default methods that java8 creates, so we    // can call the default method implementation (and not our proxied version of it).    if (methodHandleByMethod.containsKey(method)) {      return methodHandleByMethod.get(method).invokeWithArguments(args);    }    if (method.getDeclaringClass().equals(Object.class)) {      if ("equals".equals(method.getName())) {        return proxy == args[0];      } else if ("hashCode".equals(method.getName())) {        return System.identityHashCode(proxy);      } else {        return method.invoke(this, args);      }    }    AssistData data = assistDataByMethod.get(method);    checkState(data != null, "No data for method: %s", method);    Provider<?> provider;    if (data.cachedBinding != null) { // Try to get optimized form...      provider = data.cachedBinding.getProvider();    } else {      provider = getBindingFromNewInjector(method, args, data).getProvider();    }    try {      int p = 0;      for (ThreadLocalProvider tlp : data.providers) {        tlp.set(args[p++]);      }      return provider.get();    } catch (ProvisionException e) {      // if this is an exception declared by the factory method, throw it as-is      if (e.getErrorMessages().size() == 1) {        Message onlyError = getOnlyElement(e.getErrorMessages());        Throwable cause = onlyError.getCause();        if (cause != null && canRethrow(method, cause)) {          throw cause;        }      }      throw e;    } finally {      for (ThreadLocalProvider tlp : data.providers) {        tlp.remove();      }    }  }
static boolean canRethrow(Method invoked, Throwable thrown) {    if (thrown instanceof Error || thrown instanceof RuntimeException) {      return true;    }    for (Class<?> declared : invoked.getExceptionTypes()) {      if (declared.isInstance(thrown)) {        return true;      }    }    return false;  }
static <T> T checkNotNull(T reference, String name) {    if (reference != null) {      return reference;    }    NullPointerException npe = new NullPointerException(name);    throw new ConfigurationException(ImmutableSet.of(new Message(npe.toString(), npe)));  }
static void checkConfiguration(boolean condition, String format, Object... args) {    if (condition) {      return;    }    throw new ConfigurationException(ImmutableSet.of(new Message(Errors.format(format, args))));  }
public Errors withSource(Object source) {    return source == this.source || source == SourceProvider.UNKNOWN_SOURCE        ? this        : new Errors(this, source);  }
<T> Errors missingImplementationWithHint(Key<T> key, Injector injector) {    StringBuilder sb = new StringBuilder();    sb.append(format("No implementation for %s was bound.", key));    // Keys which have similar strings as the desired key    List<String> possibleMatches = new ArrayList<>();    // Check for other keys that may have the same type,    // but not the same annotation    TypeLiteral<T> type = key.getTypeLiteral();    List<Binding<T>> sameTypes = injector.findBindingsByType(type);    if (!sameTypes.isEmpty()) {      sb.append(format("%n  Did you mean?"));      int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED);      for (int i = 0; i < howMany; ++i) {        // TODO: Look into a better way to prioritize suggestions. For example, possbily        // use levenshtein distance of the given annotation vs actual annotation.        sb.append(format("%n    * %s", sameTypes.get(i).getKey()));      }      int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED;      if (remaining > 0) {        String plural = (remaining == 1) ? "" : "s";        sb.append(format("%n    %d more binding%s with other annotations.", remaining, plural));      }    } else {      // For now, do a simple substring search for possibilities. This can help spot      // issues when there are generics being used (such as a wrapper class) and the      // user has forgotten they need to bind based on the wrapper, not the underlying      // class. In the future, consider doing a strict in-depth type search.      // TODO: Look into a better way to prioritize suggestions. For example, possbily      // use levenshtein distance of the type literal strings.      String want = type.toString();      Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings();      for (Key<?> bindingKey : bindingMap.keySet()) {        String have = bindingKey.getTypeLiteral().toString();        if (have.contains(want) || want.contains(have)) {          Formatter fmt = new Formatter();          Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource());          String match = String.format("%s bound%s", convert(bindingKey), fmt.toString());          possibleMatches.add(match);          // TODO: Consider a check that if there are more than some number of results,          // don't suggest any.          if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) {            // Early exit if we have found more than we need.            break;          }        }      }      if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) {        sb.append(format("%n  Did you mean?"));        for (String possibleMatch : possibleMatches) {          sb.append(format("%n    %s", possibleMatch));        }      }    }    // If where are no possibilities to suggest, then handle the case of missing    // annotations on simple types. This is usually a bad idea.    if (sameTypes.isEmpty()        && possibleMatches.isEmpty()        && key.getAnnotation() == null        && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) {      // We don't recommend using such simple types without annotations.      sb.append(format("%nThe key seems very generic, did you forget an annotation?"));    }    return addMessage(sb.toString());  }
public static String format(String messageFormat, Object... arguments) {    return Messages.format(messageFormat, arguments);  }
public static Object convert(Object o, ElementSource source) {    return Messages.convert(o, source);  }
public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) {    binder = binder.skipSources(RealMultibinder.class);    RealMultibinder<T> result = new RealMultibinder<>(binder, key);    binder.install(result);    return result;  }
Key<T> getKeyForNewItem() {    checkConfiguration(!bindingSelection.isInitialized(), "Multibinder was already initialized");    return Key.get(        bindingSelection.getElementTypeLiteral(),        new RealElement(bindingSelection.getSetName(), MULTIBINDER, ""));  }
private Filter findNextFilter(HttpServletRequest request) {    while (++index < filterDefinitions.length) {      Filter filter = filterDefinitions[index].getFilterIfMatching(request);      if (filter != null) {        return filter;      }    }    return null;  }
private static boolean hasAtInject(Constructor cxtor) {    return cxtor.isAnnotationPresent(Inject.class)        || cxtor.isAnnotationPresent(javax.inject.Inject.class);  }
InjectionPoint getInternalConstructor() {    if (factory.constructorInjector != null) {      return factory.constructorInjector.getConstructionProxy().getInjectionPoint();    } else {      return constructorInjectionPoint;    }  }
Set<Dependency<?>> getInternalDependencies() {    ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();    if (factory.constructorInjector == null) {      builder.add(constructorInjectionPoint);      // If the below throws, it's OK -- we just ignore those dependencies, because no one      // could have used them anyway.      try {        builder.addAll(            InjectionPoint.forInstanceMethodsAndFields(                constructorInjectionPoint.getDeclaringType()));      } catch (ConfigurationException ignored) {      }    } else {      builder.add(getConstructor()).addAll(getInjectableMembers());    }    return Dependency.forInjectionPoints(builder.build());  }
@Override  public Map<Method, List<org.aopalliance.intercept.MethodInterceptor>> getMethodInterceptors() {    checkState(factory.constructorInjector != null, "Binding is not ready");    return factory.constructorInjector.getConstructionProxy().getMethodInterceptors();  }
@Override  public Set<Dependency<?>> getDependencies() {    return Dependency.forInjectionPoints(        new ImmutableSet.Builder<InjectionPoint>()            .add(getConstructor())            .addAll(getInjectableMembers())            .build());  }
public Set<InjectionPoint> getInjectionPoints() throws ConfigurationException {    return InjectionPoint.forInstanceMethodsAndFields(        instance != null ? TypeLiteral.get(instance.getClass()) : type);  }
private static <T extends Enum<T>> T getSystemOption(final String name, T defaultValue) {    return getSystemOption(name, defaultValue, defaultValue);  }
private static <T extends Enum<T>> T getSystemOption(final String name, T defaultValue,      T secureValue) {    Class<T> enumType = defaultValue.getDeclaringClass();    String value = null;    try {      value =          AccessController.doPrivileged(              new PrivilegedAction<String>() {                @Override                public String run() {                  return System.getProperty(name);                }              });      return (value != null && value.length() > 0) ? Enum.valueOf(enumType, value) : defaultValue;    } catch (SecurityException e) {      return secureValue;    } catch (IllegalArgumentException e) {      logger.warning(value + " is not a valid flag value for " + name + ". "          + " Values must be one of " + Arrays.asList(enumType.getEnumConstants()));      return defaultValue;    }  }
@Override  public String getSourceName(Object source) {    if (source instanceof ElementSource) {      source = ((ElementSource) source).getDeclaringSource();    }    if (source instanceof Method) {      source = StackTraceElements.forMember((Method) source);    }    if (source instanceof StackTraceElement) {      return getFileString((StackTraceElement) source);    }    return stripPackages(source.toString());  }
public static ParameterizedType newParameterizedType(Type rawType, Type... typeArguments) {    return newParameterizedTypeWithOwner(null, rawType, typeArguments);  }
public static ParameterizedType newParameterizedTypeWithOwner(      Type ownerType, Type rawType, Type... typeArguments) {    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);  }
public static ParameterizedType mapOf(Type keyType, Type valueType) {    return newParameterizedType(Map.class, keyType, valueType);  }
public static Type javaxProviderOf(Type type) {    return Types.newParameterizedType(javax.inject.Provider.class, type);  }
public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) {    return forObject(module, false, scanner);  }
private Annotation getAnnotation(Binder binder, Method method) {    if (method.isBridge() || method.isSynthetic()) {      return null;    }    Annotation annotation = null;    for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) {      Annotation foundAnnotation = method.getAnnotation(annotationClass);      if (foundAnnotation != null) {        if (annotation != null) {          binder.addError(              "More than one annotation claimed by %s on method %s."                  + " Methods can only have one annotation claimed per scanner.",              scanner, method);          return null;        }        annotation = foundAnnotation;      }    }    return annotation;  }
public static void bindProperties(Binder binder, Map<String, String> properties) {    binder = binder.skipSources(Names.class);    for (Map.Entry<String, String> entry : properties.entrySet()) {      String key = entry.getKey();      String value = entry.getValue();      binder.bind(Key.get(String.class, new NamedImpl(key))).toInstance(value);    }  }
public static void bindProperties(Binder binder, Properties properties) {    binder = binder.skipSources(Names.class);    // use enumeration to include the default properties    for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {      String propertyName = (String) e.nextElement();      String value = properties.getProperty(propertyName);      binder.bind(Key.get(String.class, new NamedImpl(propertyName))).toInstance(value);    }  }
public static Injector createInjector(Stage stage, Module... modules) {    return createInjector(stage, Arrays.asList(modules));  }
public static Injector createInjector(Stage stage, Iterable<? extends Module> modules) {    return new InternalInjectorCreator().stage(stage).addModules(modules).build();  }
public List<Integer> getModuleConfigurePositionsInStackTrace() {    int size = moduleSource.size();    Integer[] positions = new Integer[size];    int chunkSize = partialCallStack.length;    positions[0] = chunkSize - 1;    ModuleSource current = moduleSource;    for (int cursor = 1; cursor < size; cursor++) {      chunkSize = current.getPartialCallStackSize();      positions[cursor] = positions[cursor - 1] + chunkSize;      current = current.getParent();    }    return ImmutableList.<Integer>copyOf(positions);  }
public StackTraceElement[] getStackTrace() {    int modulesCallStackSize = moduleSource.getStackTraceSize();    int chunkSize = partialCallStack.length;    int size = moduleSource.getStackTraceSize() + chunkSize;    StackTraceElement[] callStack = new StackTraceElement[size];    System.arraycopy(        StackTraceElements.convertToStackTraceElement(partialCallStack),        0,        callStack,        0,        chunkSize);    System.arraycopy(moduleSource.getStackTrace(), 0, callStack, chunkSize, modulesCallStackSize);    return callStack;  }
public Integer getLineNumber(Member member) {    Preconditions.checkArgument(        type == member.getDeclaringClass(),        "Member %s belongs to %s, not %s",        member,        member.getDeclaringClass(),        type);    return lines.get(memberKey(member));  }
void initialize(Errors errors) {    injector.lookups = injector;    new LookupProcessor(errors).process(injector, lookups);  }
@Deprecated  public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) {    return wrap(callable, continueRequest(seedMap));  }
public static <T> Callable<T> transferRequest(Callable<T> callable) {    return wrap(callable, transferRequest());  }
public static <T> Callable<T> scopeRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) {    return wrap(callable, scopeRequest(seedMap));  }
private static Object validateAndCanonicalizeValue(Key<?> key, Object object) {    if (object == null || object == NullObject.INSTANCE) {      return NullObject.INSTANCE;    }    if (!key.getTypeLiteral().getRawType().isInstance(object)) {      throw new IllegalArgumentException(          "Value["              + object              + "] of type["              + object.getClass().getName()              + "] is not compatible with key["              + key              + "]");    }    return object;  }
@SuppressWarnings("unchecked") // the MembersInjector type always agrees with the passed type  public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException {    return (MembersInjectorImpl<T>) cache.get(key, errors);  }
private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors)      throws ErrorsException {    int numErrorsBefore = errors.size();    Set<InjectionPoint> injectionPoints;    try {      injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type);    } catch (ConfigurationException e) {      errors.merge(e.getErrorMessages());      injectionPoints = e.getPartialValue();    }    ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors);    errors.throwIfNewErrors(numErrorsBefore);    EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups);    Set<TypeListener> alreadySeenListeners = Sets.newHashSet();    for (TypeListenerBinding binding : typeListenerBindings) {      TypeListener typeListener = binding.getListener();      if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) {        alreadySeenListeners.add(typeListener);        try {          typeListener.hear(type, encounter);        } catch (RuntimeException e) {          errors.errorNotifyingTypeListener(binding, type, e);        }      }    }    encounter.invalidate();    errors.throwIfNewErrors(numErrorsBefore);    return new MembersInjectorImpl<T>(injector, type, encounter, injectors);  }
ImmutableList<SingleMemberInjector> getInjectors(      Set<InjectionPoint> injectionPoints, Errors errors) {    List<SingleMemberInjector> injectors = Lists.newArrayList();    for (InjectionPoint injectionPoint : injectionPoints) {      try {        Errors errorsForMember =            injectionPoint.isOptional()                ? new Errors(injectionPoint)                : errors.withSource(injectionPoint);        SingleMemberInjector injector =            injectionPoint.getMember() instanceof Field                ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember)                : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember);        injectors.add(injector);      } catch (ErrorsException ignoredForNow) {        // ignored for now      }    }    return ImmutableList.copyOf(injectors);  }
@Inject  static void setPipeline(FilterPipeline pipeline) {    // This can happen if you create many injectors and they all have their own    // servlet module. This is legal, caveat a small warning.    if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {      LOGGER.warning(MULTIPLE_INJECTORS_WARNING);    }    // We overwrite the default pipeline    GuiceFilter.pipeline = pipeline;  }
static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) {    return new Key<T>(type, annotationStrategy);  }
public static <T> Key<T> get(Class<T> type) {    return new Key<T>(type, NullAnnotationStrategy.INSTANCE);  }
public static <T> Key<T> get(Class<T> type, Class<? extends Annotation> annotationType) {    return new Key<T>(type, strategyFor(annotationType));  }
public static <T> Key<T> get(Class<T> type, Annotation annotation) {    return new Key<T>(type, strategyFor(annotation));  }
public static Key<?> get(Type type, Class<? extends Annotation> annotationType) {    return new Key<Object>(type, strategyFor(annotationType));  }
public static Key<?> get(Type type, Annotation annotation) {    return new Key<Object>(type, strategyFor(annotation));  }
public static <T> Key<T> get(TypeLiteral<T> typeLiteral) {    return new Key<T>(typeLiteral, NullAnnotationStrategy.INSTANCE);  }
public static <T> Key<T> get(      TypeLiteral<T> typeLiteral, Class<? extends Annotation> annotationType) {    return new Key<T>(typeLiteral, strategyFor(annotationType));  }
public static <T> Key<T> get(TypeLiteral<T> typeLiteral, Annotation annotation) {    return new Key<T>(typeLiteral, strategyFor(annotation));  }
public <T> Key<T> ofType(Class<T> type) {    return new Key<T>(type, annotationStrategy);  }
public <T> Key<T> ofType(TypeLiteral<T> type) {    return new Key<T>(type, annotationStrategy);  }
static AnnotationStrategy strategyFor(Annotation annotation) {    checkNotNull(annotation, "annotation");    Class<? extends Annotation> annotationType = annotation.annotationType();    ensureRetainedAtRuntime(annotationType);    ensureIsBindingAnnotation(annotationType);    if (Annotations.isMarker(annotationType)) {      return new AnnotationTypeStrategy(annotationType, annotation);    }    return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation));  }
static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) {    annotationType = Annotations.canonicalizeIfNamed(annotationType);    if (isAllDefaultMethods(annotationType)) {      return strategyFor(generateAnnotation(annotationType));    }    checkNotNull(annotationType, "annotation type");    ensureRetainedAtRuntime(annotationType);    ensureIsBindingAnnotation(annotationType);    return new AnnotationTypeStrategy(annotationType, null);  }
public static List<Element> getElements(Module... modules) {    return getElements(Stage.DEVELOPMENT, Arrays.asList(modules));  }
public static List<Element> getElements(Iterable<? extends Module> modules) {    return getElements(Stage.DEVELOPMENT, modules);  }
public static List<Element> getElements(Stage stage, Iterable<? extends Module> modules) {    RecordingBinder binder = new RecordingBinder(stage);    for (Module module : modules) {      binder.install(module);    }    binder.scanForAnnotatedMethods();    for (RecordingBinder child : binder.privateBinders) {      child.scanForAnnotatedMethods();    }    // Free the memory consumed by the stack trace elements cache    StackTraceElements.clearCache();    return Collections.unmodifiableList(binder.elements);  }
private void pruneStacktrace(Throwable throwable) {    for (Throwable t = throwable; t != null; t = t.getCause()) {      StackTraceElement[] stackTrace = t.getStackTrace();      List<StackTraceElement> pruned = Lists.newArrayList();      for (StackTraceElement element : stackTrace) {        String className = element.getClassName();        if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains("$EnhancerByGuice$")) {          pruned.add(element);        }      }      t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()]));    }  }
@SuppressWarnings(      "unchecked") // the ProvisionListenerStackCallback type always agrees with the passed type  public <T> ProvisionListenerStackCallback<T> get(Binding<T> binding) {    // Never notify any listeners for internal bindings.    if (!INTERNAL_BINDINGS.contains(binding.getKey())) {      ProvisionListenerStackCallback<T> callback =          (ProvisionListenerStackCallback<T>)              cache.getUnchecked(new KeyBinding(binding.getKey(), binding));      return callback.hasListeners() ? callback : null;    }    return null;  }
private <T> ProvisionListenerStackCallback<T> create(Binding<T> binding) {    List<ProvisionListener> listeners = null;    for (ProvisionListenerBinding provisionBinding : listenerBindings) {      if (provisionBinding.getBindingMatcher().matches(binding)) {        if (listeners == null) {          listeners = Lists.newArrayList();        }        listeners.addAll(provisionBinding.getListeners());      }    }    if (listeners == null || listeners.isEmpty()) {      // Optimization: don't bother constructing the callback if there are      // no listeners.      return ProvisionListenerStackCallback.emptyListener();    }    return new ProvisionListenerStackCallback<T>(binding, listeners);  }
public String getBindingSource() {    if (source instanceof Class) {      return StackTraceElements.forType((Class) source).toString();    } else if (source instanceof Member) {      return StackTraceElements.forMember((Member) source).toString();    } else {      return source.toString();    }  }
ImmutableList<MethodAspect> getAspects() {    return aspects == null ? ImmutableList.<MethodAspect>of() : ImmutableList.copyOf(aspects);  }
ImmutableSet<MembersInjector<? super T>> getMembersInjectors() {    return membersInjectors == null        ? ImmutableSet.<MembersInjector<? super T>>of()        : ImmutableSet.copyOf(membersInjectors);  }
static Message mergeSources(List<Object> sources, Message message) {    List<Object> messageSources = message.getSources();    // It is possible that the end of getSources() and the beginning of message.getSources() are    // equivalent, in this case we should drop the repeated source when joining the lists.  The    // most likely scenario where this would happen is when a scoped binding throws an exception,    // due to the fact that InternalFactoryToProviderAdapter applies the binding source when    // merging errors.    if (!sources.isEmpty()        && !messageSources.isEmpty()        && Objects.equal(messageSources.get(0), sources.get(sources.size() - 1))) {      messageSources = messageSources.subList(1, messageSources.size());    }    return new Message(        ImmutableList.builder().addAll(sources).addAll(messageSources).build(),        message.getMessage(),        message.getCause());  }
public static String format(String messageFormat, Object... arguments) {    for (int i = 0; i < arguments.length; i++) {      arguments[i] = convert(arguments[i]);    }    return String.format(messageFormat, arguments);  }
public static String formatMessages(String heading, Collection<Message> errorMessages) {    Formatter fmt = new Formatter().format(heading).format(":%n%n");    int index = 1;    boolean displayCauses = getOnlyCause(errorMessages) == null;    Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap();    for (Message errorMessage : errorMessages) {      int thisIdx = index++;      fmt.format("%s) %s%n", thisIdx, errorMessage.getMessage());      List<Object> dependencies = errorMessage.getSources();      for (int i = dependencies.size() - 1; i >= 0; i--) {        Object source = dependencies.get(i);        formatSource(fmt, source);      }      Throwable cause = errorMessage.getCause();      if (displayCauses && cause != null) {        Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause);        if (!causes.containsKey(causeEquivalence)) {          causes.put(causeEquivalence, thisIdx);          fmt.format("Caused by: %s", Throwables.getStackTraceAsString(cause));        } else {          int causeIdx = causes.get(causeEquivalence);          fmt.format(              "Caused by: %s (same stack trace as error #%s)",              cause.getClass().getName(), causeIdx);        }      }      fmt.format("%n");    }    if (errorMessages.size() == 1) {      fmt.format("1 error");    } else {      fmt.format("%s errors", errorMessages.size());    }    return fmt.toString();  }
public static Message create(String messageFormat, Object... arguments) {    return create(null, messageFormat, arguments);  }
public static Message create(Throwable cause, String messageFormat, Object... arguments) {    return create(cause, ImmutableList.of(), messageFormat, arguments);  }
public static Message create(      Throwable cause, List<Object> sources, String messageFormat, Object... arguments) {    String message = format(messageFormat, arguments);    return new Message(sources, message, cause);  }
static Object convert(Object o) {    ElementSource source = null;    if (o instanceof ElementSource) {      source = (ElementSource) o;      o = source.getDeclaringSource();    }    return convert(o, source);  }
public static Throwable getOnlyCause(Collection<Message> messages) {    Throwable onlyCause = null;    for (Message message : messages) {      Throwable messageCause = message.getCause();      if (messageCause == null) {        continue;      }      if (onlyCause != null && !ThrowableEquivalence.INSTANCE.equivalent(onlyCause, messageCause)) {        return null;      }      onlyCause = messageCause;    }    return onlyCause;  }
List<String> getModuleClassNames() {    ImmutableList.Builder<String> classNames = ImmutableList.builder();    ModuleSource current = this;    while (current != null) {      String className = current.moduleClassName;      classNames.add(className);      current = current.parent;    }    return classNames.build();  }
StackTraceElement[] getStackTrace() {    int stackTraceSize = getStackTraceSize();    StackTraceElement[] callStack = new StackTraceElement[stackTraceSize];    int cursor = 0;    ModuleSource current = this;    while (current != null) {      StackTraceElement[] chunk =          StackTraceElements.convertToStackTraceElement(current.partialCallStack);      int chunkSize = chunk.length;      System.arraycopy(chunk, 0, callStack, cursor, chunkSize);      current = current.parent;      cursor = cursor + chunkSize;    }    return callStack;  }
public static <T> T inject(Class<T> type, Object... modules) {    Key key = new Key(type, null);    MiniGuice miniGuice = new MiniGuice();    for (Object module : modules) {      miniGuice.install(module);    }    miniGuice.requireKey(key, "root injection");    miniGuice.addJitBindings();    miniGuice.addProviderBindings();    miniGuice.eagerlyLoadSingletons();    Provider<?> provider = miniGuice.bindings.get(key);    return type.cast(provider.get());  }
private boolean shouldBeSkipped(String className) {    return (parent != null && parent.shouldBeSkipped(className))        || classNamesToSkip.contains(className);  }
private static List<String> asStrings(Class... classes) {    List<String> strings = Lists.newArrayList();    for (Class c : classes) {      strings.add(c.getName());    }    return strings;  }
public StackTraceElement get(StackTraceElement[] stackTraceElements) {    Preconditions.checkNotNull(stackTraceElements, "The stack trace elements cannot be null.");    for (final StackTraceElement element : stackTraceElements) {      String className = element.getClassName();      if (!shouldBeSkipped(className)) {        return element;      }    }    throw new AssertionError();  }
public Object getFromClassNames(List<String> moduleClassNames) {    Preconditions.checkNotNull(moduleClassNames, "The list of module class names cannot be null.");    for (final String moduleClassName : moduleClassNames) {      if (!shouldBeSkipped(moduleClassName)) {        return new StackTraceElement(moduleClassName, "configure", null, -1);      }    }    return UNKNOWN_SOURCE;  }
public static void manage(String domain, Injector injector) {    manage(ManagementFactory.getPlatformMBeanServer(), domain, injector);  }
public static void manage(MBeanServer server, String domain, Injector injector) {    // Register each binding independently.    for (Binding<?> binding : injector.getBindings().values()) {      // Construct the name manually so we can ensure proper ordering of the      // key/value pairs.      StringBuilder name = new StringBuilder();      name.append(domain).append(":");      Key<?> key = binding.getKey();      name.append("type=").append(quote(key.getTypeLiteral().toString()));      Annotation annotation = key.getAnnotation();      if (annotation != null) {        name.append(",annotation=").append(quote(annotation.toString()));      } else {        Class<? extends Annotation> annotationType = key.getAnnotationType();        if (annotationType != null) {          name.append(",annotation=").append(quote("@" + annotationType.getName()));        }      }      try {        server.registerMBean(new ManagedBinding(binding), new ObjectName(name.toString()));      } catch (MalformedObjectNameException e) {        throw new RuntimeException("Bad object name: " + name, e);      } catch (Exception e) {        throw new RuntimeException(e);      }    }  }
public static void main(String[] args) throws Exception {    if (args.length != 1) {      System.err.println(          "Usage: java -Dcom.sun.management.jmxremote "              + Manager.class.getName()              + " [module class name]");      System.err.println("Then run 'jconsole' to connect.");      System.exit(1);    }    Module module = (Module) Class.forName(args[0]).newInstance();    Injector injector = Guice.createInjector(module);    manage(args[0], injector);    System.out.println("Press Ctrl+C to exit...");    // Sleep forever.    Thread.sleep(Long.MAX_VALUE);  }
public static InMemoryStackTraceElement[] convertToInMemoryStackTraceElement(      StackTraceElement[] stackTraceElements) {    if (stackTraceElements.length == 0) {      return EMPTY_INMEMORY_STACK_TRACE;    }    InMemoryStackTraceElement[] inMemoryStackTraceElements =        new InMemoryStackTraceElement[stackTraceElements.length];    for (int i = 0; i < stackTraceElements.length; i++) {      inMemoryStackTraceElements[i] =          weakIntern(new InMemoryStackTraceElement(stackTraceElements[i]));    }    return inMemoryStackTraceElements;  }
public static StackTraceElement[] convertToStackTraceElement(      InMemoryStackTraceElement[] inMemoryStackTraceElements) {    if (inMemoryStackTraceElements.length == 0) {      return EMPTY_STACK_TRACE;    }    StackTraceElement[] stackTraceElements =        new StackTraceElement[inMemoryStackTraceElements.length];    for (int i = 0; i < inMemoryStackTraceElements.length; i++) {      String declaringClass = inMemoryStackTraceElements[i].getClassName();      String methodName = inMemoryStackTraceElements[i].getMethodName();      int lineNumber = inMemoryStackTraceElements[i].getLineNumber();      stackTraceElements[i] =          new StackTraceElement(declaringClass, methodName, UNKNOWN_SOURCE, lineNumber);    }    return stackTraceElements;  }
Dependency<?> pushDependency(Dependency<?> dependency, Object source) {    Dependency<?> previous = this.dependency;    this.dependency = dependency;    doPushState(dependency, source);    return previous;  }
void pushState(com.google.inject.Key<?> key, Object source) {    doPushState(key, source);  }
java.util.List<com.google.inject.spi.DependencyAndSource> getDependencyChain() {    com.google.common.collect.ImmutableList.Builder<com.google.inject.spi.DependencyAndSource>        builder = com.google.common.collect.ImmutableList.builder();    for (int i = 0; i < dependencyStackSize; i += 2) {      Object evenEntry = dependencyStack[i];      Dependency<?> dependency;      if (evenEntry instanceof com.google.inject.Key) {        dependency = Dependency.get((com.google.inject.Key<?>) evenEntry);      } else {        dependency = (Dependency<?>) evenEntry;      }      builder.add(new com.google.inject.spi.DependencyAndSource(dependency, dependencyStack[i + 1]));    }    return builder.build();  }
static <T> Initializable<T> of(final T instance) {    return new Initializable<T>() {      @Override      public T get() {        return instance;      }      @Override      public String toString() {        return String.valueOf(instance);      }    };  }
void doService(final ServletRequest servletRequest, ServletResponse servletResponse)      throws ServletException, IOException {    HttpServletRequest request =        new HttpServletRequestWrapper((HttpServletRequest) servletRequest) {          private boolean pathComputed;          private String path;          private boolean pathInfoComputed;          private String pathInfo;          @Override          public String getPathInfo() {            if (!isPathInfoComputed()) {              String servletPath = getServletPath();              int servletPathLength = servletPath.length();              String requestUri = getRequestURI();              pathInfo = requestUri.substring(getContextPath().length()).replaceAll("[/]{2,}", "/");              // See: https://github.com/google/guice/issues/372              if (pathInfo.startsWith(servletPath)) {                pathInfo = pathInfo.substring(servletPathLength);                // Corner case: when servlet path & request path match exactly (without trailing '/'),                // then pathinfo is null.                if (pathInfo.isEmpty() && servletPathLength > 0) {                  pathInfo = null;                } else {                  try {                    pathInfo = new URI(pathInfo).getPath();                  } catch (URISyntaxException e) {                    // ugh, just leave it alone then                  }                }              } else {                pathInfo = null; // we know nothing additional about the URI.              }              pathInfoComputed = true;            }            return pathInfo;          }          // NOTE(dhanji): These two are a bit of a hack to help ensure that request dispatcher-sent          // requests don't use the same path info that was memoized for the original request.          // NOTE(iqshum): I don't think this is possible, since the dispatcher-sent request would          // perform its own wrapping.          private boolean isPathInfoComputed() {            return pathInfoComputed                && servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST) == null;          }          private boolean isPathComputed() {            return pathComputed && servletRequest.getAttribute(REQUEST_DISPATCHER_REQUEST) == null;          }          @Override          public String getServletPath() {            return computePath();          }          @Override          public String getPathTranslated() {            final String info = getPathInfo();            return (null == info) ? null : getRealPath(info);          }          // Memoizer pattern.          private String computePath() {            if (!isPathComputed()) {              String servletPath = super.getServletPath();              path = patternMatcher.extractPath(servletPath);              pathComputed = true;              if (null == path) {                path = servletPath;              }            }            return path;          }        };    doServiceImpl(request, (HttpServletResponse) servletResponse);  }
protected T provision(      Provider<? extends T> provider,      Dependency<?> dependency,      ConstructionContext<T> constructionContext)      throws InternalProvisionException {    T t = provider.get();    if (t == null && !dependency.isNullable()) {      InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency);    }    constructionContext.setProxyDelegates(t);    return t;  }
public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) {        List<ConnectionEventProcessor> processorList = this.processors.get(type);        if (processorList != null) {            for (ConnectionEventProcessor processor : processorList) {                processor.onEvent(remoteAddr, conn);            }        }    }
public void addConnectionEventProcessor(ConnectionEventType type,                                            ConnectionEventProcessor processor) {        List<ConnectionEventProcessor> processorList = this.processors.get(type);        if (processorList == null) {            this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1));            processorList = this.processors.get(type);        }        processorList.add(processor);    }
public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) {        T t = null;        if (null != task) {            try {                t = task.getAfterRun();            } catch (InterruptedException e) {                logger.error("Future task interrupted!", e);            } catch (ExecutionException e) {                logger.error("Future task execute failed!", e);            } catch (FutureTaskNotRunYetException e) {                logger.error("Future task has not run yet!", e);            } catch (FutureTaskNotCompleted e) {                logger.error("Future task has not completed!", e);            }        }        return t;    }
public static void launderThrowable(Throwable t) {        if (t instanceof RuntimeException) {            throw (RuntimeException) t;        } else if (t instanceof Error) {            throw (Error) t;        } else {            throw new IllegalStateException("Not unchecked!", t);        }    }
public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) {        if (this.cmd2processors.containsKey(cmdCode)) {            logger                .warn(                    "Processor for cmd={} is already registered, the processor is {}, and changed to {}",                    cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass()                        .getName());        }        this.cmd2processors.put(cmdCode, processor);    }
public void registerDefaultProcessor(RemotingProcessor<?> processor) {        if (this.defaultProcessor == null) {            this.defaultProcessor = processor;        } else {            throw new IllegalStateException("The defaultProcessor has already been registered: "                                            + this.defaultProcessor.getClass());        }    }
public RemotingProcessor<?> getProcessor(CommandCode cmdCode) {        RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode);        if (processor != null) {            return processor;        }        return this.defaultProcessor;    }
private Url tryGet(String url) {        SoftReference<Url> softRef = Url.parsedUrls.get(url);        return (null == softRef) ? null : softRef.get();    }
protected ProtocolCode decodeProtocolCode(ByteBuf in) {        if (in.readableBytes() >= protocolCodeLength) {            byte[] protocolCodeBytes = new byte[protocolCodeLength];            in.readBytes(protocolCodeBytes);            return ProtocolCode.fromBytes(protocolCodeBytes);        }        return null;    }
@Override    public Map<String, List<Connection>> getAll() {        Map<String, List<Connection>> allConnections = new HashMap<String, List<Connection>>();        Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iterator = this            .getConnPools().entrySet().iterator();        while (iterator.hasNext()) {            Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iterator.next();            ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger);            if (null != pool) {                allConnections.put(entry.getKey(), pool.getAll());            }        }        return allConnections;    }
@Override    public void removeAll() {        if (null == this.connTasks || this.connTasks.isEmpty()) {            return;        }        if (null != this.connTasks && !this.connTasks.isEmpty()) {            Iterator<String> iter = this.connTasks.keySet().iterator();            while (iter.hasNext()) {                String poolKey = iter.next();                this.removeTask(poolKey);                iter.remove();            }            logger.warn("All connection pool and connections have been removed!");        }    }
@Override    public void scan() {        if (null != this.connTasks && !this.connTasks.isEmpty()) {            Iterator<String> iter = this.connTasks.keySet().iterator();            while (iter.hasNext()) {                String poolKey = iter.next();                ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey));                if (null != pool) {                    pool.scan();                    if (pool.isEmpty()) {                        if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) {                            iter.remove();                            logger.warn("Remove expired pool task of poolKey {} which is empty.",                                poolKey);                        }                    }                }            }        }    }
@Override    public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException {        // get and create a connection pool with initialized connections.        ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(),            new ConnectionPoolCall(url));        if (null != pool) {            return pool.get();        } else {            logger.error("[NOTIFYME] bug detected! pool here must not be null!");            return null;        }    }
@Override    public void createConnectionAndHealIfNeed(Url url) throws InterruptedException,                                                      RemotingException {        // get and create a connection pool with initialized connections.        ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(),            new ConnectionPoolCall(url));        if (null != pool) {            healIfNeed(pool, url);        } else {            logger.error("[NOTIFYME] bug detected! pool here must not be null!");        }    }
private ConnectionPool getConnectionPoolAndCreateIfAbsent(String poolKey,                                                              Callable<ConnectionPool> callable)                                                                                                throws RemotingException,                                                                                                InterruptedException {        RunStateRecordedFutureTask<ConnectionPool> initialTask = null;        ConnectionPool pool = null;        int retry = DEFAULT_RETRY_TIMES;        int timesOfResultNull = 0;        int timesOfInterrupt = 0;        for (int i = 0; (i < retry) && (pool == null); ++i) {            initialTask = this.connTasks.get(poolKey);            if (null == initialTask) {                initialTask = new RunStateRecordedFutureTask<ConnectionPool>(callable);                initialTask = this.connTasks.putIfAbsent(poolKey, initialTask);                if (null == initialTask) {                    initialTask = this.connTasks.get(poolKey);                    initialTask.run();                }            }            try {                pool = initialTask.get();                if (null == pool) {                    if (i + 1 < retry) {                        timesOfResultNull++;                        continue;                    }                    this.connTasks.remove(poolKey);                    String errMsg = "Get future task result null for poolKey [" + poolKey                                    + "] after [" + (timesOfResultNull + 1) + "] times try.";                    throw new RemotingException(errMsg);                }            } catch (InterruptedException e) {                if (i + 1 < retry) {                    timesOfInterrupt++;                    continue;// retry if interrupted                }                this.connTasks.remove(poolKey);                logger                    .warn(                        "Future task of poolKey {} interrupted {} times. InterruptedException thrown and stop retry.",                        poolKey, (timesOfInterrupt + 1), e);                throw e;            } catch (ExecutionException e) {                // DO NOT retry if ExecutionException occurred                this.connTasks.remove(poolKey);                Throwable cause = e.getCause();                if (cause instanceof RemotingException) {                    throw (RemotingException) cause;                } else {                    FutureTaskUtil.launderThrowable(cause);                }            }        }        return pool;    }
private void removeTask(String poolKey) {        RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey);        if (null != task) {            ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger);            if (null != pool) {                pool.removeAllAndTryClose();            }        }    }
private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException,                                                         InterruptedException {        String poolKey = url.getUniqueKey();        // only when async creating connections done        // and the actual size of connections less than expected, the healing task can be run.        if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) {            FutureTask<Integer> task = this.healTasks.get(poolKey);            if (null == task) {                task = new FutureTask<Integer>(new HealConnectionCall(url, pool));                task = this.healTasks.putIfAbsent(poolKey, task);                if (null == task) {                    task = this.healTasks.get(poolKey);                    task.run();                }            }            try {                int numAfterHeal = task.get();                if (logger.isDebugEnabled()) {                    logger.debug("[NOTIFYME] - conn num after heal {}, expected {}, warmup {}",                        numAfterHeal, url.getConnNum(), url.isConnWarmup());                }            } catch (InterruptedException e) {                this.healTasks.remove(poolKey);                throw e;            } catch (ExecutionException e) {                this.healTasks.remove(poolKey);                Throwable cause = e.getCause();                if (cause instanceof RemotingException) {                    throw (RemotingException) cause;                } else {                    FutureTaskUtil.launderThrowable(cause);                }            }            // heal task is one-off, remove from cache directly after run            this.healTasks.remove(poolKey);        }    }
private void doCreate(final Url url, final ConnectionPool pool, final String taskName,                          final int syncCreateNumWhenNotWarmup) throws RemotingException {        final int actualNum = pool.size();        final int expectNum = url.getConnNum();        if (actualNum < expectNum) {            if (logger.isDebugEnabled()) {                logger.debug("actual num {}, expect num {}, task name {}", actualNum, expectNum,                    taskName);            }            if (url.isConnWarmup()) {                for (int i = actualNum; i < expectNum; ++i) {                    Connection connection = create(url);                    pool.add(connection);                }            } else {                if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) {                    throw new IllegalArgumentException(                        "sync create number when not warmup should be [0," + url.getConnNum() + "]");                }                // create connection in sync way                if (syncCreateNumWhenNotWarmup > 0) {                    for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) {                        Connection connection = create(url);                        pool.add(connection);                    }                    if (syncCreateNumWhenNotWarmup == url.getConnNum()) {                        return;                    }                }                // initialize executor in lazy way                initializeExecutor();                pool.markAsyncCreationStart();// mark the start of async                try {                    this.asyncCreateConnectionExecutor.execute(new Runnable() {                        @Override                        public void run() {                            try {                                for (int i = pool.size(); i < url.getConnNum(); ++i) {                                    Connection conn = null;                                    try {                                        conn = create(url);                                    } catch (RemotingException e) {                                        logger                                            .error(                                                "Exception occurred in async create connection thread for {}, taskName {}",                                                url.getUniqueKey(), taskName, e);                                    }                                    pool.add(conn);                                }                            } finally {                                pool.markAsyncCreationDone();// mark the end of async                            }                        }                    });                } catch (RejectedExecutionException e) {                    pool.markAsyncCreationDone();// mark the end of async when reject                    throw e;                }            } // end of NOT warm up        } // end of if    }
private void initializeExecutor() {        if (!this.executorInitialized) {            this.executorInitialized = true;            this.asyncCreateConnectionExecutor = new ThreadPoolExecutor(minPoolSize, maxPoolSize,                keepAliveTime, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(queueSize),                new NamedThreadFactory("Bolt-conn-warmup-executor", true));        }    }
public void shutdown() {        this.connectionManager.removeAll();        logger.warn("Close all connections from client side!");        this.taskScanner.shutdown();        logger.warn("Rpc client shutdown!");        if (reconnectManager != null) {            reconnectManager.stop();        }        if (connectionMonitor != null) {            connectionMonitor.destroy();        }    }
public void oneway(final String addr, final Object request) throws RemotingException,                                                               InterruptedException {        this.rpcRemoting.oneway(addr, request, null);    }
public void oneway(final Connection conn, final Object request) throws RemotingException {        this.rpcRemoting.oneway(conn, request, null);    }
public void oneway(final Connection conn, final Object request,                       final InvokeContext invokeContext) throws RemotingException {        this.rpcRemoting.oneway(conn, request, invokeContext);    }
public Object invokeSync(final String addr, final Object request, final int timeoutMillis)                                                                                              throws RemotingException,                                                                                              InterruptedException {        return this.rpcRemoting.invokeSync(addr, request, null, timeoutMillis);    }
public Object invokeSync(final String addr, final Object request,                             final InvokeContext invokeContext, final int timeoutMillis)                                                                                        throws RemotingException,                                                                                        InterruptedException {        return this.rpcRemoting.invokeSync(addr, request, invokeContext, timeoutMillis);    }
public Object invokeSync(final Url url, final Object request, final int timeoutMillis)                                                                                          throws RemotingException,                                                                                          InterruptedException {        return this.invokeSync(url, request, null, timeoutMillis);    }
public Object invokeSync(final Url url, final Object request,                             final InvokeContext invokeContext, final int timeoutMillis)                                                                                        throws RemotingException,                                                                                        InterruptedException {        return this.rpcRemoting.invokeSync(url, request, invokeContext, timeoutMillis);    }
public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis)                                                                                                  throws RemotingException,                                                                                                  InterruptedException {        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);    }
public Object invokeSync(final Connection conn, final Object request,                             final InvokeContext invokeContext, final int timeoutMillis)                                                                                        throws RemotingException,                                                                                        InterruptedException {        return this.rpcRemoting.invokeSync(conn, request, invokeContext, timeoutMillis);    }
public RpcResponseFuture invokeWithFuture(final Connection conn, final Object request,                                              int timeoutMillis) throws RemotingException {        return this.rpcRemoting.invokeWithFuture(conn, request, null, timeoutMillis);    }
public void invokeWithCallback(final Url url, final Object request,                                   final InvokeContext invokeContext,                                   final InvokeCallback invokeCallback, final int timeoutMillis)                                                                                                throws RemotingException,                                                                                                InterruptedException {        this.rpcRemoting.invokeWithCallback(url, request, invokeContext, invokeCallback,            timeoutMillis);    }
public void invokeWithCallback(final Connection conn, final Object request,                                   final InvokeCallback invokeCallback, final int timeoutMillis)                                                                                                throws RemotingException {        this.rpcRemoting.invokeWithCallback(conn, request, null, invokeCallback, timeoutMillis);    }
public void invokeWithCallback(final Connection conn, final Object request,                                   final InvokeContext invokeContext,                                   final InvokeCallback invokeCallback, final int timeoutMillis)                                                                                                throws RemotingException {        this.rpcRemoting.invokeWithCallback(conn, request, invokeContext, invokeCallback,            timeoutMillis);    }
public Connection createStandaloneConnection(String ip, int port, int connectTimeout)                                                                                         throws RemotingException {        return this.connectionManager.create(ip, port, connectTimeout);    }
public Connection createStandaloneConnection(String addr, int connectTimeout)                                                                                 throws RemotingException {        return this.connectionManager.create(addr, connectTimeout);    }
public Connection getConnection(String addr, int connectTimeout) throws RemotingException,                                                                    InterruptedException {        Url url = this.addressParser.parse(addr);        return this.getConnection(url, connectTimeout);    }
public Connection getConnection(Url url, int connectTimeout) throws RemotingException,                                                                InterruptedException {        url.setConnectTimeout(connectTimeout);        return this.connectionManager.getAndCreateIfAbsent(url);    }
public boolean checkConnection(String addr) {        Url url = this.addressParser.parse(addr);        Connection conn = this.connectionManager.get(url.getUniqueKey());        try {            this.connectionManager.check(conn);        } catch (Exception e) {            return false;        }        return true;    }
public void closeConnection(String addr) {        Url url = this.addressParser.parse(addr);        this.connectionManager.remove(url.getUniqueKey());    }
public void enableConnHeartbeat(String addr) {        Url url = this.addressParser.parse(addr);        this.enableConnHeartbeat(url);    }
public void enableConnHeartbeat(Url url) {        if (null != url) {            this.connectionManager.enableHeartbeat(this.connectionManager.get(url.getUniqueKey()));        }    }
public void disableConnHeartbeat(String addr) {        Url url = this.addressParser.parse(addr);        this.disableConnHeartbeat(url);    }
public void disableConnHeartbeat(Url url) {        if (null != url) {            this.connectionManager.disableHeartbeat(this.connectionManager.get(url.getUniqueKey()));        }    }
private void init() {        this.channel.attr(HEARTBEAT_COUNT).set(new Integer(0));        this.channel.attr(PROTOCOL).set(this.protocolCode);        this.channel.attr(VERSION).set(this.version);        this.channel.attr(HEARTBEAT_SWITCH).set(true);    }
public void onClose() {        Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator();        while (iter.hasNext()) {            Entry<Integer, InvokeFuture> entry = iter.next();            iter.remove();            InvokeFuture future = entry.getValue();            if (future != null) {                future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress()));                future.cancelTimeout();                future.tryAsyncExecuteInvokeCallbackAbnormally();            }        }    }
public void close() {        if (closed.compareAndSet(false, true)) {            try {                if (this.getChannel() != null) {                    this.getChannel().close().addListener(new ChannelFutureListener() {                        @Override                        public void operationComplete(ChannelFuture future) throws Exception {                            if (logger.isInfoEnabled()) {                                logger                                    .info(                                        "Close the connection to remote address={}, result={}, cause={}",                                        RemotingUtil.parseRemoteAddress(Connection.this                                            .getChannel()), future.isSuccess(), future.cause());                            }                        }                    });                }            } catch (Exception e) {                logger.warn("Exception caught when closing connection {}",                    RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e);            }        }    }
public Object setAttributeIfAbsent(String key, Object value) {        return attributes.putIfAbsent(key, value);    }
@Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        if (msg instanceof ByteBuf) {            RecyclableArrayList out = RecyclableArrayList.newInstance();            try {                ByteBuf data = (ByteBuf) msg;                first = cumulation == null;                if (first) {                    cumulation = data;                } else {                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);                }                callDecode(ctx, cumulation, out);            } catch (DecoderException e) {                throw e;            } catch (Throwable t) {                throw new DecoderException(t);            } finally {                if (cumulation != null && !cumulation.isReadable()) {                    numReads = 0;                    cumulation.release();                    cumulation = null;                } else if (++numReads >= discardAfterReads) {                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.                    // See https://github.com/netty/netty/issues/4275                    numReads = 0;                    discardSomeReadBytes();                }                int size = out.size();                if (size == 0) {                    decodeWasNull = true;                } else if (size == 1) {                    ctx.fireChannelRead(out.get(0));                } else {                    ArrayList<Object> ret = new ArrayList<Object>(size);                    for (int i = 0; i < size; i++) {                        ret.add(out.get(i));                    }                    ctx.fireChannelRead(ret);                }                out.recycle();            }        } else {            ctx.fireChannelRead(msg);        }    }
protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {        try {            while (in.isReadable()) {                int outSize = out.size();                int oldInputLength = in.readableBytes();                decode(ctx, in, out);                // Check if this handler was removed before continuing the loop.                // If it was removed, it is not safe to continue to operate on the buffer.                //                // See https://github.com/netty/netty/issues/1664                if (ctx.isRemoved()) {                    break;                }                if (outSize == out.size()) {                    if (oldInputLength == in.readableBytes()) {                        break;                    } else {                        continue;                    }                }                if (oldInputLength == in.readableBytes()) {                    throw new DecoderException(                        StringUtil.simpleClassName(getClass())                                + ".decode() did not read anything but decoded a message.");                }                if (isSingleDecode()) {                    break;                }            }        } catch (DecoderException e) {            throw e;        } catch (Throwable cause) {            throw new DecoderException(cause);        }    }
public static void registerUserProcessor(UserProcessor<?> processor,                                             ConcurrentHashMap<String, UserProcessor<?>> userProcessors) {        if (null == processor) {            throw new RuntimeException("User processor should not be null!");        }        if (processor instanceof MultiInterestUserProcessor) {            registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors);        } else {            if (StringUtils.isBlank(processor.interest())) {                throw new RuntimeException("Processor interest should not be blank!");            }            UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(),                processor);            if (preProcessor != null) {                String errMsg = "Processor with interest key ["                                + processor.interest()                                + "] has already been registered to rpc server, can not register again!";                throw new RuntimeException(errMsg);            }        }    }
private static void registerUserProcessor(MultiInterestUserProcessor<?> processor,                                              ConcurrentHashMap<String, UserProcessor<?>> userProcessors) {        if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) {            throw new RuntimeException("Processor interest should not be blank!");        }        for (String interest : processor.multiInterest()) {            UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor);            if (preProcessor != null) {                String errMsg = "Processor with interest key ["                                + interest                                + "] has already been registered to rpc server, can not register again!";                throw new RuntimeException(errMsg);            }        }    }
public void sendResponseIfNecessary(final RemotingContext ctx, byte type,                                        final RemotingCommand response) {        final int id = response.getId();        if (type != RpcCommandType.REQUEST_ONEWAY) {            RemotingCommand serializedResponse = response;            try {                response.serialize();            } catch (SerializationException e) {                String errMsg = "SerializationException occurred when sendResponseIfNecessary in RpcRequestProcessor, id="                                + id;                logger.error(errMsg, e);                serializedResponse = this.getCommandFactory().createExceptionResponse(id,                    ResponseStatus.SERVER_SERIAL_EXCEPTION, e);                try {                    serializedResponse.serialize();// serialize again for exception response                } catch (SerializationException e1) {                    // should not happen                    logger.error("serialize SerializationException response failed!");                }            } catch (Throwable t) {                String errMsg = "Serialize RpcResponseCommand failed when sendResponseIfNecessary in RpcRequestProcessor, id="                                + id;                logger.error(errMsg, t);                serializedResponse = this.getCommandFactory()                    .createExceptionResponse(id, t, errMsg);            }            ctx.writeAndFlush(serializedResponse).addListener(new ChannelFutureListener() {                @Override                public void operationComplete(ChannelFuture future) throws Exception {                    if (logger.isDebugEnabled()) {                        logger.debug("Rpc response sent! requestId="                                     + id                                     + ". The address is "                                     + RemotingUtil.parseRemoteAddress(ctx.getChannelContext()                                         .channel()));                    }                    if (!future.isSuccess()) {                        logger.error(                            "Rpc response send failed! id="                                    + id                                    + ". The address is "                                    + RemotingUtil.parseRemoteAddress(ctx.getChannelContext()                                        .channel()), future.cause());                    }                }            });        } else {            if (logger.isDebugEnabled()) {                logger.debug("Oneway rpc request received, do not send response, id=" + id                             + ", the address is "                             + RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()));            }        }    }
private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) {        final int id = cmd.getId();        final byte type = cmd.getType();        // processor here must not be null, for it have been checked before        UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass());        if (processor instanceof AsyncUserProcessor) {            try {                processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()),                    new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject());            } catch (RejectedExecutionException e) {                logger                    .warn("RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor");                sendResponseIfNecessary(ctx, type, this.getCommandFactory()                    .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY));            } catch (Throwable t) {                String errMsg = "AYSNC process rpc request failed in RpcRequestProcessor, id=" + id;                logger.error(errMsg, t);                sendResponseIfNecessary(ctx, type, this.getCommandFactory()                    .createExceptionResponse(id, t, errMsg));            }        } else {            try {                Object responseObject = processor                    .handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()),                        cmd.getRequestObject());                sendResponseIfNecessary(ctx, type,                    this.getCommandFactory().createResponse(responseObject, cmd));            } catch (RejectedExecutionException e) {                logger                    .warn("RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor");                sendResponseIfNecessary(ctx, type, this.getCommandFactory()                    .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY));            } catch (Throwable t) {                String errMsg = "SYNC process rpc request failed in RpcRequestProcessor, id=" + id;                logger.error(errMsg, t);                sendResponseIfNecessary(ctx, type, this.getCommandFactory()                    .createExceptionResponse(id, t, errMsg));            }        }    }
private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) {        boolean result;        try {            cmd.deserialize(level);            result = true;        } catch (DeserializationException e) {            logger                .error(                    "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}",                    cmd.getId(), RpcDeserializeLevel.valueOf(level), e);            sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory()                .createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e));            result = false;        } catch (Throwable t) {            String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id="                            + cmd.getId() + ", deserializeLevel=" + level;            logger.error(errMsg, t);            sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory()                .createExceptionResponse(cmd.getId(), t, errMsg));            result = false;        }        return result;    }
private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd,                                           long currentTimestamp) {        ctx.setArriveTimestamp(cmd.getArriveTime());        ctx.setTimeout(cmd.getTimeout());        ctx.setRpcCommandType(cmd.getType());        ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME,            currentTimestamp - cmd.getArriveTime());    }
private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) {        if (logger.isDebugEnabled()) {            logger                .debug(                    "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].",                    cmd.getId(), currentTimestamp, cmd.getArriveTime(),                    (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());        }        String remoteAddr = "UNKNOWN";        if (null != ctx) {            ChannelHandlerContext channelCtx = ctx.getChannelContext();            Channel channel = channelCtx.channel();            if (null != channel) {                remoteAddr = RemotingUtil.parseRemoteAddress(channel);            }        }        logger            .warn(                "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].",                cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());    }
private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) {        if (logger.isDebugEnabled()) {            logger.debug("Rpc request received! requestId={}, from {}", cmd.getId(),                RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()));            logger.debug(                "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.",                cmd.getId(), currentTimestamp, cmd.getArriveTime(),                (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());        }    }
@Override    public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor)                                                                                    throws Exception {        ProcessTask task = new ProcessTask(ctx, msg);        if (this.getExecutor() != null) {            this.getExecutor().execute(task);        } else {            defaultExecutor.execute(task);        }    }
protected RemotingCommand invokeSync(final Connection conn, final RemotingCommand request,                                         final int timeoutMillis) throws RemotingException,                                                                 InterruptedException {        final InvokeFuture future = createInvokeFuture(request, request.getInvokeContext());        conn.addInvokeFuture(future);        final int requestId = request.getId();        try {            conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() {                @Override                public void operationComplete(ChannelFuture f) throws Exception {                    if (!f.isSuccess()) {                        conn.removeInvokeFuture(requestId);                        future.putResponse(commandFactory.createSendFailedResponse(                            conn.getRemoteAddress(), f.cause()));                        logger.error("Invoke send failed, id={}", requestId, f.cause());                    }                }            });        } catch (Exception e) {            conn.removeInvokeFuture(requestId);            future.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e));            logger.error("Exception caught when sending invocation, id={}", requestId, e);        }        RemotingCommand response = future.waitResponse(timeoutMillis);        if (response == null) {            conn.removeInvokeFuture(requestId);            response = this.commandFactory.createTimeoutResponse(conn.getRemoteAddress());            logger.warn("Wait response, request id={} timeout!", requestId);        }        return response;    }
protected void invokeWithCallback(final Connection conn, final RemotingCommand request,                                      final InvokeCallback invokeCallback, final int timeoutMillis) {        final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(),            invokeCallback);        conn.addInvokeFuture(future);        final int requestId = request.getId();        try {            Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() {                @Override                public void run(Timeout timeout) throws Exception {                    InvokeFuture future = conn.removeInvokeFuture(requestId);                    if (future != null) {                        future.putResponse(commandFactory.createTimeoutResponse(conn                            .getRemoteAddress()));                        future.tryAsyncExecuteInvokeCallbackAbnormally();                    }                }            }, timeoutMillis, TimeUnit.MILLISECONDS);            future.addTimeout(timeout);            conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() {                @Override                public void operationComplete(ChannelFuture cf) throws Exception {                    if (!cf.isSuccess()) {                        InvokeFuture f = conn.removeInvokeFuture(requestId);                        if (f != null) {                            f.cancelTimeout();                            f.putResponse(commandFactory.createSendFailedResponse(                                conn.getRemoteAddress(), cf.cause()));                            f.tryAsyncExecuteInvokeCallbackAbnormally();                        }                        logger.error("Invoke send failed. The address is {}",                            RemotingUtil.parseRemoteAddress(conn.getChannel()), cf.cause());                    }                }            });        } catch (Exception e) {            InvokeFuture f = conn.removeInvokeFuture(requestId);            if (f != null) {                f.cancelTimeout();                f.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e));                f.tryAsyncExecuteInvokeCallbackAbnormally();            }            logger.error("Exception caught when sending invocation. The address is {}",                RemotingUtil.parseRemoteAddress(conn.getChannel()), e);        }    }
protected void oneway(final Connection conn, final RemotingCommand request) {        try {            conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() {                @Override                public void operationComplete(ChannelFuture f) throws Exception {                    if (!f.isSuccess()) {                        logger.error("Invoke send failed. The address is {}",                            RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause());                    }                }            });        } catch (Exception e) {            if (null == conn) {                logger.error("Conn is null");            } else {                logger.error("Exception caught when sending invocation. The address is {}",                    RemotingUtil.parseRemoteAddress(conn.getChannel()), e);            }        }    }
public static ProtocolSwitch create(int value) {        ProtocolSwitch status = new ProtocolSwitch();        status.setBs(toBitSet(value));        return status;    }
public static ProtocolSwitch create(int[] index) {        ProtocolSwitch status = new ProtocolSwitch();        for (int i = 0; i < index.length; ++i) {            status.turnOn(index[i]);        }        return status;    }
public static byte toByte(BitSet bs) {        int value = 0;        for (int i = 0; i < bs.length(); ++i) {            if (bs.get(i)) {                value += 1 << i;            }        }        if (bs.length() > 7) {            throw new IllegalArgumentException("The byte value " + value                                               + " generated according to bit set " + bs                                               + " is out of range, should be limited between ["                                               + Byte.MIN_VALUE + "] to [" + Byte.MAX_VALUE + "]");        }        return (byte) value;    }
public static BitSet toBitSet(int value) {        if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) {            throw new IllegalArgumentException(                "The value " + value + " is out of byte range, should be limited between ["                        + Byte.MIN_VALUE + "] to [" + Byte.MAX_VALUE + "]");        }        BitSet bs = new BitSet();        int index = 0;        while (value != 0) {            if (value % 2 != 0) {                bs.set(index);            }            ++index;            value = (byte) (value >> 1);        }        return bs;    }
protected Connection getConnectionAndInitInvokeContext(Url url, InvokeContext invokeContext)                                                                                                throws RemotingException,                                                                                                InterruptedException {        long start = System.currentTimeMillis();        Connection conn;        try {            conn = this.connectionManager.getAndCreateIfAbsent(url);        } finally {            if (null != invokeContext) {                invokeContext.putIfAbsent(InvokeContext.CLIENT_CONN_CREATETIME,                    (System.currentTimeMillis() - start));            }        }        return conn;    }
public void addReconnectTask(Url url) {        ReconnectTask task = new ReconnectTask();        task.url = url;        tasks.add(task);    }
public void stop() {        if (!this.started) {            return;        }        this.started = false;        healConnectionThreads.interrupt();        this.tasks.clear();        this.canceled.clear();    }
public void oneway(final String addr, final Object request, final InvokeContext invokeContext)                                                                                                  throws RemotingException,                                                                                                  InterruptedException {        Url url = this.addressParser.parse(addr);        this.oneway(url, request, invokeContext);    }
public void oneway(final Connection conn, final Object request,                       final InvokeContext invokeContext) throws RemotingException {        RequestCommand requestCommand = (RequestCommand) toRemotingCommand(request, conn,            invokeContext, -1);        requestCommand.setType(RpcCommandType.REQUEST_ONEWAY);        preProcessInvokeContext(invokeContext, requestCommand, conn);        super.oneway(conn, requestCommand);    }
public Object invokeSync(final String addr, final Object request,                             final InvokeContext invokeContext, final int timeoutMillis)                                                                                        throws RemotingException,                                                                                        InterruptedException {        Url url = this.addressParser.parse(addr);        return this.invokeSync(url, request, invokeContext, timeoutMillis);    }
public Object invokeSync(final Connection conn, final Object request,                             final InvokeContext invokeContext, final int timeoutMillis)                                                                                        throws RemotingException,                                                                                        InterruptedException {        RemotingCommand requestCommand = toRemotingCommand(request, conn, invokeContext,            timeoutMillis);        preProcessInvokeContext(invokeContext, requestCommand, conn);        ResponseCommand responseCommand = (ResponseCommand) super.invokeSync(conn, requestCommand,            timeoutMillis);        responseCommand.setInvokeContext(invokeContext);        Object responseObject = RpcResponseResolver.resolveResponseObject(responseCommand,            RemotingUtil.parseRemoteAddress(conn.getChannel()));        return responseObject;    }
public RpcResponseFuture invokeWithFuture(final Connection conn, final Object request,                                              final InvokeContext invokeContext,                                              final int timeoutMillis) throws RemotingException {        RemotingCommand requestCommand = toRemotingCommand(request, conn, invokeContext,            timeoutMillis);        preProcessInvokeContext(invokeContext, requestCommand, conn);        InvokeFuture future = super.invokeWithFuture(conn, requestCommand, timeoutMillis);        return new RpcResponseFuture(RemotingUtil.parseRemoteAddress(conn.getChannel()), future);    }
public void invokeWithCallback(String addr, Object request, final InvokeContext invokeContext,                                   InvokeCallback invokeCallback, int timeoutMillis)                                                                                    throws RemotingException,                                                                                    InterruptedException {        Url url = this.addressParser.parse(addr);        this.invokeWithCallback(url, request, invokeContext, invokeCallback, timeoutMillis);    }
public void invokeWithCallback(final Connection conn, final Object request,                                   final InvokeContext invokeContext,                                   final InvokeCallback invokeCallback, final int timeoutMillis)                                                                                                throws RemotingException {        RemotingCommand requestCommand = toRemotingCommand(request, conn, invokeContext,            timeoutMillis);        preProcessInvokeContext(invokeContext, requestCommand, conn);        super.invokeWithCallback(conn, requestCommand, invokeCallback, timeoutMillis);    }
protected RemotingCommand toRemotingCommand(Object request, Connection conn,                                                InvokeContext invokeContext, int timeoutMillis)                                                                                               throws SerializationException {        RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request);        if (null != invokeContext) {            // set client custom serializer for request command if not null            Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER);            if (null != clientCustomSerializer) {                try {                    command.setSerializer((Byte) clientCustomSerializer);                } catch (ClassCastException e) {                    throw new IllegalArgumentException(                        "Illegal custom serializer [" + clientCustomSerializer                                + "], the type of value should be [byte], but now is ["                                + clientCustomSerializer.getClass().getName() + "].");                }            }            // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH`            Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH,                ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE);            if (null != crcSwitch && crcSwitch) {                command.setProtocolSwitch(ProtocolSwitch                    .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX }));            }        } else {            // enable crc by default, if there is no invoke context.            command.setProtocolSwitch(ProtocolSwitch                .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX }));        }        command.setTimeout(timeoutMillis);        command.setRequestClass(request.getClass().getName());        command.setInvokeContext(invokeContext);        command.serialize();        logDebugInfo(command);        return command;    }
@Override    public Map<String, List<Connection>> filter(List<Connection> connections) {        List<Connection> serviceOnConnections = new ArrayList<Connection>();        List<Connection> serviceOffConnections = new ArrayList<Connection>();        Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>();        for (Connection connection : connections) {            String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS);            if (serviceStatus != null) {                if (connection.isInvokeFutureMapFinish()                    && !freshSelectConnections.containsValue(connection)) {                    serviceOffConnections.add(connection);                }            } else {                serviceOnConnections.add(connection);            }        }        filteredConnections.put(Configs.CONN_SERVICE_STATUS_ON, serviceOnConnections);        filteredConnections.put(Configs.CONN_SERVICE_STATUS_OFF, serviceOffConnections);        return filteredConnections;    }
@Override    public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) {        try {            if (null != connPools && !connPools.isEmpty()) {                Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools                    .entrySet().iterator();                while (iter.hasNext()) {                    Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter                        .next();                    String poolKey = entry.getKey();                    ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(),                        logger);                    List<Connection> connections = pool.getAll();                    Map<String, List<Connection>> filteredConnectons = this.filter(connections);                    List<Connection> serviceOnConnections = filteredConnectons                        .get(Configs.CONN_SERVICE_STATUS_ON);                    List<Connection> serviceOffConnections = filteredConnectons                        .get(Configs.CONN_SERVICE_STATUS_OFF);                    if (serviceOnConnections.size() > CONNECTION_THRESHOLD) {                        Connection freshSelectConnect = serviceOnConnections.get(random                            .nextInt(serviceOnConnections.size()));                        freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS,                            Configs.CONN_SERVICE_STATUS_OFF);                        Connection lastSelectConnect = freshSelectConnections.remove(poolKey);                        freshSelectConnections.put(poolKey, freshSelectConnect);                        closeFreshSelectConnections(lastSelectConnect, serviceOffConnections);                    } else {                        if (freshSelectConnections.containsKey(poolKey)) {                            Connection lastSelectConnect = freshSelectConnections.remove(poolKey);                            closeFreshSelectConnections(lastSelectConnect, serviceOffConnections);                        }                        if (logger.isInfoEnabled()) {                            logger                                .info(                                    "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].",                                    serviceOnConnections.size(), CONNECTION_THRESHOLD);                        }                    }                    for (Connection offConn : serviceOffConnections) {                        if (offConn.isFine()) {                            offConn.close();                        }                    }                }            }        } catch (Exception e) {            logger.error("ScheduledDisconnectStrategy monitor error", e);        }    }
private void closeFreshSelectConnections(Connection lastSelectConnect,                                             List<Connection> serviceOffConnections)                                                                                    throws InterruptedException {        if (null != lastSelectConnect) {            if (lastSelectConnect.isInvokeFutureMapFinish()) {                serviceOffConnections.add(lastSelectConnect);            } else {                Thread.sleep(RETRY_DETECT_PERIOD);                if (lastSelectConnect.isInvokeFutureMapFinish()) {                    serviceOffConnections.add(lastSelectConnect);                } else {                    if (logger.isInfoEnabled()) {                        logger.info("Address={} won't close at this schedule turn",                            RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel()));                    }                }            }        }    }
private void handle(final RemotingContext ctx, final Object msg) {        try {            if (msg instanceof List) {                final Runnable handleTask = new Runnable() {                    @Override                    public void run() {                        if (logger.isDebugEnabled()) {                            logger.debug("Batch message! size={}", ((List<?>) msg).size());                        }                        for (final Object m : (List<?>) msg) {                            RpcCommandHandler.this.process(ctx, m);                        }                    }                };                if (RpcConfigManager.dispatch_msg_list_in_default_executor()) {                    // If msg is list ,then the batch submission to biz threadpool can save io thread.                    // See com.alipay.remoting.decoder.ProtocolDecoder                    processorManager.getDefaultExecutor().execute(handleTask);                } else {                    handleTask.run();                }            } else {                process(ctx, msg);            }        } catch (final Throwable t) {            processException(ctx, msg, t);        }    }
private void processExceptionForSingleCommand(RemotingContext ctx, Object msg, Throwable t) {        final int id = ((RpcCommand) msg).getId();        final String emsg = "Exception caught when processing "                            + ((msg instanceof RequestCommand) ? "request, id=" : "response, id=");        logger.warn(emsg + id, t);        if (msg instanceof RequestCommand) {            final RequestCommand cmd = (RequestCommand) msg;            if (cmd.getType() != RpcCommandType.REQUEST_ONEWAY) {                if (t instanceof RejectedExecutionException) {                    final ResponseCommand response = this.commandFactory.createExceptionResponse(                        id, ResponseStatus.SERVER_THREADPOOL_BUSY);                    // RejectedExecutionException here assures no response has been sent back                    // Other exceptions should be processed where exception was caught, because here we don't known whether ack had been sent back.                    ctx.getChannelContext().writeAndFlush(response)                        .addListener(new ChannelFutureListener() {                            @Override                            public void operationComplete(ChannelFuture future) throws Exception {                                if (future.isSuccess()) {                                    if (logger.isInfoEnabled()) {                                        logger                                            .info(                                                "Write back exception response done, requestId={}, status={}",                                                id, response.getResponseStatus());                                    }                                } else {                                    logger.error(                                        "Write back exception response failed, requestId={}", id,                                        future.cause());                                }                            }                        });                }            }        }    }
public static boolean getBool(String key, String defaultValue) {        return Boolean.parseBoolean(System.getProperty(key, defaultValue));    }
public void deserialize(long mask) throws DeserializationException {        if (mask <= RpcDeserializeLevel.DESERIALIZE_CLAZZ) {            this.deserializeClazz();        } else if (mask <= RpcDeserializeLevel.DESERIALIZE_HEADER) {            this.deserializeClazz();            this.deserializeHeader(this.getInvokeContext());        } else if (mask <= RpcDeserializeLevel.DESERIALIZE_ALL) {            this.deserialize();        }    }
public CustomSerializer getCustomSerializer() {        if (this.customSerializer != null) {            return customSerializer;        }        if (this.requestClass != null) {            this.customSerializer = CustomSerializerManager.getCustomSerializer(this.requestClass);        }        if (this.customSerializer == null) {            this.customSerializer = CustomSerializerManager.getCustomSerializer(this.getCmdCode());        }        return this.customSerializer;    }
public void setConnectionEventListener(ConnectionEventListener listener) {        if (listener != null) {            this.eventListener = listener;            if (this.eventExecutor == null) {                this.eventExecutor = new ConnectionEventExecutor();            }        }    }
private void infoLog(String format, String addr) {        if (logger.isInfoEnabled()) {            if (StringUtils.isNotEmpty(addr)) {                logger.info(format, addr);            } else {                logger.info(format, "UNKNOWN-ADDR");            }        }    }
public boolean isRequestTimeout() {        if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY)            && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) {            return true;        }        return false;    }
public UserProcessor<?> getUserProcessor(String className) {        return StringUtils.isBlank(className) ? null : this.userProcessors.get(className);    }
private Connection randomGet(List<Connection> conns) {        if (null == conns || conns.isEmpty()) {            return null;        }        int size = conns.size();        int tries = 0;        Connection result = null;        while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) {            result = conns.get(this.random.nextInt(size));        }        if (result != null && !result.isFine()) {            result = null;        }        return result;    }
public CustomSerializer getCustomSerializer() {        if (this.customSerializer != null) {            return customSerializer;        }        if (this.responseClass != null) {            this.customSerializer = CustomSerializerManager.getCustomSerializer(this.responseClass);        }        if (this.customSerializer == null) {            this.customSerializer = CustomSerializerManager.getCustomSerializer(this.getCmdCode());        }        return this.customSerializer;    }
@SuppressWarnings("unchecked")    public <T> T get(String key) {        return (T) this.context.get(key);    }
@SuppressWarnings("unchecked")    public <T> T get(String key, T defaultIfNotFound) {        return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound;    }
public String getProperty(String key) {        if (properties == null) {            return null;        }        return properties.getProperty(key);    }
public static final int crc32(byte[] array, int offset, int length) {        CRC32 crc32 = CRC_32_THREAD_LOCAL.get();        crc32.update(array, offset, length);        int ret = (int) crc32.getValue();        crc32.reset();        return ret;    }
public static Object resolveResponseObject(ResponseCommand responseCommand, String addr)                                                                                            throws RemotingException {        preProcess(responseCommand, addr);        if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) {            return toResponseObject(responseCommand);        } else {            String msg = String.format("Rpc invocation exception: %s, the address is %s, id=%s",                responseCommand.getResponseStatus(), addr, responseCommand.getId());            logger.warn(msg);            if (responseCommand.getCause() != null) {                throw new InvokeException(msg, responseCommand.getCause());            } else {                throw new InvokeException(msg + ", please check the server log for more.");            }        }    }
private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException {        RpcResponseCommand response = (RpcResponseCommand) responseCommand;        response.deserialize();        return response.getResponseObject();    }
private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException {        RpcResponseCommand resp = (RpcResponseCommand) responseCommand;        resp.deserialize();        Object ex = resp.getResponseObject();        if (ex != null && ex instanceof Throwable) {            return (Throwable) ex;        }        return null;    }
private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) {        RpcResponseCommand resp = (RpcResponseCommand) responseCommand;        if (StringUtils.isNotBlank(resp.getErrorMsg())) {            return String.format("%s, ServerErrorMsg:%s", clientErrMsg, resp.getErrorMsg());        } else {            return String.format("%s, ServerErrorMsg:null", clientErrMsg);        }    }
private RpcServerException createServerException(Throwable t, String errMsg) {        String formattedErrMsg = String.format(            "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s", t.getClass().getName(),            t.getMessage(), errMsg);        RpcServerException e = new RpcServerException(formattedErrMsg);        e.setStackTrace(t.getStackTrace());        return e;    }
public static void printConnectionTraceLog(Logger logger, String traceId,                                               InvokeContext invokeContext) {        String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP);        Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT);        String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP);        Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT);        StringBuilder logMsg = new StringBuilder();        logMsg.append(traceId).append(",");        logMsg.append(sourceIp).append(",");        logMsg.append(sourcePort).append(",");        logMsg.append(targetIp).append(",");        logMsg.append(targetPort);        if (logger.isInfoEnabled()) {            logger.info(logMsg.toString());        }    }
public static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {        return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory)            : new NioEventLoopGroup(nThreads, threadFactory);    }
public static void enableTriggeredMode(ServerBootstrap serverBootstrap) {        if (epollEnabled) {            if (ConfigManager.netty_epoll_lt_enabled()) {                serverBootstrap.childOption(EpollChannelOption.EPOLL_MODE,                    EpollMode.LEVEL_TRIGGERED);            } else {                serverBootstrap                    .childOption(EpollChannelOption.EPOLL_MODE, EpollMode.EDGE_TRIGGERED);            }        }    }
public void start() {        scheduledService.scheduleWithFixedDelay(new Runnable() {            @Override            public void run() {                for (Scannable scanned : scanList) {                    try {                        scanned.scan();                    } catch (Throwable t) {                        logger.error("Exception caught when scannings.", t);                    }                }            }        }, 10000, 10000, TimeUnit.MILLISECONDS);    }
public static String parseRemoteAddress(final Channel channel) {        if (null == channel) {            return StringUtils.EMPTY;        }        final SocketAddress remote = channel.remoteAddress();        return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY);    }
public static String parseLocalAddress(final Channel channel) {        if (null == channel) {            return StringUtils.EMPTY;        }        final SocketAddress local = channel.localAddress();        return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY);    }
public static String parseRemoteIP(final Channel channel) {        if (null == channel) {            return StringUtils.EMPTY;        }        final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress();        if (remote != null) {            return remote.getAddress().getHostAddress();        }        return StringUtils.EMPTY;    }
public static String parseRemoteHostName(final Channel channel) {        if (null == channel) {            return StringUtils.EMPTY;        }        final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress();        if (remote != null) {            return remote.getAddress().getHostName();        }        return StringUtils.EMPTY;    }
public static String parseLocalIP(final Channel channel) {        if (null == channel) {            return StringUtils.EMPTY;        }        final InetSocketAddress local = (InetSocketAddress) channel.localAddress();        if (local != null) {            return local.getAddress().getHostAddress();        }        return StringUtils.EMPTY;    }
public static int parseRemotePort(final Channel channel) {        if (null == channel) {            return -1;        }        final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress();        if (remote != null) {            return remote.getPort();        }        return -1;    }
public static int parseLocalPort(final Channel channel) {        if (null == channel) {            return -1;        }        final InetSocketAddress local = (InetSocketAddress) channel.localAddress();        if (local != null) {            return local.getPort();        }        return -1;    }
public static String parseSocketAddressToString(SocketAddress socketAddress) {        if (socketAddress != null) {            return doParse(socketAddress.toString().trim());        }        return StringUtils.EMPTY;    }
public static String parseSocketAddressToHostIp(SocketAddress socketAddress) {        final InetSocketAddress addrs = (InetSocketAddress) socketAddress;        if (addrs != null) {            InetAddress addr = addrs.getAddress();            if (null != addr) {                return addr.getHostAddress();            }        }        return StringUtils.EMPTY;    }
private static String doParse(String addr) {        if (StringUtils.isBlank(addr)) {            return StringUtils.EMPTY;        }        if (addr.charAt(0) == '/') {            return addr.substring(1);        } else {            int len = addr.length();            for (int i = 1; i < len; ++i) {                if (addr.charAt(i) == '/') {                    return addr.substring(i + 1);                }            }            return addr;        }    }
public void add(Connection connection) {        markAccess();        if (null == connection) {            return;        }        boolean res = this.conns.addIfAbsent(connection);        if (res) {            connection.increaseRef();        }    }
public void removeAndTryClose(Connection connection) {        if (null == connection) {            return;        }        boolean res = this.conns.remove(connection);        if (res) {            connection.decreaseRef();        }        if (connection.noRef()) {            connection.close();        }    }
public Connection get() {        markAccess();        if (null != this.conns) {            List<Connection> snapshot = new ArrayList<Connection>(this.conns);            if (snapshot.size() > 0) {                return this.strategy.select(snapshot);            } else {                return null;            }        } else {            return null;        }    }
public static void registerCustomSerializer(String className, CustomSerializer serializer) {        CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer);        if (prevSerializer != null) {            throw new RuntimeException("CustomSerializer has been registered for class: "                                       + className + ", the custom serializer is: "                                       + prevSerializer.getClass().getName());        }    }
public static CustomSerializer getCustomSerializer(String className) {        if (!classCustomSerializer.isEmpty()) {            return classCustomSerializer.get(className);        }        return null;    }
public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) {        CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer);        if (prevSerializer != null) {            throw new RuntimeException("CustomSerializer has been registered for command code: "                                       + code + ", the custom serializer is: "                                       + prevSerializer.getClass().getName());        }    }
public static CustomSerializer getCustomSerializer(CommandCode code) {        if (!commandCustomSerializer.isEmpty()) {            return commandCustomSerializer.get(code);        }        return null;    }
public void start() {        /** initial delay to execute schedule task, unit: ms */        long initialDelay = ConfigManager.conn_monitor_initial_delay();        /** period of schedule task, unit: ms*/        long period = ConfigManager.conn_monitor_period();        this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory(            "ConnectionMonitorThread", true), new ThreadPoolExecutor.AbortPolicy());        MonitorTask monitorTask = new MonitorTask();        this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS);    }
@Override    protected boolean doStop() {        if (null != this.channelFuture) {            this.channelFuture.channel().close();        }        if (this.switches().isOn(GlobalSwitch.SERVER_SYNC_STOP)) {            this.bossGroup.shutdownGracefully().awaitUninterruptibly();        } else {            this.bossGroup.shutdownGracefully();        }        if (this.switches().isOn(GlobalSwitch.SERVER_MANAGE_CONNECTION_SWITCH)            && null != this.connectionManager) {            this.connectionManager.removeAll();            logger.warn("Close all connections from server side!");        }        logger.warn("Rpc Server stopped!");        return true;    }
public void oneway(final String addr, final Object request, final InvokeContext invokeContext)                                                                                                  throws RemotingException,                                                                                                  InterruptedException {        check();        this.rpcRemoting.oneway(addr, request, invokeContext);    }
public void oneway(final Url url, final Object request) throws RemotingException,                                                           InterruptedException {        check();        this.rpcRemoting.oneway(url, request, null);    }
public void oneway(final Url url, final Object request, final InvokeContext invokeContext)                                                                                              throws RemotingException,                                                                                              InterruptedException {        check();        this.rpcRemoting.oneway(url, request, invokeContext);    }
public RpcResponseFuture invokeWithFuture(final String addr, final Object request,                                              final int timeoutMillis) throws RemotingException,                                                                      InterruptedException {        check();        return this.rpcRemoting.invokeWithFuture(addr, request, null, timeoutMillis);    }
public RpcResponseFuture invokeWithFuture(final String addr, final Object request,                                              final InvokeContext invokeContext,                                              final int timeoutMillis) throws RemotingException,                                                                      InterruptedException {        check();        return this.rpcRemoting.invokeWithFuture(addr, request, invokeContext, timeoutMillis);    }
public RpcResponseFuture invokeWithFuture(final Url url, final Object request,                                              final int timeoutMillis) throws RemotingException,                                                                      InterruptedException {        check();        return this.rpcRemoting.invokeWithFuture(url, request, null, timeoutMillis);    }
public RpcResponseFuture invokeWithFuture(final Url url, final Object request,                                              final InvokeContext invokeContext,                                              final int timeoutMillis) throws RemotingException,                                                                      InterruptedException {        check();        return this.rpcRemoting.invokeWithFuture(url, request, invokeContext, timeoutMillis);    }
public RpcResponseFuture invokeWithFuture(final Connection conn, final Object request,                                              final InvokeContext invokeContext,                                              final int timeoutMillis) throws RemotingException {        return this.rpcRemoting.invokeWithFuture(conn, request, invokeContext, timeoutMillis);    }
public void invokeWithCallback(final String addr, final Object request,                                   final InvokeCallback invokeCallback, final int timeoutMillis)                                                                                                throws RemotingException,                                                                                                InterruptedException {        check();        this.rpcRemoting.invokeWithCallback(addr, request, null, invokeCallback, timeoutMillis);    }
public boolean isConnected(String remoteAddr) {        Url url = this.rpcRemoting.addressParser.parse(remoteAddr);        return this.isConnected(url);    }
public boolean isConnected(Url url) {        Connection conn = this.rpcRemoting.connectionManager.get(url.getUniqueKey());        if (null != conn) {            return conn.isFine();        }        return false;    }
private void initWriteBufferWaterMark() {        int lowWaterMark = this.netty_buffer_low_watermark();        int highWaterMark = this.netty_buffer_high_watermark();        if (lowWaterMark > highWaterMark) {            throw new IllegalArgumentException(                String                    .format(                        "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)",                        highWaterMark, lowWaterMark));        } else {            logger.warn(                "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes",                lowWaterMark, highWaterMark);        }        this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(            lowWaterMark, highWaterMark));    }
public static boolean isValidUTF8( ByteBuffer data, int off ) {		int len = data.remaining();		if( len < off ) {			return false;		}		int state = 0;		for( int i = off; i < len; ++i ) {			state = utf8d[256 + ( state << 4 ) + utf8d[( 0xff & data.get( i ) )]];			if( state == 1 ) {				return false;			}		}		return true;	}
public static FramedataImpl1 get(Opcode opcode) {        if (opcode== null) {            throw new IllegalArgumentException("Supplied opcode cannot be null");        }        switch (opcode) {            case PING:                return new PingFrame();            case PONG:                return new PongFrame();            case TEXT:                return new TextFrame();            case BINARY:                return new BinaryFrame();            case CLOSING:                return new CloseFrame();            case CONTINUOUS:                return new ContinuousFrame();            default:                throw new IllegalArgumentException("Supplied opcode is invalid");        }    }
public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException {		if (ws == null) {			return false;		}		ByteBuffer buffer = ws.outQueue.peek();		WrappedByteChannel c = null;		if( buffer == null ) {			if( sockchannel instanceof WrappedByteChannel ) {				c = (WrappedByteChannel) sockchannel;				if( c.isNeedWrite() ) {					c.writeMore();				}			}		} else {			do {// FIXME writing as much as possible is unfair!!				/*int written = */sockchannel.write( buffer );				if( buffer.remaining() > 0 ) {					return false;				} else {					ws.outQueue.poll(); // Buffer finished. Remove it.					buffer = ws.outQueue.peek();				}			} while ( buffer != null );		}		if( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {//			ws.closeConnection();		}		return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite();	}
public void setCode(int code) {        this.code = code;        // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire        if (code == CloseFrame.TLS_ERROR) {            this.code = CloseFrame.NOCODE;            this.reason = "";        }        updatePayload();    }
private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException {        try {            payload.position( payload.position() + 2 );            reason = Charsetfunctions.stringUtf8( payload );        } catch ( IllegalArgumentException e ) {            throw new InvalidDataException( CloseFrame.NO_UTF8 );        } finally {            payload.position( mark );        }    }
private void updatePayload() {        byte[] by = Charsetfunctions.utf8Bytes(reason);        ByteBuffer buf = ByteBuffer.allocate(4);        buf.putInt(code);        buf.position(2);        ByteBuffer pay = ByteBuffer.allocate(2 + by.length);        pay.put(buf);        pay.put(by);        pay.rewind();        super.setPayload(pay);    }
private HandshakeState containsRequestedProtocol(String requestedProtocol) {		for( IProtocol knownProtocol : knownProtocols ) {			if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) {				protocol = knownProtocol;				log.trace("acceptHandshake - Matching protocol found: {}", protocol);				return HandshakeState.MATCHED;			}		}		return HandshakeState.NOT_MATCHED;	}
private TranslatedPayloadMetaData translateSingleFramePayloadLength(ByteBuffer buffer, Opcode optcode, int oldPayloadlength, int maxpacketsize, int oldRealpacketsize) throws InvalidFrameException, IncompleteException, LimitExceededException {        int payloadlength = oldPayloadlength,				realpacketsize = oldRealpacketsize;    	if( optcode == Opcode.PING || optcode == Opcode.PONG || optcode == Opcode.CLOSING ) {            log.trace( "Invalid frame: more than 125 octets" );            throw new InvalidFrameException( "more than 125 octets" );        }        if( payloadlength == 126 ) {            realpacketsize += 2; // additional length bytes            translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize);            byte[] sizebytes = new byte[3];            sizebytes[1] = buffer.get( /*1 + 1*/ );            sizebytes[2] = buffer.get( /*1 + 2*/ );            payloadlength = new BigInteger( sizebytes ).intValue();        } else {            realpacketsize += 8; // additional length bytes            translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize);            byte[] bytes = new byte[8];            for( int i = 0; i < 8; i++ ) {                bytes[i] = buffer.get( /*1 + i*/ );            }            long length = new BigInteger( bytes ).longValue();            translateSingleFrameCheckLengthLimit(length);            payloadlength = ( int ) length;        }        return new TranslatedPayloadMetaData(payloadlength, realpacketsize);    }
private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException {		if( length > Integer.MAX_VALUE ) {			log.trace("Limit exedeed: Payloadsize is to big...");			throw new LimitExceededException("Payloadsize is to big...");		}		if( length > maxFrameSize) {			log.trace( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize, length);			throw new LimitExceededException( "Payload limit reached.", maxFrameSize );		}		if( length < 0 ) {			log.trace("Limit underflow: Payloadsize is to little...");			throw new LimitExceededException("Payloadsize is to little...");		}	}
private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException {		if( maxpacketsize < realpacketsize ) {			log.trace( "Incomplete frame: maxpacketsize < realpacketsize" );			throw new IncompleteException( realpacketsize );		}	}
private String generateFinalKey( String in ) {		String seckey = in.trim();		String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";		MessageDigest sh1;		try {			sh1 = MessageDigest.getInstance( "SHA1" );		} catch ( NoSuchAlgorithmException e ) {			throw new IllegalStateException( e );		}		return Base64.encodeBytes( sh1.digest( acc.getBytes() ) );	}
private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException {        if( curop != Opcode.CONTINUOUS ) {            processFrameIsNotFin(frame);        } else if( frame.isFin() ) {            processFrameIsFin(webSocketImpl, frame);        } else if( currentContinuousFrame == null ) {            log.error( "Protocol error: Continuous frame sequence was not started." );            throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, "Continuous frame sequence was not started." );        }        //Check if the whole payload is valid utf8, when the opcode indicates a text        if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) {            log.error( "Protocol error: Payload is not UTF8" );            throw new InvalidDataException( CloseFrame.NO_UTF8 );        }        //Checking if the current continuous frame contains a correct payload with the other frames combined        if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) {            addToBufferList(frame.getPayloadData());        }    }
private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) {		try {			webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() );		} catch ( RuntimeException e ) {			logRuntimeException(webSocketImpl, e);		}	}
private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) {		log.error( "Runtime exception during onWebsocketMessage", e );		webSocketImpl.getWebSocketListener().onWebsocketError( webSocketImpl, e );	}
private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException {		try {			webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) );		} catch ( RuntimeException e ) {			logRuntimeException(webSocketImpl, e);		}	}
private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException {		if( currentContinuousFrame == null ) {			log.trace( "Protocol error: Previous continuous frame sequence not completed." );			throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, "Continuous frame sequence was not started." );		}		addToBufferList(frame.getPayloadData());		checkBufferLimit();		if( currentContinuousFrame.getOpcode() == Opcode.TEXT ) {			((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() );			((FramedataImpl1) currentContinuousFrame).isValid();			try {				webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( currentContinuousFrame.getPayloadData() ) );			} catch ( RuntimeException e ) {				logRuntimeException(webSocketImpl, e);			}		} else if( currentContinuousFrame.getOpcode() == Opcode.BINARY ) {			((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() );			((FramedataImpl1) currentContinuousFrame).isValid();			try {				webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, currentContinuousFrame.getPayloadData() );			} catch ( RuntimeException e ) {				logRuntimeException(webSocketImpl, e);			}		}		currentContinuousFrame = null;		clearBufferList();	}
private void processFrameIsNotFin(Framedata frame) throws InvalidDataException {		if( currentContinuousFrame != null ) {			log.trace( "Protocol error: Previous continuous frame sequence not completed." );			throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, "Previous continuous frame sequence not completed." );		}		currentContinuousFrame = frame;		addToBufferList(frame.getPayloadData());		checkBufferLimit();	}
private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) {		int code = CloseFrame.NOCODE;		String reason = "";		if( frame instanceof CloseFrame ) {			CloseFrame cf = ( CloseFrame ) frame;			code = cf.getCloseCode();			reason = cf.getMessage();		}		if( webSocketImpl.getReadyState() == ReadyState.CLOSING ) {			// complete the close handshake by disconnecting			webSocketImpl.closeConnection( code, reason, true );		} else {			// echo close handshake			if( getCloseHandshakeType() == CloseHandshakeType.TWOWAY )				webSocketImpl.close( code, reason, true );			else				webSocketImpl.flushAndClose( code, reason, false );		}	}
private void checkBufferLimit() throws LimitExceededException {		long totalSize = getByteBufferListSize();		if( totalSize > maxFrameSize ) {			clearBufferList();			log.trace("Payload limit reached. Allowed: {} Current: {}", maxFrameSize, totalSize);			throw new LimitExceededException(maxFrameSize);		}	}
private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException {		long totalSize = 0;		ByteBuffer resultingByteBuffer;		synchronized (byteBufferList) {			for (ByteBuffer buffer : byteBufferList) {				totalSize += buffer.limit();			}			checkBufferLimit();			resultingByteBuffer = ByteBuffer.allocate( (int) totalSize );			for (ByteBuffer buffer : byteBufferList) {				resultingByteBuffer.put( buffer );			}		}		resultingByteBuffer.flip();		return resultingByteBuffer;	}
private long getByteBufferListSize() {		long totalSize = 0;		synchronized (byteBufferList) {			for (ByteBuffer buffer : byteBufferList) {				totalSize += buffer.limit();			}		}		return totalSize;	}
private boolean doHandshake() throws IOException {		SSLEngineResult result;		HandshakeStatus handshakeStatus;		// NioSslPeer's fields myAppData and peerAppData are supposed to be large enough to hold all message data the peer		// will send and expects to receive from the other peer respectively. Since the messages to be exchanged will usually be less		// than 16KB long the capacity of these fields should also be smaller. Here we initialize these two local buffers		// to be used for the handshake, while keeping client's buffers at the same size.		int appBufferSize = engine.getSession().getApplicationBufferSize();		myAppData = ByteBuffer.allocate( appBufferSize );		peerAppData = ByteBuffer.allocate( appBufferSize );		myNetData.clear();		peerNetData.clear();		handshakeStatus = engine.getHandshakeStatus();		boolean handshakeComplete = false;		while( !handshakeComplete) {			switch(handshakeStatus) {				case FINISHED:					handshakeComplete = !this.peerNetData.hasRemaining();					if (handshakeComplete)						return true;					socketChannel.write(this.peerNetData);					break;				case NEED_UNWRAP:					if( socketChannel.read( peerNetData ) < 0 ) {						if( engine.isInboundDone() && engine.isOutboundDone() ) {							return false;						}						try {							engine.closeInbound();						} catch ( SSLException e ) {							//Ignore, cant do anything against this exception						}						engine.closeOutbound();						// After closeOutbound the engine will be set to WRAP state, in order to try to send a close message to the client.						handshakeStatus = engine.getHandshakeStatus();						break;					}					peerNetData.flip();					try {						result = engine.unwrap( peerNetData, peerAppData );						peerNetData.compact();						handshakeStatus = result.getHandshakeStatus();					} catch ( SSLException sslException ) {						engine.closeOutbound();						handshakeStatus = engine.getHandshakeStatus();						break;					}					switch(result.getStatus()) {						case OK:							break;						case BUFFER_OVERFLOW:							// Will occur when peerAppData's capacity is smaller than the data derived from peerNetData's unwrap.							peerAppData = enlargeApplicationBuffer( peerAppData );							break;						case BUFFER_UNDERFLOW:							// Will occur either when no data was read from the peer or when the peerNetData buffer was too small to hold all peer's data.							peerNetData = handleBufferUnderflow( peerNetData );							break;						case CLOSED:							if( engine.isOutboundDone() ) {								return false;							} else {								engine.closeOutbound();								handshakeStatus = engine.getHandshakeStatus();								break;							}						default:							throw new IllegalStateException( "Invalid SSL status: " + result.getStatus() );					}					break;				case NEED_WRAP:					myNetData.clear();					try {						result = engine.wrap( myAppData, myNetData );						handshakeStatus = result.getHandshakeStatus();					} catch ( SSLException sslException ) {						engine.closeOutbound();						handshakeStatus = engine.getHandshakeStatus();						break;					}					switch(result.getStatus()) {						case OK:							myNetData.flip();							while( myNetData.hasRemaining() ) {								socketChannel.write( myNetData );							}							break;						case BUFFER_OVERFLOW:							// Will occur if there is not enough space in myNetData buffer to write all the data that would be generated by the method wrap.							// Since myNetData is set to session's packet size we should not get to this point because SSLEngine is supposed							// to produce messages smaller or equal to that, but a general handling would be the following:							myNetData = enlargePacketBuffer( myNetData );							break;						case BUFFER_UNDERFLOW:							throw new SSLException( "Buffer underflow occured after a wrap. I don't think we should ever get here." );						case CLOSED:							try {								myNetData.flip();								while( myNetData.hasRemaining() ) {									socketChannel.write( myNetData );								}								// At this point the handshake status will probably be NEED_UNWRAP so we make sure that peerNetData is clear to read.								peerNetData.clear();							} catch ( Exception e ) {								handshakeStatus = engine.getHandshakeStatus();							}							break;						default:							throw new IllegalStateException( "Invalid SSL status: " + result.getStatus() );					}					break;				case NEED_TASK:					Runnable task;					while( ( task = engine.getDelegatedTask() ) != null ) {						executor.execute( task );					}					handshakeStatus = engine.getHandshakeStatus();					break;				case NOT_HANDSHAKING:					break;				default:					throw new IllegalStateException( "Invalid SSL status: " + handshakeStatus );			}		}		return true;	}
private ByteBuffer enlargeBuffer( ByteBuffer buffer, int sessionProposedCapacity ) {		if( sessionProposedCapacity > buffer.capacity() ) {			buffer = ByteBuffer.allocate( sessionProposedCapacity );		} else {			buffer = ByteBuffer.allocate( buffer.capacity() * 2 );		}		return buffer;	}
private ByteBuffer handleBufferUnderflow( ByteBuffer buffer ) {		if( engine.getSession().getPacketBufferSize() < buffer.limit() ) {			return buffer;		} else {			ByteBuffer replaceBuffer = enlargePacketBuffer( buffer );			buffer.flip();			replaceBuffer.put( buffer );			return replaceBuffer;		}	}
private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException {		// translating/parsing the request from the CLIENT		if (!"GET".equalsIgnoreCase(firstLineTokens[0])) {			throw new InvalidHandshakeException( String.format("Invalid request method received: %s Status line: %s", firstLineTokens[0],line));		}		if (!"HTTP/1.1".equalsIgnoreCase(firstLineTokens[2])) {			throw new InvalidHandshakeException( String.format("Invalid status line received: %s Status line: %s", firstLineTokens[2], line));		}		ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client();		clienthandshake.setResourceDescriptor( firstLineTokens[ 1 ] );		return clienthandshake;	}
private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException {		// translating/parsing the response from the SERVER		if (!"101".equals(firstLineTokens[1])) {			throw new InvalidHandshakeException( String.format("Invalid status code received: %s Status line: %s", firstLineTokens[1], line));		}		if (!"HTTP/1.1".equalsIgnoreCase(firstLineTokens[0])) {			throw new InvalidHandshakeException( String.format("Invalid status line received: %s Status line: %s", firstLineTokens[0], line));		}		HandshakeBuilder handshake = new HandshakeImpl1Server();		ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake;		serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) );		serverhandshake.setHttpStatusMessage( firstLineTokens[ 2 ] );		return handshake;	}
public void decode( ByteBuffer socketBuffer ) {		assert ( socketBuffer.hasRemaining() );		log.trace( "process({}): ({})", socketBuffer.remaining(),  ( socketBuffer.remaining() > 1000 ? "too big to display" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) ));		if( readyState != ReadyState.NOT_YET_CONNECTED ) {			if( readyState == ReadyState.OPEN ) {				decodeFrames( socketBuffer );			}		} else {			if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) {				assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time				if( socketBuffer.hasRemaining() ) {					decodeFrames( socketBuffer );				} else if( tmpHandshakeBytes.hasRemaining() ) {					decodeFrames( tmpHandshakeBytes );				}			}		}	}
private boolean decodeHandshake( ByteBuffer socketBufferNew ) {		ByteBuffer socketBuffer;		if( tmpHandshakeBytes.capacity() == 0 ) {			socketBuffer = socketBufferNew;		} else {			if( tmpHandshakeBytes.remaining() < socketBufferNew.remaining() ) {				ByteBuffer buf = ByteBuffer.allocate( tmpHandshakeBytes.capacity() + socketBufferNew.remaining() );				tmpHandshakeBytes.flip();				buf.put( tmpHandshakeBytes );				tmpHandshakeBytes = buf;			}			tmpHandshakeBytes.put( socketBufferNew );			tmpHandshakeBytes.flip();			socketBuffer = tmpHandshakeBytes;		}		socketBuffer.mark();		try {			HandshakeState handshakestate;			try {				if( role == Role.SERVER ) {					if( draft == null ) {						for( Draft d : knownDrafts ) {							d = d.copyInstance();							try {								d.setParseMode( role );								socketBuffer.reset();								Handshakedata tmphandshake = d.translateHandshake( socketBuffer );								if( !( tmphandshake instanceof ClientHandshake ) ) {									log.trace("Closing due to wrong handshake");									closeConnectionDueToWrongHandshake( new InvalidDataException( CloseFrame.PROTOCOL_ERROR, "wrong http function" ) );									return false;								}								ClientHandshake handshake = ( ClientHandshake ) tmphandshake;								handshakestate = d.acceptHandshakeAsServer( handshake );								if( handshakestate == HandshakeState.MATCHED ) {									resourceDescriptor = handshake.getResourceDescriptor();									ServerHandshakeBuilder response;									try {										response = wsl.onWebsocketHandshakeReceivedAsServer( this, d, handshake );									} catch ( InvalidDataException e ) {										log.trace("Closing due to wrong handshake. Possible handshake rejection", e);										closeConnectionDueToWrongHandshake( e );										return false;									} catch ( RuntimeException e ) {										log.error("Closing due to internal server error", e);										wsl.onWebsocketError( this, e );										closeConnectionDueToInternalServerError( e );										return false;									}									write( d.createHandshake( d.postProcessHandshakeResponseAsServer( handshake, response ) ) );									draft = d;									open( handshake );									return true;								}							} catch ( InvalidHandshakeException e ) {								// go on with an other draft							}						}						if( draft == null ) {							log.trace("Closing due to protocol error: no draft matches");							closeConnectionDueToWrongHandshake( new InvalidDataException( CloseFrame.PROTOCOL_ERROR, "no draft matches" ) );						}						return false;					} else {						// special case for multiple step handshakes						Handshakedata tmphandshake = draft.translateHandshake( socketBuffer );						if( !( tmphandshake instanceof ClientHandshake ) ) {							log.trace("Closing due to protocol error: wrong http function");							flushAndClose( CloseFrame.PROTOCOL_ERROR, "wrong http function", false );							return false;						}						ClientHandshake handshake = ( ClientHandshake ) tmphandshake;						handshakestate = draft.acceptHandshakeAsServer( handshake );						if( handshakestate == HandshakeState.MATCHED ) {							open( handshake );							return true;						} else {							log.trace("Closing due to protocol error: the handshake did finally not match");							close( CloseFrame.PROTOCOL_ERROR, "the handshake did finally not match" );						}						return false;					}				} else if( role == Role.CLIENT ) {					draft.setParseMode( role );					Handshakedata tmphandshake = draft.translateHandshake( socketBuffer );					if( !( tmphandshake instanceof ServerHandshake ) ) {						log.trace("Closing due to protocol error: wrong http function");						flushAndClose( CloseFrame.PROTOCOL_ERROR, "wrong http function", false );						return false;					}					ServerHandshake handshake = ( ServerHandshake ) tmphandshake;					handshakestate = draft.acceptHandshakeAsClient( handshakerequest, handshake );					if( handshakestate == HandshakeState.MATCHED ) {						try {							wsl.onWebsocketHandshakeReceivedAsClient( this, handshakerequest, handshake );						} catch ( InvalidDataException e ) {							log.trace("Closing due to invalid data exception. Possible handshake rejection", e);							flushAndClose( e.getCloseCode(), e.getMessage(), false );							return false;						} catch ( RuntimeException e ) {							log.error("Closing since client was never connected", e);							wsl.onWebsocketError( this, e );							flushAndClose( CloseFrame.NEVER_CONNECTED, e.getMessage(), false );							return false;						}						open( handshake );						return true;					} else {						log.trace("Closing due to protocol error: draft {} refuses handshake", draft );						close( CloseFrame.PROTOCOL_ERROR, "draft " + draft + " refuses handshake" );					}				}			} catch ( InvalidHandshakeException e ) {				log.trace("Closing due to invalid handshake", e);				close( e );			}		} catch ( IncompleteHandshakeException e ) {			if( tmpHandshakeBytes.capacity() == 0 ) {				socketBuffer.reset();				int newsize = e.getPreferredSize();				if( newsize == 0 ) {					newsize = socketBuffer.capacity() + 16;				} else {					assert ( e.getPreferredSize() >= socketBuffer.remaining() );				}				tmpHandshakeBytes = ByteBuffer.allocate( newsize );				tmpHandshakeBytes.put( socketBufferNew );				// tmpHandshakeBytes.flip();			} else {				tmpHandshakeBytes.position( tmpHandshakeBytes.limit() );				tmpHandshakeBytes.limit( tmpHandshakeBytes.capacity() );			}		}		return false;	}
private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) {		write( generateHttpResponseDueToError( 404 ) );		flushAndClose( exception.getCloseCode(), exception.getMessage(), false );	}
private void closeConnectionDueToInternalServerError( RuntimeException exception ) {		write( generateHttpResponseDueToError( 500 ) );		flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false );	}
private ByteBuffer generateHttpResponseDueToError( int errorCode ) {		String errorCodeDescription;		switch(errorCode) {			case 404:				errorCodeDescription = "404 WebSocket Upgrade Failure";				break;			case 500:			default:				errorCodeDescription = "500 Internal Server Error";		}		return ByteBuffer.wrap( Charsetfunctions.asciiBytes( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription.length() ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) );	}
public synchronized void closeConnection( int code, String message, boolean remote ) {		if( readyState == ReadyState.CLOSED ) {			return;		}		//Methods like eot() call this method without calling onClose(). Due to that reason we have to adjust the ReadyState manually		if( readyState == ReadyState.OPEN ) {			if( code == CloseFrame.ABNORMAL_CLOSE ) {				readyState = ReadyState.CLOSING;			}		}		if( key != null ) {			// key.attach( null ); //see issue #114			key.cancel();		}		if( channel != null ) {			try {				channel.close();			} catch ( IOException e ) {				if( e.getMessage().equals( "Broken pipe" ) ) {					log.trace( "Caught IOException: Broken pipe during closeConnection()", e );				} else {					log.error("Exception during channel.close()", e);					wsl.onWebsocketError( this, e );				}			}		}		try {			this.wsl.onWebsocketClose( this, code, message, remote );		} catch ( RuntimeException e ) {			wsl.onWebsocketError( this, e );		}		if( draft != null )			draft.reset();		handshakerequest = null;		readyState = ReadyState.CLOSED;	}
@Override	public void send( String text ) {		if( text == null )			throw new IllegalArgumentException( "Cannot send 'null' data to a WebSocketImpl." );		send( draft.createFrames( text, role == Role.CLIENT ) );	}
@Override	public void send( ByteBuffer bytes ) {		if( bytes == null )			throw new IllegalArgumentException( "Cannot send 'null' data to a WebSocketImpl." );		send( draft.createFrames( bytes, role == Role.CLIENT ) );	}
private void write( List<ByteBuffer> bufs ) {		synchronized(synchronizeWriteObject) {			for( ByteBuffer b : bufs ) {				write( b );			}		}	}
private void reset() {		Thread current = Thread.currentThread();		if (current == writeThread || current == connectReadThread) {			throw new IllegalStateException("You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.");		}		try {			closeBlocking();			if( writeThread != null ) {				this.writeThread.interrupt();				this.writeThread = null;			}			if( connectReadThread != null ) {				this.connectReadThread.interrupt();				this.connectReadThread = null;			}			this.draft.reset();			if( this.socket != null ) {				this.socket.close();				this.socket = null;			}		} catch ( Exception e ) {			onError( e );			engine.closeConnection( CloseFrame.ABNORMAL_CLOSE, e.getMessage() );			return;		}		connectLatch = new CountDownLatch( 1 );		closeLatch = new CountDownLatch( 1 );		this.engine = new WebSocketImpl( this, this.draft );	}
public void connect() {		if( connectReadThread != null )			throw new IllegalStateException( "WebSocketClient objects are not reuseable" );		connectReadThread = new Thread( this );		connectReadThread.setName( "WebSocketConnectReadThread-" + connectReadThread.getId() );		connectReadThread.start();	}
public boolean connectBlocking(long timeout, TimeUnit timeUnit) throws InterruptedException {		connect();		return connectLatch.await(timeout, timeUnit) && engine.isOpen();	}
private int getPort() {		int port = uri.getPort();		if( port == -1 ) {			String scheme = uri.getScheme();			if( "wss".equals( scheme ) ) {				return WebSocketImpl.DEFAULT_WSS_PORT;			} else if(  "ws".equals( scheme ) ) {				return WebSocketImpl.DEFAULT_PORT;			} else {				throw new IllegalArgumentException( "unknown scheme: " + scheme );			}		}		return port;	}
private void sendHandshake() throws InvalidHandshakeException {		String path;		String part1 = uri.getRawPath();		String part2 = uri.getRawQuery();		if( part1 == null || part1.length() == 0 )			path = "/";		else			path = part1;		if( part2 != null )			path += '?' + part2;		int port = getPort();		String host = uri.getHost() + ( 			(port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT)			? ":" + port 			: "" );		HandshakeImpl1Client handshake = new HandshakeImpl1Client();		handshake.setResourceDescriptor( path );		handshake.put( "Host", host );		if( headers != null ) {			for( Map.Entry<String,String> kv : headers.entrySet() ) {				handshake.put( kv.getKey(), kv.getValue() );			}		}		engine.startHandshake( handshake );	}
@Override	public final void onWebsocketOpen( WebSocket conn, Handshakedata handshake ) {		startConnectionLostTimer();		onOpen( (ServerHandshake) handshake );		connectLatch.countDown();	}
@Override	public final void onWebsocketClose( WebSocket conn, int code, String reason, boolean remote ) {		stopConnectionLostTimer();		if( writeThread != null )			writeThread.interrupt();		onClose( code, reason, remote );		connectLatch.countDown();		closeLatch.countDown();	}
public void setConnectionLostTimeout( int connectionLostTimeout ) {        synchronized (syncConnectionLost) {            this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout);            if (this.connectionLostTimeout <= 0) {                log.trace("Connection lost timer stopped");                cancelConnectionLostTimer();                return;            }            if (this.websocketRunning) {                log.trace("Connection lost timer restarted");                //Reset all the pings                try {                    ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections());                    WebSocketImpl webSocketImpl;                    for (WebSocket conn : connections) {                        if (conn instanceof WebSocketImpl) {                            webSocketImpl = (WebSocketImpl) conn;                            webSocketImpl.updateLastPong();                        }                    }                } catch (Exception e) {                    log.error("Exception during connection lost restart", e);                }                restartConnectionLostTimer();            }        }    }
protected void stopConnectionLostTimer() {        synchronized (syncConnectionLost) {            if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) {                this.websocketRunning = false;                log.trace("Connection lost timer stopped");                cancelConnectionLostTimer();            }        }    }
protected void startConnectionLostTimer() {        synchronized (syncConnectionLost) {            if (this.connectionLostTimeout <= 0) {                log.trace("Connection lost timer deactivated");                return;            }            log.trace("Connection lost timer started");            this.websocketRunning = true;            restartConnectionLostTimer();        }    }
private void restartConnectionLostTimer() {		cancelConnectionLostTimer();		connectionLostCheckerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory("connectionLostChecker"));		Runnable connectionLostChecker = new Runnable() {			/**			 * Keep the connections in a separate list to not cause deadlocks			 */			private ArrayList<WebSocket> connections = new ArrayList<WebSocket>(  );			@Override			public void run() {				connections.clear();				try {					connections.addAll( getConnections() );					long minimumPongTime = (long) (System.nanoTime() - ( connectionLostTimeout * 1.5 ));					for( WebSocket conn : connections ) {						executeConnectionLostDetection(conn, minimumPongTime);					}				} catch ( Exception e ) {					//Ignore this exception				}				connections.clear();			}		};		connectionLostCheckerFuture = connectionLostCheckerService.scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS);	}
private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) {		if (!(webSocket instanceof WebSocketImpl)) {			return;		}		WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket;		if( webSocketImpl.getLastPong() < minimumPongTime ) {			log.trace("Closing connection due to no pong received: {}", webSocketImpl);			webSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" );		} else {			if( webSocketImpl.isOpen() ) {				webSocketImpl.sendPing();			} else {				log.trace("Trying to ping a non open connection: {}", webSocketImpl);			}		}	}
private void cancelConnectionLostTimer() {       if( connectionLostCheckerService != null ) {            connectionLostCheckerService.shutdownNow();            connectionLostCheckerService = null;        }        if( connectionLostCheckerFuture != null ) {        	connectionLostCheckerFuture.cancel(false);            connectionLostCheckerFuture = null;        }    }
public static void main( String[] args ) throws Exception {		ChatServer chatserver = new ChatServer( 8887 ); // Firefox does allow multible ssl connection only via port 443 //tested on FF16		// load up the key store		String STORETYPE = "JKS";		String KEYSTORE = "keystore.jks";		String STOREPASSWORD = "storepassword";		String KEYPASSWORD = "keypassword";		KeyStore ks = KeyStore.getInstance( STORETYPE );		File kf = new File( KEYSTORE );		ks.load( new FileInputStream( kf ), STOREPASSWORD.toCharArray() );		KeyManagerFactory kmf = KeyManagerFactory.getInstance( "SunX509" );		kmf.init( ks, KEYPASSWORD.toCharArray() );		TrustManagerFactory tmf = TrustManagerFactory.getInstance( "SunX509" );		tmf.init( ks );		SSLContext sslContext = null;		sslContext = SSLContext.getInstance( "TLS" );		sslContext.init( kmf.getKeyManagers(), tmf.getTrustManagers(), null );		chatserver.setWebSocketFactory( new DefaultSSLWebSocketServerFactory( sslContext ) );		chatserver.start();	}
@Override	public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException {		return new HandshakeImpl1Server();	}
@Override	public void onWebsocketPing( WebSocket conn, Framedata f ) {		conn.sendFrame( new PongFrame( (PingFrame)f ) );	}
public static void main(String[] args) throws Exception {        ChatServer chatserver = new ChatServer(8887); // Firefox does allow multible ssl connection only via port 443 //tested on FF16        // load up the key store        String STORETYPE = "JKS";        String KEYSTORE = "keystore.jks";        String STOREPASSWORD = "storepassword";        String KEYPASSWORD = "keypassword";        KeyStore ks = KeyStore.getInstance(STORETYPE);        File kf = new File(KEYSTORE);        ks.load(new FileInputStream(kf), STOREPASSWORD.toCharArray());        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");        kmf.init(ks, KEYPASSWORD.toCharArray());        TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");        tmf.init(ks);        SSLContext sslContext = SSLContext.getInstance("TLS");        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);        //Lets remove some ciphers and protocols        SSLEngine engine = sslContext.createSSLEngine();        List<String> ciphers = new ArrayList<String>( Arrays.asList(engine.getEnabledCipherSuites()));        ciphers.remove("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256");        List<String> protocols = new ArrayList<String>( Arrays.asList(engine.getEnabledProtocols()));        protocols.remove("SSLv3");        CustomSSLWebSocketServerFactory factory = new CustomSSLWebSocketServerFactory(sslContext, protocols.toArray(new String[]{}), ciphers.toArray(new String[]{}));        // Different example just using specific ciphers and protocols        /*        String[] enabledProtocols = {"TLSv1.2"};		String[] enabledCipherSuites = {"TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA"};        CustomSSLWebSocketServerFactory factory = new CustomSSLWebSocketServerFactory(sslContext, enabledProtocols,enabledCipherSuites);        */        chatserver.setWebSocketFactory(factory);        chatserver.start();    }
private synchronized void processHandshake() throws IOException {        if( sslEngine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING )            return; // since this may be called either from a reading or a writing thread and because this method is synchronized it is necessary to double check if we are still handshaking.        if( !tasks.isEmpty() ) {            Iterator<Future<?>> it = tasks.iterator();            while ( it.hasNext() ) {                Future<?> f = it.next();                if( f.isDone() ) {                    it.remove();                } else {                    if( isBlocking() )                        consumeFutureUninterruptible( f );                    return;                }            }        }        if( sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP ) {            if( !isBlocking() || readEngineResult.getStatus() == Status.BUFFER_UNDERFLOW ) {                inCrypt.compact();                int read = socketChannel.read( inCrypt );                if( read == -1 ) {                    throw new IOException( "connection closed unexpectedly by peer" );                }                inCrypt.flip();            }            inData.compact();            unwrap();            if( readEngineResult.getHandshakeStatus() == HandshakeStatus.FINISHED ) {                createBuffers( sslEngine.getSession() );                return;            }        }        consumeDelegatedTasks();        if( tasks.isEmpty() || sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP ) {            socketChannel.write( wrap( emptybuffer ) );            if( writeEngineResult.getHandshakeStatus() == HandshakeStatus.FINISHED ) {                createBuffers( sslEngine.getSession() );                return;            }        }        assert ( sslEngine.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING );// this function could only leave NOT_HANDSHAKING after createBuffers was called unless #190 occurs which means that nio wrap/unwrap never return HandshakeStatus.FINISHED        bufferallocations = 1; // look at variable declaration why this line exists and #190. Without this line buffers would not be be recreated when #190 AND a rehandshake occur.    }
private synchronized ByteBuffer unwrap() throws SSLException {        int rem;        //There are some ssl test suites, which get around the selector.select() call, which cause an infinite unwrap and 100% cpu usage (see #459 and #458)        if(readEngineResult.getStatus() == SSLEngineResult.Status.CLOSED && sslEngine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING){            try {                close();            } catch (IOException e) {                //Not really interesting            }        }        do {            rem = inData.remaining();            readEngineResult = sslEngine.unwrap( inCrypt, inData );        } while ( readEngineResult.getStatus() == SSLEngineResult.Status.OK && ( rem != inData.remaining() || sslEngine.getHandshakeStatus() == HandshakeStatus.NEED_UNWRAP ) );        inData.flip();        return inData;    }
public int read(ByteBuffer dst) throws IOException {        while (true) {            if (!dst.hasRemaining())                return 0;            if (!isHandShakeComplete()) {                if (isBlocking()) {                    while (!isHandShakeComplete()) {                        processHandshake();                    }                } else {                    processHandshake();                    if (!isHandShakeComplete()) {                        return 0;                    }                }            }            // assert ( bufferallocations > 1 ); //see #190            //if( bufferallocations <= 1 ) {            //	createBuffers( sslEngine.getSession() );            //}		/* 1. When "dst" is smaller than "inData" readRemaining will fill "dst" with data decoded in a previous read call.		 * 2. When "inCrypt" contains more data than "inData" has remaining space, unwrap has to be called on more time(readRemaining)		 */            int purged = readRemaining(dst);            if (purged != 0)                return purged;		/* We only continue when we really need more data from the network.		 * Thats the case if inData is empty or inCrypt holds to less data than necessary for decryption		 */            assert (inData.position() == 0);            inData.clear();            if (!inCrypt.hasRemaining())                inCrypt.clear();            else                inCrypt.compact();            if (isBlocking() || readEngineResult.getStatus() == Status.BUFFER_UNDERFLOW)                if (socketChannel.read(inCrypt) == -1) {                    return -1;                }            inCrypt.flip();            unwrap();            int transfered = transfereTo(inData, dst);            if (transfered == 0 && isBlocking()) {                continue;            }            return transfered;        }    }
private int readRemaining( ByteBuffer dst ) throws SSLException {        if( inData.hasRemaining() ) {            return transfereTo( inData, dst );        }        if( !inData.hasRemaining() )            inData.clear();        // test if some bytes left from last read (e.g. BUFFER_UNDERFLOW)        if( inCrypt.hasRemaining() ) {            unwrap();            int amount = transfereTo( inData, dst );            if (readEngineResult.getStatus() == SSLEngineResult.Status.CLOSED) {                return -1;            }            if( amount > 0 )                return amount;        }        return 0;    }
public void stop( int timeout ) throws InterruptedException {		if( !isclosed.compareAndSet( false, true ) ) { // this also makes sure that no further connections will be added to this.connections			return;		}		List<WebSocket> socketsToClose;		// copy the connections in a list (prevent callback deadlocks)		synchronized ( connections ) {			socketsToClose = new ArrayList<WebSocket>( connections );		}		for( WebSocket ws : socketsToClose ) {			ws.close( CloseFrame.GOING_AWAY );		}		wsf.close();		synchronized ( this ) {			if( selectorthread != null  && selector != null) {				selector.wakeup();				selectorthread.join( timeout );			}		}	}
public int getPort() {		int port = getAddress().getPort();		if( port == 0 && server != null ) {			port = server.socket().getLocalPort();		}		return port;	}
public void run() {		if (!doEnsureSingleThread()) {			return;		}		if (!doSetupSelectorAndServerThread()) {			return;		}		try {			int iShutdownCount = 5;			int selectTimeout = 0;			while ( !selectorthread.isInterrupted() && iShutdownCount != 0) {				SelectionKey key = null;				WebSocketImpl conn = null;				try {					if (isclosed.get()) {						selectTimeout = 5;					}					int keyCount = selector.select( selectTimeout );					if (keyCount == 0 && isclosed.get()) {						iShutdownCount--;					}					Set<SelectionKey> keys = selector.selectedKeys();					Iterator<SelectionKey> i = keys.iterator();					while ( i.hasNext() ) {						key = i.next();						conn = null;												if( !key.isValid() ) {							continue;						}						if( key.isAcceptable() ) {							doAccept(key, i);							continue;						}						if( key.isReadable() && !doRead(key, i)) {							continue;						}						if( key.isWritable() ) {							doWrite(key);						}					}					doAdditionalRead();				} catch ( CancelledKeyException e ) {					// an other thread may cancel the key				} catch ( ClosedByInterruptException e ) {					return; // do the same stuff as when InterruptedException is thrown				} catch ( IOException ex ) {					if( key != null )						key.cancel();					handleIOException( key, conn, ex );				} catch ( InterruptedException e ) {					// FIXME controlled shutdown (e.g. take care of buffermanagement)					Thread.currentThread().interrupt();				}			}		} catch ( RuntimeException e ) {			// should hopefully never occur			handleFatal( null, e );		} finally {			doServerShutdown();		}	}
private void doAdditionalRead() throws InterruptedException, IOException {		WebSocketImpl conn;		while ( !iqueue.isEmpty() ) {			conn = iqueue.remove( 0 );			WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() );			ByteBuffer buf = takeBuffer();			try {				if( SocketChannelIOHelper.readMore( buf, conn, c ) )					iqueue.add( conn );				if( buf.hasRemaining() ) {					conn.inQueue.put( buf );					queue( conn );				} else {					pushBuffer( buf );				}			} catch ( IOException e ) {				pushBuffer( buf );				throw e;			}		}	}
private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException {		if( !onConnect( key ) ) {			key.cancel();			return;		}		SocketChannel channel = server.accept();		if(channel==null){			return;		}		channel.configureBlocking( false );		Socket socket = channel.socket();		socket.setTcpNoDelay( isTcpNoDelay() );		socket.setKeepAlive( true );		WebSocketImpl w = wsf.createWebSocket( this, drafts );		w.setSelectionKey(channel.register( selector, SelectionKey.OP_READ, w ));		try {			w.setChannel( wsf.wrapChannel( channel, w.getSelectionKey() ));			i.remove();			allocateBuffers( w );		} catch (IOException ex) {			if( w.getSelectionKey() != null )				w.getSelectionKey().cancel();			handleIOException( w.getSelectionKey(), null, ex );		}	}
private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException {		WebSocketImpl conn = (WebSocketImpl) key.attachment();		ByteBuffer buf = takeBuffer();		if(conn.getChannel() == null){			key.cancel();			handleIOException( key, conn, new IOException() );			return false;		}		try {			if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) {				if( buf.hasRemaining() ) {					conn.inQueue.put( buf );					queue( conn );					i.remove();					if( conn.getChannel() instanceof WrappedByteChannel && ( (WrappedByteChannel) conn.getChannel() ).isNeedRead() ) {						iqueue.add( conn );					}				} else {					pushBuffer(buf);				}			} else {				pushBuffer( buf );			}		} catch ( IOException e ) {			pushBuffer( buf );			throw e;		}		return true;	}
private void doWrite(SelectionKey key) throws IOException {		WebSocketImpl conn = (WebSocketImpl) key.attachment();		if( SocketChannelIOHelper.batch( conn, conn.getChannel() ) ) {			if( key.isValid() ) {				key.interestOps(SelectionKey.OP_READ);			}		}	}
private boolean doSetupSelectorAndServerThread() {		selectorthread.setName( "WebSocketSelector-" + selectorthread.getId() );		try {			server = ServerSocketChannel.open();			server.configureBlocking( false );			ServerSocket socket = server.socket();			socket.setReceiveBufferSize( WebSocketImpl.RCVBUF );			socket.setReuseAddress( isReuseAddr() );			socket.bind( address );			selector = Selector.open();			server.register( selector, server.validOps() );			startConnectionLostTimer();			for( WebSocketWorker ex : decoders ){				ex.start();			}			onStart();		} catch ( IOException ex ) {			handleFatal( null, ex );			return false;		}		return true;	}
private boolean doEnsureSingleThread() {		synchronized ( this ) {			if( selectorthread != null )				throw new IllegalStateException( getClass().getName() + " can only be started once." );			selectorthread = Thread.currentThread();			if( isclosed.get() ) {				return false;			}		}		return true;	}
private void doServerShutdown() {		stopConnectionLostTimer();		if( decoders != null ) {			for( WebSocketWorker w : decoders ) {				w.interrupt();			}		}		if( selector != null ) {			try {				selector.close();			} catch ( IOException e ) {				log.error( "IOException during selector.close", e );				onError( null, e );			}		}		if( server != null ) {			try {				server.close();			} catch ( IOException e ) {				log.error( "IOException during server.close", e );				onError( null, e );			}		}	}
protected boolean removeConnection( WebSocket ws ) {		boolean removed = false;		synchronized ( connections ) {			if (this.connections.contains( ws )) {				removed = this.connections.remove( ws );			} else {				//Don't throw an assert error if the ws is not in the list. e.g. when the other endpoint did not send any handshake. see #512				log.trace("Removing connection which is not in the connections collection! Possible no handshake recieved! {}", ws);			}		}		if( isclosed.get() && connections.isEmpty() ) {			selectorthread.interrupt();		}		return removed;	}
private Socket getSocket( WebSocket conn ) {		WebSocketImpl impl = (WebSocketImpl) conn;		return ( (SocketChannel) impl.getSelectionKey().channel() ).socket();	}
public void broadcast(byte[] data, Collection<WebSocket> clients) {		if (data == null || clients == null) {			throw new IllegalArgumentException();		}		broadcast(ByteBuffer.wrap(data), clients);	}
public void broadcast(String text, Collection<WebSocket> clients) {		if (text == null || clients == null) {			throw new IllegalArgumentException();		}		doBroadcast(text, clients);	}
private void doBroadcast(Object data, Collection<WebSocket> clients) {		String sData = null;		if (data instanceof String) {			sData = (String)data;		}		ByteBuffer bData = null;		if (data instanceof ByteBuffer) {			bData = (ByteBuffer)data;		}		if (sData == null && bData == null) {			return;		}		Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>();		for( WebSocket client : clients ) {			if( client != null ) {				Draft draft = client.getDraft();				fillFrames(draft, draftFrames, sData, bData);				try {					client.sendFrame( draftFrames.get( draft ) );				} catch ( WebsocketNotConnectedException e ) {					//Ignore this exception in this case				}			}		}	}
private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) {		if( !draftFrames.containsKey( draft ) ) {			List<Framedata> frames = null;			if (sData != null) {				frames = draft.createFrames( sData, false );			}			if (bData != null) {				frames = draft.createFrames( bData, false );			}			if (frames != null) {				draftFrames.put(draft, frames);			}		}	}
public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) {		if( source == null || dest == null ) {			throw new IllegalArgumentException();		}		int fremain = source.remaining();		int toremain = dest.remaining();		if( fremain > toremain ) {			int limit = Math.min( fremain, toremain );			source.limit( limit );			dest.put( source );			return limit;		} else {			dest.put( source );			return fremain;		}	}
public static void main( String[] args ) throws Exception {		WebSocketChatClient chatclient = new WebSocketChatClient( new URI( "wss://localhost:8887" ) );		// load up the key store		String STORETYPE = "JKS";		String KEYSTORE = "keystore.jks";		String STOREPASSWORD = "storepassword";		String KEYPASSWORD = "keypassword";		KeyStore ks = KeyStore.getInstance( STORETYPE );		File kf = new File( KEYSTORE );		ks.load( new FileInputStream( kf ), STOREPASSWORD.toCharArray() );		KeyManagerFactory kmf = KeyManagerFactory.getInstance( "SunX509" );		kmf.init( ks, KEYPASSWORD.toCharArray() );		TrustManagerFactory tmf = TrustManagerFactory.getInstance( "SunX509" );		tmf.init( ks );		SSLContext sslContext = null;		sslContext = SSLContext.getInstance( "TLS" );		sslContext.init( kmf.getKeyManagers(), tmf.getTrustManagers(), null );		// sslContext.init( null, null, null ); // will use java's default key and trust store which is sufficient unless you deal with self-signed certificates		SSLSocketFactory factory = sslContext.getSocketFactory();// (SSLSocketFactory) SSLSocketFactory.getDefault();		chatclient.setSocketFactory( factory );		chatclient.connectBlocking();		BufferedReader reader = new BufferedReader( new InputStreamReader( System.in ) );		while ( true ) {			String line = reader.readLine();			if( line.equals( "close" ) ) {				chatclient.closeBlocking();			} else if ( line.equals( "open" ) ) {				chatclient.reconnect();			} else {				chatclient.send( line );			}		}	}
public JPAApi start() {    jpaConfig        .persistenceUnits()        .forEach(            persistenceUnit ->                emfs.put(                    persistenceUnit.name,                    Persistence.createEntityManagerFactory(persistenceUnit.unitName)));    return this;  }
public EntityManager em(String name) {    EntityManagerFactory emf = emfs.get(name);    if (emf == null) {      return null;    }    return emf.createEntityManager();  }
public void withTransaction(Consumer<EntityManager> block) {    withTransaction(        em -> {          block.accept(em);          return null;        });  }
public <T> T withTransaction(String name, Function<EntityManager, T> block) {    return withTransaction(name, false, block);  }
public <T> T withTransaction(String name, boolean readOnly, Function<EntityManager, T> block) {    EntityManager entityManager = null;    EntityTransaction tx = null;    try {      entityManager = em(name);      if (entityManager == null) {        throw new RuntimeException("Could not create JPA entity manager for '" + name + "'");      }      if (entityManagerContext != null) {        entityManagerContext.push(entityManager, true);      }      if (!readOnly) {        tx = entityManager.getTransaction();        tx.begin();      }      T result = block.apply(entityManager);      if (tx != null) {        if (tx.getRollbackOnly()) {          tx.rollback();        } else {          tx.commit();        }      }      return result;    } catch (Throwable t) {      if (tx != null) {        try {          if (tx.isActive()) {            tx.rollback();          }        } catch (Exception e) {          logger.error("Could not rollback transaction", e);        }      }      throw t;    } finally {      if (entityManager != null) {        if (entityManagerContext != null) {          entityManagerContext.pop(true);        }        entityManager.close();      }    }  }
public void withTransaction(String name, boolean readOnly, Consumer<EntityManager> block) {    withTransaction(        name,        readOnly,        em -> {          block.accept(em);          return null;        });  }
@Deprecated  public <T> T withTransaction(Supplier<T> block) {    return withTransaction("default", false, block);  }
@Deprecated  public void withTransaction(final Runnable block) {    try {      withTransaction(          () -> {            block.run();            return null;          });    } catch (Throwable t) {      throw new RuntimeException("JPA transaction failed", t);    }  }
@Deprecated  public <T> T withTransaction(String name, boolean readOnly, Supplier<T> block) {    return withTransaction(        name,        readOnly,        entityManager -> {          return block.get();        });  }
private static Seq<Object> convertArgsToScalaBuffer(final Object... args) {    return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args))        .asScala()        .toList();  }
@SafeVarargs  private static <T> List<T> wrapArgsToListIfNeeded(final T... args) {    List<T> out;    if (args != null && args.length == 1 && args[0] instanceof List) {      out = (List<T>) args[0];    } else {      out = Arrays.asList(args);    }    return out;  }
public String get(play.api.i18n.Lang lang, String key, Object... args) {    Seq<Object> scalaArgs = convertArgsToScalaBuffer(args);    return messages.apply(key, scalaArgs, lang);  }
public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) {    Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala();    Seq<Object> scalaArgs = convertArgsToScalaBuffer(args);    return messages.apply(keyArgs.toSeq(), scalaArgs, lang);  }
public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) {    return messages.isDefinedAt(key, lang);  }
public Messages preferred(Collection<Lang> candidates) {    Seq<Lang> cs = Scala.asScala(candidates);    play.api.i18n.Messages msgs = messages.preferred((Seq) cs);    return new MessagesImpl(new Lang(msgs.lang()), this);  }
public Messages preferred(Http.RequestHeader request) {    play.api.i18n.Messages msgs = messages.preferred(request);    return new MessagesImpl(new Lang(msgs.lang()), this);  }
public Result setLang(Result result, Lang lang) {    return messages.setLang(result.asScala(), lang).asJava();  }
public final Self configure(Config conf) {    return newBuilder(delegate.configure(new play.api.Configuration(conf)));  }
public final Self configure(Map<String, Object> conf) {    return configure(ConfigFactory.parseMap(conf));  }
public final Self configure(String key, Object value) {    return configure(ImmutableMap.of(key, value));  }
public final Self bindings(GuiceableModule... modules) {    return newBuilder(delegate.bindings(Scala.varargs(modules)));  }
public final Self bindings(play.api.inject.Module... modules) {    return bindings(Guiceable.modules(modules));  }
public final Self bindings(play.api.inject.Binding<?>... bindings) {    return bindings(Guiceable.bindings(bindings));  }
public final Self overrides(GuiceableModule... modules) {    return newBuilder(delegate.overrides(Scala.varargs(modules)));  }
public final Self overrides(play.api.inject.Module... modules) {    return overrides(Guiceable.modules(modules));  }
public final Self overrides(play.api.inject.Binding<?>... bindings) {    return overrides(Guiceable.bindings(bindings));  }
public final Self disable(Class<?>... moduleClasses) {    return newBuilder(delegate.disable(Scala.toSeq(moduleClasses)));  }
@Deprecated // TODO: When you remove this method make call(Request) below abstract  public CompletionStage<Result> call(Context ctx) {    return call(        ctx.args != null && !ctx.args.isEmpty()            ? ctx.request().addAttr(CTX_ARGS, ctx.args)            : ctx.request());  }
public CompletionStage<Result> call(      Request req) { // TODO: Make this method abstract after removing call(Context)    return Context.safeCurrent()        .map(            threadLocalCtx -> {              // A previous action did explicitly set a context onto the thread local (via              // Http.Context.current.set(...))              // Let's use that context so the user doesn't loose data he/she set onto that ctx              // (args,...)              Context newCtx = threadLocalCtx.withRequest(req.removeAttr(CTX_ARGS));              Context.setCurrent(newCtx);              return call(newCtx);            })        .orElseGet(            () -> {              // A previous action did not set a context explicitly, we simply create a new one to              // pass on the request              Context ctx = new Context(req.removeAttr(CTX_ARGS), contextComponents);              ctx.args = req.attrs().getOptional(CTX_ARGS).orElse(new HashMap<>());              return call(ctx);            });  }
public Optional<File> getExistingFile(String relativePath) {    return OptionConverters.toJava(env.getExistingFile(relativePath));  }
public <A extends Annotation> Binding<T> in(final Class<A> scope) {    return underlying.in(scope).asJava();  }
public static <A, B> Tuple<A, B> Tuple(A a, B b) {    return new Tuple<A, B>(a, b);  }
public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) {    return new Tuple5<A, B, C, D, E>(a, b, c, d, e);  }
private static Executor toExecutor(ExecutionContext ec) {    ExecutionContext prepared = ec.prepare();    if (prepared instanceof Executor) {      return (Executor) prepared;    } else {      return prepared::execute;    }  }
public Cookie decode(String header) {    if (header == null) {      throw new NullPointerException("header");    }    final int headerLen = header.length();    if (headerLen == 0) {      return null;    }    CookieBuilder cookieBuilder = null;    loop:    for (int i = 0; ; ) {      // Skip spaces and separators.      for (; ; ) {        if (i == headerLen) {          break loop;        }        char c = header.charAt(i);        if (c == ',') {          // Having multiple cookies in a single Set-Cookie header is          // deprecated, modern browsers only parse the first one          break loop;        } else if (c == '\t' || c == '\n' || c == 0x0b || c == '\f' || c == '\r' || c == ' '            || c == ';') {          i++;          continue;        }        break;      }      int nameBegin = i;      int nameEnd = i;      int valueBegin = -1;      int valueEnd = -1;      if (i != headerLen) {        keyValLoop:        for (; ; ) {          char curChar = header.charAt(i);          if (curChar == ';') {            // NAME; (no value till ';')            nameEnd = i;            valueBegin = valueEnd = -1;            break keyValLoop;          } else if (curChar == '=') {            // NAME=VALUE            nameEnd = i;            i++;            if (i == headerLen) {              // NAME= (empty value, i.e. nothing after '=')              valueBegin = valueEnd = 0;              break keyValLoop;            }            valueBegin = i;            // NAME=VALUE;            int semiPos = header.indexOf(';', i);            valueEnd = i = semiPos > 0 ? semiPos : headerLen;            break keyValLoop;          } else {            i++;          }          if (i == headerLen) {            // NAME (no value till the end of string)            nameEnd = headerLen;            valueBegin = valueEnd = -1;            break;          }        }      }      if (valueEnd > 0 && header.charAt(valueEnd - 1) == ',') {        // old multiple cookies separator, skipping it        valueEnd--;      }      if (cookieBuilder == null) {        // cookie name-value pair        DefaultCookie cookie = initCookie(header, nameBegin, nameEnd, valueBegin, valueEnd);        if (cookie == null) {          return null;        }        cookieBuilder = new CookieBuilder(cookie);      } else {        // cookie attribute        String attrValue = valueBegin == -1 ? null : header.substring(valueBegin, valueEnd);        cookieBuilder.appendAttribute(header, nameBegin, nameEnd, attrValue);      }    }    return cookieBuilder.cookie();  }
public SourceProvider plusSkippedClasses(Class... moreClassesToSkip) {    Set<String> toSkip = new HashSet<String>(classNamesToSkip);    toSkip.addAll(asStrings(moreClassesToSkip));    return new SourceProvider(toSkip);  }
private static List<String> asStrings(Class... classes) {    List<String> strings = new ArrayList<String>();    for (Class c : classes) {      strings.add(c.getName());    }    return strings;  }
public StackTraceElement get() {    for (final StackTraceElement element : new Throwable().getStackTrace()) {      String className = element.getClassName();      if (!classNamesToSkip.contains(className)) {        return element;      }    }    throw new AssertionError();  }
public static JPAConfig of(String name, String unitName) {    return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName));  }
public static JPAConfig of(String n1, String u1, String n2, String u2) {    return new DefaultJPAConfig(        new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2));  }
public static JPAConfig from(Map<String, String> map) {    ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits =        new ImmutableSet.Builder<JPAConfig.PersistenceUnit>();    for (Map.Entry<String, String> entry : map.entrySet()) {      persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue()));    }    return new DefaultJPAConfig(persistenceUnits.build());  }
public static Flow<String, ByteString, NotUsed> string(String callbackName) {    return Flow.of(String.class)        .map(            str -> {              return ByteString.fromString("'" + StringEscapeUtils.escapeEcmaScript(str) + "'");            })        .via(flow(callbackName));  }
public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) {    return Flow.of(JsonNode.class)        .map(            json -> {              return ByteString.fromString(Json.stringify(json));            })        .via(flow(callbackName));  }
public static Flow<ByteString, ByteString, NotUsed> flow(String callbackName) {    ByteString cb = ByteString.fromString(callbackName);    return Flow.of(ByteString.class)        .map(            (msg) -> {              return formatted(cb, msg);            }
public static <A> Accumulator<ByteString, F.Either<Result, A>> validateContentType(      HttpErrorHandler errorHandler,      Http.RequestHeader request,      String errorMessage,      Function<String, Boolean> validate,      Function<Http.RequestHeader, Accumulator<ByteString, F.Either<Result, A>>> parser) {    if (request.contentType().map(validate).orElse(false)) {      return parser.apply(request);    } else {      CompletionStage<Result> result =          errorHandler.onClientError(              request, Status$.MODULE$.UNSUPPORTED_MEDIA_TYPE(), errorMessage);      return Accumulator.done(result.thenApply(F.Either::Left));    }
public static ALogger of(String name) {    return new ALogger(play.api.Logger.apply(name));  }
public static ALogger of(Class<?> clazz) {    return new ALogger(play.api.Logger.apply(clazz));  }
@Deprecated  public static void trace(String message, Object... args) {    logger.trace(message, args);  }
@Deprecated  public static void trace(String message, Supplier<?>... args) {    logger.trace(message, args);  }
@Deprecated  public static void trace(String message, Throwable error) {    logger.trace(message, error);  }
@Deprecated  public static void debug(String message, Object... args) {    logger.debug(message, args);  }
@Deprecated  public static void debug(String message, Supplier<?>... args) {    logger.debug(message, args);  }
@Deprecated  public static void debug(String message, Throwable error) {    logger.debug(message, error);  }
@Deprecated  public static void info(String message, Object... args) {    logger.info(message, args);  }
@Deprecated  public static void info(String message, Supplier<?>... args) {    logger.info(message, args);  }
@Deprecated  public static void info(String message, Throwable error) {    logger.info(message, error);  }
@Deprecated  public static void warn(String message, Object... args) {    logger.warn(message, args);  }
@Deprecated  public static void warn(String message, Supplier<?>... args) {    logger.warn(message, args);  }
@Deprecated  public static void warn(String message, Throwable error) {    logger.warn(message, error);  }
@Deprecated  public static void error(String message, Object... args) {    logger.error(message, args);  }
@Deprecated  public static void error(String message, Supplier<?> args) {    logger.error(message, args);  }
@Deprecated  public static void error(String message, Throwable error) {    logger.error(message, error);  }
public <T extends ConstraintValidator<?, ?>>      MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) {    validators.put(key, () -> constraintValidator);    return this;  }
private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) {    try {      return key.getDeclaredConstructor().newInstance();    } catch (InstantiationException        | RuntimeException        | IllegalAccessException        | NoSuchMethodException        | InvocationTargetException ex) {      throw new RuntimeException(ex);    }  }
public Result show(Long id) {    Client client = clientService.findById(id);    return ok(views.html.Client.show(client));  }
public Result video(Http.Request request, Long videoId) {    File videoFile = getVideoFile(videoId);    return RangeResults.ofFile(request, videoFile);  }
public static Method getAccessibleMethod(Method method) {    if (!MemberUtils.isAccessible(method)) {      return null;    }    // If the declaring class is public, we are done    final Class<?> cls = method.getDeclaringClass();    if (Modifier.isPublic(cls.getModifiers())) {      return method;    }    final String methodName = method.getName();    final Class<?>[] parameterTypes = method.getParameterTypes();    // Check the implemented interfaces and subinterfaces    method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes);    // Check the superclass chain    if (method == null) {      method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes);    }    return method;  }
private static Method getAccessibleMethodFromSuperclass(      final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {    Class<?> parentClass = cls.getSuperclass();    while (parentClass != null) {      if (Modifier.isPublic(parentClass.getModifiers())) {        try {          return parentClass.getMethod(methodName, parameterTypes);        } catch (final NoSuchMethodException e) {          return null;        }      }      parentClass = parentClass.getSuperclass();    }    return null;  }
public static Method getMatchingAccessibleMethod(      final Class<?> cls, final String methodName, final Class<?>... parameterTypes) {    try {      final Method method = cls.getMethod(methodName, parameterTypes);      MemberUtils.setAccessibleWorkaround(method);      return method;    } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception    }    // search through all methods    Method bestMatch = null;    final Method[] methods = cls.getMethods();    for (final Method method : methods) {      // compare name and parameters      if (method.getName().equals(methodName)          && MemberUtils.isMatchingMethod(method, parameterTypes)) {        // get accessible version of method        final Method accessibleMethod = getAccessibleMethod(method);        if (accessibleMethod != null            && (bestMatch == null                || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) {          bestMatch = accessibleMethod;        }      }    }    if (bestMatch != null) {      MemberUtils.setAccessibleWorkaround(bestMatch);    }    if (bestMatch != null        && bestMatch.isVarArgs()        && bestMatch.getParameterTypes().length > 0        && parameterTypes.length > 0) {      final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes();      final Class<?> methodParameterComponentType =          methodParameterTypes[methodParameterTypes.length - 1].getComponentType();      final String methodParameterComponentTypeName =          ClassUtils.primitiveToWrapper(methodParameterComponentType).getName();      final String parameterTypeName = parameterTypes[parameterTypes.length - 1].getName();      final String parameterTypeSuperClassName =          parameterTypes[parameterTypes.length - 1].getSuperclass().getName();      if (!methodParameterComponentTypeName.equals(parameterTypeName)          && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) {        return null;      }    }    return bestMatch;  }
@Override  public CompletionStage<Result> onClientError(      RequestHeader request, int statusCode, String message) {    if (statusCode == 400) {      return onBadRequest(request, message);    } else if (statusCode == 403) {      return onForbidden(request, message);    } else if (statusCode == 404) {      return onNotFound(request, message);    } else if (statusCode >= 400 && statusCode < 500) {      return onOtherClientError(request, statusCode, message);    } else {      throw new IllegalArgumentException(          "onClientError invoked with non client error status code " + statusCode + ": " + message);    }  }
protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) {    return CompletableFuture.completedFuture(        Results.badRequest(            views.html.defaultpages.badRequest.render(                request.method(), request.uri(), message, request.asScala())));  }
protected CompletionStage<Result> onForbidden(RequestHeader request, String message) {    return CompletableFuture.completedFuture(        Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala())));  }
protected CompletionStage<Result> onNotFound(RequestHeader request, String message) {    if (environment.isProd()) {      return CompletableFuture.completedFuture(          Results.notFound(              views.html.defaultpages.notFound.render(                  request.method(), request.uri(), request.asScala())));    } else {      return CompletableFuture.completedFuture(          Results.notFound(              views.html.defaultpages.devNotFound.render(                  request.method(), request.uri(), Some.apply(routes.get()), request.asScala())));    }  }
@Override  public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) {    try {      UsefulException usefulException = throwableToUsefulException(exception);      logServerError(request, usefulException);      switch (environment.mode()) {        case PROD:          return onProdServerError(request, usefulException);        default:          return onDevServerError(request, usefulException);      }    } catch (Exception e) {      logger.error("Error while handling error", e);      return CompletableFuture.completedFuture(Results.internalServerError());    }  }
protected void logServerError(RequestHeader request, UsefulException usefulException) {    logger.error(        String.format(            "\n\n! @%s - Internal server error, for (%s) [%s] ->\n",            usefulException.id, request.method(), request.uri()),        usefulException);  }
protected final UsefulException throwableToUsefulException(final Throwable throwable) {    return HttpErrorHandlerExceptions.throwableToUsefulException(        sourceMapper.sourceMapper(), environment.isProd(), throwable);  }
protected CompletionStage<Result> onDevServerError(      RequestHeader request, UsefulException exception) {    return CompletableFuture.completedFuture(        Results.internalServerError(            views.html.defaultpages.devError.render(playEditor, exception, request.asScala())));  }
protected CompletionStage<Result> onProdServerError(      RequestHeader request, UsefulException exception) {    return CompletableFuture.completedFuture(        Results.internalServerError(            views.html.defaultpages.error.render(exception, request.asScala())));  }
public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException {    assert (files.length == baseDirs.length);    FileRepository[] repositories = new FileRepository[files.length];    List<JarFile> jarFiles = new ArrayList<>();    for (int i = 0; i < files.length; i++) {      File file = files[i];      String baseDir = baseDirs[i];      if (file.isDirectory()) {        repositories[i] = new FilesystemRepository(file);      } else {        // Assume it's a jar file        JarFile jarFile = new JarFile(file);        jarFiles.add(jarFile);        repositories[i] = new JarRepository(jarFile, Option.apply(baseDir));      }    }    return new DocumentationHandler(        new AggregateFileRepository(repositories),        () -> {          for (JarFile jarFile : jarFiles) {            jarFile.close();          }        });  }
public static BuildDocHandler fromDirectory(File directory) {    FileRepository repo = new FilesystemRepository(directory);    return new DocumentationHandler(repo);  }
public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) {    return fromDirectoryAndJar(directory, jarFile, base, false);  }
public static BuildDocHandler fromDirectoryAndJar(      File directory, JarFile jarFile, String base, boolean fallbackToJar) {    FileRepository fileRepo = new FilesystemRepository(directory);    FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base));    FileRepository manualRepo;    if (fallbackToJar) {      manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo});    } else {      manualRepo = fileRepo;    }    return new DocumentationHandler(manualRepo, jarRepo);  }
public static BuildDocHandler fromJar(JarFile jarFile, String base) {    FileRepository repo = new JarRepository(jarFile, Option.apply(base));    return new DocumentationHandler(repo);  }
private Marker requestMarker(Http.Request request) {    return append("host", request.host()).and(append("path", request.path()));  }
public CompletionStage<Result> asyncIndex(Http.Request request) {    return CompletableFuture.supplyAsync(        () -> {          logger.info(requestMarker(request), "Rendering asyncIndex()");          return ok("foo");        },        httpExecutionContext.current());  }
public CompletionStage<ByteString> consumeData(Materializer mat) {    return dataStream().runFold(ByteString.empty(), ByteString::concat, mat);  }
public static final HttpEntity fromContent(Content content, String charset) {    String body;    if (content instanceof Xml) {      // See https://github.com/playframework/playframework/issues/2770      body = content.body().trim();    } else {      body = content.body();    }    return new Strict(        ByteString.fromString(body, charset),        Optional.of(content.contentType() + "; charset=" + charset));  }
public static final HttpEntity fromString(String content, String charset) {    return new Strict(        ByteString.fromString(content, charset), Optional.of("text/plain; charset=" + charset));  }
public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) {    return new Chunked(data.map(HttpChunk.Chunk::new), contentType);  }
@Override  public Optional<AgeRange> bind(String key, Map<String, String[]> data) {    try {      from = Integer.valueOf(data.get("from")[0]);      to = Integer.valueOf(data.get("to")[0]);      return Optional.of(this);    } catch (Exception e) { // no parameter match return None      return Optional.empty();    }  }
@Override  public String javascriptUnbind() {    return new StringBuilder().append("from=").append(from).append(";to=").append(to).toString();  }
public static Result status(int status, Content content, String charset) {    if (content == null) {      throw new NullPointerException("Null content");    }    return new Result(status, HttpEntity.fromContent(content, charset));  }
public static Result status(int status, String content, String charset) {    if (content == null) {      throw new NullPointerException("Null content");    }    return new Result(status, HttpEntity.fromString(content, charset));  }
public static Result status(int status, JsonNode content) {    return status(status, content, JsonEncoding.UTF8);  }
public static Result status(int status, JsonNode content, JsonEncoding encoding) {    if (content == null) {      throw new NullPointerException("Null content");    }    return status(status).sendJson(content, encoding);  }
public static Result status(int status, byte[] content) {    if (content == null) {      throw new NullPointerException("Null content");    }    return new Result(        status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty()));  }
public static Result status(int status, InputStream content, long contentLength) {    return status(status).sendInputStream(content, contentLength);  }
public static Result status(int status, File content) {    return status(status, content, StaticFileMimeTypes.fileMimeTypes());  }
public static Result status(int status, File content, String fileName) {    return status(status, content, fileName, StaticFileMimeTypes.fileMimeTypes());  }
public static Result status(      int status, File content, String fileName, FileMimeTypes fileMimeTypes) {    return status(status).sendFile(content, fileName, fileMimeTypes);  }
public static Result status(int status, Path content) {    return status(status, content, StaticFileMimeTypes.fileMimeTypes());  }
public static Result status(int status, Path content, FileMimeTypes fileMimeTypes) {    return status(status).sendPath(content, fileMimeTypes);  }
public static Result status(int status, Path content, String fileName) {    return status(status, content, fileName, StaticFileMimeTypes.fileMimeTypes());  }
public static Result ok(String content, String charset) {    return status(OK, content, charset);  }
public static Result ok(JsonNode content, JsonEncoding encoding) {    return status(OK, content, encoding);  }
public static Result ok(File content, boolean inline) {    return ok(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result ok(File content, String filename) {    return ok(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result ok(Path content, FileMimeTypes fileMimeTypes) {    return status(OK, content, fileMimeTypes);  }
public static Result ok(Path content, boolean inline) {    return ok(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result ok(Path content, String filename) {    return ok(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result created(Content content, String charset) {    return status(CREATED, content, charset);  }
public static Result created(JsonNode content, JsonEncoding encoding) {    return status(CREATED, content, encoding);  }
public static Result created(File content, boolean inline) {    return created(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result created(File content, String filename) {    return created(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result created(Path content, boolean inline) {    return created(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result created(Path content, String filename) {    return created(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result created(      Path content, boolean inline, String filename, FileMimeTypes fileMimeTypes) {    return status(CREATED, content, inline, filename, fileMimeTypes);  }
public static Result badRequest(Content content, String charset) {    return status(BAD_REQUEST, content, charset);  }
public static Result badRequest(JsonNode content, JsonEncoding encoding) {    return status(BAD_REQUEST, content, encoding);  }
public static Result badRequest(File content, FileMimeTypes fileMimeTypes) {    return status(BAD_REQUEST, content, fileMimeTypes);  }
public static Result badRequest(File content, boolean inline) {    return badRequest(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result badRequest(File content, String filename) {    return badRequest(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result badRequest(Path content, boolean inline) {    return badRequest(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result badRequest(Path content, String filename) {    return badRequest(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unauthorized(Content content, String charset) {    return status(UNAUTHORIZED, content, charset);  }
public static Result unauthorized(JsonNode content, JsonEncoding encoding) {    return status(UNAUTHORIZED, content, encoding);  }
public static Result unauthorized(File content, FileMimeTypes fileMimeTypes) {    return status(UNAUTHORIZED, content, fileMimeTypes);  }
public static Result unauthorized(File content, boolean inline) {    return unauthorized(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unauthorized(File content, String filename) {    return unauthorized(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unauthorized(Path content, boolean inline) {    return unauthorized(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unauthorized(Path content, String filename) {    return unauthorized(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result paymentRequired(String content, String charset) {    return status(PAYMENT_REQUIRED, content, charset);  }
public static Result paymentRequired(JsonNode content, JsonEncoding encoding) {    return status(PAYMENT_REQUIRED, content, encoding);  }
public static Result paymentRequired(File content, FileMimeTypes fileMimeTypes) {    return status(PAYMENT_REQUIRED, content, fileMimeTypes);  }
public static Result paymentRequired(File content, boolean inline) {    return paymentRequired(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result paymentRequired(File content, String filename) {    return paymentRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result paymentRequired(Path content, boolean inline) {    return paymentRequired(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result paymentRequired(Path content, String filename) {    return paymentRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result forbidden(Content content, String charset) {    return status(FORBIDDEN, content, charset);  }
public static Result forbidden(JsonNode content, JsonEncoding encoding) {    return status(FORBIDDEN, content, encoding);  }
public static Result forbidden(File content, boolean inline) {    return forbidden(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result forbidden(File content, String filename) {    return forbidden(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result forbidden(      File content, boolean inline, String filename, FileMimeTypes fileMimeTypes) {    return status(FORBIDDEN, content, inline, filename, fileMimeTypes);  }
public static Result forbidden(Path content, boolean inline) {    return forbidden(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result forbidden(Path content, String filename) {    return forbidden(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notFound(Content content, String charset) {    return status(NOT_FOUND, content, charset);  }
public static Result notFound(JsonNode content, JsonEncoding encoding) {    return status(NOT_FOUND, content, encoding);  }
public static Result notFound(File content, boolean inline) {    return notFound(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notFound(File content, String filename) {    return notFound(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notFound(Path content, boolean inline) {    return notFound(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notFound(Path content, String filename) {    return notFound(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notFound(Path content, String filename, FileMimeTypes fileMimeTypes) {    return status(NOT_FOUND, content, filename, fileMimeTypes);  }
public static Result notAcceptable(Content content, String charset) {    return status(NOT_ACCEPTABLE, content, charset);  }
public static Result notAcceptable(JsonNode content, JsonEncoding encoding) {    return status(NOT_ACCEPTABLE, content, encoding);  }
public static Result notAcceptable(File content, FileMimeTypes fileMimeTypes) {    return status(NOT_ACCEPTABLE, content, fileMimeTypes);  }
public static Result notAcceptable(File content, boolean inline) {    return notAcceptable(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notAcceptable(File content, String filename) {    return notAcceptable(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notAcceptable(Path content, boolean inline) {    return notAcceptable(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result notAcceptable(Path content, String filename) {    return notAcceptable(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unsupportedMediaType(String content, String charset) {    return status(UNSUPPORTED_MEDIA_TYPE, content, charset);  }
public static Result unsupportedMediaType(JsonNode content, JsonEncoding encoding) {    return status(UNSUPPORTED_MEDIA_TYPE, content, encoding);  }
public static Result unsupportedMediaType(File content, FileMimeTypes fileMimeTypes) {    return status(UNSUPPORTED_MEDIA_TYPE, content, fileMimeTypes);  }
public static Result unsupportedMediaType(File content, boolean inline) {    return unsupportedMediaType(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unsupportedMediaType(File content, String filename) {    return unsupportedMediaType(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unsupportedMediaType(Path content, boolean inline) {    return unsupportedMediaType(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result unsupportedMediaType(Path content, String filename) {    return unsupportedMediaType(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result preconditionRequired(Content content, String charset) {    return status(PRECONDITION_REQUIRED, content, charset);  }
public static Result preconditionRequired(JsonNode content, JsonEncoding encoding) {    return status(PRECONDITION_REQUIRED, content, encoding);  }
public static Result preconditionRequired(File content, FileMimeTypes fileMimeTypes) {    return status(PRECONDITION_REQUIRED, content, fileMimeTypes);  }
public static Result preconditionRequired(File content, boolean inline) {    return preconditionRequired(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result preconditionRequired(File content, String filename) {    return preconditionRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result preconditionRequired(Path content, boolean inline) {    return preconditionRequired(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result preconditionRequired(Path content, String filename) {    return preconditionRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result tooManyRequests(Content content, String charset) {    return status(TOO_MANY_REQUESTS, content, charset);  }
public static Result tooManyRequests(JsonNode content, JsonEncoding encoding) {    return status(TOO_MANY_REQUESTS, content, encoding);  }
public static Result tooManyRequests(File content, boolean inline) {    return tooManyRequests(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result tooManyRequests(File content, String filename) {    return tooManyRequests(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result tooManyRequests(File content, String filename, FileMimeTypes fileMimeTypes) {    return status(TOO_MANY_REQUESTS, content, filename, fileMimeTypes);  }
public static Result tooManyRequests(Path content, boolean inline) {    return tooManyRequests(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result tooManyRequests(Path content, String filename) {    return tooManyRequests(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result requestHeaderFieldsTooLarge(Content content, String charset) {    return status(REQUEST_HEADER_FIELDS_TOO_LARGE, content, charset);  }
public static Result requestHeaderFieldsTooLarge(JsonNode content, JsonEncoding encoding) {    return status(REQUEST_HEADER_FIELDS_TOO_LARGE, content, encoding);  }
public static Result requestHeaderFieldsTooLarge(File content, boolean inline) {    return requestHeaderFieldsTooLarge(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result requestHeaderFieldsTooLarge(File content, String filename) {    return requestHeaderFieldsTooLarge(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result requestHeaderFieldsTooLarge(Path content, boolean inline) {    return requestHeaderFieldsTooLarge(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result requestHeaderFieldsTooLarge(      Path content, boolean inline, FileMimeTypes fileMimeTypes) {    return status(REQUEST_HEADER_FIELDS_TOO_LARGE, content, inline, fileMimeTypes);  }
public static Result requestHeaderFieldsTooLarge(Path content, String filename) {    return requestHeaderFieldsTooLarge(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result internalServerError(String content, String charset) {    return status(INTERNAL_SERVER_ERROR, content, charset);  }
public static Result internalServerError(JsonNode content, JsonEncoding encoding) {    return status(INTERNAL_SERVER_ERROR, content, encoding);  }
public static Result internalServerError(File content, FileMimeTypes fileMimeTypes) {    return status(INTERNAL_SERVER_ERROR, content, fileMimeTypes);  }
public static Result internalServerError(File content, boolean inline) {    return internalServerError(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result internalServerError(File content, String filename) {    return internalServerError(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result internalServerError(Path content, boolean inline) {    return internalServerError(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result internalServerError(Path content, String filename) {    return internalServerError(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result networkAuthenticationRequired(Content content, String charset) {    return status(NETWORK_AUTHENTICATION_REQUIRED, content, charset);  }
public static Result networkAuthenticationRequired(JsonNode content, JsonEncoding encoding) {    return status(NETWORK_AUTHENTICATION_REQUIRED, content, encoding);  }
public static Result networkAuthenticationRequired(File content, FileMimeTypes fileMimeTypes) {    return status(NETWORK_AUTHENTICATION_REQUIRED, content, fileMimeTypes);  }
public static Result networkAuthenticationRequired(File content, boolean inline) {    return networkAuthenticationRequired(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result networkAuthenticationRequired(File content, String filename) {    return networkAuthenticationRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result networkAuthenticationRequired(Path content, boolean inline) {    return networkAuthenticationRequired(content, inline, StaticFileMimeTypes.fileMimeTypes());  }
public static Result networkAuthenticationRequired(Path content, String filename) {    return networkAuthenticationRequired(content, filename, StaticFileMimeTypes.fileMimeTypes());  }
public static Result movedPermanently(String url) {    return new Result(MOVED_PERMANENTLY, Collections.singletonMap(LOCATION, url));  }
public static Result movedPermanently(Call call) {    return new Result(MOVED_PERMANENTLY, Collections.singletonMap(LOCATION, call.path()));  }
public static Result found(String url) {    return new Result(FOUND, Collections.singletonMap(LOCATION, url));  }
public static Result found(Call call) {    return new Result(FOUND, Collections.singletonMap(LOCATION, call.path()));  }
public static Result seeOther(String url) {    return new Result(SEE_OTHER, Collections.singletonMap(LOCATION, url));  }
public static Result redirect(String url) {    return new Result(SEE_OTHER, Collections.singletonMap(LOCATION, url));  }
public static Result redirect(Call call) {    return new Result(SEE_OTHER, Collections.singletonMap(LOCATION, call.path()));  }
public static Result temporaryRedirect(String url) {    return new Result(TEMPORARY_REDIRECT, Collections.singletonMap(LOCATION, url));  }
public static Result temporaryRedirect(Call call) {    return new Result(TEMPORARY_REDIRECT, Collections.singletonMap(LOCATION, call.path()));  }
public static Result permanentRedirect(String url) {    return new Result(PERMANENT_REDIRECT, Collections.singletonMap(LOCATION, url));  }
public static Result permanentRedirect(Call call) {    return new Result(PERMANENT_REDIRECT, Collections.singletonMap(LOCATION, call.path()));  }
@Override  public User bind(String key, String id) {    // findById meant to be lightweight operation    User user = findById(Long.valueOf(id));    if (user == null) {      throw new IllegalArgumentException("User with id " + id + " not found");    }    return user;  }
private User findById(Long id) {    if (id > 3) return null;    User user = new User();    user.id = id;    user.name = "User " + String.valueOf(id);    return user;  }
public Lang preferred(Collection<Lang> candidates) {    return new Lang(        langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq()));  }
public Call unique() {    return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment());  }
public Call withFragment(String fragment) {    return new play.api.mvc.Call(method(), url(), fragment);  }
public String absoluteURL(Http.Request request) {    return absoluteURL(request.secure(), request.host());  }
public String webSocketURL(Http.Request request) {    return webSocketURL(request.secure(), request.host());  }
AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) {    return new AbstractFunction1<Connection, BoxedUnit>() {      public BoxedUnit apply(Connection connection) {        try {          block.run(connection);          return BoxedUnit.UNIT;        } catch (java.sql.SQLException e) {          throw new RuntimeException("Connection runnable failed", e);        }      }    };  }
<A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) {    return new AbstractFunction1<Connection, A>() {      public A apply(Connection connection) {        try {          return block.call(connection);        } catch (java.sql.SQLException e) {          throw new RuntimeException("Connection callable failed", e);        }      }    };  }
public Result show(String page) {    String content = Page.getContentOf(page);    return ok(content).as("text/html");  }
public static Server forRouter(Function<BuiltInComponents, Router> block) {    return forRouter(Mode.TEST, 0, block);  }
public static Server forRouter(Mode mode, Function<BuiltInComponents, Router> block) {    return forRouter(mode, 0, block);  }
public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) {    return new Builder().mode(mode).http(port).build(block);  }
public Result javascriptRoutes2(Http.Request request) {    return ok(        // #javascript-router-resource-custom-method        JavaScriptReverseRouter.create(            "jsRoutes",            "myAjaxMethod",            request.host(),            routes.javascript.Users.list(),            routes.javascript.Users.get())        // #javascript-router-resource-custom-method        )        .as(Http.MimeTypes.JAVASCRIPT);  }
public static JsonNode toJson(final Object data) {    try {      return mapper().valueToTree(data);    } catch (Exception e) {      throw new RuntimeException(e);    }  }
public static <A> A fromJson(JsonNode json, Class<A> clazz) {    try {      return mapper().treeToValue(json, clazz);    } catch (Exception e) {      throw new RuntimeException(e);    }  }
public static JsonNode parse(String src) {    try {      return mapper().readTree(src);    } catch (Throwable t) {      throw new RuntimeException(t);    }  }
public static JsonNode parse(java.io.InputStream src) {    try {      return mapper().readTree(src);    } catch (Throwable t) {      throw new RuntimeException(t);    }  }
@Override  public String sign(String message, byte[] key) {    return signer.sign(message, key);  }
public static JavaScript create(      String name, String ajaxMethod, String host, JavaScriptReverseRoute... routes) {    return play.api.routing.JavaScriptReverseRouter.apply(        name, Scala.Option(ajaxMethod), host, Scala.varargs(routes));  }
@Deprecated  public static JavaScript create(      String name, String ajaxMethod, JavaScriptReverseRoute... routes) {    return create(name, ajaxMethod, play.mvc.Http.Context.current().request().host(), routes);  }
@Deprecated  public static JavaScript create(String name, JavaScriptReverseRoute... routes) {    return create(name, "jQuery.ajax", routes);  }
public static <A extends Annotation> Annotation[] unwrapContainerAnnotations(      final A[] annotations) {    final List<Annotation> unwrappedAnnotations = new LinkedList<>();    for (final Annotation maybeContainerAnnotation : annotations) {      final List<Annotation> indirectlyPresentAnnotations =          getIndirectlyPresentAnnotations(maybeContainerAnnotation);      if (!indirectlyPresentAnnotations.isEmpty()) {        unwrappedAnnotations.addAll(indirectlyPresentAnnotations);      } else {        unwrappedAnnotations.add(maybeContainerAnnotation); // was not a container annotation      }    }    return unwrappedAnnotations.toArray(new Annotation[unwrappedAnnotations.size()]);  }
public static <A extends Annotation> List<Annotation> getIndirectlyPresentAnnotations(      final A maybeContainerAnnotation) {    try {      final Method method = maybeContainerAnnotation.annotationType().getMethod("value");      final Object o = method.invoke(maybeContainerAnnotation);      if (Annotation[].class.isAssignableFrom(o.getClass())) {        final Annotation[] indirectAnnotations = (Annotation[]) o;        if (indirectAnnotations.length > 0            && indirectAnnotations[0].annotationType().isAnnotationPresent(Repeatable.class)) {          return Arrays.asList(indirectAnnotations);        }      }    } catch (final NoSuchMethodException e) {      // That's ok, this just wasn't a container annotation -> continue    } catch (final SecurityException        | IllegalAccessException        | IllegalArgumentException        | InvocationTargetException e) {      throw new IllegalStateException(e);    }    return Collections.emptyList();  }
public static String relative(String startPath, String targetPath) {    // If the start and target path's are the same then link to the current directory    if (startPath.equals(targetPath)) {      return CURRENT_DIR;    }    String[] start = toSegments(canonical(startPath));    String[] target = toSegments(canonical(targetPath));    // If start path has no trailing separator (a "file" path), then drop file segment    if (!startPath.endsWith(SEPARATOR)) start = Arrays.copyOfRange(start, 0, start.length - 1);    // If target path has no trailing separator, then drop file segment, but keep a reference to add    // it later    String targetFile = "";    if (!targetPath.endsWith(SEPARATOR)) {      targetFile = target[target.length - 1];      target = Arrays.copyOfRange(target, 0, target.length - 1);    }    // Work out how much of the filepath is shared by start and path.    String[] common = commonPrefix(start, target);    String[] parents = toParentDirs(start.length - common.length);    int relativeStartIdx = common.length;    String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length);    String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length);    System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length);    // If this is not a sibling reference append a trailing / to path    String trailingSep = "";    if (relativePath.length > 0) trailingSep = SEPARATOR;    return Arrays.stream(relativePath).collect(Collectors.joining(SEPARATOR))        + trailingSep        + targetFile;  }
public static String canonical(String url) {    String[] urlPath = toSegments(url);    Stack<String> canonical = new Stack<>();    for (String comp : urlPath) {      if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue;      if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR)))        canonical.push(comp);      else canonical.pop();    }    String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : "";    String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : "";    return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep;  }
public Result hello(String name) {    // ###replace:    return ok(views.html.hello.render(name));    return ok(javaguide.hello.html.helloName.render(name));  }
public static List<Tuple<String, List<Object>>> displayableConstraint(      Set<ConstraintDescriptor<?>> constraints) {    return constraints        .parallelStream()        .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class))        .map(c -> displayableConstraint(c))        .collect(Collectors.toList());  }
public static List<Tuple<String, List<Object>>> displayableConstraint(      Set<ConstraintDescriptor<?>> constraints, Annotation[] orderedAnnotations) {    final List<Annotation> constraintAnnot =        constraints.stream().map(c -> c.getAnnotation()).collect(Collectors.<Annotation>toList());    return Stream.of(orderedAnnotations)        .filter(            constraintAnnot                ::contains) // only use annotations for which we actually have a constraint        .filter(a -> a.annotationType().isAnnotationPresent(Display.class))        .map(            a ->                displayableConstraint(                    constraints                        .parallelStream()                        .filter(c -> c.getAnnotation().equals(a))                        .findFirst()                        .get()))        .collect(Collectors.toList());  }
public static Tuple<String, List<Object>> displayableConstraint(      ConstraintDescriptor<?> constraint) {    final Display displayAnnotation =        constraint.getAnnotation().annotationType().getAnnotation(Display.class);    return Tuple(        displayAnnotation.name(),        Collections.unmodifiableList(            Stream.of(displayAnnotation.attributes())                .map(attr -> constraint.getAttributes().get(attr))                .collect(Collectors.toList())));  }
public CompletionStage<Long> runningWithTransaction() {    return CompletableFuture.supplyAsync(        () -> {          // lambda is an instance of Function<EntityManager, Long>          return jpaApi.withTransaction(              entityManager -> {                Query query = entityManager.createNativeQuery("select max(age) from people");                return (Long) query.getSingleResult();              });        },        executionContext);  }
public CompletionStage<Void> runningWithRunnable() {    // lambda is an instance of Consumer<EntityManager>    return CompletableFuture.runAsync(        () -> {          jpaApi.withTransaction(              entityManager -> {                Query query =                    entityManager.createNativeQuery("update people set active = 1 where age > 18");                query.executeUpdate();              });        },        executionContext);  }
@Override  public <A> CompletionStage<A> timeout(      final CompletionStage<A> stage, final long amount, final TimeUnit unit) {    requireNonNull(stage, "Null stage");    requireNonNull(unit, "Null unit");    FiniteDuration duration = FiniteDuration.apply(amount, unit);    return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage)));  }
@Override  public <A> CompletionStage<A> timeout(final CompletionStage<A> stage, final Duration duration) {    requireNonNull(stage, "Null stage");    requireNonNull(duration, "Null duration");    FiniteDuration finiteDuration =        FiniteDuration.apply(duration.toMillis(), TimeUnit.MILLISECONDS);    return toJava(delegate.timeout(finiteDuration, Scala.asScalaWithFuture(() -> stage)));  }
@Override  public <A> CompletionStage<A> delayed(      final Callable<CompletionStage<A>> callable, long amount, TimeUnit unit) {    requireNonNull(callable, "Null callable");    requireNonNull(amount, "Null amount");    requireNonNull(unit, "Null unit");    FiniteDuration duration = FiniteDuration.apply(amount, unit);    return toJava(delegate.delayed(duration, Scala.asScalaWithFuture(callable)));  }
@Override  public <A> CompletionStage<A> delayed(      final Callable<CompletionStage<A>> callable, Duration duration) {    requireNonNull(callable, "Null callable");    requireNonNull(duration, "Null duration");    FiniteDuration finiteDuration =        FiniteDuration.apply(duration.toMillis(), TimeUnit.MILLISECONDS);    return toJava(delegate.delayed(finiteDuration, Scala.asScalaWithFuture(callable)));  }
public static boolean isAssignable(      Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {    if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) {      return false;    }    if (classArray == null) {      classArray = EMPTY_CLASS_ARRAY;    }    if (toClassArray == null) {      toClassArray = EMPTY_CLASS_ARRAY;    }    for (int i = 0; i < classArray.length; i++) {      if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {        return false;      }    }    return true;  }
public static Date parseCRONExpression(String cron) {    try {      return new CronExpression(cron).getNextValidTimeAfter(new Date());    } catch (Exception e) {      throw new IllegalArgumentException("Invalid CRON pattern : " + cron, e);    }  }
public static long cronInterval(String cron, Date date) {    try {      return new CronExpression(cron).getNextInterval(date);    } catch (Exception e) {      throw new IllegalArgumentException("Invalid CRON pattern : " + cron, e);    }  }
public static AhcWSClient create(      AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) {    final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer);    return new AhcWSClient(client, materializer);  }
@Test  public void createNewRoutingDsl() {    play.mvc.BodyParser.Default bodyParser =        app.injector().instanceOf(play.mvc.BodyParser.Default.class);    JavaContextComponents javaContextComponents =        app.injector().instanceOf(JavaContextComponents.class);    // #new-routing-dsl    RoutingDsl routingDsl = new RoutingDsl(bodyParser, javaContextComponents);    // #new-routing-dsl    Router router =        routingDsl.GET("/hello/:to").routingTo((request, to) -> ok("Hello " + to)).build();    assertThat(makeRequest(router, "GET", "/hello/world"), equalTo("Hello world"));  }
public GuiceApplicationBuilder builder(ApplicationLoader.Context context) {    return initialBuilder        .in(context.environment())        .loadConfig(context.initialConfig())        .overrides(overrides(context));  }
protected GuiceableModule[] overrides(ApplicationLoader.Context context) {    scala.collection.Seq<GuiceableModule> seq =        play.api.inject.guice.GuiceApplicationLoader$.MODULE$.defaultOverrides(context.asScala());    return Scala.asArray(GuiceableModule.class, seq);  }
public static Result TODO(Request request) {    return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala()));  }
@Deprecated  public static void session(String key, String value) {    session().put(key, value);  }
@Deprecated  public static void flash(String key, String value) {    flash().put(key, value);  }
@With(PassArgAction.class)  public static Result passArgIndex(Http.Request request) {    User user = request.attrs().get(Attrs.USER);    return ok(Json.toJson(user));  }
public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) {    return underlying.qualifiedWith(instance).asJava();  }
public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) {    return underlying.qualifiedWith(annotation).asJava();  }
public Binding<T> to(final Class<? extends T> implementation) {    return underlying.to(implementation).asJava();  }
public Binding<T> to(final Provider<? extends T> provider) {    return underlying.to(provider).asJava();  }
public <A extends T> Binding<T> to(final Supplier<A> instance) {    return underlying.to(new FromJavaSupplier<>(instance)).asJava();  }
public Binding<T> to(final BindingKey<? extends T> key) {    return underlying.to(key.asScala()).asJava();  }
public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider) {    return underlying.toProvider(provider).asJava();  }
public static Caffeine<Object, Object> from(Config config) {    CaffeineParser parser = new CaffeineParser(config);    config.entrySet().stream().map(Map.Entry::getKey).forEach(parser::parse);    return parser.cacheBuilder;  }
public static Lang forCode(String code) {    try {      return new Lang(play.api.i18n.Lang.apply(code));    } catch (Exception e) {      return null;    }  }
public static List<Lang> availables(Application app) {    play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class);    List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables());    return availableLangs.stream().map(Lang::new).collect(toList());  }
public static Lang preferred(Application app, List<Lang> availableLangs) {    play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class);    Stream<Lang> stream = availableLangs.stream();    List<play.api.i18n.Lang> langSeq =        stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList());    return new Lang(langs.preferred(Scala.toSeq(langSeq)));  }
public static play.api.db.evolutions.EvolutionsReader fromClassLoader(ClassLoader classLoader) {    return fromClassLoader(classLoader, "");  }
public static play.api.db.evolutions.EvolutionsReader fromClassLoader(      ClassLoader classLoader, String prefix) {    return new play.api.db.evolutions.ClassLoaderEvolutionsReader(classLoader, prefix);  }
public static play.api.db.evolutions.EvolutionsReader fromMap(      Map<String, List<Evolution>> evolutions) {    return new SimpleEvolutionsReader(evolutions);  }
public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) {    Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>();    map.put("default", Arrays.asList(evolutions));    return fromMap(map);  }
public static void applyEvolutions(      Database database,      play.api.db.evolutions.EvolutionsReader reader,      boolean autocommit,      String schema) {    DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema);    evolutions.evolve(evolutions.scripts(reader), autocommit);  }
public static void applyEvolutions(      Database database, play.api.db.evolutions.EvolutionsReader reader, String schema) {    applyEvolutions(database, reader, true, schema);  }
public static void cleanupEvolutions(Database database, boolean autocommit, String schema) {    DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema);    evolutions.evolve(evolutions.resetScripts(), autocommit);  }
public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) {    return newBuilder(        delegate.loadConfig(            func(                (play.api.Environment env) ->                    new play.api.Configuration(load.apply(new Environment(env))))));  }
public GuiceApplicationBuilder withModuleLoader(      BiFunction<Environment, Config, List<GuiceableModule>> loader) {    return newBuilder(        delegate.load(            func(                (play.api.Environment env, play.api.Configuration conf) ->                    Scala.toSeq(loader.apply(new Environment(env), conf.underlying())))));  }
public GuiceApplicationBuilder load(GuiceableModule... modules) {    return newBuilder(delegate.load(Scala.varargs(modules)));  }
public GuiceApplicationBuilder load(com.google.inject.Module... modules) {    return load(Guiceable.modules(modules));  }
public GuiceApplicationBuilder load(play.api.inject.Module... modules) {    return load(Guiceable.modules(modules));  }
public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) {    return load(Guiceable.bindings(bindings));  }
protected GuiceApplicationBuilder newBuilder(      play.api.inject.guice.GuiceApplicationBuilder builder) {    return new GuiceApplicationBuilder(builder);  }
public String encode(Cookie cookie) {    if (cookie == null) {      throw new NullPointerException("cookie");    }    StringBuilder buf = new StringBuilder();    encode(buf, cookie);    return stripTrailingSeparator(buf);  }
public String encode(Cookie... cookies) {    if (cookies == null) {      throw new NullPointerException("cookies");    }    if (cookies.length == 0) {      return null;    }    StringBuilder buf = new StringBuilder();    for (Cookie c : cookies) {      if (c == null) {        break;      }      encode(buf, c);    }    return stripTrailingSeparatorOrNull(buf);  }
public String encode(Iterable<? extends Cookie> cookies) {    if (cookies == null) {      throw new NullPointerException("cookies");    }    Iterator<? extends Cookie> cookiesIt = cookies.iterator();    if (!cookiesIt.hasNext()) {      return null;    }    StringBuilder buf = new StringBuilder();    while (cookiesIt.hasNext()) {      Cookie c = cookiesIt.next();      if (c == null) {        break;      }      encode(buf, c);    }    return stripTrailingSeparatorOrNull(buf);  }
public EntityManager em() {    Deque<EntityManager> ems = this.emStack(true);    if (ems.isEmpty()) {      Http.Context.safeCurrent()          .map(              ctx -> {                throw new RuntimeException(                    "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional");              })          .orElseGet(              () -> {                throw new RuntimeException(                    "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.");              });    }    return ems.peekFirst();  }
@SuppressWarnings("unchecked")  public Deque<EntityManager> emStack(boolean threadLocalFallback) {    return Http.Context.safeCurrent()        .map(            context -> {              Object emsObject = context.args.get(CURRENT_ENTITY_MANAGER);              if (emsObject != null) {                return (Deque<EntityManager>) emsObject;              } else {                Deque<EntityManager> ems = new ArrayDeque<>();                context.args.put(CURRENT_ENTITY_MANAGER, ems);                return ems;              }            })        .orElseGet(            () -> {              // Not a web request              if (threadLocalFallback) {                return this.get();              } else {                throw new RuntimeException(                    "No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.");              }            });  }
void pushOrPopEm(EntityManager em, boolean threadLocalFallback) {    Deque<EntityManager> ems = this.emStack(threadLocalFallback);    if (em != null) {      ems.push(em);    } else {      if (ems.isEmpty()) {        throw new IllegalStateException("Tried to remove the EntityManager, but none was set.");      }      ems.pop();    }  }
@Test  public void fromJson() {    // #from-json    // parse the JSON as a JsonNode    JsonNode json = Json.parse("{\"firstName\":\"Foo\", \"lastName\":\"Bar\", \"age\":13}");    // read the JsonNode as a Person    Person person = Json.fromJson(json, Person.class);    // #from-json    assertThat(person.firstName, equalTo("Foo"));    assertThat(person.lastName, equalTo("Bar"));    assertThat(person.age, equalTo(13));  }
public Result sayHello(Http.Request request) {    Document dom = request.body().asXml();    if (dom == null) {      return badRequest("Expecting Xml data");    } else {      String name = XPath.selectText("//name", dom);      if (name == null) {        return badRequest("Missing parameter [name]");      } else {        return ok("Hello " + name);      }    }  }
@BodyParser.Of(BodyParser.Xml.class)  public Result sayHelloBP(Http.Request request) {    Document dom = request.body().asXml();    if (dom == null) {      return badRequest("Expecting Xml data");    } else {      String name = XPath.selectText("//name", dom);      if (name == null) {        return badRequest("Missing parameter [name]");      } else {        return ok("Hello " + name);      }    }  }
public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith(      Function<In, F.Either<FlowIn, Out>> splitter, Flow<FlowIn, Out, ?> flow) {    return bypassWith(        Flow.<In>create().map(splitter::apply),        play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2),        flow);  }
public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith(      Flow<In, F.Either<FlowIn, Out>, ?> splitter,      Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy,      Flow<FlowIn, Out, ?> flow) {    return splitter.via(        Flow.fromGraph(            GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create(                builder -> {                  // Eager cancel must be true so that if the flow cancels, that will be propagated                  // upstream.                  // However, that means the bypasser must block cancel, since when this flow                  // finishes, the merge                  // will result in a cancel flowing up through the bypasser, which could lead to                  // dropped messages.                  // Using scaladsl here because of https://github.com/akka/akka/issues/18384                  UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast =                      builder.add(Broadcast.create(2, true));                  UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy);                  Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn =                      Flow.<F.Either<FlowIn, Out>>create()                          .collect(                              Scala.partialFunction(                                  x -> {                                    if (x.left.isPresent()) {                                      return x.left.get();                                    } else {                                      throw Scala.noMatch();                                    }                                  }));                  Flow<F.Either<FlowIn, Out>, Out, ?> collectOut =                      Flow.<F.Either<FlowIn, Out>>create()                          .collect(                              Scala.partialFunction(                                  x -> {                                    if (x.right.isPresent()) {                                      return x.right.get();                                    } else {                                      throw Scala.noMatch();                                    }                                  }));                  Flow<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>, ?> blockCancel =                      play.api.libs.streams.AkkaStreams                          .<F.Either<FlowIn, Out>>ignoreAfterCancellation()                          .asJava();                  // Normal flow                  builder                      .from(broadcast.out(0))                      .via(builder.add(collectIn))                      .via(builder.add(flow))                      .toInlet(merge.in(0));                  // Bypass flow, need to ignore downstream finish                  builder                      .from(broadcast.out(1))                      .via(builder.add(blockCancel))                      .via(builder.add(collectOut))                      .toInlet(merge.in(1));                  return new FlowShape<>(broadcast.in(), merge.out());                })));  }
public static <In, Out> Flow<In, Out, ?> actorRef(      Function<ActorRef, Props> props,      int bufferSize,      OverflowStrategy overflowStrategy,      ActorRefFactory factory,      Materializer mat) {    return play.api.libs.streams.ActorFlow.<In, Out>actorRef(            new AbstractFunction1<ActorRef, Props>() {              @Override              public Props apply(ActorRef v1) {                return props.apply(v1);              }            },            bufferSize,            overflowStrategy,            factory,            mat)        .asJava();  }
@Deprecated  public Form<T> bindFromRequest(String... allowedFields) {    return bind(        play.mvc.Controller.ctx().messages().lang(),        play.mvc.Controller.request().attrs(),        requestData(play.mvc.Controller.request()),        requestFileData(play.mvc.Controller.request()),        allowedFields);  }
public Form<T> bindFromRequest(Http.Request request, String... allowedFields) {    return bind(        this.messagesApi.preferred(request).lang(),        request.attrs(),        requestData(request),        requestFileData(request),        allowedFields);  }
@Deprecated  public Form<T> bindFromRequest(Map<String, String[]> requestData, String... allowedFields) {    return bindFromRequestData(ctxLang(), ctxRequestAttrs(), requestData, allowedFields);  }
public Form<T> bindFromRequestData(      Lang lang, TypedMap attrs, Map<String, String[]> requestData, String... allowedFields) {    return bindFromRequestData(lang, attrs, requestData, Collections.emptyMap(), allowedFields);  }
@Deprecated  public Form<T> bind(JsonNode data, String... allowedFields) {    return bind(ctxLang(), ctxRequestAttrs(), data, allowedFields);  }
public Form<T> bind(Lang lang, TypedMap attrs, JsonNode data, String... allowedFields) {    return bind(        lang,        attrs,        play.libs.Scala.asJava(            play.api.data.FormUtils.fromJson(                "", play.api.libs.json.Json.parse(play.libs.Json.stringify(data)))),        allowedFields);  }
protected String getMessageForConstraintViolation(ConstraintViolation<Object> violation) {    String errorMessage = violation.getMessage();    Annotation annotation = violation.getConstraintDescriptor().getAnnotation();    if (annotation instanceof Constraints.ValidateWith) {      Constraints.ValidateWith validateWithAnnotation = (Constraints.ValidateWith) annotation;      if (violation.getMessage().equals(Constraints.ValidateWithValidator.defaultMessage)) {        Constraints.ValidateWithValidator validateWithValidator =            new Constraints.ValidateWithValidator();        validateWithValidator.initialize(validateWithAnnotation);        Tuple<String, Object[]> errorMessageKey = validateWithValidator.getErrorMessageKey();        if (errorMessageKey != null && errorMessageKey._1 != null) {          errorMessage = errorMessageKey._1;        }      }    }    if (annotation instanceof Constraints.ValidatePayloadWith) {      Constraints.ValidatePayloadWith validatePayloadWithAnnotation =          (Constraints.ValidatePayloadWith) annotation;      if (violation.getMessage().equals(Constraints.ValidatePayloadWithValidator.defaultMessage)) {        Constraints.ValidatePayloadWithValidator validatePayloadWithValidator =            new Constraints.ValidatePayloadWithValidator();        validatePayloadWithValidator.initialize(validatePayloadWithAnnotation);        Tuple<String, Object[]> errorMessageKey = validatePayloadWithValidator.getErrorMessageKey();        if (errorMessageKey != null && errorMessageKey._1 != null) {          errorMessage = errorMessageKey._1;        }      }    }    return errorMessage;  }
@SuppressWarnings("unchecked")  @Deprecated  public Form<T> bind(Map<String, String> data, String... allowedFields) {    return bind(ctxLang(), ctxRequestAttrs(), data, allowedFields);  }
@SuppressWarnings("unchecked")  public Form<T> bind(      Lang lang, TypedMap attrs, Map<String, String> data, String... allowedFields) {    return bind(lang, attrs, data, Collections.emptyMap(), allowedFields);  }
@SuppressWarnings("unchecked")  public Form<T> bind(      Lang lang,      TypedMap attrs,      Map<String, String> data,      Map<String, Http.MultipartFormData.FilePart<?>> files,      String... allowedFields) {    final DataBinder dataBinder = dataBinder(allowedFields);    final Map<String, Object> objectDataFinal = getObjectData(data, files);    final Set<ConstraintViolation<Object>> validationErrors =        runValidation(lang, attrs, dataBinder, objectDataFinal);    final BindingResult result = dataBinder.getBindingResult();    validationErrors.forEach(violation -> addConstraintViolationToBindingResult(violation, result));    boolean hasAnyError = result.hasErrors() || result.getGlobalErrorCount() > 0;    if (hasAnyError) {      final List<ValidationError> errors = getFieldErrorsAsValidationErrors(lang, result);      final List<ValidationError> globalErrors = globalErrorsAsValidationErrors(result);      errors.addAll(globalErrors);      return new Form<>(          rootName,          backedType,          data,          files,          errors,          Optional.ofNullable((T) result.getTarget()),          groups,          messagesApi,          formatters,          this.validatorFactory,          config,          lang,          directFieldAccess);    }    return new Form<>(        rootName,        backedType,        data,        files,        errors,        Optional.ofNullable((T) result.getTarget()),        groups,        messagesApi,        formatters,        this.validatorFactory,        config,        lang,        directFieldAccess);  }
private List<Object> convertErrorArguments(Object[] arguments) {    if (arguments == null) {      return Collections.emptyList();    }    List<Object> converted =        Arrays.stream(arguments)            .filter(                arg ->                    !(arg                        instanceof                        org.springframework.context.support.DefaultMessageSourceResolvable))            .collect(Collectors.toList());    return Collections.unmodifiableList(converted);  }
public Form<T> fill(T value) {    if (value == null) {      throw new RuntimeException("Cannot fill a form with a null value");    }    return new Form<>(        rootName,        backedType,        new HashMap<>(),        new HashMap<>(),        new ArrayList<>(),        Optional.ofNullable(value),        groups,        messagesApi,        formatters,        validatorFactory,        config,        lang,        directFieldAccess);  }
public List<ValidationError> globalErrors() {    return Collections.unmodifiableList(        errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList()));  }
public JsonNode errorsAsJson(Lang lang) {    Map<String, List<String>> allMessages = new HashMap<>();    errors.forEach(        error -> {          if (error != null) {            final List<String> messages = new ArrayList<>();            if (messagesApi != null && lang != null) {              final List<String> reversedMessages = new ArrayList<>(error.messages());              Collections.reverse(reversedMessages);              messages.add(                  messagesApi.get(                      lang,                      reversedMessages,                      translateMsgArg(error.arguments(), messagesApi, lang)));            } else {              messages.add(error.message());            }            allMessages.put(error.key(), messages);          }        });    return play.libs.Json.toJson(allMessages);  }
public T get(Lang lang) {    if (!errors.isEmpty()) {      throw new IllegalStateException("Error(s) binding form: " + errorsAsJson(lang));    }    return value.get();  }
public Field field(final String key, final Lang lang) {    // Value    String fieldValue = null;    Http.MultipartFormData.FilePart file = null;    if (rawData.containsKey(key)) {      fieldValue = rawData.get(key);    } else if (files.containsKey(key)) {      file = files.get(key);    } else {      if (value.isPresent()) {        BeanWrapper beanWrapper = new BeanWrapperImpl(value.get());        beanWrapper.setAutoGrowNestedPaths(true);        String objectKey = key;        if (rootName != null && key.startsWith(rootName + ".")) {          objectKey = key.substring(rootName.length() + 1);        }        if (beanWrapper.isReadableProperty(objectKey)) {          Object oValue = beanWrapper.getPropertyValue(objectKey);          if (oValue != null) {            if (oValue instanceof Http.MultipartFormData.FilePart<?>) {              file = (Http.MultipartFormData.FilePart<?>) oValue;            } else {              if (formatters != null) {                final String objectKeyFinal = objectKey;                fieldValue =                    withRequestLocale(                        lang,                        () ->                            formatters.print(                                beanWrapper.getPropertyTypeDescriptor(objectKeyFinal), oValue));              } else {                fieldValue = oValue.toString();              }            }          }        }      }    }    // Format    Tuple<String, List<Object>> format = null;    BeanWrapper beanWrapper = new BeanWrapperImpl(blankInstance());    beanWrapper.setAutoGrowNestedPaths(true);    try {      for (Annotation a : beanWrapper.getPropertyTypeDescriptor(key).getAnnotations()) {        Class<?> annotationType = a.annotationType();        if (annotationType.isAnnotationPresent(play.data.Form.Display.class)) {          play.data.Form.Display d = annotationType.getAnnotation(play.data.Form.Display.class);          if (d.name().startsWith("format.")) {            List<Object> attributes = new ArrayList<>();            for (String attr : d.attributes()) {              Object attrValue = null;              try {                attrValue = a.getClass().getDeclaredMethod(attr).invoke(a);              } catch (Exception e) {                // do nothing              }              attributes.add(attrValue);            }            format = Tuple(d.name(), Collections.unmodifiableList(attributes));          }        }      }    } catch (NullPointerException e) {      // do nothing    }    // Constraints    List<Tuple<String, List<Object>>> constraints = new ArrayList<>();    Class<?> classType = backedType;    String leafKey = key;    if (rootName != null && leafKey.startsWith(rootName + ".")) {      leafKey = leafKey.substring(rootName.length() + 1);    }    int p = leafKey.lastIndexOf('.');    if (p > 0) {      classType = beanWrapper.getPropertyType(leafKey.substring(0, p));      leafKey = leafKey.substring(p + 1);    }    if (classType != null && this.validatorFactory != null) {      BeanDescriptor beanDescriptor =          this.validatorFactory.getValidator().getConstraintsForClass(classType);      if (beanDescriptor != null) {        PropertyDescriptor property = beanDescriptor.getConstraintsForProperty(leafKey);        if (property != null) {          Annotation[] orderedAnnotations = null;          for (Class<?> c = classType;              c != null;              c = c.getSuperclass()) { // we also check the fields of all superclasses            java.lang.reflect.Field field = null;            try {              field = c.getDeclaredField(leafKey);            } catch (NoSuchFieldException | SecurityException e) {              continue;            }            // getDeclaredAnnotations also looks for private fields; also it provides the            // annotations in a guaranteed order            orderedAnnotations =                AnnotationUtils.unwrapContainerAnnotations(field.getDeclaredAnnotations());            break;          }          constraints =              Constraints.displayableConstraint(                  property                      .findConstraints()                      .unorderedAndMatchingGroups(                          groups != null ? groups : new Class[] {Default.class})                      .getConstraintDescriptors(),                  orderedAnnotations);        }      }    }    return new Field(this, key, constraints, format, errors(key), fieldValue, file);  }
public Form<T> withLang(Lang lang) {    return new Form<T>(        this.rootName,        this.backedType,        this.rawData,        this.files,        this.errors,        this.value,        this.groups,        this.messagesApi,        this.formatters,        this.validatorFactory,        this.config,        lang,        this.directFieldAccess);  }
private static <T> T withRequestLocale(Lang lang, Supplier<T> code) {    try {      LocaleContextHolder.setLocale(lang != null ? lang.toLocale() : null);    } catch (Exception e) {      // Just continue (Maybe there is no context or some internal error in LocaleContextHolder).      // System default locale will be used.    }    try {      return code.get();    } finally {      LocaleContextHolder.resetLocaleContext(); // Clean up ThreadLocal    }  }
public String get(String key) {    try {      return (String) get().getData().get(asNormalKey(key));    } catch (Exception e) {      return null;    }  }
public <A> Http.MultipartFormData.FilePart<A> file(String key) {    try {      return (Http.MultipartFormData.FilePart<A>) get().getData().get(asNormalKey(key));    } catch (Exception e) {      return null;    }  }
public Optional<Object> value(String key) {    return super.value().map(v -> v.getData().get(asNormalKey(key)));  }
public DynamicForm fill(Map<String, Object> value) {    Form<Dynamic> form = super.fill(new Dynamic(value));    return new DynamicForm(        form.rawData(),        form.files(),        form.errors(),        form.value(),        messagesApi,        formatters,        validatorFactory,        config,        lang().orElse(null));  }
static String asDynamicKey(String key) {    if (key.isEmpty() || MATCHES_DATA.matcher(key).matches()) {      return key;    } else {      return "data[" + key + "]";    }  }
public <T> T parse(String text, Class<T> clazz) {    return conversion.convert(text, clazz);  }
@SuppressWarnings("unchecked")  public <T> T parse(Field field, String text) {    return (T) conversion.convert(text, new TypeDescriptor(field));  }
public <T> String print(T t) {    if (t == null) {      return "";    }    if (conversion.canConvert(t.getClass(), String.class)) {      return conversion.convert(t, String.class);    } else {      return t.toString();    }  }
public <T> String print(Field field, T t) {    return print(new TypeDescriptor(field), t);  }
public <T> String print(TypeDescriptor desc, T t) {    if (t == null) {      return "";    }    if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) {      return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class));    } else if (conversion.canConvert(t.getClass(), String.class)) {      return conversion.convert(t, String.class);    } else {      return t.toString();    }  }
private Formatters registerOptional() {    conversion.addConverter(        new GenericConverter() {          public Object convert(              Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {            if (sourceType.getObjectType().equals(String.class)) {              // From String to Optional              Object element =                  conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source));              return Optional.ofNullable(element);            } else if (targetType.getObjectType().equals(String.class)) {              // From Optional to String              if (source == null) return "";              Optional<?> opt = (Optional) source;              return opt.map(                      o ->                          conversion.convert(                              source, sourceType.getElementTypeDescriptor(), targetType))                  .orElse("");            }            return null;          }          public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {            Set<ConvertiblePair> result = new HashSet<>();            result.add(new ConvertiblePair(Optional.class, String.class));            result.add(new ConvertiblePair(String.class, Optional.class));            return result;          }        });    return this;  }
public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) {    conversion.addFormatterForFieldType(        clazz,        new org.springframework.format.Formatter<T>() {          public T parse(String text, Locale locale) throws java.text.ParseException {            return formatter.parse(text, locale);          }          public String print(T t, Locale locale) {            return formatter.print(t, locale);          }          public String toString() {            return formatter.toString();          }        });    return this;  }
@SuppressWarnings("unchecked")  public <A extends Annotation, T> Formatters register(      final Class<T> clazz, final AnnotationFormatter<A, T> formatter) {    final Class<? extends Annotation> annotationType =        (Class<? extends Annotation>)            GenericTypeResolver.resolveTypeArguments(                formatter.getClass(), AnnotationFormatter.class)[0];    conversion.addConverter(        new ConditionalGenericConverter() {          public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {            Set<GenericConverter.ConvertiblePair> types = new HashSet<>();            types.add(new GenericConverter.ConvertiblePair(clazz, String.class));            return types;          }          public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {            return (sourceType.getAnnotation(annotationType) != null);          }          public Object convert(              Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {            final A a = (A) sourceType.getAnnotation(annotationType);            Locale locale = LocaleContextHolder.getLocale();            try {              return formatter.print(a, (T) source, locale);            } catch (Exception ex) {              throw new ConversionFailedException(sourceType, targetType, source, ex);            }          }          public String toString() {            return "@"                + annotationType.getName()                + " "                + clazz.getName()                + " -> "                + String.class.getName()                + ": "                + formatter;          }        });    conversion.addConverter(        new ConditionalGenericConverter() {          public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {            Set<GenericConverter.ConvertiblePair> types = new HashSet<>();            types.add(new GenericConverter.ConvertiblePair(String.class, clazz));            return types;          }          public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {            return (targetType.getAnnotation(annotationType) != null);          }          public Object convert(              Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {            final A a = (A) targetType.getAnnotation(annotationType);            Locale locale = LocaleContextHolder.getLocale();            try {              return formatter.parse(a, (String) source, locale);            } catch (Exception ex) {              throw new ConversionFailedException(sourceType, targetType, source, ex);            }          }          public String toString() {            return String.class.getName()                + " -> @"                + annotationType.getName()                + " "                + clazz.getName()                + ": "                + formatter;          }        });    return this;  }
public String encode(Cookie cookie) {    if (cookie == null) {      throw new NullPointerException("cookie");    }    final String name = cookie.name();    final String value = cookie.value() != null ? cookie.value() : "";    validateCookie(name, value);    StringBuilder buf = new StringBuilder();    if (cookie.wrap()) {      addQuoted(buf, name, value);    } else {      add(buf, name, value);    }    if (cookie.maxAge() != Integer.MIN_VALUE) {      add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge());      Date expires =          cookie.maxAge() <= 0              ? new Date(0) // Set expires to the Unix epoch              : new Date(cookie.maxAge() * 1000L + System.currentTimeMillis());      add(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires));    }    if (cookie.sameSite() != null) {      add(buf, CookieHeaderNames.SAMESITE, cookie.sameSite());    }    if (cookie.path() != null) {      add(buf, CookieHeaderNames.PATH, cookie.path());    }    if (cookie.domain() != null) {      add(buf, CookieHeaderNames.DOMAIN, cookie.domain());    }    if (cookie.isSecure()) {      add(buf, CookieHeaderNames.SECURE);    }    if (cookie.isHttpOnly()) {      add(buf, CookieHeaderNames.HTTPONLY);    }    return stripTrailingSeparator(buf);  }
public List<String> encode(Cookie... cookies) {    if (cookies == null) {      throw new NullPointerException("cookies");    }    if (cookies.length == 0) {      return Collections.emptyList();    }    List<String> encoded = new ArrayList<String>(cookies.length);    for (Cookie c : cookies) {      if (c == null) {        break;      }      encoded.add(encode(c));    }    return encoded;  }
public List<String> encode(Collection<? extends Cookie> cookies) {    if (cookies == null) {      throw new NullPointerException("cookies");    }    if (cookies.isEmpty()) {      return Collections.emptyList();    }    List<String> encoded = new ArrayList<String>(cookies.size());    for (Cookie c : cookies) {      if (c == null) {        break;      }      encoded.add(encode(c));    }    return encoded;  }
public List<String> encode(Iterable<? extends Cookie> cookies) {    if (cookies == null) {      throw new NullPointerException("cookies");    }    if (cookies.iterator().hasNext()) {      return Collections.emptyList();    }    List<String> encoded = new ArrayList<String>();    for (Cookie c : cookies) {      if (c == null) {        break;      }      encoded.add(encode(c));    }    return encoded;  }
public Set<Cookie> decode(String header) {    if (header == null) {      throw new NullPointerException("header");    }    final int headerLen = header.length();    if (headerLen == 0) {      return Collections.emptySet();    }    Set<Cookie> cookies = new TreeSet<Cookie>();    int i = 0;    boolean rfc2965Style = false;    if (header.regionMatches(true, 0, RFC2965_VERSION, 0, RFC2965_VERSION.length())) {      // RFC 2965 style cookie, move to after version value      i = header.indexOf(';') + 1;      rfc2965Style = true;    }    loop:    for (; ; ) {      // Skip spaces and separators.      for (; ; ) {        if (i == headerLen) {          break loop;        }        char c = header.charAt(i);        if (c == '\t' || c == '\n' || c == 0x0b || c == '\f' || c == '\r' || c == ' ' || c == ','            || c == ';') {          i++;          continue;        }        break;      }      int nameBegin = i;      int nameEnd = i;      int valueBegin = -1;      int valueEnd = -1;      if (i != headerLen) {        keyValLoop:        for (; ; ) {          char curChar = header.charAt(i);          if (curChar == ';') {            // NAME; (no value till ';')            nameEnd = i;            valueBegin = valueEnd = -1;            break keyValLoop;          } else if (curChar == '=') {            // NAME=VALUE            nameEnd = i;            i++;            if (i == headerLen) {              // NAME= (empty value, i.e. nothing after '=')              valueBegin = valueEnd = 0;              break keyValLoop;            }            valueBegin = i;            // NAME=VALUE;            int semiPos = header.indexOf(';', i);            valueEnd = i = semiPos > 0 ? semiPos : headerLen;            break keyValLoop;          } else {            i++;          }          if (i == headerLen) {            // NAME (no value till the end of string)            nameEnd = headerLen;            valueBegin = valueEnd = -1;            break;          }        }      }      if (rfc2965Style          && (header.regionMatches(nameBegin, RFC2965_PATH, 0, RFC2965_PATH.length())              || header.regionMatches(nameBegin, RFC2965_DOMAIN, 0, RFC2965_DOMAIN.length())              || header.regionMatches(nameBegin, RFC2965_PORT, 0, RFC2965_PORT.length()))) {        // skip obsolete RFC2965 fields        continue;      }      DefaultCookie cookie = initCookie(header, nameBegin, nameEnd, valueBegin, valueEnd);      if (cookie != null) {        cookies.add(cookie);      }    }    return cookies;  }
public static Result ofStream(Http.Request request, InputStream stream) {    return JavaRangeResult.ofStream(stream, rangeHeader(request), null, Optional.empty());  }
@Deprecated  public static Result ofStream(InputStream stream, long contentLength) {    return ofStream(Http.Context.current().request(), stream, contentLength);  }
public static Result ofPath(Http.Request request, Path path) {    return ofPath(request, path, StaticFileMimeTypes.fileMimeTypes());  }
public static Result ofPath(Http.Request request, Path path, FileMimeTypes fileMimeTypes) {    return JavaRangeResult.ofPath(        path, rangeHeader(request), fileMimeTypes.forFileName(path.toFile().getName()));  }
@Deprecated  public static Result ofPath(Path path, String fileName) {    return ofPath(Http.Context.current().request(), path, fileName);  }
public static Result ofPath(      Http.Request request, Path path, String fileName, FileMimeTypes fileMimeTypes) {    return JavaRangeResult.ofPath(        path, rangeHeader(request), fileName, fileMimeTypes.forFileName(fileName));  }
@Deprecated  public static Result ofFile(File file, String fileName) {    return ofFile(Http.Context.current().request(), file, fileName);  }
public static Result ofFile(Http.Request request, File file, String fileName) {    return ofFile(request, file, fileName, StaticFileMimeTypes.fileMimeTypes());  }
public static Result ofFile(      Http.Request request, File file, String fileName, FileMimeTypes fileMimeTypes) {    return JavaRangeResult.ofFile(        file, rangeHeader(request), fileName, fileMimeTypes.forFileName(fileName));  }
@Deprecated  public static Result ofSource(      Long entityLength, Source<ByteString, ?> source, String fileName, String contentType) {    return ofSource(Http.Context.current().request(), entityLength, source, fileName, contentType);  }
public static Result ofSource(      Http.Request request,      Long entityLength,      Source<ByteString, ?> source,      String fileName,      String contentType) {    return JavaRangeResult.ofSource(        entityLength,        source,        rangeHeader(request),        Optional.ofNullable(fileName),        Optional.ofNullable(contentType));  }
public static NodeList selectNodes(String path, Object node) {    return selectNodes(path, node, null);  }
public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) {        return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList();    }
public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) {        return toSeq(java.util.Arrays.asList(array));    }
@SafeVarargs    public static <T> scala.collection.immutable.Seq<T> varargs(T... array) {        return toSeq(array);    }
public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) {    return new MappedWebSocketAcceptor<>(        Scala.partialFunction(            message -> {              try {                if (message instanceof Message.Binary) {                  return F.Either.Left(                      play.libs.Json.mapper()                          .readValue(                              ((Message.Binary) message).data().iterator().asInputStream(), in));                } else if (message instanceof Message.Text) {                  return F.Either.Left(                      play.libs.Json.mapper().readValue(((Message.Text) message).data(), in));                }              } catch (Exception e) {                return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage()));              }              throw Scala.noMatch();            }),        outMessage -> {          try {            return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage));          } catch (Exception e) {            throw new RuntimeException(e);          }        });  }
private static <In, Out> WebSocket acceptOrResult(      PartialFunction<Message, F.Either<In, Message>> inMapper,      Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f,      Function<Out, Message> outMapper) {    return new WebSocket() {      @Override      public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply(          Http.RequestHeader request) {        return f.apply(request)            .thenApply(                resultOrFlow -> {                  if (resultOrFlow.left.isPresent()) {                    return F.Either.Left(resultOrFlow.left.get());                  } else {                    Flow<Message, Message, ?> flow =                        AkkaStreams.bypassWith(                            Flow.<Message>create().collect(inMapper),                            play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2),                            resultOrFlow.right.get().map(outMapper::apply));                    return F.Either.Right(flow);                  }                });      }    };  }
static boolean isAccessible(final Member m) {    return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();  }
static boolean setAccessibleWorkaround(final AccessibleObject o) {    if (o == null || o.isAccessible()) {      return false;    }    final Member m = (Member) o;    if (!o.isAccessible()        && Modifier.isPublic(m.getModifiers())        && isPackageAccess(m.getDeclaringClass().getModifiers())) {      try {        o.setAccessible(true);        return true;      } catch (final SecurityException e) { // NOPMD        // ignore in favor of subsequent IllegalAccessException      }    }    return false;  }
static int compareConstructorFit(      final Constructor<?> left, final Constructor<?> right, final Class<?>[] actual) {    return compareParameterTypes(Executable.of(left), Executable.of(right), actual);  }
static int compareMethodFit(final Method left, final Method right, final Class<?>[] actual) {    return compareParameterTypes(Executable.of(left), Executable.of(right), actual);  }
private static int compareParameterTypes(      final Executable left, final Executable right, final Class<?>[] actual) {    final float leftCost = getTotalTransformationCost(actual, left);    final float rightCost = getTotalTransformationCost(actual, right);    return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;  }
private static float getPrimitivePromotionCost(      final Class<?> srcClass, final Class<?> destClass) {    float cost = 0.0f;    Class<?> cls = srcClass;    if (!cls.isPrimitive()) {      // slight unwrapping penalty      cost += 0.1f;      cls = ClassUtils.wrapperToPrimitive(cls);    }    for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {      if (cls == ORDERED_PRIMITIVE_TYPES[i]) {        cost += 0.1f;        if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {          cls = ORDERED_PRIMITIVE_TYPES[i + 1];        }      }    }    return cost;  }
private static float getTotalTransformationCost(      final Class<?>[] srcArgs, final Executable executable) {    final Class<?>[] destArgs = executable.getParameterTypes();    final boolean isVarArgs = executable.isVarArgs();    // "source" and "destination" are the actual and declared args respectively.    float totalCost = 0.0f;    final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length;    if (srcArgs.length < normalArgsLen) {      return Float.MAX_VALUE;    }    for (int i = 0; i < normalArgsLen; i++) {      totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]);    }    if (isVarArgs) {      // When isVarArgs is true, srcArgs and dstArgs may differ in length.      // There are two special cases to consider:      final boolean noVarArgsPassed = srcArgs.length < destArgs.length;      final boolean explicitArrayForVarags =          srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray();      final float varArgsCost = 0.001f;      final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType();      if (noVarArgsPassed) {        // When no varargs passed, the best match is the most generic matching type, not the most        // specific.        totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost;      } else if (explicitArrayForVarags) {        final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType();        totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost;      } else {        // This is typical varargs case.        for (int i = destArgs.length - 1; i < srcArgs.length; i++) {          final Class<?> srcClass = srcArgs[i];          totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost;        }      }    }    return totalCost;  }
private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) {    if (destClass.isPrimitive()) {      return getPrimitivePromotionCost(srcClass, destClass);    }    float cost = 0.0f;    while (srcClass != null && !destClass.equals(srcClass)) {      if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {        // slight penalty for interface match.        // we still want an exact match to override an interface match,        // but        // an interface match should override anything where we have to        // get a superclass.        cost += 0.25f;        break;      }      cost++;      srcClass = srcClass.getSuperclass();    }    /*     * If the destination class is null, we've traveled all the way up to     * an Object match. We'll penalize this by adding 1.5 to the cost.     */    if (srcClass == null) {      cost += 1.5f;    }    return cost;  }
private MessagesApi explicitMessagesApi() {    return new play.i18n.MessagesApi(        new play.api.i18n.DefaultMessagesApi(            Collections.singletonMap(                Lang.defaultLang().code(), Collections.singletonMap("foo", "bar")),            new play.api.i18n.DefaultLangs().asJava()));  }
public String at(String key, Object... args) {    return messagesApi.get(lang, key, args);  }
public String at(List<String> keys, Object... args) {    return messagesApi.get(lang, keys, args);  }
public static Database createFrom(      String name, String driver, String url, Map<String, ? extends Object> config) {    ImmutableMap.Builder<String, Object> dbConfig = new ImmutableMap.Builder<String, Object>();    dbConfig.put("driver", driver);    dbConfig.put("url", url);    dbConfig.putAll(config);    return new DefaultDatabase(name, dbConfig.build());  }
public static Database createFrom(String name, String driver, String url) {    return createFrom(name, driver, url, ImmutableMap.<String, Object>of());  }
public static Database createFrom(      String driver, String url, Map<String, ? extends Object> config) {    return createFrom("default", driver, url, config);  }
public static Database inMemory(String name, String url, Map<String, ? extends Object> config) {    return createFrom(name, "org.h2.Driver", url, config);  }
public static Database inMemory(      String name, Map<String, String> urlOptions, Map<String, ? extends Object> config) {    StringBuilder urlExtra = new StringBuilder();    for (Map.Entry<String, String> option : urlOptions.entrySet()) {      urlExtra.append(';').append(option.getKey()).append('=').append(option.getValue());    }    String url = "jdbc:h2:mem:" + name + urlExtra;    return inMemory(name, url, config);  }
public static Database inMemory(String name, Map<String, ? extends Object> config) {    return inMemory(name, "jdbc:h2:mem:" + name, config);  }
public static Database inMemory(String name) {    return inMemory(name, ImmutableMap.<String, Object>of());  }
public static Database inMemoryWith(String k1, Object v1) {    return inMemory(ImmutableMap.of(k1, v1));  }
public static Database inMemoryWith(      String k1, Object v1, String k2, Object v2, String k3, Object v3) {    return inMemory(ImmutableMap.of(k1, v1, k2, v2, k3, v3));  }
public static BeanMap create(Object bean) {        Generator gen = new Generator();        gen.setBean(bean);        return gen.create();    }
public Set entrySet() {        HashMap copy = new HashMap();        for (Iterator it = keySet().iterator(); it.hasNext();) {            Object key = it.next();            copy.put(key, get(key));        }        return Collections.unmodifiableMap(copy).entrySet();    }
public static ParallelSorter create(Object[] arrays) {        Generator gen = new Generator();        gen.setArrays(arrays);        return gen.create();    }
public void quickSort(int index, int lo, int hi, Comparator cmp) {        chooseComparer(index, cmp);        super.quickSort(lo, hi - 1);    }
public void mergeSort(int index, int lo, int hi, Comparator cmp) {        chooseComparer(index, cmp);        super.mergeSort(lo, hi - 1);    }
private void emitIndexBySignature(List methods) {        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SIGNATURE_GET_INDEX, null);        List signatures = CollectionUtils.transform(methods, new Transformer() {            public Object transform(Object obj) {                return ReflectUtils.getSignature((Method)obj).toString();            }        });        e.load_arg(0);        e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);        signatureSwitchHelper(e, signatures);        e.end_method();    }
private void emitIndexByClassArray(List methods) {        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, METHOD_GET_INDEX, null);        if (methods.size() > TOO_MANY_METHODS) {            // hack for big classes            List signatures = CollectionUtils.transform(methods, new Transformer() {                public Object transform(Object obj) {                    String s = ReflectUtils.getSignature((Method)obj).toString();                    return s.substring(0, s.lastIndexOf(')') + 1);                }            });            e.load_args();            e.invoke_static(FAST_CLASS, GET_SIGNATURE_WITHOUT_RETURN_TYPE);            signatureSwitchHelper(e, signatures);        } else {            e.load_args();            List info = CollectionUtils.transform(methods, MethodInfoTransformer.getInstance());            EmitUtils.method_switch(e, info, new GetIndexCallback(e, info));        }        e.end_method();    }
public static Mixin create(Object[] delegates) {        Generator gen = new Generator();        gen.setDelegates(delegates);        return gen.create();    }
public static Mixin create(Class[] interfaces, Object[] delegates) {        Generator gen = new Generator();        gen.setClasses(interfaces);        gen.setDelegates(delegates);        return gen.create();    }
public static Mixin createBean(ClassLoader loader,Object[] beans) {        Generator gen = new Generator();        gen.setStyle(STYLE_BEANS);        gen.setDelegates(beans);        gen.setClassLoader(loader);        return gen.create();    }
private static Route route(Object[] delegates) {        Object key = ClassesKey.create(delegates);        Route route = (Route)ROUTE_CACHE.get(key);        if (route == null) {            ROUTE_CACHE.put(key, route = new Route(delegates));        }        return route;    }
public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {        MethodProxy proxy = new MethodProxy();        proxy.sig1 = new Signature(name1, desc);        proxy.sig2 = new Signature(name2, desc);        proxy.createInfo = new CreateInfo(c1, c2);        return proxy;    }
public static MethodProxy find(Class type, Signature sig) {        try {            Method m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME,                                              MethodInterceptorGenerator.FIND_PROXY_TYPES);            return (MethodProxy)m.invoke(null, new Object[]{ sig });        } catch (NoSuchMethodException e) {            throw new IllegalArgumentException("Class " + type + " does not use a MethodInterceptor");        } catch (IllegalAccessException e) {            throw new CodeGenerationException(e);        } catch (InvocationTargetException e) {            throw new CodeGenerationException(e);        }    }
public Object invoke(Object obj, Object[] args) throws Throwable {        try {            init();            FastClassInfo fci = fastClassInfo;            return fci.f1.invoke(fci.i1, obj, args);        } catch (InvocationTargetException e) {            throw e.getTargetException();        } catch (IllegalArgumentException e) {            if (fastClassInfo.i1 < 0)                throw new IllegalArgumentException("Protected method: " + sig1);            throw e;        }    }
public Object invokeSuper(Object obj, Object[] args) throws Throwable {        try {            init();            FastClassInfo fci = fastClassInfo;            return fci.f2.invoke(fci.i2, obj, args);        } catch (InvocationTargetException e) {            throw e.getTargetException();        }    }
public void cast_numeric(Type from, Type to) {        if (from != to) {            if (from == Type.DOUBLE_TYPE) {                if (to == Type.FLOAT_TYPE) {                    mv.visitInsn(Constants.D2F);                } else if (to == Type.LONG_TYPE) {                    mv.visitInsn(Constants.D2L);                } else {                    mv.visitInsn(Constants.D2I);                    cast_numeric(Type.INT_TYPE, to);                }            } else if (from == Type.FLOAT_TYPE) {                if (to == Type.DOUBLE_TYPE) {                    mv.visitInsn(Constants.F2D);                } else if (to == Type.LONG_TYPE) {                    mv.visitInsn(Constants.F2L);                } else {                    mv.visitInsn(Constants.F2I);                    cast_numeric(Type.INT_TYPE, to);                }            } else if (from == Type.LONG_TYPE) {                if (to == Type.DOUBLE_TYPE) {                    mv.visitInsn(Constants.L2D);                } else if (to == Type.FLOAT_TYPE) {                    mv.visitInsn(Constants.L2F);                } else {                    mv.visitInsn(Constants.L2I);                    cast_numeric(Type.INT_TYPE, to);                }            } else {                if (to == Type.BYTE_TYPE) {                    mv.visitInsn(Constants.I2B);                } else if (to == Type.CHAR_TYPE) {                    mv.visitInsn(Constants.I2C);                } else if (to == Type.DOUBLE_TYPE) {                    mv.visitInsn(Constants.I2D);                } else if (to == Type.FLOAT_TYPE) {                    mv.visitInsn(Constants.I2F);                } else if (to == Type.LONG_TYPE) {                    mv.visitInsn(Constants.I2L);                } else if (to == Type.SHORT_TYPE) {                    mv.visitInsn(Constants.I2S);                }            }        }    }
public void load_arg(int index) {        load_local(state.argumentTypes[index],                   state.localOffset + skipArgs(index));    }
public void load_args(int fromArg, int count) {        int pos = state.localOffset + skipArgs(fromArg);        for (int i = 0; i < count; i++) {            Type t = state.argumentTypes[fromArg + i];            load_local(t, pos);            pos += t.getSize();        }    }
void emit_field(int opcode, Type ctype, String name, Type ftype) {        mv.visitFieldInsn(opcode,                          ctype.getInternalName(),                          name,                          ftype.getDescriptor());    }
public void box(Type type) {        if (TypeUtils.isPrimitive(type)) {            if (type == Type.VOID_TYPE) {                aconst_null();            } else {                Type boxed = TypeUtils.getBoxedType(type);                new_instance(boxed);                if (type.getSize() == 2) {                    // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o                    dup_x2();                    dup_x2();                    pop();                } else {                    // p -> po -> opo -> oop -> o                    dup_x1();                    swap();                }                invoke_constructor(boxed, new Signature(Constants.CONSTRUCTOR_NAME, Type.VOID_TYPE, new Type[]{ type }));            }        }    }
public void unbox(Type type) {        Type t = Constants.TYPE_NUMBER;        Signature sig = null;        switch (type.getSort()) {        case Type.VOID:            return;        case Type.CHAR:            t = Constants.TYPE_CHARACTER;            sig = CHAR_VALUE;            break;        case Type.BOOLEAN:            t = Constants.TYPE_BOOLEAN;            sig = BOOLEAN_VALUE;            break;        case Type.DOUBLE:            sig = DOUBLE_VALUE;            break;        case Type.FLOAT:            sig = FLOAT_VALUE;            break;        case Type.LONG:            sig = LONG_VALUE;            break;        case Type.INT:        case Type.SHORT:        case Type.BYTE:            sig = INT_VALUE;        }        if (sig == null) {            checkcast(type);        } else {            checkcast(t);            invoke_virtual(t, sig);        }    }
public void create_arg_array() {        /* generates:           Object[] args = new Object[]{ arg1, new Integer(arg2) };         */        push(state.argumentTypes.length);        newarray();        for (int i = 0; i < state.argumentTypes.length; i++) {            dup();            push(i);            load_arg(i);            box(state.argumentTypes[i]);            aastore();        }    }
public void zero_or_null(Type type) {        if (TypeUtils.isPrimitive(type)) {            switch (type.getSort()) {            case Type.DOUBLE:                push(0d);                break;            case Type.LONG:                push(0L);                break;            case Type.FLOAT:                push(0f);                break;            case Type.VOID:                aconst_null();            default:                push(0);            }        } else {            aconst_null();        }    }
public void unbox_or_zero(Type type) {        if (TypeUtils.isPrimitive(type)) {            if (type != Type.VOID_TYPE) {                Label nonNull = make_label();                Label end = make_label();                dup();                ifnonnull(nonNull);                pop();                zero_or_null(type);                goTo(end);                mark(nonNull);                unbox(type);                mark(end);            }        } else {            checkcast(type);        }    }
public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {        Type componentType = TypeUtils.getComponentType(type);        Local array = e.make_local();        Local loopvar = e.make_local(Type.INT_TYPE);        Label loopbody = e.make_label();        Label checkloop = e.make_label();        e.store_local(array);        e.push(0);        e.store_local(loopvar);        e.goTo(checkloop);                e.mark(loopbody);        e.load_local(array);        e.load_local(loopvar);        e.array_load(componentType);        callback.processElement(componentType);        e.iinc(loopvar, 1);                e.mark(checkloop);        e.load_local(loopvar);        e.load_local(array);        e.arraylength();        e.if_icmp(e.LT, loopbody);    }
public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final CustomizerRegistry registry) {        (new ProcessArrayCallback() {            public void processElement(Type type) {                not_equals_helper(e, type, notEquals, registry, this);            }        }).processElement(type);    }
private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {        e.dup2();        Label nonNull = e.make_label();        Label oneNullHelper = e.make_label();        Label end = e.make_label();        e.ifnonnull(nonNull);        e.ifnonnull(oneNullHelper);        e.pop2();        e.goTo(bothNull);                e.mark(nonNull);        e.ifnull(oneNullHelper);        e.goTo(end);                e.mark(oneNullHelper);        e.pop2();        e.goTo(oneNull);                e.mark(end);    }
public static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {        Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));        if (set.contains(Constants.TYPE_THROWABLE))            return;        boolean needThrow = exceptions != null;        if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {            e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);            needThrow = true;        }        if (!set.contains(Constants.TYPE_ERROR)) {            e.catch_exception(handler, Constants.TYPE_ERROR);            needThrow = true;        }        if (exceptions != null) {            for (int i = 0; i < exceptions.length; i++) {                e.catch_exception(handler, exceptions[i]);            }        }        if (needThrow) {            e.athrow();        }        // e -> eo -> oeo -> ooe -> o        e.catch_exception(handler, Constants.TYPE_THROWABLE);        e.new_instance(wrapper);        e.dup_x1();        e.swap();        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);        e.athrow();    }
public Map/*<Signature, Signature>*/resolveAll() {        Map resolved = new HashMap();        for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) {            Map.Entry entry = (Map.Entry) entryIter.next();            Class owner = (Class) entry.getKey();            Set bridges = (Set) entry.getValue();            try {                InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + ".class");                if (is == null) {                    return resolved;                }                try {                    new ClassReader(is)                            .accept(new BridgedFinder(bridges, resolved),                                    ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);                } finally {                    is.close();                }            } catch (IOException ignored) {}        }        return resolved;    }
public void setSuperclass(Class superclass) {        if (superclass != null && superclass.isInterface()) {            setInterfaces(new Class[]{ superclass });        } else if (superclass != null && superclass.equals(Object.class)) {            // affects choice of ClassLoader            this.superclass = null;        } else {            this.superclass = superclass;        }    }
public void setCallbacks(Callback[] callbacks) {        if (callbacks != null && callbacks.length == 0) {            throw new IllegalArgumentException("Array cannot be empty");        }        this.callbacks = callbacks;    }
public void setCallbackTypes(Class[] callbackTypes) {        if (callbackTypes != null && callbackTypes.length == 0) {            throw new IllegalArgumentException("Array cannot be empty");        }        this.callbackTypes = CallbackInfo.determineTypes(callbackTypes);    }
public Object create(Class[] argumentTypes, Object[] arguments) {        classOnly = false;        if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {            throw new IllegalArgumentException("Arguments must be non-null and of equal length");        }        this.argumentTypes = argumentTypes;        this.arguments = arguments;        return createHelper();    }
public static void getMethods(Class superclass, Class[] interfaces, List methods)    {        getMethods(superclass, interfaces, methods, null, null);    }
protected void filterConstructors(Class sc, List constructors) {        CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));        if (constructors.size() == 0)            throw new IllegalArgumentException("No visible constructors in " + sc);    }
public static boolean isEnhanced(Class type) {        try {            getCallbacksSetter(type, SET_THREAD_CALLBACKS_NAME);            return true;        } catch (NoSuchMethodException e) {            return false;        }    }
private Object createUsingReflection(Class type) {        setThreadCallbacks(type, callbacks);        try{                if (argumentTypes != null) {        	             return ReflectUtils.newInstance(type, argumentTypes, arguments);                     } else {        	            return ReflectUtils.newInstance(type);                    }        }finally{         // clear thread callbacks to allow them to be gc'd         setThreadCallbacks(type, null);        }    }
public static Object create(Class type, Callback callback) {        Enhancer e = new Enhancer();        e.setSuperclass(type);        e.setCallback(callback);        return e.create();    }
public static Object create(Class superclass, Class interfaces[], Callback callback) {        Enhancer e = new Enhancer();        e.setSuperclass(superclass);        e.setInterfaces(interfaces);        e.setCallback(callback);        return e.create();    }
public static Object create(Class superclass, Class[] interfaces, CallbackFilter filter, Callback[] callbacks) {        Enhancer e = new Enhancer();        e.setSuperclass(superclass);        e.setInterfaces(interfaces);        e.setCallbackFilter(filter);        e.setCallbacks(callbacks);        return e.create();    }
public void setSuperclass(Class superclass) {        if (superclass != null && superclass.equals(Object.class)) {            superclass = null;        }        this.superclass = superclass;    }
private void getField(String[] names) throws Exception {        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null);        e.load_this();        e.load_arg(0);        EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {            public void processCase(Object key, Label end) {                Type type = (Type)fields.get(key);                e.getfield((String)key);                e.box(type);                e.return_value();            }            public void processDefault() {                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, "Unknown field name");            }        });        e.end_method();    }
public void add(Method method) {        add(ReflectUtils.getSignature(method),            ReflectUtils.getExceptionTypes(method));    }
public void add(Class clazz) {        Method[] methods = clazz.getMethods();        for (int i = 0; i < methods.length; i++) {            Method m = methods[i];            if (!m.getDeclaringClass().getName().equals("java.lang.Object")) {                add(m);            }        }    }
public int cardinality() {        int w = value;        int c = 0;        while (w != 0) {            c += T[w & 255];            w >>= 8;        }        return c;    }
public void setNamingPolicy(NamingPolicy namingPolicy) {        if (namingPolicy == null)            namingPolicy = DefaultNamingPolicy.INSTANCE;        this.namingPolicy = namingPolicy;    }
public void setStrategy(GeneratorStrategy strategy) {        if (strategy == null)            strategy = DefaultGeneratorStrategy.INSTANCE;        this.strategy = strategy;    }
protected V createEntry(final K key, KK cacheKey, Object v) {        FutureTask<V> task;        boolean creator = false;        if (v != null) {            // Another thread is already loading an instance            task = (FutureTask<V>) v;        } else {            task = new FutureTask<V>(new Callable<V>() {                public V call() throws Exception {                    return loader.apply(key);                }            });            Object prevTask = map.putIfAbsent(cacheKey, task);            if (prevTask == null) {                // creator does the load                creator = true;                task.run();            } else if (prevTask instanceof FutureTask) {                task = (FutureTask<V>) prevTask;            } else {                return (V) prevTask;            }        }        V result;        try {            result = task.get();        } catch (InterruptedException e) {            throw new IllegalStateException("Interrupted while loading cache item", e);        } catch (ExecutionException e) {            Throwable cause = e.getCause();            if (cause instanceof RuntimeException) {                throw ((RuntimeException) cause);            }            throw new IllegalStateException("Unable to load cache item", cause);        }        if (creator) {            map.put(cacheKey, result);        }        return result;    }
public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods)    {        Map map = new HashMap();        for (int i = 0; i < methods.length; i++) {            Method method = methods[i];            map.put(method.getName() + Type.getMethodDescriptor(method), method);        }        Method[] result = new Method[namesAndDescriptors.length / 2];        for (int i = 0; i < result.length; i++) {            result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);            if (result[i] == null) {                // TODO: error?            }        }        return result;    }
public static Path resolve(final Path base, String child) {		if (StringUtil.startsWithChar(child, File.separatorChar)) {			child = child.substring(1);		}		return base.resolve(child);	}
public static String readString(final Path path) throws IOException {		try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {			StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance			StreamUtil.copy(reader, writer);			return writer.toString();		}	}
public HttpRequest host(final String host) {		this.host = host;		if (headers.contains(HEADER_HOST)) {			headerOverwrite(HEADER_HOST, host);		}		return this;	}
public HttpRequest set(String destination) {		destination = destination.trim();		// http method, optional		int ndx = destination.indexOf(' ');		if (ndx != -1) {			String method = destination.substring(0, ndx).toUpperCase();			try {				HttpMethod httpMethod = HttpMethod.valueOf(method);				this.method = httpMethod.name();				destination = destination.substring(ndx + 1);			}			catch (IllegalArgumentException ignore) {				// unknown http method			}		}		// protocol		ndx = destination.indexOf("://");		if (ndx != -1) {			protocol = destination.substring(0, ndx);			destination = destination.substring(ndx + 3);		}		// host		ndx = destination.indexOf('/');		if (ndx == -1) {			ndx = destination.length();		}		if (ndx != 0) {			String hostToSet = destination.substring(0, ndx);			destination = destination.substring(ndx);			// port			ndx = hostToSet.indexOf(':');			if (ndx == -1) {				port = Defaults.DEFAULT_PORT;			} else {				port = Integer.parseInt(hostToSet.substring(ndx + 1));				hostToSet = hostToSet.substring(0, ndx);			}			host(hostToSet);		}		// path + query		path(destination);		return this;	}
public static HttpRequest create(final String method, final String destination) {		return new HttpRequest()				.method(method.toUpperCase())				.set(destination);	}
public static HttpRequest connect(final String destination) {		return new HttpRequest()				.method(HttpMethod.CONNECT)				.set(destination);	}
public static HttpRequest get(final String destination) {		return new HttpRequest()				.method(HttpMethod.GET)				.set(destination);	}
public static HttpRequest post(final String destination) {		return new HttpRequest()				.method(HttpMethod.POST)				.set(destination);	}
public static HttpRequest put(final String destination) {		return new HttpRequest()				.method(HttpMethod.PUT)				.set(destination);	}
public static HttpRequest patch(final String destination) {		return new HttpRequest()				.method(HttpMethod.PATCH)				.set(destination);	}
public static HttpRequest delete(final String destination) {		return new HttpRequest()				.method(HttpMethod.DELETE)				.set(destination);	}
public static HttpRequest head(final String destination) {		return new HttpRequest()				.method(HttpMethod.HEAD)				.set(destination);	}
public static HttpRequest trace(final String destination) {		return new HttpRequest()				.method(HttpMethod.TRACE)				.set(destination);	}
public static HttpRequest options(final String destination) {		return new HttpRequest()				.method(HttpMethod.OPTIONS)				.set(destination);	}
public HttpRequest path(String path) {		// this must be the only place that sets the path		if (!path.startsWith(StringPool.SLASH)) {			path = StringPool.SLASH + path;		}		int ndx = path.indexOf('?');		if (ndx != -1) {			String queryString = path.substring(ndx + 1);			path = path.substring(0, ndx);			query = HttpUtil.parseQuery(queryString, true);		} else {			query = HttpMultiMap.newCaseInsensitiveMap();		}		this.path = path;		return this;	}
public HttpRequest cookies(final Cookie... cookies) {		if (cookies.length == 0) {			return this;		}		StringBuilder cookieString = new StringBuilder();		boolean first = true;		for (Cookie cookie : cookies) {			Integer maxAge = cookie.getMaxAge();			if (maxAge != null && maxAge.intValue() == 0) {				continue;			}			if (!first) {				cookieString.append("; ");			}			first = false;			cookieString.append(cookie.getName());			cookieString.append('=');			cookieString.append(cookie.getValue());		}		headerOverwrite("cookie", cookieString.toString());		return this;	}
public HttpRequest query(final String name, final String value) {		query.add(name, value);		return this;	}
public HttpRequest query(final String name1, final Object value1, final Object... parameters) {		query(name1, value1 == null ? null : value1.toString());		for (int i = 0; i < parameters.length; i += 2) {			String name = parameters[i].toString();			String value = parameters[i + 1].toString();			query.add(name, value);		}		return this;	}
public HttpRequest query(final Map<String, String> queryMap) {		for (Map.Entry<String, String> entry : queryMap.entrySet()) {			query.add(entry.getKey(), entry.getValue());		}		return this;	}
public HttpRequest queryString(final String queryString, final boolean decode) {		this.query = HttpUtil.parseQuery(queryString, decode);		return this;	}
public String queryString() {		if (query == null) {			return StringPool.EMPTY;		}		return HttpUtil.buildQuery(query, queryEncoding);	}
public String url() {		StringBuilder url = new StringBuilder();		url.append(hostUrl());		if (path != null) {			url.append(path);		}		String queryString = queryString();		if (StringUtil.isNotBlank(queryString)) {			url.append('?');			url.append(queryString);		}		return url.toString();	}
public String hostUrl() {		StringBand url = new StringBand(8);		if (protocol != null) {			url.append(protocol);			url.append("://");		}		if (host != null) {			url.append(host);		}		if (port != Defaults.DEFAULT_PORT) {			url.append(':');			url.append(port);		}		return url.toString();	}
public HttpRequest basicAuthentication(final String username, final String password) {		if (username != null && password != null) {			String data = username.concat(StringPool.COLON).concat(password);			String base64 = Base64.encodeToString(data);			headerOverwrite(HEADER_AUTHORIZATION, "Basic " + base64);		}		return this;	}
public HttpRequest setHostHeader() {		String hostPort = this.host;		if (port != Defaults.DEFAULT_PORT) {			hostPort += StringPool.COLON + port;		}		headerOverwrite(HEADER_HOST, hostPort);		return this;	}
public HttpRequest open(final HttpConnectionProvider httpConnectionProvider) {		if (this.httpConnection != null) {			throw new HttpException("Connection already opened");		}		try {			this.httpConnectionProvider = httpConnectionProvider;			this.httpConnection = httpConnectionProvider.createHttpConnection(this);		} catch (IOException ioex) {			throw new HttpException("Can't connect to: " + url(), ioex);		}		return this;	}
public HttpRequest open(final HttpConnection httpConnection) {		if (this.httpConnection != null) {			throw new HttpException("Connection already opened");		}		this.httpConnection = httpConnection;		this.httpConnectionProvider = null;		return this;	}
public HttpRequest keepAlive(final HttpResponse httpResponse, final boolean doContinue) {		boolean keepAlive = httpResponse.isConnectionPersistent();		if (keepAlive) {			HttpConnection previousConnection = httpResponse.getHttpRequest().httpConnection;			if (previousConnection != null) {				// keep using the connection!				this.httpConnection = previousConnection;				this.httpConnectionProvider = httpResponse.getHttpRequest().connectionProvider();			}			//keepAlive = true; (already set)		} else {			// close previous connection			httpResponse.close();			// force keep-alive on new request			keepAlive = true;		}		// if we don't want to continue with this persistent session, mark this connection as closed		if (!doContinue) {			keepAlive = false;		}		connectionKeepAlive(keepAlive);		// if connection is not opened, open it using previous connection provider		if (httpConnection == null) {			open(httpResponse.getHttpRequest().connectionProvider());		}		return this;	}
public HttpResponse send() {		if (!followRedirects) {			return _send();		}		int redirects = this.maxRedirects;		while (redirects > 0) {			redirects--;			final HttpResponse httpResponse = _send();			final int statusCode = httpResponse.statusCode();			if (HttpStatus.isRedirect(statusCode)) {				_reset();				set(httpResponse.location());				continue;			}			return httpResponse;		}		throw new HttpException("Max number of redirects exceeded: " + this.maxRedirects);	}
@Override	protected Buffer buffer(final boolean fullRequest) {		// INITIALIZATION		// host port		if (header(HEADER_HOST) == null) {			setHostHeader();		}		// form		Buffer formBuffer = formBuffer();		// query string		String queryString = queryString();		// user-agent		if (header("User-Agent") == null) {			header("User-Agent", Defaults.userAgent);		}		// POST method requires Content-Type to be set		if (method.equals("POST") && (contentLength() == null)) {			contentLength(0);		}		// BUILD OUT		Buffer request = new Buffer();		request.append(method)			.append(SPACE)			.append(path);		if (query != null && !query.isEmpty()) {			request.append('?');			request.append(queryString);		}		request.append(SPACE)			.append(httpVersion)			.append(CRLF);		populateHeaderAndBody(request, formBuffer, fullRequest);		return request;	}
public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) {		return responseHandler.apply(send());	}
protected Session createSession(Properties properties) {		if (properties == null) {			properties = System.getProperties();		}		this.session = Session.getInstance(properties);		return session;	}
public T set(final Properties properties) throws MailException {		checkSessionNotSet();		this.properties.putAll(properties);		return _this();	}
public T set(final String name, final String value) {		checkSessionNotSet();		properties.setProperty(name, value);		return _this();	}
public void addError(final String message) {		if (config.collectErrors) {			if (errors == null) {				errors = new ArrayList<>();			}			errors.add(message);		}	}
static Handler removeRange(final Handler firstHandler, final Label start, final Label end) {    if (firstHandler == null) {      return null;    } else {      firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end);    }    int handlerStart = firstHandler.startPc.bytecodeOffset;    int handlerEnd = firstHandler.endPc.bytecodeOffset;    int rangeStart = start.bytecodeOffset;    int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset;    // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect.    if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) {      return firstHandler;    }    if (rangeStart <= handlerStart) {      if (rangeEnd >= handlerEnd) {        // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler.        return firstHandler.nextHandler;      } else {        // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[        return new Handler(firstHandler, end, firstHandler.endPc);      }    } else if (rangeEnd >= handlerEnd) {      // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[      return new Handler(firstHandler, firstHandler.startPc, start);    } else {      // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ =      //     [handlerStart,rangeStart[ + [rangeEnd,handerEnd[      firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc);      return new Handler(firstHandler, firstHandler.startPc, start);    }  }
static int getExceptionTableLength(final Handler firstHandler) {    int length = 0;    Handler handler = firstHandler;    while (handler != null) {      length++;      handler = handler.nextHandler;    }    return length;  }
static void putExceptionTable(final Handler firstHandler, final ByteVector output) {    output.putShort(getExceptionTableLength(firstHandler));    Handler handler = firstHandler;    while (handler != null) {      output          .putShort(handler.startPc.bytecodeOffset)          .putShort(handler.endPc.bytecodeOffset)          .putShort(handler.handlerPc.bytecodeOffset)          .putShort(handler.catchType);      handler = handler.nextHandler;    }  }
protected void collectActionInterceptors() {		final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors();		interceptors = new ArrayList<>();		interceptors.addAll(interceptorValues);		interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName()));	}
protected void collectActionFilters() {		final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters();		filters = new ArrayList<>();		filters.addAll(filterValues);		filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName()));	}
protected void collectActionResults() {		final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults();		results = new ArrayList<>();		results.addAll(resultsValues);		results.sort(Comparator.comparing(a -> a.getClass().getSimpleName()));	}
protected void collectActionRuntimes() {		actions = actionsManager.getAllActionRuntimes();		actions.sort(Comparator.comparing(ActionRuntime::getActionPath));	}
protected void resolveNestedProperties(final BeanProperty bp) {		String name = bp.name;		int dotNdx;		while ((dotNdx = indexOfDot(name)) != -1) {			bp.last = false;			bp.setName(name.substring(0, dotNdx));			bp.updateBean(getIndexProperty(bp));			name = name.substring(dotNdx + 1);		}		bp.last = true;		bp.setName(name);	}
@Override	public boolean hasSimpleProperty(final Object bean, final String property) {		return hasSimpleProperty(new BeanProperty(this, bean, property));	}
@SuppressWarnings({"unchecked"})	protected void setSimpleProperty(final BeanProperty bp, final Object value) {		Setter setter = bp.getSetter(isDeclared);		// try: setter		if (setter != null) {			invokeSetter(setter, bp, value);			return;		}		// try: put("property", value)		if (bp.isMap()) {			((Map) bp.bean).put(bp.name, value);			return;		}		if (isSilent) {			return;		}		throw new BeanException("Simple property not found: " + bp.name, bp);	}
protected boolean hasIndexProperty(final BeanProperty bp) {		if (bp.bean == null) {			return false;		}		String indexString = extractIndex(bp);		if (indexString == null) {			return hasSimpleProperty(bp);		}		Object resultBean = getSimpleProperty(bp);		if (resultBean == null) {			return false;		}		// try: property[index]		if (resultBean.getClass().isArray()) {			int index = parseInt(indexString, bp);			return (index >= 0) && (index < Array.getLength(resultBean));		}		// try: list.get(index)		if (resultBean instanceof List) {			int index = parseInt(indexString, bp);			return (index >= 0) && (index < ((List)resultBean).size());		}		if (resultBean instanceof Map) {			return ((Map)resultBean).containsKey(indexString);		}		// failed		return false;	}
protected Object getIndexProperty(final BeanProperty bp) {		bp.indexString = extractIndex(bp);		Object value = _getIndexProperty(bp);		bp.indexString = null;		return value;	}
protected void setIndexProperty(final BeanProperty bp, final Object value) {		bp.indexString = extractIndex(bp);		_setIndexProperty(bp, value);		bp.indexString = null;	}
@Override	public void setProperty(final Object bean, final String name, final Object value) {		BeanProperty beanProperty = new BeanProperty(this, bean, name);		if (!isSilent) {			resolveNestedProperties(beanProperty);			setIndexProperty(beanProperty, value);		}		else {			try {				resolveNestedProperties(beanProperty);				setIndexProperty(beanProperty, value);			}			catch (Exception ignore) {}		}	}
@Override	public <T> T getProperty(final Object bean, final String name) {		BeanProperty beanProperty = new BeanProperty(this, bean, name);		if (!isSilent) {			resolveNestedProperties(beanProperty);			return (T) getIndexProperty(beanProperty);		}		else {			try {				resolveNestedProperties(beanProperty);				return (T) getIndexProperty(beanProperty);			}			catch (Exception ignore) {				return null;			}		}	}
@Override	public boolean hasProperty(final Object bean, final String name) {		BeanProperty beanProperty = new BeanProperty(this, bean, name);		if (!resolveExistingNestedProperties(beanProperty)) {			return false;		}		return hasIndexProperty(beanProperty);	}
@Override	public Class<?> getPropertyType(final Object bean, final String name) {		BeanProperty beanProperty = new BeanProperty(this, bean, name);		if (!resolveExistingNestedProperties(beanProperty)) {			return null;		}		hasIndexProperty(beanProperty);		return extractType(beanProperty);	}
@Override	public String extractThisReference(final String propertyName) {		int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS);		if (ndx == -1) {			return propertyName;		}		return propertyName.substring(0, ndx);	}
@Override	public PrintWriter getWriter() {		if (writer == null) {			writer = new FastCharArrayWriter();			printWriter = new PrintWriter(writer);		}		return printWriter;	}
protected void resetSoft() {		columnCount = 0;		paramCount = 0;		hintCount = 0;		if (tableRefs != null) {			tableRefs.clear();		}//		objectRefs = null;		if (columnData != null) {			columnData.clear();		}		if (parameters != null) {			parameters.clear();		}		if (hints != null) {			hints.clear();		}		//columnAliasType = defaultColumnAliasType;	}
public void setObjectReference(final String name, final Object object) {		if (objectRefs == null) {			objectRefs = new HashMap<>();		}		objectRefs.put(name, object);	}
public Object getObjectReference(final String name) {		if (objectRefs == null) {			return null;		}		return objectRefs.get(name);	}
public Object lookupObject(final String ref) {		Object value = getObjectReference(ref);		if (value == null) {			throw new DbSqlBuilderException("Invalid object reference: " + ref);		}		return value;	}
public DbEntityDescriptor getTableDescriptor(final String tableRef) {		if (tableRefs == null) {			return null;		}		TableRefData t = tableRefs.get(tableRef);		return t == null ? null : t.desc;	}
public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) {		for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) {			DbEntityDescriptor ded = entry.getValue().desc;			if (ded.findByPropertyName(columnRef) != null) {				return ded;			}		}		return null;	}
public String getTableAlias(final String tableRef) {		if (tableRefs == null) {			return null;		}		TableRefData t = tableRefs.get(tableRef);		return t == null ? null : t.alias;	}
public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) {		if (tableRefs == null) {			tableRefs = new HashMap<>();		}		TableRefData t = new TableRefData(ded, tableAlias);		if (tableRefs.put(tableReference, t) != null) {			throw new DbSqlBuilderException("Duplicated table reference: " + tableReference);		}	}
public void addParameter(final String name, final Object value, final DbEntityColumnDescriptor dec) {		if (parameters == null) {			parameters = new HashMap<>();		}		parameters.put(name, new ParameterValue(value, dec));	}
protected DbEntityDescriptor lookupName(final String entityName) {		DbEntityDescriptor ded = entityManager.lookupName(entityName);		if (ded == null) {			throw new DbSqlBuilderException("Entity name not registered: " + entityName);		}		return ded;	}
protected DbEntityDescriptor lookupTableRef(final String tableRef) {		DbEntityDescriptor ded = getTableDescriptor(tableRef);		if (ded == null) {			throw new DbSqlBuilderException("Table reference not used in this query: " + tableRef);		}		return ded;	}
protected void defineParameter(final StringBuilder query, String name, final Object value) {		if (name == null) {			name = getNextParameterName();		}		query.append(':').append(name);		addParameter(name, value, null);	}
public void registerHint(final String hint) {		if (hints == null) {			hints = new ArrayList<>(hintCount);		}		hints.add(hint);	}
@Override	public final boolean serialize(final JsonContext jsonContext, final T value) {		if (jsonContext.pushValue(value)) {			// prevent circular dependencies			return false;		}		serializeValue(jsonContext, value);		jsonContext.popValue();		return true;	}
@Override	public void inject(final ActionRequest actionRequest, final Targets targets) {		final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();		instancesInjector.inject(actionRequest, targets);		if (injectAttributes) {			injectAttributes(servletRequest, targets);		}		if (injectParameters) {			injectParameters(servletRequest, targets);			injectUploadedFiles(servletRequest, targets);		}		actionPathMacroInjector.inject(actionRequest, targets);	}
protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) {		final Enumeration<String> attributeNames = servletRequest.getAttributeNames();		while (attributeNames.hasMoreElements()) {			final String attrName = attributeNames.nextElement();			targets.forEachTargetAndIn(this, (target, in) -> {				final String name = in.matchedName(attrName);				if (name != null) {					final Object attrValue = servletRequest.getAttribute(attrName);					target.writeValue(name, attrValue, true);				}			});		}	}
protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) {		final boolean encode = encodeGetParams && servletRequest.getMethod().equals("GET");		final Enumeration<String> paramNames = servletRequest.getParameterNames();		while (paramNames.hasMoreElements()) {			final String paramName = paramNames.nextElement();			if (servletRequest.getAttribute(paramName) != null) {				continue;			}			targets.forEachTargetAndIn(this, (target, in) -> {				final String name = in.matchedName(paramName);				if (name != null) {					String[] paramValues = servletRequest.getParameterValues(paramName);					paramValues = ServletUtil.prepareParameters(						paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams);					if (paramValues != null) {						if (encode) {							for (int j = 0; j < paramValues.length; j++) {								final String p = paramValues[j];								if (p != null) {									final String encoding = madvocEncoding.getEncoding();									paramValues[j] = StringUtil.convertCharset(p, StringPool.ISO_8859_1, encoding);								}							}						}						final Object value = (paramValues.length != 1 ? paramValues : paramValues[0]);						target.writeValue(name, value, true);					}				}			});		}	}
protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) {		if (!(servletRequest instanceof MultipartRequestWrapper)) {			return;		}		final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest;		if (!multipartRequest.isMultipart()) {			return;		}		final Enumeration<String> paramNames = multipartRequest.getFileParameterNames();		while (paramNames.hasMoreElements()) {			final String paramName = paramNames.nextElement();			if (servletRequest.getAttribute(paramName) != null) {				continue;			}			targets.forEachTargetAndIn(this, (target, in) -> {				final String name = in.matchedName(paramName);				if (name != null) {					final FileUpload[] paramValues = multipartRequest.getFiles(paramName);					if (ignoreInvalidUploadFiles) {						for (int j = 0; j < paramValues.length; j++) {							final FileUpload paramValue = paramValues[j];							if ((!paramValue.isValid()) || (!paramValue.isUploaded())) {								paramValues[j] = null;							}						}					}					final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues);					target.writeValue(name, value, true);				}			});		}	}
@Override	public void outject(final ActionRequest actionRequest, final Targets targets) {		final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();		targets.forEachTargetAndOut(this, (target, out) -> {			final Object value = target.readValue(out);			servletRequest.setAttribute(out.name(), value);		});	}
public String convertPropertyNameToColumnName(final String propertyName) {		StringBuilder tableName = new StringBuilder(propertyName.length() * 2);		if (splitCamelCase) {			String convertedTableName = Format.fromCamelCase(propertyName, separatorChar);			tableName.append(convertedTableName);		} else {			tableName.append(propertyName);		}		if (!changeCase) {			return tableName.toString();		}		return uppercase ?				toUppercase(tableName).toString() :				toLowercase(tableName).toString();	}
public String convertColumnNameToPropertyName(final String columnName) {		StringBuilder propertyName = new StringBuilder(columnName.length());		int len = columnName.length();		if (splitCamelCase) {			boolean toUpper = false;			for (int i = 0; i < len; i++) {				char c = columnName.charAt(i);				if (c == separatorChar) {					toUpper = true;					continue;				}				if (toUpper) {					propertyName.append(Character.toUpperCase(c));					toUpper = false;				} else {					propertyName.append(Character.toLowerCase(c));				}			}			return propertyName.toString();		}		return columnName;	}
public String applyToColumnName(final String columnName) {		String propertyName = convertColumnNameToPropertyName(columnName);		return convertPropertyNameToColumnName(propertyName);	}
protected boolean[] convertValueToArray(final Object value) {		if (value instanceof Collection) {			final Collection collection = (Collection) value;			final boolean[] target = new boolean[collection.size()];			int i = 0;			for (final Object element : collection) {				target[i] = convertType(element);				i++;			}			return target;		}		if (value instanceof Iterable) {			final Iterable iterable = (Iterable) value;			final ArrayList<Boolean> booleanArrayList = new ArrayList<>();			for (final Object element : iterable) {				final boolean convertedValue = convertType(element);				booleanArrayList.add(Boolean.valueOf(convertedValue));            }						final boolean[] array = new boolean[booleanArrayList.size()];			for (int i = 0; i < booleanArrayList.size(); i++) {				final Boolean b = booleanArrayList.get(i);				array[i] = b.booleanValue();			}						return array;		}		if (value instanceof CharSequence) {			final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS);			return convertArrayToArray(strings);		}		// everything else:		return convertToSingleElementArray(value);	}
public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException {		T t = TypeConverterManager.get().convertType(value, sqlType);		set(st, index, t, dbSqlType);	}
@SuppressWarnings({"unchecked"})	protected <E> E prepareGetValue(final T t, final Class<E> destinationType) {		if (t == null) {			return null;		}		if (destinationType == null) {			return (E) t;		}		return TypeConverterManager.get().convertType(t, destinationType);	}
protected Set<T> getAll() {		final Set<T> set = new HashSet<>(wrappers.size());		set.addAll(wrappers.values());		return set;	}
public T resolve(final Class<? extends T> wrapperClass) {		String wrapperClassName = wrapperClass.getName();		T wrapper = lookup(wrapperClassName);		if (wrapper == null) {			wrapper = createWrapper(wrapperClass);			initializeWrapper(wrapper);			wrappers.put(wrapperClassName, wrapper);		}		return wrapper;	}
public T[] resolveAll(Class<? extends T>[] wrapperClasses) {		if (wrapperClasses == null) {			return null;		}		wrapperClasses = expand(wrapperClasses);		T[] result = createArray(wrapperClasses.length);		for (int i = 0; i < wrapperClasses.length; i++) {			result[i] = resolve(wrapperClasses[i]);		}		return result;	}
protected Class<? extends T>[] expand(final Class<? extends T>[] actionWrappers) {		if (actionWrappers == null) {			return null;		}		List<Class<? extends T>> list = new ArrayList<>(actionWrappers.length);		list.addAll(Arrays.asList(actionWrappers));		int i = 0;		while (i < list.size()) {			Class<? extends T> wrapperClass = list.get(i);			if (wrapperClass == null) {				continue;			}			if (ClassUtil.isTypeOf(wrapperClass, BaseActionWrapperStack.class)) {				BaseActionWrapperStack stack = (BaseActionWrapperStack) resolve(wrapperClass);				list.remove(i);				Class<? extends T>[] stackWrappers = stack.getWrappers();				if (stackWrappers != null) {					list.addAll(i, Arrays.asList(stackWrappers));				}				i--;				//continue;			}			i++;		}		return list.toArray(new Class[0]);	}
protected <R extends T> R createWrapper(final Class<R> wrapperClass) {		try {		    return ClassUtil.newInstance(wrapperClass);		} catch (Exception ex) {			throw new MadvocException("Invalid Madvoc wrapper: " + wrapperClass, ex);		}	}
public static String concat(final String basePath, final String fullFilenameToAdd) {		return doConcat(basePath, fullFilenameToAdd, SYSTEM_SEPARATOR);	}
public static String separatorsToSystem(final String path) {		if (path == null) {			return null;		}		if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) {			return separatorsToWindows(path);		} else {			return separatorsToUnix(path);		}	}
public static int indexOfLastSeparator(final String filename) {		if (filename == null) {			return -1;		}		int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);		int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);		return Math.max(lastUnixPos, lastWindowsPos);	}
private static String doGetPath(final String filename, final int separatorAdd) {		if (filename == null) {			return null;		}		int prefix = getPrefixLength(filename);		if (prefix < 0) {			return null;		}		int index = indexOfLastSeparator(filename);        int endIndex = index + separatorAdd;        if (prefix >= filename.length() || index < 0 || prefix >= endIndex) {			return StringPool.EMPTY;		}        return filename.substring(prefix, endIndex);	}
public static String[] split(final String filename) {		String prefix = getPrefix(filename);		if (prefix == null) {			prefix = StringPool.EMPTY;		}		int lastSeparatorIndex = indexOfLastSeparator(filename);		int lastExtensionIndex = indexOfExtension(filename);		String path;		String baseName;		String extension;		if (lastSeparatorIndex == -1) {			path = StringPool.EMPTY;			if (lastExtensionIndex == -1) {				baseName = filename.substring(prefix.length());				extension = StringPool.EMPTY;			} else {				baseName = filename.substring(prefix.length(), lastExtensionIndex);				extension = filename.substring(lastExtensionIndex + 1);			}		} else {			path = filename.substring(prefix.length(), lastSeparatorIndex + 1);			if (lastExtensionIndex == -1) {				baseName = filename.substring(prefix.length() + path.length());				extension = StringPool.EMPTY;			} else {				baseName = filename.substring(prefix.length() + path.length(), lastExtensionIndex);				extension = filename.substring(lastExtensionIndex + 1);			}		}		return new String[] {prefix, path, baseName, extension};	}
public static String resolveHome(final String path) {		if (path.length() == 1) {			if (path.charAt(0) == '~') {				return SystemUtil.info().getHomeDir();			}			return path;		}		if (path.length() >= 2) {			if ((path.charAt(0) == '~') && (path.charAt(1) == File.separatorChar)) {				return SystemUtil.info().getHomeDir() + path.substring(1);			}		}		return path;	}
public static String relativePath(final String targetPath, final String basePath) {		return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString();	}
@Override	public void visit(final String name, final Object value) {		elements.put(name, value);	}
public WebApp registerComponent(final Class<?> madvocComponent) {		Objects.requireNonNull(madvocComponent);		madvocComponents.add(ClassConsumer.of(madvocComponent));		return this;	}
public WebApp registerComponent(final Object madvocComponent) {		Objects.requireNonNull(madvocComponent);		madvocComponentInstances.add(madvocComponent);		return this;	}
public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) {		withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer));		return this;	}
public <T> WebApp withRegisteredComponent(final Class<T> madvocComponent, final Consumer<T> componentConsumer) {		if (componentConfigs == null) {			// component is already configured			final T component = madvocContainer.lookupComponent(madvocComponent);			if (component == null) {				throw new MadvocException("Component not found: " + madvocComponent.getName());			}			componentConsumer.accept(component);		}		else {			componentConfigs.add(madvocContainer -> {				final T component = madvocContainer.lookupComponent(madvocComponent);				if (component == null) {					throw new MadvocException("Component not found: " + madvocComponent.getName());				}				componentConsumer.accept(component);			});		}		return this;	}
public WebApp start() {		log = LoggerFactory.getLogger(WebApp.class);		log.debug("Initializing Madvoc WebApp");		//// params & props		for (final Map<String, Object> params : paramsList) {			madvocContainer.defineParams(params);		}		for (final Props props : propsList) {			madvocContainer.defineParams(props);		}		propsList = null;		//// components		registerMadvocComponents();		madvocComponents.forEach(			madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer()));		madvocComponents = null;		madvocComponentInstances.forEach(madvocContainer::registerComponentInstance);		madvocComponentInstances = null;		configureDefaults();		//// listeners		madvocContainer.fireEvent(Init.class);		//// component configuration		componentConfigs.accept(madvocContainer);		componentConfigs = null;		initialized();		madvocContainer.fireEvent(Start.class);		if (!madvocRouterConsumers.isEmpty()) {			final MadvocRouter madvocRouter = MadvocRouter.create();			madvocContainer.registerComponentInstance(madvocRouter);			madvocRouterConsumers.accept(madvocRouter);		}		madvocRouterConsumers = null;		started();		madvocContainer.fireEvent(Ready.class);		ready();		return this;	}
protected void configureDefaults() {		final ActionConfigManager actionConfigManager =			madvocContainer.lookupComponent(ActionConfigManager.class);		actionConfigManager.registerAnnotation(Action.class);		actionConfigManager.registerAnnotation(RestAction.class);	}
protected void registerMadvocComponents() {		if (madvocContainer == null) {			throw new MadvocException("Madvoc WebApp not initialized.");		}		log.debug("Registering Madvoc WebApp components");		madvocContainer.registerComponent(MadvocEncoding.class);		madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext));		madvocContainer.registerComponent(ActionConfigManager.class);		madvocContainer.registerComponent(ActionMethodParamNameResolver.class);		madvocContainer.registerComponent(ActionMethodParser.class);		madvocContainer.registerComponent(ActionPathRewriter.class);		madvocContainer.registerComponent(ActionsManager.class);		madvocContainer.registerComponent(ContextInjectorComponent.class);		madvocContainer.registerComponent(InterceptorsManager.class);		madvocContainer.registerComponent(FiltersManager.class);		madvocContainer.registerComponent(MadvocController.class);		madvocContainer.registerComponent(RootPackages.class);		madvocContainer.registerComponent(ResultsManager.class);		madvocContainer.registerComponent(ResultMapper.class);		madvocContainer.registerComponent(ScopeResolver.class);		madvocContainer.registerComponent(ScopeDataInspector.class);		madvocContainer.registerComponent(AsyncActionExecutor.class);		madvocContainer.registerComponent(FileUploader.class);	}
public ClassScanner excludeJars(final String... excludedJars) {		for (final String excludedJar : excludedJars) {			rulesJars.exclude(excludedJar);		}		return this;	}
public ClassScanner includeJars(final String... includedJars) {		for (final String includedJar : includedJars) {			rulesJars.include(includedJar);		}		return this;	}
public ClassScanner includeEntries(final String... includedEntries) {		for (final String includedEntry : includedEntries) {			rulesEntries.include(includedEntry);		}		return this;	}
public ClassScanner excludeEntries(final String... excludedEntries) {		for (final String excludedEntry : excludedEntries) {			rulesEntries.exclude(excludedEntry);		}		return this;	}
protected boolean acceptJar(final File jarFile) {		String path = jarFile.getAbsolutePath();		path = FileNameUtil.separatorsToUnix(path);		return rulesJars.match(path);	}
protected void scanJarFile(final File file) {		final ZipFile zipFile;		try {			zipFile = new ZipFile(file);		} catch (IOException ioex) {			if (!ignoreException) {				throw new FindFileException("Invalid zip: " + file.getName(), ioex);			}			return;		}		final Enumeration entries = zipFile.entries();		while (entries.hasMoreElements()) {			final ZipEntry zipEntry = (ZipEntry) entries.nextElement();			final String zipEntryName = zipEntry.getName();			try {				if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) {					final String entryName = prepareEntryName(zipEntryName, true);					final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry);					try {						scanEntry(classPathEntry);					} finally {						classPathEntry.closeInputStream();					}				} else if (includeResources) {					final String entryName = prepareEntryName(zipEntryName, false);					final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry);					try {						scanEntry(classPathEntry);					} finally {						classPathEntry.closeInputStream();					}				}			} catch (RuntimeException rex) {				if (!ignoreException) {					ZipUtil.close(zipFile);					throw rex;				}			}		}		ZipUtil.close(zipFile);	}
protected void scanClassPath(final File root) {		String rootPath = root.getAbsolutePath();		if (!rootPath.endsWith(File.separator)) {			rootPath += File.separatorChar;		}		final FindFile ff = FindFile.create().includeDirs(false).recursive(true).searchPath(rootPath);		File file;		while ((file = ff.nextFile()) != null) {			final String filePath = file.getAbsolutePath();			try {				if (StringUtil.endsWithIgnoreCase(filePath, CLASS_FILE_EXT)) {					scanClassFile(filePath, rootPath, file, true);				} else if (includeResources) {					scanClassFile(filePath, rootPath, file, false);				}			} catch (RuntimeException rex) {				if (!ignoreException) {					throw rex;				}			}		}	}
protected String prepareEntryName(final String name, final boolean isClass) {		String entryName = name;		if (isClass) {			entryName = name.substring(0, name.length() - 6);		// 6 == ".class".length()			entryName = StringUtil.replaceChar(entryName, '/', '.');			entryName = StringUtil.replaceChar(entryName, '\\', '.');		} else {			entryName = '/' + StringUtil.replaceChar(entryName, '\\', '/');		}		return entryName;	}
protected void scanEntry(final ClassPathEntry classPathEntry) {		if (!acceptEntry(classPathEntry.name())) {			return;		}		try {			onEntry(classPathEntry);		} catch (Exception ex) {			throw new FindFileException("Scan entry error: " + classPathEntry, ex);		}	}
public static byte[] bytecodeSignatureOfType(final Class type) {		final String name = 'L' + type.getName().replace('.', '/') + ';';		return name.getBytes();	}
public ClassScanner scan(final URL... urls) {		for (final URL url : urls) {			final File file = FileUtil.toContainerFile(url);			if (file == null) {				if (!ignoreException) {					throw new FindFileException("URL is not a valid file: " + url);				}			}			else {				filesToScan.add(file);			}		}		return this;	}
public ClassScanner scan(final String... paths) {		for (final String path : paths) {			filesToScan.add(new File(path));		}		return this;	}
public void start() {		if (detectEntriesMode) {			rulesEntries.detectMode();		}		filesToScan.forEach(file -> {			final String path = file.getAbsolutePath();			if (StringUtil.endsWithIgnoreCase(path, JAR_FILE_EXT)) {				if (!acceptJar(file)) {					return;				}				scanJarFile(file);			} else if (file.isDirectory()) {				scanClassPath(file);			}		});	}
public static char[] getChars(final String string) {		if (string == null) {			return null;		}		if (!HAS_UNSAFE || !JoddCore.unsafeUsageEnabled) {			return string.toCharArray();		}		return UnsafeInternal.unsafeGetChars(string);	}
@Override	public DbJtxTransaction requestTransaction(final JtxTransactionMode mode, final Object scope) {		return (DbJtxTransaction) super.requestTransaction(mode, scope);	}
@Override	protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) {		return new DbJtxTransaction(this, tm, scope, active);	}
@SuppressWarnings("unchecked")	public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) {		if (scopeClass == null) {			return (S) getOrInitScope(RequestScope.class);		}		return (S) getOrInitScope(scopeClass);	}
protected MadvocScope getOrInitScope(final Class<? extends MadvocScope> madvocScopeType) {		for (final MadvocScope s : allScopes) {			if (s.getClass().equals(madvocScopeType)) {				return s;			}		}		// new scope detected		final MadvocScope newScope;		try {			newScope = madpc.createBean(madvocScopeType);		} catch (Exception ex) {			throw new MadvocException("Unable to create scope: " + madvocScopeType, ex);		}		allScopes.add(newScope);		return newScope;	}
public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) {		final MadvocScope scope = getOrInitScope(scopeType);		madvocScopeConsumer.accept(scope);	}
protected void parseMessage(final Message msg, final boolean envelope) throws MessagingException, IOException {		// flags		flags(msg.getFlags());		// message number		messageNumber(msg.getMessageNumber());		if (msg instanceof MimeMessage) {			messageId(((MimeMessage) msg).getMessageID());		}		// single from		final Address[] addresses = msg.getFrom();		if (addresses != null && addresses.length > 0) {			from(addresses[0]);		}		// reply-to		replyTo(msg.getReplyTo());		// recipients		to(msg.getRecipients(Message.RecipientType.TO));		cc(msg.getRecipients(Message.RecipientType.CC));		// no BCC because this will always be empty		// subject		subject(msg.getSubject());		// dates		receivedDate(msg.getReceivedDate());		sentDate(msg.getSentDate());		// headers		headers(msg.getAllHeaders());		// content		if (!envelope) {			processPart(msg);		}	}
protected void processPart(final Part part) throws MessagingException, IOException {		final Object content = part.getContent();		if (content instanceof String) {			addStringContent(part, (String) content);		} else if (content instanceof Multipart) {			processMultipart((Multipart) content);		} else if (content instanceof InputStream) {			addAttachment(part, (InputStream) content, attachmentStorage);		} else if (content instanceof MimeMessage) {			final MimeMessage mimeMessage = (MimeMessage) content;			attachedMessage(new ReceivedEmail(mimeMessage, false, attachmentStorage));		} else {			addAttachment(part, part.getInputStream(), attachmentStorage);		}	}
private void processMultipart(final Multipart mp) throws MessagingException, IOException {		final int count = mp.getCount();		for (int i = 0; i < count; i++) {			final Part innerPart = mp.getBodyPart(i);			processPart(innerPart);		}	}
private void addStringContent(final Part part, final String content) throws MessagingException, UnsupportedEncodingException {		final String contentType = part.getContentType();		final String encoding = EmailUtil.extractEncoding(contentType, StringPool.US_ASCII);		final String disposition = part.getDisposition();		if (disposition != null && disposition.equalsIgnoreCase(Part.ATTACHMENT)) {			addAttachment(part, content.getBytes(encoding));		} else {			final String mimeType = EmailUtil.extractMimeType(contentType);			message(content, mimeType, encoding);		}	}
protected static String parseContentId(final Part part) throws MessagingException {		if (part instanceof MimePart) {			final MimePart mp = (MimePart) part;			return mp.getContentID();		} else {			return null;		}	}
protected static boolean parseInline(final Part part) throws MessagingException {		if (part instanceof MimePart) {			final String dispositionId = part.getDisposition();			return dispositionId != null && dispositionId.equalsIgnoreCase("inline");		}		return false;	}
private ReceivedEmail addAttachment(final Part part, final InputStream content, final File attachmentStorage) throws MessagingException, IOException {		final EmailAttachmentBuilder builder = addAttachmentInfo(part);		builder.content(content, part.getContentType());		if (attachmentStorage != null) {			String name = messageId + "-" + (this.attachments().size() + 1);			return storeAttachment(builder.buildFileDataSource(name, attachmentStorage));		}		return storeAttachment(builder.buildByteArrayDataSource());	}
private ReceivedEmail addAttachment(final Part part, final byte[] content) throws MessagingException {		final EmailAttachmentBuilder builder = addAttachmentInfo(part);		builder.content(content, part.getContentType());		final EmailAttachment<ByteArrayDataSource> attachment = builder.buildByteArrayDataSource();		attachment.setSize(content.length);		return storeAttachment(attachment);	}
private static EmailAttachmentBuilder addAttachmentInfo(final Part part) throws MessagingException {		final String fileName = EmailUtil.resolveFileName(part);		final String contentId = parseContentId(part);		final boolean isInline = parseInline(part);		return new EmailAttachmentBuilder()			.name(fileName)			.contentId(contentId)			.inline(isInline);	}
public static char[] encodeToChar(final byte[] arr, final boolean lineSeparator) {		int len = arr != null ? arr.length : 0;		if (len == 0) {			return new char[0];		}		int evenlen = (len / 3) * 3;		int cnt = ((len - 1) / 3 + 1) << 2;		int destLen = cnt + (lineSeparator ? (cnt - 1) / 76 << 1 : 0);		char[] dest = new char[destLen];		for (int s = 0, d = 0, cc = 0; s < evenlen;) {			int i = (arr[s++] & 0xff) << 16 | (arr[s++] & 0xff) << 8 | (arr[s++] & 0xff);			dest[d++] = CHARS[(i >>> 18) & 0x3f];			dest[d++] = CHARS[(i >>> 12) & 0x3f];			dest[d++] = CHARS[(i >>> 6) & 0x3f];			dest[d++] = CHARS[i & 0x3f];			if (lineSeparator && (++cc == 19) && (d < (destLen - 2))) {				dest[d++] = '\r';				dest[d++] = '\n';				cc = 0;			}		}		int left = len - evenlen; // 0 - 2.		if (left > 0) {			int i = ((arr[evenlen] & 0xff) << 10) | (left == 2 ? ((arr[len - 1] & 0xff) << 2) : 0);			dest[destLen - 4] = CHARS[i >> 12];			dest[destLen - 3] = CHARS[(i >>> 6) & 0x3f];			dest[destLen - 2] = left == 2 ? CHARS[i & 0x3f] : '=';			dest[destLen - 1] = '=';		}		return dest;	}
public static byte[] decode(final char[] arr) {		int length = arr.length;		if (length == 0) {			return new byte[0];		}		int sndx = 0, endx = length - 1;		int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0;		int cnt = endx - sndx + 1;		int sepCnt = length > 76 ? (arr[76] == '\r' ? cnt / 78 : 0) << 1 : 0;		int len = ((cnt - sepCnt) * 6 >> 3) - pad;		byte[] dest = new byte[len];		int d = 0;		for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {			int i = INV[arr[sndx++]] << 18 | INV[arr[sndx++]] << 12 | INV[arr[sndx++]] << 6 | INV[arr[sndx++]];			dest[d++] = (byte) (i >> 16);			dest[d++] = (byte) (i >> 8);			dest[d++] = (byte) i;			if (sepCnt > 0 && ++cc == 19) {				sndx += 2;				cc = 0;			}		}		if (d < len) {			int i = 0;			for (int j = 0; sndx <= endx - pad; j++) {				i |= INV[arr[sndx++]] << (18 - j * 6);			}			for (int r = 16; d < len; r -= 8) {				dest[d++] = (byte) (i >> r);			}		}		return dest;	}
public static byte[] encodeToByte(final byte[] arr, final boolean lineSep) {		int len = arr != null ? arr.length : 0;		if (len == 0) {			return new byte[0];		}		int evenlen = (len / 3) * 3;		int cnt = ((len - 1) / 3 + 1) << 2;		int destlen = cnt + (lineSep ? (cnt - 1) / 76 << 1 : 0);		byte[] dest = new byte[destlen];		for (int s = 0, d = 0, cc = 0; s < evenlen;) {			int i = (arr[s++] & 0xff) << 16 | (arr[s++] & 0xff) << 8 | (arr[s++] & 0xff);			dest[d++] = (byte) CHARS[(i >>> 18) & 0x3f];			dest[d++] = (byte) CHARS[(i >>> 12) & 0x3f];			dest[d++] = (byte) CHARS[(i >>> 6) & 0x3f];			dest[d++] = (byte) CHARS[i & 0x3f];			if (lineSep && ++cc == 19 && d < destlen - 2) {				dest[d++] = '\r';				dest[d++] = '\n';				cc = 0;			}		}		int left = len - evenlen;		if (left > 0) {			int i = ((arr[evenlen] & 0xff) << 10) | (left == 2 ? ((arr[len - 1] & 0xff) << 2) : 0);			dest[destlen - 4] = (byte) CHARS[i >> 12];			dest[destlen - 3] = (byte) CHARS[(i >>> 6) & 0x3f];			dest[destlen - 2] = left == 2 ? (byte) CHARS[i & 0x3f] : (byte) '=';			dest[destlen - 1] = '=';		}		return dest;	}
public static String encodeToString(final String s) {		return new String(encodeToChar(StringUtil.getBytes(s), false));	}
@SuppressWarnings({"unchecked"})	public static String prepareCsrfToken(final HttpSession session, final int timeToLive) {		Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET);		if (tokenSet == null) {			tokenSet = new HashSet<>();			session.setAttribute(CSRF_TOKEN_SET, tokenSet);		}		String value;		boolean unique;		do {			value = RandomString.get().randomAlphaNumeric(32);			assureSize(tokenSet);			unique = tokenSet.add(new Token(value, timeToLive));		} while (!unique);		return value;	}
protected static void assureSize(final Set<Token> tokenSet) {		if (tokenSet.size() < maxTokensPerSession) {			return;		}		long validUntilMin = Long.MAX_VALUE;		Token tokenToRemove = null;		Iterator<Token> iterator = tokenSet.iterator();		while (iterator.hasNext()) {			Token token = iterator.next();			if (token.isExpired()) {				iterator.remove();				continue;			}			if (token.validUntil < validUntilMin) {				validUntilMin = token.validUntil;				tokenToRemove = token;			}		}		if ((tokenToRemove != null) && (tokenSet.size() >= maxTokensPerSession)) {			tokenSet.remove(tokenToRemove);		}	}
@SuppressWarnings({"unchecked"})	public static boolean checkCsrfToken(final HttpServletRequest request, final String tokenName) {		String tokenValue = request.getParameter(tokenName);		return checkCsrfToken(request.getSession(), tokenValue);	}
@SuppressWarnings({"unchecked"})	public static boolean checkCsrfToken(final HttpSession session, final String tokenValue) {		Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET);		if ((tokenSet == null) && (tokenValue == null)) {			return true;		}		if ((tokenSet == null) || (tokenValue == null)) {			return false;		}		boolean found = false;		Iterator<Token> it = tokenSet.iterator();		while (it.hasNext()) {			Token t = it.next();			if (t.isExpired()) {				it.remove();				continue;			}			if (t.getValue().equals(tokenValue)) {				it.remove();				found = true;			}		}		return found;	}
public static BeanCopy fromMap(final Map source) {		BeanCopy beanCopy = new BeanCopy(source);		beanCopy.isSourceMap = true;		return beanCopy;	}
public static BeanCopy from(final Object source) {		BeanCopy beanCopy = new BeanCopy(source);		beanCopy.isSourceMap = source instanceof Map;		return beanCopy;	}
public void copy() {		beanUtil = new BeanUtilBean()						.declared(declared)						.forced(forced)						.silent(true);		visit();	}
@Override	protected boolean visitProperty(String name, final Object value) {		if (isTargetMap) {			name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET;		}		beanUtil.setProperty(destination, name, value);		return true;	}
@Override	protected final char[] parse(final char[] content, final HttpServletRequest request) {		LagartoParsingProcessor lpp = createParsingProcessor();		if (lpp == null) {			return content;		}		lpp.init(content);		return lpp.parse(request);	}
@Override	public void init(final TemplateData templateData) {		super.init(templateData);		if (entity != null) {			ded = lookupType(entity);		} else {			Object object = templateData.getObjectReference(entityName);			if (object != null) {				ded = lookupType(resolveClass(object));			} else {				ded = lookupName(entityName);			}		}		String tableReference = this.tableReference;		if (tableReference == null) {			tableReference = tableAlias;		}		if (tableReference == null) {			tableReference = entityName;		}		if (tableReference == null) {			tableReference = ded.getEntityName();		}		templateData.registerTableReference(tableReference, ded, tableAlias);	}
@SuppressWarnings("unchecked")	public <S extends Scope> S resolveScope(final Class<S> scopeType) {		S scope = (S) scopes.get(scopeType);		if (scope == null) {			try {				scope = newInternalInstance(scopeType, (PetiteContainer) this);			} catch (Exception ex) {				throw new PetiteException("Invalid Petite scope: " + scopeType.getName(), ex);			}			registerScope(scopeType, scope);			scopes.put(scopeType, scope);		}		return scope;	}
private <T> T newInternalInstance(final Class<T> type, final PetiteContainer petiteContainer) throws Exception {		T t = null;		// first try ctor(PetiteContainer)		try {			Constructor<T> ctor = type.getConstructor(PetiteContainer.class);			t = ctor.newInstance(petiteContainer);		} catch (NoSuchMethodException nsmex) {			// ignore		}		// if first try failed, try default ctor		if (t == null) {			return ClassUtil.newInstance(type);		}		return t;	}
public void registerScope(final Class<? extends Scope> scopeType, final Scope scope) {		scopes.put(scopeType, scope);	}
public BeanDefinition lookupBeanDefinition(final String name) {		BeanDefinition beanDefinition = beans.get(name);		// try alt bean names		if (beanDefinition == null) {			if (petiteConfig.isUseAltBeanNames()) {				beanDefinition = beansAlt.get(name);			}		}		return beanDefinition;	}
protected BeanDefinition lookupBeanDefinitions(final BeanReferences beanReferences) {		final int total = beanReferences.size();		for (int i = 0; i < total; i++) {			final String name = beanReferences.name(i);			BeanDefinition beanDefinition = lookupBeanDefinition(name);			if (beanDefinition != null) {				return beanDefinition;			}		}		return null;	}
protected BeanDefinition lookupExistingBeanDefinition(final String name) {		BeanDefinition beanDefinition = lookupBeanDefinition(name);		if (beanDefinition == null) {			throw new PetiteException("Bean not found: " + name);		}		return beanDefinition;	}
protected <T> BeanDefinition createBeanDefinitionForRegistration(			final String name,			final Class<T> type,			final Scope scope,			final WiringMode wiringMode,			final Consumer<T> consumer) {		return new BeanDefinition<>(name, type, scope, wiringMode, consumer);	}
protected <T> BeanDefinition createBeandDefinitionForExternalBeans(			final Class<T> type,			final WiringMode wiringMode) {		final String name = resolveBeanName(type);		return new BeanDefinition<>(name, type, null, wiringMode, null);	}
public BeanDefinition registerPetiteBean(final Class type) {		return registerPetiteBean(type, null, null, null, false, null);	}
public <T> BeanDefinition<T> registerPetiteBean(final Class<T> type, final Consumer<T> consumer) {		return registerPetiteBean(type, null, null, null, false, consumer);	}
public <T> BeanDefinition<T> registerPetiteBean(		final Class<T> type, String name,		Class<? extends Scope> scopeType,		WiringMode wiringMode,		final boolean define,		final Consumer<T> consumer	) {		if (name == null) {			name = resolveBeanName(type);		}		if (wiringMode == null) {			wiringMode = annotationResolver.resolveBeanWiringMode(type);		}		if (wiringMode == WiringMode.DEFAULT) {			wiringMode = petiteConfig.getDefaultWiringMode();		}		if (scopeType == null) {			scopeType = annotationResolver.resolveBeanScopeType(type);		}		if (scopeType == null) {			scopeType = SingletonScope.class;		}		// remove existing bean		BeanDefinition existing = removeBean(name);		if (existing != null) {			if (petiteConfig.getDetectDuplicatedBeanNames()) {				throw new PetiteException(						"Duplicated bean name detected while registering class '" + type.getName() + "'. Petite bean class '" +						existing.type.getName() + "' is already registered with the name: " + name);			}		}		// check if type is valid		if (type.isInterface()) {			throw new PetiteException("PetiteBean can not be an interface: " + type.getName());		}		// registration		if (log.isDebugEnabled()) {			log.info("Petite bean: [" + name +					"] --> " + type.getName() +					" @ " + scopeType.getSimpleName() +					":" + wiringMode.toString());		}		// register		Scope scope = resolveScope(scopeType);		BeanDefinition<T> beanDefinition = createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer);		registerBean(name, beanDefinition);		// providers		ProviderDefinition[] providerDefinitions = petiteResolvers.resolveProviderDefinitions(type, name);		if (providerDefinitions != null) {			for (ProviderDefinition providerDefinition : providerDefinitions) {				providers.put(providerDefinition.name, providerDefinition);			}		}		// define		if (define) {			beanDefinition.ctor = petiteResolvers.resolveCtorInjectionPoint(beanDefinition.type());			beanDefinition.properties = PropertyInjectionPoint.EMPTY;			beanDefinition.methods = MethodInjectionPoint.EMPTY;			beanDefinition.initMethods = InitMethodPoint.EMPTY;			beanDefinition.destroyMethods = DestroyMethodPoint.EMPTY;		}		// return		return beanDefinition;	}
protected void registerBean(final String name, final BeanDefinition beanDefinition) {		beans.put(name, beanDefinition);		if (!petiteConfig.isUseAltBeanNames()) {			return;		}		Class type = beanDefinition.type();		if (annotationResolver.beanHasAnnotationName(type)) {			return;		}		Class[] interfaces = ClassUtil.resolveAllInterfaces(type);		for (Class anInterface : interfaces) {			String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames());			if (name.equals(altName)) {				continue;			}			if (beans.containsKey(altName)) {				continue;			}			if (beansAlt.containsKey(altName)) {				BeanDefinition existing = beansAlt.get(altName);				if (existing != null) {					beansAlt.put(altName, null);		// store null as value to mark that alt name is duplicate				}			}			else {				beansAlt.put(altName, beanDefinition);			}		}	}
public void removeBean(final Class type) {		// collect bean names		Set<String> beanNames = new HashSet<>();		for (BeanDefinition def : beans.values()) {			if (def.type.equals(type)) {				beanNames.add(def.name);			}		}		// remove collected bean names		for (String beanName : beanNames) {			removeBean(beanName);		}	}
public BeanDefinition removeBean(final String name) {		BeanDefinition bd = beans.remove(name);		if (bd == null) {			return null;		}		bd.scopeRemove();		return bd;	}
protected String[] resolveBeanNamesForType(final Class type) {		String[] beanNames = beanCollections.get(type);		if (beanNames != null) {			return beanNames;		}		ArrayList<String> list = new ArrayList<>();		for (Map.Entry<String, BeanDefinition> entry : beans.entrySet()) {			BeanDefinition beanDefinition = entry.getValue();			if (ClassUtil.isTypeOf(beanDefinition.type, type)) {				String beanName = entry.getKey();				list.add(beanName);			}		}		if (list.isEmpty()) {			beanNames = StringPool.EMPTY_ARRAY;		} else {			beanNames = list.toArray(new String[0]);		}		beanCollections.put(type, beanNames);		return beanNames;	}
public void registerPetiteCtorInjectionPoint(final String beanName, final Class[] paramTypes, final String[] references) {		BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);		ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);		Constructor constructor = null;		if (paramTypes == null) {			CtorDescriptor[] ctors = cd.getAllCtorDescriptors();			if (ctors != null && ctors.length > 0) {				if (ctors.length > 1) {					throw new PetiteException(ctors.length + " suitable constructor found as injection point for: " + beanDefinition.type.getName());				}				constructor = ctors[0].getConstructor();			}		} else {			CtorDescriptor ctorDescriptor = cd.getCtorDescriptor(paramTypes, true);			if (ctorDescriptor != null) {				constructor = ctorDescriptor.getConstructor();			}		}		if (constructor == null) {			throw new PetiteException("Constructor not found: " + beanDefinition.type.getName());		}		BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(constructor, references);		beanDefinition.ctor = new CtorInjectionPoint(constructor, ref);	}
public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) {		BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);		ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);		PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true);		if (propertyDescriptor == null) {			throw new PetiteException("Property not found: " + beanDefinition.type.getName() + '#' + property);		}		BeanReferences ref = referencesResolver.resolveReferenceFromValue(propertyDescriptor, reference);		PropertyInjectionPoint pip = new PropertyInjectionPoint(propertyDescriptor, ref);		beanDefinition.addPropertyInjectionPoint(pip);	}
public void registerPetiteSetInjectionPoint(final String beanName, final String property) {		BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);		ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);		PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true);		if (propertyDescriptor == null) {			throw new PetiteException("Property not found: " + beanDefinition.type.getName() + '#' + property);		}		SetInjectionPoint sip = new SetInjectionPoint(propertyDescriptor);		beanDefinition.addSetInjectionPoint(sip);	}
public void registerPetiteMethodInjectionPoint(final String beanName, final String methodName, final Class[] arguments, final String[] references) {		BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);		ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);		Method method = null;		if (arguments == null) {			MethodDescriptor[] methods = cd.getAllMethodDescriptors(methodName);			if (methods != null && methods.length > 0) {				if (methods.length > 1) {					throw new PetiteException(methods.length + " suitable methods found as injection points for: " + beanDefinition.type.getName() + '#' + methodName);				}				method = methods[0].getMethod();			}		} else {			MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true);			if (md != null) {				method = md.getMethod();			}		}		if (method == null) {			throw new PetiteException("Method not found: " + beanDefinition.type.getName() + '#' + methodName);		}		BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(method, references);		MethodInjectionPoint mip = new MethodInjectionPoint(method, ref);		beanDefinition.addMethodInjectionPoint(mip);	}
public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) {		BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);		ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);		if (initMethodNames == null) {			initMethodNames = StringPool.EMPTY_ARRAY;		}		int total = initMethodNames.length;		InitMethodPoint[] initMethodPoints = new InitMethodPoint[total];		int i;		for (i = 0; i < initMethodNames.length; i++) {			MethodDescriptor md = cd.getMethodDescriptor(initMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true);			if (md == null) {				throw new PetiteException("Init method not found: " + beanDefinition.type.getName() + '#' + initMethodNames[i]);			}			initMethodPoints[i] = new InitMethodPoint(md.getMethod(), i, invocationStrategy);		}		beanDefinition.addInitMethodPoints(initMethodPoints);	}
public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) {		BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);		ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);		if (destroyMethodNames == null) {			destroyMethodNames = StringPool.EMPTY_ARRAY;		}		int total = destroyMethodNames.length;		DestroyMethodPoint[] destroyMethodPoints = new DestroyMethodPoint[total];		int i;		for (i = 0; i < destroyMethodNames.length; i++) {			MethodDescriptor md = cd.getMethodDescriptor(destroyMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true);			if (md == null) {				throw new PetiteException("Destroy method not found: " + beanDefinition.type.getName() + '#' + destroyMethodNames[i]);			}			destroyMethodPoints[i] = new DestroyMethodPoint(md.getMethod());		}		beanDefinition.addDestroyMethodPoints(destroyMethodPoints);	}
public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments) {		BeanDefinition beanDefinition = lookupBeanDefinition(beanName);		if (beanDefinition == null) {			throw new PetiteException("Bean not found: " + beanName);		}		Class beanType = beanDefinition.type;		ClassDescriptor cd = ClassIntrospector.get().lookup(beanType);		MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true);		if (md == null) {			throw new PetiteException("Provider method not found: " + methodName);		}		ProviderDefinition providerDefinition = new ProviderDefinition(providerName, beanName, md.getMethod());		providers.put(providerName, providerDefinition);	}
public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) {		ClassDescriptor cd = ClassIntrospector.get().lookup(type);		MethodDescriptor md = cd.getMethodDescriptor(staticMethodName, arguments, true);		if (md == null) {			throw new PetiteException("Provider method not found: " + staticMethodName);		}		ProviderDefinition providerDefinition = new ProviderDefinition(providerName, md.getMethod());		providers.put(providerName, providerDefinition);	}
public void forEachBean(final Consumer<BeanDefinition> beanDefinitionConsumer) {		final Set<String> names = beanNames();		for (String beanName : names) {			BeanDefinition beanDefinition = lookupBeanDefinition(beanName);			if (beanDefinition != null) {				beanDefinitionConsumer.accept(beanDefinition);			}		}	}
public void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) {		forEachBean(bd -> {			if (ClassUtil.isTypeOf(bd.type, type)) {				beanNameConsumer.accept(bd.name);			}		});	}
public void defineParameters(final Map<?, ?> properties) {		for (Map.Entry<?, ?> entry : properties.entrySet()) {			defineParameter(entry.getKey().toString(), entry.getValue());		}	}
public void defineParameters(final Props props) {		Map<?, ?> map = new HashMap<>();		props.extractProps(map);		defineParameters(map);	}
public synchronized T get() {		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();		if (contextClassLoader != null) {			T value = weakMap.get(contextClassLoader);			if ((value == null) && !weakMap.containsKey(contextClassLoader)) {				value = initialValue();				weakMap.put(contextClassLoader, value);			}			return value;		}		if (!initialized) {			value = initialValue();			initialized = true;		}		return value;	}
public synchronized void set(final T value) {		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();		if (contextClassLoader != null) {			weakMap.put(contextClassLoader, value);			return;		}		this.value = value;		this.initialized = true;	}
@Override	public Float get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return Float.valueOf(rs.getFloat(index));	}
@Override	public void set(final PreparedStatement st, final int index, final Float value, final int dbSqlType) throws SQLException {		st.setFloat(index, value.floatValue());	}
@Override	public Date get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getDate(index);	}
@Override	public void set(final PreparedStatement st, final int index, final Date value, final int dbSqlType) throws SQLException {		st.setDate(index, value);	}
@Override	public Object intercept(final ActionRequest actionRequest) throws Exception {		printBefore(actionRequest);		long startTime = System.currentTimeMillis();		Object result = null;		try {			result = actionRequest.invoke();		} catch (Exception ex) {			result = "<exception>";			throw ex;		} catch (Throwable th) {			result = "<throwable>";			throw new Exception(th);		} finally {			long executionTime = System.currentTimeMillis() - startTime;			printAfter(actionRequest, executionTime, result);		}		return result;	}
protected void printBefore(final ActionRequest request) {		StringBuilder message = new StringBuilder(prefixIn);		message.append(request.getActionPath()).append("   [").append(request.getActionRuntime().createActionString()).append(']');		out(message.toString());	}
protected void printAfter(final ActionRequest request, final long executionTime, final Object result) {		StringBuilder message = new StringBuilder(prefixOut);		String resultString = StringUtil.toSafeString(result);		if (resultString.length() > 70) {			resultString = resultString.substring(0, 70);			resultString += "...";		}		message.append(request.getActionPath()).append("  (")				.append(resultString).append(") in ").append(executionTime)				.append("ms.");		out(message.toString());	}
public static int resolveJavaVersion(final int version) {		final int javaVersionNumber = SystemUtil.info().getJavaVersionNumber();		final int platformVersion = javaVersionNumber - 8 + 52;		return version > platformVersion ? version : platformVersion;	}
public static void pushInt(final MethodVisitor mv, final int value) {		if (value <= 5) {			mv.visitInsn(ICONST_0 + value);		} else if (value <= Byte.MAX_VALUE) {			mv.visitIntInsn(BIPUSH, value);		}  else {			mv.visitIntInsn(SIPUSH, value);		}	}
public static void checkArgumentIndex(final MethodInfo methodInfo, final int argIndex) {		if ((argIndex < 1) || (argIndex > methodInfo.getArgumentsCount())) {			throw new ProxettaException("Invalid argument index: " + argIndex);		}	}
public static String adviceFieldName(final String name, final int index) {		return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index;	}
public static String adviceMethodName(final String name, final int index) {		return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index;	}
public static void loadMethodArgumentClass(final MethodVisitor mv, final MethodInfo methodInfo, final int index) {		TypeInfo argument = methodInfo.getArgument(index);		loadClass(mv, argument.getOpcode(), argument.getRawName());	}
public static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {		mv.visitVarInsn(ALOAD, 0);		for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) {			loadMethodArgument(mv, methodInfo, i);		}	}
public static void loadStaticMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {		for (int i = 0; i < methodInfo.getArgumentsCount(); i++) {			loadMethodArgument(mv, methodInfo, i);		}	}
public static void loadVirtualMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {		for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) {			loadMethodArgument(mv, methodInfo, i);		}	}
public static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) {		int offset = methodInfo.getArgumentOffset(index);		int type = methodInfo.getArgument(index).getOpcode();		switch (type) {			case 'V':				break;			case 'B':			case 'C':			case 'S':			case 'I':			case 'Z':				mv.visitVarInsn(ILOAD, offset);				break;			case 'J':				mv.visitVarInsn(LLOAD, offset);				break;			case 'F':				mv.visitVarInsn(FLOAD, offset);				break;			case 'D':				mv.visitVarInsn(DLOAD, offset);				break;			default:				mv.visitVarInsn(ALOAD, offset);		}	}
public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) {		int offset = methodInfo.getArgumentOffset(index);		int type = methodInfo.getArgument(index).getOpcode();		switch (type) {			case 'V':				break;			case 'B':			case 'C':			case 'S':			case 'I':			case 'Z':				mv.visitVarInsn(ISTORE, offset); break;			case 'J':				mv.visitVarInsn(LSTORE, offset); break;			case 'F':				mv.visitVarInsn(FSTORE, offset); break;			case 'D':				mv.visitVarInsn(DSTORE, offset); break;			default:				mv.visitVarInsn(ASTORE, offset);		}	}
public static boolean isStoreOpcode(final int opcode) {		return (opcode == ISTORE)				|| (opcode == LSTORE)				|| (opcode == FSTORE)				|| (opcode == DSTORE)				|| (opcode == ASTORE);	}
public static void visitReturn(final MethodVisitor mv, final MethodInfo methodInfo, final boolean isLast) {		switch (methodInfo.getReturnType().getOpcode()) {			case 'V':				if (isLast) {					mv.visitInsn(POP);				}				mv.visitInsn(RETURN);				break;			case 'B':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(ICONST_0);						mv.visitInsn(IRETURN);					mv.visitLabel(label);					AsmUtil.byteValue(mv);				}				mv.visitInsn(IRETURN);				break;			case 'C':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(ICONST_0);						mv.visitInsn(IRETURN);					mv.visitLabel(label);					AsmUtil.charValue(mv);				}				mv.visitInsn(IRETURN);				break;			case 'S':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(ICONST_0);						mv.visitInsn(IRETURN);					mv.visitLabel(label);					AsmUtil.shortValue(mv);				}				mv.visitInsn(IRETURN);				break;			case 'I':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(ICONST_0);						mv.visitInsn(IRETURN);					mv.visitLabel(label);					AsmUtil.intValue(mv);				}				mv.visitInsn(IRETURN);				break;			case 'Z':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(ICONST_0);						mv.visitInsn(IRETURN);					mv.visitLabel(label);					AsmUtil.booleanValue(mv);				}				mv.visitInsn(IRETURN);				break;			case 'J':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(LCONST_0);						mv.visitInsn(LRETURN);					mv.visitLabel(label);					AsmUtil.longValue(mv);				}				mv.visitInsn(LRETURN);				break;			case 'F':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(FCONST_0);						mv.visitInsn(FRETURN);					mv.visitLabel(label);					AsmUtil.floatValue(mv);				}				mv.visitInsn(FRETURN);				break;			case 'D':				if (isLast) {					mv.visitInsn(DUP);					Label label = new Label();					mv.visitJumpInsn(IFNONNULL, label);						mv.visitInsn(POP);						mv.visitInsn(DCONST_0);						mv.visitInsn(DRETURN);					mv.visitLabel(label);					AsmUtil.doubleValue(mv);				}				mv.visitInsn(DRETURN);				break;			default:				mv.visitInsn(ARETURN);				break;		}	}
public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) {		varOffset += methodInfo.getAllArgumentsSize();		switch (methodInfo.getReturnType().getOpcode()) {			case 'V':				mv.visitInsn(ACONST_NULL);				break;			case 'B':				AsmUtil.valueOfByte(mv);				break;			case 'C':				AsmUtil.valueOfCharacter(mv);				break;			case 'S':				AsmUtil.valueOfShort(mv);				break;			case 'I':				AsmUtil.valueOfInteger(mv);				break;			case 'Z':				AsmUtil.valueOfBoolean(mv);				break;			case 'J':				AsmUtil.valueOfLong(mv);				break;			case 'F':				AsmUtil.valueOfFloat(mv);				break;			case 'D':				AsmUtil.valueOfDouble(mv);				break;		}	}
public static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) {		return new StringBand(7)			.append(access)			.append(COLON)			.append(description)			.append(StringPool.UNDERSCORE)			.append(className)			.append(StringPool.HASH)			.append(methodName)			.toString();	}
public static void visitElementValue(final MethodVisitor mv, final Object elementValue, final boolean boxPrimitives) {		if (elementValue instanceof String) {	// string			mv.visitLdcInsn(elementValue);			return;		}		if (elementValue instanceof Type) {		// class			mv.visitLdcInsn(elementValue);			return;		}		if (elementValue instanceof Class) {			mv.visitLdcInsn(Type.getType((Class) elementValue));			return;		}		// primitives		if (elementValue instanceof Integer) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfInteger(mv);			}			return;		}		if (elementValue instanceof Long) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfLong(mv);			}			return;		}		if (elementValue instanceof Short) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfShort(mv);			}			return;		}		if (elementValue instanceof Byte) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfByte(mv);			}			return;		}		if (elementValue instanceof Float) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfFloat(mv);			}			return;		}		if (elementValue instanceof Double) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfDouble(mv);			}			return;		}		if (elementValue instanceof Character) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfCharacter(mv);			}			return;		}		if (elementValue instanceof Boolean) {			mv.visitLdcInsn(elementValue);			if (boxPrimitives) {				AsmUtil.valueOfBoolean(mv);			}			return;		}		// enum		Class elementValueClass = elementValue.getClass();		Class enumClass = ClassUtil.findEnum(elementValueClass);		if (enumClass != null) {			try {				String typeRef = AsmUtil.typeToTyperef(enumClass);				String typeSignature = AsmUtil.typeToSignature(enumClass);				// invoke				Method nameMethod = elementValue.getClass().getMethod("name");				String name = (String) nameMethod.invoke(elementValue);				mv.visitFieldInsn(GETSTATIC, typeSignature, name, typeRef);				return;			} catch (Exception ignore) {			}		}		throw new ProxettaException("Unsupported annotation type: " + elementValue.getClass());	}
public static void newArray(final MethodVisitor mv, final Class componentType) {		if (componentType == int.class) {			mv.visitIntInsn(NEWARRAY, T_INT);			return;		}		if (componentType == long.class) {			mv.visitIntInsn(NEWARRAY, T_LONG);			return;		}		if (componentType == float.class) {			mv.visitIntInsn(NEWARRAY, T_FLOAT);			return;		}		if (componentType == double.class) {			mv.visitIntInsn(NEWARRAY, T_DOUBLE);			return;		}		if (componentType == byte.class) {			mv.visitIntInsn(NEWARRAY, T_BYTE);			return;		}		if (componentType == short.class) {			mv.visitIntInsn(NEWARRAY, T_SHORT);			return;		}		if (componentType == boolean.class) {			mv.visitIntInsn(NEWARRAY, T_BOOLEAN);			return;		}		if (componentType == char.class) {			mv.visitIntInsn(NEWARRAY, T_CHAR);			return;		}		mv.visitTypeInsn(ANEWARRAY, AsmUtil.typeToSignature(componentType));	}
public static void storeIntoArray(final MethodVisitor mv, final Class componentType) {		if (componentType == int.class) {			mv.visitInsn(IASTORE);			return;		}		if (componentType == long.class) {			mv.visitInsn(LASTORE);			return;		}		if (componentType == float.class) {			mv.visitInsn(FASTORE);			return;		}		if (componentType == double.class) {			mv.visitInsn(DASTORE);			return;		}		if (componentType == byte.class) {			mv.visitInsn(BASTORE);			return;		}		if (componentType == short.class) {			mv.visitInsn(SASTORE);			return;		}		if (componentType == boolean.class) {			mv.visitInsn(BASTORE);			return;		}		if (componentType == char.class) {			mv.visitInsn(CASTORE);			return;		}		mv.visitInsn(AASTORE);	}
public static boolean isInvokeMethod(final String name, final String desc) {		if (name.equals("invoke")) {			if (desc.equals("()Ljava/lang/Object;")) {				return true;			}		}		return false;	}
public char[] lookupDecoratorContent(final String path) {		if (contentMap != null) {			final char[] data = contentMap.get(path);			if (data != null) {				return data;			}			final File file = filesMap.get(path);			if (file != null) {				try {					return FileUtil.readChars(file);				} catch (IOException e) {					throw new DecoraException("Unable to read Decrator files", e);				}			}		}		return null;	}
public String resolveDecorator(final HttpServletRequest request, final String actionPath) {		if (actionPath.endsWith(".html")) {			return DEFAULT_DECORATOR;		}		return null;	}
public static String extractMimeType(final String contentType) {		final int ndx = contentType.indexOf(';');		final String mime;		if (ndx != -1) {			mime = contentType.substring(0, ndx);		} else {			mime = contentType;		}		return mime;	}
public static String extractEncoding(final String contentType) {		int ndx = contentType.indexOf(';');		final String charset = ndx != -1 ? contentType.substring(ndx + 1) : StringPool.EMPTY;		String encoding = null;		ndx = charset.indexOf(ATTR_CHARSET);		if (ndx != -1) {			ndx += ATTR_CHARSET.length();			final int len = charset.length();			if (charset.charAt(ndx) == '"') {				ndx++;			}			final int start = ndx;			while (ndx < len) {				final char c = charset.charAt(ndx);				if ((c == '"') || (CharUtil.isWhitespace(c)) || (c == ';')) {					break;				}				ndx++;			}			encoding = charset.substring(start, ndx);		}		return encoding;	}
public static String extractEncoding(final String contentType, String defaultEncoding) {		String encoding = extractEncoding(contentType);		if (encoding == null) {			if (defaultEncoding == null) {				defaultEncoding = JoddCore.encoding;			}			encoding = defaultEncoding;		}		return encoding;	}
public static String resolveFileName(final Part part) throws MessagingException {		if (!(part instanceof MimeBodyPart)) {			return part.getFileName();		}		final String contentType = part.getContentType();		String ret;		try {			ret = MimeUtility.decodeText(part.getFileName());		} catch (final Exception ex) {			// String[] contentId = part.getHeader("Content-ID");			// if (contentId != null && contentId.length > 0) {			final String contentId = ((MimeBodyPart) part).getContentID();			if (contentId != null) {				ret = contentId + contentTypeForFileName(contentType);			} else {				ret = defaultFileName(contentType);			}		}		return ret;	}
public static boolean isEmptyFlags(Flags flags) {		if (flags == null) return true;		Flags.Flag[] systemFlags = flags.getSystemFlags();		if (systemFlags != null && systemFlags.length > 0) {			return false;		}		String[] userFlags = flags.getUserFlags();		if (userFlags != null && userFlags.length > 0) {			return false;		}		return true;	}
protected char[] convertValueToArray(final Object value) {		if (value instanceof Collection) {			final Collection collection = (Collection) value;			final char[] target = new char[collection.size()];			int i = 0;			for (final Object element : collection) {				target[i] = convertType(element);				i++;			}			return target;		}		if (value instanceof Iterable) {			final Iterable iterable = (Iterable) value;			final ArrayList<Character> charArrayList = new ArrayList<>();			for (final Object element : iterable) {				final char convertedValue = convertType(element);				charArrayList.add(Character.valueOf(convertedValue));			}			final char[] array = new char[charArrayList.size()];			for (int i = 0; i < charArrayList.size(); i++) {				final Character c = charArrayList.get(i);				array[i] = c.charValue();			}			return array;		}		if (value instanceof CharSequence) {			final CharSequence charSequence = (CharSequence) value;			final char[] result = new char[charSequence.length()];			for (int i = 0; i < result.length; i++) {				result[i] = charSequence.charAt(i);			}			return result;		}		// everything else:		return convertToSingleElementArray(value);	}
public static boolean isMultipartRequest(final HttpServletRequest request) {		String type = request.getHeader(HEADER_CONTENT_TYPE);		return (type != null) && type.startsWith(TYPE_MULTIPART_FORM_DATA);	}
public static String resolveAuthUsername(final HttpServletRequest request) {		String header = request.getHeader(HEADER_AUTHORIZATION);		if (header == null) {			return null;		}		if (!header.contains("Basic ")) {			return null;		}		final String encoded = header.substring(header.indexOf(' ') + 1);		final String decoded = new String(Base64.decode(encoded));		return decoded.substring(0, decoded.indexOf(':'));	}
public static String resolveAuthBearerToken(final HttpServletRequest request) {		String header = request.getHeader(HEADER_AUTHORIZATION);		if (header == null) {			return null;		}		int ndx = header.indexOf("Bearer ");		if (ndx == -1) {			return null;		}		return header.substring(ndx + 7).trim();	}
public static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException {		resp.setHeader(WWW_AUTHENTICATE, "Basic realm=\"" + realm + '\"');		resp.sendError(HttpServletResponse.SC_UNAUTHORIZED);	}
public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) {		if (!file.exists()) {			throw new IllegalArgumentException("File not found: " + file);		}		if (file.length() > Integer.MAX_VALUE) {			throw new IllegalArgumentException("File too big: " + file);		}		prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length());	}
public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) {		if ((mimeType == null) && (fileName != null)) {			String extension = FileNameUtil.getExtension(fileName);			mimeType = MimeTypes.getMimeType(extension);		}		if (mimeType != null) {			response.setContentType(mimeType);		}		if (fileSize >= 0) {			response.setContentLength(fileSize);		}		// support internationalization		// See https://tools.ietf.org/html/rfc6266#section-5 for more information.		if (fileName != null) {			String name = FileNameUtil.getName(fileName);			String encodedFileName = URLCoder.encode(name);			response.setHeader(CONTENT_DISPOSITION,				"attachment;filename=\"" + name + "\";filename*=utf8''" + encodedFileName);		}	}
public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) {		Cookie[] cookies = request.getCookies();		if (cookies == null) {			return null;		}		ArrayList<Cookie> list = new ArrayList<>(cookies.length);		for (Cookie cookie : cookies) {			if (cookie.getName().equals(cookieName)) {				list.add(cookie);			}		}		if (list.isEmpty()) {			return null;		}		return list.toArray(new Cookie[0]);	}
public static String readRequestBodyFromReader(final HttpServletRequest request) throws IOException {		BufferedReader buff = request.getReader();		StringWriter out = new StringWriter();		StreamUtil.copy(buff, out);		return out.toString();	}
public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException {		String charEncoding = request.getCharacterEncoding();		if (charEncoding == null) {			charEncoding = JoddCore.encoding;		}		CharArrayWriter charArrayWriter = new CharArrayWriter();		BufferedReader bufferedReader = null;		try {			InputStream inputStream = request.getInputStream();			if (inputStream != null) {				bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding));				StreamUtil.copy(bufferedReader, charArrayWriter);			} else {				return StringPool.EMPTY;			}		} finally {			StreamUtil.close(bufferedReader);		}		return charArrayWriter.toString();	}
public static String getContextPath(final HttpServletRequest request) {		String contextPath = request.getContextPath();		if (contextPath == null || contextPath.equals(StringPool.SLASH)) {			contextPath = StringPool.EMPTY;		}		return contextPath;	}
public static String getContextPath(final ServletContext servletContext) {		String contextPath = servletContext.getContextPath();		if (contextPath == null || contextPath.equals(StringPool.SLASH)) {			contextPath = StringPool.EMPTY;		}		return contextPath;	}
public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) {		String ctxPath = getContextPath(pageContext);		HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();		request.setAttribute(contextPathVariableName, ctxPath);		ServletContext servletContext = pageContext.getServletContext();		servletContext.setAttribute(contextPathVariableName, ctxPath);	}
public static void storeContextPath(final ServletContext servletContext, final String contextPathVariableName) {		String ctxPath = getContextPath(servletContext);		servletContext.setAttribute(contextPathVariableName, ctxPath);	}
public static Object attribute(final HttpServletRequest request, final String name) {		Object value = request.getAttribute(name);		if (value != null) {			return value;		}		value = request.getSession().getAttribute(name);		if (value != null) {			return value;		}		return request.getServletContext().getAttribute(name);	}
public static Object value(final PageContext pageContext, final String name) {		Object value = pageContext.getAttribute(name);		if (value != null) {			return value;		}		return value((HttpServletRequest) pageContext.getRequest(), name);	}
public static Object value(final HttpServletRequest request, final String name) {		Object value = request.getAttribute(name);		if (value != null) {			return value;		}		if (isMultipartRequest(request)) {			try {				MultipartRequest multipartRequest = MultipartRequest.getInstance(request);				value = multipartRequest.getParameter(name);			} catch (IOException ignore) {			}		}		else {			String[] params = request.getParameterValues(name);			if (params != null) {				if (params.length == 1) {					value = params[0];				} else {					value = params;				}			}		}		if (value != null) {			return value;		}		value = request.getSession().getAttribute(name);		if (value != null) {			return value;		}		return request.getServletContext().getAttribute(name);	}
public static void setScopeAttribute(final String name, final Object value, final String scope, final PageContext pageContext) {		HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();		String scopeValue = scope != null ? scope.toLowerCase() : SCOPE_PAGE;		if (scopeValue.equals(SCOPE_PAGE)) {			pageContext.setAttribute(name, value);		}		else if (scopeValue.equals(SCOPE_REQUEST)) {			request.setAttribute(name, value);		}		else if (scopeValue.equals(SCOPE_SESSION)) {			request.getSession().setAttribute(name, value);		}		else if (scopeValue.equals(SCOPE_APPLICATION)) {            request.getServletContext().setAttribute(name, value);        }		else {			throw new IllegalArgumentException("Invalid scope: " + scope);        }	}
public static void removeScopeAttribute(final String name, final String scope, final PageContext pageContext) {		HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();		String scopeValue = scope != null ? scope.toLowerCase() : SCOPE_PAGE;		if (scopeValue.equals(SCOPE_PAGE)) {			pageContext.removeAttribute(name);		}		else if (scopeValue.equals(SCOPE_REQUEST)) {			request.removeAttribute(name);		}		else if (scopeValue.equals(SCOPE_SESSION)) {			request.getSession().removeAttribute(name);		}		else if (scopeValue.equals(SCOPE_APPLICATION)) {            request.getServletContext().removeAttribute(name);        }		else {			throw new IllegalArgumentException("Invalid scope: " + scope);        }	}
public static boolean isAbsoluteUrl(final String url) {	    if (url == null) {      	    // a null URL is not absolute		    return false;	    }	    int colonPos;                   // fast simple check first	    if ((colonPos = url.indexOf(':')) == -1) {		    return false;	    }	    // if we DO have a colon, make sure that every character	    // leading up to it is a valid scheme character	    for (int i = 0; i < colonPos; i++) {		    if (VALID_SCHEME_CHARS.indexOf(url.charAt(i)) == -1) {			    return false;		    }	    }	    return true;    }
public static String stripSessionId(final String url) {		StringBuilder u = new StringBuilder(url);		int sessionStart;		while ((sessionStart = u.toString().indexOf(";jsessionid=")) != -1) {			int sessionEnd = u.toString().indexOf(';', sessionStart + 1);			if (sessionEnd == -1) {				sessionEnd = u.toString().indexOf('?', sessionStart + 1);			}			if (sessionEnd == -1) {				sessionEnd = u.length();			}			u.delete(sessionStart, sessionEnd);		}		return u.toString();	}
public static Object getRequestParameter(final ServletRequest request, final String name) {		String[] values = request.getParameterValues(name);		if (values == null) {			return null;		}		if (values.length == 1) {			return values[0];		}		return values;	}
public boolean isGetParameter(final HttpServletRequest request, String name) {		name = URLCoder.encodeQueryParam(name) + '=';		String query = request.getQueryString();		String[] nameValuePairs = StringUtil.splitc(query, '&');		for (String nameValuePair : nameValuePairs) {			if (nameValuePair.startsWith(name)) {				return true;			}		}		return false;	}
public static String[] prepareParameters(		final String[] paramValues,		final boolean treatEmptyParamsAsNull,		final boolean ignoreEmptyRequestParams) {		if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) {			int emptyCount = 0;			int total = paramValues.length;			for (int i = 0; i < paramValues.length; i++) {				String paramValue = paramValues[i];				if (paramValue == null) {					emptyCount++;					continue;				}				if (paramValue.length() == 0) {					emptyCount++;					if (treatEmptyParamsAsNull) {						paramValue = null;					}				}				paramValues[i] = paramValue;			}			if ((ignoreEmptyRequestParams) && (emptyCount == total)) {				return null;			}		}		return paramValues;	}
public static boolean isJsonRequest(HttpServletRequest servletRequest) {		final String contentType = servletRequest.getContentType();		if (contentType == null) {			return false;		}		return contentType.equals(MimeTypes.MIME_APPLICATION_JSON);	}
public static void copyParamsToAttributes(		final HttpServletRequest servletRequest,		final boolean treatEmptyParamsAsNull,		final boolean ignoreEmptyRequestParams) {		Enumeration paramNames = servletRequest.getParameterNames();		while (paramNames.hasMoreElements()) {			String paramName = (String) paramNames.nextElement();			if (servletRequest.getAttribute(paramName) != null) {				continue;			}			String[] paramValues = servletRequest.getParameterValues(paramName);			paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams);			if (paramValues == null) {				continue;			}			servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues);		}		// multipart		if (!(servletRequest instanceof MultipartRequestWrapper)) {			return;		}		MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest;		if (!multipartRequest.isMultipart()) {			return;		}		paramNames = multipartRequest.getFileParameterNames();		while (paramNames.hasMoreElements()) {			String paramName = (String) paramNames.nextElement();			if (servletRequest.getAttribute(paramName) != null) {				continue;			}			FileUpload[] paramValues = multipartRequest.getFiles(paramName);			servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues);		}	}
public static void invokeBody(final JspFragment body) throws JspException {		if (body == null) {			return;		}		try {			body.invoke(null);		} catch (IOException ioex) {			throw new JspException("Tag body failed", ioex);		}	}
public static char[] renderBody(final JspFragment body) throws JspException {		FastCharArrayWriter writer = new FastCharArrayWriter();		invokeBody(body, writer);		return writer.toCharArray();	}
public static String renderBodyToString(final JspFragment body) throws JspException {		char[] result = renderBody(body);		return new String(result);	}
public static void setScopeAttribute(final String name, final Object value, final String scope, final PageContext pageContext) throws JspException {		try {			ServletUtil.setScopeAttribute(name, value, scope, pageContext);		} catch (UncheckedException uex) {			throw new JspException(uex);        }	}
public static void removeScopeAttribute(final String name, final String scope, final PageContext pageContext) throws JspException {		try {			ServletUtil.removeScopeAttribute(name, scope, pageContext);		} catch (UncheckedException uex) {			throw new JspException(uex);        }	}
public void invokeInitMethods(final InitMethodInvocationStrategy invocationStrategy) {		for (final InitMethodPoint initMethod : beanDefinition.initMethodPoints()) {			if (invocationStrategy != initMethod.invocationStrategy) {				continue;			}			try {				initMethod.method.invoke(bean);			} catch (Exception ex) {				throw new PetiteException("Invalid init method: " + initMethod, ex);			}		}	}
public void callDestroyMethods() {		for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) {			try {				destroyMethodPoint.method.invoke(bean);			} catch (Exception ex) {				throw new PetiteException("Invalid destroy method: " + destroyMethodPoint.method, ex);			}		}	}
public Object newBeanInstance() {		if (beanDefinition.ctor == CtorInjectionPoint.EMPTY) {			throw new PetiteException("No constructor (annotated, single or default) founded as injection point for: " + beanDefinition.type.getName());		}		int paramNo = beanDefinition.ctor.references.length;		Object[] args = new Object[paramNo];		// wiring		if (beanDefinition.wiringMode != WiringMode.NONE) {			for (int i = 0; i < paramNo; i++) {				args[i] = pc.getBean(beanDefinition.ctor.references[i]);				if (args[i] == null) {					if ((beanDefinition.wiringMode == WiringMode.STRICT)) {						throw new PetiteException(							"Wiring constructor failed. References '" + beanDefinition.ctor.references[i] +								"' not found for constructor: " + beanDefinition.ctor.constructor);					}				}			}		}		// create instance		final Object bean;		try {			bean = beanDefinition.ctor.constructor.newInstance(args);		} catch (Exception ex) {			throw new PetiteException("Failed to create new bean instance '" + beanDefinition.type.getName() + "' using constructor: " + beanDefinition.ctor.constructor, ex);		}		return bean;	}
public void injectParams(final ParamManager paramManager, final boolean implicitParamInjection) {		if (beanDefinition.name == null) {			return;		}		if (implicitParamInjection) {			// implicit			final int len = beanDefinition.name.length() + 1;			for (final String param : beanDefinition.params) {				final Object value = paramManager.get(param);				final String destination = param.substring(len);				try {					BeanUtil.declared.setProperty(bean, destination, value);				} catch (Exception ex) {					throw new PetiteException("Unable to set parameter: '" + param + "' to bean: " + beanDefinition.name, ex);				}			}		}		// explicit		for (final ValueInjectionPoint pip : beanDefinition.values) {			final String value = paramManager.parseKeyTemplate(pip.valueTemplate);			try {				BeanUtil.declared.setProperty(bean, pip.property, value);			} catch (Exception ex) {				throw new PetiteException("Unable to set value for: '" + pip.valueTemplate + "' to bean: " + beanDefinition.name, ex);			}		}	}
@SuppressWarnings({"UnusedDeclaration"})	public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) {		return actionPath;	}
@Override	public void configure(final HasSubstring annotation) {		this.substring = annotation.value();		this.ignoreCase = annotation.ignoreCase();	}
@Override	public boolean isValid(final ValidationConstraintContext vcc, final Object value) {		return validate(value, substring, ignoreCase);	}
public void addHeader(final String name, final String value) {		List<String> valuesList = super.getAll(name);		if (valuesList.isEmpty()) {			super.add(name, value);			return;		}		super.remove(name);		valuesList.add(value);		super.addAll(name, valuesList);	}
@Override	public void configure(final Length annotation) {		this.min = annotation.min();		this.max = annotation.max();	}
@Override	public boolean isValid(final ValidationConstraintContext vcc, final Object value) {		return validate(value, min, max);	}
protected void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) {		String realValue = value;		if (append || appendDuplicateProps) {			PropsEntry pv = map.get(key);			if (pv != null) {				realValue = pv.value + APPEND_SEPARATOR + realValue;			}		}		PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this);		// update position pointers		if (first == null) {			first = propsEntry;		} else {			last.next = propsEntry;		}		last = propsEntry;		// add to the map		map.put(key, propsEntry);	}
public void putBaseProperty(final String key, final String value, final boolean append) {		put(null, baseProperties, key, value, append);	}
public int countProfileProperties() {		final HashSet<String> profileKeys = new HashSet<>();		for (final Map<String, PropsEntry> map : profileProperties.values()) {			for (final String key : map.keySet()) {				if (!baseProperties.containsKey(key)) {					profileKeys.add(key);				}			}		}		return profileKeys.size();	}
public void putProfileProperty(final String key, final String value, final String profile, final boolean append) {		Map<String, PropsEntry> map = profileProperties.computeIfAbsent(profile, k -> new HashMap<>());		put(profile, map, key, value, append);	}
public PropsEntry getProfileProperty(final String profile, final String key) {		final Map<String, PropsEntry> profileMap = profileProperties.get(profile);		if (profileMap == null) {			return null;		}		return profileMap.get(key);	}
protected String lookupValue(final String key, final String... profiles) {		if (profiles != null) {			for (String profile : profiles) {				if (profile == null) {					continue;				}				while (true) {					final Map<String, PropsEntry> profileMap = this.profileProperties.get(profile);					if (profileMap != null) {						final PropsEntry value = profileMap.get(key);						if (value != null) {							return value.getValue(profiles);						}					}					// go back with profile					final int ndx = profile.lastIndexOf('.');					if (ndx == -1) {						break;					}					profile = profile.substring(0, ndx);				}			}		}		final PropsEntry value = getBaseProperty(key);		if (value == null) {			return null;		}		return value.getValue(profiles);	}
public String resolveMacros(String value, final String... profiles) {		// create string template parser that will be used internally		StringTemplateParser stringTemplateParser = new StringTemplateParser();		stringTemplateParser.setResolveEscapes(false);		if (!ignoreMissingMacros) {			stringTemplateParser.setReplaceMissingKey(false);		} else {			stringTemplateParser.setReplaceMissingKey(true);			stringTemplateParser.setMissingKeyReplacement(StringPool.EMPTY);		}		final Function<String, String> macroResolver = macroName -> {			String[] lookupProfiles = profiles;			int leftIndex = macroName.indexOf('<');			if (leftIndex != -1) {				int rightIndex = macroName.indexOf('>');				String profiles1 = macroName.substring(leftIndex + 1, rightIndex);				macroName = macroName.substring(0, leftIndex).concat(macroName.substring(rightIndex + 1));				lookupProfiles = StringUtil.splitc(profiles1, ',');				StringUtil.trimAll(lookupProfiles);			}			return lookupValue(macroName, lookupProfiles);		};		// start parsing		int loopCount = 0;		while (loopCount++ < MAX_INNER_MACROS) {			final String newValue = stringTemplateParser.parse(value, macroResolver);			if (newValue.equals(value)) {				break;			}			if (skipEmptyProps) {				if (newValue.length() == 0) {					return null;				}			}			value = newValue;		}		return value;	}
public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) {		if (target == null) {			target = new HashMap();		}		// make sure prefix ends with a dot		if (prefix != null) {			if (!StringUtil.endsWithChar(prefix, '.')) {				prefix += StringPool.DOT;			}		}		if (profiles != null) {			for (String profile : profiles) {				while (true) {					final Map<String, PropsEntry> map = this.profileProperties.get(profile);					if (map != null) {						extractMap(target, map, profiles, wildcardPatterns, prefix);					}					final int ndx = profile.lastIndexOf('.');					if (ndx == -1) {						break;					}					profile = profile.substring(0, ndx);				}			}		}		extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix);		return target;	}
private static int streamtoword(byte[] data, int[] offp) {		int i;		int word = 0;		int off = offp[0];		for (i = 0; i < 4; i++) {			word = (word << 8) | (data[off] & 0xff);			off = (off + 1) % data.length;		}		offp[0] = off;		return word;	}
public static String hashpw(String password, String salt) {		BCrypt B;		String real_salt;		byte[] passwordb, saltb, hashed;		char minor = (char) 0;		int rounds, off;		StringBuffer rs = new StringBuffer();		if (salt.charAt(0) != '$' || salt.charAt(1) != '2') {			throw new IllegalArgumentException("Invalid salt version");		}		if (salt.charAt(2) == '$') {			off = 3;		}		else {			minor = salt.charAt(2);			if (minor != 'a' || salt.charAt(3) != '$') {				throw new IllegalArgumentException("Invalid salt revision");			}			off = 4;		}		// Extract number of rounds		if (salt.charAt(off + 2) > '$') {			throw new IllegalArgumentException("Missing salt rounds");		}		rounds = Integer.parseInt(salt.substring(off, off + 2));		real_salt = salt.substring(off + 3, off + 25);		try {			passwordb = (password + (minor >= 'a' ? "\000" : "")).getBytes("UTF-8");		}		catch (UnsupportedEncodingException uee) {			throw new AssertionError("UTF-8 is not supported");		}		saltb = decode_base64(real_salt, BCRYPT_SALT_LEN);		B = new BCrypt();		hashed = B.crypt_raw(passwordb, saltb, rounds,				(int[]) bf_crypt_ciphertext.clone());		rs.append("$2");		if (minor >= 'a') {			rs.append(minor);		}		rs.append('$');		if (rounds < 10) {			rs.append('0');		}		if (rounds > 30) {			throw new IllegalArgumentException(					"rounds exceeds maximum (30)");		}		rs.append(rounds)				.append('$')				.append(encode_base64(saltb, saltb.length))				.append(encode_base64(hashed,						bf_crypt_ciphertext.length * 4 - 1));		return rs.toString();	}
public static boolean checkpw(String plaintext, String hashed) {		byte[] hashed_bytes;		byte[] try_bytes;		try {			String try_pw = hashpw(plaintext, hashed);			hashed_bytes = hashed.getBytes("UTF-8");			try_bytes = try_pw.getBytes("UTF-8");		}		catch (UnsupportedEncodingException uee) {			return false;		}		if (hashed_bytes.length != try_bytes.length) {			return false;		}		byte ret = 0;		for (int i = 0; i < try_bytes.length; i++) {			ret |= hashed_bytes[i] ^ try_bytes[i];		}		return ret == 0;	}
public FileUploadHeader readDataHeader(final String encoding) throws IOException {		String dataHeader = readDataHeaderString(encoding);		if (dataHeader != null) {			lastHeader = new FileUploadHeader(dataHeader);		} else {			lastHeader = null;		}		return lastHeader;	}
public int copyAll(final OutputStream out) throws IOException {		int count = 0;		while (true) {			byte b = readByte();			if (isBoundary(b)) {				break;			}			out.write(b);			count++;		}		return count;	}
public int copyMax(final OutputStream out, final int maxBytes) throws IOException {		int count = 0;		while (true) {			byte b = readByte();			if (isBoundary(b)) {				break;			}			out.write(b);			count++;			if (count == maxBytes) {				return count;			}		}		return count;	}
public ActionDefinition parseActionDefinition(final Class<?> actionClass, final Method actionMethod) {		final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod);		final ActionConfig actionConfig = resolveActionConfig(annotationValues);		final String[] packageActionNames = readPackageActionPath(actionClass);		final String[] classActionNames = readClassActionPath(actionClass);		final String[] methodActionNames = readMethodActionPath(actionMethod.getName(), annotationValues, actionConfig);		final String method = readMethodHttpMethod(actionMethod);		final ActionNames actionNames = new ActionNames(packageActionNames, classActionNames, methodActionNames, method);		final ActionNamingStrategy namingStrategy;		try {			namingStrategy = ClassUtil.newInstance(actionConfig.getNamingStrategy());			contextInjectorComponent.injectContext(namingStrategy);		} catch (Exception ex) {			throw new MadvocException(ex);		}		return namingStrategy.buildActionDef(actionClass, actionMethod, actionNames);	}
public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) {		final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod);		final ActionConfig actionConfig = resolveActionConfig(annotationValues);		// interceptors		ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig);		// filters		ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig);		// build action definition when not provided		if (actionDefinition == null) {			actionDefinition = parseActionDefinition(actionClass, actionMethod);		}		detectAndRegisterAlias(annotationValues, actionDefinition);		final boolean async = parseMethodAsyncFlag(actionMethod);		final boolean auth = parseMethodAuthFlag(actionMethod);		final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod);		final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult();		return createActionRuntime(			null,			actionClass,			actionMethod,			actionResult,			defaultActionResult,			actionFilters,			actionInterceptors,			actionDefinition,			async,			auth);	}
protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) {		final Class<? extends Annotation> annotationType;		if (annotationValues == null) {			annotationType = Action.class;		}		else {			annotationType = annotationValues.annotationType();		}		return actionConfigManager.lookup(annotationType);	}
protected void detectAndRegisterAlias(final ActionAnnotationValues annotationValues, final ActionDefinition actionDefinition) {		final String alias = parseMethodAlias(annotationValues);		if (alias != null) {			String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH);			actionsManager.registerPathAlias(alias, aliasPath);		}	}
protected Class<? extends ActionInterceptor>[] readActionInterceptors(final AnnotatedElement actionClassOrMethod) {		Class<? extends ActionInterceptor>[] result = null;		InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class);		if (interceptedBy != null) {			result = interceptedBy.value();			if (result.length == 0) {				result = null;			}		}		return result;	}
protected Class<? extends ActionFilter>[] readActionFilters(final AnnotatedElement actionClassOrMethod) {		Class<? extends ActionFilter>[] result = null;		FilteredBy filteredBy = actionClassOrMethod.getAnnotation(FilteredBy.class);		if (filteredBy != null) {			result = filteredBy.value();			if (result.length == 0) {				result = null;			}		}		return result;	}
protected String[] readPackageActionPath(final Class actionClass) {		Package actionPackage = actionClass.getPackage();		final String actionPackageName = actionPackage.getName();		// 1 - read annotations first		String packageActionPathFromAnnotation;		mainloop:		while (true) {			MadvocAction madvocActionAnnotation = actionPackage.getAnnotation(MadvocAction.class);			packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation.value().trim() : null;			if (StringUtil.isEmpty(packageActionPathFromAnnotation)) {				packageActionPathFromAnnotation = null;			}			if (packageActionPathFromAnnotation == null) {				// next package				String newPackage = actionPackage.getName();				actionPackage = null;				while (actionPackage == null) {					final int ndx = newPackage.lastIndexOf('.');					if (ndx == -1) {						// end of hierarchy, nothing found						break mainloop;					}					newPackage = newPackage.substring(0, ndx);					actionPackage = Packages.of(actionClass.getClassLoader(), newPackage);				}			}			else {				// annotation found, register root				rootPackages.addRootPackage(actionPackage.getName(), packageActionPathFromAnnotation);				break;			}		}		// 2 - read root package		String packagePath = rootPackages.findPackagePathForActionPackage(actionPackageName);		if (packagePath == null) {			return ArraysUtil.array(null, null);		}		return ArraysUtil.array(			StringUtil.stripChar(packagePath, '/'),			StringUtil.surround(packagePath, StringPool.SLASH)		);	}
protected String[] readClassActionPath(final Class actionClass) {		// read class annotation		MadvocAction madvocActionAnnotation = ((Class<?>)actionClass).getAnnotation(MadvocAction.class);		String classActionPath = madvocActionAnnotation != null ? madvocActionAnnotation.value().trim() : null;		if (StringUtil.isEmpty(classActionPath)) {			classActionPath = null;		}		String actionClassName = actionClass.getSimpleName();		actionClassName = StringUtil.uncapitalize(actionClassName);		actionClassName = MadvocUtil.stripLastCamelWord(actionClassName);       // removes 'Action' from the class name		if (classActionPath == null) {			classActionPath = actionClassName;		}		return ArraysUtil.array(actionClassName, classActionPath);	}
protected String[] readMethodActionPath(final String methodName, final ActionAnnotationValues annotationValues, final ActionConfig actionConfig) {		// read annotation		String methodActionPath = annotationValues != null ? annotationValues.value() : null;		if (methodActionPath == null) {			methodActionPath = methodName;		} else {			if (methodActionPath.equals(Action.NONE)) {				return ArraysUtil.array(null, null);			}		}		// check for defaults		for (String path : actionConfig.getActionMethodNames()) {			if (methodActionPath.equals(path)) {				methodActionPath = null;				break;			}		}		return ArraysUtil.array(methodName, methodActionPath);	}
protected String parseMethodAlias(final ActionAnnotationValues annotationValues) {		String alias = null;		if (annotationValues != null) {			alias = annotationValues.alias();		}		return alias;	}
private String readMethodHttpMethod(final Method actionMethod) {		for (Class<? extends Annotation> methodAnnotation : METHOD_ANNOTATIONS) {			if (actionMethod.getAnnotation(methodAnnotation) != null) {				return methodAnnotation.getSimpleName();			}		}		return null;	}
public ActionRuntime createActionRuntime(		final ActionHandler actionHandler,		final Class actionClass,		final Method actionClassMethod,		final Class<? extends ActionResult> actionResult,		final Class<? extends ActionResult> defaultActionResult,		final ActionFilter[] filters,		final ActionInterceptor[] interceptors,		final ActionDefinition actionDefinition,		final boolean async,		final boolean auth)	{		if (actionHandler != null) {			return new ActionRuntime(				actionHandler,				actionClass,				actionClassMethod,				filters,				interceptors,				actionDefinition,				NoneActionResult.class,				NoneActionResult.class,				async,				auth,				null,				null);		}		final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass);		// find ins and outs		final Class[] paramTypes = actionClassMethod.getParameterTypes();		final MethodParam[] params = new MethodParam[paramTypes.length];		final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations();		String[] methodParamNames = null;		// for all elements: action and method arguments...		for (int ndx = 0; ndx < paramTypes.length; ndx++) {			Class paramType = paramTypes[ndx];			// lazy init to postpone bytecode usage, when method has no arguments			if (methodParamNames == null) {				methodParamNames = actionMethodParamNameResolver.resolveParamNames(actionClassMethod);			}			final String paramName = methodParamNames[ndx];			final Annotation[] parameterAnnotations = paramAnns[ndx];			final ScopeData paramsScopeData = scopeDataInspector.inspectMethodParameterScopes(paramName, paramType, parameterAnnotations);			MapperFunction mapperFunction = null;			for (final Annotation annotation : parameterAnnotations) {				if (annotation instanceof Mapper) {					mapperFunction = MapperFunctionInstances.get().lookup(((Mapper) annotation).value());					break;				}			}			params[ndx] = new MethodParam(				paramTypes[ndx],				paramName,				scopeDataInspector.detectAnnotationType(parameterAnnotations),				paramsScopeData,				mapperFunction			);		}		return new ActionRuntime(				null,				actionClass,				actionClassMethod,				filters,				interceptors,				actionDefinition,				actionResult,				defaultActionResult,				async,				auth,				scopeData,				params);	}
@Override	public Time get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getTime(index);	}
@Override	public void set(final PreparedStatement st, final int index, final Time value, final int dbSqlType) throws SQLException {		st.setTime(index, value);	}
@Override	protected void preResponseCommit() {		long lastModified = lastModifiedData.getLastModified();		long ifModifiedSince = request.getDateHeader("If-Modified-Since");		if (lastModified > -1 && !response.containsHeader("Last-Modified")) {			if (ifModifiedSince < (lastModified / 1000 * 1000)) {				response.setDateHeader("Last-Modified", lastModified);			} else {				response.reset();				response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);			}		}	}
public Boolean toBoolean(final Object value) {		final TypeConverter<Boolean> tc = TypeConverterManager.get().lookup(Boolean.class);		return tc.convert(value);	}
public Boolean toBoolean(final Object value, final Boolean defaultValue) {		final Boolean result = toBoolean(value);		if (result == null) {			return defaultValue;		}		return result;	}
public boolean toBooleanValue(final Object value, final boolean defaultValue) {		final Boolean result = toBoolean(value);		if (result == null) {			return defaultValue;		}		return result.booleanValue();	}
public Integer toInteger(final Object value) {		final TypeConverter<Integer> tc = TypeConverterManager.get().lookup(Integer.class);		return tc.convert(value);	}
public Integer toInteger(final Object value, final Integer defaultValue) {		final Integer result = toInteger(value);		if (result == null) {			return defaultValue;		}		return result;	}
public int toIntValue(final Object value, final int defaultValue) {		final Integer result = toInteger(value);		if (result == null) {			return defaultValue;		}		return result.intValue();	}
public Long toLong(final Object value) {		final TypeConverter<Long> tc = TypeConverterManager.get().lookup(Long.class);		return tc.convert(value);	}
public Long toLong(final Object value, final Long defaultValue) {		final Long result = toLong(value);		if (result == null) {			return defaultValue;		}		return result;	}
public long toLongValue(final Object value, final long defaultValue) {		final Long result = toLong(value);		if (result == null) {			return defaultValue;		}		return result.longValue();	}
public Float toFloat(final Object value) {		final TypeConverter<Float> tc = TypeConverterManager.get().lookup(Float.class);		return tc.convert(value);	}
public Float toFloat(final Object value, final Float defaultValue) {		final Float result = toFloat(value);		if (result == null) {			return defaultValue;		}		return result;	}
public float toFloatValue(final Object value, final float defaultValue) {		final Float result = toFloat(value);		if (result == null) {			return defaultValue;		}		return result.floatValue();	}
public Double toDouble(final Object value) {		final TypeConverter<Double> tc = TypeConverterManager.get().lookup(Double.class);		return tc.convert(value);	}
public Double toDouble(final Object value, final Double defaultValue) {		final Double result = toDouble(value);		if (result == null) {			return defaultValue;		}		return result;	}
public double toDoubleValue(final Object value, final double defaultValue) {		final Double result = toDouble(value);		if (result == null) {			return defaultValue;		}		return result.doubleValue();	}
public Short toShort(final Object value) {		final TypeConverter<Short> tc = TypeConverterManager.get().lookup(Short.class);		return tc.convert(value);	}
public Short toShort(final Object value, final Short defaultValue) {		final Short result = toShort(value);		if (result == null) {			return defaultValue;		}		return result;	}
public short toShortValue(final Object value, final short defaultValue) {		final Short result = toShort(value);		if (result == null) {			return defaultValue;		}		return result.shortValue();	}
public Character toCharacter(final Object value) {		final TypeConverter<Character> tc = TypeConverterManager.get().lookup(Character.class);		return tc.convert(value);	}
public Character toCharacter(final Object value, final Character defaultValue) {		final Character result = toCharacter(value);		if (result == null) {			return defaultValue;		}		return result;	}
public char toCharValue(final Object value, final char defaultValue) {		final Character result = toCharacter(value);		if (result == null) {			return defaultValue;		}		return result.charValue();	}
public Byte toByte(final Object value) {		final TypeConverter<Byte> tc = TypeConverterManager.get().lookup(Byte.class);		return tc.convert(value);	}
public Byte toByte(final Object value, final Byte defaultValue) {		final Byte result = toByte(value);		if (result == null) {			return defaultValue;		}		return result;	}
public byte toByteValue(final Object value, final byte defaultValue) {		final Byte result = toByte(value);		if (result == null) {			return defaultValue;		}		return result.byteValue();	}
public long[] toLongArray(final Object value) {		final TypeConverter<long[]> tc = TypeConverterManager.get().lookup(long[].class);		return tc.convert(value);	}
public String[] toStringArray(final Object value) {		final TypeConverter<String[]> tc = TypeConverterManager.get().lookup(String[].class);		return tc.convert(value);	}
public Class toClass(final Object value) {		final TypeConverter<Class> tc = TypeConverterManager.get().lookup(Class.class);		return tc.convert(value);	}
public BigInteger toBigInteger(final Object value) {		final TypeConverter<BigInteger> tc = TypeConverterManager.get().lookup(BigInteger.class);		return tc.convert(value);	}
public BigInteger toBigInteger(final Object value, final BigInteger defaultValue) {		final BigInteger result = toBigInteger(value);		if (result == null) {			return defaultValue;		}		return result;	}
public BigDecimal toBigDecimal(final Object value) {		final TypeConverter<BigDecimal> tc = TypeConverterManager.get().lookup(BigDecimal.class);		return tc.convert(value);	}
public BigDecimal toBigDecimal(final Object value, final BigDecimal defaultValue) {		final BigDecimal result = toBigDecimal(value);		if (result == null) {			return defaultValue;		}		return result;	}
@Override	public void configure(final Range annotation) {		this.min = annotation.min();		this.max = annotation.max();	}
public void configure() {		long elapsed = System.currentTimeMillis();		final ClassScanner classScanner = new ClassScanner();		classScanner.detectEntriesMode(true);		classScanner.scanDefaultClasspath();		classScannerConsumers.accept(classScanner);		registerAsConsumer(classScanner);		try {			classScanner.start();		} catch (Exception ex) {			throw new PetiteException("Scan classpath error", ex);		}		elapsed = System.currentTimeMillis() - elapsed;		log.info("Petite configured in " + elapsed + " ms. Total beans: " + container.beansCount());	}
public void registerAsConsumer(final ClassScanner classScanner) {		classScanner.registerEntryConsumer(classPathEntry -> {			if (!classPathEntry.isTypeSignatureInUse(PETITE_BEAN_ANNOTATION_BYTES)) {				return;			}			final Class<?> beanClass;			try {				beanClass = classPathEntry.loadClass();			} catch (ClassNotFoundException cnfex) {				throw new PetiteException("Unable to load class: " + cnfex, cnfex);			}			if (beanClass == null) {				return;			}			final PetiteBean petiteBean = beanClass.getAnnotation(PetiteBean.class);			if (petiteBean == null) {				return;			}			container.registerPetiteBean(beanClass, null, null, null, false, null);		});	}
public static <T> T applyAdvice(final Class<T> targetClass) {		Class adviceClass = cache.get(targetClass);		if (adviceClass == null) {			// advice not yet created			adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define();			cache.put(targetClass, adviceClass);		}		// create new advice instance and injects target instance to it		try {			Object advice = ClassUtil.newInstance(adviceClass);			Field field = adviceClass.getField("$___target$0");			field.set(advice, targetClass);			return (T) advice;		} catch (Exception ex) {			throw new ProxettaException(ex);		}	}
public static void injectTargetIntoProxy(final Object proxy, final Object target) {		Class proxyClass = proxy.getClass();		try {			Field field = proxyClass.getField("$___target$0");			field.set(proxy, target);		} catch (Exception ex) {			throw new ProxettaException(ex);		}	}
public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {    if (fv != null) {      return fv.visitAnnotation(descriptor, visible);    }    return null;  }
public String resolveRealName(final String jsonName) {		if (jsonNames == null) {			return jsonName;		}		int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName);		if (jsonIndex == -1) {			return jsonName;		}		return realNames[jsonIndex];	}
public String resolveJsonName(final String realName) {		if (realNames == null) {			return realName;		}		int realIndex = ArraysUtil.indexOf(realNames, realName);		if (realIndex == -1) {			return realName;		}		return jsonNames[realIndex];	}
public TypeData lookupTypeData(final Class type) {		TypeData typeData = typeDataMap.get(type);		if (typeData == null) {			if (serializationSubclassAware) {				typeData = findSubclassTypeData(type);			}			if (typeData == null) {				typeData = scanClassForAnnotations(type);				typeDataMap.put(type, typeData);			}		}		return typeData;	}
protected TypeData _lookupTypeData(final Class type) {		TypeData typeData = typeDataMap.get(type);		if (typeData == null) {			typeData = scanClassForAnnotations(type);			typeDataMap.put(type, typeData);		}		return typeData;	}
protected TypeData findSubclassTypeData(final Class type) {		final Class<? extends Annotation> defaultAnnotation = jsonAnnotation;		if (type.getAnnotation(defaultAnnotation) != null) {			// current type has annotation, don't find anything, let type data be created			return null;		}		ClassDescriptor cd = ClassIntrospector.get().lookup(type);		// lookup superclasses		Class[] superClasses = cd.getAllSuperclasses();		for (Class superClass : superClasses) {			if (superClass.getAnnotation(defaultAnnotation) != null) {				// annotated subclass founded!				return _lookupTypeData(superClass);			}		}		Class[] interfaces = cd.getAllInterfaces();		for (Class interfaze : interfaces) {			if (interfaze.getAnnotation(defaultAnnotation) != null) {				// annotated subclass founded!				return _lookupTypeData(interfaze);			}		}		return null;	}
public String resolveJsonName(final Class type, final String name) {		TypeData typeData = lookupTypeData(type);		return typeData.resolveJsonName(name);	}
public String resolveRealName(final Class type, final String jsonName) {		TypeData typeData = lookupTypeData(type);		return typeData.resolveRealName(jsonName);	}
private TypeData scanClassForAnnotations(final Class type) {		ClassDescriptor cd = ClassIntrospector.get().lookup(type);		PropertyDescriptor[] pds = cd.getAllPropertyDescriptors();		ArrayList<String> includedList = new ArrayList<>();		ArrayList<String> excludedList = new ArrayList<>();		ArrayList<String> jsonNames = new ArrayList<>();		ArrayList<String> realNames = new ArrayList<>();		AnnotationParser annotationParser = JSONAnnotationValues.parserFor(jsonAnnotation);		for (PropertyDescriptor pd : pds) {			JSONAnnotationValues data = null;			{				MethodDescriptor md = pd.getReadMethodDescriptor();				if (md != null) {					Method method = md.getMethod();					data = JSONAnnotationValues.of(annotationParser, method);				}			}			if (data == null) {				MethodDescriptor md = pd.getWriteMethodDescriptor();				if (md != null) {					Method method = md.getMethod();					data = JSONAnnotationValues.of(annotationParser, method);				}			}			if (data == null) {				FieldDescriptor fd = pd.getFieldDescriptor();				if (fd != null) {					Field field = fd.getField();					data = JSONAnnotationValues.of(annotationParser, field);				}			}			if (data != null) {				// annotation found				String propertyName = pd.getName();				String newPropertyName = data.name();				if (newPropertyName != null) {					realNames.add(propertyName);					jsonNames.add(newPropertyName);					propertyName = newPropertyName;				}				if (data.include()) {					includedList.add(propertyName);				} else {					excludedList.add(propertyName);				}			}		}		String[] reals = null;		if (!realNames.isEmpty()) {			reals = realNames.toArray(new String[0]);		}		String[] jsons = null;			if (!jsonNames.isEmpty()) {			jsons = jsonNames.toArray(new String[0]);		}		// type		JSONAnnotationValues data = JSONAnnotationValues.of(annotationParser, type);		return new TypeData(includedList, excludedList, data != null && data.strict(), jsons, reals);	}
protected boolean matchFileExtension() throws IOException {		String fileNameExtension = FileNameUtil.getExtension(getHeader().getFileName());		for (String fileExtension : fileExtensions) {			if (fileNameExtension.equalsIgnoreCase(fileExtension)) {				if (!allowFileExtensions) {	// extension matched and it is not allowed					if (breakOnError) {						throw new IOException("Upload filename extension not allowed: " + fileNameExtension);					}					size = input.skipToBoundary();					return false;				}				return true;		// extension matched and it is allowed.			}		}		if (allowFileExtensions) {	// extension is not one of the allowed ones.			if (breakOnError) {				throw new IOException("Upload filename extension not allowed: " + fileNameExtension);			}			size = input.skipToBoundary();			return false;		}		return true;	}
@Override	public byte[] getFileContent() throws IOException {		if (data != null) {			return data;		}		if (tempFile != null) {			return FileUtil.readBytes(tempFile);		}		return null;	}
private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) {    // Find attributOffset of the 'bootstrap_methods' array.    byte[] inputBytes = classReader.b;    int currentAttributeOffset = classReader.getFirstAttributeOffset();    for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {      String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {        bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6);        break;      }      currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2);    }    if (bootstrapMethodCount > 0) {      // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array.      int bootstrapMethodsOffset = currentAttributeOffset + 8;      int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2;      bootstrapMethods = new ByteVector(bootstrapMethodsLength);      bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength);      // Add each bootstrap method in the symbol table entries.      int currentOffset = bootstrapMethodsOffset;      for (int i = 0; i < bootstrapMethodCount; i++) {        int offset = currentOffset - bootstrapMethodsOffset;        int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset);        currentOffset += 2;        int numBootstrapArguments = classReader.readUnsignedShort(currentOffset);        currentOffset += 2;        int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode();        while (numBootstrapArguments-- > 0) {          int bootstrapArgument = classReader.readUnsignedShort(currentOffset);          currentOffset += 2;          hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode();        }        add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF));      }    }  }
int setMajorVersionAndClassName(final int majorVersion, final String className) {    this.majorVersion = majorVersion;    this.className = className;    return addConstantClass(className).index;  }
void putConstantPool(final ByteVector output) {    output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length);  }
void putBootstrapMethods(final ByteVector output) {    if (bootstrapMethods != null) {      output          .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS))          .putInt(bootstrapMethods.length + 2)          .putShort(bootstrapMethodCount)          .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);    }  }
private Entry put(final Entry entry) {    if (entryCount > (entries.length * 3) / 4) {      int currentCapacity = entries.length;      int newCapacity = currentCapacity * 2 + 1;      Entry[] newEntries = new Entry[newCapacity];      for (int i = currentCapacity - 1; i >= 0; --i) {        Entry currentEntry = entries[i];        while (currentEntry != null) {          int newCurrentEntryIndex = currentEntry.hashCode % newCapacity;          Entry nextEntry = currentEntry.next;          currentEntry.next = newEntries[newCurrentEntryIndex];          newEntries[newCurrentEntryIndex] = currentEntry;          currentEntry = nextEntry;        }      }      entries = newEntries;    }    entryCount++;    int index = entry.hashCode % entries.length;    entry.next = entries[index];    return entries[index] = entry;  }
private void add(final Entry entry) {    entryCount++;    int index = entry.hashCode % entries.length;    entry.next = entries[index];    entries[index] = entry;  }
Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);  }
Symbol addConstantMethodref(      final String owner, final String name, final String descriptor, final boolean isInterface) {    int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG;    return addConstantMemberReference(tag, owner, name, descriptor);  }
private Entry addConstantMemberReference(      final int tag, final String owner, final String name, final String descriptor) {    int hashCode = hash(tag, owner, name, descriptor);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag          && entry.hashCode == hashCode          && entry.owner.equals(owner)          && entry.name.equals(name)          && entry.value.equals(descriptor)) {        return entry;      }      entry = entry.next;    }    constantPool.put122(        tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));    return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode));  }
private void addConstantMemberReference(      final int index,      final int tag,      final String owner,      final String name,      final String descriptor) {    add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));  }
private Symbol addConstantIntegerOrFloat(final int tag, final int value) {    int hashCode = hash(tag, value);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {        return entry;      }      entry = entry.next;    }    constantPool.putByte(tag).putInt(value);    return put(new Entry(constantPoolCount++, tag, value, hashCode));  }
private void addConstantIntegerOrFloat(final int index, final int tag, final int value) {    add(new Entry(index, tag, value, hash(tag, value)));  }
private Symbol addConstantLongOrDouble(final int tag, final long value) {    int hashCode = hash(tag, value);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {        return entry;      }      entry = entry.next;    }    int index = constantPoolCount;    constantPool.putByte(tag).putLong(value);    constantPoolCount += 2;    return put(new Entry(index, tag, value, hashCode));  }
private void addConstantLongOrDouble(final int index, final int tag, final long value) {    add(new Entry(index, tag, value, hash(tag, value)));  }
int addConstantNameAndType(final String name, final String descriptor) {    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;    int hashCode = hash(tag, name, descriptor);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag          && entry.hashCode == hashCode          && entry.name.equals(name)          && entry.value.equals(descriptor)) {        return entry.index;      }      entry = entry.next;    }    constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));    return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index;  }
private void addConstantNameAndType(final int index, final String name, final String descriptor) {    final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;    add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));  }
int addConstantUtf8(final String value) {    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == Symbol.CONSTANT_UTF8_TAG          && entry.hashCode == hashCode          && entry.value.equals(value)) {        return entry.index;      }      entry = entry.next;    }    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;  }
private void addConstantUtf8(final int index, final String value) {    add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value)));  }
Symbol addConstantMethodHandle(      final int referenceKind,      final String owner,      final String name,      final String descriptor,      final boolean isInterface) {    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;    // Note that we don't need to include isInterface in the hash computation, because it is    // redundant with owner (we can't have the same owner with different isInterface values).    int hashCode = hash(tag, owner, name, descriptor, referenceKind);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag          && entry.hashCode == hashCode          && entry.data == referenceKind          && entry.owner.equals(owner)          && entry.name.equals(name)          && entry.value.equals(descriptor)) {        return entry;      }      entry = entry.next;    }    if (referenceKind <= Opcodes.H_PUTSTATIC) {      constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index);    } else {      constantPool.put112(          tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index);    }    return put(        new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode));  }
private void addConstantMethodHandle(      final int index,      final int referenceKind,      final String owner,      final String name,      final String descriptor) {    final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;    int hashCode = hash(tag, owner, name, descriptor, referenceKind);    add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));  }
Symbol addConstantDynamic(      final String name,      final String descriptor,      final Handle bootstrapMethodHandle,      final Object... bootstrapMethodArguments) {    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);    return addConstantDynamicOrInvokeDynamicReference(        Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);  }
Symbol addConstantInvokeDynamic(      final String name,      final String descriptor,      final Handle bootstrapMethodHandle,      final Object... bootstrapMethodArguments) {    Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);    return addConstantDynamicOrInvokeDynamicReference(        Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);  }
private Symbol addConstantDynamicOrInvokeDynamicReference(      final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag          && entry.hashCode == hashCode          && entry.data == bootstrapMethodIndex          && entry.name.equals(name)          && entry.value.equals(descriptor)) {        return entry;      }      entry = entry.next;    }    constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor));    return put(        new Entry(            constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));  }
private void addConstantDynamicOrInvokeDynamicReference(      final int tag,      final int index,      final String name,      final String descriptor,      final int bootstrapMethodIndex) {    int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);    add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));  }
private Symbol addConstantUtf8Reference(final int tag, final String value) {    int hashCode = hash(tag, value);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {        return entry;      }      entry = entry.next;    }    constantPool.put12(tag, addConstantUtf8(value));    return put(new Entry(constantPoolCount++, tag, value, hashCode));  }
private void addConstantUtf8Reference(final int index, final int tag, final String value) {    add(new Entry(index, tag, value, hash(tag, value)));  }
Symbol addBootstrapMethod(      final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {    ByteVector bootstrapMethodsAttribute = bootstrapMethods;    if (bootstrapMethodsAttribute == null) {      bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();    }    // The bootstrap method arguments can be Constant_Dynamic values, which reference other    // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool    // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified    // while adding the given bootstrap method to it, in the rest of this method.    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {      addConstant(bootstrapMethodArgument);    }    // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to    // compare it with existing ones, and will be reverted below if there is already a similar    // bootstrap method.    int bootstrapMethodOffset = bootstrapMethodsAttribute.length;    bootstrapMethodsAttribute.putShort(        addConstantMethodHandle(                bootstrapMethodHandle.getTag(),                bootstrapMethodHandle.getOwner(),                bootstrapMethodHandle.getName(),                bootstrapMethodHandle.getDesc(),                bootstrapMethodHandle.isInterface())            .index);    int numBootstrapArguments = bootstrapMethodArguments.length;    bootstrapMethodsAttribute.putShort(numBootstrapArguments);    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {      bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index);    }    // Compute the length and the hash code of the bootstrap method.    int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset;    int hashCode = bootstrapMethodHandle.hashCode();    for (Object bootstrapMethodArgument : bootstrapMethodArguments) {      hashCode ^= bootstrapMethodArgument.hashCode();    }    hashCode &= 0x7FFFFFFF;    // Add the bootstrap method to the symbol table or revert the above changes.    return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode);  }
private Symbol addBootstrapMethod(final int offset, final int length, final int hashCode) {    final byte[] bootstrapMethodsData = bootstrapMethods.data;    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == Symbol.BOOTSTRAP_METHOD_TAG && entry.hashCode == hashCode) {        int otherOffset = (int) entry.data;        boolean isSameBootstrapMethod = true;        for (int i = 0; i < length; ++i) {          if (bootstrapMethodsData[offset + i] != bootstrapMethodsData[otherOffset + i]) {            isSameBootstrapMethod = false;            break;          }        }        if (isSameBootstrapMethod) {          bootstrapMethods.length = offset; // Revert to old position.          return entry;        }      }      entry = entry.next;    }    return put(new Entry(bootstrapMethodCount++, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode));  }
int addMergedType(final int typeTableIndex1, final int typeTableIndex2) {    // TODO sort the arguments? The merge result should be independent of their order.    long data = typeTableIndex1 | (((long) typeTableIndex2) << 32);    int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2);    Entry entry = get(hashCode);    while (entry != null) {      if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) {        return entry.info;      }      entry = entry.next;    }    String type1 = typeTable[typeTableIndex1].value;    String type2 = typeTable[typeTableIndex2].value;    int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2));    put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex;    return commonSuperTypeIndex;  }
private int addTypeInternal(final Entry entry) {    if (typeTable == null) {      typeTable = new Entry[16];    }    if (typeCount == typeTable.length) {      Entry[] newTypeTable = new Entry[2 * typeTable.length];      System.arraycopy(typeTable, 0, newTypeTable, 0, typeTable.length);      typeTable = newTypeTable;    }    typeTable[typeCount++] = entry;    return put(entry).index;  }
protected float[] convertValueToArray(final Object value) {		if (value instanceof Collection) {			final Collection collection = (Collection) value;			final float[] target = new float[collection.size()];			int i = 0;			for (final Object element : collection) {				target[i] = convertType(element);				i++;			}			return target;		}		if (value instanceof Iterable) {			final Iterable iterable = (Iterable) value;			final ArrayList<Float> floatArrayList = new ArrayList<>();			for (final Object element : iterable) {				final float convertedValue = convertType(element);				floatArrayList.add(Float.valueOf(convertedValue));			}			final float[] array = new float[floatArrayList.size()];			for (int i = 0; i < floatArrayList.size(); i++) {				final Float f = floatArrayList.get(i);				array[i] = f.floatValue();			}			return array;		}		if (value instanceof CharSequence) {			final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS);			return convertArrayToArray(strings);		}		// everything else:		return convertToSingleElementArray(value);	}
private int hash(final String name) {		int h = 0;		for (int i = name.length() - 1; i >= 0; i--) {			char c = name.charAt(i);			if (!caseSensitive) {				if (c >= 'A' && c <= 'Z') {					c += 32;				}			}			h = 31 * h + c;		}		if (h > 0) {			return h;		}		if (h == Integer.MIN_VALUE) {			return Integer.MAX_VALUE;		}		return -h;	}
private boolean eq(final String name1, final String name2) {		int nameLen = name1.length();		if (nameLen != name2.length()) {			return false;		}		for (int i = nameLen - 1; i >= 0; i--) {			char c1 = name1.charAt(i);			char c2 = name2.charAt(i);			if (c1 != c2) {				if (caseSensitive) {					return false;				}				if (c1 >= 'A' && c1 <= 'Z') {					c1 += 32;				}				if (c2 >= 'A' && c2 <= 'Z') {					c2 += 32;				}				if (c1 != c2) {					return false;				}			}		}		return true;	}
public HttpMultiMap<V> clear() {		for (int i = 0; i < entries.length; i++) {			entries[i] = null;		}		head.before = head.after = head;		return this;	}
private HttpMultiMap<V> _set(final Iterable<Map.Entry<String, V>> map) {		clear();		for (Map.Entry<String, V> entry : map) {			add(entry.getKey(), entry.getValue());		}		return this;	}
public HttpMultiMap<V> remove(final String name) {		int h = hash(name);		int i = index(h);		_remove(h, i, name);		return this;	}
public V get(final String name) {		Map.Entry<String, V> entry = getEntry(name);		if (entry == null) {			return null;		}		return entry.getValue();	}
public Map.Entry<String, V> getEntry(final String name) {		int h = hash(name);		int i = index(h);		MapEntry<V> e = entries[i];		while (e != null) {			if (e.hash == h && eq(name, e.key)) {				return e;			}			e = e.next;		}		return null;	}
public List<V> getAll(final String name) {		LinkedList<V> values = new LinkedList<>();		int h = hash(name);		int i = index(h);		MapEntry<V> e = entries[i];		while (e != null) {			if (e.hash == h && eq(name, e.key)) {				values.addFirst(e.getValue());			}			e = e.next;		}		return values;	}
@Override	public Iterator<Map.Entry<String, V>> iterator() {		final MapEntry[] e = {head.after};		return new Iterator<Map.Entry<String, V>>() {			@Override			public boolean hasNext() {				return e[0] != head;			}			@Override			@SuppressWarnings("unchecked")			public Map.Entry<String, V> next() {				if (!hasNext()) {					throw new NoSuchElementException("No next() entry in the iteration");				}				MapEntry<V> next = e[0];				e[0] = e[0].after;				return next;			}			@Override			public void remove() {				throw new UnsupportedOperationException();			}		};	}
public List<Map.Entry<String, V>> entries() {		List<Map.Entry<String, V>> all = new LinkedList<>();		MapEntry<V> e = head.after;		while (e != head) {			all.add(e);			e = e.after;		}		return all;	}
private void grow(final int minCapacity) {		final int oldCapacity = buffer.length;		int newCapacity = oldCapacity << 1;		if (newCapacity - minCapacity < 0) {			// special case, min capacity is larger then a grow			newCapacity = minCapacity + 512;		}		buffer = Arrays.copyOf(buffer, newCapacity);	}
@Override	public FastCharBuffer append(final char element) {		if (offset - buffer.length >= 0) {			grow(offset);		}		buffer[offset++] = element;		return this;	}
public FastCharBuffer append(final FastCharBuffer buff) {		if (buff.offset == 0) {			return this;		}		append(buff.buffer, 0, buff.offset);		return this;	}
@Override	public FastCharBuffer append(final CharSequence csq, final int start, final int end) {		for (int i = start; i < end; i++) {			append(csq.charAt(i));		}		return this;	}
@Override	public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {		AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4]		return new AnnotationVisitorAdapter(destAnn);	}
@Override	public void visitEnd() {		createFirstChainDelegate_Continue(tmd);		for (int p = 0; p < tmd.proxyData.length; p++) {			tmd.selectCurrentProxy(p);			createProxyMethod(tmd);		}	}
protected void createFirstChainDelegate_Start() {		// check invalid access flags		int access = msign.getAccessFlags();		if (!wd.allowFinalMethods) {			if ((access & AsmUtil.ACC_FINAL) != 0) {   // detect final				throw new ProxettaException(					"Unable to create proxy for final method: " + msign + ". Remove final modifier or change the pointcut definition.");			}		}		// create proxy methods		tmd = new TargetMethodData(msign, aspectList);		access &= ~ACC_NATIVE;		access &= ~ACC_ABSTRACT;		methodVisitor = wd.dest.visitMethod(				access, tmd.msign.getMethodName(), tmd.msign.getDescription(), tmd.msign.getAsmMethodSignature(), null);	}
protected void createFirstChainDelegate_Continue(final TargetMethodData tmd) {		methodVisitor.visitCode();		if (tmd.msign.isStatic) {			loadStaticMethodArguments(methodVisitor, tmd.msign);			methodVisitor.visitMethodInsn(				INVOKESTATIC,				wd.thisReference,				tmd.firstMethodName(),				tmd.msign.getDescription(),				false);		} else {			loadSpecialMethodArguments(methodVisitor, tmd.msign);			methodVisitor.visitMethodInsn(				INVOKESPECIAL,				wd.thisReference,				tmd.firstMethodName(),				tmd.msign.getDescription(),				false);		}		visitReturn(methodVisitor, tmd.msign, false);		methodVisitor.visitMaxs(0, 0);		methodVisitor.visitEnd();	}
public void createProxyMethod(final TargetMethodData td) {		final ProxyAspectData aspectData = td.getProxyData();		int access = td.msign.getAccessFlags();		access &= ~ACC_NATIVE;		access &= ~ACC_ABSTRACT;		access = ProxettaAsmUtil.makePrivateFinalAccess(access);		final MethodVisitor mv = wd.dest.visitMethod(access, td.methodName(), td.msign.getDescription(), null, null);		mv.visitCode();		//*** VISIT ADVICE - called for each aspect and each method		aspectData.getAdviceClassReader().accept(new EmptyClassVisitor() {			@Override			public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {				if (!name.equals(ProxettaNames.executeMethodName)) {					return null;				}				return new HistoryMethodAdapter(mv) {					@Override					public void visitFieldInsn(final int opcode, String owner, String name, final String desc) {						if (owner.equals(aspectData.adviceReference)) {							owner = wd.thisReference;              // [F5]							name = adviceFieldName(name, aspectData.aspectIndex);						}						super.visitFieldInsn(opcode, owner, name, desc);					}					@Override					public void visitVarInsn(final int opcode, int var) {						var += (var == 0 ? 0 : td.msign.getAllArgumentsSize());						if (proxyInfoRequested) {							proxyInfoRequested = false;							if (opcode == ASTORE) {								ProxyTargetReplacement.info(mv, td.msign, var);							}						}						super.visitVarInsn(opcode, var);   // [F1]					}					@Override					public void visitIincInsn(int var, final int increment) {						var += (var == 0 ? 0 : td.msign.getAllArgumentsSize());						super.visitIincInsn(var, increment);  // [F1]					}					@Override					public void visitInsn(final int opcode) {						if (opcode == ARETURN) {							visitReturn(mv, td.msign, true);							return;						}						if (traceNext) {							if ((opcode == POP) || (opcode == POP2)) {      // [F3] - invoke invoked without assignment								return;							}						}						super.visitInsn(opcode);					}					@SuppressWarnings({"ParameterNameDiffersFromOverriddenParameter"})					@Override					public void visitMethodInsn(final int opcode, String string, String mname, final String mdesc, final boolean isInterface) {						if ((opcode == INVOKEVIRTUAL) || (opcode == INVOKEINTERFACE) || (opcode == INVOKESPECIAL)) {							if (string.equals(aspectData.adviceReference)) {								string = wd.thisReference;								mname = adviceMethodName(mname, aspectData.aspectIndex);							}						} else						if (opcode == INVOKESTATIC) {							if (string.equals(aspectData.adviceReference)) {								string = wd.thisReference;								mname = adviceMethodName(mname, aspectData.aspectIndex);							} else							if (string.endsWith('/' + TARGET_CLASS_NAME)) {								if (isInvokeMethod(mname, mdesc)) {           // [R7]									if (td.isLastMethodInChain()) {                            // last proxy method just calls super target method										if (!wd.isWrapper()) {											// PROXY											loadSpecialMethodArguments(mv, td.msign);											mv.visitMethodInsn(INVOKESPECIAL, wd.superReference, td.msign.getMethodName(), td.msign.getDescription(), isInterface);										} else {											// WRAPPER											mv.visitVarInsn(ALOAD, 0);											mv.visitFieldInsn(GETFIELD, wd.thisReference, wd.wrapperRef, wd.wrapperType);											loadVirtualMethodArguments(mv, td.msign);											if (wd.wrapInterface) {												mv.visitMethodInsn(													INVOKEINTERFACE,													wd.wrapperType.substring(1, wd.wrapperType.length() - 1),													td.msign.getMethodName(),													td.msign.getDescription(),													true);											} else {												mv.visitMethodInsn(													INVOKEVIRTUAL,													wd.wrapperType.substring(1, wd.wrapperType.length() - 1),													td.msign.getMethodName(),													td.msign.getDescription(),													isInterface);											}										}										prepareReturnValue(mv, td.msign, aspectData.maxLocalVarOffset);     // [F4]										traceNext = true;									} else {                                                    // calls next proxy method										loadSpecialMethodArguments(mv, td.msign);										mv.visitMethodInsn(INVOKESPECIAL, wd.thisReference, td.nextMethodName(), td.msign.getDescription(), isInterface);										visitReturn(mv, td.msign, false);									}									return;								}								if (isArgumentsCountMethod(mname, mdesc)) {		// [R2]									ProxyTargetReplacement.argumentsCount(mv, td.msign);									return;								}								if (isArgumentTypeMethod(mname, mdesc)) {      // [R3]									int argIndex = this.getArgumentIndex();									ProxyTargetReplacement.argumentType(mv, td.msign, argIndex);									return;								}								if (isArgumentMethod(mname, mdesc)) {           // [R4]									int argIndex = this.getArgumentIndex();									ProxyTargetReplacement.argument(mv, td.msign, argIndex);									return;								}								if (isSetArgumentMethod(mname, mdesc)) {           // [R5]									int argIndex = this.getArgumentIndex();									checkArgumentIndex(td.msign, argIndex);									mv.visitInsn(POP);									storeMethodArgumentFromObject(mv, td.msign, argIndex);									return;								}								if (isCreateArgumentsArrayMethod(mname, mdesc)) {  // [R6]									ProxyTargetReplacement.createArgumentsArray(mv, td.msign);									return;								}								if (isCreateArgumentsClassArrayMethod(mname, mdesc)) {     // [R11]									ProxyTargetReplacement.createArgumentsClassArray(mv, td.msign);									return;								}								if (isTargetMethod(mname, mdesc)) {       // [R9.1]									mv.visitVarInsn(ALOAD, 0);									return;								}								if (isTargetClassMethod(mname, mdesc)) {       // [R9]									ProxyTargetReplacement.targetClass(mv, td.msign);									//ProxyTargetReplacement.targetClass(mv, wd.superReference);									return;								}								if (isTargetMethodNameMethod(mname, mdesc)) {  // [R10]									ProxyTargetReplacement.targetMethodName(mv, td.msign);									return;								}								if (isTargetMethodSignatureMethod(mname, mdesc)) {									ProxyTargetReplacement.targetMethodSignature(mv, td.msign);									return;								}								if (isTargetMethodDescriptionMethod(mname, mdesc)) {									ProxyTargetReplacement.targetMethodDescription(mv, td.msign);									return;								}								if (isInfoMethod(mname, mdesc)) {									// we are NOT replacing info() here! First, we need to figure out									// what is the operand for the very next ASTORE instructions									// since we need to create an object and store it in this									// register - and reuse it, in replacement code.									//ProxyTargetReplacement.info(mv, td.msign);									proxyInfoRequested = true;									return;								}								if (isReturnTypeMethod(mname, mdesc)) {        // [R11]									ProxyTargetReplacement.returnType(mv, td.msign);									return;								}								if (isReturnValueMethod(mname, mdesc)) {									castToReturnType(mv, td.msign);									return;								}								if (isTargetMethodAnnotationMethod(mname, mdesc)) {									String[] args = getLastTwoStringArguments();									// pop current two args									mv.visitInsn(POP);									mv.visitInsn(POP);									ProxyTargetReplacement.targetMethodAnnotation(mv, td.msign, args);									return;								}								if (isTargetClassAnnotationMethod(mname, mdesc)) {									String[] args = getLastTwoStringArguments();									// pop current two args									mv.visitInsn(POP);									mv.visitInsn(POP);									ProxyTargetReplacement.targetClassAnnotation(mv, td.msign.getClassInfo(), args);									return;								}							}						}						super.visitMethodInsn(opcode, string, mname, mdesc, isInterface);					}				};			}		}, 0);	}
public static Path parse(final String path) {		return path == null ? new Path() : new Path(StringUtil.splitc(path, '.'));	}
public Path push(final CharSequence field) {		_push(field);		if (altPath != null) {			altPath.push(field);		}		return this;	}
public static void registerInServletContext(			final ServletContext servletContext,			final Class<? extends JoyContextListener> joyContextListenerClass	) {		try {			final JoyContextListener joyContextListener =				ClassUtil.newInstance(joyContextListenerClass);			joyContextListener.createJoyAndInitServletContext(servletContext);		} catch (Exception e) {			throw new JoyException(e);		}		servletContext.addListener(joyContextListenerClass);	}
protected JoddJoy createJoy() {		final JoddJoy joy = JoddJoy.get();		if (SystemUtil.info().isAtLeastJavaVersion(9)) {			joy.withScanner(joyScanner -> joyScanner.scanClasspathOf(this.getClass()));		}		return joy;	}
private void configureServletContext(final ServletContext servletContext) {		servletContext.addListener(jodd.servlet.RequestContextListener.class);		if (decoraEnabled) {			final FilterRegistration filter = servletContext.addFilter("decora", jodd.decora.DecoraServletFilter.class);			filter.addMappingForUrlPatterns(null, true, contextPath);		}		final FilterRegistration filter = servletContext.addFilter("madvoc", jodd.madvoc.MadvocServletFilter.class);		filter.addMappingForUrlPatterns(madvocDispatcherTypes, true, contextPath);	}
public int getInteger(final int index) {		try {			return statement.getInt(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public boolean getBoolean(final int index) {		try {			return statement.getBoolean(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public byte getByte(final int index) {		try {			return statement.getByte(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public double getDouble(final int index) {		try {			return statement.getDouble(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public float getFloat(final int index) {		try {			return statement.getFloat(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public String getString(final int index) {		try {			return statement.getString(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public long getLong(final int index) {		try {			return statement.getLong(index);		} catch (SQLException sex) {			throw newGetParamError(index, sex);		}	}
public Object execute() {		String methodName = targetMethodName();		Class returnType = returnType();		Object next = pathref.continueWith(this, methodName, returnType);		return ProxyTarget.returnValue(next);	}
private Map<String, FieldDescriptor> inspectFields() {		if (classDescriptor.isSystemClass()) {			return emptyFields();		}		final boolean scanAccessible = classDescriptor.isScanAccessible();		final Class type = classDescriptor.getType();		final Field[] fields = scanAccessible ? ClassUtil.getAccessibleFields(type) : ClassUtil.getSupportedFields(type);		final HashMap<String, FieldDescriptor> map = new HashMap<>(fields.length);		for (final Field field : fields) {			final String fieldName = field.getName();			if (fieldName.equals("serialVersionUID")) {				continue;			}			map.put(fieldName, createFieldDescriptor(field));		}		return map;	}
public FieldDescriptor[] getAllFieldDescriptors() {		if (allFields == null) {			FieldDescriptor[] allFields = new FieldDescriptor[fieldsMap.size()];			int index = 0;			for (FieldDescriptor fieldDescriptor : fieldsMap.values()) {				allFields[index] = fieldDescriptor;				index++;			}			Arrays.sort(allFields, Comparator.comparing(fd -> fd.getField().getName()));			this.allFields = allFields;		}		return allFields;	}
@Override	public Blob get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getBlob(index);	}
@Override	public void set(final PreparedStatement st, final int index, final Blob value, final int dbSqlType) throws SQLException {		st.setBlob(index, value);	}
@SuppressWarnings("unchecked")	@Override	protected <T> BeanDefinition<T> createBeanDefinitionForRegistration(			final String name,			Class<T> type,			final Scope scope,			final WiringMode wiringMode,			final Consumer<T> consumer)	{		if (proxetta != null) {			final Class originalType = type;			final ProxettaFactory builder = proxetta.proxy();			builder.setTarget(type);			type = builder.define();			return new ProxettaBeanDefinition(				name,				type,				scope,				wiringMode,				originalType,				proxetta.getAspects(new ProxyAspect[0]),				consumer);		}		return super.createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer);	}
public static DbTransactionMode convertToDbMode(final JtxTransactionMode txMode) {		final int isolation;		switch (txMode.getIsolationLevel()) {			case ISOLATION_DEFAULT: isolation = DbTransactionMode.ISOLATION_DEFAULT; break;			case ISOLATION_NONE: isolation = DbTransactionMode.ISOLATION_NONE; break;			case ISOLATION_READ_COMMITTED: isolation = DbTransactionMode.ISOLATION_READ_COMMITTED; break;			case ISOLATION_READ_UNCOMMITTED: isolation = DbTransactionMode.ISOLATION_READ_UNCOMMITTED; break;			case ISOLATION_REPEATABLE_READ: isolation = DbTransactionMode.ISOLATION_REPEATABLE_READ; break;			case ISOLATION_SERIALIZABLE: isolation = DbTransactionMode.ISOLATION_SERIALIZABLE; break;			default:				throw new IllegalArgumentException();		}		return new DbTransactionMode(isolation, txMode.isReadOnly());	}
@Override	public Character get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		if (TypesUtil.isIntegerType(dbSqlType)) {			return Character.valueOf((char) rs.getInt(index));		}		String s = rs.getString(index);		if (s == null) {			return null;		}		if (s.length() > 1) {			throw new DbSqlException("Char column size too long, should be 1");		}		return Character.valueOf(s.charAt(0));	}
@Override	public void set(final PreparedStatement st, final int index, final Character value, final int dbSqlType) throws SQLException {		if (TypesUtil.isIntegerType(dbSqlType)) {			st.setInt(index, value.charValue());			return;		}		st.setString(index, value.toString());	}
@Override	protected final void onSerializableProperty(String propertyName, final PropertyDescriptor propertyDescriptor) {		final Object value;		if (propertyDescriptor == null) {			// metadata - classname			value = source.getClass().getName();		} else {			value = readProperty(source, propertyDescriptor);			if ((value == null) && jsonContext.isExcludeNulls()) {				return;			}			// change name for properties			propertyName = typeData.resolveJsonName(propertyName);		}		onSerializableProperty(				propertyName,				propertyDescriptor == null ? null : propertyDescriptor.getType(),				value);	}
protected void onSerializableProperty(final String propertyName, final Class propertyType, final Object value) {		jsonContext.pushName(propertyName, count > 0);		jsonContext.serialize(value);		if (jsonContext.isNamePopped()) {			count++;		}	}
private Object readProperty(final Object source, final PropertyDescriptor propertyDescriptor) {		Getter getter = propertyDescriptor.getGetter(declared);		if (getter != null) {			try {				return getter.invokeGetter(source);			}			catch (Exception ex) {				throw new JsonException(ex);			}		}		return null;	}
public static boolean containsElement(final Object obj, final Object element) {		if (obj == null) {			return false;		}		if (obj instanceof String) {			if (element == null) {				return false;			}			return ((String) obj).contains(element.toString());		}		if (obj instanceof Collection) {			return ((Collection) obj).contains(element);		}		if (obj instanceof Map) {			return ((Map) obj).values().contains(element);		}		if (obj instanceof Iterator) {			Iterator iter = (Iterator) obj;			while (iter.hasNext()) {				Object o = iter.next();				if (equals(o, element)) {					return true;				}			}			return false;		}		if (obj instanceof Enumeration) {			Enumeration enumeration = (Enumeration) obj;			while (enumeration.hasMoreElements()) {				Object o = enumeration.nextElement();				if (equals(o, element)) {					return true;				}			}			return false;		}		if (obj.getClass().isArray()) {			int len = Array.getLength(obj);			for (int i = 0; i < len; i++) {				Object o = Array.get(obj, i);				if (equals(o, element)) {					return true;				}			}		}		return false;	}
public String compose(final Email email) {		if (getSession() == null) {			createSession(getProperties());		}		final OutputStreamTransport ost = new OutputStreamTransport(getSession());		final SendMailSession sendMailSession = new SendMailSession(getSession(), ost);		sendMailSession.sendMail(email);		return ost.getEml();	}
public String compose(final ReceivedEmail receivedEmail) {		Message msg = receivedEmail.originalMessage();		final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();		try {			msg.writeTo(outputStream);		} catch (IOException | MessagingException e) {			throw new MailException(e);		}		return outputStream.toString();	}
public FastDoubleBuffer append(final FastDoubleBuffer buff) {		if (buff.offset == 0) {			return this;		}		append(buff.buffer, 0, buff.offset);		return this;	}
private void rehash() {		int oldCapacity = table.length;		Entry[] oldMap = table;		int newCapacity = (oldCapacity << 1) + 1;		Entry[] newMap = new Entry[newCapacity];		modCount++;		threshold = (int) (newCapacity * loadFactor);		table = newMap;		for (int i = oldCapacity; i-- > 0; ) {			for (Entry old = oldMap[i]; old != null; ) {				Entry e = old;				old = old.next;				int index = (e.key & 0x7FFFFFFF) % newCapacity;				e.next = newMap[index];				newMap[index] = e;			}		}	}
public Object put(final int key, final Object value) {		// makes sure the key is not already in the IntHashMap.		Entry[] tab = table;		int index = (key & 0x7FFFFFFF) % tab.length;		for (Entry e = tab[index]; e != null; e = e.next) {			if (e.key == key) {				Object old = e.value;				e.value = value;				return old;			}		}		modCount++;		if (count >= threshold) {			// rehash the table if the threshold is exceeded			rehash();			tab = table;			index = (key & 0x7FFFFFFF) % tab.length;		}		// creates the new entry.		tab[index] = new Entry(key, value, tab[index]);		count++;		return null;	}
@Override	public void putAll(final Map t) {		for (Object o : t.entrySet()) {			Map.Entry e = (Map.Entry) o;			put(e.getKey(), e.getValue());		}	}
@Override	public void clear() {		Entry[] tab = table;		modCount++;		for (int index = tab.length; --index >= 0; ) {			tab[index] = null;		}		count = 0;	}
public FastLongBuffer append(final FastLongBuffer buff) {		if (buff.offset == 0) {			return this;		}		append(buff.buffer, 0, buff.offset);		return this;	}
public long[] toArray(final int start, final int len) {		final long[] array = new long[len];		if (len == 0) {			return array;		}		System.arraycopy(buffer, start, array, 0, len);		return array;	}
public Buffer append(final String string) {		ensureLast();		try {			byte[] bytes = string.getBytes(StringPool.ISO_8859_1);			last.append(bytes);			size += bytes.length;		} catch (UnsupportedEncodingException ignore) {		}		return this;	}
public Buffer append(final Uploadable uploadable) {		list.add(uploadable);		size += uploadable.getSize();		last = null;		return this;	}
public Buffer append(final Buffer buffer) {		if (buffer.list.isEmpty()) {			// nothing to append			return buffer;		}		list.addAll(buffer.list);		last = buffer.last;		size += buffer.size;		return this;	}
public void writeTo(final Writer writer) throws IOException {		for (Object o : list) {			if (o instanceof FastByteBuffer) {				FastByteBuffer fastByteBuffer = (FastByteBuffer) o;				byte[] array = fastByteBuffer.toArray();				writer.write(new String(array, StringPool.ISO_8859_1));			}			else if (o instanceof Uploadable) {				Uploadable uploadable = (Uploadable) o;				InputStream inputStream = uploadable.openInputStream();				try {					StreamUtil.copy(inputStream, writer, StringPool.ISO_8859_1);				}				finally {					StreamUtil.close(inputStream);				}			}		}	}
public void writeTo(final OutputStream out) throws IOException {		for (Object o : list) {			if (o instanceof FastByteBuffer) {				FastByteBuffer fastByteBuffer = (FastByteBuffer) o;				out.write(fastByteBuffer.toArray());			}			else if (o instanceof Uploadable) {				Uploadable uploadable = (Uploadable) o;				InputStream inputStream = uploadable.openInputStream();				try {					StreamUtil.copy(inputStream, out);				}				finally {					StreamUtil.close(inputStream);				}			}		}	}
public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException {		// start		final int size = size();		final int callbackSize = progressListener.callbackSize(size);		int count = 0;		// total count		int step = 0;		// step is offset in current chunk		progressListener.transferred(count);		// loop		for (Object o : list) {			if (o instanceof FastByteBuffer) {				FastByteBuffer fastByteBuffer = (FastByteBuffer) o;				byte[] bytes = fastByteBuffer.toArray();				int offset = 0;				while (offset < bytes.length) {					// calc the remaining sending chunk size					int chunk = callbackSize - step;					// check if this chunk size fits the bytes array					if (offset + chunk > bytes.length) {						chunk = bytes.length - offset;					}					// writes the chunk					out.write(bytes, offset, chunk);					offset += chunk;					step += chunk;					count += chunk;					// listener					if (step >= callbackSize) {						progressListener.transferred(count);						step -= callbackSize;					}				}			}			else if (o instanceof Uploadable) {				Uploadable uploadable = (Uploadable) o;				InputStream inputStream = uploadable.openInputStream();				int remaining = uploadable.getSize();				try {					while (remaining > 0) {						// calc the remaining sending chunk size						int chunk = callbackSize - step;						// check if this chunk size fits the remaining size						if (chunk > remaining) {							chunk = remaining;						}						// writes remaining chunk						StreamUtil.copy(inputStream, out, chunk);						remaining -= chunk;						step += chunk;						count += chunk;						// listener						if (step >= callbackSize) {							progressListener.transferred(count);							step -= callbackSize;						}					}				}				finally {					StreamUtil.close(inputStream);				}			}		}		// end		if (step != 0) {			progressListener.transferred(count);		}	}
private static String encode(final CharSequence text, final char[][] buff, final int bufflen) {		int len;		if ((text == null) || ((len = text.length()) == 0)) {			return StringPool.EMPTY;		}		StringBuilder buffer = new StringBuilder(len + (len >> 2));		for (int i = 0; i < len; i++) {			char c = text.charAt(i);			if (c < bufflen) {				buffer.append(buff[c]);			} else {				buffer.append(c);			}		}		return buffer.toString();	}
public String getString(final String key) {		CharSequence cs = (CharSequence) map.get(key);		return cs == null ? null : cs.toString();	}
public Integer getInteger(final String key) {		Number number = (Number) map.get(key);		if (number == null) {			return null;		}		if (number instanceof Integer) {			return (Integer) number;		}		return number.intValue();	}
public Long getLong(final String key) {		Number number = (Number) map.get(key);		if (number == null) {			return null;		}		if (number instanceof Long) {			return (Long) number;		}		return number.longValue();	}
public Double getDouble(final String key) {		Number number = (Number) map.get(key);		if (number == null) {			return null;		}		if (number instanceof Double) {			return (Double) number;		}		return number.doubleValue();	}
public Float getFloat(final String key) {		Number number = (Number) map.get(key);		if (number == null) {			return null;		}		if (number instanceof Float) {			return (Float) number;		}		return number.floatValue();	}
public JsonObject getJsonObject(final String key) {		Object val = map.get(key);		if (val instanceof Map) {			val = new JsonObject((Map) val);		}		return (JsonObject) val;	}
public JsonArray getJsonArray(final String key) {		Object val = map.get(key);		if (val instanceof List) {			val = new JsonArray((List) val);		}		return (JsonArray) val;	}
public byte[] getBinary(final String key) {		String encoded = (String) map.get(key);		return encoded == null ? null : Base64.getDecoder().decode(encoded);	}
@SuppressWarnings("unchecked")	public <T> T getValue(final String key) {		T val = (T) map.get(key);		if (val instanceof Map) {			return (T) new JsonObject((Map) val);		}		if (val instanceof List) {			return (T) new JsonArray((List) val);		}		return val;	}
public String getString(final String key, final String def) {		String val = getString(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public Integer getInteger(final String key, final Integer def) {		Integer val = getInteger(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public Long getLong(final String key, final Long def) {		Long val = getLong(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public Double getDouble(final String key, final Double def) {		Double val = getDouble(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public Float getFloat(final String key, final Float def) {		Float val = getFloat(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public Boolean getBoolean(final String key, final Boolean def) {		Boolean val = getBoolean(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public JsonObject getJsonObject(final String key, final JsonObject def) {		JsonObject val = getJsonObject(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public JsonArray getJsonArray(final String key, final JsonArray def) {		JsonArray val = getJsonArray(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public byte[] getBinary(final String key, final byte[] def) {		byte[] val = getBinary(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public <T> T getValue(final String key, final T def) {		T val = getValue(key);		if (val == null) {			if (map.containsKey(key)) {				return null;			}			return def;		}		return val;	}
public JsonObject put(final String key, final Enum value) {		Objects.requireNonNull(key);		map.put(key, value == null ? null : value.name());		return this;	}
public JsonObject put(final String key, final CharSequence value) {		Objects.requireNonNull(key);		map.put(key, value == null ? null : value.toString());		return this;	}
public JsonObject put(final String key, final String value) {		Objects.requireNonNull(key);		map.put(key, value);		return this;	}
public JsonObject putNull(final String key) {		Objects.requireNonNull(key);		map.put(key, null);		return this;	}
public JsonObject put(final String key, final byte[] value) {		Objects.requireNonNull(key);		map.put(key, value == null ? null : Base64.getEncoder().encodeToString(value));		return this;	}
public String[] getAllFolders() {		final Folder[] folders;		try {			folders = getService().getDefaultFolder().list("*");		} catch (final MessagingException msgexc) {			throw new MailException("Failed to connect to folder", msgexc);		}		final String[] folderNames = new String[folders.length];		for (int i = 0; i < folders.length; i++) {			final Folder folder = folders[i];			folderNames[i] = folder.getFullName();		}		return folderNames;	}
public void useFolder(final String folderName) {		closeFolderIfOpened(folder);		try {			this.folderName = folderName;			this.folder = getService().getFolder(folderName);			try {				folder.open(Folder.READ_WRITE);			} catch (final MailException ignore) {				folder.open(Folder.READ_ONLY);			}		} catch (final MessagingException msgexc) {			throw new MailException("Failed to connect to folder: " + folderName, msgexc);		}	}
public Folder getFolder(final String folder) {		try {			return getService().getFolder(folder);		} catch (MessagingException e) {			throw new MailException("Folder not found: " + folder, e);		}	}
public ReceivedEmail[] receiveEmail(final EmailFilter filter) {		return receiveMessages(filter, null, null, false, null);	}
public ReceivedEmail[] receiveEmailAndMarkSeen(final EmailFilter filter) {		final Flags flagsToSet = new Flags();		flagsToSet.add(Flags.Flag.SEEN);		return receiveMessages(filter, flagsToSet, null, false, null);	}
public ReceivedEmail[] receiveEmailAndDelete(final EmailFilter filter) {		final Flags flags = new Flags();		flags.add(Flags.Flag.SEEN);		flags.add(Flags.Flag.DELETED);		return receiveMessages(filter, flags, null, false, null);	}
ReceivedEmail[] receiveMessages(			final EmailFilter filter,			final Flags flagsToSet,			final Flags flagsToUnset,			final boolean envelope,			final Consumer<Message[]> processedMessageConsumer) {		useAndOpenFolderIfNotSet();		final Message[] messages;		try {			if (filter == null) {				messages = folder.getMessages();			} else {				messages = folder.search(filter.getSearchTerm());			}			if (messages.length == 0) {				return ReceivedEmail.EMPTY_ARRAY;			}			if (envelope) {				final FetchProfile fetchProfile = new FetchProfile();				fetchProfile.add(FetchProfile.Item.ENVELOPE);				fetchProfile.add(FetchProfile.Item.FLAGS);				folder.fetch(messages, fetchProfile);			}			// process messages			final ReceivedEmail[] emails = new ReceivedEmail[messages.length];			for (int i = 0; i < messages.length; i++) {				final Message msg = messages[i];				// we need to parse message BEFORE flags are set!				emails[i] = new ReceivedEmail(msg, envelope, attachmentStorage);				if (!EmailUtil.isEmptyFlags(flagsToSet)) {					emails[i].flags(flagsToSet);					msg.setFlags(flagsToSet, true);				}				if (!EmailUtil.isEmptyFlags(flagsToUnset)) {					emails[i].flags().remove(flagsToUnset);					msg.setFlags(flagsToUnset, false);				}				if (EmailUtil.isEmptyFlags(flagsToSet) && !emails[i].isSeen()) {					msg.setFlag(Flags.Flag.SEEN, false);				}			}			if (processedMessageConsumer != null) {				processedMessageConsumer.accept(messages);			}			// if messages were marked to be deleted, we need to expunge the folder			if (!EmailUtil.isEmptyFlags(flagsToSet)) {				if (flagsToSet.contains(Flags.Flag.DELETED)) {					folder.expunge();				}			}			return emails;		} catch (final MessagingException msgexc) {			throw new MailException("Failed to fetch messages", msgexc);		}	}
public void updateEmailFlags(final ReceivedEmail receivedEmail) {		useAndOpenFolderIfNotSet();		try {			folder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(),true);		} catch (MessagingException mex) {			throw new MailException("Failed to fetch messages", mex);		}	}
protected void closeFolderIfOpened(final Folder folder) {		if (folder != null) {			try {				folder.close(true);			} catch (final MessagingException ignore) {			}		}	}
DbQueryNamedParameter lookupNamedParameter(final String name) {		DbQueryNamedParameter p = rootNP;		while (p != null) {			if (p.equalsName(name)) {				return p;			}			p = p.next;		}		return null;	}
protected int getBatchParameterSize(final String name) {		if (batchParams == null) {			return 0;		}		Integer size = batchParams.get(name);		if (size == null) {			return 0;		}		return size.intValue();	}
void parseSql(final String sqlString) {		rootNP = null;		final int stringLength = sqlString.length();		final StringBuilder pureSql = new StringBuilder(stringLength);		boolean inQuote = false;		int index = 0;		int paramCount = 0;		while (index < stringLength) {			char c = sqlString.charAt(index);			if (inQuote) {				if (c == '\'') {					inQuote = false;				}			}			else if (c == '\'') {				inQuote = true;			}			else if (c == ':' && index + 1 < stringLength					&& sqlString.charAt(index + 1) == ':') {				// don't treat '::foo' sequence as named parameter; skip this				// chunk				int right = StringUtil.indexOfChars(sqlString,						SQL_SEPARATORS, index + 2);				if (right < 0) {					right = stringLength;				}				pureSql.append(sqlString.substring(index, right));				index = right;				continue;			}			else if (c == ':') {				int right = StringUtil.indexOfChars(sqlString, SQL_SEPARATORS, index + 1);				boolean batch = false;				if (right < 0) {					right = stringLength;				} else {					if (sqlString.charAt(right) == '!') {						batch = true;					}				}				String param = sqlString.substring(index + 1, right);				if (!batch) {					paramCount++;					storeNamedParameter(param, paramCount);					pureSql.append('?');				}				else {					// read batch size					right++;					int numStart = right;					while (right < stringLength) {						if (!CharUtil.isDigit(sqlString.charAt(right))) {							break;						}						right++;					}					String numberValue = sqlString.substring(numStart, right);					int batchSize;					try {						batchSize = Integer.parseInt(numberValue);					} catch (NumberFormatException nfex) {						throw new DbSqlException("Batch size is not an integer: " + numberValue, nfex);					}					saveBatchParameter(param, batchSize);					// create batch parameters					for (int i = 1; i <= batchSize; i++) {						if (i != 1) {							pureSql.append(',');						}						paramCount++;						storeNamedParameter(param + '.' + i, paramCount);						pureSql.append('?');					}				}				index = right;				continue;			}			else if (c == '?') {		// either an ordinal or positional parameter				if ((index < stringLength - 1) && (Character.isDigit(sqlString.charAt(index + 1)))) {   // positional parameter					int right = StringUtil.indexOfChars(sqlString, SQL_SEPARATORS, index + 1);					if (right < 0) {						right = stringLength;					}					String param = sqlString.substring(index + 1, right);					try {						Integer.parseInt(param);					} catch (NumberFormatException nfex) {						throw new DbSqlException("Positional parameter is not an integer: " + param, nfex);					}					paramCount++;					storeNamedParameter(param, paramCount);					pureSql.append('?');					index = right;					continue;				}				paramCount++;		// ordinal param			}			pureSql.append(c);			index++;		}		this.prepared = (paramCount != 0);		this.sql = pureSql.toString();		if (this.sql.startsWith("{")) {			this.callable = true;		}	}
protected String alias(final String target) {		return StringPool.LEFT_CHEV.concat(target).concat(StringPool.RIGHT_CHEV);	}
protected String alias(final Object target, final String targetMethodName) {		String targetClassName = target.getClass().getName();		targetClassName = StringUtil.cutToIndexOf(targetClassName, '$');		return '<' + targetClassName + '#' + targetMethodName + '>';	}
protected boolean validateAction(final String... profiles) {		prepareValidator();		vtor.useProfiles(profiles);		vtor.validate(this);		vtor.resetProfiles();		List<Violation> violations = vtor.getViolations();		return violations == null;	}
protected void addViolation(final String name, final Object invalidValue) {		prepareValidator();		vtor.addViolation(new Violation(name, this, invalidValue));	}
public boolean isVoidTag(final CharSequence tagName) {		for (String html5VoidTag : HTML5_VOID_TAGS) {			if (CharSequenceUtil.equalsToLowercase(tagName, html5VoidTag)) {				return true;			}		}		return false;	}
public RawData as(final String mimeOrExtension) {		if (mimeOrExtension.contains(StringPool.SLASH)) {			this.mimeType = mimeOrExtension;		}		else {			this.mimeType = MimeTypes.getMimeType(mimeOrExtension);		}		return this;	}
public RawData downloadableAs(final String downloadFileName) {		this.downloadFileName = downloadFileName;		this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName));		return this;	}
protected T setTarget(final InputStream target) {		assertTargetIsNotDefined();		targetInputStream = target;		targetClass = null;		targetClassName = null;		return _this();	}
protected T setTarget(final String targetName) {		assertTargetIsNotDefined();		try {			targetInputStream = ClassLoaderUtil.getClassAsStream(targetName);			if (targetInputStream == null) {				throw new ProxettaException("Target class not found: " + targetName);			}			targetClassName = targetName;			targetClass = null;		}		catch (IOException ioex) {			StreamUtil.close(targetInputStream);			throw new ProxettaException("Unable to get stream class name: " + targetName, ioex);		}		return _this();	}
public T setTarget(final Class target) {		assertTargetIsNotDefined();		try {			targetInputStream = ClassLoaderUtil.getClassAsStream(target);			if (targetInputStream == null) {				throw new ProxettaException("Target class not found: " + target.getName());			}			targetClass = target;			targetClassName = target.getName();		}		catch (IOException ioex) {			StreamUtil.close(targetInputStream);			throw new ProxettaException("Unable to stream class: " + target.getName(), ioex);		}		return _this();	}
protected String resolveClassNameSuffix() {		String classNameSuffix = proxetta.getClassNameSuffix();		if (classNameSuffix == null) {			return null;		}		if (!proxetta.isVariableClassName()) {			return classNameSuffix;		}		suffixCounter++;		return classNameSuffix + suffixCounter;	}
protected void process() {		if (targetInputStream == null) {			throw new ProxettaException("Target missing: " + targetClassName);		}		// create class reader		final ClassReader classReader;		try {			classReader = new ClassReader(targetInputStream);		} catch (IOException ioex) {			throw new ProxettaException("Error reading class input stream", ioex);		}		// reads information		final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader(proxetta.getClassLoader());		classReader.accept(targetClassInfoReader, 0);		this.destClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);		// create proxy		if (log.isDebugEnabled()) {			log.debug("processing: " + classReader.getClassName());		}		WorkData wd = process(classReader, targetClassInfoReader);		// store important data		proxyApplied = wd.proxyApplied;		proxyClassName = wd.thisReference.replace('/', '.');	}
public byte[] create() {		process();		byte[] result = toByteArray();		dumpClassInDebugFolder(result);		if ((!proxetta.isForced()) && (!isProxyApplied())) {			if (log.isDebugEnabled()) {				log.debug("Proxy not applied: " + StringUtil.toSafeString(targetClassName));			}			return null;		}		if (log.isDebugEnabled()) {			log.debug("Proxy created " + StringUtil.toSafeString(targetClassName));		}		return result;	}
public Class define() {		process();		if ((!proxetta.isForced()) && (!isProxyApplied())) {			if (log.isDebugEnabled()) {				log.debug("Proxy not applied: " + StringUtil.toSafeString(targetClassName));			}			if (targetClass != null) {				return targetClass;			}			if (targetClassName != null) {				try {					return ClassLoaderUtil.loadClass(targetClassName);				} catch (ClassNotFoundException cnfex) {					throw new ProxettaException(cnfex);				}			}		}		if (log.isDebugEnabled()) {			log.debug("Proxy created: " + StringUtil.toSafeString(targetClassName));		}		try {			ClassLoader classLoader = proxetta.getClassLoader();			if (classLoader == null) {				classLoader = ClassLoaderUtil.getDefaultClassLoader();				if ((classLoader == null) && (targetClass != null)) {					classLoader = targetClass.getClassLoader();				}			}			final byte[] bytes = toByteArray();			dumpClassInDebugFolder(bytes);			return DefineClass.of(getProxyClassName(), bytes, classLoader);		} catch (Exception ex) {			throw new ProxettaException("Class definition failed", ex);		}	}
public Object newInstance() {		Class type = define();		try {			return ClassUtil.newInstance(type);		} catch (Exception ex) {			throw new ProxettaException("Invalid Proxetta class", ex);		}	}
protected void dumpClassInDebugFolder(final byte[] bytes) {		File debugFolder = proxetta.getDebugFolder();		if (debugFolder == null) {			return;		}		if (!debugFolder.exists() || !debugFolder.isDirectory()) {			log.warn("Invalid debug folder: " + debugFolder);		}		String fileName = proxyClassName;		if (fileName == null) {			fileName = "proxetta-" + System.currentTimeMillis();		}		fileName += ".class";		File file = new File(debugFolder, fileName);		try {			FileUtil.writeBytes(file, bytes);		} catch (IOException ioex) {			log.warn("Error writing class as " + file, ioex);		}	}
public T from(final String personalName, final String from) {		return from(new EmailAddress(personalName, from));	}
public T to(final EmailAddress to) {		this.to = ArraysUtil.append(this.to, to);		return _this();	}
public T to(final String personalName, final String to) {		return to(new EmailAddress(personalName, to));	}
public T replyTo(final EmailAddress replyTo) {		this.replyTo = ArraysUtil.append(this.replyTo, replyTo);		return _this();	}
public T replyTo(final String personalName, final String replyTo) {		return replyTo(new EmailAddress(personalName, replyTo));	}
public T replyTo(final EmailAddress... replyTo) {		this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo));		return _this();	}
public T cc(final EmailAddress to) {		this.cc = ArraysUtil.append(this.cc, to);		return _this();	}
public T cc(final String personalName, final String cc) {		return cc(new EmailAddress(personalName, cc));	}
public T cc(final EmailAddress... ccs) {		this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs));		return _this();	}
public T subject(final String subject, final String encoding) {		subject(subject);		this.subjectEncoding = encoding;		return _this();	}
public T message(final String text, final String mimeType, final String encoding) {		return message(new EmailMessage(text, mimeType, encoding));	}
public T textMessage(final String text, final String encoding) {		return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding));	}
public T htmlMessage(final String html, final String encoding) {		return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding));	}
public T header(final String name, final String value) {		headers.put(name, value);		return _this();	}
public T headers(final Map<String, String> headersToSet) {		headers.putAll(headersToSet);		return _this();	}
public T headers(final Enumeration<Header> headersToSet) {		while (headersToSet.hasMoreElements()) {			final Header header = headersToSet.nextElement();			header(header.getName(), header.getValue());		}		return _this();	}
protected T storeAttachments(final List<EmailAttachment<? extends DataSource>> attachments) {		this.attachments.addAll(attachments);		return _this();	}
public T attachments(final List<EmailAttachment<? extends DataSource>> attachments) {		for (final EmailAttachment<?> attachment : attachments) {			attachment(attachment);		}		return _this();	}
public T attachment(final EmailAttachment<? extends DataSource> attachment) {		attachment.setContentId(null);		return storeAttachment(attachment);	}
public T embeddedAttachment(final EmailAttachmentBuilder builder) {		builder.setContentIdFromNameIfMissing();		// https://github.com/oblac/jodd/issues/546		// https://github.com/oblac/jodd/issues/404#issuecomment-297011351		// content disposition will be set to "inline"		builder.inline(true);		return embeddedAttachment(builder.buildByteArrayDataSource());	}
public T embeddedAttachment(final EmailAttachment<? extends DataSource> attachment) {		storeAttachment(attachment);		final List<EmailMessage> messages = messages();		final int size = messages.size();		if (size > 1) {			// Add to last message			final int lastMessagePos = size - 1;			final EmailMessage lastMessage = messages.get(lastMessagePos);			attachment.setEmbeddedMessage(lastMessage);		}		return _this();	}
protected EmailAddress[] valueOrEmptyArray(EmailAddress[] arr) {		if (arr == null) {			arr = EmailAddress.EMPTY_ARRAY;		}		return arr;	}
public static String get(final String name, final String defaultValue) {		Objects.requireNonNull(name);		String value = null;		try {			if (System.getSecurityManager() == null) {				value = System.getProperty(name);			} else {				value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name));			}		} catch (Exception ignore) {		}		if (value == null) {			return defaultValue;		}		return value;	}
public static boolean getBoolean(final String name, final boolean defaultValue) {		String value = get(name);		if (value == null) {			return defaultValue;		}		value = value.trim().toLowerCase();		switch (value) {			case "true" :			case "yes"  :			case "1"    :			case "on"   :				return true;			case "false":			case "no"   :			case "0"    :			case "off"  :				return false;			default:				return defaultValue;		}	}
public static long getInt(final String name, final int defaultValue) {		String value = get(name);		if (value == null) {			return defaultValue;		}		value = value.trim().toLowerCase();		try {			return Integer.parseInt(value);		}		catch (NumberFormatException nfex) {			return defaultValue;		}	}
public static long getLong(final String name, final long defaultValue) {		String value = get(name);		if (value == null) {			return defaultValue;		}		value = value.trim().toLowerCase();		try {			return Long.parseLong(value);		}		catch (NumberFormatException nfex) {			return defaultValue;		}	}
public Jerry parse(final char[] content) {			Document doc = domBuilder.parse(content);			return new Jerry(domBuilder, doc);		}
public Jerry parse(String content) {			if (content == null) {				content = StringPool.EMPTY;			}			Document doc = domBuilder.parse(content);			return new Jerry(domBuilder, doc);		}
public void append(final float element) {		if (offset - buffer.length >= 0) {			grow(offset);		}		buffer[offset++] = element;	}
public FastFloatBuffer append(final float[] array, final int off, final int len) {		if (offset + len - buffer.length > 0) {			grow(offset + len);		}		System.arraycopy(array, off, buffer, offset, len);		offset += len;		return this;	}
public FastFloatBuffer append(final FastFloatBuffer buff) {		if (buff.offset == 0) {			return this;		}		append(buff.buffer, 0, buff.offset);		return this;	}
boolean isEqualTypeName(final Type argumentType, final Class paramType) {		String s = argumentType.getClassName();		if (s.endsWith(ARRAY)) {		// arrays detected			String prefix = s.substring(0, s.length() - 2);			String bytecodeSymbol = primitives.get(prefix);			if (bytecodeSymbol != null) {				s = '[' + bytecodeSymbol;			} else {				s = "[L" + prefix + ';';			}		}		return s.equals(paramType.getName());	}
MethodParameter[] getResolvedParameters() {		if (paramExtractor == null) {			return MethodParameter.EMPTY_ARRAY;		}		if (!paramExtractor.debugInfoPresent) {			throw new ParamoException("Parameter names not available for method: "					+ declaringClass.getName() + '#' + methodName);		}		return paramExtractor.getMethodParameters();	}
protected int serializeKeyValue(final JsonContext jsonContext, final Path currentPath, final Object key, final Object value, int count) {		if ((value == null) && jsonContext.isExcludeNulls()) {			return count;		}		if (key != null) {			currentPath.push(key.toString());		} else {			currentPath.push(StringPool.NULL);		}		// check if we should include the field		boolean include = true;		if (value != null) {			// + all collections are not serialized by default			include = jsonContext.matchIgnoredPropertyTypes(value.getClass(), false, include);			// + path queries: excludes/includes			include = jsonContext.matchPathToQueries(include);		}		// done		if (!include) {			currentPath.pop();			return count;		}		if (key == null) {			jsonContext.pushName(null, count > 0);		} else {			jsonContext.pushName(key.toString(), count > 0);		}		jsonContext.serialize(value);		if (jsonContext.isNamePopped()) {			count++;		}		currentPath.pop();		return count;	}
protected String lookupAlias(final String alias) {		String value = actionsManager.lookupPathAlias(alias);		if (value == null) {			ActionRuntime cfg = actionsManager.lookup(alias);			if (cfg != null) {				value = cfg.getActionPath();			}		}		return value;	}
protected String resolveAlias(final String value) {		final StringBuilder result = new StringBuilder(value.length());		int i = 0;		int len = value.length();		while (i < len) {			int ndx = value.indexOf('<', i);			if (ndx == -1) {				// alias markers not found				if (i == 0) {					// try whole string as an alias					String alias = lookupAlias(value);					return (alias != null ? alias : value);				} else {					result.append(value.substring(i));				}				break;			}			// alias marked found			result.append(value.substring(i, ndx));			ndx++;			int ndx2 = value.indexOf('>', ndx);			String aliasName = (ndx2 == -1 ? value.substring(ndx) : value.substring(ndx, ndx2));			// process alias			String alias = lookupAlias(aliasName);			if (alias != null) {				result.append(alias);			}			else {				// alias not found				if (log.isWarnEnabled()) {					log.warn("Alias not found: " + aliasName);				}			}			i = ndx2 + 1;		}		// fix prefix '//' - may happened when aliases are used		i = 0; len = result.length();		while (i < len) {			if (result.charAt(i) != '/') {				break;			}			i++;		}		if (i > 1) {			return result.substring(i - 1, len);		}		return result.toString();	}
public ResultPath resolveResultPath(String path, String value) {		boolean absolutePath = false;		if (value != null) {			// [*] resolve alias in value			value = resolveAlias(value);			// [*] absolute paths			if (StringUtil.startsWithChar(value, '/')) {				absolutePath = true;				int dotNdx = value.indexOf("..");				if (dotNdx != -1) {					path = value.substring(0, dotNdx);					value = value.substring(dotNdx + 2);				} else {					path = value;					value = null;				}			} else {				// [*] resolve # in value and path				int i = 0;				while (i < value.length()) {					if (value.charAt(i) != '#') {						break;					}					int dotNdx = MadvocUtil.lastIndexOfSlashDot(path);					if (dotNdx != -1) {						// dot found						path = path.substring(0, dotNdx);					}					i++;				}				if (i > 0) {					// remove # from value					value = value.substring(i);					// [*] update path and value					if (StringUtil.startsWithChar(value, '.')) {						value = value.substring(1);					} else {						int dotNdx = value.indexOf("..");						if (dotNdx != -1) {							path += '.' + value.substring(0, dotNdx);							value = value.substring(dotNdx + 2);						} else {							if (value.length() > 0) {								if (StringUtil.endsWithChar(path, '/')) {									path += value;								} else {									path += '.' + value;								}							}							value = null;						}					}				}			}		}		if (!absolutePath) {			if (resultPathPrefix != null) {				path = resultPathPrefix + path;			}		}		return new ResultPath(path, value);	}
public String resolveResultPathString(final String path, final String value) {		final ResultPath resultPath = resolveResultPath(path, value);		final String result = resultPath.pathValue();		return resolveAlias(result);	}
public static int lastIndexOfSlashDot(final String str) {		int slashNdx = str.lastIndexOf('/');		int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx);		if (dotNdx == -1) {			if (slashNdx == -1) {				return -1;			}			slashNdx++;			if (slashNdx < str.length() - 1) {				dotNdx = slashNdx;			} else {				dotNdx = -1;			}		}		return dotNdx;	}
public static int lastIndexOfDotAfterSlash(final String str) {		int slashNdx = str.lastIndexOf('/');		slashNdx++;		return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx);	}
public static int indexOfDotAfterSlash(final String str) {		int slashNdx = str.lastIndexOf('/');		if (slashNdx == -1) {			slashNdx = 0;		}		return str.indexOf('.', slashNdx);	}
public static String stripLastCamelWord(String name) {		int ndx = name.length() - 1;		while (ndx >= 0) {			if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) {				break;			}			ndx--;		}		if (ndx >= 0) {			name = name.substring(0, ndx);		}		return name;	}
public String matchedName(final String value) {		// match		if (!value.startsWith(name)) {			return null;		}		final int requiredLen = name.length();		if (value.length() >= requiredLen + 1) {			final char c = value.charAt(requiredLen);			if ((c != '.') && (c != '[')) {				return null;			}		}		// get param		if (targetName == null) {			return value;		}		return targetName + value.substring(name.length());	}
public String encode(final SimTok simTok) {		final String json = JsonSerializer.create().deep(true).serialize(simTok);		final String p1 = Base64.encodeToString("JoddSimTok" + SALT_ROUNDS);		final String p2 = Base64.encodeToString(json);		final String salt = BCrypt.gensalt(SALT_ROUNDS);		final String p3 = BCrypt.hashpw(p1 + "." + p2 + "." + SECRET, salt);		return p1 + "." + p2 + "." + p3;	}
public SimTok decode(final String token) {		final int ndx = token.indexOf('.');		final String p1 = token.substring(0, ndx);		final int ndx2 = token.indexOf('.', ndx + 1);		final String p2 = token.substring(ndx + 1, ndx2);		final String p3 = token.substring(ndx2 + 1);		if (!BCrypt.checkpw(p1 + "." + p2 + "." + SECRET, p3)) {			return null;		}		final String p2Decoded = Base64.decodeToString(p2);		return JsonParser.create().parse(p2Decoded, SimTok.class);	}
public static String resolveTableName(final Class<?> type, final TableNamingStrategy tableNamingStrategy) {		String tableName = null;		final DbTable dbTable = type.getAnnotation(DbTable.class);		if (dbTable != null) {			tableName = dbTable.value().trim();		}		if ((tableName == null) || (tableName.length() == 0)) {			tableName = tableNamingStrategy.convertEntityNameToTableName(type);		} else {			if (!tableNamingStrategy.isStrictAnnotationNames()) {				tableName = tableNamingStrategy.applyToTableName(tableName);			}		}		return quoteIfRequired(tableName, tableNamingStrategy.isAlwaysQuoteNames(), tableNamingStrategy.getQuoteChar());	}
public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) {		String schemaName = null;		final DbTable dbTable = type.getAnnotation(DbTable.class);		if (dbTable != null) {			schemaName = dbTable.schema().trim();		}		if ((schemaName == null) || (schemaName.length() == 0)) {			schemaName = defaultSchemaName;		}		return schemaName;	}
public static boolean resolveIsAnnotated(final Class<?> type) {		DbTable dbTable = type.getAnnotation(DbTable.class);		return dbTable != null;	}
public static DbEntityColumnDescriptor resolveColumnDescriptors(		final DbEntityDescriptor dbEntityDescriptor,		final PropertyDescriptor property,		final boolean isAnnotated,		final ColumnNamingStrategy columnNamingStrategy) {		String columnName = null;		boolean isId = false;		Class<? extends SqlType> sqlTypeClass = null;		// read ID annotation		DbId dbId = null;		if (property.getFieldDescriptor() != null) {			dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class);		}		if (dbId == null && property.getReadMethodDescriptor() != null) {			dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class);		}		if (dbId == null && property.getWriteMethodDescriptor() != null) {			dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId.class);		}		if (dbId != null) {			columnName = dbId.value().trim();			sqlTypeClass = dbId.sqlType();			isId = true;		} else {			DbColumn dbColumn = null;			if (property.getFieldDescriptor() != null) {				dbColumn = property.getFieldDescriptor().getField().getAnnotation(DbColumn.class);			}			if (dbColumn == null && property.getReadMethodDescriptor() != null) {				dbColumn = property.getReadMethodDescriptor().getMethod().getAnnotation(DbColumn.class);			}			if (dbColumn == null && property.getWriteMethodDescriptor() != null) {				dbColumn = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbColumn.class);			}			if (dbColumn != null) {				columnName = dbColumn.value().trim();				sqlTypeClass = dbColumn.sqlType();			} else {				if (isAnnotated) {					return null;				}			}		}		if (StringUtil.isEmpty(columnName)) {			// default annotation value			columnName = columnNamingStrategy.convertPropertyNameToColumnName(property.getName());		} else {			if (!columnNamingStrategy.isStrictAnnotationNames()) {				columnName = columnNamingStrategy.applyToColumnName(columnName);			}		}		if (sqlTypeClass == SqlType.class) {			sqlTypeClass = null;		}		return new DbEntityColumnDescriptor(			dbEntityDescriptor,			quoteIfRequired(columnName, columnNamingStrategy.isAlwaysQuoteNames(), columnNamingStrategy.getQuoteChar()),			property.getName(),			property.getType(),			isId,			sqlTypeClass);	}
public static Class[] resolveMappedTypes(final Class type) {		DbMapTo dbMapTo = (DbMapTo) type.getAnnotation(DbMapTo.class);		if (dbMapTo == null) {			return null;		}		return dbMapTo.value();	}
private static String quoteIfRequired(final String name, final boolean alwaysQuoteNames, final char quoteChar) {		if (StringUtil.detectQuoteChar(name) != 0) {			return name;   // already quoted		}		if (alwaysQuoteNames && quoteChar != 0) {			return quoteChar + name + quoteChar;		}		return name;	}
public void init(final long[] key, final long[] tweak) {		final int newNw = key.length;		// only create new arrays if the value of N{w} changes (different key size)		if (nw != newNw) {			nw = newNw;			switch (nw) {				case WORDS_4:					pi = PI4;					rpi = RPI4;					r = R4;					break;				case WORDS_8:					pi = PI8;					rpi = RPI8;					r = R8;					break;				case WORDS_16:					pi = PI16;					rpi = RPI16;					r = R16;					break;				default:					throw new RuntimeException("Invalid threefish key");			}			this.k = new long[nw + 1];			// instantiation of these fields here for performance reasons			vd = new long[nw]; // v is the intermediate value v{d} at round d			ed = new long[nw]; // ed is the value of e{d} at round d			fd = new long[nw]; // fd is the value of f{d} at round d			ksd = new long[nw]; // ksd is the value of k{s} at round d		}		System.arraycopy(key, 0, this.k, 0, key.length);		long knw = EXTENDED_KEY_SCHEDULE_CONST;		for (int i = 0; i < nw; i++) {			knw ^= this.k[i];		}		this.k[nw] = knw;		// set tweak values		t[0] = tweak[0];		t[1] = tweak[1];		t[2] = t[0] ^ t[1];	}
public void blockEncrypt(final long[] p, final long[] c) {		// initial value = plain		System.arraycopy(p, 0, vd, 0, nw);		for (int d = 0; d < nr; d++) { // do the rounds			// calculate e{d,i}			if (d % SUBKEY_INTERVAL == 0) {				final int s = d / SUBKEY_INTERVAL;				keySchedule(s);				for (int i = 0; i < nw; i++) {					ed[i] = vd[i] + ksd[i];				}			} else {				System.arraycopy(vd, 0, ed, 0, nw);			}			for (int j = 0; j < nw / 2; j++) {				x[0] = ed[j * 2];				x[1] = ed[j * 2 + 1];				mix(j, d);				fd[j * 2] = y[0];				fd[j * 2 + 1] = y[1];			}			for (int i = 0; i < nw; i++) {				vd[i] = fd[pi[i]];			}		}		// do the last keyschedule		keySchedule(nr / SUBKEY_INTERVAL);		for (int i = 0; i < nw; i++) {			c[i] = vd[i] + ksd[i];		}	}
private void mix(final int j, final int d) {		y[0] = x[0] + x[1];		final long rotl = r[d % DEPTH_OF_D_IN_R][j];		// java left rotation for a long		y[1] = (x[1] << rotl) | (x[1] >>> (Long.SIZE - rotl));		y[1] ^= y[0];	}
public void blockDecrypt(final long[] c, final long[] p) {		// initial value = plain		System.arraycopy(c, 0, vd, 0, nw);		for (int d = nr; d > 0; d--) { // do the rounds			// calculate e{d,i}			if (d % SUBKEY_INTERVAL == 0) {				final int s = d / SUBKEY_INTERVAL;				keySchedule(s); // calculate same keys				for (int i = 0; i < nw; i++) {					fd[i] = vd[i] - ksd[i];				}			} else {				System.arraycopy(vd, 0, fd, 0, nw);			}			for (int i = 0; i < nw; i++) {				ed[i] = fd[rpi[i]];			}			for (int j = 0; j < nw / 2; j++) {				y[0] = ed[j * 2];				y[1] = ed[j * 2 + 1];				demix(j, d - 1);				vd[j * 2] = x[0];				vd[j * 2 + 1] = x[1];			}		}		// do the first keyschedule		keySchedule(0);		for (int i = 0; i < nw; i++) {			p[i] = vd[i] - ksd[i];		}	}
private void demix(final int j, final int d) {		y[1] ^= y[0];		final long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack!		// right shift		x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr);		x[0] = y[0] - x[1];	}
private void keySchedule(final int s) {		for (int i = 0; i < nw; i++) {			// just put in the main key first			ksd[i] = k[(s + i) % (nw + 1)];			// don't add anything for i = 0,...,Nw - 4			if (i == nw - 3) { // second to last				ksd[i] += t[s % TWEAK_VALUES];			} else if (i == nw - 2) { // first to last				ksd[i] += t[(s + 1) % TWEAK_VALUES];			} else if (i == nw - 1) { // last				ksd[i] += s;			}		}	}
public void init(final String keyMessage, final long tweak1, final long tweak2) {		long[] tweak = new long[] {tweak1, tweak2};		byte[] key = new byte[blockSize / Byte.SIZE];		byte[] keyData = StringUtil.getBytes(keyMessage);		System.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length);		init(bytesToLongs(key), tweak);	}
@Override	public byte[] encryptBlock(final byte[] content, final int offset) {				long[] contentBlock = bytesToLongs(content, offset, blockSizeInBytes);				long[] encryptedBlock = new long[blockSize / Long.SIZE];		blockEncrypt(contentBlock, encryptedBlock);		return longsToBytes(encryptedBlock);	}
protected static long[] bytesToLongs(final byte[] ba, final int offset, final int size) {		long[] result = new long[size >> 3];		int i8 = offset;		for (int i = 0; i < result.length; i++) {			result[i] = Bits.getLong(ba, i8);			i8 += 8;		}		return result;	}
public static int parseDigit(final char digit) {		if ((digit >= '0') && (digit <= '9')) {			return digit - '0';		}		if (CharUtil.isLowercaseAlpha(digit)) {			return 10 + digit - 'a';		}		return 10 + digit - 'A';	}
@Override	public void init(final FilterConfig filterConfig) throws ServletException {		final ServletContext servletContext = filterConfig.getServletContext();		madvoc = Madvoc.get(servletContext);		if (madvoc != null) {			log = LoggerFactory.getLogger(this.getClass());			madvocController =				madvoc.webapp().madvocContainer().requestComponent(MadvocController.class);			return;		}		final WebApp webApp = WebApp.get(servletContext);		if (webApp != null) {			log = LoggerFactory.getLogger(this.getClass());			madvocController =				webApp.madvocContainer().requestComponent(MadvocController.class);			return;		}		throw new ServletException("Neither Madvoc or WebApp found! Use MadvocContextListener to create Madvoc or " +			"WebApp#withServletContext() to make it available.");	}
@Override	public void doFilter(final ServletRequest req, final ServletResponse res, final FilterChain chain) throws IOException, ServletException {		HttpServletRequest request = (HttpServletRequest) req;		HttpServletResponse response = (HttpServletResponse) res;		String actionPath = DispatcherUtil.getServletPath(request);		try {			MadvocResponseWrapper madvocResponse = new MadvocResponseWrapper(response);			actionPath = madvocController.invoke(actionPath, request, madvocResponse);		} catch (Exception ex) {			log.error("Invoking action path failed: " + actionPath, ex);			throw new ServletException(ex);		}		if (actionPath != null) {	// action path is not consumed			boolean pathProcessed = processUnhandledPath(actionPath, req, res);			if (!pathProcessed) {				chain.doFilter(request, response);			}		}	}
public ParsedAddress parse(String email) {		email = email.trim();		// match all		final Matcher mailboxMatcher = MAILBOX_PATTERN().matcher(email);		final boolean mailboxMatcherMatches = mailboxMatcher.matches();		final String[] mailboxMatcherParts = mailboxMatcherMatches ? _calcMatcherParts(mailboxMatcher) : null;		final Matcher returnPathMatcher = RETURN_PATH_PATTERN().matcher(email);		final boolean returnPathMatches = returnPathMatcher.matches();		// extract		String personalName = null;		String localPart = null;		String domain = null;		InternetAddress internetAddress = null;		String returnPathAddress = null;		if (mailboxMatcherMatches) {			personalName = mailboxMatcherParts[0];			localPart = mailboxMatcherParts[1];			domain = mailboxMatcherParts[2];			internetAddress = pullFromGroups(mailboxMatcher);		}		if (returnPathMatches) {			if (internetAddress != null) {				returnPathAddress = internetAddress.getAddress();			} else {				returnPathAddress = StringPool.EMPTY;			}		}		return new ParsedAddress(mailboxMatcherMatches, personalName, localPart, domain, internetAddress, returnPathMatches, returnPathAddress);	}
public InternetAddress parseToInternetAddress(final String email) {		final ParsedAddress parsedAddress = parse(email);		if (!parsedAddress.isValid()) {			return null;		}		return parsedAddress.getInternetAddress();	}
public EmailAddress parseToEmailAddress(final String email) {		final ParsedAddress parsedAddress = parse(email);		if (!parsedAddress.isValid()) {			return null;		}		return new EmailAddress(parsedAddress.getPersonalName(), parsedAddress.getLocalPart() + '@' + parsedAddress.getDomain());	}
private void buildPatterns() {		// http://tools.ietf.org/html/rfc2822		// RFC 2822 2.2.2 Structured Header Field Bodies		final String CRLF = "\\r\\n";		final String WSP = "[ \\t]";		final String FWSP = "(?:" + WSP + "*" + CRLF + ")?" + WSP + "+";		// RFC 2822 3.2.1 Primitive tokens		final String D_QUOTE = "\\\"";		final String NO_WS_CTL = "\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F";		final String ASCII_TEXT = "[\\x01-\\x09\\x0B\\x0C\\x0E-\\x7F]";		// RFC 2822 3.2.2 Quoted characters		final String QUOTED_PAIR = "(?:\\\\" + ASCII_TEXT + ")";		// RFC 2822 3.2.3 CFWS specification		final String C_TEXT = "[" + NO_WS_CTL + "\\!-\\'\\*-\\[\\]-\\~]";		final String C_CONTENT = C_TEXT + "|" + QUOTED_PAIR; // + "|" + comment;		final String COMMENT = "\\((?:(?:" + FWSP + ")?" + C_CONTENT + ")*(?:" + FWSP + ")?\\)";		final String CFWS = "(?:(?:" + FWSP + ")?" + COMMENT + ")*(?:(?:(?:" + FWSP + ")?" + COMMENT + ")|(?:" + FWSP + "))";		// RFC 2822 3.2.4 Atom		final String A_TEXT =			"[a-zA-Z0-9\\!\\#-\\'\\*\\+\\-\\/\\=\\?\\^-\\`\\{-\\~"				+ (ALLOW_DOT_IN_ATEXT ? "\\." : "")				+ (ALLOW_SQUARE_BRACKETS_IN_ATEXT ? "\\[\\]" : "") + "]";		final String REGULAR_A_TEXT = "[a-zA-Z0-9\\!\\#-\\'\\*\\+\\-\\/\\=\\?\\^-\\`\\{-\\~]";		final String ATOM = "(?:" + CFWS + ")?" + A_TEXT + "+" + "(?:" + CFWS + ")?";		final String DOT_ATOM_TEXT = REGULAR_A_TEXT + "+" + "(?:" + "\\." + REGULAR_A_TEXT + "+)*";		final String CAP_DOT_ATOM_NO_CFWS = "(?:" + CFWS + ")?(" + DOT_ATOM_TEXT + ")(?:" + CFWS + ")?";		final String CAP_DOT_ATOM_TRAILING_CFWS = "(?:" + CFWS + ")?(" + DOT_ATOM_TEXT + ")(" + CFWS + ")?";		// RFC 2822 3.2.5 Quoted strings		final String Q_TEXT = "[" + NO_WS_CTL + "\\!\\#-\\[\\]-\\~]";		final String LOCAL_PART_Q_TEXT = "[" + NO_WS_CTL + (ALLOW_PARENS_IN_LOCALPART ? "\\!\\#-\\[\\]-\\~]" : "\\!\\#-\\'\\*-\\[\\]-\\~]");		final String Q_CONTENT = "(?:" + Q_TEXT + "|" + QUOTED_PAIR + ")";		final String LOCAL_PART_Q_CONTENT = "(?>" + LOCAL_PART_Q_TEXT + "|" + QUOTED_PAIR + ")";		final String QUOTED_STRING_WOCFWS = D_QUOTE + "(?>(?:" + FWSP + ")?" + Q_CONTENT + ")*(?:" + FWSP + ")?" + D_QUOTE;		final String QUOTED_STRING = "(?:" + CFWS + ")?" + QUOTED_STRING_WOCFWS + "(?:" + CFWS + ")?";		final String LOCAL_PART_QUOTED_STRING = "(?:" + CFWS + ")?(" + D_QUOTE + "(?:(?:" + FWSP + ")?" + LOCAL_PART_Q_CONTENT + ")*(?:" + FWSP + ")?" + D_QUOTE + ")(?:" + CFWS + ")?";		// RFC 2822 3.2.6 Miscellaneous tokens		final String WORD = "(?:(?:" + ATOM + ")|(?:" + QUOTED_STRING + "))";		// by 2822: phrase = 1*word / obs-phrase		// implemented here as: phrase = word (FWS word)*		// so that aaaa can't be four words, which can cause tons of recursive backtracking		final String PHRASE = WORD + "(?:(?:" + FWSP + ")" + WORD + ")*";		// RFC 1035 tokens for domain names		final String LETTER = "[a-zA-Z]";		final String LET_DIG = "[a-zA-Z0-9]";		final String LET_DIG_HYP = "[a-zA-Z0-9-]";		final String RFC_LABEL = LET_DIG + "(?:" + LET_DIG_HYP + "{0,61}" + LET_DIG + ")?";		final String RFC_1035_DOMAIN_NAME = RFC_LABEL + "(?:\\." + RFC_LABEL + ")*\\." + LETTER + "{2,6}";		// RFC 2822 3.4 Address specification		final String D_TEXT = "[" + NO_WS_CTL + "\\!-Z\\^-\\~]";		final String D_CONTENT = D_TEXT + "|" + QUOTED_PAIR;		final String CAP_DOMAIN_LITERAL_NO_CFWS = "(?:" + CFWS + ")?" + "(\\[" + "(?:(?:" + FWSP + ")?(?:" + D_CONTENT + ")+)*(?:" + FWSP + ")?\\])" + "(?:" + CFWS + ")?";		final String CAP_DOMAIN_LITERAL_TRAILING_CFWS = "(?:" + CFWS + ")?" + "(\\[" + "(?:(?:" + FWSP + ")?(?:" + D_CONTENT + ")+)*(?:" + FWSP + ")?\\])" + "(" + CFWS + ")?";		final String RFC_2822_DOMAIN = "(?:" + CAP_DOT_ATOM_NO_CFWS + "|" + CAP_DOMAIN_LITERAL_NO_CFWS + ")";		final String CAP_CFWSR_FC2822_DOMAIN = "(?:" + CAP_DOT_ATOM_TRAILING_CFWS + "|" + CAP_DOMAIN_LITERAL_TRAILING_CFWS + ")";		final String DOMAIN = ALLOW_DOMAIN_LITERALS ? RFC_2822_DOMAIN : "(?:" + CFWS + ")?(" + RFC_1035_DOMAIN_NAME + ")(?:" + CFWS + ")?";		final String CAP_CFWS_DOMAIN = ALLOW_DOMAIN_LITERALS ? CAP_CFWSR_FC2822_DOMAIN : "(?:" + CFWS + ")?(" + RFC_1035_DOMAIN_NAME + ")(" + CFWS + ")?";		final String LOCAL_PART = "(" + CAP_DOT_ATOM_NO_CFWS + "|" + LOCAL_PART_QUOTED_STRING + ")";		// uniqueAddrSpec exists so we can have a duplicate tree that has a capturing group		// instead of a non-capturing group for the trailing CFWS after the domain token		// that we wouldn't want if it was inside		// an angleAddr. The matching should be otherwise identical.		final String ADDR_SPEC = LOCAL_PART + "@" + DOMAIN;		final String UNIQUE_ADDR_SPEC = LOCAL_PART + "@" + CAP_CFWS_DOMAIN;		final String ANGLE_ADDR = "(?:" + CFWS + ")?<" + ADDR_SPEC + ">(" + CFWS + ")?";		final String NAME_ADDR = "(" + PHRASE + ")??(" + ANGLE_ADDR + ")";		final String MAIL_BOX = (ALLOW_QUOTED_IDENTIFIERS ? "(" + NAME_ADDR + ")|" : "") + "(" + UNIQUE_ADDR_SPEC + ")";		final String RETURN_PATH = "(?:(?:" + CFWS + ")?<((?:" + CFWS + ")?|" + ADDR_SPEC + ")>(?:" + CFWS + ")?)";		//private static final String mailboxList = "(?:(?:" + mailbox + ")(?:,(?:" + mailbox + "))*)";		//private static final String groupPostfix = "(?:" + CFWS + "|(?:" + mailboxList + ")" + ")?;(?:" + CFWS + ")?";		//private static final String groupPrefix = phrase + ":";		//private static final String group = groupPrefix + groupPostfix;		//private static final String address = "(?:(?:" + mailbox + ")|(?:" + group + "))"		// Java regex pattern for 2822		_MAILBOX_PATTERN = Pattern.compile(MAIL_BOX);		_ADDR_SPEC_PATTERN = Pattern.compile(ADDR_SPEC);		//final Pattern MAILBOX_LIST_PATTERN = Pattern.compile(mailboxList);		_COMMENT_PATTERN = Pattern.compile(COMMENT);		_QUOTED_STRING_WO_CFWS_PATTERN = Pattern.compile(QUOTED_STRING_WOCFWS);		_RETURN_PATH_PATTERN = Pattern.compile(RETURN_PATH);	}
private InternetAddress pullFromGroups(final Matcher m) {		InternetAddress currentInternetAddress;		final String[] parts = _calcMatcherParts(m);		if (parts[1] == null || parts[2] == null) {			return null;		}		// if for some reason you want to require that the result be re-parsable by		// InternetAddress, you		// could uncomment the appropriate stuff below, but note that not all the utility		// functions use pullFromGroups; some call getMatcherParts directly.		try {			//currentInternetAddress = new InternetAddress(parts[0] + " <" + parts[1] + "@" +			//                                 parts[2]+ ">", true);			// so it parses it OK, but since javamail doesn't extract too well			// we make sure that the consistent parts			// are correct			currentInternetAddress = new InternetAddress();			currentInternetAddress.setPersonal(parts[0]);			currentInternetAddress.setAddress(parts[1] + "@" + parts[2]);		} catch (final UnsupportedEncodingException uee) {			currentInternetAddress = null;		}		return currentInternetAddress;	}
private String getFirstComment(final String text) {		if (text == null) {			return null; // important		}		final Matcher m = _COMMENT_PATTERN.matcher(text);		if (!m.find()) {			return null;		}		return m.group().trim();    // must trim	}
private static String removeAnyBounding(final char s, final char e, final String str) {		if (str == null || str.length() < 2) {			return str;		}		if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) {			return str.substring(1, str.length() - 1);		}		return str;	}
protected <T> Methref<T> wrapTargetToMethref(final Class<T> target) {		return Methref.on(target);	}
public String path() {		if (methref != null) {			final String methodName = methref.ref();			return target.getName() + '#' + methodName;		}		return path;	}
public static File zlib(final File file) throws IOException {		if (file.isDirectory()) {			throw new IOException("Can't zlib folder");		}		FileInputStream fis = new FileInputStream(file);		Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION);		String zlibFileName = file.getAbsolutePath() + ZLIB_EXT;		DeflaterOutputStream dos = new DeflaterOutputStream(new FileOutputStream(zlibFileName), deflater);		try {			StreamUtil.copy(fis, dos);		} finally {			StreamUtil.close(dos);			StreamUtil.close(fis);		}		return new File(zlibFileName);	}
public static File gzip(final File file) throws IOException {		if (file.isDirectory()) {			throw new IOException("Can't gzip folder");		}		FileInputStream fis = new FileInputStream(file);		String gzipName = file.getAbsolutePath() + GZIP_EXT;		GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(gzipName));		try {			StreamUtil.copy(fis, gzos);		} finally {			StreamUtil.close(gzos);			StreamUtil.close(fis);		}		return new File(gzipName);	}
public static File ungzip(final File file) throws IOException {		String outFileName = FileNameUtil.removeExtension(file.getAbsolutePath());		File out = new File(outFileName);		out.createNewFile();		FileOutputStream fos = new FileOutputStream(out);		GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(file));		try {			StreamUtil.copy(gzis, fos);		} finally {			StreamUtil.close(fos);			StreamUtil.close(gzis);		}		return out;	}
public static File zip(final File file) throws IOException {		String zipFile = file.getAbsolutePath() + ZIP_EXT;		return ZipBuilder.createZipFile(zipFile)					.add(file).recursive().save()				.toZipFile();	}
public static List<String> listZip(final File zipFile) throws IOException {		List<String> entries = new ArrayList<>();		ZipFile zip = new ZipFile(zipFile);		Enumeration zipEntries = zip.entries();		while (zipEntries.hasMoreElements()) {			ZipEntry entry = (ZipEntry) zipEntries.nextElement();			String entryName = entry.getName();			entries.add(entryName);		}		return Collections.unmodifiableList(entries);	}
public static void unzip(final String zipFile, final String destDir, final String... patterns) throws IOException {		unzip(new File(zipFile), new File(destDir), patterns);	}
public static void addToZip(final ZipOutputStream zos, final File file, String path, final String comment, final boolean recursive) throws IOException {		if (!file.exists()) {			throw new FileNotFoundException(file.toString());		}		if (path == null) {			path = file.getName();		}		while (path.length() != 0 && path.charAt(0) == '/') {			path = path.substring(1);		}		boolean isDir = file.isDirectory();		if (isDir) {			// add folder record			if (!StringUtil.endsWithChar(path, '/')) {				path += '/';			}		}		ZipEntry zipEntry = new ZipEntry(path);		zipEntry.setTime(file.lastModified());		if (comment != null) {			zipEntry.setComment(comment);		}		if (isDir) {			zipEntry.setSize(0);			zipEntry.setCrc(0);		}		zos.putNextEntry(zipEntry);		if (!isDir) {			InputStream is = new FileInputStream(file);			try {				StreamUtil.copy(is, zos);			} finally {				StreamUtil.close(is);			}		}		zos.closeEntry();		// continue adding		if (recursive && file.isDirectory()) {			boolean noRelativePath = StringUtil.isEmpty(path);			final File[] children = file.listFiles();			if (children != null && children.length != 0) {				for (File child : children) {					String childRelativePath = (noRelativePath ? StringPool.EMPTY : path) + child.getName();					addToZip(zos, child, childRelativePath, comment, recursive);				}			}		}	}
public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException {		while (path.length() != 0 && path.charAt(0) == '/') {			path = path.substring(1);		}		if (StringUtil.endsWithChar(path, '/')) {			path = path.substring(0, path.length() - 1);		}		ZipEntry zipEntry = new ZipEntry(path);		zipEntry.setTime(System.currentTimeMillis());		if (comment != null) {			zipEntry.setComment(comment);		}		zos.putNextEntry(zipEntry);		InputStream is = new ByteArrayInputStream(content);		try {			StreamUtil.copy(is, zos);		} finally {			StreamUtil.close(is);		}		zos.closeEntry();	}
public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) {		final FieldDescriptor fieldDescriptor = getFields().getFieldDescriptor(name);		if (fieldDescriptor != null) {			if (!fieldDescriptor.matchDeclared(declared)) {				return null;			}		}		return fieldDescriptor;	}
public MethodDescriptor getMethodDescriptor(final String name, final boolean declared) {		final MethodDescriptor methodDescriptor = getMethods().getMethodDescriptor(name);		if ((methodDescriptor != null) && methodDescriptor.matchDeclared(declared)) {			return methodDescriptor;		}		return methodDescriptor;	}
public PropertyDescriptor getPropertyDescriptor(final String name, final boolean declared) {		PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name);		if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) {			return propertyDescriptor;		}		return null;	}
public CtorDescriptor getDefaultCtorDescriptor(final boolean declared) {		CtorDescriptor defaultCtor = getCtors().getDefaultCtor();		if ((defaultCtor != null) && defaultCtor.matchDeclared(declared)) {			return defaultCtor;		}		return null;	}
public CtorDescriptor getCtorDescriptor(final Class[] args, final boolean declared) {		CtorDescriptor ctorDescriptor = getCtors().getCtorDescriptor(args);		if ((ctorDescriptor != null) && ctorDescriptor.matchDeclared(declared)) {			return ctorDescriptor;		}		return null;	}
public static void setRequestBundleName(final ServletRequest request, final String bundleName) {		if (log.isDebugEnabled()) {			log.debug("Bundle name for this request: " + bundleName);		}		request.setAttribute(REQUEST_BUNDLE_NAME_ATTR, bundleName);	}
public static void setSessionLocale(final HttpSession session, final String localeCode) {		if (log.isDebugEnabled()) {			log.debug("Locale stored to session: " + localeCode);		}		Locale locale = Locale.forLanguageTag(localeCode);		session.setAttribute(SESSION_LOCALE_ATTR, locale);	}
public static Locale getSessionLocale(final HttpSession session) {		Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR);		return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale;	}
@Override	public void contextInitialized(final ServletContextEvent servletContextEvent) {		ServletContext servletContext = servletContextEvent.getServletContext();		madvoc = new Madvoc();		madvoc.configureWith(servletContext);		madvoc.startWebApplication(servletContext);	}
public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) {		beanName = beanName + '.';		List<String> list = new ArrayList<>();		for (Map.Entry<String, Object> entry : params.entrySet()) {			String key = entry.getKey();			if (!key.startsWith(beanName)) {				continue;			}			list.add(key);			if (!resolveReferenceParams) {				continue;			}			// resolve all references			String value = PropertiesUtil.resolveProperty(params, key);			entry.setValue(value);		}		if (list.isEmpty()) {			return StringPool.EMPTY_ARRAY;		} else {			return list.toArray(new String[0]);		}	}
@Override  public void visit(final String name, final Object value) {    // Case of an element_value with a const_value_index, class_info_index or array_index field.    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.    ++numElementValuePairs;    if (useNamedValues) {      annotation.putShort(symbolTable.addConstantUtf8(name));    }    if (value instanceof String) {      annotation.put12('s', symbolTable.addConstantUtf8((String) value));    } else if (value instanceof Byte) {      annotation.put12('B', symbolTable.addConstantInteger(((Byte) value).byteValue()).index);    } else if (value instanceof Boolean) {      int booleanValue = ((Boolean) value).booleanValue() ? 1 : 0;      annotation.put12('Z', symbolTable.addConstantInteger(booleanValue).index);    } else if (value instanceof Character) {      annotation.put12('C', symbolTable.addConstantInteger(((Character) value).charValue()).index);    } else if (value instanceof Short) {      annotation.put12('S', symbolTable.addConstantInteger(((Short) value).shortValue()).index);    } else if (value instanceof Type) {      annotation.put12('c', symbolTable.addConstantUtf8(((Type) value).getDescriptor()));    } else if (value instanceof byte[]) {      byte[] byteArray = (byte[]) value;      annotation.put12('[', byteArray.length);      for (byte byteValue : byteArray) {        annotation.put12('B', symbolTable.addConstantInteger(byteValue).index);      }    } else if (value instanceof boolean[]) {      boolean[] booleanArray = (boolean[]) value;      annotation.put12('[', booleanArray.length);      for (boolean booleanValue : booleanArray) {        annotation.put12('Z', symbolTable.addConstantInteger(booleanValue ? 1 : 0).index);      }    } else if (value instanceof short[]) {      short[] shortArray = (short[]) value;      annotation.put12('[', shortArray.length);      for (short shortValue : shortArray) {        annotation.put12('S', symbolTable.addConstantInteger(shortValue).index);      }    } else if (value instanceof char[]) {      char[] charArray = (char[]) value;      annotation.put12('[', charArray.length);      for (char charValue : charArray) {        annotation.put12('C', symbolTable.addConstantInteger(charValue).index);      }    } else if (value instanceof int[]) {      int[] intArray = (int[]) value;      annotation.put12('[', intArray.length);      for (int intValue : intArray) {        annotation.put12('I', symbolTable.addConstantInteger(intValue).index);      }    } else if (value instanceof long[]) {      long[] longArray = (long[]) value;      annotation.put12('[', longArray.length);      for (long longValue : longArray) {        annotation.put12('J', symbolTable.addConstantLong(longValue).index);      }    } else if (value instanceof float[]) {      float[] floatArray = (float[]) value;      annotation.put12('[', floatArray.length);      for (float floatValue : floatArray) {        annotation.put12('F', symbolTable.addConstantFloat(floatValue).index);      }    } else if (value instanceof double[]) {      double[] doubleArray = (double[]) value;      annotation.put12('[', doubleArray.length);      for (double doubleValue : doubleArray) {        annotation.put12('D', symbolTable.addConstantDouble(doubleValue).index);      }    } else {      Symbol symbol = symbolTable.addConstant(value);      annotation.put12(".s.IFJDCS".charAt(symbol.tag), symbol.index);    }  }  @Override  public void visitEnum(final String name, final String descriptor, final String value) {    // Case of an element_value with an enum_const_value field.    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.    ++numElementValuePairs;    if (useNamedValues) {      annotation.putShort(symbolTable.addConstantUtf8(name));    }    annotation        .put12('e', symbolTable.addConstantUtf8(descriptor))        .putShort(symbolTable.addConstantUtf8(value));  }  @Override  public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {    // Case of an element_value with an annotation_value field.    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.1.    ++numElementValuePairs;    if (useNamedValues) {      annotation.putShort(symbolTable.addConstantUtf8(name));    }    // Write tag and type_index, and reserve 2 bytes for num_element_value_pairs.    annotation.put12('@', symbolTable.addConstantUtf8(descriptor)).putShort(0);    return new AnnotationWriter(symbolTable, annotation, null);  }
int computeAnnotationsSize(final String attributeName) {    if (attributeName != null) {      symbolTable.addConstantUtf8(attributeName);    }    // The attribute_name_index, attribute_length and num_annotations fields use 8 bytes.    int attributeSize = 8;    AnnotationWriter annotationWriter = this;    while (annotationWriter != null) {      attributeSize += annotationWriter.annotation.length;      annotationWriter = annotationWriter.previousAnnotation;    }    return attributeSize;  }
void putAnnotations(final int attributeNameIndex, final ByteVector output) {    int attributeLength = 2; // For num_annotations.    int numAnnotations = 0;    AnnotationWriter annotationWriter = this;    AnnotationWriter firstAnnotation = null;    while (annotationWriter != null) {      // In case the user forgot to call visitEnd().      annotationWriter.visitEnd();      attributeLength += annotationWriter.annotation.length;      numAnnotations++;      firstAnnotation = annotationWriter;      annotationWriter = annotationWriter.previousAnnotation;    }    output.putShort(attributeNameIndex);    output.putInt(attributeLength);    output.putShort(numAnnotations);    annotationWriter = firstAnnotation;    while (annotationWriter != null) {      output.putByteArray(annotationWriter.annotation.data, 0, annotationWriter.annotation.length);      annotationWriter = annotationWriter.nextAnnotation;    }  }
static int computeParameterAnnotationsSize(      final String attributeName,      final AnnotationWriter[] annotationWriters,      final int annotableParameterCount) {    // Note: attributeName is added to the constant pool by the call to computeAnnotationsSize    // below. This assumes that there is at least one non-null element in the annotationWriters    // sub-array (which is ensured by the lazy instantiation of this array in MethodWriter).    // The attribute_name_index, attribute_length and num_parameters fields use 7 bytes, and each    // element of the parameter_annotations array uses 2 bytes for its num_annotations field.    int attributeSize = 7 + 2 * annotableParameterCount;    for (int i = 0; i < annotableParameterCount; ++i) {      AnnotationWriter annotationWriter = annotationWriters[i];      attributeSize +=          annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(attributeName) - 8;    }    return attributeSize;  }
static void putParameterAnnotations(      final int attributeNameIndex,      final AnnotationWriter[] annotationWriters,      final int annotableParameterCount,      final ByteVector output) {    // The num_parameters field uses 1 byte, and each element of the parameter_annotations array    // uses 2 bytes for its num_annotations field.    int attributeLength = 1 + 2 * annotableParameterCount;    for (int i = 0; i < annotableParameterCount; ++i) {      AnnotationWriter annotationWriter = annotationWriters[i];      attributeLength +=          annotationWriter == null ? 0 : annotationWriter.computeAnnotationsSize(null) - 8;    }    output.putShort(attributeNameIndex);    output.putInt(attributeLength);    output.putByte(annotableParameterCount);    for (int i = 0; i < annotableParameterCount; ++i) {      AnnotationWriter annotationWriter = annotationWriters[i];      AnnotationWriter firstAnnotation = null;      int numAnnotations = 0;      while (annotationWriter != null) {        // In case user the forgot to call visitEnd().        annotationWriter.visitEnd();        numAnnotations++;        firstAnnotation = annotationWriter;        annotationWriter = annotationWriter.previousAnnotation;      }      output.putShort(numAnnotations);      annotationWriter = firstAnnotation;      while (annotationWriter != null) {        output.putByteArray(            annotationWriter.annotation.data, 0, annotationWriter.annotation.length);        annotationWriter = annotationWriter.nextAnnotation;      }    }  }
public PropsEntries profile(final String... profiles) {		if (profiles == null) {			return this;		}		for (String profile : profiles) {			addProfiles(profile);		}		return this;	}
public static long getLongLittleEndian(final byte[] buf, final int offset) {		return ((long) buf[offset + 7] << 56)   // no mask needed			| ((buf[offset + 6] & 0xffL) << 48)			| ((buf[offset + 5] & 0xffL) << 40)			| ((buf[offset + 4] & 0xffL) << 32)			| ((buf[offset + 3] & 0xffL) << 24)			| ((buf[offset + 2] & 0xffL) << 16)			| ((buf[offset + 1] & 0xffL) << 8)			| ((buf[offset] & 0xffL));        // no shift needed	}
public static HashValue murmurhash3_x64_128(final byte[] key, final int offset, final int len, final int seed) {		// The original algorithm does have a 32 bit unsigned seed.		// We have to mask to match the behavior of the unsigned types and prevent sign extension.		long h1 = seed & 0x00000000FFFFFFFFL;		long h2 = seed & 0x00000000FFFFFFFFL;		final long c1 = 0x87c37b91114253d5L;		final long c2 = 0x4cf5ad432745937fL;		int roundedEnd = offset + (len & 0xFFFFFFF0);  // round down to 16 byte block		for (int i = offset; i < roundedEnd; i += 16) {			long k1 = getLongLittleEndian(key, i);			long k2 = getLongLittleEndian(key, i + 8);			k1 *= c1;			k1 = Long.rotateLeft(k1, 31);			k1 *= c2;			h1 ^= k1;			h1 = Long.rotateLeft(h1, 27);			h1 += h2;			h1 = h1 * 5 + 0x52dce729;			k2 *= c2;			k2 = Long.rotateLeft(k2, 33);			k2 *= c1;			h2 ^= k2;			h2 = Long.rotateLeft(h2, 31);			h2 += h1;			h2 = h2 * 5 + 0x38495ab5;		}		long k1 = 0;		long k2 = 0;		switch (len & 15) {			case 15:				k2 = (key[roundedEnd + 14] & 0xffL) << 48;			case 14:				k2 |= (key[roundedEnd + 13] & 0xffL) << 40;			case 13:				k2 |= (key[roundedEnd + 12] & 0xffL) << 32;			case 12:				k2 |= (key[roundedEnd + 11] & 0xffL) << 24;			case 11:				k2 |= (key[roundedEnd + 10] & 0xffL) << 16;			case 10:				k2 |= (key[roundedEnd + 9] & 0xffL) << 8;			case 9:				k2 |= (key[roundedEnd + 8] & 0xffL);				k2 *= c2;				k2 = Long.rotateLeft(k2, 33);				k2 *= c1;				h2 ^= k2;			case 8:				k1 = ((long) key[roundedEnd + 7]) << 56;			case 7:				k1 |= (key[roundedEnd + 6] & 0xffL) << 48;			case 6:				k1 |= (key[roundedEnd + 5] & 0xffL) << 40;			case 5:				k1 |= (key[roundedEnd + 4] & 0xffL) << 32;			case 4:				k1 |= (key[roundedEnd + 3] & 0xffL) << 24;			case 3:				k1 |= (key[roundedEnd + 2] & 0xffL) << 16;			case 2:				k1 |= (key[roundedEnd + 1] & 0xffL) << 8;			case 1:				k1 |= (key[roundedEnd] & 0xffL);				k1 *= c1;				k1 = Long.rotateLeft(k1, 31);				k1 *= c2;				h1 ^= k1;		}		//----------		// finalization		h1 ^= len;		h2 ^= len;		h1 += h2;		h2 += h1;		h1 = fmix64(h1);		h2 = fmix64(h2);		h1 += h2;		h2 += h1;		return new HashValue(h1, h2);	}
private static byte[] readStream(final InputStream inputStream, final boolean close)      throws IOException {    if (inputStream == null) {      throw new IOException("Class not found");    }    try {      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();      byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];      int bytesRead;      while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {        outputStream.write(data, 0, bytesRead);      }      outputStream.flush();      return outputStream.toByteArray();    } finally {      if (close) {        inputStream.close();      }    }  }
public String[] getInterfaces() {    // interfaces_count is after the access_flags, this_class and super_class fields (2 bytes each).    int currentOffset = header + 6;    int interfacesCount = readUnsignedShort(currentOffset);    String[] interfaces = new String[interfacesCount];    if (interfacesCount > 0) {      char[] charBuffer = new char[maxStringLength];      for (int i = 0; i < interfacesCount; ++i) {        currentOffset += 2;        interfaces[i] = readClass(currentOffset, charBuffer);      }    }    return interfaces;  }
public void accept(      final ClassVisitor classVisitor,      final Attribute[] attributePrototypes,      final int parsingOptions) {    Context context = new Context();    context.attributePrototypes = attributePrototypes;    context.parsingOptions = parsingOptions;    context.charBuffer = new char[maxStringLength];    // Read the access_flags, this_class, super_class, interface_count and interfaces fields.    char[] charBuffer = context.charBuffer;    int currentOffset = header;    int accessFlags = readUnsignedShort(currentOffset);    String thisClass = readClass(currentOffset + 2, charBuffer);    String superClass = readClass(currentOffset + 4, charBuffer);    String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];    currentOffset += 8;    for (int i = 0; i < interfaces.length; ++i) {      interfaces[i] = readClass(currentOffset, charBuffer);      currentOffset += 2;    }    // Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).    // Attribute offsets exclude the attribute_name_index and attribute_length fields.    // - The offset of the InnerClasses attribute, or 0.    int innerClassesOffset = 0;    // - The offset of the EnclosingMethod attribute, or 0.    int enclosingMethodOffset = 0;    // - The string corresponding to the Signature attribute, or null.    String signature = null;    // - The string corresponding to the SourceFile attribute, or null.    String sourceFile = null;    // - The string corresponding to the SourceDebugExtension attribute, or null.    String sourceDebugExtension = null;    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.    int runtimeVisibleAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.    int runtimeInvisibleAnnotationsOffset = 0;    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.    int runtimeVisibleTypeAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.    int runtimeInvisibleTypeAnnotationsOffset = 0;    // - The offset of the Module attribute, or 0.    int moduleOffset = 0;    // - The offset of the ModulePackages attribute, or 0.    int modulePackagesOffset = 0;    // - The string corresponding to the ModuleMainClass attribute, or null.    String moduleMainClass = null;    // - The string corresponding to the NestHost attribute, or null.    String nestHostClass = null;    // - The offset of the NestMembers attribute, or 0.    int nestMembersOffset = 0;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.    Attribute attributes = null;    int currentAttributeOffset = getFirstAttributeOffset();    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {      // Read the attribute_info's attribute_name and attribute_length fields.      String attributeName = readUTF8(currentAttributeOffset, charBuffer);      int attributeLength = readInt(currentAttributeOffset + 2);      currentAttributeOffset += 6;      // The tests are sorted in decreasing frequency order (based on frequencies observed on      // typical classes).      if (Constants.SOURCE_FILE.equals(attributeName)) {        sourceFile = readUTF8(currentAttributeOffset, charBuffer);      } else if (Constants.INNER_CLASSES.equals(attributeName)) {        innerClassesOffset = currentAttributeOffset;      } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {        enclosingMethodOffset = currentAttributeOffset;      } else if (Constants.NEST_HOST.equals(attributeName)) {        nestHostClass = readClass(currentAttributeOffset, charBuffer);      } else if (Constants.NEST_MEMBERS.equals(attributeName)) {        nestMembersOffset = currentAttributeOffset;      } else if (Constants.SIGNATURE.equals(attributeName)) {        signature = readUTF8(currentAttributeOffset, charBuffer);      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleAnnotationsOffset = currentAttributeOffset;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;      } else if (Constants.DEPRECATED.equals(attributeName)) {        accessFlags |= Opcodes.ACC_DEPRECATED;      } else if (Constants.SYNTHETIC.equals(attributeName)) {        accessFlags |= Opcodes.ACC_SYNTHETIC;      } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {        sourceDebugExtension =            readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;      } else if (Constants.MODULE.equals(attributeName)) {        moduleOffset = currentAttributeOffset;      } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {        moduleMainClass = readClass(currentAttributeOffset, charBuffer);      } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {        modulePackagesOffset = currentAttributeOffset;      } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {        // The BootstrapMethods attribute is read in the constructor.        Attribute attribute =            readAttribute(                attributePrototypes,                attributeName,                currentAttributeOffset,                attributeLength,                charBuffer,                -1,                null);        attribute.nextAttribute = attributes;        attributes = attribute;      }      currentAttributeOffset += attributeLength;    }    // Visit the class declaration. The minor_version and major_version fields start 6 bytes before    // the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).    classVisitor.visit(        readInt(cpInfoOffsets[1] - 7), accessFlags, thisClass, signature, superClass, interfaces);    // Visit the SourceFile and SourceDebugExtenstion attributes.    if ((parsingOptions & SKIP_DEBUG) == 0        && (sourceFile != null || sourceDebugExtension != null)) {      classVisitor.visitSource(sourceFile, sourceDebugExtension);    }    // Visit the Module, ModulePackages and ModuleMainClass attributes.    if (moduleOffset != 0) {      readModuleAttributes(          classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);    }    // Visit the NestHost attribute.    if (nestHostClass != null) {      classVisitor.visitNestHost(nestHostClass);    }    // Visit the EnclosingMethod attribute.    if (enclosingMethodOffset != 0) {      String className = readClass(enclosingMethodOffset, charBuffer);      int methodIndex = readUnsignedShort(enclosingMethodOffset + 2);      String name = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex], charBuffer);      String type = methodIndex == 0 ? null : readUTF8(cpInfoOffsets[methodIndex] + 2, charBuffer);      classVisitor.visitOuterClass(className, name, type);    }    // Visit the RuntimeVisibleAnnotations attribute.    if (runtimeVisibleAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeInvisibleAnnotations attribute.    if (runtimeInvisibleAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                classVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeVisibleTypeAnnotations attribute.    if (runtimeVisibleTypeAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the target_type, target_info and target_path fields.        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                classVisitor.visitTypeAnnotation(                    context.currentTypeAnnotationTarget,                    context.currentTypeAnnotationTargetPath,                    annotationDescriptor,                    /* visible = */ true),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeInvisibleTypeAnnotations attribute.    if (runtimeInvisibleTypeAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the target_type, target_info and target_path fields.        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                classVisitor.visitTypeAnnotation(                    context.currentTypeAnnotationTarget,                    context.currentTypeAnnotationTargetPath,                    annotationDescriptor,                    /* visible = */ false),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the non standard attributes.    while (attributes != null) {      // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.      Attribute nextAttribute = attributes.nextAttribute;      attributes.nextAttribute = null;      classVisitor.visitAttribute(attributes);      attributes = nextAttribute;    }    // Visit the NestedMembers attribute.    if (nestMembersOffset != 0) {      int numberOfNestMembers = readUnsignedShort(nestMembersOffset);      int currentNestMemberOffset = nestMembersOffset + 2;      while (numberOfNestMembers-- > 0) {        classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));        currentNestMemberOffset += 2;      }    }    // Visit the InnerClasses attribute.    if (innerClassesOffset != 0) {      int numberOfClasses = readUnsignedShort(innerClassesOffset);      int currentClassesOffset = innerClassesOffset + 2;      while (numberOfClasses-- > 0) {        classVisitor.visitInnerClass(            readClass(currentClassesOffset, charBuffer),            readClass(currentClassesOffset + 2, charBuffer),            readUTF8(currentClassesOffset + 4, charBuffer),            readUnsignedShort(currentClassesOffset + 6));        currentClassesOffset += 8;      }    }    // Visit the fields and methods.    int fieldsCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (fieldsCount-- > 0) {      currentOffset = readField(classVisitor, context, currentOffset);    }    int methodsCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (methodsCount-- > 0) {      currentOffset = readMethod(classVisitor, context, currentOffset);    }    // Visit the end of the class.    classVisitor.visitEnd();  }
private void readModuleAttributes(      final ClassVisitor classVisitor,      final Context context,      final int moduleOffset,      final int modulePackagesOffset,      final String moduleMainClass) {    char[] buffer = context.charBuffer;    // Read the module_name_index, module_flags and module_version_index fields and visit them.    int currentOffset = moduleOffset;    String moduleName = readModule(currentOffset, buffer);    int moduleFlags = readUnsignedShort(currentOffset + 2);    String moduleVersion = readUTF8(currentOffset + 4, buffer);    currentOffset += 6;    ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);    if (moduleVisitor == null) {      return;    }    // Visit the ModuleMainClass attribute.    if (moduleMainClass != null) {      moduleVisitor.visitMainClass(moduleMainClass);    }    // Visit the ModulePackages attribute.    if (modulePackagesOffset != 0) {      int packageCount = readUnsignedShort(modulePackagesOffset);      int currentPackageOffset = modulePackagesOffset + 2;      while (packageCount-- > 0) {        moduleVisitor.visitPackage(readPackage(currentPackageOffset, buffer));        currentPackageOffset += 2;      }    }    // Read the 'requires_count' and 'requires' fields.    int requiresCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (requiresCount-- > 0) {      // Read the requires_index, requires_flags and requires_version fields and visit them.      String requires = readModule(currentOffset, buffer);      int requiresFlags = readUnsignedShort(currentOffset + 2);      String requiresVersion = readUTF8(currentOffset + 4, buffer);      currentOffset += 6;      moduleVisitor.visitRequire(requires, requiresFlags, requiresVersion);    }    // Read the 'exports_count' and 'exports' fields.    int exportsCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (exportsCount-- > 0) {      // Read the exports_index, exports_flags, exports_to_count and exports_to_index fields      // and visit them.      String exports = readPackage(currentOffset, buffer);      int exportsFlags = readUnsignedShort(currentOffset + 2);      int exportsToCount = readUnsignedShort(currentOffset + 4);      currentOffset += 6;      String[] exportsTo = null;      if (exportsToCount != 0) {        exportsTo = new String[exportsToCount];        for (int i = 0; i < exportsToCount; ++i) {          exportsTo[i] = readModule(currentOffset, buffer);          currentOffset += 2;        }      }      moduleVisitor.visitExport(exports, exportsFlags, exportsTo);    }    // Reads the 'opens_count' and 'opens' fields.    int opensCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (opensCount-- > 0) {      // Read the opens_index, opens_flags, opens_to_count and opens_to_index fields and visit them.      String opens = readPackage(currentOffset, buffer);      int opensFlags = readUnsignedShort(currentOffset + 2);      int opensToCount = readUnsignedShort(currentOffset + 4);      currentOffset += 6;      String[] opensTo = null;      if (opensToCount != 0) {        opensTo = new String[opensToCount];        for (int i = 0; i < opensToCount; ++i) {          opensTo[i] = readModule(currentOffset, buffer);          currentOffset += 2;        }      }      moduleVisitor.visitOpen(opens, opensFlags, opensTo);    }    // Read the 'uses_count' and 'uses' fields.    int usesCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (usesCount-- > 0) {      moduleVisitor.visitUse(readClass(currentOffset, buffer));      currentOffset += 2;    }    // Read the  'provides_count' and 'provides' fields.    int providesCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (providesCount-- > 0) {      // Read the provides_index, provides_with_count and provides_with_index fields and visit them.      String provides = readClass(currentOffset, buffer);      int providesWithCount = readUnsignedShort(currentOffset + 2);      currentOffset += 4;      String[] providesWith = new String[providesWithCount];      for (int i = 0; i < providesWithCount; ++i) {        providesWith[i] = readClass(currentOffset, buffer);        currentOffset += 2;      }      moduleVisitor.visitProvide(provides, providesWith);    }    // Visit the end of the module attributes.    moduleVisitor.visitEnd();  }
private int readField(      final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {    char[] charBuffer = context.charBuffer;    // Read the access_flags, name_index and descriptor_index fields.    int currentOffset = fieldInfoOffset;    int accessFlags = readUnsignedShort(currentOffset);    String name = readUTF8(currentOffset + 2, charBuffer);    String descriptor = readUTF8(currentOffset + 4, charBuffer);    currentOffset += 6;    // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).    // Attribute offsets exclude the attribute_name_index and attribute_length fields.    // - The value corresponding to the ConstantValue attribute, or null.    Object constantValue = null;    // - The string corresponding to the Signature attribute, or null.    String signature = null;    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.    int runtimeVisibleAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.    int runtimeInvisibleAnnotationsOffset = 0;    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.    int runtimeVisibleTypeAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.    int runtimeInvisibleTypeAnnotationsOffset = 0;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.    Attribute attributes = null;    int attributesCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (attributesCount-- > 0) {      // Read the attribute_info's attribute_name and attribute_length fields.      String attributeName = readUTF8(currentOffset, charBuffer);      int attributeLength = readInt(currentOffset + 2);      currentOffset += 6;      // The tests are sorted in decreasing frequency order (based on frequencies observed on      // typical classes).      if (Constants.CONSTANT_VALUE.equals(attributeName)) {        int constantvalueIndex = readUnsignedShort(currentOffset);        constantValue = constantvalueIndex == 0 ? null : readConst(constantvalueIndex, charBuffer);      } else if (Constants.SIGNATURE.equals(attributeName)) {        signature = readUTF8(currentOffset, charBuffer);      } else if (Constants.DEPRECATED.equals(attributeName)) {        accessFlags |= Opcodes.ACC_DEPRECATED;      } else if (Constants.SYNTHETIC.equals(attributeName)) {        accessFlags |= Opcodes.ACC_SYNTHETIC;      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleTypeAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleTypeAnnotationsOffset = currentOffset;      } else {        Attribute attribute =            readAttribute(                context.attributePrototypes,                attributeName,                currentOffset,                attributeLength,                charBuffer,                -1,                null);        attribute.nextAttribute = attributes;        attributes = attribute;      }      currentOffset += attributeLength;    }    // Visit the field declaration.    FieldVisitor fieldVisitor =        classVisitor.visitField(accessFlags, name, descriptor, signature, constantValue);    if (fieldVisitor == null) {      return currentOffset;    }    // Visit the RuntimeVisibleAnnotations attribute.    if (runtimeVisibleAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeInvisibleAnnotations attribute.    if (runtimeInvisibleAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                fieldVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeVisibleTypeAnnotations attribute.    if (runtimeVisibleTypeAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the target_type, target_info and target_path fields.        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                fieldVisitor.visitTypeAnnotation(                    context.currentTypeAnnotationTarget,                    context.currentTypeAnnotationTargetPath,                    annotationDescriptor,                    /* visible = */ true),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeInvisibleTypeAnnotations attribute.    if (runtimeInvisibleTypeAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the target_type, target_info and target_path fields.        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                fieldVisitor.visitTypeAnnotation(                    context.currentTypeAnnotationTarget,                    context.currentTypeAnnotationTargetPath,                    annotationDescriptor,                    /* visible = */ false),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the non standard attributes.    while (attributes != null) {      // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.      Attribute nextAttribute = attributes.nextAttribute;      attributes.nextAttribute = null;      fieldVisitor.visitAttribute(attributes);      attributes = nextAttribute;    }    // Visit the end of the field.    fieldVisitor.visitEnd();    return currentOffset;  }
private int readMethod(      final ClassVisitor classVisitor, final Context context, final int methodInfoOffset) {    char[] charBuffer = context.charBuffer;    // Read the access_flags, name_index and descriptor_index fields.    int currentOffset = methodInfoOffset;    context.currentMethodAccessFlags = readUnsignedShort(currentOffset);    context.currentMethodName = readUTF8(currentOffset + 2, charBuffer);    context.currentMethodDescriptor = readUTF8(currentOffset + 4, charBuffer);    currentOffset += 6;    // Read the method attributes (the variables are ordered as in Section 4.7 of the JVMS).    // Attribute offsets exclude the attribute_name_index and attribute_length fields.    // - The offset of the Code attribute, or 0.    int codeOffset = 0;    // - The offset of the Exceptions attribute, or 0.    int exceptionsOffset = 0;    // - The strings corresponding to the Exceptions attribute, or null.    String[] exceptions = null;    // - Whether the method has a Synthetic attribute.    boolean synthetic = false;    // - The constant pool index contained in the Signature attribute, or 0.    int signatureIndex = 0;    // - The offset of the RuntimeVisibleAnnotations attribute, or 0.    int runtimeVisibleAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.    int runtimeInvisibleAnnotationsOffset = 0;    // - The offset of the RuntimeVisibleParameterAnnotations attribute, or 0.    int runtimeVisibleParameterAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleParameterAnnotations attribute, or 0.    int runtimeInvisibleParameterAnnotationsOffset = 0;    // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.    int runtimeVisibleTypeAnnotationsOffset = 0;    // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.    int runtimeInvisibleTypeAnnotationsOffset = 0;    // - The offset of the AnnotationDefault attribute, or 0.    int annotationDefaultOffset = 0;    // - The offset of the MethodParameters attribute, or 0.    int methodParametersOffset = 0;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.    Attribute attributes = null;    int attributesCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (attributesCount-- > 0) {      // Read the attribute_info's attribute_name and attribute_length fields.      String attributeName = readUTF8(currentOffset, charBuffer);      int attributeLength = readInt(currentOffset + 2);      currentOffset += 6;      // The tests are sorted in decreasing frequency order (based on frequencies observed on      // typical classes).      if (Constants.CODE.equals(attributeName)) {        if ((context.parsingOptions & SKIP_CODE) == 0) {          codeOffset = currentOffset;        }      } else if (Constants.EXCEPTIONS.equals(attributeName)) {        exceptionsOffset = currentOffset;        exceptions = new String[readUnsignedShort(exceptionsOffset)];        int currentExceptionOffset = exceptionsOffset + 2;        for (int i = 0; i < exceptions.length; ++i) {          exceptions[i] = readClass(currentExceptionOffset, charBuffer);          currentExceptionOffset += 2;        }      } else if (Constants.SIGNATURE.equals(attributeName)) {        signatureIndex = readUnsignedShort(currentOffset);      } else if (Constants.DEPRECATED.equals(attributeName)) {        context.currentMethodAccessFlags |= Opcodes.ACC_DEPRECATED;      } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleTypeAnnotationsOffset = currentOffset;      } else if (Constants.ANNOTATION_DEFAULT.equals(attributeName)) {        annotationDefaultOffset = currentOffset;      } else if (Constants.SYNTHETIC.equals(attributeName)) {        synthetic = true;        context.currentMethodAccessFlags |= Opcodes.ACC_SYNTHETIC;      } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleTypeAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {        runtimeVisibleParameterAnnotationsOffset = currentOffset;      } else if (Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS.equals(attributeName)) {        runtimeInvisibleParameterAnnotationsOffset = currentOffset;      } else if (Constants.METHOD_PARAMETERS.equals(attributeName)) {        methodParametersOffset = currentOffset;      } else {        Attribute attribute =            readAttribute(                context.attributePrototypes,                attributeName,                currentOffset,                attributeLength,                charBuffer,                -1,                null);        attribute.nextAttribute = attributes;        attributes = attribute;      }      currentOffset += attributeLength;    }    // Visit the method declaration.    MethodVisitor methodVisitor =        classVisitor.visitMethod(            context.currentMethodAccessFlags,            context.currentMethodName,            context.currentMethodDescriptor,            signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),            exceptions);    if (methodVisitor == null) {      return currentOffset;    }    // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method    // adapter between the reader and the writer. In this case, it might be possible to copy    // the method attributes directly into the writer. If so, return early without visiting    // the content of these attributes.    if (methodVisitor instanceof MethodWriter) {      MethodWriter methodWriter = (MethodWriter) methodVisitor;      if (methodWriter.canCopyMethodAttributes(          this,          methodInfoOffset,          currentOffset - methodInfoOffset,          synthetic,          (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0,          readUnsignedShort(methodInfoOffset + 4),          signatureIndex,          exceptionsOffset)) {        return currentOffset;      }    }    // Visit the MethodParameters attribute.    if (methodParametersOffset != 0) {      int parametersCount = readByte(methodParametersOffset);      int currentParameterOffset = methodParametersOffset + 1;      while (parametersCount-- > 0) {        // Read the name_index and access_flags fields and visit them.        methodVisitor.visitParameter(            readUTF8(currentParameterOffset, charBuffer),            readUnsignedShort(currentParameterOffset + 2));        currentParameterOffset += 4;      }    }    // Visit the AnnotationDefault attribute.    if (annotationDefaultOffset != 0) {      AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();      readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);      if (annotationVisitor != null) {        annotationVisitor.visitEnd();      }    }    // Visit the RuntimeVisibleAnnotations attribute.    if (runtimeVisibleAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);      int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeInvisibleAnnotations attribute.    if (runtimeInvisibleAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);      int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                methodVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeVisibleTypeAnnotations attribute.    if (runtimeVisibleTypeAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);      int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the target_type, target_info and target_path fields.        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                methodVisitor.visitTypeAnnotation(                    context.currentTypeAnnotationTarget,                    context.currentTypeAnnotationTargetPath,                    annotationDescriptor,                    /* visible = */ true),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeInvisibleTypeAnnotations attribute.    if (runtimeInvisibleTypeAnnotationsOffset != 0) {      int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);      int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;      while (numAnnotations-- > 0) {        // Parse the target_type, target_info and target_path fields.        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);        currentAnnotationOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentAnnotationOffset =            readElementValues(                methodVisitor.visitTypeAnnotation(                    context.currentTypeAnnotationTarget,                    context.currentTypeAnnotationTargetPath,                    annotationDescriptor,                    /* visible = */ false),                currentAnnotationOffset,                /* named = */ true,                charBuffer);      }    }    // Visit the RuntimeVisibleParameterAnnotations attribute.    if (runtimeVisibleParameterAnnotationsOffset != 0) {      readParameterAnnotations(          methodVisitor, context, runtimeVisibleParameterAnnotationsOffset, /* visible = */ true);    }    // Visit the RuntimeInvisibleParameterAnnotations attribute.    if (runtimeInvisibleParameterAnnotationsOffset != 0) {      readParameterAnnotations(          methodVisitor,          context,          runtimeInvisibleParameterAnnotationsOffset,          /* visible = */ false);    }    // Visit the non standard attributes.    while (attributes != null) {      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.      Attribute nextAttribute = attributes.nextAttribute;      attributes.nextAttribute = null;      methodVisitor.visitAttribute(attributes);      attributes = nextAttribute;    }    // Visit the Code attribute.    if (codeOffset != 0) {      methodVisitor.visitCode();      readCode(methodVisitor, context, codeOffset);    }    // Visit the end of the method.    methodVisitor.visitEnd();    return currentOffset;  }
private void readCode(      final MethodVisitor methodVisitor, final Context context, final int codeOffset) {    int currentOffset = codeOffset;    // Read the max_stack, max_locals and code_length fields.    final byte[] classFileBuffer = b;    final char[] charBuffer = context.charBuffer;    final int maxStack = readUnsignedShort(currentOffset);    final int maxLocals = readUnsignedShort(currentOffset + 2);    final int codeLength = readInt(currentOffset + 4);    currentOffset += 8;    // Read the bytecode 'code' array to create a label for each referenced instruction.    final int bytecodeStartOffset = currentOffset;    final int bytecodeEndOffset = currentOffset + codeLength;    final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];    while (currentOffset < bytecodeEndOffset) {      final int bytecodeOffset = currentOffset - bytecodeStartOffset;      final int opcode = classFileBuffer[currentOffset] & 0xFF;      switch (opcode) {        case Constants.NOP:        case Constants.ACONST_NULL:        case Constants.ICONST_M1:        case Constants.ICONST_0:        case Constants.ICONST_1:        case Constants.ICONST_2:        case Constants.ICONST_3:        case Constants.ICONST_4:        case Constants.ICONST_5:        case Constants.LCONST_0:        case Constants.LCONST_1:        case Constants.FCONST_0:        case Constants.FCONST_1:        case Constants.FCONST_2:        case Constants.DCONST_0:        case Constants.DCONST_1:        case Constants.IALOAD:        case Constants.LALOAD:        case Constants.FALOAD:        case Constants.DALOAD:        case Constants.AALOAD:        case Constants.BALOAD:        case Constants.CALOAD:        case Constants.SALOAD:        case Constants.IASTORE:        case Constants.LASTORE:        case Constants.FASTORE:        case Constants.DASTORE:        case Constants.AASTORE:        case Constants.BASTORE:        case Constants.CASTORE:        case Constants.SASTORE:        case Constants.POP:        case Constants.POP2:        case Constants.DUP:        case Constants.DUP_X1:        case Constants.DUP_X2:        case Constants.DUP2:        case Constants.DUP2_X1:        case Constants.DUP2_X2:        case Constants.SWAP:        case Constants.IADD:        case Constants.LADD:        case Constants.FADD:        case Constants.DADD:        case Constants.ISUB:        case Constants.LSUB:        case Constants.FSUB:        case Constants.DSUB:        case Constants.IMUL:        case Constants.LMUL:        case Constants.FMUL:        case Constants.DMUL:        case Constants.IDIV:        case Constants.LDIV:        case Constants.FDIV:        case Constants.DDIV:        case Constants.IREM:        case Constants.LREM:        case Constants.FREM:        case Constants.DREM:        case Constants.INEG:        case Constants.LNEG:        case Constants.FNEG:        case Constants.DNEG:        case Constants.ISHL:        case Constants.LSHL:        case Constants.ISHR:        case Constants.LSHR:        case Constants.IUSHR:        case Constants.LUSHR:        case Constants.IAND:        case Constants.LAND:        case Constants.IOR:        case Constants.LOR:        case Constants.IXOR:        case Constants.LXOR:        case Constants.I2L:        case Constants.I2F:        case Constants.I2D:        case Constants.L2I:        case Constants.L2F:        case Constants.L2D:        case Constants.F2I:        case Constants.F2L:        case Constants.F2D:        case Constants.D2I:        case Constants.D2L:        case Constants.D2F:        case Constants.I2B:        case Constants.I2C:        case Constants.I2S:        case Constants.LCMP:        case Constants.FCMPL:        case Constants.FCMPG:        case Constants.DCMPL:        case Constants.DCMPG:        case Constants.IRETURN:        case Constants.LRETURN:        case Constants.FRETURN:        case Constants.DRETURN:        case Constants.ARETURN:        case Constants.RETURN:        case Constants.ARRAYLENGTH:        case Constants.ATHROW:        case Constants.MONITORENTER:        case Constants.MONITOREXIT:        case Constants.ILOAD_0:        case Constants.ILOAD_1:        case Constants.ILOAD_2:        case Constants.ILOAD_3:        case Constants.LLOAD_0:        case Constants.LLOAD_1:        case Constants.LLOAD_2:        case Constants.LLOAD_3:        case Constants.FLOAD_0:        case Constants.FLOAD_1:        case Constants.FLOAD_2:        case Constants.FLOAD_3:        case Constants.DLOAD_0:        case Constants.DLOAD_1:        case Constants.DLOAD_2:        case Constants.DLOAD_3:        case Constants.ALOAD_0:        case Constants.ALOAD_1:        case Constants.ALOAD_2:        case Constants.ALOAD_3:        case Constants.ISTORE_0:        case Constants.ISTORE_1:        case Constants.ISTORE_2:        case Constants.ISTORE_3:        case Constants.LSTORE_0:        case Constants.LSTORE_1:        case Constants.LSTORE_2:        case Constants.LSTORE_3:        case Constants.FSTORE_0:        case Constants.FSTORE_1:        case Constants.FSTORE_2:        case Constants.FSTORE_3:        case Constants.DSTORE_0:        case Constants.DSTORE_1:        case Constants.DSTORE_2:        case Constants.DSTORE_3:        case Constants.ASTORE_0:        case Constants.ASTORE_1:        case Constants.ASTORE_2:        case Constants.ASTORE_3:          currentOffset += 1;          break;        case Constants.IFEQ:        case Constants.IFNE:        case Constants.IFLT:        case Constants.IFGE:        case Constants.IFGT:        case Constants.IFLE:        case Constants.IF_ICMPEQ:        case Constants.IF_ICMPNE:        case Constants.IF_ICMPLT:        case Constants.IF_ICMPGE:        case Constants.IF_ICMPGT:        case Constants.IF_ICMPLE:        case Constants.IF_ACMPEQ:        case Constants.IF_ACMPNE:        case Constants.GOTO:        case Constants.JSR:        case Constants.IFNULL:        case Constants.IFNONNULL:          createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);          currentOffset += 3;          break;        case Constants.ASM_IFEQ:        case Constants.ASM_IFNE:        case Constants.ASM_IFLT:        case Constants.ASM_IFGE:        case Constants.ASM_IFGT:        case Constants.ASM_IFLE:        case Constants.ASM_IF_ICMPEQ:        case Constants.ASM_IF_ICMPNE:        case Constants.ASM_IF_ICMPLT:        case Constants.ASM_IF_ICMPGE:        case Constants.ASM_IF_ICMPGT:        case Constants.ASM_IF_ICMPLE:        case Constants.ASM_IF_ACMPEQ:        case Constants.ASM_IF_ACMPNE:        case Constants.ASM_GOTO:        case Constants.ASM_JSR:        case Constants.ASM_IFNULL:        case Constants.ASM_IFNONNULL:          createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);          currentOffset += 3;          break;        case Constants.GOTO_W:        case Constants.JSR_W:        case Constants.ASM_GOTO_W:          createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);          currentOffset += 5;          break;        case Constants.WIDE:          switch (classFileBuffer[currentOffset + 1] & 0xFF) {            case Constants.ILOAD:            case Constants.FLOAD:            case Constants.ALOAD:            case Constants.LLOAD:            case Constants.DLOAD:            case Constants.ISTORE:            case Constants.FSTORE:            case Constants.ASTORE:            case Constants.LSTORE:            case Constants.DSTORE:            case Constants.RET:              currentOffset += 4;              break;            case Constants.IINC:              currentOffset += 6;              break;            default:              throw new IllegalArgumentException();          }          break;        case Constants.TABLESWITCH:          // Skip 0 to 3 padding bytes.          currentOffset += 4 - (bytecodeOffset & 3);          // Read the default label and the number of table entries.          createLabel(bytecodeOffset + readInt(currentOffset), labels);          int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;          currentOffset += 12;          // Read the table labels.          while (numTableEntries-- > 0) {            createLabel(bytecodeOffset + readInt(currentOffset), labels);            currentOffset += 4;          }          break;        case Constants.LOOKUPSWITCH:          // Skip 0 to 3 padding bytes.          currentOffset += 4 - (bytecodeOffset & 3);          // Read the default label and the number of switch cases.          createLabel(bytecodeOffset + readInt(currentOffset), labels);          int numSwitchCases = readInt(currentOffset + 4);          currentOffset += 8;          // Read the switch labels.          while (numSwitchCases-- > 0) {            createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);            currentOffset += 8;          }          break;        case Constants.ILOAD:        case Constants.LLOAD:        case Constants.FLOAD:        case Constants.DLOAD:        case Constants.ALOAD:        case Constants.ISTORE:        case Constants.LSTORE:        case Constants.FSTORE:        case Constants.DSTORE:        case Constants.ASTORE:        case Constants.RET:        case Constants.BIPUSH:        case Constants.NEWARRAY:        case Constants.LDC:          currentOffset += 2;          break;        case Constants.SIPUSH:        case Constants.LDC_W:        case Constants.LDC2_W:        case Constants.GETSTATIC:        case Constants.PUTSTATIC:        case Constants.GETFIELD:        case Constants.PUTFIELD:        case Constants.INVOKEVIRTUAL:        case Constants.INVOKESPECIAL:        case Constants.INVOKESTATIC:        case Constants.NEW:        case Constants.ANEWARRAY:        case Constants.CHECKCAST:        case Constants.INSTANCEOF:        case Constants.IINC:          currentOffset += 3;          break;        case Constants.INVOKEINTERFACE:        case Constants.INVOKEDYNAMIC:          currentOffset += 5;          break;        case Constants.MULTIANEWARRAY:          currentOffset += 4;          break;        default:          throw new IllegalArgumentException();      }    }    // Read the 'exception_table_length' and 'exception_table' field to create a label for each    // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.    int exceptionTableLength = readUnsignedShort(currentOffset);    currentOffset += 2;    while (exceptionTableLength-- > 0) {      Label start = createLabel(readUnsignedShort(currentOffset), labels);      Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);      Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);      String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);      currentOffset += 8;      methodVisitor.visitTryCatchBlock(start, end, handler, catchType);    }    // Read the Code attributes to create a label for each referenced instruction (the variables    // are ordered as in Section 4.7 of the JVMS). Attribute offsets exclude the    // attribute_name_index and attribute_length fields.    // - The offset of the current 'stack_map_frame' in the StackMap[Table] attribute, or 0.    // Initially, this is the offset of the first 'stack_map_frame' entry. Then this offset is    // updated after each stack_map_frame is read.    int stackMapFrameOffset = 0;    // - The end offset of the StackMap[Table] attribute, or 0.    int stackMapTableEndOffset = 0;    // - Whether the stack map frames are compressed (i.e. in a StackMapTable) or not.    boolean compressedFrames = true;    // - The offset of the LocalVariableTable attribute, or 0.    int localVariableTableOffset = 0;    // - The offset of the LocalVariableTypeTable attribute, or 0.    int localVariableTypeTableOffset = 0;    // - The offset of each 'type_annotation' entry in the RuntimeVisibleTypeAnnotations    // attribute, or null.    int[] visibleTypeAnnotationOffsets = null;    // - The offset of each 'type_annotation' entry in the RuntimeInvisibleTypeAnnotations    // attribute, or null.    int[] invisibleTypeAnnotationOffsets = null;    // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).    //   This list in the <i>reverse order</i> or their order in the ClassFile structure.    Attribute attributes = null;    int attributesCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (attributesCount-- > 0) {      // Read the attribute_info's attribute_name and attribute_length fields.      String attributeName = readUTF8(currentOffset, charBuffer);      int attributeLength = readInt(currentOffset + 2);      currentOffset += 6;      if (Constants.LOCAL_VARIABLE_TABLE.equals(attributeName)) {        if ((context.parsingOptions & SKIP_DEBUG) == 0) {          localVariableTableOffset = currentOffset;          // Parse the attribute to find the corresponding (debug only) labels.          int currentLocalVariableTableOffset = currentOffset;          int localVariableTableLength = readUnsignedShort(currentLocalVariableTableOffset);          currentLocalVariableTableOffset += 2;          while (localVariableTableLength-- > 0) {            int startPc = readUnsignedShort(currentLocalVariableTableOffset);            createDebugLabel(startPc, labels);            int length = readUnsignedShort(currentLocalVariableTableOffset + 2);            createDebugLabel(startPc + length, labels);            // Skip the name_index, descriptor_index and index fields (2 bytes each).            currentLocalVariableTableOffset += 10;          }        }      } else if (Constants.LOCAL_VARIABLE_TYPE_TABLE.equals(attributeName)) {        localVariableTypeTableOffset = currentOffset;        // Here we do not extract the labels corresponding to the attribute content. We assume they        // are the same or a subset of those of the LocalVariableTable attribute.      } else if (Constants.LINE_NUMBER_TABLE.equals(attributeName)) {        if ((context.parsingOptions & SKIP_DEBUG) == 0) {          // Parse the attribute to find the corresponding (debug only) labels.          int currentLineNumberTableOffset = currentOffset;          int lineNumberTableLength = readUnsignedShort(currentLineNumberTableOffset);          currentLineNumberTableOffset += 2;          while (lineNumberTableLength-- > 0) {            int startPc = readUnsignedShort(currentLineNumberTableOffset);            int lineNumber = readUnsignedShort(currentLineNumberTableOffset + 2);            currentLineNumberTableOffset += 4;            createDebugLabel(startPc, labels);            labels[startPc].addLineNumber(lineNumber);          }        }      } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        visibleTypeAnnotationOffsets =            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ true);        // Here we do not extract the labels corresponding to the attribute content. This would        // require a full parsing of the attribute, which would need to be repeated when parsing        // the bytecode instructions (see below). Instead, the content of the attribute is read one        // type annotation at a time (i.e. after a type annotation has been visited, the next type        // annotation is read), and the labels it contains are also extracted one annotation at a        // time. This assumes that type annotations are ordered by increasing bytecode offset.      } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {        invisibleTypeAnnotationOffsets =            readTypeAnnotations(methodVisitor, context, currentOffset, /* visible = */ false);        // Same comment as above for the RuntimeVisibleTypeAnnotations attribute.      } else if (Constants.STACK_MAP_TABLE.equals(attributeName)) {        if ((context.parsingOptions & SKIP_FRAMES) == 0) {          stackMapFrameOffset = currentOffset + 2;          stackMapTableEndOffset = currentOffset + attributeLength;        }        // Here we do not extract the labels corresponding to the attribute content. This would        // require a full parsing of the attribute, which would need to be repeated when parsing        // the bytecode instructions (see below). Instead, the content of the attribute is read one        // frame at a time (i.e. after a frame has been visited, the next frame is read), and the        // labels it contains are also extracted one frame at a time. Thanks to the ordering of        // frames, having only a "one frame lookahead" is not a problem, i.e. it is not possible to        // see an offset smaller than the offset of the current instruction and for which no Label        // exist. Except for UNINITIALIZED type offsets. We solve this by parsing the stack map        // table without a full decoding (see below).      } else if ("StackMap".equals(attributeName)) {        if ((context.parsingOptions & SKIP_FRAMES) == 0) {          stackMapFrameOffset = currentOffset + 2;          stackMapTableEndOffset = currentOffset + attributeLength;          compressedFrames = false;        }        // IMPORTANT! Here we assume that the frames are ordered, as in the StackMapTable attribute,        // although this is not guaranteed by the attribute format. This allows an incremental        // extraction of the labels corresponding to this attribute (see the comment above for the        // StackMapTable attribute).      } else {        Attribute attribute =            readAttribute(                context.attributePrototypes,                attributeName,                currentOffset,                attributeLength,                charBuffer,                codeOffset,                labels);        attribute.nextAttribute = attributes;        attributes = attribute;      }      currentOffset += attributeLength;    }    // Initialize the context fields related to stack map frames, and generate the first    // (implicit) stack map frame, if needed.    final boolean expandFrames = (context.parsingOptions & EXPAND_FRAMES) != 0;    if (stackMapFrameOffset != 0) {      // The bytecode offset of the first explicit frame is not offset_delta + 1 but only      // offset_delta. Setting the implicit frame offset to -1 allows us to use of the      // "offset_delta + 1" rule in all cases.      context.currentFrameOffset = -1;      context.currentFrameType = 0;      context.currentFrameLocalCount = 0;      context.currentFrameLocalCountDelta = 0;      context.currentFrameLocalTypes = new Object[maxLocals];      context.currentFrameStackCount = 0;      context.currentFrameStackTypes = new Object[maxStack];      if (expandFrames) {        computeImplicitFrame(context);      }      // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the      // stack map table, we look for 3 consecutive bytes that "look like" an UNINITIALIZED type      // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).      // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,      // and the only consequence will be the creation of an unneeded label. This is better than      // creating a label for each NEW instruction, and faster than fully decoding the whole stack      // map table.      for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {        if (classFileBuffer[offset] == Frame.ITEM_UNINITIALIZED) {          int potentialBytecodeOffset = readUnsignedShort(offset + 1);          if (potentialBytecodeOffset >= 0              && potentialBytecodeOffset < codeLength              && (classFileBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)                  == Opcodes.NEW) {            createLabel(potentialBytecodeOffset, labels);          }        }      }    }    if (expandFrames && (context.parsingOptions & EXPAND_ASM_INSNS) != 0) {      // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method      // does not currently have any frame. These inserted frames must be computed by simulating the      // effect of the bytecode instructions, one by one, starting from the implicit first frame.      // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To      // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is      // computed in MethodWriter).      methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);    }    // Visit the bytecode instructions. First, introduce state variables for the incremental parsing    // of the type annotations.    // Index of the next runtime visible type annotation to read (in the    // visibleTypeAnnotationOffsets array).    int currentVisibleTypeAnnotationIndex = 0;    // The bytecode offset of the next runtime visible type annotation to read, or -1.    int currentVisibleTypeAnnotationBytecodeOffset =        getTypeAnnotationBytecodeOffset(visibleTypeAnnotationOffsets, 0);    // Index of the next runtime invisible type annotation to read (in the    // invisibleTypeAnnotationOffsets array).    int currentInvisibleTypeAnnotationIndex = 0;    // The bytecode offset of the next runtime invisible type annotation to read, or -1.    int currentInvisibleTypeAnnotationBytecodeOffset =        getTypeAnnotationBytecodeOffset(invisibleTypeAnnotationOffsets, 0);    // Whether a F_INSERT stack map frame must be inserted before the current instruction.    boolean insertFrame = false;    // The delta to subtract from a goto_w or jsr_w opcode to get the corresponding goto or jsr    // opcode, or 0 if goto_w and jsr_w must be left unchanged (i.e. when expanding ASM specific    // instructions).    final int wideJumpOpcodeDelta =        (context.parsingOptions & EXPAND_ASM_INSNS) == 0 ? Constants.WIDE_JUMP_OPCODE_DELTA : 0;    currentOffset = bytecodeStartOffset;    while (currentOffset < bytecodeEndOffset) {      final int currentBytecodeOffset = currentOffset - bytecodeStartOffset;      // Visit the label and the line number(s) for this bytecode offset, if any.      Label currentLabel = labels[currentBytecodeOffset];      if (currentLabel != null) {        currentLabel.accept(methodVisitor, (context.parsingOptions & SKIP_DEBUG) == 0);      }      // Visit the stack map frame for this bytecode offset, if any.      while (stackMapFrameOffset != 0          && (context.currentFrameOffset == currentBytecodeOffset              || context.currentFrameOffset == -1)) {        // If there is a stack map frame for this offset, make methodVisitor visit it, and read the        // next stack map frame if there is one.        if (context.currentFrameOffset != -1) {          if (!compressedFrames || expandFrames) {            methodVisitor.visitFrame(                Opcodes.F_NEW,                context.currentFrameLocalCount,                context.currentFrameLocalTypes,                context.currentFrameStackCount,                context.currentFrameStackTypes);          } else {            methodVisitor.visitFrame(                context.currentFrameType,                context.currentFrameLocalCountDelta,                context.currentFrameLocalTypes,                context.currentFrameStackCount,                context.currentFrameStackTypes);          }          // Since there is already a stack map frame for this bytecode offset, there is no need to          // insert a new one.          insertFrame = false;        }        if (stackMapFrameOffset < stackMapTableEndOffset) {          stackMapFrameOffset =              readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);        } else {          stackMapFrameOffset = 0;        }      }      // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to      // true during the previous iteration. The actual frame content is computed in MethodWriter.      if (insertFrame) {        if ((context.parsingOptions & EXPAND_FRAMES) != 0) {          methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);        }        insertFrame = false;      }      // Visit the instruction at this bytecode offset.      int opcode = classFileBuffer[currentOffset] & 0xFF;      switch (opcode) {        case Constants.NOP:        case Constants.ACONST_NULL:        case Constants.ICONST_M1:        case Constants.ICONST_0:        case Constants.ICONST_1:        case Constants.ICONST_2:        case Constants.ICONST_3:        case Constants.ICONST_4:        case Constants.ICONST_5:        case Constants.LCONST_0:        case Constants.LCONST_1:        case Constants.FCONST_0:        case Constants.FCONST_1:        case Constants.FCONST_2:        case Constants.DCONST_0:        case Constants.DCONST_1:        case Constants.IALOAD:        case Constants.LALOAD:        case Constants.FALOAD:        case Constants.DALOAD:        case Constants.AALOAD:        case Constants.BALOAD:        case Constants.CALOAD:        case Constants.SALOAD:        case Constants.IASTORE:        case Constants.LASTORE:        case Constants.FASTORE:        case Constants.DASTORE:        case Constants.AASTORE:        case Constants.BASTORE:        case Constants.CASTORE:        case Constants.SASTORE:        case Constants.POP:        case Constants.POP2:        case Constants.DUP:        case Constants.DUP_X1:        case Constants.DUP_X2:        case Constants.DUP2:        case Constants.DUP2_X1:        case Constants.DUP2_X2:        case Constants.SWAP:        case Constants.IADD:        case Constants.LADD:        case Constants.FADD:        case Constants.DADD:        case Constants.ISUB:        case Constants.LSUB:        case Constants.FSUB:        case Constants.DSUB:        case Constants.IMUL:        case Constants.LMUL:        case Constants.FMUL:        case Constants.DMUL:        case Constants.IDIV:        case Constants.LDIV:        case Constants.FDIV:        case Constants.DDIV:        case Constants.IREM:        case Constants.LREM:        case Constants.FREM:        case Constants.DREM:        case Constants.INEG:        case Constants.LNEG:        case Constants.FNEG:        case Constants.DNEG:        case Constants.ISHL:        case Constants.LSHL:        case Constants.ISHR:        case Constants.LSHR:        case Constants.IUSHR:        case Constants.LUSHR:        case Constants.IAND:        case Constants.LAND:        case Constants.IOR:        case Constants.LOR:        case Constants.IXOR:        case Constants.LXOR:        case Constants.I2L:        case Constants.I2F:        case Constants.I2D:        case Constants.L2I:        case Constants.L2F:        case Constants.L2D:        case Constants.F2I:        case Constants.F2L:        case Constants.F2D:        case Constants.D2I:        case Constants.D2L:        case Constants.D2F:        case Constants.I2B:        case Constants.I2C:        case Constants.I2S:        case Constants.LCMP:        case Constants.FCMPL:        case Constants.FCMPG:        case Constants.DCMPL:        case Constants.DCMPG:        case Constants.IRETURN:        case Constants.LRETURN:        case Constants.FRETURN:        case Constants.DRETURN:        case Constants.ARETURN:        case Constants.RETURN:        case Constants.ARRAYLENGTH:        case Constants.ATHROW:        case Constants.MONITORENTER:        case Constants.MONITOREXIT:          methodVisitor.visitInsn(opcode);          currentOffset += 1;          break;        case Constants.ILOAD_0:        case Constants.ILOAD_1:        case Constants.ILOAD_2:        case Constants.ILOAD_3:        case Constants.LLOAD_0:        case Constants.LLOAD_1:        case Constants.LLOAD_2:        case Constants.LLOAD_3:        case Constants.FLOAD_0:        case Constants.FLOAD_1:        case Constants.FLOAD_2:        case Constants.FLOAD_3:        case Constants.DLOAD_0:        case Constants.DLOAD_1:        case Constants.DLOAD_2:        case Constants.DLOAD_3:        case Constants.ALOAD_0:        case Constants.ALOAD_1:        case Constants.ALOAD_2:        case Constants.ALOAD_3:          opcode -= Constants.ILOAD_0;          methodVisitor.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);          currentOffset += 1;          break;        case Constants.ISTORE_0:        case Constants.ISTORE_1:        case Constants.ISTORE_2:        case Constants.ISTORE_3:        case Constants.LSTORE_0:        case Constants.LSTORE_1:        case Constants.LSTORE_2:        case Constants.LSTORE_3:        case Constants.FSTORE_0:        case Constants.FSTORE_1:        case Constants.FSTORE_2:        case Constants.FSTORE_3:        case Constants.DSTORE_0:        case Constants.DSTORE_1:        case Constants.DSTORE_2:        case Constants.DSTORE_3:        case Constants.ASTORE_0:        case Constants.ASTORE_1:        case Constants.ASTORE_2:        case Constants.ASTORE_3:          opcode -= Constants.ISTORE_0;          methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);          currentOffset += 1;          break;        case Constants.IFEQ:        case Constants.IFNE:        case Constants.IFLT:        case Constants.IFGE:        case Constants.IFGT:        case Constants.IFLE:        case Constants.IF_ICMPEQ:        case Constants.IF_ICMPNE:        case Constants.IF_ICMPLT:        case Constants.IF_ICMPGE:        case Constants.IF_ICMPGT:        case Constants.IF_ICMPLE:        case Constants.IF_ACMPEQ:        case Constants.IF_ACMPNE:        case Constants.GOTO:        case Constants.JSR:        case Constants.IFNULL:        case Constants.IFNONNULL:          methodVisitor.visitJumpInsn(              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);          currentOffset += 3;          break;        case Constants.GOTO_W:        case Constants.JSR_W:          methodVisitor.visitJumpInsn(              opcode - wideJumpOpcodeDelta,              labels[currentBytecodeOffset + readInt(currentOffset + 1)]);          currentOffset += 5;          break;        case Constants.ASM_IFEQ:        case Constants.ASM_IFNE:        case Constants.ASM_IFLT:        case Constants.ASM_IFGE:        case Constants.ASM_IFGT:        case Constants.ASM_IFLE:        case Constants.ASM_IF_ICMPEQ:        case Constants.ASM_IF_ICMPNE:        case Constants.ASM_IF_ICMPLT:        case Constants.ASM_IF_ICMPGE:        case Constants.ASM_IF_ICMPGT:        case Constants.ASM_IF_ICMPLE:        case Constants.ASM_IF_ACMPEQ:        case Constants.ASM_IF_ACMPNE:        case Constants.ASM_GOTO:        case Constants.ASM_JSR:        case Constants.ASM_IFNULL:        case Constants.ASM_IFNONNULL:          {            // A forward jump with an offset > 32767. In this case we automatically replace ASM_GOTO            // with GOTO_W, ASM_JSR with JSR_W and ASM_IFxxx <l> with IFNOTxxx <L> GOTO_W <l> L:...,            // where IFNOTxxx is the "opposite" opcode of ASMS_IFxxx (e.g. IFNE for ASM_IFEQ) and            // where <L> designates the instruction just after the GOTO_W.            // First, change the ASM specific opcodes ASM_IFEQ ... ASM_JSR, ASM_IFNULL and            // ASM_IFNONNULL to IFEQ ... JSR, IFNULL and IFNONNULL.            opcode =                opcode < Constants.ASM_IFNULL                    ? opcode - Constants.ASM_OPCODE_DELTA                    : opcode - Constants.ASM_IFNULL_OPCODE_DELTA;            Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {              // Replace GOTO with GOTO_W and JSR with JSR_W.              methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);            } else {              // Compute the "opposite" of opcode. This can be done by flipping the least              // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ              // (with a pre and post offset by 1).              opcode = opcode < Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;              Label endif = createLabel(currentBytecodeOffset + 3, labels);              methodVisitor.visitJumpInsn(opcode, endif);              methodVisitor.visitJumpInsn(Constants.GOTO_W, target);              // endif designates the instruction just after GOTO_W, and is visited as part of the              // next instruction. Since it is a jump target, we need to insert a frame here.              insertFrame = true;            }            currentOffset += 3;            break;          }        case Constants.ASM_GOTO_W:          {            // Replace ASM_GOTO_W with GOTO_W.            methodVisitor.visitJumpInsn(                Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);            // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns            // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame            // here.            insertFrame = true;            currentOffset += 5;            break;          }        case Constants.WIDE:          opcode = classFileBuffer[currentOffset + 1] & 0xFF;          if (opcode == Opcodes.IINC) {            methodVisitor.visitIincInsn(                readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));            currentOffset += 6;          } else {            methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));            currentOffset += 4;          }          break;        case Constants.TABLESWITCH:          {            // Skip 0 to 3 padding bytes.            currentOffset += 4 - (currentBytecodeOffset & 3);            // Read the instruction.            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];            int low = readInt(currentOffset + 4);            int high = readInt(currentOffset + 8);            currentOffset += 12;            Label[] table = new Label[high - low + 1];            for (int i = 0; i < table.length; ++i) {              table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];              currentOffset += 4;            }            methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);            break;          }        case Constants.LOOKUPSWITCH:          {            // Skip 0 to 3 padding bytes.            currentOffset += 4 - (currentBytecodeOffset & 3);            // Read the instruction.            Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];            int numPairs = readInt(currentOffset + 4);            currentOffset += 8;            int[] keys = new int[numPairs];            Label[] values = new Label[numPairs];            for (int i = 0; i < numPairs; ++i) {              keys[i] = readInt(currentOffset);              values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];              currentOffset += 8;            }            methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);            break;          }        case Constants.ILOAD:        case Constants.LLOAD:        case Constants.FLOAD:        case Constants.DLOAD:        case Constants.ALOAD:        case Constants.ISTORE:        case Constants.LSTORE:        case Constants.FSTORE:        case Constants.DSTORE:        case Constants.ASTORE:        case Constants.RET:          methodVisitor.visitVarInsn(opcode, classFileBuffer[currentOffset + 1] & 0xFF);          currentOffset += 2;          break;        case Constants.BIPUSH:        case Constants.NEWARRAY:          methodVisitor.visitIntInsn(opcode, classFileBuffer[currentOffset + 1]);          currentOffset += 2;          break;        case Constants.SIPUSH:          methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));          currentOffset += 3;          break;        case Constants.LDC:          methodVisitor.visitLdcInsn(              readConst(classFileBuffer[currentOffset + 1] & 0xFF, charBuffer));          currentOffset += 2;          break;        case Constants.LDC_W:        case Constants.LDC2_W:          methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));          currentOffset += 3;          break;        case Constants.GETSTATIC:        case Constants.PUTSTATIC:        case Constants.GETFIELD:        case Constants.PUTFIELD:        case Constants.INVOKEVIRTUAL:        case Constants.INVOKESPECIAL:        case Constants.INVOKESTATIC:        case Constants.INVOKEINTERFACE:          {            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];            String owner = readClass(cpInfoOffset, charBuffer);            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);            if (opcode < Opcodes.INVOKEVIRTUAL) {              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);            } else {              boolean isInterface =                  classFileBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);            }            if (opcode == Opcodes.INVOKEINTERFACE) {              currentOffset += 5;            } else {              currentOffset += 3;            }            break;          }        case Constants.INVOKEDYNAMIC:          {            int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];            int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];            String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);            String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);            int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];            Handle handle =                (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);            Object[] bootstrapMethodArguments =                new Object[readUnsignedShort(bootstrapMethodOffset + 2)];            bootstrapMethodOffset += 4;            for (int i = 0; i < bootstrapMethodArguments.length; i++) {              bootstrapMethodArguments[i] =                  readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);              bootstrapMethodOffset += 2;            }            methodVisitor.visitInvokeDynamicInsn(                name, descriptor, handle, bootstrapMethodArguments);            currentOffset += 5;            break;          }        case Constants.NEW:        case Constants.ANEWARRAY:        case Constants.CHECKCAST:        case Constants.INSTANCEOF:          methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));          currentOffset += 3;          break;        case Constants.IINC:          methodVisitor.visitIincInsn(              classFileBuffer[currentOffset + 1] & 0xFF, classFileBuffer[currentOffset + 2]);          currentOffset += 3;          break;        case Constants.MULTIANEWARRAY:          methodVisitor.visitMultiANewArrayInsn(              readClass(currentOffset + 1, charBuffer), classFileBuffer[currentOffset + 3] & 0xFF);          currentOffset += 4;          break;        default:          throw new AssertionError();      }      // Visit the runtime visible instruction annotations, if any.      while (visibleTypeAnnotationOffsets != null          && currentVisibleTypeAnnotationIndex < visibleTypeAnnotationOffsets.length          && currentVisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {        if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {          // Parse the target_type, target_info and target_path fields.          int currentAnnotationOffset =              readTypeAnnotationTarget(                  context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);          // Parse the type_index field.          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);          currentAnnotationOffset += 2;          // Parse num_element_value_pairs and element_value_pairs and visit these values.          readElementValues(              methodVisitor.visitInsnAnnotation(                  context.currentTypeAnnotationTarget,                  context.currentTypeAnnotationTargetPath,                  annotationDescriptor,                  /* visible = */ true),              currentAnnotationOffset,              /* named = */ true,              charBuffer);        }        currentVisibleTypeAnnotationBytecodeOffset =            getTypeAnnotationBytecodeOffset(                visibleTypeAnnotationOffsets, ++currentVisibleTypeAnnotationIndex);      }      // Visit the runtime invisible instruction annotations, if any.      while (invisibleTypeAnnotationOffsets != null          && currentInvisibleTypeAnnotationIndex < invisibleTypeAnnotationOffsets.length          && currentInvisibleTypeAnnotationBytecodeOffset <= currentBytecodeOffset) {        if (currentInvisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {          // Parse the target_type, target_info and target_path fields.          int currentAnnotationOffset =              readTypeAnnotationTarget(                  context, invisibleTypeAnnotationOffsets[currentInvisibleTypeAnnotationIndex]);          // Parse the type_index field.          String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);          currentAnnotationOffset += 2;          // Parse num_element_value_pairs and element_value_pairs and visit these values.          readElementValues(              methodVisitor.visitInsnAnnotation(                  context.currentTypeAnnotationTarget,                  context.currentTypeAnnotationTargetPath,                  annotationDescriptor,                  /* visible = */ false),              currentAnnotationOffset,              /* named = */ true,              charBuffer);        }        currentInvisibleTypeAnnotationBytecodeOffset =            getTypeAnnotationBytecodeOffset(                invisibleTypeAnnotationOffsets, ++currentInvisibleTypeAnnotationIndex);      }    }    if (labels[codeLength] != null) {      methodVisitor.visitLabel(labels[codeLength]);    }    // Visit LocalVariableTable and LocalVariableTypeTable attributes.    if (localVariableTableOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {      // The (start_pc, index, signature_index) fields of each entry of the LocalVariableTypeTable.      int[] typeTable = null;      if (localVariableTypeTableOffset != 0) {        typeTable = new int[readUnsignedShort(localVariableTypeTableOffset) * 3];        currentOffset = localVariableTypeTableOffset + 2;        int typeTableIndex = typeTable.length;        while (typeTableIndex > 0) {          // Store the offset of 'signature_index', and the value of 'index' and 'start_pc'.          typeTable[--typeTableIndex] = currentOffset + 6;          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset + 8);          typeTable[--typeTableIndex] = readUnsignedShort(currentOffset);          currentOffset += 10;        }      }      int localVariableTableLength = readUnsignedShort(localVariableTableOffset);      currentOffset = localVariableTableOffset + 2;      while (localVariableTableLength-- > 0) {        int startPc = readUnsignedShort(currentOffset);        int length = readUnsignedShort(currentOffset + 2);        String name = readUTF8(currentOffset + 4, charBuffer);        String descriptor = readUTF8(currentOffset + 6, charBuffer);        int index = readUnsignedShort(currentOffset + 8);        currentOffset += 10;        String signature = null;        if (typeTable != null) {          for (int i = 0; i < typeTable.length; i += 3) {            if (typeTable[i] == startPc && typeTable[i + 1] == index) {              signature = readUTF8(typeTable[i + 2], charBuffer);              break;            }          }        }        methodVisitor.visitLocalVariable(            name, descriptor, signature, labels[startPc], labels[startPc + length], index);      }    }    // Visit the local variable type annotations of the RuntimeVisibleTypeAnnotations attribute.    if (visibleTypeAnnotationOffsets != null) {      for (int typeAnnotationOffset : visibleTypeAnnotationOffsets) {        int targetType = readByte(typeAnnotationOffset);        if (targetType == TypeReference.LOCAL_VARIABLE            || targetType == TypeReference.RESOURCE_VARIABLE) {          // Parse the target_type, target_info and target_path fields.          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);          // Parse the type_index field.          String annotationDescriptor = readUTF8(currentOffset, charBuffer);          currentOffset += 2;          // Parse num_element_value_pairs and element_value_pairs and visit these values.          readElementValues(              methodVisitor.visitLocalVariableAnnotation(                  context.currentTypeAnnotationTarget,                  context.currentTypeAnnotationTargetPath,                  context.currentLocalVariableAnnotationRangeStarts,                  context.currentLocalVariableAnnotationRangeEnds,                  context.currentLocalVariableAnnotationRangeIndices,                  annotationDescriptor,                  /* visible = */ true),              currentOffset,              /* named = */ true,              charBuffer);        }      }    }    // Visit the local variable type annotations of the RuntimeInvisibleTypeAnnotations attribute.    if (invisibleTypeAnnotationOffsets != null) {      for (int typeAnnotationOffset : invisibleTypeAnnotationOffsets) {        int targetType = readByte(typeAnnotationOffset);        if (targetType == TypeReference.LOCAL_VARIABLE            || targetType == TypeReference.RESOURCE_VARIABLE) {          // Parse the target_type, target_info and target_path fields.          currentOffset = readTypeAnnotationTarget(context, typeAnnotationOffset);          // Parse the type_index field.          String annotationDescriptor = readUTF8(currentOffset, charBuffer);          currentOffset += 2;          // Parse num_element_value_pairs and element_value_pairs and visit these values.          readElementValues(              methodVisitor.visitLocalVariableAnnotation(                  context.currentTypeAnnotationTarget,                  context.currentTypeAnnotationTargetPath,                  context.currentLocalVariableAnnotationRangeStarts,                  context.currentLocalVariableAnnotationRangeEnds,                  context.currentLocalVariableAnnotationRangeIndices,                  annotationDescriptor,                  /* visible = */ false),              currentOffset,              /* named = */ true,              charBuffer);        }      }    }    // Visit the non standard attributes.    while (attributes != null) {      // Copy and reset the nextAttribute field so that it can also be used in MethodWriter.      Attribute nextAttribute = attributes.nextAttribute;      attributes.nextAttribute = null;      methodVisitor.visitAttribute(attributes);      attributes = nextAttribute;    }    // Visit the max stack and max locals values.    methodVisitor.visitMaxs(maxStack, maxLocals);  }
protected Label readLabel(final int bytecodeOffset, final Label[] labels) {    if (labels[bytecodeOffset] == null) {      labels[bytecodeOffset] = new Label();    }    return labels[bytecodeOffset];  }
private Label createLabel(final int bytecodeOffset, final Label[] labels) {    Label label = readLabel(bytecodeOffset, labels);    label.flags &= ~Label.FLAG_DEBUG_ONLY;    return label;  }
private void createDebugLabel(final int bytecodeOffset, final Label[] labels) {    if (labels[bytecodeOffset] == null) {      readLabel(bytecodeOffset, labels).flags |= Label.FLAG_DEBUG_ONLY;    }  }
private int[] readTypeAnnotations(      final MethodVisitor methodVisitor,      final Context context,      final int runtimeTypeAnnotationsOffset,      final boolean visible) {    char[] charBuffer = context.charBuffer;    int currentOffset = runtimeTypeAnnotationsOffset;    // Read the num_annotations field and create an array to store the type_annotation offsets.    int[] typeAnnotationsOffsets = new int[readUnsignedShort(currentOffset)];    currentOffset += 2;    // Parse the 'annotations' array field.    for (int i = 0; i < typeAnnotationsOffsets.length; ++i) {      typeAnnotationsOffsets[i] = currentOffset;      // Parse the type_annotation's target_type and the target_info fields. The size of the      // target_info field depends on the value of target_type.      int targetType = readInt(currentOffset);      switch (targetType >>> 24) {        case TypeReference.LOCAL_VARIABLE:        case TypeReference.RESOURCE_VARIABLE:          // A localvar_target has a variable size, which depends on the value of their table_length          // field. It also references bytecode offsets, for which we need labels.          int tableLength = readUnsignedShort(currentOffset + 1);          currentOffset += 3;          while (tableLength-- > 0) {            int startPc = readUnsignedShort(currentOffset);            int length = readUnsignedShort(currentOffset + 2);            // Skip the index field (2 bytes).            currentOffset += 6;            createLabel(startPc, context.currentMethodLabels);            createLabel(startPc + length, context.currentMethodLabels);          }          break;        case TypeReference.CAST:        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:          currentOffset += 4;          break;        case TypeReference.CLASS_EXTENDS:        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:        case TypeReference.THROWS:        case TypeReference.EXCEPTION_PARAMETER:        case TypeReference.INSTANCEOF:        case TypeReference.NEW:        case TypeReference.CONSTRUCTOR_REFERENCE:        case TypeReference.METHOD_REFERENCE:          currentOffset += 3;          break;        case TypeReference.CLASS_TYPE_PARAMETER:        case TypeReference.METHOD_TYPE_PARAMETER:        case TypeReference.METHOD_FORMAL_PARAMETER:        case TypeReference.FIELD:        case TypeReference.METHOD_RETURN:        case TypeReference.METHOD_RECEIVER:        default:          // TypeReference type which can't be used in Code attribute, or which is unknown.          throw new IllegalArgumentException();      }      // Parse the rest of the type_annotation structure, starting with the target_path structure      // (whose size depends on its path_length field).      int pathLength = readByte(currentOffset);      if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {        // Parse the target_path structure and create a corresponding TypePath.        TypePath path = pathLength == 0 ? null : new TypePath(b, currentOffset);        currentOffset += 1 + 2 * pathLength;        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentOffset, charBuffer);        currentOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentOffset =            readElementValues(                methodVisitor.visitTryCatchAnnotation(                    targetType & 0xFFFFFF00, path, annotationDescriptor, visible),                currentOffset,                /* named = */ true,                charBuffer);      } else {        // We don't want to visit the other target_type annotations, so we just skip them (which        // requires some parsing because the element_value_pairs array has a variable size). First,        // skip the target_path structure:        currentOffset += 3 + 2 * pathLength;        // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them        // with a null AnnotationVisitor).        currentOffset =            readElementValues(                /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);      }    }    return typeAnnotationsOffsets;  }
private int getTypeAnnotationBytecodeOffset(      final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {    if (typeAnnotationOffsets == null        || typeAnnotationIndex >= typeAnnotationOffsets.length        || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {      return -1;    }    return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);  }
private int readTypeAnnotationTarget(final Context context, final int typeAnnotationOffset) {    int currentOffset = typeAnnotationOffset;    // Parse and store the target_type structure.    int targetType = readInt(typeAnnotationOffset);    switch (targetType >>> 24) {      case TypeReference.CLASS_TYPE_PARAMETER:      case TypeReference.METHOD_TYPE_PARAMETER:      case TypeReference.METHOD_FORMAL_PARAMETER:        targetType &= 0xFFFF0000;        currentOffset += 2;        break;      case TypeReference.FIELD:      case TypeReference.METHOD_RETURN:      case TypeReference.METHOD_RECEIVER:        targetType &= 0xFF000000;        currentOffset += 1;        break;      case TypeReference.LOCAL_VARIABLE:      case TypeReference.RESOURCE_VARIABLE:        targetType &= 0xFF000000;        int tableLength = readUnsignedShort(currentOffset + 1);        currentOffset += 3;        context.currentLocalVariableAnnotationRangeStarts = new Label[tableLength];        context.currentLocalVariableAnnotationRangeEnds = new Label[tableLength];        context.currentLocalVariableAnnotationRangeIndices = new int[tableLength];        for (int i = 0; i < tableLength; ++i) {          int startPc = readUnsignedShort(currentOffset);          int length = readUnsignedShort(currentOffset + 2);          int index = readUnsignedShort(currentOffset + 4);          currentOffset += 6;          context.currentLocalVariableAnnotationRangeStarts[i] =              createLabel(startPc, context.currentMethodLabels);          context.currentLocalVariableAnnotationRangeEnds[i] =              createLabel(startPc + length, context.currentMethodLabels);          context.currentLocalVariableAnnotationRangeIndices[i] = index;        }        break;      case TypeReference.CAST:      case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:      case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:      case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:      case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:        targetType &= 0xFF0000FF;        currentOffset += 4;        break;      case TypeReference.CLASS_EXTENDS:      case TypeReference.CLASS_TYPE_PARAMETER_BOUND:      case TypeReference.METHOD_TYPE_PARAMETER_BOUND:      case TypeReference.THROWS:      case TypeReference.EXCEPTION_PARAMETER:        targetType &= 0xFFFFFF00;        currentOffset += 3;        break;      case TypeReference.INSTANCEOF:      case TypeReference.NEW:      case TypeReference.CONSTRUCTOR_REFERENCE:      case TypeReference.METHOD_REFERENCE:        targetType &= 0xFF000000;        currentOffset += 3;        break;      default:        throw new IllegalArgumentException();    }    context.currentTypeAnnotationTarget = targetType;    // Parse and store the target_path structure.    int pathLength = readByte(currentOffset);    context.currentTypeAnnotationTargetPath =        pathLength == 0 ? null : new TypePath(b, currentOffset);    // Return the start offset of the rest of the type_annotation structure.    return currentOffset + 1 + 2 * pathLength;  }
private void readParameterAnnotations(      final MethodVisitor methodVisitor,      final Context context,      final int runtimeParameterAnnotationsOffset,      final boolean visible) {    int currentOffset = runtimeParameterAnnotationsOffset;    int numParameters = b[currentOffset++] & 0xFF;    methodVisitor.visitAnnotableParameterCount(numParameters, visible);    char[] charBuffer = context.charBuffer;    for (int i = 0; i < numParameters; ++i) {      int numAnnotations = readUnsignedShort(currentOffset);      currentOffset += 2;      while (numAnnotations-- > 0) {        // Parse the type_index field.        String annotationDescriptor = readUTF8(currentOffset, charBuffer);        currentOffset += 2;        // Parse num_element_value_pairs and element_value_pairs and visit these values.        currentOffset =            readElementValues(                methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),                currentOffset,                /* named = */ true,                charBuffer);      }    }  }
private int readElementValues(      final AnnotationVisitor annotationVisitor,      final int annotationOffset,      final boolean named,      final char[] charBuffer) {    int currentOffset = annotationOffset;    // Read the num_element_value_pairs field (or num_values field for an array_value).    int numElementValuePairs = readUnsignedShort(currentOffset);    currentOffset += 2;    if (named) {      // Parse the element_value_pairs array.      while (numElementValuePairs-- > 0) {        String elementName = readUTF8(currentOffset, charBuffer);        currentOffset =            readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);      }    } else {      // Parse the array_value array.      while (numElementValuePairs-- > 0) {        currentOffset =            readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);      }    }    if (annotationVisitor != null) {      annotationVisitor.visitEnd();    }    return currentOffset;  }
private int readElementValue(      final AnnotationVisitor annotationVisitor,      final int elementValueOffset,      final String elementName,      final char[] charBuffer) {    int currentOffset = elementValueOffset;    if (annotationVisitor == null) {      switch (b[currentOffset] & 0xFF) {        case 'e': // enum_const_value          return currentOffset + 5;        case '@': // annotation_value          return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);        case '[': // array_value          return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);        default:          return currentOffset + 3;      }    }    switch (b[currentOffset++] & 0xFF) {      case 'B': // const_value_index, CONSTANT_Integer        annotationVisitor.visit(            elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));        currentOffset += 2;        break;      case 'C': // const_value_index, CONSTANT_Integer        annotationVisitor.visit(            elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));        currentOffset += 2;        break;      case 'D': // const_value_index, CONSTANT_Double      case 'F': // const_value_index, CONSTANT_Float      case 'I': // const_value_index, CONSTANT_Integer      case 'J': // const_value_index, CONSTANT_Long        annotationVisitor.visit(            elementName, readConst(readUnsignedShort(currentOffset), charBuffer));        currentOffset += 2;        break;      case 'S': // const_value_index, CONSTANT_Integer        annotationVisitor.visit(            elementName, (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));        currentOffset += 2;        break;      case 'Z': // const_value_index, CONSTANT_Integer        annotationVisitor.visit(            elementName,            readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]) == 0                ? Boolean.FALSE                : Boolean.TRUE);        currentOffset += 2;        break;      case 's': // const_value_index, CONSTANT_Utf8        annotationVisitor.visit(elementName, readUTF8(currentOffset, charBuffer));        currentOffset += 2;        break;      case 'e': // enum_const_value        annotationVisitor.visitEnum(            elementName,            readUTF8(currentOffset, charBuffer),            readUTF8(currentOffset + 2, charBuffer));        currentOffset += 4;        break;      case 'c': // class_info        annotationVisitor.visit(elementName, Type.getType(readUTF8(currentOffset, charBuffer)));        currentOffset += 2;        break;      case '@': // annotation_value        currentOffset =            readElementValues(                annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),                currentOffset + 2,                true,                charBuffer);        break;      case '[': // array_value        int numValues = readUnsignedShort(currentOffset);        currentOffset += 2;        if (numValues == 0) {          return readElementValues(              annotationVisitor.visitArray(elementName),              currentOffset - 2,              /* named = */ false,              charBuffer);        }        switch (b[currentOffset] & 0xFF) {          case 'B':            byte[] byteValues = new byte[numValues];            for (int i = 0; i < numValues; i++) {              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);              currentOffset += 3;            }            annotationVisitor.visit(elementName, byteValues);            break;          case 'Z':            boolean[] booleanValues = new boolean[numValues];            for (int i = 0; i < numValues; i++) {              booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;              currentOffset += 3;            }            annotationVisitor.visit(elementName, booleanValues);            break;          case 'S':            short[] shortValues = new short[numValues];            for (int i = 0; i < numValues; i++) {              shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);              currentOffset += 3;            }            annotationVisitor.visit(elementName, shortValues);            break;          case 'C':            char[] charValues = new char[numValues];            for (int i = 0; i < numValues; i++) {              charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);              currentOffset += 3;            }            annotationVisitor.visit(elementName, charValues);            break;          case 'I':            int[] intValues = new int[numValues];            for (int i = 0; i < numValues; i++) {              intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);              currentOffset += 3;            }            annotationVisitor.visit(elementName, intValues);            break;          case 'J':            long[] longValues = new long[numValues];            for (int i = 0; i < numValues; i++) {              longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);              currentOffset += 3;            }            annotationVisitor.visit(elementName, longValues);            break;          case 'F':            float[] floatValues = new float[numValues];            for (int i = 0; i < numValues; i++) {              floatValues[i] =                  Float.intBitsToFloat(                      readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));              currentOffset += 3;            }            annotationVisitor.visit(elementName, floatValues);            break;          case 'D':            double[] doubleValues = new double[numValues];            for (int i = 0; i < numValues; i++) {              doubleValues[i] =                  Double.longBitsToDouble(                      readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));              currentOffset += 3;            }            annotationVisitor.visit(elementName, doubleValues);            break;          default:            currentOffset =                readElementValues(                    annotationVisitor.visitArray(elementName),                    currentOffset - 2,                    /* named = */ false,                    charBuffer);            break;        }        break;      default:        throw new IllegalArgumentException();    }    return currentOffset;  }
private void computeImplicitFrame(final Context context) {    String methodDescriptor = context.currentMethodDescriptor;    Object[] locals = context.currentFrameLocalTypes;    int numLocal = 0;    if ((context.currentMethodAccessFlags & Opcodes.ACC_STATIC) == 0) {      if ("<init>".equals(context.currentMethodName)) {        locals[numLocal++] = Opcodes.UNINITIALIZED_THIS;      } else {        locals[numLocal++] = readClass(header + 2, context.charBuffer);      }    }    // Parse the method descriptor, one argument type descriptor at each iteration. Start by    // skipping the first method descriptor character, which is always '('.    int currentMethodDescritorOffset = 1;    while (true) {      int currentArgumentDescriptorStartOffset = currentMethodDescritorOffset;      switch (methodDescriptor.charAt(currentMethodDescritorOffset++)) {        case 'Z':        case 'C':        case 'B':        case 'S':        case 'I':          locals[numLocal++] = Opcodes.INTEGER;          break;        case 'F':          locals[numLocal++] = Opcodes.FLOAT;          break;        case 'J':          locals[numLocal++] = Opcodes.LONG;          break;        case 'D':          locals[numLocal++] = Opcodes.DOUBLE;          break;        case '[':          while (methodDescriptor.charAt(currentMethodDescritorOffset) == '[') {            ++currentMethodDescritorOffset;          }          if (methodDescriptor.charAt(currentMethodDescritorOffset) == 'L') {            ++currentMethodDescritorOffset;            while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {              ++currentMethodDescritorOffset;            }          }          locals[numLocal++] =              methodDescriptor.substring(                  currentArgumentDescriptorStartOffset, ++currentMethodDescritorOffset);          break;        case 'L':          while (methodDescriptor.charAt(currentMethodDescritorOffset) != ';') {            ++currentMethodDescritorOffset;          }          locals[numLocal++] =              methodDescriptor.substring(                  currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);          break;        default:          context.currentFrameLocalCount = numLocal;          return;      }    }  }
private int readStackMapFrame(      final int stackMapFrameOffset,      final boolean compressed,      final boolean expand,      final Context context) {    int currentOffset = stackMapFrameOffset;    final char[] charBuffer = context.charBuffer;    final Label[] labels = context.currentMethodLabels;    int frameType;    if (compressed) {      // Read the frame_type field.      frameType = b[currentOffset++] & 0xFF;    } else {      frameType = Frame.FULL_FRAME;      context.currentFrameOffset = -1;    }    int offsetDelta;    context.currentFrameLocalCountDelta = 0;    if (frameType < Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {      offsetDelta = frameType;      context.currentFrameType = Opcodes.F_SAME;      context.currentFrameStackCount = 0;    } else if (frameType < Frame.RESERVED) {      offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;      currentOffset =          readVerificationTypeInfo(              currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);      context.currentFrameType = Opcodes.F_SAME1;      context.currentFrameStackCount = 1;    } else if (frameType >= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {      offsetDelta = readUnsignedShort(currentOffset);      currentOffset += 2;      if (frameType == Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {        currentOffset =            readVerificationTypeInfo(                currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);        context.currentFrameType = Opcodes.F_SAME1;        context.currentFrameStackCount = 1;      } else if (frameType >= Frame.CHOP_FRAME && frameType < Frame.SAME_FRAME_EXTENDED) {        context.currentFrameType = Opcodes.F_CHOP;        context.currentFrameLocalCountDelta = Frame.SAME_FRAME_EXTENDED - frameType;        context.currentFrameLocalCount -= context.currentFrameLocalCountDelta;        context.currentFrameStackCount = 0;      } else if (frameType == Frame.SAME_FRAME_EXTENDED) {        context.currentFrameType = Opcodes.F_SAME;        context.currentFrameStackCount = 0;      } else if (frameType < Frame.FULL_FRAME) {        int local = expand ? context.currentFrameLocalCount : 0;        for (int k = frameType - Frame.SAME_FRAME_EXTENDED; k > 0; k--) {          currentOffset =              readVerificationTypeInfo(                  currentOffset, context.currentFrameLocalTypes, local++, charBuffer, labels);        }        context.currentFrameType = Opcodes.F_APPEND;        context.currentFrameLocalCountDelta = frameType - Frame.SAME_FRAME_EXTENDED;        context.currentFrameLocalCount += context.currentFrameLocalCountDelta;        context.currentFrameStackCount = 0;      } else {        final int numberOfLocals = readUnsignedShort(currentOffset);        currentOffset += 2;        context.currentFrameType = Opcodes.F_FULL;        context.currentFrameLocalCountDelta = numberOfLocals;        context.currentFrameLocalCount = numberOfLocals;        for (int local = 0; local < numberOfLocals; ++local) {          currentOffset =              readVerificationTypeInfo(                  currentOffset, context.currentFrameLocalTypes, local, charBuffer, labels);        }        final int numberOfStackItems = readUnsignedShort(currentOffset);        currentOffset += 2;        context.currentFrameStackCount = numberOfStackItems;        for (int stack = 0; stack < numberOfStackItems; ++stack) {          currentOffset =              readVerificationTypeInfo(                  currentOffset, context.currentFrameStackTypes, stack, charBuffer, labels);        }      }    } else {      throw new IllegalArgumentException();    }    context.currentFrameOffset += offsetDelta + 1;    createLabel(context.currentFrameOffset, labels);    return currentOffset;  }
private int readVerificationTypeInfo(      final int verificationTypeInfoOffset,      final Object[] frame,      final int index,      final char[] charBuffer,      final Label[] labels) {    int currentOffset = verificationTypeInfoOffset;    int tag = b[currentOffset++] & 0xFF;    switch (tag) {      case Frame.ITEM_TOP:        frame[index] = Opcodes.TOP;        break;      case Frame.ITEM_INTEGER:        frame[index] = Opcodes.INTEGER;        break;      case Frame.ITEM_FLOAT:        frame[index] = Opcodes.FLOAT;        break;      case Frame.ITEM_DOUBLE:        frame[index] = Opcodes.DOUBLE;        break;      case Frame.ITEM_LONG:        frame[index] = Opcodes.LONG;        break;      case Frame.ITEM_NULL:        frame[index] = Opcodes.NULL;        break;      case Frame.ITEM_UNINITIALIZED_THIS:        frame[index] = Opcodes.UNINITIALIZED_THIS;        break;      case Frame.ITEM_OBJECT:        frame[index] = readClass(currentOffset, charBuffer);        currentOffset += 2;        break;      case Frame.ITEM_UNINITIALIZED:        frame[index] = createLabel(readUnsignedShort(currentOffset), labels);        currentOffset += 2;        break;      default:        throw new IllegalArgumentException();    }    return currentOffset;  }
final int getFirstAttributeOffset() {    // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes    // each), as well as the interfaces array field (2 bytes per interface).    int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;    // Read the fields_count field.    int fieldsCount = readUnsignedShort(currentOffset);    currentOffset += 2;    // Skip the 'fields' array field.    while (fieldsCount-- > 0) {      // Invariant: currentOffset is the offset of a field_info structure.      // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the      // attributes_count field.      int attributesCount = readUnsignedShort(currentOffset + 6);      currentOffset += 8;      // Skip the 'attributes' array field.      while (attributesCount-- > 0) {        // Invariant: currentOffset is the offset of an attribute_info structure.        // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip        // this many bytes, plus 6 for the attribute_name_index and attribute_length fields        // (yielding the total size of the attribute_info structure).        currentOffset += 6 + readInt(currentOffset + 2);      }    }    // Skip the methods_count and 'methods' fields, using the same method as above.    int methodsCount = readUnsignedShort(currentOffset);    currentOffset += 2;    while (methodsCount-- > 0) {      int attributesCount = readUnsignedShort(currentOffset + 6);      currentOffset += 8;      while (attributesCount-- > 0) {        currentOffset += 6 + readInt(currentOffset + 2);      }    }    // Skip the ClassFile's attributes_count field.    return currentOffset + 2;  }
private int[] readBootstrapMethodsAttribute(final int maxStringLength) {    char[] charBuffer = new char[maxStringLength];    int currentAttributeOffset = getFirstAttributeOffset();    int[] currentBootstrapMethodOffsets = null;    for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {      // Read the attribute_info's attribute_name and attribute_length fields.      String attributeName = readUTF8(currentAttributeOffset, charBuffer);      int attributeLength = readInt(currentAttributeOffset + 2);      currentAttributeOffset += 6;      if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {        // Read the num_bootstrap_methods field and create an array of this size.        currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];        // Compute and store the offset of each 'bootstrap_methods' array field entry.        int currentBootstrapMethodOffset = currentAttributeOffset + 2;        for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) {          currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;          // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),          // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).          currentBootstrapMethodOffset +=              4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;        }        return currentBootstrapMethodOffsets;      }      currentAttributeOffset += attributeLength;    }    return null;  }
private Attribute readAttribute(      final Attribute[] attributePrototypes,      final String type,      final int offset,      final int length,      final char[] charBuffer,      final int codeAttributeOffset,      final Label[] labels) {    for (Attribute attributePrototype : attributePrototypes) {      if (attributePrototype.type.equals(type)) {        return attributePrototype.read(            this, offset, length, charBuffer, codeAttributeOffset, labels);      }    }    return new Attribute(type).read(this, offset, length, null, -1, null);  }
public int readInt(final int offset) {    byte[] classFileBuffer = b;    return ((classFileBuffer[offset] & 0xFF) << 24)        | ((classFileBuffer[offset + 1] & 0xFF) << 16)        | ((classFileBuffer[offset + 2] & 0xFF) << 8)        | (classFileBuffer[offset + 3] & 0xFF);  }
public long readLong(final int offset) {    long l1 = readInt(offset);    long l0 = readInt(offset + 4) & 0xFFFFFFFFL;    return (l1 << 32) | l0;  }
public String readUTF8(final int offset, final char[] charBuffer) {    int constantPoolEntryIndex = readUnsignedShort(offset);    if (offset == 0 || constantPoolEntryIndex == 0) {      return null;    }    return readUtf(constantPoolEntryIndex, charBuffer);  }
final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {    String value = constantUtf8Values[constantPoolEntryIndex];    if (value != null) {      return value;    }    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];    return constantUtf8Values[constantPoolEntryIndex] =        readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);  }
private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {    int currentOffset = utfOffset;    int endOffset = currentOffset + utfLength;    int strLength = 0;    byte[] classFileBuffer = b;    while (currentOffset < endOffset) {      int currentByte = classFileBuffer[currentOffset++];      if ((currentByte & 0x80) == 0) {        charBuffer[strLength++] = (char) (currentByte & 0x7F);      } else if ((currentByte & 0xE0) == 0xC0) {        charBuffer[strLength++] =            (char) (((currentByte & 0x1F) << 6) + (classFileBuffer[currentOffset++] & 0x3F));      } else {        charBuffer[strLength++] =            (char)                (((currentByte & 0xF) << 12)                    + ((classFileBuffer[currentOffset++] & 0x3F) << 6)                    + (classFileBuffer[currentOffset++] & 0x3F));      }    }    return new String(charBuffer, 0, strLength);  }
private ConstantDynamic readConstantDynamic(      final int constantPoolEntryIndex, final char[] charBuffer) {    ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];    if (constantDynamic != null) {      return constantDynamic;    }    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];    int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];    String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);    String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);    int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];    Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);    Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];    bootstrapMethodOffset += 4;    for (int i = 0; i < bootstrapMethodArguments.length; i++) {      bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);      bootstrapMethodOffset += 2;    }    return constantDynamicValues[constantPoolEntryIndex] =        new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);  }
public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {    int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];    switch (b[cpInfoOffset - 1]) {      case Symbol.CONSTANT_INTEGER_TAG:        return readInt(cpInfoOffset);      case Symbol.CONSTANT_FLOAT_TAG:        return Float.intBitsToFloat(readInt(cpInfoOffset));      case Symbol.CONSTANT_LONG_TAG:        return readLong(cpInfoOffset);      case Symbol.CONSTANT_DOUBLE_TAG:        return Double.longBitsToDouble(readLong(cpInfoOffset));      case Symbol.CONSTANT_CLASS_TAG:        return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));      case Symbol.CONSTANT_STRING_TAG:        return readUTF8(cpInfoOffset, charBuffer);      case Symbol.CONSTANT_METHOD_TYPE_TAG:        return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));      case Symbol.CONSTANT_METHOD_HANDLE_TAG:        int referenceKind = readByte(cpInfoOffset);        int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];        int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];        String owner = readClass(referenceCpInfoOffset, charBuffer);        String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);        String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);        boolean isInterface =            b[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;        return new Handle(referenceKind, owner, name, descriptor, isInterface);      case Symbol.CONSTANT_DYNAMIC_TAG:        return readConstantDynamic(constantPoolEntryIndex, charBuffer);      default:        throw new IllegalArgumentException();    }  }
@Override	public Clob get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getClob(index);	}
@Override	public void set(final PreparedStatement st, final int index, final Clob value, final int dbSqlType) throws SQLException {		st.setClob(index, value);	}
@Override	public void setContentType(final String type) {		if (type == null) {			mimeType = null;			characterEncoding = null;			return;		}		ContentTypeHeaderResolver contentTypeResolver = new ContentTypeHeaderResolver(type);		mimeType = contentTypeResolver.getMimeType();		characterEncoding = contentTypeResolver.getEncoding();	}
@Override	public String getContentType() {		String contentType = mimeType;		if (mimeType != null && characterEncoding != null) {			contentType += ";charset=" + characterEncoding;		}		return contentType;	}
@Override	public String get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getString(index);	}
@Override	public void set(final PreparedStatement st, final int index, final String value, final int dbSqlType) throws SQLException {		st.setString(index, value);	}
protected CtorDescriptor[] inspectConstructors() {		Class type = classDescriptor.getType();		Constructor[] ctors = type.getDeclaredConstructors();		CtorDescriptor[] allCtors = new CtorDescriptor[ctors.length];		for (int i = 0; i < ctors.length; i++) {			Constructor ctor = ctors[i];			CtorDescriptor ctorDescriptor = createCtorDescriptor(ctor);			allCtors[i] = ctorDescriptor;			if (ctorDescriptor.isDefault()) {				defaultCtor = ctorDescriptor;			}		}		return allCtors;	}
public CtorDescriptor getCtorDescriptor(final Class... args) {		ctors:		for (CtorDescriptor ctorDescriptor : allCtors) {			Class[] arg = ctorDescriptor.getParameters();			if (arg.length != args.length) {				continue;			}			for (int j = 0; j < arg.length; j++) {				if (arg[j] != args[j]) {					continue ctors;				}			}			return ctorDescriptor;		}		return null;	}
@SuppressWarnings("unchecked")	protected Map<String, TransientBeanData> getRequestMap(final HttpServletRequest servletRequest) {		return (Map<String, TransientBeanData>) servletRequest.getAttribute(ATTR_NAME);	}
protected Map<String, TransientBeanData> createRequestMap(final HttpServletRequest servletRequest) {		Map<String, TransientBeanData> map = new HashMap<>();		servletRequest.setAttribute(ATTR_NAME, map);		return map;	}
protected HttpServletRequest getCurrentHttpRequest() {		HttpServletRequest request = RequestContextListener.getRequest();		if (request == null) {			throw new PetiteException("No HTTP request bound to the current thread. Is RequestContextListener registered?");		}		return request;	}
protected long[] convertValueToArray(final Object value) {		if (value instanceof Collection) {			final Collection collection = (Collection) value;			final long[] target = new long[collection.size()];			int i = 0;			for (final Object element : collection) {				target[i] = convertType(element);				i++;			}			return target;		}		if (value instanceof Iterable) {			final Iterable iterable = (Iterable) value;			final ArrayList<Long> longArrayList = new ArrayList<>();			for (final Object element : iterable) {				final long convertedValue = convertType(element);				longArrayList.add(Long.valueOf(convertedValue));			}			final long[] array = new long[longArrayList.size()];			for (int i = 0; i < longArrayList.size(); i++) {				final Long l = longArrayList.get(i);				array[i] = l.longValue();			}			return array;		}		if (value instanceof CharSequence) {			final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS);			return convertArrayToArray(strings);		}		// everything else:		return convertToSingleElementArray(value);	}
protected long[] convertArrayToArray(final Object value) {		final Class valueComponentType = value.getClass().getComponentType();		final long[] result;		if (valueComponentType.isPrimitive()) {			result = convertPrimitiveArrayToArray(value, valueComponentType);		} else {			// convert object array to target array			final Object[] array = (Object[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = convertType(array[i]);			}		}		return result;	}
protected long[] convertPrimitiveArrayToArray(final Object value, final Class primitiveComponentType) {		long[] result = null;		if (primitiveComponentType == long.class) {			return (long[]) value;		}		if (primitiveComponentType == int.class) {			final int[] array = (int[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = array[i];			}		}		else if (primitiveComponentType == float.class) {			final float[] array = (float[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = (long) array[i];			}		}		else if (primitiveComponentType == double.class) {			final double[] array = (double[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = (long) array[i];			}		}		else if (primitiveComponentType == short.class) {			final short[] array = (short[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = array[i];			}		}		else if (primitiveComponentType == byte.class) {			final byte[] array = (byte[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = array[i];			}		}		else if (primitiveComponentType == char.class) {			final char[] array = (char[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = array[i];			}		}		else if (primitiveComponentType == boolean.class) {			final boolean[] array = (boolean[]) value;			result = new long[array.length];			for (int i = 0; i < array.length; i++) {				result[i] = array[i] ? 1 : 0;			}		}		return result;	}
@Override	public void init(final FilterConfig filterConfig) throws ServletException {		//		final String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER);		if (decoraManagerClass != null) {			try {				final Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass);				decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType);			} catch (Exception ex) {				log.error("Unable to load Decora manager class: " + decoraManagerClass, ex);				throw new ServletException(ex);			}		} else {			decoraManager = createDecoraManager();		}		//		final String decoraParserClass = filterConfig.getInitParameter(PARAM_DECORA_PARSER);		if (decoraParserClass != null) {			try {				final Class decoraParserType = ClassLoaderUtil.loadClass(decoraParserClass);				decoraParser = (DecoraParser) ClassUtil.newInstance(decoraParserType);			} catch (Exception ex) {				log.error("Unable to load Decora parser class: " + decoraParserClass, ex);				throw new ServletException(ex);			}		} else {			decoraParser = createDecoraParser();		}		//		final String decoraCache = filterConfig.getInitParameter(PARAM_DECORA_CACHE);		if (decoraCache != null) {			cached = Converter.get().toBoolean(decoraCache, false);		}	}
public FindFile onFile(final Consumer<File> fileConsumer) {		if (consumers == null) {			consumers = Consumers.of(fileConsumer);		}		else {			consumers.add(fileConsumer);		}		return this;	}
public FindFile searchPath(final String searchPath) {		if (searchPath.indexOf(File.pathSeparatorChar) != -1) {			String[] paths = StringUtil.split(searchPath, File.pathSeparator);			for (String path : paths) {				addPath(new File(path));			}		} else {			addPath(new File(searchPath));		}		return this;	}
public FindFile searchPath(final URI searchPath) {		File file;		try {			file = new File(searchPath);		} catch (Exception ex) {			throw new FindFileException("URI error: " + searchPath, ex);		}		addPath(file);		return this;	}
public FindFile searchPath(final URL searchPath) {		File file = FileUtil.toContainerFile(searchPath);		if (file == null) {			throw new FindFileException("URL error: " + searchPath);		}		addPath(file);		return this;	}
public FindFile include(final String... patterns) {		for (String pattern : patterns) {			rules.include(pattern);		}		return this;	}
public FindFile exclude(final String... patterns) {		for (String pattern : patterns) {			rules.exclude(pattern);		}		return this;	}
protected boolean acceptFile(final File file) {		String matchingFilePath = getMatchingFilePath(file);		if (rules.match(matchingFilePath)) {			if (consumers != null) {				consumers.accept(file);			}			return true;		}		return false;	}
protected String getMatchingFilePath(final File file) {		String path = null;		switch (matchType) {			case FULL_PATH:				path = file.getAbsolutePath();				break;			case RELATIVE_PATH:				path = file.getAbsolutePath();				path = path.substring(rootPath.length());				break;			case NAME:				path = file.getName();		}		path = FileNameUtil.separatorsToUnix(path);		return path;	}
protected void addPath(final File path) {		if (!path.exists()) {			return;		}		if (pathList == null) {			pathList = new LinkedList<>();		}		pathList.add(path);	}
public void reset() {		pathList = pathListOriginal;		pathListOriginal = null;		todoFiles = null;		lastFile = null;		rules.reset();	}
public File nextFile() {		if (todoFiles == null) {			init();		}		while (true) {			// iterate files			if (!todoFiles.isEmpty()) {				FilesIterator filesIterator = todoFiles.getLast();				File nextFile = filesIterator.next();				if (nextFile == null) {					todoFiles.removeLast();					continue;				}				if (nextFile.isDirectory()) {					if (!walking) {						todoFolders.add(nextFile);						continue;					}					// walking					if (recursive) {						todoFiles.add(new FilesIterator(nextFile));					}					if (includeDirs) {						if (acceptFile(nextFile)) {							lastFile = nextFile;							return nextFile;						}					}					continue;				}				lastFile = nextFile;				return nextFile;			}			// process folders			File folder;			boolean initialDir = false;			if (todoFolders.isEmpty()) {				if (pathList.isEmpty()) {					// the end					return null;				}				folder = pathList.removeFirst();				rootFile = folder;				rootPath = rootFile.getAbsolutePath();				initialDir = true;			} else {				folder = todoFolders.removeFirst();			}			if ((initialDir) || (recursive)) {				todoFiles.add(new FilesIterator(folder));			}			if ((!initialDir) && (includeDirs)) {				if (acceptFile(folder)) {					lastFile = folder;					return folder;				}			}		}	}
public List<File> findAll() {		List<File> allFiles = new ArrayList<>();		File file;		while ((file = nextFile()) != null) {			allFiles.add(file);		}		return allFiles;	}
protected void init() {		rules.detectMode();		todoFiles = new LinkedList<>();		todoFolders = new LinkedList<>();		if (pathList == null) {			pathList = new LinkedList<>();			return;		}		if (pathListOriginal == null) {			pathListOriginal = (LinkedList<File>) pathList.clone();		}		String[] files = new String[pathList.size()];		int index = 0;		Iterator<File> iterator = pathList.iterator();		while (iterator.hasNext()) {			File file = iterator.next();			if (file.isFile()) {				files[index++] = file.getAbsolutePath();				iterator.remove();			}		}		if (index != 0) {			FilesIterator filesIterator = new FilesIterator(files);			todoFiles.add(filesIterator);		}	}
@Override	public Iterator<File> iterator() {		return new Iterator<File>() {			private File nextFile;			@Override			public boolean hasNext() {				nextFile = nextFile();				return nextFile != null;			}			@Override			public File next() {				if (nextFile == null) {					throw new NoSuchElementException();				}				return nextFile;			}			@Override			public void remove() {				throw new UnsupportedOperationException();			}		};	}
@Override	public byte[] get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getBytes(index);	}
@Override	public void set(final PreparedStatement st, final int index, final byte[] value, final int dbSqlType) throws SQLException {		st.setBytes(index, value);	}
public WiringMode resolveBeanWiringMode(final Class type) {		PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class);		return petiteBean != null ? petiteBean.wiring() : WiringMode.DEFAULT;	}
public Class<? extends Scope> resolveBeanScopeType(final Class type) {		PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class);		return petiteBean != null ? petiteBean.scope() : null;	}
public String resolveBeanName(final Class type, final boolean useLongTypeName) {		PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class);		String name = null;		if (petiteBean != null) {			name = petiteBean.value().trim();		}		if ((name == null) || (name.length() == 0)) {			if (useLongTypeName) {				name = type.getName();			} else {				name = StringUtil.uncapitalize(type.getSimpleName());			}		}		return name;	}
public boolean beanHasAnnotationName(final Class type) {		PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class);		if (petiteBean == null) {			return false;		}		String name = petiteBean.value().trim();		return !name.isEmpty();	}
public PrintWriter getWriter() {		if (outWriter == null) {			if (outStream != null) {				throw new IllegalStateException("Can't call getWriter() after getOutputStream()");			}			bufferedWriter = new FastCharArrayWriter();			outWriter = new PrintWriter(bufferedWriter) {				@Override				public void close() {					// do not close the print writer after rendering					// since it will remove reference to bufferedWriter				}			};		}		return outWriter;	}
public ServletOutputStream getOutputStream() {		if (outStream == null) {			if (outWriter != null) {				throw new IllegalStateException("Can't call getOutputStream() after getWriter()");			}			bufferOutputStream = new FastByteArrayServletOutputStream();			outStream = bufferOutputStream;		}		return outStream;	}
public static Type getType(final Class<?> clazz) {    if (clazz.isPrimitive()) {      if (clazz == Integer.TYPE) {        return INT_TYPE;      } else if (clazz == Void.TYPE) {        return VOID_TYPE;      } else if (clazz == Boolean.TYPE) {        return BOOLEAN_TYPE;      } else if (clazz == Byte.TYPE) {        return BYTE_TYPE;      } else if (clazz == Character.TYPE) {        return CHAR_TYPE;      } else if (clazz == Short.TYPE) {        return SHORT_TYPE;      } else if (clazz == Double.TYPE) {        return DOUBLE_TYPE;      } else if (clazz == Float.TYPE) {        return FLOAT_TYPE;      } else if (clazz == Long.TYPE) {        return LONG_TYPE;      } else {        throw new AssertionError();      }    } else {      return getType(getDescriptor(clazz));    }  }
public static Type getObjectType(final String internalName) {    return new Type(        internalName.charAt(0) == '[' ? ARRAY : INTERNAL, internalName, 0, internalName.length());  }
public static Type getMethodType(final Type returnType, final Type... argumentTypes) {    return getType(getMethodDescriptor(returnType, argumentTypes));  }
public static Type[] getArgumentTypes(final String methodDescriptor) {    // First step: compute the number of argument types in methodDescriptor.    int numArgumentTypes = 0;    // Skip the first character, which is always a '('.    int currentOffset = 1;    // Parse the argument types, one at a each loop iteration.    while (methodDescriptor.charAt(currentOffset) != ')') {      while (methodDescriptor.charAt(currentOffset) == '[') {        currentOffset++;      }      if (methodDescriptor.charAt(currentOffset++) == 'L') {        // Skip the argument descriptor content.        currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;      }      ++numArgumentTypes;    }    // Second step: create a Type instance for each argument type.    Type[] argumentTypes = new Type[numArgumentTypes];    // Skip the first character, which is always a '('.    currentOffset = 1;    // Parse and create the argument types, one at each loop iteration.    int currentArgumentTypeIndex = 0;    while (methodDescriptor.charAt(currentOffset) != ')') {      final int currentArgumentTypeOffset = currentOffset;      while (methodDescriptor.charAt(currentOffset) == '[') {        currentOffset++;      }      if (methodDescriptor.charAt(currentOffset++) == 'L') {        // Skip the argument descriptor content.        currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;      }      argumentTypes[currentArgumentTypeIndex++] =          getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);    }    return argumentTypes;  }
public static Type getReturnType(final String methodDescriptor) {    // Skip the first character, which is always a '('.    int currentOffset = 1;    // Skip the argument types, one at a each loop iteration.    while (methodDescriptor.charAt(currentOffset) != ')') {      while (methodDescriptor.charAt(currentOffset) == '[') {        currentOffset++;      }      if (methodDescriptor.charAt(currentOffset++) == 'L') {        // Skip the argument descriptor content.        currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;      }    }    return getTypeInternal(methodDescriptor, currentOffset + 1, methodDescriptor.length());  }
private static Type getTypeInternal(      final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {    switch (descriptorBuffer.charAt(descriptorBegin)) {      case 'V':        return VOID_TYPE;      case 'Z':        return BOOLEAN_TYPE;      case 'C':        return CHAR_TYPE;      case 'B':        return BYTE_TYPE;      case 'S':        return SHORT_TYPE;      case 'I':        return INT_TYPE;      case 'F':        return FLOAT_TYPE;      case 'J':        return LONG_TYPE;      case 'D':        return DOUBLE_TYPE;      case '[':        return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);      case 'L':        return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);      case '(':        return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);      default:        throw new IllegalArgumentException();    }  }
public String getClassName() {    switch (sort) {      case VOID:        return "void";      case BOOLEAN:        return "boolean";      case CHAR:        return "char";      case BYTE:        return "byte";      case SHORT:        return "short";      case INT:        return "int";      case FLOAT:        return "float";      case LONG:        return "long";      case DOUBLE:        return "double";      case ARRAY:        StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());        for (int i = getDimensions(); i > 0; --i) {          stringBuilder.append("[]");        }        return stringBuilder.toString();      case OBJECT:      case INTERNAL:        return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.');      default:        throw new AssertionError();    }  }
public static String getConstructorDescriptor(final Constructor<?> constructor) {    StringBuilder stringBuilder = new StringBuilder();    stringBuilder.append('(');    Class<?>[] parameters = constructor.getParameterTypes();    for (Class<?> parameter : parameters) {      appendDescriptor(parameter, stringBuilder);    }    return stringBuilder.append(")V").toString();  }
public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {    StringBuilder stringBuilder = new StringBuilder();    stringBuilder.append('(');    for (Type argumentType : argumentTypes) {      argumentType.appendDescriptor(stringBuilder);    }    stringBuilder.append(')');    returnType.appendDescriptor(stringBuilder);    return stringBuilder.toString();  }
public static String getMethodDescriptor(final Method method) {    StringBuilder stringBuilder = new StringBuilder();    stringBuilder.append('(');    Class<?>[] parameters = method.getParameterTypes();    for (Class<?> parameter : parameters) {      appendDescriptor(parameter, stringBuilder);    }    stringBuilder.append(')');    appendDescriptor(method.getReturnType(), stringBuilder);    return stringBuilder.toString();  }
private void appendDescriptor(final StringBuilder stringBuilder) {    if (sort == OBJECT) {      stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);    } else if (sort == INTERNAL) {      stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');    } else {      stringBuilder.append(valueBuffer, valueBegin, valueEnd);    }  }
public int getSize() {    switch (sort) {      case VOID:        return 0;      case BOOLEAN:      case CHAR:      case BYTE:      case SHORT:      case INT:      case FLOAT:      case ARRAY:      case OBJECT:      case INTERNAL:        return 1;      case LONG:      case DOUBLE:        return 2;      default:        throw new AssertionError();    }  }
public static int getArgumentsAndReturnSizes(final String methodDescriptor) {    int argumentsSize = 1;    // Skip the first character, which is always a '('.    int currentOffset = 1;    int currentChar = methodDescriptor.charAt(currentOffset);    // Parse the argument types and compute their size, one at a each loop iteration.    while (currentChar != ')') {      if (currentChar == 'J' || currentChar == 'D') {        currentOffset++;        argumentsSize += 2;      } else {        while (methodDescriptor.charAt(currentOffset) == '[') {          currentOffset++;        }        if (methodDescriptor.charAt(currentOffset++) == 'L') {          // Skip the argument descriptor content.          currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;        }        argumentsSize += 1;      }      currentChar = methodDescriptor.charAt(currentOffset);    }    currentChar = methodDescriptor.charAt(currentOffset + 1);    if (currentChar == 'V') {      return argumentsSize << 2;    } else {      int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1;      return argumentsSize << 2 | returnSize;    }  }
public int getOpcode(final int opcode) {    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {      switch (sort) {        case BOOLEAN:        case BYTE:          return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);        case CHAR:          return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);        case SHORT:          return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);        case INT:          return opcode;        case FLOAT:          return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);        case LONG:          return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);        case DOUBLE:          return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);        case ARRAY:        case OBJECT:        case INTERNAL:          return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);        case METHOD:        case VOID:          throw new UnsupportedOperationException();        default:          throw new AssertionError();      }    } else {      switch (sort) {        case VOID:          if (opcode != Opcodes.IRETURN) {            throw new UnsupportedOperationException();          }          return Opcodes.RETURN;        case BOOLEAN:        case BYTE:        case CHAR:        case SHORT:        case INT:          return opcode;        case FLOAT:          return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);        case LONG:          return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);        case DOUBLE:          return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);        case ARRAY:        case OBJECT:        case INTERNAL:          if (opcode != Opcodes.ILOAD && opcode != Opcodes.ISTORE && opcode != Opcodes.IRETURN) {            throw new UnsupportedOperationException();          }          return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);        case METHOD:          throw new UnsupportedOperationException();        default:          throw new AssertionError();      }    }  }
public void setRollbackOnly(final Throwable th) {		if (!isNoTransaction()) {			if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) {				throw new JtxException("TNo active TX that can be marked as rollback only");			}		}		rollbackCause = th;		status = STATUS_MARKED_ROLLBACK;	}
protected void commitOrRollback(boolean doCommit) {		if (log.isDebugEnabled()) {			if (doCommit) {				log.debug("Commit JTX");			} else {				log.debug("Rollback JTX");			}		}		boolean forcedRollback = false;		if (!isNoTransaction()) {			if (isRollbackOnly()) {				if (doCommit) {					doCommit = false;					forcedRollback = true;				}			} else if (!isActive()) {				if (isCompleted()) {					throw new JtxException("TX is already completed, commit or rollback should be called once per TX");				}				throw new JtxException("No active TX to " + (doCommit ? "commit" : "rollback"));			}		}		if (doCommit) {			commitAllResources();		} else {			rollbackAllResources(forcedRollback);		}	}
protected void commitAllResources() throws JtxException {		status = STATUS_COMMITTING;		Exception lastException = null;		Iterator<JtxResource> it = resources.iterator();		while (it.hasNext()) {			JtxResource resource = it.next();			try {				resource.commitTransaction();				it.remove();			} catch (Exception ex) {				lastException = ex;			}		}		if (lastException != null) {			setRollbackOnly(lastException);			throw new JtxException("Commit failed: one or more TX resources couldn't commit a TX", lastException);		}		txManager.removeTransaction(this);		status = STATUS_COMMITTED;	}
protected void rollbackAllResources(final boolean wasForced) {		status = STATUS_ROLLING_BACK;		Exception lastException = null;		Iterator<JtxResource> it = resources.iterator();		while (it.hasNext()) {			JtxResource resource = it.next();			try {				resource.rollbackTransaction();			} catch (Exception ex) {				lastException = ex;			} finally {				it.remove();			}		}		txManager.removeTransaction(this);		status = STATUS_ROLLEDBACK;		if (lastException != null) {			status = STATUS_UNKNOWN;			throw new JtxException("Rollback failed: one or more TX resources couldn't rollback a TX", lastException);		}		if (wasForced) {			throw new JtxException("TX rolled back because it has been marked as rollback-only", rollbackCause);		}	}
public <E> E requestResource(final Class<E> resourceType) {		if (isCompleted()) {			throw new JtxException("TX is already completed, resource are not available after commit or rollback");		}		if (isRollbackOnly()) {			throw new JtxException("TX is marked as rollback only, resource are not available", rollbackCause);		}		if (!isNoTransaction() && !isActive()) {			throw new JtxException("Resources are not available since TX is not active");		}		checkTimeout();		E resource = lookupResource(resourceType);		if (resource == null) {			int maxResources = txManager.getMaxResourcesPerTransaction();			if ((maxResources != -1) && (resources.size() >= maxResources)) {				throw new JtxException("TX already has attached max. number of resources");			}			JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType);			resource = resourceManager.beginTransaction(mode, isActive());			resources.add(new JtxResource<>(this, resourceManager, resource));		}		return resource;	}
protected <E> E lookupResource(final Class<E> resourceType) {		for (JtxResource jtxResource : resources) {			if (jtxResource.isSameTypeAsResource(resourceType)) {				//noinspection unchecked				return (E) jtxResource.getResource();			}		}		return null;	}
public void pushName(final String name, final boolean withComma) {		pushedName = name;		pushedComma = withComma;		isPushed = true;	}
protected void popName() {		if (isPushed) {			if (pushedComma) {				writeComma();			}			String name = pushedName;			pushedName = null;			isPushed = false;			writeName(name);		}	}
public void writeName(final String name) {		if (name != null) {			writeString(name);		}		else {			write(NULL);		}		write(':');	}
public void writeString(final String value) {		popName();		write(StringPool.QUOTE);		int len = value.length();		for (int i = 0; i < len; i++) {			char c = value.charAt(i);			switch (c) {				case '"':					write("\\\"");					break;				case '\\':					write("\\\\");					break;				case '/':					if (strictStringEncoding) {						write("\\/");					}					else {						write(c);					}					break;				case '\b':					write("\\b");					break;				case '\f':					write("\\f");					break;				case '\n':					write("\\n");					break;				case '\r':					write("\\r");					break;				case '\t':					write("\\t");					break;				default:					if (Character.isISOControl(c)) {						unicode(c);					}					else {						write(c);					}			}		}		write(StringPool.QUOTE);	}
protected void unicode(final char c) {		write("\\u");		int n = c;		for (int i = 0; i < 4; ++i) {			int digit = (n & 0xf000) >> 12;			char hex = CharUtil.int2hex(digit);			write(hex);			n <<= 4;		}	}
public void write(final CharSequence charSequence) {		popName();		try {			out.append(charSequence);		} catch (IOException ioex) {			throw new JsonException(ioex);		}	}
public LagartoDomBuilderConfig setParsingErrorLogLevelName(String logLevel) {		logLevel = logLevel.trim().toUpperCase();		parsingErrorLogLevel = Logger.Level.valueOf(logLevel);		return this;	}
protected static StringBuilder toUppercase(final StringBuilder string) {		final int strLen = string.length();		for (int i = 0; i < strLen; i++) {			char c = string.charAt(i);			char uppercaseChar = Character.toUpperCase(c);			if (c != uppercaseChar) {				string.setCharAt(i, uppercaseChar);			}		}		return string;	}
public boolean isMatchedTag(final Tag tag) {		if (!tag.nameEquals(name)) {			return false;		}		if (id != null) {			CharSequence tagId = tag.getId();			if (tagId == null) {				return false;			}			if (!CharSequenceUtil.equals(id, tagId)) {				return false;			}		}		return true;	}
public void startRegion(final int start, final int tagLen, final int deepLevel) {		this.regionStart = start + tagLen;		this.regionLength = 0;		this.regionTagStart = start;		this.deepLevel = deepLevel;	}
public boolean isInsideOtherTagRegion(final DecoraTag decoraTag) {		return (regionStart > decoraTag.getRegionStart()) && (regionStart < decoraTag.getRegionStart() + decoraTag.getRegionLength());	}
public boolean isContaining(final String include) {		if (value == null) {			return false;		}		if (splits == null) {			splits = StringUtil.splitc(value, ' ');		}		for (String s: splits) {			if (s.equals(include)) {				return true;			}		}		return false;	}
public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) {		PseudoFunction pseudoFunction;		try {			pseudoFunction = ClassUtil.newInstance(pseudoFunctionType);		} catch (Exception ex) {			throw new CSSellyException(ex);		}		PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction);	}
public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) {		PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName);		if (pseudoFunction == null) {			throw new CSSellyException("Unsupported pseudo function: " + pseudoFunctionName);		}		return pseudoFunction;	}
@Override	public boolean accept(final List<Node> currentResults, final Node node, final int index) {		return pseudoFunction.match(currentResults, node, index, parsedExpression);	}
@Override	public void visit(final int version, int access, final String name, final String signature, final String superName, final String[] interfaces) {		wd.init(name, superName, this.suffix, this.reqProxyClassName);		// change access of destination		access &= ~AsmUtil.ACC_ABSTRACT;		// write destination class		final int v = ProxettaAsmUtil.resolveJavaVersion(version);		wd.dest.visit(v, access, wd.thisReference, signature, wd.superName, null);		wd.proxyAspects = new ProxyAspectData[aspects.length];		for (int i = 0; i < aspects.length; i++) {			wd.proxyAspects[i] = new ProxyAspectData(wd, aspects[i], i);		}	}
@Override	public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {		final MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, wd.superReference);		if (msign == null) {			return null;		}		if (msign.isFinal && !wd.allowFinalMethods) {			return null;		}		// destination constructors [A1]		if (name.equals(INIT)) {			MethodVisitor mv = wd.dest.visitMethod(access, name, desc, msign.getAsmMethodSignature(), null);			return new ProxettaCtorBuilder(mv, msign, wd);		}		// ignore destination static block		if (name.equals(CLINIT)) {			return null;		}		return applyProxy(msign);	}
@Override	public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {		AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3]		return new AnnotationVisitorAdapter(destAnn);	}
protected void makeStaticInitBlock() {		if (wd.adviceClinits != null) {			MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_STATIC, CLINIT, DESC_VOID, null, null);			mv.visitCode();			for (String name : wd.adviceClinits) {				mv.visitMethodInsn(					INVOKESTATIC,					wd.thisReference,					name, DESC_VOID,					false);			}			mv.visitInsn(RETURN);			mv.visitMaxs(0, 0);			mv.visitEnd();		}	}
protected void makeProxyConstructor() {		MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL, ProxettaNames.initMethodName, DESC_VOID, null, null);		mv.visitCode();		if (wd.adviceInits != null) {			for (String name : wd.adviceInits) {				mv.visitVarInsn(ALOAD, 0);				mv.visitMethodInsn					(INVOKESPECIAL,						wd.thisReference,						name, DESC_VOID,						false);			}		}		mv.visitInsn(RETURN);		mv.visitMaxs(0, 0);		mv.visitEnd();	}
protected void processSuperMethods() {		for (ClassReader cr : targetClassInfo.superClassReaders) {			cr.accept(new EmptyClassVisitor() {				String declaredClassName;				@Override				public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {					declaredClassName = name;				}				@Override				public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {					if (name.equals(INIT) || name.equals(CLINIT)) {						return null;					}					MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName);					if (msign == null) {						return null;					}					return applyProxy(msign);				}			}, 0);		}	}
protected ProxettaMethodBuilder applyProxy(final MethodSignatureVisitor msign) {		List<ProxyAspectData> aspectList = matchMethodPointcuts(msign);		if (aspectList == null) {			// no pointcuts on this method, return			return null;		}		int access = msign.getAccessFlags();		if ((access & ACC_ABSTRACT) != 0) {			throw new ProxettaException("Unable to process abstract method: " + msign);		}		wd.proxyApplied = true;		return new ProxettaMethodBuilder(msign, wd, aspectList);	}
protected List<ProxyAspectData> matchMethodPointcuts(final MethodSignatureVisitor msign) {		List<ProxyAspectData> aspectList = null;		for (ProxyAspectData aspectData : wd.proxyAspects) {			if (aspectData.apply(msign)) {				if (aspectList == null) {					aspectList = new ArrayList<>(wd.proxyAspects.length);				}				aspectList.add(aspectData);			}		}		return aspectList;	}
public int find(int low, int high) {		while (low <= high) {			int mid = (low + high) >>> 1;			int delta = compare(mid);			if (delta < 0) {				low = mid + 1;			} else if (delta > 0) {				high = mid - 1;			} else {				return mid;			}		}		// not found		return -(low + 1);	}
public int findFirst(int low, int high) {		int ndx = -1;		while (low <= high) {			int mid = (low + high) >>> 1;			int delta = compare(mid);			if (delta < 0) {				low = mid + 1;			} else {				if (delta == 0) {					ndx = mid;				}				high = mid - 1;			}		}		if (ndx == -1) {			return -(low + 1);		}		return ndx;	}
public int findLast(int low, int high) {		int ndx = -1;		while (low <= high) {			int mid = (low + high) >>> 1;			int delta = compare(mid);			if (delta > 0) {				high = mid - 1;			} else {				if (delta == 0) {					ndx = mid;				}				low = mid + 1;			}		}		if (ndx == -1) {			return -(low + 1);		}		return ndx;	}
protected void startSequence(final String value) {		if (prefix == null) {			prefix = new StringBuilder();			prefix.append("\u001B[");		}		else {			prefix.append(StringPool.SEMICOLON);		}		prefix.append(value);	}
public String on(final String string) {		if (!enabled) {			return string;		}		final StringBuilder sb = new StringBuilder();		if (prefix != null) {			sb.append(prefix).append("m");		}		sb.append(string);		if (suffix != null) {			sb.append(suffix).append("m");		}		return sb.toString();	}
@Override  public final void visit(      final int version,      final int access,      final String name,      final String signature,      final String superName,      final String[] interfaces) {    this.version = version;    this.accessFlags = access;    this.thisClass = symbolTable.setMajorVersionAndClassName(version & 0xFFFF, name);    if (signature != null) {      this.signatureIndex = symbolTable.addConstantUtf8(signature);    }    this.superClass = superName == null ? 0 : symbolTable.addConstantClass(superName).index;    if (interfaces != null && interfaces.length > 0) {      interfaceCount = interfaces.length;      this.interfaces = new int[interfaceCount];      for (int i = 0; i < interfaceCount; ++i) {        this.interfaces[i] = symbolTable.addConstantClass(interfaces[i]).index;      }    }    if (compute == MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL && (version & 0xFFFF) >= Opcodes.V1_7) {      compute = MethodWriter.COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES;    }  }
public byte[] toByteArray() throws ClassTooLargeException, MethodTooLargeException {    // First step: compute the size in bytes of the ClassFile structure.    // The magic field uses 4 bytes, 10 mandatory fields (minor_version, major_version,    // constant_pool_count, access_flags, this_class, super_class, interfaces_count, fields_count,    // methods_count and attributes_count) use 2 bytes each, and each interface uses 2 bytes too.    int size = 24 + 2 * interfaceCount;    int fieldsCount = 0;    FieldWriter fieldWriter = firstField;    while (fieldWriter != null) {      ++fieldsCount;      size += fieldWriter.computeFieldInfoSize();      fieldWriter = (FieldWriter) fieldWriter.fv;    }    int methodsCount = 0;    MethodWriter methodWriter = firstMethod;    while (methodWriter != null) {      ++methodsCount;      size += methodWriter.computeMethodInfoSize();      methodWriter = (MethodWriter) methodWriter.mv;    }    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.    int attributesCount = 0;    if (innerClasses != null) {      ++attributesCount;      size += 8 + innerClasses.length;      symbolTable.addConstantUtf8(Constants.INNER_CLASSES);    }    if (enclosingClassIndex != 0) {      ++attributesCount;      size += 10;      symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD);    }    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {      ++attributesCount;      size += 6;      symbolTable.addConstantUtf8(Constants.SYNTHETIC);    }    if (signatureIndex != 0) {      ++attributesCount;      size += 8;      symbolTable.addConstantUtf8(Constants.SIGNATURE);    }    if (sourceFileIndex != 0) {      ++attributesCount;      size += 8;      symbolTable.addConstantUtf8(Constants.SOURCE_FILE);    }    if (debugExtension != null) {      ++attributesCount;      size += 6 + debugExtension.length;      symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION);    }    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {      ++attributesCount;      size += 6;      symbolTable.addConstantUtf8(Constants.DEPRECATED);    }    if (lastRuntimeVisibleAnnotation != null) {      ++attributesCount;      size +=          lastRuntimeVisibleAnnotation.computeAnnotationsSize(              Constants.RUNTIME_VISIBLE_ANNOTATIONS);    }    if (lastRuntimeInvisibleAnnotation != null) {      ++attributesCount;      size +=          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);    }    if (lastRuntimeVisibleTypeAnnotation != null) {      ++attributesCount;      size +=          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);    }    if (lastRuntimeInvisibleTypeAnnotation != null) {      ++attributesCount;      size +=          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);    }    if (symbolTable.computeBootstrapMethodsSize() > 0) {      ++attributesCount;      size += symbolTable.computeBootstrapMethodsSize();    }    if (moduleWriter != null) {      attributesCount += moduleWriter.getAttributeCount();      size += moduleWriter.computeAttributesSize();    }    if (nestHostClassIndex != 0) {      ++attributesCount;      size += 8;      symbolTable.addConstantUtf8(Constants.NEST_HOST);    }    if (nestMemberClasses != null) {      ++attributesCount;      size += 8 + nestMemberClasses.length;      symbolTable.addConstantUtf8(Constants.NEST_MEMBERS);    }    if (firstAttribute != null) {      attributesCount += firstAttribute.getAttributeCount();      size += firstAttribute.computeAttributesSize(symbolTable);    }    // IMPORTANT: this must be the last part of the ClassFile size computation, because the previous    // statements can add attribute names to the constant pool, thereby changing its size!    size += symbolTable.getConstantPoolLength();    int constantPoolCount = symbolTable.getConstantPoolCount();    if (constantPoolCount > 0xFFFF) {      throw new ClassTooLargeException(symbolTable.getClassName(), constantPoolCount);    }    // Second step: allocate a ByteVector of the correct size (in order to avoid any array copy in    // dynamic resizes) and fill it with the ClassFile content.    ByteVector result = new ByteVector(size);    result.putInt(0xCAFEBABE).putInt(version);    symbolTable.putConstantPool(result);    int mask = (version & 0xFFFF) < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;    result.putShort(accessFlags & ~mask).putShort(thisClass).putShort(superClass);    result.putShort(interfaceCount);    for (int i = 0; i < interfaceCount; ++i) {      result.putShort(interfaces[i]);    }    result.putShort(fieldsCount);    fieldWriter = firstField;    while (fieldWriter != null) {      fieldWriter.putFieldInfo(result);      fieldWriter = (FieldWriter) fieldWriter.fv;    }    result.putShort(methodsCount);    boolean hasFrames = false;    boolean hasAsmInstructions = false;    methodWriter = firstMethod;    while (methodWriter != null) {      hasFrames |= methodWriter.hasFrames();      hasAsmInstructions |= methodWriter.hasAsmInstructions();      methodWriter.putMethodInfo(result);      methodWriter = (MethodWriter) methodWriter.mv;    }    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.    result.putShort(attributesCount);    if (innerClasses != null) {      result          .putShort(symbolTable.addConstantUtf8(Constants.INNER_CLASSES))          .putInt(innerClasses.length + 2)          .putShort(numberOfInnerClasses)          .putByteArray(innerClasses.data, 0, innerClasses.length);    }    if (enclosingClassIndex != 0) {      result          .putShort(symbolTable.addConstantUtf8(Constants.ENCLOSING_METHOD))          .putInt(4)          .putShort(enclosingClassIndex)          .putShort(enclosingMethodIndex);    }    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xFFFF) < Opcodes.V1_5) {      result.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);    }    if (signatureIndex != 0) {      result          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))          .putInt(2)          .putShort(signatureIndex);    }    if (sourceFileIndex != 0) {      result          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_FILE))          .putInt(2)          .putShort(sourceFileIndex);    }    if (debugExtension != null) {      int length = debugExtension.length;      result          .putShort(symbolTable.addConstantUtf8(Constants.SOURCE_DEBUG_EXTENSION))          .putInt(length)          .putByteArray(debugExtension.data, 0, length);    }    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {      result.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);    }    if (lastRuntimeVisibleAnnotation != null) {      lastRuntimeVisibleAnnotation.putAnnotations(          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), result);    }    if (lastRuntimeInvisibleAnnotation != null) {      lastRuntimeInvisibleAnnotation.putAnnotations(          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), result);    }    if (lastRuntimeVisibleTypeAnnotation != null) {      lastRuntimeVisibleTypeAnnotation.putAnnotations(          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), result);    }    if (lastRuntimeInvisibleTypeAnnotation != null) {      lastRuntimeInvisibleTypeAnnotation.putAnnotations(          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), result);    }    symbolTable.putBootstrapMethods(result);    if (moduleWriter != null) {      moduleWriter.putAttributes(result);    }    if (nestHostClassIndex != 0) {      result          .putShort(symbolTable.addConstantUtf8(Constants.NEST_HOST))          .putInt(2)          .putShort(nestHostClassIndex);    }    if (nestMemberClasses != null) {      result          .putShort(symbolTable.addConstantUtf8(Constants.NEST_MEMBERS))          .putInt(nestMemberClasses.length + 2)          .putShort(numberOfNestMemberClasses)          .putByteArray(nestMemberClasses.data, 0, nestMemberClasses.length);    }    if (firstAttribute != null) {      firstAttribute.putAttributes(symbolTable, result);    }    // Third step: replace the ASM specific instructions, if any.    if (hasAsmInstructions) {      return replaceAsmInstructions(result.data, hasFrames);    } else {      return result.data;    }  }
private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {    final Attribute[] attributes = getAttributePrototypes();    firstField = null;    lastField = null;    firstMethod = null;    lastMethod = null;    lastRuntimeVisibleAnnotation = null;    lastRuntimeInvisibleAnnotation = null;    lastRuntimeVisibleTypeAnnotation = null;    lastRuntimeInvisibleTypeAnnotation = null;    moduleWriter = null;    nestHostClassIndex = 0;    numberOfNestMemberClasses = 0;    nestMemberClasses = null;    firstAttribute = null;    compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING;    new ClassReader(classFile, 0, /* checkClassVersion = */ false)        .accept(            this,            attributes,            (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS);    return toByteArray();  }
private Attribute[] getAttributePrototypes() {    Attribute.Set attributePrototypes = new Attribute.Set();    attributePrototypes.addAttributes(firstAttribute);    FieldWriter fieldWriter = firstField;    while (fieldWriter != null) {      fieldWriter.collectAttributePrototypes(attributePrototypes);      fieldWriter = (FieldWriter) fieldWriter.fv;    }    MethodWriter methodWriter = firstMethod;    while (methodWriter != null) {      methodWriter.collectAttributePrototypes(attributePrototypes);      methodWriter = (MethodWriter) methodWriter.mv;    }    return attributePrototypes.toArray();  }
public int newHandle(      final int tag,      final String owner,      final String name,      final String descriptor,      final boolean isInterface) {    return symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;  }
public int newConstantDynamic(      final String name,      final String descriptor,      final Handle bootstrapMethodHandle,      final Object... bootstrapMethodArguments) {    return symbolTable.addConstantDynamic(            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)        .index;  }
public int newInvokeDynamic(      final String name,      final String descriptor,      final Handle bootstrapMethodHandle,      final Object... bootstrapMethodArguments) {    return symbolTable.addConstantInvokeDynamic(            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments)        .index;  }
public int newField(final String owner, final String name, final String descriptor) {    return symbolTable.addConstantFieldref(owner, name, descriptor).index;  }
public int newMethod(      final String owner, final String name, final String descriptor, final boolean isInterface) {    return symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;  }
protected String getCommonSuperClass(final String type1, final String type2) {    ClassLoader classLoader = getClassLoader();    Class<?> class1;    try {      class1 = Class.forName(type1.replace('/', '.'), false, classLoader);    } catch (ClassNotFoundException e) {      throw new TypeNotPresentException(type1, e);    }    Class<?> class2;    try {      class2 = Class.forName(type2.replace('/', '.'), false, classLoader);    } catch (ClassNotFoundException e) {      throw new TypeNotPresentException(type2, e);    }    if (class1.isAssignableFrom(class2)) {      return type1;    }    if (class2.isAssignableFrom(class1)) {      return type2;    }    if (class1.isInterface() || class2.isInterface()) {      return "java/lang/Object";    } else {      do {        class1 = class1.getSuperclass();      } while (!class1.isAssignableFrom(class2));      return class1.getName().replace('.', '/');    }  }
public void registerDefaults() {		register(Integer.class, IntegerSqlType.class);		register(int.class, IntegerSqlType.class);		register(MutableInteger.class, IntegerSqlType.class);				register(Float.class, FloatSqlType.class);		register(float.class, FloatSqlType.class);		register(MutableFloat.class, FloatSqlType.class);		register(Double.class, DoubleSqlType.class);		register(double.class, DoubleSqlType.class);		register(MutableDouble.class, DoubleSqlType.class);		register(Byte.class, ByteSqlType.class);		register(byte.class, ByteSqlType.class);		register(MutableByte.class, ByteSqlType.class);		register(Boolean.class, BooleanSqlType.class);		register(boolean.class, BooleanSqlType.class);		register(MutableBoolean.class, BooleanSqlType.class);		register(Long.class, LongSqlType.class);		register(long.class, LongSqlType.class);		register(MutableLong.class, LongSqlType.class);		register(Short.class, ShortSqlType.class);		register(short.class, ShortSqlType.class);		register(MutableShort.class, ShortSqlType.class);		register(Character.class, CharacterSqlType.class);		register(char.class, CharacterSqlType.class);		register(BigDecimal.class, BigDecimalSqlType.class);		register(BigInteger.class, BigIntegerSqlType.class);		register(String.class, StringSqlType.class);		register(LocalDateTime.class, LocalDateTimeSqlType.class);		register(LocalDate.class, LocalDateSqlType.class);		register(LocalTime.class, LocalTimeSqlType.class);		register(Date.class, SqlDateSqlType.class);		register(Timestamp.class, TimestampSqlType.class);		register(Time.class, TimeSqlType.class);		register(java.util.Date.class, DateSqlType.class);		register(JulianDate.class, JulianDateSqlType.class);		register(byte[].class, ByteArraySqlType.class);		register(URL.class, URLSqlType.class);		register(Blob.class, BlobSqlType.class);		register(Clob.class, ClobSqlType.class);		register(Array.class, SqlArraySqlType.class);		register(Ref.class, SqlRefSqlType.class);	}
public void register(final Class type, final Class<? extends SqlType> sqlTypeClass) {		types.put(type, lookupSqlType(sqlTypeClass));	}
public SqlType lookup(final Class clazz) {		SqlType sqlType;		for (Class x = clazz; x != null; x = x.getSuperclass()) {			sqlType = types.get(clazz);			if (sqlType != null) {				return sqlType;			}			Class[] interfaces = x.getInterfaces();			for (Class i : interfaces) {				sqlType = types.get(i);				if (sqlType != null) {					return sqlType;				}			}		}		return null;	}
public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) {		SqlType sqlType = sqlTypes.get(sqlTypeClass);		if (sqlType == null) {			try {				sqlType = ClassUtil.newInstance(sqlTypeClass);			} catch (Exception ex) {				throw new DbSqlException("SQL type not found: " + sqlTypeClass.getSimpleName(), ex);			}			sqlTypes.put(sqlTypeClass, sqlType);		}		return sqlType;	}
public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser) {		return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, null);	}
public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) {		return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword);	}
public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) {		return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword);	}
public int totalThreadTransactions() {		ArrayList<JtxTransaction> txList = txStack.get();		if (txList == null) {			return 0;		}		return txList.size();	}
public int totalThreadTransactionsWithStatus(final JtxStatus status) {		ArrayList<JtxTransaction> txlist = txStack.get();		if (txlist == null) {			return 0;		}		int count = 0;		for (JtxTransaction tx : txlist) {			if (tx.getStatus() == status) {				count++;			}		}		return count;	}
public boolean isAssociatedWithThread(final JtxTransaction tx) {		ArrayList<JtxTransaction> txList = txStack.get();		if (txList == null) {			return false;		}		return txList.contains(tx);	}
protected boolean removeTransaction(final JtxTransaction tx) {		ArrayList<JtxTransaction> txList = txStack.get();		if (txList == null) {			return false;		}		boolean removed = txList.remove(tx);		if (removed) {			totalTransactions--;		}		if (txList.isEmpty()) {			txStack.remove();		}		return removed;	}
public JtxTransaction getTransaction() {		ArrayList<JtxTransaction> txlist = txStack.get();		if (txlist == null) {			return null;		}		if (txlist.isEmpty()) {			return null;		}		return txlist.get(txlist.size() - 1);	// get last	}
protected void associateTransaction(final JtxTransaction tx) {		totalTransactions++;		ArrayList<JtxTransaction> txList = txStack.get();		if (txList == null) {			txList = new ArrayList<>();			txStack.set(txList);		}		txList.add(tx);	// add last	}
protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) {		return new JtxTransaction(this, tm, scope, active);	}
public JtxTransaction requestTransaction(final JtxTransactionMode mode, final Object scope) {		if (log.isDebugEnabled()) {			log.debug("Requesting TX " + mode.toString());		}		JtxTransaction currentTx = getTransaction();		if (!isNewTxScope(currentTx, scope)) {			return currentTx;		}		switch (mode.getPropagationBehavior()) {			case PROPAGATION_REQUIRED: return propRequired(currentTx, mode, scope);			case PROPAGATION_SUPPORTS: return propSupports(currentTx, mode, scope);			case PROPAGATION_MANDATORY: return propMandatory(currentTx, mode, scope);			case PROPAGATION_REQUIRES_NEW: return propRequiresNew(currentTx, mode, scope);			case PROPAGATION_NOT_SUPPORTED: return propNotSupported(currentTx, mode, scope);			case PROPAGATION_NEVER: return propNever(currentTx, mode, scope);		}		throw new JtxException("Invalid TX propagation value: " + mode.getPropagationBehavior().value());	}
protected boolean isNewTxScope(final JtxTransaction currentTx, final Object destScope) {		if (ignoreScope) {			return true;		}		if (currentTx == null) {			return true;		}		if (destScope == null) {			return true;		}		if (currentTx.getScope() == null) {			return true;		}		return !destScope.equals(currentTx.getScope());	}
protected void continueTx(final JtxTransaction sourceTx, final JtxTransactionMode destMode) {		if (!validateExistingTransaction) {			return;		}		JtxTransactionMode sourceMode = sourceTx.getTransactionMode();		JtxIsolationLevel destIsolationLevel = destMode.getIsolationLevel();		if (destIsolationLevel != ISOLATION_DEFAULT) {			JtxIsolationLevel currentIsolationLevel = sourceMode.getIsolationLevel();			if (currentIsolationLevel != destIsolationLevel) {				throw new JtxException("Participating TX specifies isolation level: " + destIsolationLevel +						" which is incompatible with existing TX: " + currentIsolationLevel);			}		}		if ((!destMode.isReadOnly()) && (sourceMode.isReadOnly())) {			throw new JtxException("Participating TX is not marked as read-only, but existing TX is");		}	}
protected JtxTransaction propRequired(JtxTransaction currentTx, final JtxTransactionMode mode, final Object scope) {		if ((currentTx == null) || (currentTx.isNoTransaction())) {			currentTx = createNewTransaction(mode, scope, true);		} else {			continueTx(currentTx, mode);		}		return currentTx;	}
@SuppressWarnings({"UnusedDeclaration"})	protected JtxTransaction propRequiresNew(final JtxTransaction currentTx, final JtxTransactionMode mode, final Object scope) {		return createNewTransaction(mode, scope, true);	}
protected JtxTransaction propSupports(JtxTransaction currentTx, final JtxTransactionMode mode, final Object scope) {		if ((currentTx != null) && (!currentTx.isNoTransaction())) {			continueTx(currentTx, mode);		}		if (currentTx == null) {			currentTx = createNewTransaction(mode, scope, false);		}		return currentTx;	}
@SuppressWarnings({"UnusedDeclaration"})	protected JtxTransaction propMandatory(final JtxTransaction currentTx, final JtxTransactionMode mode, final Object scope) {		if ((currentTx == null) || (currentTx.isNoTransaction())) {			throw new JtxException("No existing TX found for TX marked with propagation 'mandatory'");		}		continueTx(currentTx, mode);		return currentTx;	}
protected JtxTransaction propNotSupported(final JtxTransaction currentTx, final JtxTransactionMode mode, final Object scope) {		if (currentTx == null) {			return createNewTransaction(mode, scope, false);		}		if (currentTx.isNoTransaction()) {			return currentTx;		}		return createNewTransaction(mode, scope, false);	}
protected JtxTransaction propNever(JtxTransaction currentTx, final JtxTransactionMode mode, final Object scope) {		if ((currentTx != null) && (!currentTx.isNoTransaction())) {			throw new JtxException("Existing TX found for TX marked with propagation 'never'");		}		if (currentTx == null) {			currentTx = createNewTransaction(mode, scope, false);		}		return currentTx;	}
public void registerResourceManager(final JtxResourceManager resourceManager) {		if ((oneResourceManager) && (!resourceManagers.isEmpty())) {			throw new JtxException("TX manager allows only one resource manager");		}		this.resourceManagers.put(resourceManager.getResourceType(), resourceManager);	}
protected <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) {		//noinspection unchecked		JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType);		if (resourceManager == null) {			throw new JtxException("No registered resource manager for resource type: " + resourceType.getSimpleName());		}		return resourceManager;	}
public void close() {		this.resourceManagers.forEachValue(resourceManager -> {			try {				resourceManager.close();			} catch (Exception ex) {				// ignore			}		});		resourceManagers.clear();	}
protected C createProxyObject(Class<C> target) {		target = ProxettaUtil.resolveTargetClass(target);		Class proxyClass = cache.get(target);		if (proxyClass == null) {			proxyClass = proxetta.defineProxy(target);			cache.put(target, proxyClass);		}		C proxy;		try {			proxy = (C) ClassUtil.newInstance(proxyClass);		} catch (Exception ex) {			throw new PathrefException(ex);		}		return proxy;	}
protected void append(final String methodName) {		if (path.length() != 0) {			path += StringPool.DOT;		}		if (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) {			path = StringUtil.substring(path, 0, -1);		}		path += methodName;	}
@SuppressWarnings("unchecked")	public <T> T continueWith(final Object currentInstance, final String methodName, final Class<T> target) {		Class currentClass = currentInstance.getClass();		Method method;		try {			method = currentClass.getDeclaredMethod(methodName);		}		catch (NoSuchMethodException e) {			throw new PathrefException("Not a getter: " + methodName, e);		}		if (!ClassUtil.isBeanPropertyGetter(method)) {			throw new PathrefException("Not a getter: " + methodName);		}		String getterName = ClassUtil.getBeanPropertyGetterName(method);		append(getterName);		if (ClassUtil.isTypeOf(target, List.class)) {			final Class componentType =				ClassUtil.getComponentType(method.getGenericReturnType(), currentClass, 0);			if (componentType == null) {				throw new PathrefException("Unknown component name for: " + methodName);			}			return (T) new ArrayList() {				@Override				public Object get(final int index) {					if (index >= 0) {						append("[" + index + "]");					}					return new Pathref<>(componentType, Pathref.this).to();				}			};		}		try {			return new Pathref<>(target, this).to();		}		catch (Exception ex) {			return null;		}	}
@Benchmark    public String encode_Apache_Base64() {        return org.apache.commons.codec.binary.Base64.encodeBase64String(to_be_encoded);    }
public static String alignLeftAndPad(final String text, final int size) {		int textLength = text.length();		if (textLength > size) {			return text.substring(0, size);		}		final StringBuilder sb = new StringBuilder(size);		sb.append(text);		while (textLength++ < size) {			sb.append(' ');		}		return sb.toString();	}
public static String humanReadableByteCount(final long bytes, final boolean useSi) {		final int unit = useSi ? 1000 : 1024;		if (bytes < unit) return bytes + " B";		final int exp = (int) (Math.log(bytes) / Math.log(unit));		final String pre = (useSi ? "kMGTPE" : "KMGTPE").charAt(exp-1) + (useSi ? "" : "i");		return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);	}
public static String toPrettyString(final Object value) {		if (value == null) {			return StringPool.NULL;		}		final Class<?> type = value.getClass();		if (type.isArray()) {			final Class componentType = type.getComponentType();			if (componentType.isPrimitive()) {				final StringBuilder sb = new StringBuilder();				sb.append('[');				if (componentType == int.class) {					sb.append(ArraysUtil.toString((int[]) value));				}				else if (componentType == long.class) {					sb.append(ArraysUtil.toString((long[]) value));				}				else if (componentType == double.class) {					sb.append(ArraysUtil.toString((double[]) value));				}				else if (componentType == float.class) {					sb.append(ArraysUtil.toString((float[]) value));				}				else if (componentType == boolean.class) {					sb.append(ArraysUtil.toString((boolean[]) value));				}				else if (componentType == short.class) {					sb.append(ArraysUtil.toString((short[]) value));				}				else if (componentType == byte.class) {					sb.append(ArraysUtil.toString((byte[]) value));				} else {					throw new IllegalArgumentException();				}				sb.append(']');				return sb.toString();			} else {				final StringBuilder sb = new StringBuilder();				sb.append('[');				final Object[] array = (Object[]) value;				for (int i = 0; i < array.length; i++) {					if (i > 0) {						sb.append(',');					}					sb.append(toPrettyString(array[i]));				}				sb.append(']');				return sb.toString();			}		} else if (value instanceof Iterable) {			final Iterable iterable = (Iterable) value;			final StringBuilder sb = new StringBuilder();			sb.append('{');			int i = 0;			for (final Object o : iterable) {				if (i > 0) {					sb.append(',');				}				sb.append(toPrettyString(o));				i++;			}			sb.append('}');			return sb.toString();		}		return value.toString();	}
public static String fromCamelCase(final String input, final char separator) {		final int length = input.length();		final StringBuilder result = new StringBuilder(length * 2);		int resultLength = 0;		boolean prevTranslated = false;		for (int i = 0; i < length; i++) {			char c = input.charAt(i);			if (i > 0 || c != separator) {// skip first starting separator				if (Character.isUpperCase(c)) {					if (!prevTranslated && resultLength > 0 && result.charAt(resultLength - 1) != separator) {						result.append(separator);						resultLength++;					}					c = Character.toLowerCase(c);					prevTranslated = true;				} else {					prevTranslated = false;				}				result.append(c);				resultLength++;			}		}		return resultLength > 0 ? result.toString() : input;	}
public static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) {		final int length = input.length();		final StringBuilder sb = new StringBuilder(length);		boolean upperCase = firstCharUppercase;		for (int i = 0; i < length; i++) {			final char ch = input.charAt(i);			if (ch == separator) {				upperCase = true;			} else if (upperCase) {				sb.append(Character.toUpperCase(ch));				upperCase = false;			} else {				sb.append(ch);			}		}		return sb.toString();	}
public static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) {		StringBuilder str = new StringBuilder();		int total = src.length();		int from = 0;		while (from < total) {			int to = from + len;			if (to >= total) {				to = total;			} else if (breakOnWhitespace) {				int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from);				if (ndx != -1) {					to = ndx + 1;				}			}			int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to);			if (cutFrom != -1) {				int cutTo = StringUtil.lastIndexOfNonWhitespace(src, to - 1, from) + 1;				str.append(src, cutFrom, cutTo);			}			str.append('\n');			from = to;		}		return str.toString();	}
public static String convertTabsToSpaces(final String line, final int tabWidth) {		int tab_index, tab_size;		int last_tab_index = 0;		int added_chars = 0;		if (tabWidth == 0) {			return StringUtil.remove(line, '\t');		}		StringBuilder result = new StringBuilder();		while ((tab_index = line.indexOf('\t', last_tab_index)) != -1) {			tab_size = tabWidth - ((tab_index + added_chars) % tabWidth);			if (tab_size == 0) {				tab_size = tabWidth;			}			added_chars += tab_size - 1;			result.append(line, last_tab_index, tab_index);			result.append(StringUtil.repeat(' ', tab_size));			last_tab_index = tab_index+1;		}		if (last_tab_index == 0) {			return line;		}		result.append(line.substring(last_tab_index));		return result.toString();	}
public static String escapeJava(final String string) {		int strLen = string.length();		StringBuilder sb = new StringBuilder(strLen);		for (int i = 0; i < strLen; i++) {			char c = string.charAt(i);			switch (c) {				case '\b' : sb.append("\\b"); break;				case '\t' : sb.append("\\t"); break;				case '\n' : sb.append("\\n"); break;				case '\f' : sb.append("\\f"); break;				case '\r' : sb.append("\\r"); break;				case '\"' : sb.append("\\\""); break;				case '\\' : sb.append("\\\\"); break;				default:					if ((c < 32) || (c > 127)) {						String hex = Integer.toHexString(c);						sb.append("\\u");						for (int k = hex.length(); k < 4; k++) {							sb.append('0');						}						sb.append(hex);					} else {						sb.append(c);					}			}		}		return sb.toString();	}
public static String unescapeJava(final String str) {		char[] chars = str.toCharArray();		StringBuilder sb = new StringBuilder(str.length());		for (int i = 0; i < chars.length; i++) {			char c = chars[i];			if (c != '\\') {				sb.append(c);				continue;			}			i++;			c = chars[i];			switch (c) {				case 'b': sb.append('\b'); break;				case 't': sb.append('\t'); break;				case 'n': sb.append('\n'); break;				case 'f': sb.append('\f'); break;				case 'r': sb.append('\r'); break;				case '"': sb.append('\"'); break;				case '\\': sb.append('\\'); break;				case 'u' :					char hex = (char) Integer.parseInt(new String(chars, i + 1, 4), 16);					sb.append(hex);					i += 4;					break;				default:					throw new IllegalArgumentException("Invalid escaping character: " + c);			}		}		return sb.toString();	}
public static TransactionAnnotationValues of(final AnnotationParser annotationParser, final AnnotatedElement annotatedElement) {		if (!annotationParser.hasAnnotationOn(annotatedElement)) {			return null;		}		return new TransactionAnnotationValues(annotationParser.of(annotatedElement));	}
protected Object lookupMixingScopedBean(final BeanDefinition def, final BeanReferences refNames) {		final boolean mixing = petiteConfig.wireScopedProxy || petiteConfig.detectMixedScopes;		Object value = null;		if (mixing) {			final BeanDefinition refBeanDefinition = lookupBeanDefinitions(refNames);			if (refBeanDefinition != null) {				value = scopedProxyManager.lookupValue(PetiteContainer.this, def, refBeanDefinition);			}		}		if (value == null) {			value = PetiteContainer.this.getBean(refNames);		}		return value;	}
@SuppressWarnings({"unchecked"})	public <T> T getBean(final Class<T> type) {		String name = resolveBeanName(type);		return (T) getBean(name);	}
protected Object getBean(final BeanReferences beanReferences) {		final int total = beanReferences.size();		for (int i = 0; i < total; i++) {			String name = beanReferences.name(i);			if (name != null) {				Object bean = getBean(name);				if (bean != null) {					return bean;				}			}		}		return null;	}
public <T> T getBean(final String name) {		// Lookup for registered bean definition.		BeanDefinition def = lookupBeanDefinition(name);		if (def == null) {			// try provider			ProviderDefinition providerDefinition = providers.get(name);			if (providerDefinition != null) {				return (T) invokeProvider(providerDefinition);			}			return null;		}		// Find the bean in its scope		Object bean = def.scopeLookup();		if (bean == null) {			// Create new bean in the scope			initBeanDefinition(def);			final BeanData beanData = new BeanData(this, def);			registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData);			bean = beanData.bean();		}		return (T) bean;	}
protected void initBeanDefinition(final BeanDefinition def) {		// init methods		if (def.initMethods == null) {			def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type);		}		// destroy methods		if (def.destroyMethods == null) {			def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type);		}		// properties		if (def.properties == null) {			def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE);		}		// methods		if (def.methods == null) {			def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type);		}		// ctors		if (def.ctor == null) {			def.ctor = petiteResolvers.resolveCtorInjectionPoint(def.type);		}		// values		if (def.values == null) {			def.values = paramManager.resolveParamInjectionPoints(def.type);		}		// sets		if (def.sets == null) {			def.sets = petiteResolvers.resolveSetInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE);		}		// params		if (def.params == null) {			def.params = paramManager.filterParametersForBeanName(def.name, petiteConfig.getResolveReferenceParameters());		}	}
protected void registerBeanAndWireAndInjectParamsAndInvokeInitMethods(final BeanData beanData) {		initBeanDefinition(beanData.definition());		beanData.scopeRegister();		beanData.invokeInitMethods(InitMethodInvocationStrategy.POST_CONSTRUCT);		beanData.wireBean();		beanData.invokeInitMethods(InitMethodInvocationStrategy.POST_DEFINE);		beanData.injectParams(paramManager, petiteConfig.isImplicitParamInjection());		beanData.invokeInitMethods(InitMethodInvocationStrategy.POST_INITIALIZE);		beanData.invokeConsumerIfRegistered();	}
public void wire(final Object bean, final WiringMode wiringMode) {		final WiringMode finalWiringMode = petiteConfig.resolveWiringMode(wiringMode);		final BeanDefinition def = externalsCache.get(			bean.getClass(), () -> {				final BeanDefinition beanDefinition = createBeandDefinitionForExternalBeans(bean.getClass(), finalWiringMode);				initBeanDefinition(beanDefinition);				return beanDefinition;			});		registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean));	}
public <T> T invokeMethod(final Object bean, final Method method) {		final WiringMode wiringMode = petiteConfig.resolveWiringMode(null);		final BeanDefinition def = externalsCache.get(			bean.getClass(), () -> {				final BeanDefinition beanDefinition = createBeandDefinitionForExternalBeans(bean.getClass(), wiringMode);				initBeanDefinition(beanDefinition);				return beanDefinition;			});		final BeanData beanData = new BeanData(this, def, bean);		for (MethodInjectionPoint methodInjectionPoint : def.methods) {			if (methodInjectionPoint.method.equals(method)) {				return (T) beanData.invokeMethodInjectionPoint(methodInjectionPoint);			}		}		try {			return (T) method.invoke(bean);		} catch (Exception e) {			throw new PetiteException(e);		}	}
@SuppressWarnings({"unchecked"})	public <E> E createBean(final Class<E> type, final WiringMode wiringMode) {		final WiringMode finalWiringMode = petiteConfig.resolveWiringMode(wiringMode);		final BeanDefinition def = externalsCache.get(			type, () -> {				final BeanDefinition beanDefinition = createBeandDefinitionForExternalBeans(type, finalWiringMode);				initBeanDefinition(beanDefinition);				return beanDefinition;			});		final BeanData<E> beanData = new BeanData(this, def);		registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData);		return beanData.bean();	}
protected Object invokeProvider(final ProviderDefinition provider) {		if (provider.method != null) {			final Object bean;			if (provider.beanName != null) {				// instance factory method				bean = getBean(provider.beanName);			} else {				// static factory method				bean = null;			}			try {				return provider.method.invoke(bean);			} catch (Exception ex) {				throw new PetiteException("Invalid provider method: " + provider.method.getName(), ex);			}		}		throw new PetiteException("Invalid provider");	}
public void addBean(final String name, final Object bean, WiringMode wiringMode) {		wiringMode = petiteConfig.resolveWiringMode(wiringMode);		registerPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null);		BeanDefinition def = lookupExistingBeanDefinition(name);		registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean));	}
public void setBeanProperty(final String name, final Object value) {		Object bean = null;		int ndx = name.length();		while (true) {			ndx = name.lastIndexOf('.', ndx);			if (ndx == -1) {				break;			}			String beanName = name.substring(0, ndx);			bean = getBean(beanName);			if (bean != null) {				break;			}			ndx--;		}		if (bean == null) {			throw new PetiteException("Invalid bean property: " + name);		}		try {			BeanUtil.declared.setProperty(bean, name.substring(ndx + 1), value);		} catch (Exception ex) {			throw new PetiteException("Invalid bean property: " + name, ex);		}	}
public Object getBeanProperty(final String name) {		int ndx = name.indexOf('.');		if (ndx == -1) {			throw new PetiteException("Only bean name is specified, missing property name: " + name);		}		String beanName = name.substring(0, ndx);		Object bean = getBean(beanName);		if (bean == null) {			throw new PetiteException("Bean doesn't exist: " + name);		}		try {			return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1));		} catch (Exception ex) {			throw new PetiteException("Invalid bean property: " + name, ex);		}	}
public void shutdown() {		scopes.forEachValue(Scope::shutdown);		externalsCache.clear();		beans.clear();		beansAlt.clear();		scopes.clear();		providers.clear();		beanCollections.clear();	}
@Override	protected Properties createSessionProperties() {		final Properties props = super.createSessionProperties();		props.setProperty(MAIL_TRANSPORT_PROTOCOL, PROTOCOL_SMTP);		props.setProperty(MAIL_HOST, host);		props.setProperty(MAIL_SMTP_HOST, host);		props.setProperty(MAIL_SMTP_PORT, String.valueOf(port));		if (authenticator != null) {			props.setProperty(MAIL_SMTP_AUTH, TRUE);		}		if (timeout > 0) {			final String timeoutValue = String.valueOf(timeout);			props.put(MAIL_SMTP_CONNECTIONTIMEOUT, timeoutValue);			props.put(MAIL_SMTP_TIMEOUT, timeoutValue);			props.put(MAIL_SMTP_WRITETIMEOUT, timeoutValue);		}		return props;	}
@Override	public SendMailSession createSession() {		final Session session = Session.getInstance(createSessionProperties(), authenticator);		final Transport mailTransport;		try {			mailTransport = getTransport(session);		} catch (final NoSuchProviderException nspex) {			throw new MailException(nspex);		}		return new SendMailSession(session, mailTransport);	}
@Override	public void start() {		initLogger();		final String resourceName = StringUtil.replaceChar(JoyPaths.class.getName(), '.', '/') + ".class";		URL url = ClassLoaderUtil.getResourceUrl(resourceName);		if (url == null) {			throw new JoyException("Failed to resolve app dir, missing: " + resourceName);		}		final String protocol = url.getProtocol();		if (!protocol.equals("file")) {			try {				url = new URL(url.getFile());			} catch (MalformedURLException ignore) {			}		}		appDir = url.getFile();		final int ndx = appDir.indexOf("WEB-INF");		appDir = (ndx > 0) ? appDir.substring(0, ndx) : SystemUtil.info().getWorkingDir();		System.setProperty(APP_DIR, appDir);		log.info("Application folder: " + appDir);	}
private java.util.logging.Level jodd2jdk(final Level level) {		switch (level) {			case TRACE: return java.util.logging.Level.FINER;			case DEBUG: return java.util.logging.Level.FINE;			case INFO:	return java.util.logging.Level.INFO;			case WARN:	return java.util.logging.Level.WARNING;			case ERROR:	return java.util.logging.Level.SEVERE;			default:				throw new IllegalArgumentException();		}	}
@Override	public Double get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return Double.valueOf(rs.getDouble(index));	}
@Override	public void set(final PreparedStatement st, final int index, final Double value, final int dbSqlType) throws SQLException {		st.setDouble(index, value.doubleValue());	}
public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor) {		Class[] paramTypes;		Class declaringClass;		String name;		if (methodOrCtor instanceof Method) {			Method method = (Method) methodOrCtor;			paramTypes = method.getParameterTypes();			name = method.getName();			declaringClass = method.getDeclaringClass();		} else {			Constructor constructor = (Constructor) methodOrCtor;			paramTypes = constructor.getParameterTypes();			declaringClass = constructor.getDeclaringClass();			name = CTOR_METHOD;		}		if (paramTypes.length == 0) {			return MethodParameter.EMPTY_ARRAY;		}		InputStream stream;		try {			stream = ClassLoaderUtil.getClassAsStream(declaringClass);		} catch (IOException ioex) {			throw new ParamoException("Failed to read class bytes: " + declaringClass.getName(), ioex);		}		if (stream == null) {			throw new ParamoException("Class not found: " + declaringClass);		}		try {			ClassReader reader = new ClassReader(stream);			MethodFinder visitor = new MethodFinder(declaringClass, name, paramTypes);			reader.accept(visitor, 0);			return visitor.getResolvedParameters();		}		catch (IOException ioex) {			throw new ParamoException(ioex);		}		finally {			StreamUtil.close(stream);		}	}
@Override	public int doAfterBody() throws JspException {		BodyContent body = getBodyContent();		JspWriter out = body.getEnclosingWriter();		String bodytext = populateForm(body.getString(), name -> value(name, pageContext));		try {			out.print(bodytext);		} catch (IOException ioex) {			throw new JspException(ioex);		}		return SKIP_BODY;	}
public String getValue(final String... profiles) {		if (hasMacro) {			return propsData.resolveMacros(value, profiles);		}		return value;	}
@Override	public void start() {		log.debug("DomTree builder started");		if (rootNode == null) {			rootNode = new Document(domBuilder.config);		}		parentNode = rootNode;		enabled = true;		if (domBuilder.config.isEnabledVoidTags()) {			htmlVoidRules = new HtmlVoidRules();		}	}
@Override	public void end() {		if (parentNode != rootNode) {			Node thisNode = parentNode;			while (thisNode != rootNode) {				if (domBuilder.config.isImpliedEndTags()) {					if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) {						thisNode = thisNode.getParentNode();						continue;					}				}				error("Unclosed tag closed: <" + thisNode.getNodeName() + ">");				thisNode = thisNode.getParentNode();			}		}		// remove whitespaces		if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) {			removeLastChildNodeIfEmptyText(parentNode, true);		}		// foster		if (domBuilder.config.isUseFosterRules()) {			HtmlFosterRules fosterRules = new HtmlFosterRules();			fosterRules.fixFosterElements(rootNode);		}		// elapsed		rootNode.end();		if (log.isDebugEnabled()) {			log.debug("LagartoDom tree created in " + rootNode.getElapsedTime() + " ms");		}	}
protected Element createElementNode(final Tag tag) {		boolean hasVoidTags = htmlVoidRules != null;		boolean isVoid = false;		boolean selfClosed = false;		if (hasVoidTags) {			isVoid = htmlVoidRules.isVoidTag(tag.getName());			// HTML and XHTML			if (isVoid) {				// it's void tag, lookup the flag				selfClosed = domBuilder.config.isSelfCloseVoidTags();			}		} else {			// XML, no voids, lookup the flag			selfClosed = domBuilder.config.isSelfCloseVoidTags();		}		return new Element(rootNode, tag, isVoid, selfClosed);	}
@Override	public void tag(final Tag tag) {		if (!enabled) {			return;		}		TagType tagType = tag.getType();		Element node;		switch (tagType) {			case START:				if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) {					removeLastChildNodeIfEmptyText(parentNode, false);				}				node = createElementNode(tag);				if (domBuilder.config.isImpliedEndTags()) {					while (true) {						String parentNodeName = parentNode.getNodeName();						if (!implRules.implicitlyCloseParentTagOnNewTag(parentNodeName, node.getNodeName())) {							break;						}						parentNode = parentNode.getParentNode();						if (log.isDebugEnabled()) {							log.debug("Implicitly closed tag <" + node.getNodeName() + "> ");						}					}				}				parentNode.addChild(node);				if (!node.isVoidElement()) {					parentNode = node;				}				break;			case END:				if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) {					removeLastChildNodeIfEmptyText(parentNode, true);				}				String tagName = tag.getName().toString();				Node matchingParent = findMatchingParentOpenTag(tagName);				if (matchingParent == parentNode) {		// regular situation					parentNode = parentNode.getParentNode();					break;				}				if (matchingParent == null) {			// matching open tag not found, remove it					error("Orphan closed tag ignored: </" + tagName + "> " + tag.getTagPosition());					break;				}				// try to close it implicitly				if (domBuilder.config.isImpliedEndTags()) {					boolean fixed = false;					while (implRules.implicitlyCloseParentTagOnTagEnd(parentNode.getNodeName(), tagName)) {						parentNode = parentNode.getParentNode();						if (log.isDebugEnabled()) {							log.debug("Implicitly closed tag <" + tagName + ">");						}						if (parentNode == matchingParent) {							parentNode = matchingParent.parentNode;							fixed = true;							break;						}					}					if (fixed) {						break;					}				}				// matching tag found, but it is not a regular situation				// therefore close all unclosed tags in between				fixUnclosedTagsUpToMatchingParent(tag, matchingParent);				break;			case SELF_CLOSING:				if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) {					removeLastChildNodeIfEmptyText(parentNode, false);				}				node = createElementNode(tag);				parentNode.addChild(node);				break;		}	}
protected void removeLastChildNodeIfEmptyText(final Node parentNode, final boolean closedTag) {		if (parentNode == null) {			return;		}		Node lastChild = parentNode.getLastChild();		if (lastChild == null) {			return;		}				if (lastChild.getNodeType() != Node.NodeType.TEXT) {			return;		}		if (closedTag) {			if (parentNode.getChildNodesCount() == 1) {				return;			}		}		Text text = (Text) lastChild;		if (text.isBlank()) {			lastChild.detachFromParent();		}	}
protected Node findMatchingParentOpenTag(String tagName) {		Node parent = parentNode;				if (!rootNode.config.isCaseSensitive()) {			tagName = tagName.toLowerCase();		}				while (parent != null) {			String parentNodeName = parent.getNodeName();			if (parentNodeName != null) {				if (!rootNode.config.isCaseSensitive()) {					parentNodeName = parentNodeName.toLowerCase();				}			}						if (tagName.equals(parentNodeName)) {				return parent;			}			parent = parent.getParentNode();		}		return null;	}
protected void fixUnclosedTagsUpToMatchingParent(final Tag tag, final Node matchingParent) {		if (domBuilder.config.isUnclosedTagAsOrphanCheck()) {			Node thisNode = parentNode;			if (!CharSequenceUtil.equalsIgnoreCase(tag.getName(), "table")) {				// check if there is table or list between this node				// and matching parent				while (thisNode != matchingParent) {					String thisNodeName = thisNode.getNodeName().toLowerCase();					if (thisNodeName.equals("table") || thisNodeName.equals("ul") || thisNodeName.equals("ol")) {						String positionString = tag.getPosition();						if (positionString == null) {							positionString = StringPool.EMPTY;						}						error("Orphan closed tag ignored: </" + tag.getName() + "> " + positionString);						return;					}					thisNode = thisNode.getParentNode();				}			}		}		while (true) {			if (parentNode == matchingParent) {				parentNode = parentNode.getParentNode();				break;			}			Node parentParentNode = parentNode.getParentNode();			if (domBuilder.config.isImpliedEndTags()) {				if (implRules.implicitlyCloseParentTagOnNewTag(						parentParentNode.getNodeName(), parentNode.getNodeName())) {					// break the tree: detach this node and append it after parent					parentNode.detachFromParent();					parentParentNode.getParentNode().addChild(parentNode);				}			}			// debug message			error("Unclosed tag closed: <" + parentNode.getNodeName() + ">");			// continue looping			parentNode = parentParentNode;		}	}
@Override	public void script(final Tag tag, final CharSequence body) {		if (!enabled) {			return;		}		Element node = createElementNode(tag);		parentNode.addChild(node);		if (body.length() != 0) {			Node text = new Text(rootNode, body.toString());			node.addChild(text);		}	}
@Override	public void error(final String message) {		rootNode.addError(message);		log.log(domBuilder.config.getParsingErrorLogLevel(), message);	}
protected int getArgumentIndex() {		if (!isPrevious) {			throw new ProxettaException("Unexpected previous instruction type used for setting argument index");		}		int argIndex;		switch (opcode) {			case ICONST_0: argIndex = 0; break;			case ICONST_1: argIndex = 1; break;			case ICONST_2: argIndex = 2; break;			case ICONST_3: argIndex = 3; break;			case ICONST_4: argIndex = 4; break;			case ICONST_5: argIndex = 5; break;			case BIPUSH:			case SIPUSH:				argIndex = operand; break;			default:				throw new ProxettaException("Unexpected previous instruction used for setting argument index");		}		return argIndex;	}
@Override	public void visitInsn(final int opcode) {		this.opcode = opcode;		isPrevious = true;		traceNext = false;		super.visitInsn(opcode);	}
public static void argumentsCount(final MethodVisitor mv, final MethodInfo methodInfo) {		int argsCount = methodInfo.getArgumentsCount();		pushInt(mv, argsCount);	}
public static void argumentType(final MethodVisitor mv, final MethodInfo methodInfo, final int argIndex) {		checkArgumentIndex(methodInfo, argIndex);		mv.visitInsn(POP);		loadMethodArgumentClass(mv, methodInfo, argIndex);	}
public static void argument(final MethodVisitor mv, final MethodInfo methodInfo, final int argIndex) {		checkArgumentIndex(methodInfo, argIndex);		mv.visitInsn(POP);		loadMethodArgumentAsObject(mv, methodInfo, argIndex);	}
public static void createArgumentsArray(final MethodVisitor mv, final MethodInfo methodInfo) {		int argsCount = methodInfo.getArgumentsCount();		pushInt(mv, argsCount);		mv.visitTypeInsn(ANEWARRAY, AsmUtil.SIGNATURE_JAVA_LANG_OBJECT);		for (int i = 0; i < argsCount; i++) {			mv.visitInsn(DUP);			pushInt(mv, i);			loadMethodArgumentAsObject(mv, methodInfo, i + 1);			mv.visitInsn(AASTORE);		}	}
public static void createArgumentsClassArray(final MethodVisitor mv, final MethodInfo methodInfo) {		int argsCount = methodInfo.getArgumentsCount();		pushInt(mv, argsCount);		mv.visitTypeInsn(ANEWARRAY, AsmUtil.SIGNATURE_JAVA_LANG_CLASS);		for (int i = 0; i < argsCount; i++) {			mv.visitInsn(DUP);			pushInt(mv, i);			loadMethodArgumentClass(mv, methodInfo, i + 1);			mv.visitInsn(AASTORE);		}	}
public static void returnType(final MethodVisitor mv, final MethodInfo methodInfo) {		ProxettaAsmUtil.loadClass(mv, methodInfo.getReturnType().getOpcode(), methodInfo.getReturnType().getName());	}
public static void targetClass(final MethodVisitor mv, final MethodInfo methodInfo) {		ClassInfo classInfo = methodInfo.getClassInfo();		mv.visitLdcInsn(Type.getType('L' + classInfo.getReference() + ';'));	}
public static void info(final MethodVisitor mv, final MethodInfo methodInfo, final int argsOff) {		mv.visitTypeInsn(Opcodes.NEW, PROXY_TARGET_INFO);		mv.visitInsn(DUP);		mv.visitMethodInsn(Opcodes.INVOKESPECIAL, PROXY_TARGET_INFO, "<init>", "()V", false);//		int argsOff = methodInfo.getAllArgumentsSize();//		argsOff++;		mv.visitVarInsn(Opcodes.ASTORE, argsOff);		// argument count		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		argumentsCount(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "argumentCount", "I");		// arguments class		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		createArgumentsClassArray(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "argumentsClasses", "[Ljava/lang/Class;");		// arguments		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		createArgumentsArray(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "arguments", "[Ljava/lang/Object;");		// return type		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		returnType(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "returnType", AsmUtil.L_SIGNATURE_JAVA_LANG_CLASS);		// target method name		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		targetMethodName(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "targetMethodName", AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);		// target method name		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		targetMethodDescription(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "targetMethodDescription", AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);		// target method name		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		targetMethodSignature(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "targetMethodSignature", AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);		// target class		mv.visitVarInsn(Opcodes.ALOAD, argsOff);		targetClass(mv, methodInfo);		mv.visitFieldInsn(Opcodes.PUTFIELD, PROXY_TARGET_INFO, "targetClass", AsmUtil.L_SIGNATURE_JAVA_LANG_CLASS);		// the end		mv.visitVarInsn(Opcodes.ALOAD, argsOff);	}
public static void targetMethodAnnotation(final MethodVisitor mv, final MethodInfo methodInfo, final String[] args) {		AnnotationInfo[] anns = methodInfo.getAnnotations();		if (anns != null) {			targetAnnotation(mv, anns, args);		}	}
public static void targetClassAnnotation(final MethodVisitor mv, final ClassInfo classInfo, final String[] args) {		AnnotationInfo[] anns = classInfo.getAnnotations();		if (anns != null) {			targetAnnotation(mv, anns, args);		} else {			mv.visitInsn(Opcodes.ACONST_NULL);		}	}
public String getQueryString() {		if (sqlTemplate == null) {			return toString();		}		if (parameterValues == null) {			return sqlTemplate;		}		final StringBuilder sb = new StringBuilder();		int qMarkCount = 0;		final StringTokenizer tok = new StringTokenizer(sqlTemplate + ' ', "?");		while (tok.hasMoreTokens()) {			final String oneChunk = tok.nextToken();			sb.append(oneChunk);			try {				Object value = null;				if (parameterValues.size() > 1 + qMarkCount) {					value = parameterValues.get(1 + qMarkCount);					qMarkCount++;				} else {					if (!tok.hasMoreTokens()) {						value = "";					}				}				if (value == null) {					value = "?";				}				sb.append(value);			} catch (Throwable th) {				sb.append("--- Building query failed: ").append(th.toString());			}		}		return sb.toString().trim();	}
protected void saveQueryParamValue(final int position, final Object obj) {		final String strValue;		if (obj instanceof String || obj instanceof Date) {			strValue = "'" + obj + '\''; // if we have a String or Date, include '' in the saved value		} else if (obj instanceof LocalDateTime || obj instanceof LocalDate || obj instanceof LocalTime) {			strValue = "'" + Converter.get().toString(obj) + '\''; // time as string with '		} else if (obj == null) {			strValue = "<null>"; // convert null to the string null		} else {			strValue = Converter.get().toString(obj); // all other objects (includes all Numbers, arrays, etc)		}		// if we are setting a position larger than current size of parameterValues,		// first make it larger		if (parameterValues == null) {			parameterValues = new ArrayList<>();		}		while (position >= parameterValues.size()) {			parameterValues.add(null);		}		parameterValues.set(position, strValue);	}
protected String getActionClassName(final Object action) {		Class clazz = action.getClass();		clazz = ProxettaUtil.resolveTargetClass(clazz);		return clazz.getName();	}
protected int calculateTo(final int from, final int count, final int size) {		int to = size;		if (count != -1) {			to = from + count;			if (to > size) {				to = size;			}		}		return to;	}
protected void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException {		JspFragment body = getJspBody();		Iterator iter = collection.iterator();		int i = 0;		int to = calculateTo(from, count, collection.size());		while (i < to) {			Object item = iter.next();			if (i >= from) {				if (status != null) {					iteratorStatus.next(!iter.hasNext());				}				TagUtil.setScopeAttribute(var, item, scope, pageContext);				TagUtil.invokeBody(body);			}			i++;		}	}
protected void iterateArray(final Object[] array, final int from, final int count, final PageContext pageContext) throws JspException {		JspFragment body = getJspBody();		int len = array.length;		int to = calculateTo(from, count, len);		int last = to - 1;		for (int i = from; i < to; i++) {			Object item = array[i];			if (status != null) {				iteratorStatus.next(i == last);			}			TagUtil.setScopeAttribute(var, item, scope, pageContext);			TagUtil.invokeBody(body);		}	}
public Object[] join(final Object[] data, final String[] hints) {		if (hints == null) {			return data;		}		// build context		Map<String, Object> context = new HashMap<>(hints.length);		for (int i = 0; i < hints.length; i++) {			hints[i] = hints[i].trim();			String hint = hints[i];			if (hint.indexOf('.') == -1) {				context.put(hint, data[i]);			}		}		// no joining hints found		if (context.size() == data.length) {			return data;		}		// joining		Object[] result = new Object[context.size()];		int count = 0;		for (int i = 0; i < hints.length; i++) {			String hint = hints[i];			int ndx = hint.indexOf('.');			if (ndx != -1) {				String key = hint.substring(0, ndx);				Object value = context.get(key);				if (value == null) {					throw new DbOomException("Hint value missing: " + key);				}				// don't merge nulls				if (data[i] == null) {					continue;				}				String hintPropertyName = hint.substring(ndx + 1);				Class hintPropertyType = BeanUtil.pojo.getPropertyType(value, hintPropertyName);				if (hintPropertyType != null) {					ClassDescriptor cd = ClassIntrospector.get().lookup(hintPropertyType);					if (cd.isCollection()) {						// add element to collection						try {							Collection collection = BeanUtil.declared.getProperty(value, hintPropertyName);							if (collection == null) {								collection = (Collection) ClassUtil.newInstance(hintPropertyType);								BeanUtil.declaredSilent.setProperty(value, hintPropertyName, collection);							}							collection.add(data[i]);						} catch (Exception ex) {							throw new DbOomException(ex);						}					} else if (cd.isArray()) {						// add element to array						try {							Object[] array = BeanUtil.declared.getProperty(value, hintPropertyName);							if (array == null) {								array = (Object[]) Array.newInstance(hintPropertyType.getComponentType(), 1);								BeanUtil.declaredSilent.setProperty(value, hintPropertyName, array);								array[0] = data[i];							} else {								Object[] newArray = ArraysUtil.append(array, data[i]);								if (newArray != array) {									BeanUtil.declaredSilent.setProperty(value, hintPropertyName, newArray);								}							}						} catch (Exception ex) {							throw new DbOomException(ex);						}					} else {						// set value						BeanUtil.declaredSilent.setProperty(value, hintPropertyName, data[i]);					}				}				else {					// special case - the property probably contains the collection in the way					int lastNdx = hintPropertyName.lastIndexOf('.');					String name = hintPropertyName.substring(0, lastNdx);					Object target = resolveValueInSpecialCase(value, name);					if (target != null) {						String targetSimpleName = hintPropertyName.substring(lastNdx + 1);						BeanUtil.declaredForcedSilent.setProperty(target, targetSimpleName, data[i]);					}				}			} else {				result[count] = data[i];				count++;			}		}		return result;	}
public static String replace(final String s, final String sub, final String with) {		if (sub.isEmpty()) {			return s;		}		int c = 0;		int i = s.indexOf(sub, c);		if (i == -1) {			return s;		}		int length = s.length();		StringBuilder sb = new StringBuilder(length + with.length());		do {			sb.append(s, c, i);			sb.append(with);			c = i + sub.length();		} while ((i = s.indexOf(sub, c)) != -1);		if (c < length) {			sb.append(s, c, length);		}		return sb.toString();	}
public static String replaceChar(final String s, final char sub, final char with) {		int startIndex = s.indexOf(sub);		if (startIndex == -1) {			return s;		}		char[] str = s.toCharArray();		for (int i = startIndex; i < str.length; i++) {			if (str[i] == sub) {				str[i] = with;			}		}		return new String(str);	}
public static String replaceChars(final String s, final char[] sub, final char[] with) {		char[] str = s.toCharArray();		for (int i = 0; i < str.length; i++) {			char c = str[i];			for (int j = 0; j < sub.length; j++) {			    if (c == sub[j]) {					str[i] = with[j];					break;				}			}		}		return new String(str);	}
public static String replaceFirst(final String s, final String sub, final String with) {		int i = s.indexOf(sub);		if (i == -1) {			return s;		}		return s.substring(0, i) + with + s.substring(i + sub.length());	}
public static String replaceFirst(final String s, final char sub, final char with) {		int index = s.indexOf(sub);		if (index == -1) {			return s;		}		char[] str = s.toCharArray();		str[index] = with;		return new String(str);	}
public static String replaceLast(final String s, final String sub, final String with) {		int i = s.lastIndexOf(sub);		if (i == -1) {			return s;		}		return s.substring(0, i) + with + s.substring(i + sub.length());	}
public static String replaceLast(final String s, final char sub, final char with) {		int index = s.lastIndexOf(sub);		if (index == -1) {			return s;		}		char[] str = s.toCharArray();		str[index] = with;		return new String(str);	}
public static String remove(final String s, final String sub) {		int c = 0;		int sublen = sub.length();		if (sublen == 0) {			return s;		}		int i = s.indexOf(sub, c);		if (i == -1) {			return s;		}		StringBuilder sb = new StringBuilder(s.length());		do {			 sb.append(s, c, i);			 c = i + sublen;		 } while ((i = s.indexOf(sub, c)) != -1);		 if (c < s.length()) {			 sb.append(s, c, s.length());		 }		 return sb.toString();	}
public static String remove(final String string, final char ch) {		int stringLen = string.length();		char[] result = new char[stringLen];		int offset = 0;		for (int i = 0; i < stringLen; i++) {			char c = string.charAt(i);			if (c == ch) {				continue;			}			result[offset] = c;			offset++;		}		if (offset == stringLen) {			return string;	// no changes		}		return new String(result, 0, offset);	}
public static boolean isAllEmpty(final String... strings) {		for (String string : strings) {			if (!isEmpty(string)) {				return false;			}		}		return true;	}
public static boolean isAllBlank(final String... strings) {		for (String string : strings) {			if (!isBlank(string)) {				return false;			}		}		return true;	}
public static boolean containsOnlyWhitespaces(final CharSequence string) {		int size = string.length();		for (int i = 0; i < size; i++) {			char c = string.charAt(i);			if (!CharUtil.isWhitespace(c)) {				return false;			}		}		return true;	}
public static boolean containsOnlyDigits(final CharSequence string) {		int size = string.length();		for (int i = 0; i < size; i++) {			char c = string.charAt(i);			if (!CharUtil.isDigit(c)) {				return false;			}		}		return true;	}
public static String[] toStringArray(final Object value) {		if (value == null) {			return new String[0];		}		Class<?> type = value.getClass();		if (!type.isArray()) {			return new String[] {value.toString()};		}		Class componentType = type.getComponentType();		if (componentType.isPrimitive()) {			if (componentType == int.class) {				return ArraysUtil.toStringArray((int[]) value);			}			else if (componentType == long.class) {				return ArraysUtil.toStringArray((long[]) value);			}			else if (componentType == double.class) {				return ArraysUtil.toStringArray((double[]) value);			}			else if (componentType == float.class) {				return ArraysUtil.toStringArray((float[]) value);			}			else if (componentType == boolean.class) {				return ArraysUtil.toStringArray((boolean[]) value);			}			else if (componentType == short.class) {				return ArraysUtil.toStringArray((short[]) value);			}			else if (componentType == byte.class) {				return ArraysUtil.toStringArray((byte[]) value);			}			else {				throw new IllegalArgumentException();			}		}		else {			return ArraysUtil.toStringArray((Object[]) value);		}	}
private static String changeFirstCharacterCase(final boolean capitalize, final String string) {		int strLen = string.length();		if (strLen == 0) {			return string;		}		char ch = string.charAt(0);		char modifiedCh;		if (capitalize) {			modifiedCh = Character.toUpperCase(ch);		} else {			modifiedCh = Character.toLowerCase(ch);		}		if (modifiedCh == ch) {			// no change, return unchanged string			return string;		}		char[] chars = string.toCharArray();		chars[0] = modifiedCh;		return new String(chars);	}
public static String title(final String string) {		char[] chars = string.toCharArray();				boolean wasWhitespace = true;				for (int i = 0; i < chars.length; i++) {			char c = chars[i];						if (CharUtil.isWhitespace(c)) {				wasWhitespace = true;			} else {				if (wasWhitespace) {					chars[i] = Character.toUpperCase(c);				} else {					chars[i] = Character.toLowerCase(c);				}				wasWhitespace = false;			}		}				return new String(chars);	}
public static String substring(final String string, int fromIndex, int toIndex) {		int len = string.length();		if (fromIndex < 0) {			fromIndex = len + fromIndex;			if (toIndex == 0) {				toIndex = len;			}		}		if (toIndex < 0) {			toIndex = len + toIndex;		}		// safe net		if (fromIndex < 0) {			fromIndex = 0;		}		if (toIndex > len) {			toIndex = len;		}		if (fromIndex >= toIndex) {			return StringPool.EMPTY;		}		return string.substring(fromIndex, toIndex);	}
public static boolean isSubstringAt(final String string, final String substring, final int offset) {		int len = substring.length();		int max = offset + len;		if (max > string.length()) {			return false;		}		int ndx = 0;		for (int i = offset; i < max; i++, ndx++) {			if (string.charAt(i) != substring.charAt(ndx)) {				return false;			}		}		return true;	}
public static String[] split(final String src, final String delimiter) {		int maxparts = (src.length() / delimiter.length()) + 2;		// one more for the last		int[] positions = new int[maxparts];		int dellen = delimiter.length();		int i, j = 0;		int count = 0;		positions[0] = - dellen;		while ((i = src.indexOf(delimiter, j)) != -1) {			count++;			positions[count] = i;			j = i + dellen;		}		count++;		positions[count] = src.length();		String[] result = new String[count];		for (i = 0; i < count; i++) {			result[i] = src.substring(positions[i] + dellen, positions[i + 1]);		}		return result;	}
public static String[] splitc(final String src, final String d) {		if ((d.length() == 0) || (src.length() == 0)) {			return new String[] {src};		}		return splitc(src, d.toCharArray());	}
public static String compressChars(final String s, final char c) {		int len = s.length();		StringBuilder sb = new StringBuilder(len);		boolean wasChar = false;		for (int i = 0; i < len; i++) {			char c1 = s.charAt(i);			if (c1 == c) {				if (wasChar) {					continue;				}				wasChar = true;			} else {				wasChar = false;			}			sb.append(c1);		}		if (sb.length() == len) {			return s;		}		return sb.toString();	}
public static int indexOf(final String src, final char c, int startIndex, int endIndex) {		if (startIndex < 0) {			startIndex = 0;		}		int srclen = src.length();		if (endIndex > srclen) {			endIndex = srclen;		}		for (int i = startIndex; i < endIndex; i++) {			if (src.charAt(i) == c) {				return i;			}		}		return -1;	}
public static int indexOfIgnoreCase(final String src, char c, int startIndex, int endIndex) {		if (startIndex < 0) {			startIndex = 0;		}		int srclen = src.length();		if (endIndex > srclen) {			endIndex = srclen;		}		c = Character.toLowerCase(c);		for (int i = startIndex; i < endIndex; i++) {			if (Character.toLowerCase(src.charAt(i)) == c) {				return i;			}		}		return -1;	}
public static int indexOfIgnoreCase(final String src, final String subS) {		return indexOfIgnoreCase(src, subS, 0, src.length());	}
public static int lastIndexOfIgnoreCase(final String s, final String subS) {		return lastIndexOfIgnoreCase(s, subS, s.length(), 0);	}
public static int lastIndexOfIgnoreCase(final String src, final String subS, final int startIndex) {		return lastIndexOfIgnoreCase(src, subS, startIndex, 0);	}
public static int lastIndexOf(final String src, final String sub, int startIndex, int endIndex) {		int sublen = sub.length();		int srclen = src.length();		if (sublen == 0) {			return startIndex > srclen ? srclen : (startIndex < -1 ? -1 : startIndex);		}		int total = srclen - sublen;		if (total < 0) {			return -1;		}		if (startIndex >= total) {			startIndex = total;		}		if (endIndex < 0) {			endIndex = 0;		}		char c = sub.charAt(0);	mainloop:		for (int i = startIndex; i >= endIndex; i--) {			if (src.charAt(i) != c) {				continue;			}			int j = 1;			int k = i + 1;			while (j < sublen) {				if (sub.charAt(j) != src.charAt(k)) {					continue mainloop;				}				j++; k++;			}			return i;		}		return -1;	}
public static int lastIndexOf(final String src, final char c, int startIndex, int endIndex) {		int total = src.length() - 1;		if (total < 0) {			return -1;		}		if (startIndex >= total) {			startIndex = total;		}		if (endIndex < 0) {			endIndex = 0;		}		for (int i = startIndex; i >= endIndex; i--) {			if (src.charAt(i) == c) {				return i;			}		}		return -1;	}
public static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) {		String sub = subS.toLowerCase();		int sublen = sub.length();		if (startIndex + sublen > src.length()) {			return false;		}		int j = 0;		int i = startIndex;		while (j < sublen) {			char source = Character.toLowerCase(src.charAt(i));			if (sub.charAt(j) != source) {				return false;			}			j++; i++;		}		return true;	}
public static boolean endsWithChar(final String s, final char c) {		if (s.length() == 0) {			return false;		}		return s.charAt(s.length() - 1) == c;	}
public static int countIgnoreCase(final String source, final String sub) {		int count = 0;		int j = 0;		int sublen = sub.length();		if (sublen == 0) {			return 0;		}		while (true) {			int i = indexOfIgnoreCase(source, sub, j);			if (i == -1) {				break;			}			count++;			j = i + sublen;		}		return count;	}
public static int[] lastIndexOfIgnoreCase(final String s, final String... arr) {		return lastIndexOfIgnoreCase(s, arr, s.length());	}
public static boolean equalsIgnoreCase(final String[] as, final String[] as1) {		if (as.length != as1.length) {			return false;		}		for (int i = 0; i < as.length; i++) {			if (!as[i].equalsIgnoreCase(as1[i])) {				return false;			}		}		return true;	}
public static String replace(final String s, final String[] sub, final String[] with) {		if ((sub.length != with.length) || (sub.length == 0)) {			return s;		}		int start = 0;		StringBuilder buf = new StringBuilder(s.length());		while (true) {			int[] res = indexOf(s, sub, start);			if (res == null) {				break;			}			int end = res[1];			buf.append(s, start, end);			buf.append(with[res[0]]);			start = end + sub[res[0]].length();		}		buf.append(s.substring(start));		return buf.toString();	}
public static String replaceIgnoreCase(final String s, final String[] sub, final String[] with) {		if ((sub.length != with.length) || (sub.length == 0)) {			return s;		}		int start = 0;		StringBuilder buf = new StringBuilder(s.length());		while (true) {			int[] res = indexOfIgnoreCase(s, sub, start);			if (res == null) {				break;			}			int end = res[1];			buf.append(s, start, end);			buf.append(with[res[0]]);			start = end + sub[0].length();		}		buf.append(s.substring(start));		return buf.toString();	}
public static int equalsOne(final String src, final String... dest) {		for (int i = 0; i < dest.length; i++) {			if (src.equals(dest[i])) {				return i;			}		}		return -1;	}
public static int equalsOneIgnoreCase(final String src, final String... dest) {		for (int i = 0; i < dest.length; i++) {			if (src.equalsIgnoreCase(dest[i])) {				return i;			}		}		return -1;	}
public static int startsWithOne(final String src, final String... dest) {		for (int i = 0; i < dest.length; i++) {			String m = dest[i];			if (m == null) {				continue;			}			if (src.startsWith(m)) {				return i;			}		}		return -1;	}
public static int startsWithOneIgnoreCase(final String src, final String... dest) {		for (int i = 0; i < dest.length; i++) {			String m = dest[i];			if (m == null) {				continue;			}			if (startsWithIgnoreCase(src, m)) {				return i;			}		}		return -1;	}
public static int endsWithOne(final String src, final String... dest) {		for (int i = 0; i < dest.length; i++) {			String m = dest[i];			if (m == null) {				continue;			}			if (src.endsWith(m)) {				return i;			}		}		return -1;	}
public static int endsWithOneIgnoreCase(final String src, final String... dest) {		for (int i = 0; i < dest.length; i++) {			String m = dest[i];			if (m == null) {				continue;			}			if (endsWithIgnoreCase(src, m)) {				return i;			}		}		return -1;	}
public static int indexOfWhitespace(final String string, final int startindex, final int endindex) {		for (int i = startindex; i < endindex; i++) {			if (CharUtil.isWhitespace(string.charAt(i))) {				return i;			}		}		return -1;	}
public static String stripLeadingChar(final String string, final char c) {		if (string.length() > 0) {			if (string.charAt(0) == c) {				return string.substring(1);			}		}		return string;	}
public static String stripTrailingChar(final String string, final char c) {		if (string.length() > 0) {			if (string.charAt(string.length() - 1) == c) {				return string.substring(0, string.length() - 1);			}		}		return string;	}
public static String stripChar(final String string, final char c) {		if (string.length() == 0) {			return string;		}		if (string.length() == 1) {			if (string.charAt(0) == c) {				return StringPool.EMPTY;			}			return string;		}		int left = 0;		int right = string.length();		if (string.charAt(left) == c) {			left++;		}		if (string.charAt(right - 1) == c) {			right--;		}		return string.substring(left, right);	}
public static String stripToChar(final String string, final char c) {		int ndx = string.indexOf(c);		if (ndx == -1) {			return string;		}		return string.substring(ndx);	}
public static String stripFromChar(final String string, final char c) {		int ndx = string.indexOf(c);		if (ndx == -1) {			return string;		}		return string.substring(0, ndx);	}
public static void trimAll(final String... strings) {		for (int i = 0; i < strings.length; i++) {			String string = strings[i];			if (string != null) {				strings[i] = string.trim();			}		}	}
public static void trimDownAll(final String... strings) {		for (int i = 0; i < strings.length; i++) {			String string = strings[i];			if (string != null) {				strings[i] = trimDown(string);			}		}	}
public static String trimDown(String string) {		string = string.trim();		if (string.length() == 0) {			string = null;		}		return string;	}
public static void cropAll(final String... strings) {		for (int i = 0; i < strings.length; i++) {			String string = strings[i];			if (string != null) {				string = crop(strings[i]);			}			strings[i] = string;		}	}
public static String trimLeft(final String src) {		int len = src.length();		int st = 0;		while ((st < len) && (CharUtil.isWhitespace(src.charAt(st)))) {			st++;		}		return st > 0 ? src.substring(st) : src;	}
public static String trimRight(final String src) {		int len = src.length();		int count = len;		while ((len > 0) && (CharUtil.isWhitespace(src.charAt(len - 1)))) {			len--;		}		return (len < count) ? src.substring(0, len) : src;	}
public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) {		int ndx = offset;		int[] res = new int[4];		ndx = string.indexOf(leftBoundary, ndx);		if (ndx == -1) {			return null;		}		res[0] = ndx;		ndx += leftBoundary.length();		res[1] = ndx;		ndx = string.indexOf(rightBoundary, ndx);		if (ndx == -1) {			return null;		}		res[2] = ndx;		res[3] = ndx + rightBoundary.length();		return res;	}
public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final char escape, final int offset) {		int ndx = offset;		int[] res = new int[4];		while (true) {			ndx = string.indexOf(leftBoundary, ndx);			if (ndx == -1) {				return null;			}			int leftBoundaryLen = leftBoundary.length();			if (ndx > 0) {				if (string.charAt(ndx - 1) == escape) {				// check previous char					boolean cont = true;					if (ndx > 1) {						if (string.charAt(ndx - 2) == escape) {		// check double escapes							ndx--;							leftBoundaryLen++;							cont = false;						}					}					if (cont) {						ndx += leftBoundaryLen;						continue;					}				}			}			res[0] = ndx;			ndx += leftBoundaryLen;			res[1] = ndx;			while (true) {		// find right boundary				ndx = string.indexOf(rightBoundary, ndx);				if (ndx == -1) {					return null;				}				if (ndx > 0) {					if (string.charAt(ndx - 1) == escape) {						ndx += rightBoundary.length();						continue;					}				}				res[2] = ndx;				res[3] = ndx + rightBoundary.length();				return res;			}		}	}
public static String join(final Collection collection, final char separator) {		if (collection == null) {			return null;		}		if (collection.size() == 0) {			return StringPool.EMPTY;		}		final StringBuilder sb = new StringBuilder(collection.size() * 16);		final Iterator it = collection.iterator();		for (int i = 0; i < collection.size(); i++) {			if (i > 0) {				sb.append(separator);			}			sb.append(it.next());		}		return sb.toString();	}
public static String join(final Object[] array, final String separator) {		if (array == null) {			return null;		}		if (array.length == 0) {			return StringPool.EMPTY;		}		if (array.length == 1) {			return String.valueOf(array[0]);		}		final StringBuilder sb = new StringBuilder(array.length * 16);		for (int i = 0; i < array.length; i++) {			if (i > 0) {				sb.append(separator);			}			sb.append(array[i]);		}		return sb.toString();	}
public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) {		if (srcCharsetName.equals(newCharsetName)) {			return source;		}		return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName);	}
public static boolean isCharAtEqual(final String string, final int index, final char charToCompare) {		if ((index < 0) || (index >= string.length())) {			return false;		}		return string.charAt(index) == charToCompare;	}
public static String surround(String string, final String prefix, final String suffix) {		if (!string.startsWith(prefix)) {			string = prefix + string;		}		if (!string.endsWith(suffix)) {			string += suffix;		}		return string;	}
public static String prefix(String string, final String prefix) {		if (!string.startsWith(prefix)) {			string = prefix + string;		}		return string;	}
public static String suffix(String string, final String suffix) {		if (!string.endsWith(suffix)) {			string += suffix;		}		return string;	}
public static String cutToIndexOf(String string, final String substring) {		int i = string.indexOf(substring);		if (i != -1) {			string = string.substring(0, i);		}		return string;	}
public static String cutFromIndexOf(String string, final String substring) {		int i = string.indexOf(substring);		if (i != -1) {			string = string.substring(i);		}		return string;	}
public static String cutPrefix(String string, final String prefix) {		if (string.startsWith(prefix)) {			string = string.substring(prefix.length());		}		return string;	}
public static String cutSuffix(String string, final String suffix) {		if (string.endsWith(suffix)) {			string = string.substring(0, string.length() - suffix.length());		}		return string;	}
public static String cutSurrounding(final String string, final String prefix, final String suffix) {		int start = 0;		int end = string.length();		if (string.startsWith(prefix)) {			start = prefix.length();		}		if (string.endsWith(suffix)) {			end -= suffix.length();		}		if (end <= start) {			return StringPool.EMPTY;		}		return string.substring(start, end);	}
public static String cutBetween(final String string, final String left, final String right) {		int leftNdx = string.indexOf(left);		if (leftNdx == -1) {			return null;		}		int rightNdx = string.indexOf(right);		if (rightNdx == -1) {			return null;		}		leftNdx += left.length();		if (leftNdx >= rightNdx) {			return StringPool.EMPTY;		}		return string.substring(leftNdx, rightNdx);	}
public static boolean isCharAtEscaped(final String src, int ndx, final char escapeChar) {		if (ndx == 0) {			return false;		}		ndx--;		return src.charAt(ndx) == escapeChar;	}
public static String insert(final String src, final String insert, int offset) {		if (offset < 0) {			offset = 0;		}		if (offset > src.length()) {			offset = src.length();		}		StringBuilder sb = new StringBuilder(src);		sb.insert(offset, insert);		return sb.toString();	}
public static String repeat(final String source, int count) {		StringBand result = new StringBand(count);		while (count > 0) {			result.append(source);			count--;		}		return result.toString();	}
public static String reverse(final String s) {		StringBuilder result = new StringBuilder(s.length());		for (int i = s.length() -1; i >= 0; i--) {			result.append(s.charAt(i));		}		return result.toString();	}
public static String maxCommonPrefix(final String one, final String two) {        final int minLength = Math.min(one.length(), two.length());        final StringBuilder sb = new StringBuilder(minLength);        for (int pos = 0; pos < minLength; pos++) {            final char currentChar = one.charAt(pos);            if (currentChar != two.charAt(pos)) {                break;            }            sb.append(currentChar);        }		return sb.toString();	}
public static String findCommonPrefix(final String... strings) {		StringBuilder prefix = new StringBuilder();		int index = 0;		char c = 0;		loop:		while (true) {			for (int i = 0; i < strings.length; i++) {				String s = strings[i];				if (index == s.length()) {					break loop;				}				if (i == 0) {					c = s.charAt(index);				} else {					if (s.charAt(index) != c) {						break loop;					}				}			}			index++;			prefix.append(c);		}		return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString();	}
public static String shorten(String s, int length, final String suffix) {		length -= suffix.length();		if (s.length() > length) {			for (int j = length; j >= 0; j--) {				if (CharUtil.isWhitespace(s.charAt(j))) {					length = j;					break;				}			}			String temp = s.substring(0, length);			s = temp.concat(suffix);		}		return s;	}
public static String toUpperCase(final String s, Locale locale) {		if (s == null) {			return null;		}		StringBuilder sb = null;		for (int i = 0; i < s.length(); i++) {			char c = s.charAt(i);			if (c > 127) {				// found non-ascii char, fallback to the slow unicode detection				if (locale == null) {					locale = Locale.getDefault();				}				return s.toUpperCase(locale);			}			if ((c >= 'a') && (c <= 'z')) {				if (sb == null) {					sb = new StringBuilder(s);				}				sb.setCharAt(i, (char)(c - 32));			}		}		if (sb == null) {			return s;		}		return sb.toString();	}
public static String removeQuotes(final String string) {		if (			(startsWithChar(string, '\'') && endsWithChar(string, '\'')) ||			(startsWithChar(string, '"') && endsWithChar(string, '"')) ||			(startsWithChar(string, '`') && endsWithChar(string, '`'))		) {			return substring(string, 1, -1);		}		return string;	}
public static String toHexString(final byte[] bytes) {		char[] chars = new char[bytes.length * 2];		int i = 0;		for (byte b : bytes) {			chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4);			chars[i++] = CharUtil.int2hex(b & 0x0F);		}		return new String(chars);	}
public static String ifNotNull(final String input, final Function<String, String> stringFunction) {		if (input == null) {			return StringPool.EMPTY;		}		return stringFunction.apply(input);	}
public static byte[] getBytes(final String string) {		try {			return string.getBytes(JoddCore.encoding);		} catch (UnsupportedEncodingException e) {			throw new RuntimeException(e);		}	}
public static char detectQuoteChar(final String str) {		if (str.length() < 2) {			return 0;		}		final char c = str.charAt(0);		if (c != str.charAt(str.length() - 1)) {			return 0;		}		if (c == '\'' || c == '"' || c == '`') {			return c;		}		return 0;	}
@Override	public void render(final ActionRequest actionRequest, final Object resultValue) {		final PermRedirect redirectResult;		if (resultValue == null) {			redirectResult = PermRedirect.to(StringPool.SLASH);		} else {			if (resultValue instanceof String) {				redirectResult = PermRedirect.to((String)resultValue);			}			else {				redirectResult = (PermRedirect) resultValue;			}		}		final String resultBasePath = actionRequest.getActionRuntime().getResultBasePath();		final String redirectValue = redirectResult.path();		final String resultPath;		if (redirectValue.startsWith("http://") || redirectValue.startsWith("https://")) {			resultPath = redirectValue;		}		else {			resultPath = resultMapper.resolveResultPathString(resultBasePath, redirectValue);		}		final HttpServletRequest request = actionRequest.getHttpServletRequest();		final HttpServletResponse response = actionRequest.getHttpServletResponse();		String path = beanTemplateParser.parseWithBean(resultPath, actionRequest.getAction());		DispatcherUtil.redirectPermanent(request, response, path);	}
public FastIntBuffer append(final FastIntBuffer buff) {		if (buff.offset == 0) {			return this;		}		append(buff.buffer, 0, buff.offset);		return this;	}
public void visit(final String name, final Object value) {    if (av != null) {      av.visit(name, value);    }  }
public void visitEnum(final String name, final String descriptor, final String value) {    if (av != null) {      av.visitEnum(name, descriptor, value);    }  }
public AnnotationVisitor visitAnnotation(final String name, final String descriptor) {    if (av != null) {      return av.visitAnnotation(name, descriptor);    }    return null;  }
public <E> DbEntityDescriptor<E> lookupType(final Class<E> type) {		String typeName = type.getName();		if (StringUtil.startsWithOne(typeName, primitiveEntitiesPrefixes) != -1) {			return null;		}		DbEntityDescriptor<E> ded = descriptorsMap.get(type);		if (ded == null) {			ded = registerType(type);		}		return ded;	}
public <E> DbEntityDescriptor<E> registerType(final Class<E> type) {		DbEntityDescriptor<E> ded = createDbEntityDescriptor(type);		DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded);		if (log.isDebugEnabled()) {			log.debug("Register " + type.getName() + " as " + ded.getTableName());		}		if (existing != null) {			if (ded.getType() == type) {				return ded;			}			throw new DbOomException("Type already registered: " + existing.getType());		}		existing = entityNamesMap.put(ded.getEntityName(), ded);		if (existing != null) {			throw new DbOomException("Name '" + ded.getEntityName() + "' already mapped to an entity: " + existing.getType());		}		return ded;	}
public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type) {		DbEntityDescriptor<E> ded = registerType(type);		DbEntityDescriptor existing = tableNamesMap.put(ded.getTableName(), ded);		if (existing != null) {			if (ded.getType() == type) {				return ded;			}			throw new DbOomException("Entity registration failed! Table '" + ded.getTableName() + "' already mapped to an entity: " + existing.getType());		}		return ded;	}
public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) {		if (force) {			removeEntity(type);		}		return registerEntity(type);	}
public <E> DbEntityDescriptor<E> removeEntity(final Class<E> type) {		DbEntityDescriptor<E> ded = descriptorsMap.remove(type);		if (ded == null) {			ded = createDbEntityDescriptor(type);		}		entityNamesMap.remove(ded.getEntityName());		tableNamesMap.remove(ded.getTableName());		return ded;	}
protected <E> DbEntityDescriptor<E> createDbEntityDescriptor(final Class<E> type) {		final String schemaName = dbOomConfig.getSchemaName();		final TableNamingStrategy tableNames = dbOomConfig.getTableNames();		final ColumnNamingStrategy columnNames = dbOomConfig.getColumnNames();		return new DbEntityDescriptor<>(type, schemaName, tableNames, columnNames);	}
public <E> E createEntityInstance(final Class<E> type) {		try {			return ClassUtil.newInstance(type);		} catch (Exception ex) {			throw new DbOomException(ex);		}	}
public WrapperProxettaFactory setTargetInterface(final Class targetInterface) {		if (!targetInterface.isInterface()) {			throw new ProxettaException("Not an interface: " + targetInterface.getName());		}		this.targetInterface = targetInterface;		return this;	}
@Override	protected WorkData process(final ClassReader cr, final TargetClassInfoReader targetClassInfoReader) {		final ProxettaWrapperClassBuilder pcb =				new ProxettaWrapperClassBuilder(						targetClassOrInterface,						targetInterface,						targetFieldName,						destClassWriter,						proxetta.getAspects(new ProxyAspect[0]),						resolveClassNameSuffix(),						requestedProxyClassName,						targetClassInfoReader,						createTargetInDefaultCtor				);		cr.accept(pcb, 0);		return pcb.getWorkData();	}
public void injectTargetIntoWrapper(final Object target, final Object wrapper) {		ProxettaUtil.injectTargetIntoWrapper(target, wrapper, targetFieldName);	}
protected PropertyDescriptor[] lookupAnnotatedProperties(final Class type) {		PropertyDescriptor[] properties = annotatedProperties.get(type);		if (properties != null) {			return properties;		}		ClassDescriptor cd = ClassIntrospector.get().lookup(type);		PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors();		List<PropertyDescriptor> list = new ArrayList<>();		for (PropertyDescriptor propertyDescriptor : allProperties) {			Annotation ann = null;			if (propertyDescriptor.getFieldDescriptor() != null) {				ann = propertyDescriptor.getFieldDescriptor().getField().getAnnotation(annotations);			}			if (ann == null && propertyDescriptor.getWriteMethodDescriptor() != null) {				ann = propertyDescriptor.getWriteMethodDescriptor().getMethod().getAnnotation(annotations);			}			if (ann == null && propertyDescriptor.getReadMethodDescriptor() != null) {				ann = propertyDescriptor.getReadMethodDescriptor().getMethod().getAnnotation(annotations);			}			if (ann != null) {				list.add(propertyDescriptor);			}		}		if (list.isEmpty()) {			properties = EMPTY;		} else {			properties = list.toArray(new PropertyDescriptor[0]);		}		annotatedProperties.put(type, properties);		return properties;	}
public DbServer detectDatabaseAndConfigureDbOom(			final ConnectionProvider cp,			final DbOomConfig dbOomConfig) {		cp.init();		final Connection connection = cp.getConnection();		final DbServer dbServer = detectDatabase(connection);		cp.closeConnection(connection);		dbServer.accept(dbOomConfig);		return dbServer;	}
public DbServer detectDatabase(final Connection connection) {		final String dbName;		final int dbMajorVersion;		final String version;		try {			log.info("Detecting database...");			DatabaseMetaData databaseMetaData = connection.getMetaData();			dbName = databaseMetaData.getDatabaseProductName();			dbMajorVersion = databaseMetaData.getDatabaseMajorVersion();			final int dbMinorVersion = databaseMetaData.getDatabaseMinorVersion();			version = dbMajorVersion + "." + dbMinorVersion;			log.info("Database: " + dbName + " v" + dbMajorVersion + "." + dbMinorVersion);		}		catch (SQLException sex) {			String msg = sex.getMessage();			if (msg.contains("explicitly set for database: DB2")) {				return new Db2DbServer();			}			throw new DbSqlException(sex);		}		if (dbName.equals("Apache Derby")) {			return new DerbyDbServer(version);		}		if (dbName.startsWith("DB2/")) {			return new Db2DbServer(version);		}		if (dbName.equals("HSQL Database Engine")) {			return new HsqlDbServer(version);		}		if (dbName.equals("Informix Dynamic Server")) {			return new InformixDbServer(version);		}		if (dbName.startsWith("Microsoft SQL Server")) {			return new SqlServerDbServer(version);		}		if (dbName.equals("MySQL")) {			return new MySqlDbServer(version);		}		if (dbName.equals("Oracle")) {			return new OracleDbServer(version);		}		if (dbName.equals("PostgreSQL")) {			return new PostgreSqlDbServer(version);		}		if (dbName.equals("Sybase SQL Server")) {			return new SybaseDbServer(version);		}		if (dbName.equals("ASE") && (dbMajorVersion == 15)) {			return new SybaseDbServer(version);		}		if (dbName.equals("SQLite")) {			return new SQLiteDbServer(version);		}		return new GenericDbServer();	}
@Override	public void close() throws IOException {		if (closed) {			return;		}		if (gzipstream != null) {			flushToGZip();			gzipstream.close();			gzipstream = null;		} else {			if (bufferCount > 0) {				output.write(buffer, 0, bufferCount);				bufferCount = 0;			}		}		output.close();		closed = true;	}
@Override	public void write(final int b) throws IOException {		if (closed) {			throw new IOException("Cannot write to a closed output stream");		}		if (bufferCount >= buffer.length) {			flushToGZip();		}		buffer[bufferCount++] = (byte) b;	}
@Override	public void write(final byte[] b, final int off, final int len) throws IOException {		if (closed) {			throw new IOException("Cannot write to a closed output stream");		}		if (len == 0) {			return;		}		// Can we write into buffer ?		if (len <= (buffer.length - bufferCount)) {			System.arraycopy(b, off, buffer, bufferCount, len);			bufferCount += len;			return;		}		// There is not enough space in buffer. Flush it ...		flushToGZip();		// ... and try again. Note, that bufferCount = 0 here !		if (len <= (buffer.length - bufferCount)) {			System.arraycopy(b, off, buffer, bufferCount, len);			bufferCount += len;			return;		}		// write direct to gzip		writeToGZip(b, off, len);	}
public void writeToGZip(final byte[] b, final int off, final int len) throws IOException {		if (gzipstream == null) {			gzipstream = new GZIPOutputStream(output);			response.setHeader("Content-Encoding", "gzip");		}		gzipstream.write(b, off, len);	}
@Override	public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain)			throws IOException, ServletException {		HttpServletRequest httpRequest = (HttpServletRequest) request;		HttpServletResponse httpResponse = (HttpServletResponse) response;		if (isRequestedSessionIdFromURL(httpRequest)) {			HttpSession session = httpRequest.getSession(false);			if (session != null) {				session.invalidate();		// clear session if session id in URL			}		}		// wrap response to remove URL encoding		HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) {			@Override			public String encodeRedirectUrl(final String url) {				return url;			}			@Override			public String encodeRedirectURL(final String url) {				return url;			}			@Override			public String encodeUrl(final String url) {				return url;			}			@Override			public String encodeURL(final String url) {				return url;			}		};		chain.doFilter(request, wrappedResponse);	}
protected boolean isRequestedSessionIdFromURL(final HttpServletRequest servletRequest) {		if (servletRequest.isRequestedSessionIdFromURL()) {			return true;		}		HttpSession session = servletRequest.getSession(false);		if (session != null) {			String sessionId = session.getId();			StringBuffer requestUri = servletRequest.getRequestURL();			return requestUri.indexOf(sessionId) != -1;		}		return false;	}
public String getEncodedName() {		if (name == null) {			return null;		}		try {			return MimeUtility.encodeText(name);		} catch (final UnsupportedEncodingException ueex) {			throw new MailException(ueex);		}	}
public byte[] toByteArray() {		final FastByteArrayOutputStream out;		if (size != -1) {			out = new FastByteArrayOutputStream(size);		} else {			out = new FastByteArrayOutputStream();		}		writeToStream(out);		return out.toByteArray();	}
public void writeToFile(final File destination) {		InputStream input = null;		final OutputStream output;		try {			input = getDataSource().getInputStream();			output = new FileOutputStream(destination);			StreamUtil.copy(input, output);		}		catch (final IOException ioex) {			throw new MailException(ioex);		}		finally {			StreamUtil.close(input);		}	}
public void writeToStream(final OutputStream out) {		InputStream input = null;		try {			input = getDataSource().getInputStream();			StreamUtil.copy(input, out);		}		catch (final IOException ioex) {			throw new MailException(ioex);		}		finally {			StreamUtil.close(input);		}	}
@Override	public BigDecimal get(final ResultSet rs, final int index, final int dbSqlType) throws SQLException {		return rs.getBigDecimal(index);	}
@Override	public void set(final PreparedStatement st, final int index, final BigDecimal value, final int dbSqlType) throws SQLException {		st.setBigDecimal(index, value);	}
@Override	public void visitMethodInsn(final int opcode, String owner, String name, String desc, final boolean isInterface) {		// replace NEW.<init>		if ((newInvokeReplacer != null) && (opcode == INVOKESPECIAL)) {			String exOwner = owner;			owner = newInvokeReplacer.getOwner();			name = newInvokeReplacer.getMethodName();			desc = changeReturnType(desc, 'L' + exOwner + ';');			super.visitMethodInsn(INVOKESTATIC, owner, name, desc, isInterface);			newInvokeReplacer = null;			return;		}		InvokeInfo invokeInfo = new InvokeInfo(owner, name, desc);		// [*]		// creating FooClone.<init>; inside the FOO constructor		// replace the very first invokespecial <init> call (SUB.<init>)		// to targets subclass with target (FOO.<init>).		if (methodInfo.getMethodName().equals(INIT)) {			if (					(!firstSuperCtorInitCalled) &&							(opcode == INVOKESPECIAL) &&							name.equals(INIT) &&							owner.equals(wd.nextSupername)					) {				firstSuperCtorInitCalled = true;				owner = wd.superReference;				super.visitMethodInsn(opcode, owner, name, desc, isInterface);				return;			}		}		// detection of super calls		if ((opcode == INVOKESPECIAL) && (owner.equals(wd.nextSupername) && (!name.equals(INIT)))) {			throw new ProxettaException("Super call detected in class " + methodInfo.getClassname() + " method: " + methodInfo.getSignature() +				"\nProxetta can't handle super calls due to VM limitations.");		}		InvokeReplacer ir = null;		// find first matching aspect		for (InvokeAspect aspect : aspects) {			ir = aspect.pointcut(invokeInfo);			if (ir != null) {				break;			}		}		if (ir == null || ir.isNone()) {			if (ProxettaAsmUtil.isCreateArgumentsArrayMethod(name, desc)) {				ProxyTargetReplacement.createArgumentsArray(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isCreateArgumentsClassArrayMethod(name, desc)) {				ProxyTargetReplacement.createArgumentsClassArray(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isArgumentsCountMethod(name, desc)) {				ProxyTargetReplacement.argumentsCount(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isTargetMethodNameMethod(name, desc)) {				ProxyTargetReplacement.targetMethodName(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isTargetMethodDescriptionMethod(name, desc)) {				ProxyTargetReplacement.targetMethodDescription(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isTargetMethodSignatureMethod(name, desc)) {				ProxyTargetReplacement.targetMethodSignature(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isReturnTypeMethod(name, desc)) {				ProxyTargetReplacement.returnType(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (ProxettaAsmUtil.isTargetClassMethod(name, desc)) {				ProxyTargetReplacement.targetClass(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (isArgumentTypeMethod(name, desc)) {				int argIndex = this.getArgumentIndex();				ProxyTargetReplacement.argumentType(mv, methodInfo, argIndex);				wd.proxyApplied = true;				return;			}			if (isArgumentMethod(name, desc)) {				int argIndex = this.getArgumentIndex();				ProxyTargetReplacement.argument(mv, methodInfo, argIndex);				wd.proxyApplied = true;				return;			}			if (isInfoMethod(name, desc)) {				proxyInfoRequested = true;				// we are NOT calling the replacement here, as we would expect.				// NO, we need to wait for the very next ASTORE method so we				// can read the index and use it for replacement method!!!				//ProxyTargetReplacement.info(mv, methodInfo);				wd.proxyApplied = true;				return;			}			if (isTargetMethodAnnotationMethod(name, desc)) {				String[] args = getLastTwoStringArguments();				// pop current two args				mv.visitInsn(POP);				mv.visitInsn(POP);				ProxyTargetReplacement.targetMethodAnnotation(mv, methodInfo, args);				wd.proxyApplied = true;				return;			}			if (isTargetClassAnnotationMethod(name, desc)) {				String[] args = getLastTwoStringArguments();				// pop current two args				mv.visitInsn(POP);				mv.visitInsn(POP);				ProxyTargetReplacement.targetClassAnnotation(mv, methodInfo.getClassInfo(), args);				wd.proxyApplied = true;				return;			}			super.visitMethodInsn(opcode, owner, name, desc, isInterface);			return;		}		wd.proxyApplied = true;		String exOwner = owner;		owner = ir.getOwner();		name = ir.getMethodName();		switch (opcode) {			case INVOKEINTERFACE:				desc = prependArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_OBJECT);				break;			case INVOKEVIRTUAL:				desc = prependArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_OBJECT);				break;			case INVOKESTATIC:				break;			default:				throw new ProxettaException("Unsupported opcode: " + opcode);		}		// additional arguments		if (ir.isPassOwnerName()) {			desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);			super.visitLdcInsn(exOwner);		}		if (ir.isPassMethodName()) {			desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);			super.visitLdcInsn(methodInfo.getMethodName());		}		if (ir.isPassMethodSignature()) {			desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_STRING);			super.visitLdcInsn(methodInfo.getSignature());		}		if (ir.isPassTargetClass()) {			desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_CLASS);			super.mv.visitLdcInsn(Type.getType('L' + wd.superReference + ';'));		}		if (ir.isPassThis()) {			desc = appendArgument(desc, AsmUtil.L_SIGNATURE_JAVA_LANG_OBJECT);			super.mv.visitVarInsn(ALOAD, 0);		}		super.visitMethodInsn(INVOKESTATIC, owner, name, desc, false);	}
protected static String appendArgument(final String desc, final String type) {		int ndx = desc.indexOf(')');		return desc.substring(0, ndx) + type + desc.substring(ndx);	}
protected static String prependArgument(final String desc, final String type) {		int ndx = desc.indexOf('(');		ndx++;		return desc.substring(0, ndx) + type + desc.substring(ndx);	}
protected static String changeReturnType(final String desc, final String type) {		int ndx = desc.indexOf(')');		return desc.substring(0, ndx + 1) + type;	}
@Override	public void text(final CharSequence text) {		if (!strip) {			super.text(text);			return;		}		int textLength = text.length();		char[] dest = new char[textLength];		int ndx = 0;		boolean regularChar = true;		for (int i = 0; i < textLength; i++) {			char c = text.charAt(i);			if (CharUtil.isWhitespace(c)) {				if (regularChar) {					regularChar = false;					c = ' ';				} else {					continue;				}			} else {				regularChar = true;			}			dest[ndx] = c;			ndx++;		}		if (regularChar || (ndx != 1)) {			super.text(CharBuffer.wrap(dest, 0, ndx));			strippedCharsCount += textLength - ndx;		} else {			strippedCharsCount += textLength;		}	}
public void registerDefaults() {		register(String.class, new StringConverter());		register(String[].class, new StringArrayConverter(this));		IntegerConverter integerConverter = new IntegerConverter();		register(Integer.class, integerConverter);		register(int.class, integerConverter);		register(MutableInteger.class, new MutableIntegerConverter(this));		ShortConverter shortConverter = new ShortConverter();		register(Short.class, shortConverter);		register(short.class, shortConverter);		register(MutableShort.class, new MutableShortConverter(this));		LongConverter longConverter = new LongConverter();		register(Long.class, longConverter);		register(long.class, longConverter);		register(MutableLong.class, new MutableLongConverter(this));		ByteConverter byteConverter = new ByteConverter();		register(Byte.class, byteConverter);		register(byte.class, byteConverter);		register(MutableByte.class, new MutableByteConverter(this));		FloatConverter floatConverter = new FloatConverter();		register(Float.class, floatConverter);		register(float.class, floatConverter);		register(MutableFloat.class, new MutableFloatConverter(this));		DoubleConverter doubleConverter = new DoubleConverter();		register(Double.class, doubleConverter);		register(double.class, doubleConverter);		register(MutableDouble.class, new MutableDoubleConverter(this));		BooleanConverter booleanConverter = new BooleanConverter();		register(Boolean.class, booleanConverter);		register(boolean.class, booleanConverter);		CharacterConverter characterConverter = new CharacterConverter();		register(Character.class, characterConverter);		register(char.class, characterConverter);		register(byte[].class, new ByteArrayConverter(this));		register(short[].class, new ShortArrayConverter(this));		register(int[].class, new IntegerArrayConverter(this));		register(long[].class, new LongArrayConverter(this));		register(float[].class, new FloatArrayConverter(this));		register(double[].class, new DoubleArrayConverter(this));		register(boolean[].class, new BooleanArrayConverter(this));		register(char[].class, new CharacterArrayConverter(this));		// we don't really need these, but converters will be cached and not created every time		register(Integer[].class, new ArrayConverter<Integer>(this, Integer.class) {			@Override			protected Integer[] createArray(final int length) {				return new Integer[length];			}		});		register(Long[].class, new ArrayConverter<Long>(this, Long.class) {			@Override			protected Long[] createArray(final int length) {				return new Long[length];			}		});		register(Byte[].class, new ArrayConverter<Byte>(this, Byte.class) {			@Override			protected Byte[] createArray(final int length) {				return new Byte[length];			}		});		register(Short[].class, new ArrayConverter<Short>(this, Short.class) {			@Override			protected Short[] createArray(final int length) {				return new Short[length];			}		});		register(Float[].class, new ArrayConverter<Float>(this, Float.class) {			@Override			protected Float[] createArray(final int length) {				return new Float[length];			}		});		register(Double[].class, new ArrayConverter<Double>(this, Double.class) {			@Override			protected Double[] createArray(final int length) {				return new Double[length];			}		});		register(Boolean[].class, new ArrayConverter<Boolean>(this, Boolean.class) {			@Override			protected Boolean[] createArray(final int length) {				return new Boolean[length];			}		});		register(Character[].class, new ArrayConverter<Character>(this, Character.class) {			@Override			protected Character[] createArray(final int length) {				return new Character[length];			}		});		register(MutableInteger[].class, new ArrayConverter<>(this, MutableInteger.class));		register(MutableLong[].class, new ArrayConverter<>(this, MutableLong.class));		register(MutableByte[].class, new ArrayConverter<>(this, MutableByte.class));		register(MutableShort[].class, new ArrayConverter<>(this, MutableShort.class));		register(MutableFloat[].class, new ArrayConverter<>(this, MutableFloat.class));		register(MutableDouble[].class, new ArrayConverter<>(this, MutableDouble.class));		register(BigDecimal.class, new BigDecimalConverter());		register(BigInteger.class, new BigIntegerConverter());		register(BigDecimal[].class, new ArrayConverter<>(this, BigDecimal.class));		register(BigInteger[].class, new ArrayConverter<>(this, BigInteger.class));		register(java.util.Date.class, new DateConverter());		register(java.sql.Date.class, new SqlDateConverter());		register(Time.class, new SqlTimeConverter());		register(Timestamp.class, new SqlTimestampConverter());		register(Calendar.class, new CalendarConverter());//		register(GregorianCalendar.class, new CalendarConverter());		register(LocalDateTime.class, new LocalDateTimeConverter());		register(LocalDate.class, new LocalDateConverter());		register(LocalTime.class, new LocalTimeConverter());		register(File.class, new FileConverter());		register(FileUpload.class, new FileUploadConverter());		register(Class.class, new ClassConverter());		register(Class[].class, new ClassArrayConverter(this));		register(URI.class, new URIConverter());		register(URL.class, new URLConverter());		register(Locale.class, new LocaleConverter());		register(TimeZone.class, new TimeZoneConverter());		register(UUID.class, new UUIDConverter());	}
public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) {		converters.put(type, typeConverter);	}
public <T> TypeConverter<T> lookup(final Class<T> type) {		return converters.get(type);	}
@SuppressWarnings({"unchecked"})	public <T> T convertType(final Object value, final Class<T> destinationType) {		if (destinationType == Object.class) {			// no conversion :)			return (T) value;		}		final TypeConverter converter = lookup(destinationType);		if (converter != null) {			return (T) converter.convert(value);		}		// no converter		if (value == null) {			return null;		}		// check same instances		if (ClassUtil.isInstanceOf(value, destinationType)) {			return (T) value;		}		// handle destination arrays		if (destinationType.isArray()) {			ArrayConverter<T> arrayConverter = new ArrayConverter(this, destinationType.getComponentType());			return (T) arrayConverter.convert(value);		}		// handle enums		if (destinationType.isEnum()) {			Object[] enums = destinationType.getEnumConstants();			String valStr = value.toString();			for (Object e : enums) {				if (e.toString().equals(valStr)) {					return (T) e;				}			}		}		// collection		if (ClassUtil.isTypeOf(destinationType, Collection.class)) {			// component type is unknown because of Java's type-erasure			CollectionConverter<T> collectionConverter =					new CollectionConverter(this, destinationType, Object.class);			return (T) collectionConverter.convert(value);		}		// fail		throw new TypeConversionException("Conversion failed of input type: " + value.getClass() + " into: " + destinationType.getName());	}
@SuppressWarnings("unchecked")	public <C extends Collection<T>, T> C convertToCollection(final Object value, final Class<? extends Collection> destinationType, final Class<T> componentType) {		if (value == null) {			return null;		}		// check same instances		if (ClassUtil.isInstanceOf(value, destinationType)) {			return (C) value;		}		final CollectionConverter collectionConverter;		if (componentType == null) {			collectionConverter = new CollectionConverter(destinationType, Object.class);		}		else {			collectionConverter = new CollectionConverter(destinationType, componentType);		}		return (C) collectionConverter.convert(value);	}
