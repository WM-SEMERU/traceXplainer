private static boolean assertManagedBeanClassValidity(final ClassInfo managedBeanClass) {        final short flags = managedBeanClass.flags();        final String className = managedBeanClass.name().toString();        // must *not* be an interface        if (Modifier.isInterface(flags)) {            ROOT_LOGGER.invalidManagedBeanInterface("MB.2.1.1", className);            return false;        }        // bean class must *not* be abstract or final        if (Modifier.isAbstract(flags) || Modifier.isFinal(flags)) {            ROOT_LOGGER.invalidManagedBeanAbstractOrFinal("MB.2.1.1", className);            return false;        }        // valid class        return true;    }
private static PersistentResourceXMLDescription.PersistentResourceXMLBuilder listenerBuilder(PersistentResourceDefinition resource) {        return builder(resource.getPathElement())                // xsd socket-optionsType                .addAttributes(                        ListenerResourceDefinition.RECEIVE_BUFFER,                        ListenerResourceDefinition.SEND_BUFFER,                        ListenerResourceDefinition.BACKLOG,                        ListenerResourceDefinition.KEEP_ALIVE,                        ListenerResourceDefinition.READ_TIMEOUT,                        ListenerResourceDefinition.WRITE_TIMEOUT,                        ListenerResourceDefinition.MAX_CONNECTIONS)                // xsd listener-type                .addAttributes(                        ListenerResourceDefinition.SOCKET_BINDING,                        ListenerResourceDefinition.WORKER,                        ListenerResourceDefinition.BUFFER_POOL,                        ListenerResourceDefinition.ENABLED,                        ListenerResourceDefinition.RESOLVE_PEER_ADDRESS,                        ListenerResourceDefinition.MAX_ENTITY_SIZE,                        ListenerResourceDefinition.BUFFER_PIPELINED_DATA,                        ListenerResourceDefinition.MAX_HEADER_SIZE,                        ListenerResourceDefinition.MAX_PARAMETERS,                        ListenerResourceDefinition.MAX_HEADERS,                        ListenerResourceDefinition.MAX_COOKIES,                        ListenerResourceDefinition.ALLOW_ENCODED_SLASH,                        ListenerResourceDefinition.DECODE_URL,                        ListenerResourceDefinition.URL_CHARSET,                        ListenerResourceDefinition.ALWAYS_SET_KEEP_ALIVE,                        ListenerResourceDefinition.MAX_BUFFERED_REQUEST_SIZE,                        ListenerResourceDefinition.RECORD_REQUEST_START_TIME,                        ListenerResourceDefinition.ALLOW_EQUALS_IN_COOKIE_VALUE,                        ListenerResourceDefinition.NO_REQUEST_TIMEOUT,                        ListenerResourceDefinition.REQUEST_PARSE_TIMEOUT,                        ListenerResourceDefinition.DISALLOWED_METHODS,                        ListenerResourceDefinition.SECURE,                        ListenerResourceDefinition.RFC6265_COOKIE_VALIDATION,                        ListenerResourceDefinition.ALLOW_UNESCAPED_CHARACTERS_IN_URL);    }
public void initialize(ExtensionContext context) {        TransactionLogger.ROOT_LOGGER.debug("Initializing Transactions Extension");        final LogStoreResource resource = new LogStoreResource();        final boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        final TransactionSubsystemRootResourceDefinition rootResourceDefinition = new TransactionSubsystemRootResourceDefinition(registerRuntimeOnly);        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(rootResourceDefinition);        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);        // Create the path resolver handlers        if (context.getProcessType().isServer()) {            // It's less than ideal to create a separate operation here, but this extension contains two relative-to attributes            final ResolvePathHandler objectStorePathHandler = ResolvePathHandler.Builder.of(RESOLVE_OBJECT_STORE_PATH, context.getPathManager())                   .setPathAttribute(TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH)                   .setRelativeToAttribute(TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO)                   .build();            registration.registerOperationHandler(objectStorePathHandler.getOperationDefinition(), objectStorePathHandler);        }        ManagementResourceRegistration logStoreChild = registration.registerSubModel(new LogStoreDefinition(resource, registerRuntimeOnly));        if (registerRuntimeOnly) {            ManagementResourceRegistration transactionChild = logStoreChild.registerSubModel(new LogStoreTransactionDefinition(resource));            transactionChild.registerSubModel(LogStoreTransactionParticipantDefinition.INSTANCE);        }        subsystem.registerXMLElementWriter(TransactionSubsystemXMLPersister.INSTANCE);    }
@Override    public void initializeParsers(ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_0.getUriString(), TransactionSubsystem10Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_1.getUriString(), TransactionSubsystem11Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_2.getUriString(), TransactionSubsystem12Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_3.getUriString(), TransactionSubsystem13Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_4.getUriString(), TransactionSubsystem14Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_1_5.getUriString(), TransactionSubsystem15Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_2_0.getUriString(), TransactionSubsystem20Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_3_0.getUriString(), TransactionSubsystem30Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_4_0.getUriString(), TransactionSubsystem40Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.TRANSACTIONS_5_0.getUriString(), TransactionSubsystem50Parser::new);    }
public static PrimitiveAnalysis getPrimitiveAnalysis(final Class cls) {        if (cls == null)            throw IIOPLogger.ROOT_LOGGER.cannotAnalyzeNullClass();        if (cls == Void.TYPE)            return voidAnalysis;        if (cls == Boolean.TYPE)            return booleanAnalysis;        if (cls == Character.TYPE)            return charAnalysis;        if (cls == Byte.TYPE)            return byteAnalysis;        if (cls == Short.TYPE)            return shortAnalysis;        if (cls == Integer.TYPE)            return intAnalysis;        if (cls == Long.TYPE)            return longAnalysis;        if (cls == Float.TYPE)            return floatAnalysis;        if (cls == Double.TYPE)            return doubleAnalysis;        throw IIOPLogger.ROOT_LOGGER.notAPrimitive(cls.getName());    }
public void shutdown() {        int value;        int oldValue;        //set the shutdown bit        do {            oldValue = invocationCount;            value = SHUTDOWN_FLAG | oldValue;            //the component has already been shutdown            if (oldValue == value) {                return;            }        } while (!updater.compareAndSet(this, oldValue, value));        synchronized (lock) {            value = invocationCount;            while (value != SHUTDOWN_FLAG) {                try {                    lock.wait();                } catch (InterruptedException e) {                    throw new RuntimeException(e);                }                value = invocationCount;                if((value & SHUTDOWN_FLAG) == 0) {                    return; //component has been restarted                }            }        }    }
private EntityManagerFactory createContainerEntityManagerFactory() {        persistenceProviderAdaptor.beforeCreateContainerEntityManagerFactory(pu);        try {            ROOT_LOGGER.tracef("calling createContainerEntityManagerFactory for pu=%s with integration properties=%s, application properties=%s",                    pu.getScopedPersistenceUnitName(), properties, pu.getProperties());            return persistenceProvider.createContainerEntityManagerFactory(pu, properties);        } finally {            try {                persistenceProviderAdaptor.afterCreateContainerEntityManagerFactory(pu);            } finally {                pu.setAnnotationIndex(null);    // close reference to Annotation Index (only needed during call to createContainerEntityManagerFactory)                //This is needed if the datasource is restarted                //pu.setTempClassLoaderFactory(null);    // close reference to temp classloader factory (only needed during call to createEntityManagerFactory)            }        }    }
public static List<String> getUrlPatterns(final String urlPattern) {        final List<String> linkedList = new LinkedList<String>();        linkedList.add(urlPattern);        return linkedList;    }
public static JBossServletsMetaData getServlets(final JBossWebMetaData jbossWebMD) {        JBossServletsMetaData servletsMD = jbossWebMD.getServlets();        if (servletsMD == null) {            servletsMD = new JBossServletsMetaData();            jbossWebMD.setServlets(servletsMD);        }        return servletsMD;    }
public static List<ServletMappingMetaData> getServletMappings(final JBossWebMetaData jbossWebMD) {        List<ServletMappingMetaData> servletMappingsMD = jbossWebMD.getServletMappings();        if (servletMappingsMD == null) {            servletMappingsMD = new LinkedList<ServletMappingMetaData>();            jbossWebMD.setServletMappings(servletMappingsMD);        }        return servletMappingsMD;    }
public static List<SecurityConstraintMetaData> getSecurityConstraints(final JBossWebMetaData jbossWebMD) {        List<SecurityConstraintMetaData> securityConstraintsMD = jbossWebMD.getSecurityConstraints();        if (securityConstraintsMD == null) {            securityConstraintsMD = new LinkedList<SecurityConstraintMetaData>();            jbossWebMD.setSecurityConstraints(securityConstraintsMD);        }        return securityConstraintsMD;    }
public static LoginConfigMetaData getLoginConfig(final JBossWebMetaData jbossWebMD) {        LoginConfigMetaData loginConfigMD = jbossWebMD.getLoginConfig();        if (loginConfigMD == null) {            loginConfigMD = new LoginConfigMetaData();            jbossWebMD.setLoginConfig(loginConfigMD);        }        return loginConfigMD;    }
public static List<ParamValueMetaData> getContextParams(final JBossWebMetaData jbossWebMD) {        List<ParamValueMetaData> contextParamsMD = jbossWebMD.getContextParams();        if (contextParamsMD == null) {            contextParamsMD = new LinkedList<ParamValueMetaData>();            jbossWebMD.setContextParams(contextParamsMD);        }        return contextParamsMD;    }
public static WebResourceCollectionsMetaData getWebResourceCollections(final SecurityConstraintMetaData securityConstraintMD) {        WebResourceCollectionsMetaData webResourceCollectionsMD = securityConstraintMD.getResourceCollections();        if (webResourceCollectionsMD == null) {            webResourceCollectionsMD = new WebResourceCollectionsMetaData();            securityConstraintMD.setResourceCollections(webResourceCollectionsMD);        }        return webResourceCollectionsMD;    }
public static List<ParamValueMetaData> getServletInitParams(final ServletMetaData servletMD) {        List<ParamValueMetaData> initParamsMD = servletMD.getInitParam();        if (initParamsMD == null) {            initParamsMD = new LinkedList<ParamValueMetaData>();            servletMD.setInitParam(initParamsMD);        }        return initParamsMD;    }
public static SecurityConstraintMetaData newSecurityConstraint(final List<SecurityConstraintMetaData> securityConstraintsMD) {        final SecurityConstraintMetaData securityConstraintMD = new SecurityConstraintMetaData();        securityConstraintsMD.add(securityConstraintMD);        return securityConstraintMD;    }
public static WebResourceCollectionMetaData newWebResourceCollection(final String servletName, final String urlPattern,            final boolean securedWsdl, final WebResourceCollectionsMetaData webResourceCollectionsMD) {        final WebResourceCollectionMetaData webResourceCollectionMD = new WebResourceCollectionMetaData();        webResourceCollectionMD.setWebResourceName(servletName);        webResourceCollectionMD.setUrlPatterns(WebMetaDataHelper.getUrlPatterns(urlPattern));        webResourceCollectionMD.setHttpMethods(WebMetaDataHelper.getHttpMethods(securedWsdl));        webResourceCollectionsMD.add(webResourceCollectionMD);        return webResourceCollectionMD;    }
public static JBossServletMetaData newServlet(final String servletName, final String servletClass,            final JBossServletsMetaData servletsMD) {        final JBossServletMetaData servletMD = new JBossServletMetaData();        servletMD.setServletName(servletName);        servletMD.setServletClass(servletClass);        servletsMD.add(servletMD);        return servletMD;    }
public static ServletMappingMetaData newServletMapping(final String servletName, final List<String> urlPatterns,            final List<ServletMappingMetaData> servletMappingsMD) {        final ServletMappingMetaData servletMappingMD = new ServletMappingMetaData();        servletMappingMD.setServletName(servletName);        servletMappingMD.setUrlPatterns(urlPatterns);        servletMappingsMD.add(servletMappingMD);        return servletMappingMD;    }
public static AuthConstraintMetaData newAuthConstraint(final List<String> roleNames,            final SecurityConstraintMetaData securityConstraintMD) {        final AuthConstraintMetaData authConstraintMD = new AuthConstraintMetaData();        authConstraintMD.setRoleNames(roleNames);        securityConstraintMD.setAuthConstraint(authConstraintMD);        return authConstraintMD;    }
public static UserDataConstraintMetaData newUserDataConstraint(final String transportGuarantee,            final SecurityConstraintMetaData securityConstraintMD) {        final UserDataConstraintMetaData userDataConstraintMD = new UserDataConstraintMetaData();        final TransportGuaranteeType transportGuaranteeValue = TransportGuaranteeType.valueOf(transportGuarantee);        userDataConstraintMD.setTransportGuarantee(transportGuaranteeValue);        securityConstraintMD.setUserDataConstraint(userDataConstraintMD);        return userDataConstraintMD;    }
public static ParamValueMetaData newParamValue(final String key, final String value, final List<ParamValueMetaData> paramsMD) {        final ParamValueMetaData paramValueMD = WebMetaDataHelper.newParamValue(key, value);        paramsMD.add(paramValueMD);        return paramValueMD;    }
private static ParamValueMetaData newParamValue(final String key, final String value) {        final ParamValueMetaData paramMD = new ParamValueMetaData();        paramMD.setParamName(key);        paramMD.setParamValue(value);        return paramMD;    }
@Override    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final CapabilityServiceSupport support = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);        final List<DataSources> dataSourcesList = deploymentUnit.getAttachmentList(DsXmlDeploymentParsingProcessor.DATA_SOURCES_ATTACHMENT_KEY);        final boolean legacySecurityPresent = phaseContext.getDeploymentUnit().hasAttachment(SecurityAttachments.SECURITY_ENABLED);        for(DataSources dataSources : dataSourcesList) {            if (dataSources.getDrivers() != null && dataSources.getDrivers().size() > 0) {                ConnectorLogger.DS_DEPLOYER_LOGGER.driversElementNotSupported(deploymentUnit.getName());            }            ServiceTarget serviceTarget = phaseContext.getServiceTarget();            if (dataSources.getDataSource() != null && dataSources.getDataSource().size() > 0) {                for (int i = 0; i < dataSources.getDataSource().size(); i++) {                    DataSource ds = (DataSource)dataSources.getDataSource().get(i);                    if (ds.isEnabled() && ds.getDriver() != null) {                        try {                            final String jndiName = Util.cleanJndiName(ds.getJndiName(), ds.isUseJavaContext());                            LocalDataSourceService lds = new LocalDataSourceService(jndiName, ContextNames.bindInfoFor(jndiName));                            lds.getDataSourceConfigInjector().inject(buildDataSource(ds));                            final String dsName = ds.getJndiName();                            final PathAddress addr = getDataSourceAddress(dsName, deploymentUnit, false);                            installManagementModel(ds, deploymentUnit, addr);                            // TODO why have we been ignoring a configured legacy security domain but no legacy security present?                            boolean useLegacySecurity = legacySecurityPresent && isLegacySecurityRequired(ds.getSecurity());                            startDataSource(lds, jndiName, ds.getDriver(), serviceTarget,                                    getRegistration(false, deploymentUnit), getResource(dsName, false, deploymentUnit), dsName, useLegacySecurity, ds.isJTA(), support);                        } catch (Exception e) {                            throw ConnectorLogger.ROOT_LOGGER.exceptionDeployingDatasource(e, ds.getJndiName());                        }                    } else {                        ConnectorLogger.DS_DEPLOYER_LOGGER.debugf("Ignoring: %s", ds.getJndiName());                    }                }            }            if (dataSources.getXaDataSource() != null && dataSources.getXaDataSource().size() > 0) {               for (int i = 0; i < dataSources.getXaDataSource().size(); i++) {                    XaDataSource xads = (XaDataSource)dataSources.getXaDataSource().get(i);                    if (xads.isEnabled() && xads.getDriver() != null) {                        try {                            String jndiName = Util.cleanJndiName(xads.getJndiName(), xads.isUseJavaContext());                            XaDataSourceService xds = new XaDataSourceService(jndiName, ContextNames.bindInfoFor(jndiName));                            xds.getDataSourceConfigInjector().inject(buildXaDataSource(xads));                            final String dsName = xads.getJndiName();                            final PathAddress addr = getDataSourceAddress(dsName, deploymentUnit, true);                            installManagementModel(xads, deploymentUnit, addr);                            final Credential credential = xads.getRecovery() == null? null: xads.getRecovery().getCredential();                            // TODO why have we been ignoring a configured legacy security domain but no legacy security present?                            boolean useLegacySecurity = legacySecurityPresent && (isLegacySecurityRequired(xads.getSecurity())                                                        || isLegacySecurityRequired(credential));                            startDataSource(xds, jndiName, xads.getDriver(), serviceTarget,                                    getRegistration(true, deploymentUnit), getResource(dsName, true, deploymentUnit), dsName, useLegacySecurity, true, support);                        } catch (Exception e) {                            throw ConnectorLogger.ROOT_LOGGER.exceptionDeployingDatasource(e, xads.getJndiName());                        }                    } else {                        ConnectorLogger.DS_DEPLOYER_LOGGER.debugf("Ignoring %s", xads.getJndiName());                    }                }            }        }    }
@Override    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);        final ServicesAttachment servicesAttachment = deploymentUnit.getAttachment(Attachments.SERVICES);        if (module != null && servicesAttachment != null) {            final ModuleClassLoader classLoader = module.getClassLoader();            final List<String> driverNames = servicesAttachment.getServiceImplementations(Driver.class.getName());            int idx = 0;            for (String driverClassName : driverNames) {                try {                    final Class<? extends Driver> driverClass = classLoader.loadClass(driverClassName).asSubclass(Driver.class);                    final Constructor<? extends Driver> constructor = driverClass.getConstructor();                    final Driver driver = constructor.newInstance();                    final int majorVersion = driver.getMajorVersion();                    final int minorVersion = driver.getMinorVersion();                    final boolean compliant = driver.jdbcCompliant();                    if (compliant) {                        DEPLOYER_JDBC_LOGGER.deployingCompliantJdbcDriver(driverClass, Integer.valueOf(majorVersion),                                Integer.valueOf(minorVersion));                    } else {                        DEPLOYER_JDBC_LOGGER.deployingNonCompliantJdbcDriver(driverClass, Integer.valueOf(majorVersion),                                Integer.valueOf(minorVersion));                    }                    String driverName = deploymentUnit.getName();                    if ((driverName.contains(".") && ! driverName.endsWith(".jar")) || driverNames.size() != 1) {                        driverName += "_" + driverClassName + "_" + majorVersion + "_" + minorVersion;                    }                    InstalledDriver driverMetadata = new InstalledDriver(driverName, driverClass.getName(), null, null, majorVersion,                            minorVersion, compliant);                    DriverService driverService = new DriverService(driverMetadata, driver);                    phaseContext                            .getServiceTarget()                            .addService(ServiceName.JBOSS.append("jdbc-driver", driverName.replaceAll("\\.", "_")), driverService)                            .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,                                    driverService.getDriverRegistryServiceInjector()).setInitialMode(Mode.ACTIVE).install();                    if (idx == 0 && driverNames.size() != 1) {                        // create short name driver service                        driverName = deploymentUnit.getName(); // reset driverName to the deployment unit name                        driverMetadata = new InstalledDriver(driverName, driverClass.getName(), null,                                null, majorVersion, minorVersion, compliant);                        driverService = new DriverService(driverMetadata, driver);                        phaseContext.getServiceTarget()                                .addService(ServiceName.JBOSS.append("jdbc-driver", driverName.replaceAll("\\.", "_")), driverService)                                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class, driverService.getDriverRegistryServiceInjector())                                .setInitialMode(Mode.ACTIVE).install();                    }                    idx++;                } catch (Throwable e) {                    DEPLOYER_JDBC_LOGGER.cannotInstantiateDriverClass(driverClassName, e);                }            }        }    }
private InterceptorBindingMetaData readInterceptorBinding(final XMLStreamReader reader, final PropertyReplacer propertyReplacer) throws XMLStreamException {        return InterceptorBindingMetaDataParser.INSTANCE.parse(reader, propertyReplacer);    }
private void registerSessionBeanInterceptors(SessionBeanComponentDescription componentDescription, final DeploymentUnit deploymentUnit) {        // if it's a SFSB then setup appropriate interceptors        if (componentDescription.isStateful()) {            // first setup the post construct and pre destroy component interceptors            componentDescription.getConfigurators().addFirst(new ComponentConfigurator() {                @Override                public void configure(DeploymentPhaseContext context, ComponentDescription description, ComponentConfiguration configuration) throws                    DeploymentUnitProcessingException {                    configuration.addPostConstructInterceptor(SFSBPreCreateInterceptor.FACTORY, InterceptorOrder.ComponentPostConstruct.JPA_SFSB_PRE_CREATE);                    configuration.addPostConstructInterceptor(SFSBCreateInterceptor.FACTORY, InterceptorOrder.ComponentPostConstruct.JPA_SFSB_CREATE);                    configuration.addPreDestroyInterceptor(SFSBDestroyInterceptor.FACTORY, InterceptorOrder.ComponentPreDestroy.JPA_SFSB_DESTROY);                    configuration.addComponentInterceptor(SFSBInvocationInterceptor.FACTORY, InterceptorOrder.Component.JPA_SFSB_INTERCEPTOR, false);                    //we need to serialized the entity manager state                    configuration.getInterceptorContextKeys().add(SFSBInvocationInterceptor.CONTEXT_KEY);                }            });        }        // register interceptor on stateful/stateless SB with transactional entity manager.        if ((componentDescription.isStateful() || componentDescription.isStateless())) {            componentDescription.getConfigurators().add(new ComponentConfigurator() {                @Override                public void configure(DeploymentPhaseContext context, ComponentDescription description, ComponentConfiguration configuration) throws                    DeploymentUnitProcessingException {                    configuration.addComponentInterceptor(SBInvocationInterceptor.FACTORY, InterceptorOrder.Component.JPA_SESSION_BEAN_INTERCEPTOR, false);                }            });        }    }
public static TaggedComponent createCopy(TaggedComponent tc) {        TaggedComponent copy = null;        if (tc != null) {            byte[] buf = new byte[tc.component_data.length];            System.arraycopy(tc.component_data, 0, buf, 0, tc.component_data.length);            copy = new TaggedComponent(tc.tag, buf);        }        return copy;    }
public static TaggedComponent createSSLTaggedComponent(IORSecurityConfigMetaData metadata, Codec codec, int sslPort,                                                           ORB orb) {        if (metadata == null) {            IIOPLogger.ROOT_LOGGER.debug("Method createSSLTaggedComponent() called with null metadata");            return null;        }        if (sslPort == 0) {            // no support for transport security.            return null;        }        TaggedComponent tc;        try {            int supports = createTargetSupports(metadata.getTransportConfig());            int requires = createTargetRequires(metadata.getTransportConfig());            SSL ssl = new SSL((short) supports, (short) requires, (short) sslPort);            Any any = orb.create_any();            SSLHelper.insert(any, ssl);            byte[] componentData = codec.encode_value(any);            tc = new TaggedComponent(TAG_SSL_SEC_TRANS.value, componentData);        } catch (InvalidTypeForEncoding e) {            throw IIOPLogger.ROOT_LOGGER.unexpectedException(e);        }        return tc;    }
public static TaggedComponent createSecurityTaggedComponent(IORSecurityConfigMetaData metadata, Codec codec,                                                                int sslPort, ORB orb) {        if (metadata == null) {            IIOPLogger.ROOT_LOGGER.debug("Method createSecurityTaggedComponent() called with null metadata");            return null;        }        TaggedComponent tc;        // get the the supported security mechanisms.        CompoundSecMech[] mechList = createCompoundSecMechanisms(metadata, codec, sslPort, orb);        // the above is wrapped into a org.omg.CSIIOP.CompoundSecMechList structure, which is NOT a CompoundSecMech[].        // we don't support stateful/reusable security contexts (false).        CompoundSecMechList csmList = new CompoundSecMechList(false, mechList);        // finally, the CompoundSecMechList must be encoded as a TaggedComponent        try {            Any any = orb.create_any();            CompoundSecMechListHelper.insert(any, csmList);            byte[] b = codec.encode_value(any);            tc = new TaggedComponent(TAG_CSI_SEC_MECH_LIST.value, b);        } catch (InvalidTypeForEncoding e) {            throw IIOPLogger.ROOT_LOGGER.unexpectedException(e);        }        return tc;    }
public static CompoundSecMech[] createCompoundSecMechanisms(IORSecurityConfigMetaData metadata, Codec codec,                                                                int sslPort, ORB orb) {        // support just 1 security mechanism for now (and ever).        CompoundSecMech[] csmList = new CompoundSecMech[1];        // a CompoundSecMech contains: target_requires, transport_mech, as_context_mech, sas_context_mech.        TaggedComponent transport_mech = createTransportMech(metadata.getTransportConfig(), codec, sslPort, orb);        // create AS Context.        AS_ContextSec asContext = createAuthenticationServiceContext(metadata);        // create SAS Context.        SAS_ContextSec sasContext = createSecureAttributeServiceContext(metadata);        // create target_requires bit field (AssociationOption) can't read directly the transport_mech TaggedComponent.        int target_requires = createTargetRequires(metadata.getTransportConfig()) | asContext.target_requires |                sasContext.target_requires;        CompoundSecMech csm = new CompoundSecMech((short) target_requires, transport_mech, asContext, sasContext);        csmList[0] = csm;        return csmList;    }
public static SAS_ContextSec createSecureAttributeServiceContext(IORSecurityConfigMetaData metadata) {        SAS_ContextSec context;        // context contains target_supports, target_requires, privilige_authorities, supported_naming_mechanisms, supported_identity_types.        int support = 0;        int require = 0;        ServiceConfiguration[] privilAuth = new ServiceConfiguration[0];        byte[][] supNamMechs = {};        int supIdenTypes = 0; // 0 means ITTAbsent        // the the SasContext metadata.        IORSASContextMetaData sasMeta = metadata.getSasContext();        // if no SAS context metadata, or caller propagation is not supported, we return with a more or less empty sas context.        if (sasMeta == null || sasMeta.getCallerPropagation().equals(IORSASContextMetaData.CALLER_PROPAGATION_NONE)) {            context = new SAS_ContextSec((short) support, (short) require, privilAuth, supNamMechs, supIdenTypes);        } else {            support = IdentityAssertion.value;            // supporting GSSUP (username/password) naming mechanism.            byte[] upMech = createGSSUPMechOID();            supNamMechs = new byte[1][upMech.length];            System.arraycopy(upMech, 0, supNamMechs[0], 0, upMech.length);            // since we support IdentityAssertion we need to specify supported identity types. CTS says we need them all            supIdenTypes = ITTAnonymous.value | ITTPrincipalName.value | ITTX509CertChain.value | ITTDistinguishedName.value;            context = new SAS_ContextSec((short) support, (short) require, privilAuth, supNamMechs, supIdenTypes);        }        return context;    }
public static AS_ContextSec createAuthenticationServiceContext(IORSecurityConfigMetaData metadata) {        AS_ContextSec context;        // the content of the context.        int support = 0;        int require = 0;        byte[] clientAuthMech = {};        byte[] targetName = {};        IORASContextMetaData asMeta = metadata.getAsContext();        // if no AS context metatada exists, or authentication method "none" is specified, we can produce an empty AS context.        if (asMeta == null || asMeta.getAuthMethod().equals(IORASContextMetaData.AUTH_METHOD_NONE)) {            context = new AS_ContextSec((short) support, (short) require, clientAuthMech, targetName);        } else {            // we do support.            support = EstablishTrustInClient.value;            // required depends on the metadata.            if (asMeta.isRequired()) {                require = EstablishTrustInClient.value;            }            // we only support GSSUP authentication method.            clientAuthMech = createGSSUPMechOID();            // finally, encode the "realm" name as a CSI.GSS_NT_ExportedName.            // clientAuthMech should contain the DER encoded GSSUPMechOID at this point.            String realm = asMeta.getRealm();            targetName = createGSSExportedName(clientAuthMech, realm.getBytes(StandardCharsets.UTF_8));            context = new AS_ContextSec((short) support, (short) require, clientAuthMech, targetName);        }        return context;    }
public static TaggedComponent createTransportMech(IORTransportConfigMetaData tconfig, Codec codec, int sslPort, ORB orb) {        TaggedComponent tc;        // what we support and require as a target.        int support = 0;        int require = 0;        if (tconfig != null) {            require = createTargetRequires(tconfig);            support = createTargetSupports(tconfig);        }        if (tconfig == null || support == 0 || sslPort == 0) {            // no support for transport security.            tc = new TaggedComponent(TAG_NULL_TAG.value, new byte[0]);        } else {            // my ip address.            String host = CorbaORBService.getORBProperty(Constants.ORB_ADDRESS);            // this will create only one transport address.            TransportAddress[] taList = createTransportAddress(host, sslPort);            TLS_SEC_TRANS tst = new TLS_SEC_TRANS((short) support, (short) require, taList);            // The tricky part, we must encode TLS_SEC_TRANS into an octet sequence.            try {                Any any = orb.create_any();                TLS_SEC_TRANSHelper.insert(any, tst);                byte[] b = codec.encode_value(any);                tc = new TaggedComponent(TAG_TLS_SEC_TRANS.value, b);            } catch (InvalidTypeForEncoding e) {                throw IIOPLogger.ROOT_LOGGER.unexpectedException(e);            }        }        return tc;    }
public static TransportAddress[] createTransportAddress(String host, int port) {        // idl type is unsigned sort, so we need this trick        short short_port = (port > 32767) ? (short) (port - 65536) : (short) port;        TransportAddress ta = new TransportAddress(host, short_port);        TransportAddress[] taList = new TransportAddress[1];        taList[0] = ta;        return taList;    }
public static int createTargetRequires(IORTransportConfigMetaData tc) {        int requires = 0;        if (tc != null) {            if (tc.getIntegrity().equals(IORTransportConfigMetaData.INTEGRITY_REQUIRED)) {                requires = requires | Integrity.value;            }            if (tc.getConfidentiality().equals(IORTransportConfigMetaData.CONFIDENTIALITY_REQUIRED)) {                requires = requires | Confidentiality.value;            }            if (tc.getDetectMisordering().equalsIgnoreCase(IORTransportConfigMetaData.DETECT_MISORDERING_REQUIRED)) {                requires = requires | DetectMisordering.value;            }            if (tc.getDetectReplay().equalsIgnoreCase(IORTransportConfigMetaData.DETECT_REPLAY_REQUIRED)) {                requires = requires | DetectReplay.value;            }            // no EstablishTrustInTarget required - client decides            if (tc.getEstablishTrustInClient().equals(IORTransportConfigMetaData.ESTABLISH_TRUST_IN_CLIENT_REQUIRED)) {                requires = requires | EstablishTrustInClient.value;            }        }        return requires;    }
public static int createTargetSupports(IORTransportConfigMetaData tc) {        int supports = 0;        if (tc != null) {            if (!tc.getIntegrity().equals(IORTransportConfigMetaData.INTEGRITY_NONE)) {                supports = supports | Integrity.value;            }            if (!tc.getConfidentiality().equals(IORTransportConfigMetaData.CONFIDENTIALITY_NONE)) {                supports = supports | Confidentiality.value;            }            if (!tc.getDetectMisordering().equalsIgnoreCase(IORTransportConfigMetaData.DETECT_MISORDERING_NONE)) {                supports = supports | DetectMisordering.value;            }            if (!tc.getDetectReplay().equalsIgnoreCase(IORTransportConfigMetaData.DETECT_REPLAY_NONE)) {                supports = supports | DetectReplay.value;            }            if (!tc.getEstablishTrustInTarget().equals(IORTransportConfigMetaData.ESTABLISH_TRUST_IN_TARGET_NONE)) {                supports = supports | EstablishTrustInTarget.value;            }            if (!tc.getEstablishTrustInClient().equals(IORTransportConfigMetaData.ESTABLISH_TRUST_IN_CLIENT_NONE)) {                supports = supports | EstablishTrustInClient.value;            }        }        return supports;    }
public static byte[] createGSSUPMechOID() {        // kudos to org.ietf.jgss.Oid for the Oid utility need to strip the "oid:" part of the GSSUPMechOID first.        byte[] retval = {};        try {            Oid oid = new Oid(GSSUPMechOID.value.substring(4));            retval = oid.getDER();        } catch (GSSException e) {            IIOPLogger.ROOT_LOGGER.caughtExceptionEncodingGSSUPMechOID(e);        }        return retval;    }
public static byte[] createGSSExportedName(byte[] oid, byte[] name) {        int olen = oid.length;        int nlen = name.length;        // size according to spec.        int size = 2 + 2 + olen + 4 + nlen;        // allocate space for the exported name.        byte[] buf = new byte[size];        // index.        int i = 0;        // standard header.        buf[i++] = 0x04;        buf[i++] = 0x01;        // encode oid length.        buf[i++] = (byte) (olen & 0xFF00);        buf[i++] = (byte) (olen & 0x00FF);        // copy the oid in the exported name buffer.        System.arraycopy(oid, 0, buf, i, olen);        i += olen;        // encode the name length in the exported buffer.        buf[i++] = (byte) (nlen & 0xFF000000);        buf[i++] = (byte) (nlen & 0x00FF0000);        buf[i++] = (byte) (nlen & 0x0000FF00);        buf[i++] = (byte) (nlen & 0x000000FF);        // finally, copy the name bytes.        System.arraycopy(name, 0, buf, i, nlen);        return buf;    }
public static byte[] encodeInitialContextToken(InitialContextToken authToken, Codec codec) {        byte[] out;        Any any = ORB.init().create_any();        InitialContextTokenHelper.insert(any, authToken);        try {            out = codec.encode_value(any);        } catch (Exception e) {            return new byte[0];        }        int length = out.length + gssUpMechOidArray.length;        int n;        if (length < (1 << 7)) {            n = 0;        } else if (length < (1 << 8)) {            n = 1;        } else if (length < (1 << 16)) {            n = 2;        } else if (length < (1 << 24)) {            n = 3;        } else {// if (length < (1 << 32))            n = 4;        }        byte[] encodedToken = new byte[2 + n + length];        encodedToken[0] = 0x60;        if (n == 0) {            encodedToken[1] = (byte) length;        } else {            encodedToken[1] = (byte) (n | 0x80);            switch (n) {                case 1:                    encodedToken[2] = (byte) length;                    break;                case 2:                    encodedToken[2] = (byte) (length >> 8);                    encodedToken[3] = (byte) length;                    break;                case 3:                    encodedToken[2] = (byte) (length >> 16);                    encodedToken[3] = (byte) (length >> 8);                    encodedToken[4] = (byte) length;                    break;                default: // case 4:                    encodedToken[2] = (byte) (length >> 24);                    encodedToken[3] = (byte) (length >> 16);                    encodedToken[4] = (byte) (length >> 8);                    encodedToken[5] = (byte) length;            }        }        System.arraycopy(gssUpMechOidArray, 0, encodedToken, 2 + n, gssUpMechOidArray.length);        System.arraycopy(out, 0, encodedToken, 2 + n + gssUpMechOidArray.length, out.length);        return encodedToken;    }
public static InitialContextToken decodeInitialContextToken(byte[] encodedToken, Codec codec) {        if (encodedToken[0] != 0x60)            return null;        int encodedLength = 0;        int n = 0;        if (encodedToken[1] >= 0)            encodedLength = encodedToken[1];        else {            n = encodedToken[1] & 0x7F;            for (int i = 1; i <= n; i++) {                encodedLength += (encodedToken[1 + i] & 0xFF) << (n - i) * 8;            }        }        int length = encodedLength - gssUpMechOidArray.length;        byte[] encodedInitialContextToken = new byte[length];        System.arraycopy(encodedToken, 2 + n + gssUpMechOidArray.length,                encodedInitialContextToken, 0,                length);        Any any;        try {            any = codec.decode_value(encodedInitialContextToken, InitialContextTokenHelper.type());        } catch (Exception e) {            return null;        }        return InitialContextTokenHelper.extract(any);    }
public static byte[] decodeGssExportedName(byte[] encodedName) {        if (encodedName[0] != 0x04 || encodedName[1] != 0x01)            return null;        int mechOidLength = (encodedName[2] & 0xFF) << 8; //MECH_OID_LEN        mechOidLength += (encodedName[3] & 0xFF);      // MECH_OID_LEN        byte[] oidArray = new byte[mechOidLength];        System.arraycopy(encodedName, 4, oidArray, 0, mechOidLength);        for (int i = 0; i < mechOidLength; i++) {            if (gssUpMechOidArray[i] != oidArray[i]) {                return null;            }        }        int offset = 4 + mechOidLength;        int nameLength = (encodedName[offset] & 0xFF) << 24;        nameLength += (encodedName[++offset] & 0xFF) << 16;        nameLength += (encodedName[++offset] & 0xFF) << 8;        nameLength += (encodedName[++offset] & 0xFF);        byte[] name = new byte[nameLength];        System.arraycopy(encodedName, ++offset, name, 0, nameLength);        return name;    }
public static CompoundSecMech getMatchingSecurityMech(ClientRequestInfo ri, Codec codec, short clientSupports,                                                          short clientRequires) {        CompoundSecMechList csmList;        try {            TaggedComponent tc = ri.get_effective_component(org.omg.IOP.TAG_CSI_SEC_MECH_LIST.value);            Any any = codec.decode_value(tc.component_data, CompoundSecMechListHelper.type());            csmList = CompoundSecMechListHelper.extract(any);            // look for the first matching security mech.            for (int i = 0; i < csmList.mechanism_list.length; i++) {                CompoundSecMech securityMech = csmList.mechanism_list[i];                AS_ContextSec authConfig = securityMech.as_context_mech;                if ((EstablishTrustInTarget.value & (clientRequires ^ authConfig.target_supports)                        & ~authConfig.target_supports) != 0) {                    // client requires EstablishTrustInTarget, but target does not support it: skip this securityMech.                    continue;                }                if ((EstablishTrustInClient.value & (authConfig.target_requires ^ clientSupports)                        & ~clientSupports) != 0) {                    // target requires EstablishTrustInClient, but client does not support it: skip this securityMech.                    continue;                }                SAS_ContextSec identityConfig = securityMech.sas_context_mech;                if ((IdentityAssertion.value & (identityConfig.target_requires ^ clientSupports)                        & ~clientSupports) != 0) {                    // target requires IdentityAssertion, but client does not support it: skip this securityMech                    continue;                }                // found matching securityMech.                return securityMech;            }            // no matching securityMech was found.            return null;        } catch (BAD_PARAM e) {            // no component with TAG_CSI_SEC_MECH_LIST was found.            return null;        } catch (org.omg.IOP.CodecPackage.TypeMismatch e) {            // unexpected exception in codec            throw IIOPLogger.ROOT_LOGGER.unexpectedException(e);        } catch (org.omg.IOP.CodecPackage.FormatMismatch e) {            // unexpected exception in codec            throw IIOPLogger.ROOT_LOGGER.unexpectedException(e);        }    }
@Override    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {        // EE subsystem doesn't have any attributes, so make sure that the xml doesn't have any        requireNoAttributes(reader);        final ModelNode eeSubSystem = Util.createAddOperation(PathAddress.pathAddress(EeExtension.PATH_SUBSYSTEM));        // add the subsystem to the ModelNode(s)        list.add(eeSubSystem);        // elements        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            switch (Namespace.forUri(reader.getNamespaceURI())) {                case EE_1_0: {                    final Element element = Element.forName(reader.getLocalName());                    if (!encountered.add(element)) {                        throw unexpectedElement(reader);                    }                    switch (element) {                        case GLOBAL_MODULES: {                            final ModelNode model = parseGlobalModules(reader);                            eeSubSystem.get(GlobalModulesDefinition.GLOBAL_MODULES).set(model);                            break;                        }                        case EAR_SUBDEPLOYMENTS_ISOLATED: {                            final String earSubDeploymentsIsolated = parseEarSubDeploymentsIsolatedElement(reader);                            // set the ear subdeployment isolation on the subsystem operation                            EeSubsystemRootResource.EAR_SUBDEPLOYMENTS_ISOLATED.parseAndSetParameter(earSubDeploymentsIsolated, eeSubSystem, reader);                            break;                        }                        default: {                            throw unexpectedElement(reader);                        }                    }                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
protected List<BindingConfiguration> processDescriptorEntries(DeploymentUnit deploymentUnit, DeploymentDescriptorEnvironment environment, ResourceInjectionTarget resourceInjectionTarget, final ComponentDescription componentDescription, ClassLoader classLoader, DeploymentReflectionIndex deploymentReflectionIndex, final EEApplicationClasses applicationClasses) throws DeploymentUnitProcessingException {        final RemoteEnvironment remoteEnvironment = environment.getEnvironment();        List<BindingConfiguration> bindingDescriptions = new ArrayList<BindingConfiguration>();        EJBReferencesMetaData ejbRefs = remoteEnvironment.getEjbReferences();        if (ejbRefs != null) {            for (EJBReferenceMetaData ejbRef : ejbRefs) {                String name = ejbRef.getEjbRefName();                String ejbName = ejbRef.getLink();                String lookup = ejbRef.getLookupName() != null ? ejbRef.getLookupName() : ejbRef.getMappedName();                String remoteInterface = ejbRef.getRemote();                String home = ejbRef.getHome();                Class<?> remoteInterfaceType = null;                //if a home is specified this is the type that is bound                if (!isEmpty(home)) {                    try {                        remoteInterfaceType = ClassLoadingUtils.loadClass(home, deploymentUnit);                    } catch (ClassNotFoundException e) {                        throw EjbLogger.ROOT_LOGGER.failedToLoadViewClass(e, home);                    }                } else if (!isEmpty(remoteInterface)) {                    try {                        remoteInterfaceType = ClassLoadingUtils.loadClass(remoteInterface, deploymentUnit);                    } catch (ClassNotFoundException e) {                        throw EjbLogger.ROOT_LOGGER.failedToLoadViewClass(e, remoteInterface);                    }                }                if (!name.startsWith("java:")) {                    name = environment.getDefaultContext() + name;                }                // our injection (source) comes from the local (ENC) lookup, no matter what.                LookupInjectionSource injectionSource = new LookupInjectionSource(name);                //add any injection targets                remoteInterfaceType = processInjectionTargets(resourceInjectionTarget, injectionSource, classLoader, deploymentReflectionIndex, ejbRef, remoteInterfaceType);                final BindingConfiguration bindingConfiguration;                EjbInjectionSource ejbInjectionSource = null;                if (!isEmpty(lookup)) {                    if (!lookup.startsWith("java:")) {                        bindingConfiguration = new BindingConfiguration(name, new EjbLookupInjectionSource(lookup, remoteInterfaceType));                    } else {                        bindingConfiguration = new BindingConfiguration(name, new LookupInjectionSource(lookup));                    }                } else {                    if (remoteInterfaceType == null) {                        throw EjbLogger.ROOT_LOGGER.couldNotDetermineEjbRefForInjectionTarget(name, resourceInjectionTarget);                    }                    if (!isEmpty(ejbName)) {                        bindingConfiguration = new BindingConfiguration(name, ejbInjectionSource = new EjbInjectionSource(ejbName, remoteInterfaceType.getName(), name, deploymentUnit, appclient));                    } else {                        bindingConfiguration = new BindingConfiguration(name, ejbInjectionSource = new EjbInjectionSource(remoteInterfaceType.getName(), name, deploymentUnit, appclient));                    }                }                if (ejbInjectionSource != null) {                    deploymentUnit.addToAttachmentList(EjbDeploymentAttachmentKeys.EJB_INJECTIONS, ejbInjectionSource);                }                bindingDescriptions.add(bindingConfiguration);            }        }        if (remoteEnvironment instanceof Environment && !appclient) {            EJBLocalReferencesMetaData ejbLocalRefs = ((Environment) remoteEnvironment).getEjbLocalReferences();            if (ejbLocalRefs != null) {                for (EJBLocalReferenceMetaData ejbRef : ejbLocalRefs) {                    String name = ejbRef.getEjbRefName();                    String ejbName = ejbRef.getLink();                    String lookup = ejbRef.getLookupName() != null ? ejbRef.getLookupName() : ejbRef.getMappedName();                    String localInterface = ejbRef.getLocal();                    String localHome = ejbRef.getLocalHome();                    Class<?> localInterfaceType = null;                    //if a home is specified this is the type that is bound                    if (!isEmpty(localHome)) {                        try {                            localInterfaceType = ClassLoadingUtils.loadClass(localHome, deploymentUnit);                        } catch (ClassNotFoundException e) {                            throw EjbLogger.ROOT_LOGGER.failedToLoadViewClass(e, localHome);                        }                    } else if (!isEmpty(localInterface)) {                        try {                            localInterfaceType = ClassLoadingUtils.loadClass(localInterface, deploymentUnit);                        } catch (ClassNotFoundException e) {                            throw EjbLogger.ROOT_LOGGER.failedToLoadViewClass(e, localInterface);                        }                    }                    if (!name.startsWith("java:")) {                        name = environment.getDefaultContext() + name;                    }                    // our injection (source) comes from the local (ENC) lookup, no matter what.                    LookupInjectionSource injectionSource = new LookupInjectionSource(name);                    //add any injection targets                    localInterfaceType = processInjectionTargets(resourceInjectionTarget, injectionSource, classLoader, deploymentReflectionIndex, ejbRef, localInterfaceType);                    if (localInterfaceType == null) {                        throw EjbLogger.ROOT_LOGGER.couldNotDetermineEjbLocalRefForInjectionTarget(name, resourceInjectionTarget);                    }                    final BindingConfiguration bindingConfiguration;                    EjbInjectionSource ejbInjectionSource = null;                    if (!isEmpty(lookup)) {                        if (!lookup.startsWith("java:")) {                            bindingConfiguration = new BindingConfiguration(name, new EjbLookupInjectionSource(lookup, localInterfaceType));                        } else {                            bindingConfiguration = new BindingConfiguration(name, new LookupInjectionSource(lookup));                        }                    } else if (!isEmpty(ejbName)) {                        bindingConfiguration = new BindingConfiguration(name, ejbInjectionSource = new EjbInjectionSource(ejbName, localInterfaceType.getName(), name, deploymentUnit, appclient));                    } else {                        bindingConfiguration = new BindingConfiguration(name, ejbInjectionSource = new EjbInjectionSource(localInterfaceType.getName(), name, deploymentUnit, appclient));                    }                    if (ejbInjectionSource != null) {                        deploymentUnit.addToAttachmentList(EjbDeploymentAttachmentKeys.EJB_INJECTIONS, ejbInjectionSource);                    }                    bindingDescriptions.add(bindingConfiguration);                }            }        }        return bindingDescriptions;    }
protected Class<?> processInjectionTargets(final ResourceInjectionTarget resourceInjectionTarget, InjectionSource injectionSource, ClassLoader classLoader, DeploymentReflectionIndex deploymentReflectionIndex, ResourceInjectionMetaData entry, Class<?> classType) throws DeploymentUnitProcessingException {        if (entry.getInjectionTargets() != null) {            for (ResourceInjectionTargetMetaData injectionTarget : entry.getInjectionTargets()) {                final String injectionTargetClassName = injectionTarget.getInjectionTargetClass();                final String injectionTargetName = injectionTarget.getInjectionTargetName();                final AccessibleObject fieldOrMethod = getInjectionTarget(injectionTargetClassName, injectionTargetName, classLoader, deploymentReflectionIndex);                final Class<?> injectionTargetType = fieldOrMethod instanceof Field ? ((Field) fieldOrMethod).getType() : ((Method) fieldOrMethod).getParameterTypes()[0];                final String memberName = fieldOrMethod instanceof Field ? ((Field) fieldOrMethod).getName() : ((Method) fieldOrMethod).getName();                if (classType != null) {                    if (!injectionTargetType.isAssignableFrom(classType)) {                        boolean ok = false;                        if (classType.isPrimitive()) {                            if (BOXED_TYPES.get(classType).equals(injectionTargetType)) {                                ok = true;                            }                        } else if (injectionTargetType.isPrimitive()) {                            if (BOXED_TYPES.get(injectionTargetType).equals(classType)) {                                ok = true;                            }                        }                        if (!ok) {                            throw EeLogger.ROOT_LOGGER.invalidInjectionTarget(injectionTarget.getInjectionTargetName(), injectionTarget.getInjectionTargetClass(), classType);                        }                        classType = injectionTargetType;                    }                } else {                    classType = injectionTargetType;                }                final InjectionTarget injectionTargetDescription = fieldOrMethod instanceof Field ?                        new FieldInjectionTarget(injectionTargetClassName, memberName, classType.getName()) :                        new MethodInjectionTarget(injectionTargetClassName, memberName, classType.getName());                final ResourceInjectionConfiguration injectionConfiguration = new ResourceInjectionConfiguration(injectionTargetDescription, injectionSource);                resourceInjectionTarget.addResourceInjection(injectionConfiguration);            }        }        return classType;    }
@Override    public void stop(final StopContext context) {        final WeldBootstrapService bootstrapService = bootstrapSupplier.get();        if (!bootstrapService.isStarted()) {            throw WeldLogger.ROOT_LOGGER.notStarted("WeldContainer");        }        WeldLogger.DEPLOYMENT_LOGGER.stoppingWeldService(bootstrapService.getDeploymentName());        ClassLoader oldTccl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        try {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(bootstrapService.getDeployment().getModule().getClassLoader());            WeldProvider.containerShutDown(Container.instance(bootstrapService.getDeploymentName()));            bootstrapService.getBootstrap().shutdown();        } finally {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(oldTccl);            ModuleGroupSingletonProvider.removeClassLoader(bootstrapService.getDeployment().getModule().getClassLoader());        }        bootstrapService.setStarted(false);    }
public static String getJndiName(final OperationContext context, final ModelNode modelNode) throws OperationFailedException {        final String rawJndiName = JNDI_NAME.resolveModelAttribute(context, modelNode).asString();        return cleanJndiName(rawJndiName, modelNode.hasDefined(USE_JAVA_CONTEXT.getName()) && modelNode.get(USE_JAVA_CONTEXT.getName()).asBoolean());    }
@Override    public void performBoottime(OperationContext context, ModelNode operation, ModelNode model) {        MicroProfileConfigLogger.ROOT_LOGGER.activatingSubsystem();        ConfigProviderService.install(context);        context.addStep(new AbstractDeploymentChainStep() {            public void execute(DeploymentProcessorTarget processorTarget) {                processorTarget.addDeploymentProcessor(MicroProfileConfigExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_MICROPROFILE_CONFIG, new DependencyProcessor());                processorTarget.addDeploymentProcessor(MicroProfileConfigExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_MICROPROFILE_CONFIG, new SubsystemDeploymentProcessor());            }        }, OperationContext.Stage.RUNTIME);    }
private String resolveAttribute(SimpleAttributeDefinition attr, OperationContext context, ModelNode model) throws OperationFailedException {        final ModelNode node = attr.resolveModelAttribute(context, model);        return node.isDefined() ? node.asString() : null;    }
@Override    public void deploy(DeploymentPhaseContext deploymentPhase) throws DeploymentUnitProcessingException {        // get hold of the deployment unit.        final DeploymentUnit deploymentUnit = deploymentPhase.getDeploymentUnit();        // get the root of the deployment unit        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);        final EEApplicationClasses applicationClassesDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);        final EjbJarMetaData ejbJarMetaData;        final EjbJarMetaData specMetaData = parseEjbJarXml(deploymentUnit);        final EjbJarMetaData jbossMetaData = parseJBossEjb3Xml(deploymentUnit);        if (specMetaData == null) {            if (jbossMetaData == null)                return;            ejbJarMetaData = jbossMetaData;        } else if (jbossMetaData == null) {            ejbJarMetaData = specMetaData;        } else {            ejbJarMetaData = jbossMetaData.createMerged(specMetaData);        }        // Mark it as an EJB deployment        EjbDeploymentMarker.mark(deploymentUnit);        if (!deploymentUnit.hasAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_DESCRIPTION)) {            final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);            final EjbJarDescription ejbModuleDescription = new EjbJarDescription(moduleDescription, deploymentUnit.getName().endsWith(".war"));            deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_DESCRIPTION, ejbModuleDescription);        }        // attach the EjbJarMetaData to the deployment unit        deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_METADATA, ejbJarMetaData);        // if the jboss-ejb3.xml has a distinct-name configured then attach it to the deployment unit        if (jbossMetaData != null && jbossMetaData.getDistinctName() != null) {            deploymentUnit.putAttachment(org.jboss.as.ee.structure.Attachments.DISTINCT_NAME, jbossMetaData.getDistinctName());        }        if (ejbJarMetaData.getModuleName() != null) {            eeModuleDescription.setModuleName(ejbJarMetaData.getModuleName());        }        if (ejbJarMetaData.isMetadataComplete()) {            MetadataCompleteMarker.setMetadataComplete(deploymentUnit, true);        }        if (!ejbJarMetaData.isEJB3x()) {            //EJB spec 20.5.1, we do not process annotations for older deployments            MetadataCompleteMarker.setMetadataComplete(deploymentUnit, true);        }        if(ejbJarMetaData.getEnterpriseBeans() != null) {            //check for entity beans            StringBuilder beans = new StringBuilder();            boolean error = false;            for (AbstractEnterpriseBeanMetaData bean : ejbJarMetaData.getEnterpriseBeans()) {                if (bean.getEjbType() == EjbType.ENTITY) {                    if (!error) {                        error = true;                    } else {                        beans.append(", ");                    }                    beans.append(bean.getEjbName());                }            }            if (error) {                throw EjbLogger.ROOT_LOGGER.entityBeansAreNotSupported(beans.toString());            }        }    }
private static XMLStreamReader getXMLStreamReader(InputStream stream, VirtualFile ejbJarXml, XMLResolver resolver) throws DeploymentUnitProcessingException {        try {            final XMLInputFactory inputFactory = XMLInputFactory.newInstance();            inputFactory.setXMLResolver(resolver);            XMLStreamReader xmlReader = inputFactory.createXMLStreamReader(stream);            return xmlReader;        } catch (XMLStreamException xmlse) {            throw EjbLogger.ROOT_LOGGER.failedToParse(xmlse, "ejb-jar.xml: " + ejbJarXml.getPathName());        }    }
@Override    public void createPermissions(WarMetaData metaData, PolicyConfiguration pc) throws PolicyContextException {        JBossWebMetaData jbossWebMetaData = metaData.getMergedJBossWebMetaData();        HashMap<String, PatternInfo> patternMap = qualifyURLPatterns(jbossWebMetaData);        List<SecurityConstraintMetaData> secConstraints = jbossWebMetaData.getSecurityConstraints();        if (secConstraints != null) {            for (SecurityConstraintMetaData secConstraint : secConstraints) {                WebResourceCollectionsMetaData resourceCollectionsMetaData = secConstraint.getResourceCollections();                UserDataConstraintMetaData userDataConstraintMetaData = secConstraint.getUserDataConstraint();                if (resourceCollectionsMetaData != null) {                    if (secConstraint.isExcluded() || secConstraint.isUnchecked()) {                        // Process the permissions for the excluded/unchecked resources                        for (WebResourceCollectionMetaData resourceCollectionMetaData : resourceCollectionsMetaData) {                            List<String> httpMethods = new ArrayList<>(resourceCollectionMetaData.getHttpMethods());                            List<String> ommisions = resourceCollectionMetaData.getHttpMethodOmissions();                            if(httpMethods.isEmpty() && !ommisions.isEmpty()) {                                httpMethods.addAll(WebResourceCollectionMetaData.ALL_HTTP_METHODS);                                httpMethods.removeAll(ommisions);                            }                            List<String> urlPatterns = resourceCollectionMetaData.getUrlPatterns();                            for (String urlPattern : urlPatterns) {                                PatternInfo info = patternMap.get(urlPattern);                                info.descriptor=true;                                // Add the excluded methods                                if (secConstraint.isExcluded()) {                                    info.addExcludedMethods(httpMethods);                                }                                // SECURITY-63: Missing auth-constraint needs unchecked policy                                if (secConstraint.isUnchecked() && httpMethods.isEmpty()) {                                    info.isMissingAuthConstraint = true;                                } else {                                    info.missingAuthConstraintMethods.addAll(httpMethods);                                }                            }                        }                    } else {                        // Process the permission for the resources x roles                        for (WebResourceCollectionMetaData resourceCollectionMetaData : resourceCollectionsMetaData) {                            List<String> httpMethods = new ArrayList<>(resourceCollectionMetaData.getHttpMethods());                            List<String> methodOmissions = resourceCollectionMetaData.getHttpMethodOmissions();                            if(httpMethods.isEmpty() && !methodOmissions.isEmpty()) {                                httpMethods.addAll(WebResourceCollectionMetaData.ALL_HTTP_METHODS);                                httpMethods.removeAll(methodOmissions);                            }                            List<String> urlPatterns = resourceCollectionMetaData.getUrlPatterns();                            for (String urlPattern : urlPatterns) {                                // Get the qualified url pattern                                PatternInfo info = patternMap.get(urlPattern);                                info.descriptor=true;                                HashSet<String> mappedRoles = new HashSet<String>();                                secConstraint.getAuthConstraint().getRoleNames();                                List<String> authRoles = secConstraint.getAuthConstraint().getRoleNames();                                for (String role : authRoles) {                                    if ("*".equals(role)) {                                        // The wildcard ref maps to all declared security-role names                                        mappedRoles.addAll(jbossWebMetaData.getSecurityRoleNames());                                    }                                    else {                                        mappedRoles.add(role);                                    }                                }                                info.addRoles(mappedRoles, httpMethods);                                // Add the transport to methods                                if (userDataConstraintMetaData != null && userDataConstraintMetaData.getTransportGuarantee() != null)                                    info.addTransport(userDataConstraintMetaData.getTransportGuarantee().name(), httpMethods);                            }                        }                    }                }            }        }        JBossServletsMetaData servlets = jbossWebMetaData.getServlets();        List<ServletMappingMetaData> mappings = jbossWebMetaData.getServletMappings();        if(servlets != null && mappings != null) {            Map<String, List<String>> servletMappingMap = new HashMap<>();            for(ServletMappingMetaData mapping : mappings) {                List<String> list = servletMappingMap.get(mapping.getServletName());                if(list == null) {                    servletMappingMap.put(mapping.getServletName(), list = new ArrayList<>());                }                list.addAll(mapping.getUrlPatterns());            }            if(!jbossWebMetaData.isMetadataComplete()) {                for (JBossServletMetaData servlet : servlets) {                    ServletSecurityMetaData security = servlet.getServletSecurity();                    if (security != null) {                        List<String> servletMappings = servletMappingMap.get(servlet.getServletName());                        if (servletMappings != null) {                            if (security.getHttpMethodConstraints() != null) {                                for (HttpMethodConstraintMetaData s : security.getHttpMethodConstraints()) {                                    if (s.getRolesAllowed() == null || s.getRolesAllowed().isEmpty()) {                                        for (String urlPattern : servletMappings) {                                            // Get the qualified url pattern                                            PatternInfo info = patternMap.get(urlPattern);                                            if (info.descriptor) {                                                continue;                                            }                                            // Add the excluded methods                                            if (s.getEmptyRoleSemantic() == null || s.getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT) {                                                info.missingAuthConstraintMethods.add(s.getMethod());                                            } else {                                                info.addExcludedMethods(Collections.singletonList(s.getMethod()));                                            }                                            // Add the transport to methods                                            if (s.getTransportGuarantee() != null)                                                info.addTransport(s.getTransportGuarantee().name(), Collections.singletonList(s.getMethod()));                                        }                                    } else {                                        for (String urlPattern : servletMappings) {                                            // Get the qualified url pattern                                            PatternInfo info = patternMap.get(urlPattern);                                            if (info.descriptor) {                                                continue;                                            }                                            HashSet<String> mappedRoles = new HashSet<String>();                                            List<String> authRoles = s.getRolesAllowed();                                            for (String role : authRoles) {                                                if ("*".equals(role)) {                                                    // The wildcard ref maps to all declared security-role names                                                    mappedRoles.addAll(jbossWebMetaData.getSecurityRoleNames());                                                } else {                                                    mappedRoles.add(role);                                                }                                            }                                            info.addRoles(mappedRoles, Collections.singletonList(s.getMethod()));                                            // Add the transport to methods                                            if (s.getTransportGuarantee() != null)                                                info.addTransport(s.getTransportGuarantee().name(), Collections.singletonList(s.getMethod()));                                        }                                    }                                }                            }                            if (security.getRolesAllowed() == null || security.getRolesAllowed().isEmpty()) {                                for (String urlPattern : servletMappings) {                                    // Get the qualified url pattern                                    PatternInfo info = patternMap.get(urlPattern);                                    if (info.descriptor) {                                        continue;                                    }                                    // Add the excluded methods                                    if (security.getEmptyRoleSemantic() == null || security.getEmptyRoleSemantic() == EmptyRoleSemanticType.PERMIT) {                                        info.isMissingAuthConstraint = true;                                    } else {                                        Set<String> methods = new HashSet<>(WebResourceCollectionMetaData.ALL_HTTP_METHODS);                                        if (security.getHttpMethodConstraints() != null) {                                            for (HttpMethodConstraintMetaData method : security.getHttpMethodConstraints()) {                                                methods.remove(method.getMethod());                                            }                                        }                                        info.addExcludedMethods(new ArrayList<>(methods));                                    }                                    // Add the transport to methods                                    if (security.getTransportGuarantee() != null)                                        info.addTransport(security.getTransportGuarantee().name(), Collections.emptyList());                                }                            } else {                                for (String urlPattern : servletMappings) {                                    // Get the qualified url pattern                                    PatternInfo info = patternMap.get(urlPattern);                                    if (info.descriptor) {                                        continue;                                    }                                    HashSet<String> mappedRoles = new HashSet<String>();                                    List<String> authRoles = security.getRolesAllowed();                                    for (String role : authRoles) {                                        if ("*".equals(role)) {                                            // The wildcard ref maps to all declared security-role names                                            mappedRoles.addAll(jbossWebMetaData.getSecurityRoleNames());                                        } else {                                            mappedRoles.add(role);                                        }                                    }                                    info.addRoles(mappedRoles, Collections.emptyList());                                    // Add the transport to methods                                    if (security.getTransportGuarantee() != null)                                        info.addTransport(security.getTransportGuarantee().name(), Collections.emptyList());                                }                            }                        }                    }                }            }        }        // Create the permissions        for (PatternInfo info : patternMap.values()) {            String qurl = info.getQualifiedPattern();            if (info.isOverridden) {                continue;            }            // Create the excluded permissions            String[] httpMethods = info.getExcludedMethods();            if (httpMethods != null) {                // There were excluded security-constraints                WebResourcePermission wrp = new WebResourcePermission(qurl, httpMethods);                WebUserDataPermission wudp = new WebUserDataPermission(qurl, httpMethods, null);                pc.addToExcludedPolicy(wrp);                pc.addToExcludedPolicy(wudp);            }            // Create the role permissions            Iterator<Map.Entry<String, Set<String>>> roles = info.getRoleMethods();            Set<String> seenMethods = new HashSet<>();            while (roles.hasNext()) {                Map.Entry<String, Set<String>> roleMethods = roles.next();                String role = roleMethods.getKey();                Set<String> methods = roleMethods.getValue();                seenMethods.addAll(methods);                httpMethods = methods.toArray(new String[methods.size()]);                pc.addToRole(role, new WebResourcePermission(qurl, httpMethods));            }            //there are totally 7 http methods from the jacc spec (See WebResourceCollectionMetaData.ALL_HTTP_METHOD_NAMES)            final int NUMBER_OF_HTTP_METHODS = 7;            // JACC 1.1: create !(httpmethods) in unchecked perms            if(jbossWebMetaData.getDenyUncoveredHttpMethods() == null) {                if (seenMethods.size() != NUMBER_OF_HTTP_METHODS) {                    WebResourcePermission wrpUnchecked = new WebResourcePermission(qurl, "!"                            + getCommaSeparatedString(seenMethods.toArray(new String[seenMethods.size()])));                    pc.addToUncheckedPolicy(wrpUnchecked);                }            }            if (jbossWebMetaData.getDenyUncoveredHttpMethods() == null) {                // Create the unchecked permissions                String[] missingHttpMethods = info.getMissingMethods();                int length = missingHttpMethods.length;                roles = info.getRoleMethods();                if (length > 0 && !roles.hasNext()) {                    // Create the unchecked permissions WebResourcePermissions                    WebResourcePermission wrp = new WebResourcePermission(qurl, missingHttpMethods);                    pc.addToUncheckedPolicy(wrp);                } else if (!roles.hasNext()) {                    pc.addToUncheckedPolicy(new WebResourcePermission(qurl, (String) null));                }                // SECURITY-63: Missing auth-constraint needs unchecked policy                if (info.isMissingAuthConstraint) {                    pc.addToUncheckedPolicy(new WebResourcePermission(qurl, (String) null));                } else if (!info.allMethods.containsAll(WebResourceCollectionMetaData.ALL_HTTP_METHODS)) {                    List<String> methods = new ArrayList<>(WebResourceCollectionMetaData.ALL_HTTP_METHODS);                    methods.removeAll(info.allMethods);                    pc.addToUncheckedPolicy(new WebResourcePermission(qurl, methods.toArray(new String[methods.size()])));                }                if (!info.missingAuthConstraintMethods.isEmpty()) {                    pc.addToUncheckedPolicy(new WebResourcePermission(qurl, info.missingAuthConstraintMethods.toArray(new String[info.missingAuthConstraintMethods.size()])));                }            }            // Create the unchecked permissions WebUserDataPermissions            Iterator<Map.Entry<String, Set<String>>> transportConstraints = info.getTransportMethods();            while (transportConstraints.hasNext()) {                Map.Entry<String, Set<String>> transportMethods = transportConstraints.next();                String transport = transportMethods.getKey();                Set<String> methods = transportMethods.getValue();                httpMethods = new String[methods.size()];                methods.toArray(httpMethods);                WebUserDataPermission wudp = new WebUserDataPermission(qurl, httpMethods, transport);                pc.addToUncheckedPolicy(wudp);                // If the transport is "NONE", then add an exclusive WebUserDataPermission                // with the url pattern and null                if ("NONE".equals(transport)) {                    WebUserDataPermission wudp1 = new WebUserDataPermission(qurl, null);                    pc.addToUncheckedPolicy(wudp1);                } else {                    // JACC 1.1: Transport is CONFIDENTIAL/INTEGRAL, add a !(http methods)                    WebUserDataPermission wudpNonNull = new WebUserDataPermission(qurl, "!"                            + getCommaSeparatedString(httpMethods));                    pc.addToUncheckedPolicy(wudpNonNull);                }            }        }        Set<String> declaredRoles = jbossWebMetaData.getSecurityRoleNames();        declaredRoles.add(ANY_AUTHENTICATED_USER_ROLE);        /*         * Create WebRoleRefPermissions for all servlet/security-role-refs along with all the cross product of servlets and         * security-role elements that are not referenced via a security-role-ref as described in JACC section 3.1.3.2         */        JBossServletsMetaData servletsMetaData = jbossWebMetaData.getServlets();        for (JBossServletMetaData servletMetaData : servletsMetaData) {            Set<String> unrefRoles = new HashSet<String>(declaredRoles);            String servletName = servletMetaData.getName();            SecurityRoleRefsMetaData roleRefsMetaData = servletMetaData.getSecurityRoleRefs();            // Perform the unreferenced roles processing for every servlet name            if (roleRefsMetaData != null) {                for (SecurityRoleRefMetaData roleRefMetaData : roleRefsMetaData) {                    String roleRef = roleRefMetaData.getRoleLink();                    String roleName = roleRefMetaData.getRoleName();                    WebRoleRefPermission wrrp = new WebRoleRefPermission(servletName, roleName);                    pc.addToRole(roleRef, wrrp);                    // Remove the role from the unreferencedRoles                    unrefRoles.remove(roleName);                }            }            // Spec 3.1.3.2: For each servlet element in the deployment descriptor            // a WebRoleRefPermission must be added to each security-role of the            // application whose name does not appear as the rolename            // in a security-role-ref within the servlet element.            for (String unrefRole : unrefRoles) {                WebRoleRefPermission unrefP = new WebRoleRefPermission(servletName, unrefRole);                pc.addToRole(unrefRole, unrefP);            }        }        // JACC 1.1:Spec 3.1.3.2: For each security-role defined in the deployment descriptor, an        // additional WebRoleRefPermission must be added to the corresponding role by        // calling the addToRole method on the PolicyConfiguration object. The        // name of all such permissions must be the empty string, and the actions of each        // such permission must be the role-name of the corresponding role.        for (String role : declaredRoles) {            WebRoleRefPermission wrrep = new WebRoleRefPermission("", role);            pc.addToRole(role, wrrep);        }    }
static int getPatternType(String urlPattern) {        int type = EXACT;        if (urlPattern.startsWith("*."))            type = EXTENSION;        else if (urlPattern.startsWith("/") && urlPattern.endsWith("/*"))            type = PREFIX;        else if (urlPattern.equals("/"))            type = DEFAULT;        return type;    }
static HashMap<String, PatternInfo> qualifyURLPatterns(JBossWebMetaData metaData) {        ArrayList<PatternInfo> prefixList = new ArrayList<PatternInfo>();        ArrayList<PatternInfo> extensionList = new ArrayList<PatternInfo>();        ArrayList<PatternInfo> exactList = new ArrayList<PatternInfo>();        HashMap<String, PatternInfo> patternMap = new HashMap<String, PatternInfo>();        PatternInfo defaultInfo = null;        List<SecurityConstraintMetaData> constraints = metaData.getSecurityConstraints();        if (constraints != null) {            for (SecurityConstraintMetaData constraint : constraints) {                WebResourceCollectionsMetaData resourceCollectionsMetaData = constraint.getResourceCollections();                if (resourceCollectionsMetaData != null) {                    for (WebResourceCollectionMetaData resourceCollectionMetaData : resourceCollectionsMetaData) {                        List<String> urlPatterns = resourceCollectionMetaData.getUrlPatterns();                        for (String url : urlPatterns) {                            int type = getPatternType(url);                            PatternInfo info = patternMap.get(url);                            if (info == null) {                                info = new PatternInfo(url, type);                                patternMap.put(url, info);                                switch (type) {                                    case PREFIX:                                        prefixList.add(info);                                        break;                                    case EXTENSION:                                        extensionList.add(info);                                        break;                                    case EXACT:                                        exactList.add(info);                                        break;                                    case DEFAULT:                                        defaultInfo = info;                                        break;                                }                            }                        }                    }                }            }        }        JBossServletsMetaData servlets = metaData.getServlets();        List<ServletMappingMetaData> mappings = metaData.getServletMappings();        if(!metaData.isMetadataComplete() && servlets != null && mappings != null) {            Map<String, List<String>> servletMappingMap = new HashMap<>();            for(ServletMappingMetaData mapping : mappings) {                List<String> list = servletMappingMap.get(mapping.getServletName());                if(list == null) {                    servletMappingMap.put(mapping.getServletName(), list = new ArrayList<>());                }                list.addAll(mapping.getUrlPatterns());            }            for (JBossServletMetaData servlet : servlets) {                ServletSecurityMetaData security = servlet.getServletSecurity();                if(security != null) {                    List<String> servletMappings = servletMappingMap.get(servlet.getServletName());                    if(servletMappings != null) {                        for (String url : servletMappings) {                            int type = getPatternType(url);                            PatternInfo info = patternMap.get(url);                            if (info == null) {                                info = new PatternInfo(url, type);                                patternMap.put(url, info);                                switch (type) {                                    case PREFIX:                                        prefixList.add(info);                                        break;                                    case EXTENSION:                                        extensionList.add(info);                                        break;                                    case EXACT:                                        exactList.add(info);                                        break;                                    case DEFAULT:                                        defaultInfo = info;                                        break;                                }                            }                        }                    }                }            }        }        // Qualify all prefix patterns        for (int i = 0; i < prefixList.size(); i++) {            PatternInfo info = prefixList.get(i);            // Qualify by every other prefix pattern matching this pattern            for (int j = 0; j < prefixList.size(); j++) {                if (i == j)                    continue;                PatternInfo other = prefixList.get(j);                if (info.matches(other))                    info.addQualifier(other);            }            // Qualify by every exact pattern that is matched by this pattern            for (PatternInfo other : exactList) {                if (info.matches(other))                    info.addQualifier(other);            }        }        // Qualify all extension patterns        for (PatternInfo info : extensionList) {            // Qualify by every path prefix pattern            for (PatternInfo other : prefixList) {                // Any extension                info.addQualifier(other);            }            // Qualify by every matching exact pattern            for (PatternInfo other : exactList) {                if (info.isExtensionFor(other))                    info.addQualifier(other);            }        }        // Qualify the default pattern        if (defaultInfo == null) {            defaultInfo = new PatternInfo("/", DEFAULT);            patternMap.put("/", defaultInfo);        }        for (PatternInfo info : patternMap.values()) {            if (info == defaultInfo)                continue;            defaultInfo.addQualifier(info);        }        return patternMap;    }
public void internalAssociateWithJtaTx() {        isInTx = TransactionUtil.isInTx(transactionManager);        // ensure that a different XPC (with same name) is not already present in the TX        if (isInTx) {            // 7.6.3.1 throw EJBException if a different persistence context is already joined to the            // transaction (with the same puScopedName).            EntityManager existing = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);            if (existing != null && existing != this) {                // should be enough to test if not the same object                throw JpaLogger.ROOT_LOGGER.cannotUseExtendedPersistenceTransaction(puScopedName, existing, this);            } else if (existing == null) {                if (SynchronizationType.SYNCHRONIZED.equals(synchronizationType)) {                    // JPA 7.9.1 join the transaction if not already done for SynchronizationType.SYNCHRONIZED.                    underlyingEntityManager.joinTransaction();                }                // associate the entity manager with the current transaction                TransactionUtil.putEntityManagerInTransactionRegistry(puScopedName, this, transactionSynchronizationRegistry);            }        }    }
static boolean targetsPooledConnectionFactory(String server, String resourceAdapter, ServiceRegistry serviceRegistry) {        // if the resourceAdapter is not defined, the default behaviour is to create a pooled-connection-factory.        if (resourceAdapter == null || resourceAdapter.isEmpty()) {            return true;        }        ServiceName activeMQServiceName = MessagingServices.getActiveMQServiceName(server);        ServiceName pcfName = JMSServices.getPooledConnectionFactoryBaseServiceName(activeMQServiceName).append(resourceAdapter);        return serviceRegistry.getServiceNames().contains(pcfName);    }
static boolean targetsExternalPooledConnectionFactory(String resourceAdapter, ServiceRegistry serviceRegistry) {        // if the resourceAdapter is not defined, the default behaviour is to create a pooled-connection-factory.        if (resourceAdapter == null || resourceAdapter.isEmpty()) {            return false;        }        //let's look into the external-pooled-connection-factory        ServiceName pcfName = JMSServices.getPooledConnectionFactoryBaseServiceName(MessagingServices.getActiveMQServiceName("")).append(resourceAdapter);        return serviceRegistry.getServiceNames().contains(pcfName);    }
static String getActiveMQServerName(Map<String, String> properties) {        return properties.getOrDefault(SERVER, DEFAULT);    }
private static PersistenceUnitMetadata findWithinDeployment(DeploymentUnit unit, String persistenceUnitName) {        if (traceEnabled) {            ROOT_LOGGER.tracef("pu findWithinDeployment searching for %s", persistenceUnitName);        }        for (ResourceRoot root : DeploymentUtils.allResourceRoots(unit)) {            PersistenceUnitMetadataHolder holder = root.getAttachment(PersistenceUnitMetadataHolder.PERSISTENCE_UNITS);            if (holder == null || holder.getPersistenceUnits() == null) {                if (traceEnabled) {                    ROOT_LOGGER.tracef("pu findWithinDeployment skipping empty pu holder for %s", persistenceUnitName);                }                continue;            }            ambiguousPUError(unit, persistenceUnitName, holder);            persistenceUnitName = defaultPersistenceUnitName(persistenceUnitName, holder);            for (PersistenceUnitMetadata persistenceUnit : holder.getPersistenceUnits()) {                if (traceEnabled) {                    ROOT_LOGGER.tracef("findWithinDeployment check '%s' against pu '%s'", persistenceUnitName, persistenceUnit.getPersistenceUnitName());                }                if (persistenceUnitName == null || persistenceUnitName.length() == 0 || persistenceUnit.getPersistenceUnitName().equals(persistenceUnitName)) {                    if (traceEnabled) {                        ROOT_LOGGER.tracef("findWithinDeployment matched '%s' against pu '%s'", persistenceUnitName, persistenceUnit.getPersistenceUnitName());                    }                    return persistenceUnit;                }            }        }        return null;    }
private static String defaultPersistenceUnitName(String persistenceUnitName, PersistenceUnitMetadataHolder holder) {        if ((persistenceUnitName == null || persistenceUnitName.length() == 0)) {            for (PersistenceUnitMetadata persistenceUnit : holder.getPersistenceUnits()) {                String defaultPU = persistenceUnit.getProperties().getProperty(Configuration.JPA_DEFAULT_PERSISTENCE_UNIT);                if(Boolean.TRUE.toString().equals(defaultPU)) {                    persistenceUnitName = persistenceUnit.getPersistenceUnitName();                }            }        }        return persistenceUnitName;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ConnectorXmlDescriptor connectorXmlDescriptor = deploymentUnit.getAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY);        final ManagementResourceRegistration registration;        final ManagementResourceRegistration baseRegistration = deploymentUnit.getAttachment(DeploymentModelUtils.MUTABLE_REGISTRATION_ATTACHMENT);        final Resource deploymentResource = deploymentUnit.getAttachment(DeploymentModelUtils.DEPLOYMENT_RESOURCE);        final CapabilityServiceSupport support = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);        if (connectorXmlDescriptor == null) {            return;        }        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();        if (deploymentUnit.getParent() != null) {            registration = baseRegistration.getSubModel(PathAddress.pathAddress(PathElement.pathElement("subdeployment")));        } else {            registration = baseRegistration;        }        final IronJacamarXmlDescriptor ironJacamarXmlDescriptor = deploymentUnit                .getAttachment(IronJacamarXmlDescriptor.ATTACHMENT_KEY);        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);        DEPLOYMENT_CONNECTOR_LOGGER.debugf("ParsedRaDeploymentProcessor: Processing=%s", deploymentUnit);        final ClassLoader classLoader = module.getClassLoader();        Map<ResourceRoot, Index> annotationIndexes = AnnotationIndexUtils.getAnnotationIndexes(deploymentUnit);        ServiceBuilder builder = process(connectorXmlDescriptor, ironJacamarXmlDescriptor, classLoader, serviceTarget, annotationIndexes, deploymentUnit.getServiceName(),registration, deploymentResource, support);        if (builder != null) {            String bootstrapCtx = null;            if (ironJacamarXmlDescriptor != null && ironJacamarXmlDescriptor.getIronJacamar() != null && ironJacamarXmlDescriptor.getIronJacamar().getBootstrapContext() != null)                bootstrapCtx = ironJacamarXmlDescriptor.getIronJacamar().getBootstrapContext();            if (bootstrapCtx == null)                bootstrapCtx = "default";            builder.requires(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(bootstrapCtx));            //Register an empty override model regardless of we're enabled or not - the statistics listener will add the relevant childresources            if (registration.isAllowsOverride() && registration.getOverrideModel(deploymentUnit.getName()) == null) {                registration.registerOverrideModel(deploymentUnit.getName(), new OverrideDescriptionProvider() {                    @Override                    public Map<String, ModelNode> getAttributeOverrideDescriptions(Locale locale) {                        return Collections.emptyMap();                    }                    @Override                    public Map<String, ModelNode> getChildTypeOverrideDescriptions(Locale locale) {                        return Collections.emptyMap();                    }                });            }            builder.setInitialMode(Mode.ACTIVE).install();        }    }
public static boolean containsAnnotation(Class<?> javaClass, Class<? extends Annotation> requiredAnnotation) {        for (Class<?> clazz = javaClass; clazz != null && clazz != Object.class; clazz = clazz.getSuperclass()) {            // class level annotations            if (clazz == javaClass || requiredAnnotation.isAnnotationPresent(Inherited.class)) {                if (containsAnnotations(clazz.getAnnotations(), requiredAnnotation)) {                    return true;                }            }            // fields            for (Field field : clazz.getDeclaredFields()) {                if (containsAnnotations(field.getAnnotations(), requiredAnnotation)) {                    return true;                }            }            // constructors            for (Constructor<?> constructor : clazz.getConstructors()) {                if (containsAnnotations(constructor.getAnnotations(), requiredAnnotation)) {                    return true;                }                for (Annotation[] parameterAnnotations : constructor.getParameterAnnotations()) {                    if (containsAnnotations(parameterAnnotations, requiredAnnotation)) {                        return true;                    }                }            }            // methods            for (Method method : clazz.getDeclaredMethods()) {                if (containsAnnotations(method.getAnnotations(), requiredAnnotation)) {                    return true;                }                for (Annotation[] parameterAnnotations : method.getParameterAnnotations()) {                    if (containsAnnotations(parameterAnnotations, requiredAnnotation)) {                        return true;                    }                }            }        }        return false;    }
public void start(StartContext context) {        final SuspendController suspendController = suspendControllerInjectedValue.getValue();        suspendController.registerActivity(this);        final LocalTransactionContext localTransactionContext = localTransactionContextInjectedValue.getValue();        localTransactionContext.registerCreationListener(this);    }
public void stop(StopContext context) {        final SuspendController suspendController = suspendControllerInjectedValue.getValue();        suspendController.unRegisterActivity(this);        final LocalTransactionContext localTransactionContext = localTransactionContextInjectedValue.getValue();        localTransactionContext.removeCreationListener(this);    }
@Override public void suspended(ServerActivityCallback listener) {        this.suspended = true;        listenerUpdater.set(this, listener);        localTransactionContextInjectedValue.getValue().suspendRequests();        final int activeInvocationCount = activeInvocationCountUpdater.get(this);        if (activeInvocationCount == 0) {            if (gracefulTxnShutdown) {                if (activeTransactionCountUpdater.get(this) == 0) {                    this.doneSuspended();                } else {                    EjbLogger.ROOT_LOGGER.suspensionWaitingActiveTransactions(activeInvocationCount);                }            } else {                this.doneSuspended();            }        }    }
@Override public void resume() {        this.suspended = false;        localTransactionContextInjectedValue.getValue().resumeRequests();        ServerActivityCallback listener = listenerUpdater.get(this);        if (listener != null) {            listenerUpdater.compareAndSet(this, listener, null);        }        deploymentRepositoryInjectedValue.getValue().resume();    }
public boolean acceptInvocation(InterceptorContext context) throws SystemException {        if (suspended) {            if (!gracefulTxnShutdown)                return false;            // a null listener means that we are done suspending;            if (listenerUpdater.get(this) == null || activeTransactionCountUpdater.get(this) == 0)                return false;            // retrieve attachment only when we are not entirely suspended, meaning we are mid-suspension            if (!context.hasTransaction()) {                // all requests with no transaction must be rejected at this point                // we need also to block requests with new transactions, which is not being done here. Instead,                // we are relying on a future call to getTransaction in the same thread, before the invocation is executed;                // this call will throw an exception if the transaction is new, because this suspend handler                // has invoked clientTransactionContext.suspendRequests                return false;            }        }        activeInvocationCountUpdater.incrementAndGet(this);        return true;    }
public void invocationComplete() {        int activeInvocations = activeInvocationCountUpdater.decrementAndGet(this);        if (suspended && activeInvocations == 0 && (!gracefulTxnShutdown || (activeTransactionCountUpdater.get(this) == 0))) {            doneSuspended();        }    }
@Override public void transactionCreated(AbstractTransaction transaction, CreatedBy createdBy) {        activeTransactionCountUpdater.incrementAndGet(this);        try {            transaction.registerSynchronization(this);        } catch (RollbackException | IllegalStateException e) {            // it means the transaction is marked for rollback, or is prepared for commit, at this point we cannot register synchronization            decrementTransactionCount();        } catch (SystemException e) {            decrementTransactionCount();            EjbLogger.ROOT_LOGGER.debug("Unexpected exception", e);            throw new RuntimeException(e);        }    }
private void doneSuspended() {        final ServerActivityCallback oldListener = listener;        if (oldListener != null && listenerUpdater.compareAndSet(this, oldListener, null)) {            deploymentRepositoryInjectedValue.getValue().suspend();            oldListener.done();            EjbLogger.ROOT_LOGGER.suspensionComplete();        }    }
public boolean release() {        if (refcnt != null && refcnt.decrementAndGet() <= 0 && controller != null) {            controller.setMode(ServiceController.Mode.REMOVE);            return true;        }        return false;    }
public void start(StartContext context) throws StartException {        final ServiceBasedNamingStore namingStore = namingStoreValue.getValue();        controller = context.getController();        namingStore.add(controller.getName());        ROOT_LOGGER.tracef("Bound resource %s into naming store %s (service name %s)", name, namingStore, controller.getName());    }
public void stop(StopContext context) {        final ServiceBasedNamingStore namingStore = namingStoreValue.getValue();        namingStore.remove(controller.getName());        ROOT_LOGGER.tracef("Unbound resource %s into naming store %s (service name %s)", name, namingStore, context.getController().getName());    }
public static ServiceName getCapabilityServiceName(String capabilityBaseName, String... dynamicParts) {        if (capabilityServiceSupport == null) {            throw new IllegalStateException();        }        if (dynamicParts == null || dynamicParts.length == 0) {            return capabilityServiceSupport.getCapabilityServiceName(capabilityBaseName);        }        return capabilityServiceSupport.getCapabilityServiceName(capabilityBaseName, dynamicParts);    }
private List<ResourceRoot> createResourceRoots(final VirtualFile deploymentRoot, final DeploymentUnit deploymentUnit) throws IOException, DeploymentUnitProcessingException {        final List<ResourceRoot> entries = new ArrayList<ResourceRoot>();        // WEB-INF classes        final VirtualFile webinfClasses = deploymentRoot.getChild(WEB_INF_CLASSES);        if (webinfClasses.exists()) {            final ResourceRoot webInfClassesRoot = new ResourceRoot(webinfClasses.getName(), webinfClasses, null);            ModuleRootMarker.mark(webInfClassesRoot);            entries.add(webInfClassesRoot);        }        // WEB-INF lib        Map<String, MountedDeploymentOverlay> overlays = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_OVERLAY_LOCATIONS);        final VirtualFile webinfLib = deploymentRoot.getChild(WEB_INF_LIB);        if (webinfLib.exists()) {            final List<VirtualFile> archives = webinfLib.getChildren(DEFAULT_WEB_INF_LIB_FILTER);            for (final VirtualFile archive : archives) {                try {                    String relativeName = archive.getPathNameRelativeTo(deploymentRoot);                    MountedDeploymentOverlay overlay = overlays.get(relativeName);                    Closeable closable = null;                    if(overlay != null) {                        overlay.remountAsZip(false);                    } else if (archive.isFile()) {                        closable = VFS.mountZip(archive, archive, TempFileProviderService.provider());                    } else {                        closable = null;                    }                    final ResourceRoot webInfArchiveRoot = new ResourceRoot(archive.getName(), archive, new MountHandle(closable));                    ModuleRootMarker.mark(webInfArchiveRoot);                    entries.add(webInfArchiveRoot);                } catch (IOException e) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.failToProcessWebInfLib(archive), e);                }            }        }        return entries;    }
@Override    public void initialize(ExtensionContext context) {        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(new NamingSubsystemRootResourceDefinition());        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);        registration.registerSubModel(NamingBindingResourceDefinition.INSTANCE);        registration.registerSubModel(RemoteNamingResourceDefinition.INSTANCE);        if (context.isRuntimeOnlyRegistrationValid()) {            registration.registerOperationHandler(NamingSubsystemRootResourceDefinition.JNDI_VIEW, JndiViewOperation.INSTANCE, false);        }        subsystem.registerXMLElementWriter(NamingSubsystemXMLPersister.INSTANCE);    }
@Override    public void initializeParsers(ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_0, () -> new NamingSubsystem10Parser(context.getProcessType() == ProcessType.APPLICATION_CLIENT));        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_1, NamingSubsystem11Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_2, NamingSubsystem12Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_3, NamingSubsystem13Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_4, NamingSubsystem14Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_2_0, NamingSubsystem20Parser::new);    }
protected Query detachQueryNonTxInvocation(EntityManager underlyingEntityManager, Query underLyingQuery) {        if (!this.isExtendedPersistenceContext() && !this.isInTx()) {            return new QueryNonTxInvocationDetacher(underlyingEntityManager, underLyingQuery);        }        return underLyingQuery;    }
protected <T> TypedQuery<T> detachTypedQueryNonTxInvocation(EntityManager underlyingEntityManager, TypedQuery<T> underLyingQuery) {        if (!this.isExtendedPersistenceContext() && !this.isInTx()) {            return new TypedQueryNonTxInvocationDetacher<>(underlyingEntityManager, underLyingQuery);        }        return underLyingQuery;    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.PrimitiveDefHelper.narrow(                    servantToReference(new PrimitiveDefPOATie(this)));        }        return ref;    }
@Override    public void initialize(final ExtensionContext context) {        JAXRS_LOGGER.debug("Activating JAX-RS Extension");        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(JaxrsSubsystemDefinition.INSTANCE);        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);        ManagementResourceRegistration jaxrsResReg = subsystem.registerDeploymentModel(JaxrsDeploymentDefinition.INSTANCE);        jaxrsResReg.registerSubModel(DeploymentRestResourcesDefintion.INSTANCE);        subsystem.registerXMLElementWriter(parser);    }
@Override    public void initializeParsers(final ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JaxrsExtension.NAMESPACE, () -> parser);    }
private void processViewAnnotations(final DeploymentUnit deploymentUnit, final Class<?> sessionBeanClass, final SessionBeanComponentDescription sessionBeanComponentDescription) throws DeploymentUnitProcessingException {        final Collection<Class<?>> remoteBusinessInterfaces = this.getRemoteBusinessInterfaces(deploymentUnit, sessionBeanClass);        if (remoteBusinessInterfaces != null && !remoteBusinessInterfaces.isEmpty()) {            sessionBeanComponentDescription.addRemoteBusinessInterfaceViews(this.toString(remoteBusinessInterfaces));        }        // fetch the local business interfaces of the bean        Collection<Class<?>> localBusinessInterfaces = this.getLocalBusinessInterfaces(deploymentUnit, sessionBeanClass);        if (localBusinessInterfaces != null && !localBusinessInterfaces.isEmpty()) {            sessionBeanComponentDescription.addLocalBusinessInterfaceViews(this.toString(localBusinessInterfaces));        }        if (hasNoInterfaceView(sessionBeanClass)) {            sessionBeanComponentDescription.addNoInterfaceView();        }        // EJB 3.1 FR 4.9.7 & 4.9.8, if the bean exposes no views        if (hasNoViews(sessionBeanComponentDescription)) {            final Set<Class<?>> potentialBusinessInterfaces = getPotentialBusinessInterfaces(sessionBeanClass);            if (potentialBusinessInterfaces.isEmpty()) {                sessionBeanComponentDescription.addNoInterfaceView();            } else if (potentialBusinessInterfaces.size() == 1) {                sessionBeanComponentDescription.addLocalBusinessInterfaceViews(potentialBusinessInterfaces.iterator().next().getName());            } else if (isEjbVersionGreaterThanOrEqualTo32(deploymentUnit)) {                // EJB 3.2 spec states (section 4.9.7):                // ... or if the bean class is annotated with neither the Local nor the Remote annotation, all implemented interfaces (excluding the interfaces listed above)                // are assumed to be local business interfaces of the bean                sessionBeanComponentDescription.addLocalBusinessInterfaceViews(toString(potentialBusinessInterfaces));            }        }    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);        final Collection<ComponentDescription> componentConfigurations = eeModuleDescription.getComponentDescriptions();        if (componentConfigurations == null || componentConfigurations.isEmpty()) {            return;        }        for (ComponentDescription componentConfiguration : componentConfigurations) {            final CompositeIndex index = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPOSITE_ANNOTATION_INDEX);            if (index != null) {                processComponentConfig(deploymentUnit, phaseContext, index, componentConfiguration);            }        }    }
private static Set<ClassLoader> allDeploymentModuleClassLoaders(DeploymentUnit deploymentUnit) {        Set<ClassLoader> deploymentClassLoaders = new HashSet<ClassLoader>();        final DeploymentUnit topDeploymentUnit = DeploymentUtils.getTopDeploymentUnit(deploymentUnit);        final Module toplevelModule = topDeploymentUnit.getAttachment(Attachments.MODULE);        if (toplevelModule != null) {            deploymentClassLoaders.add(toplevelModule.getClassLoader());            final List<DeploymentUnit> subDeployments = topDeploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);            for (DeploymentUnit subDeploymentUnit: subDeployments) {                final Module subDeploymentModule = subDeploymentUnit.getAttachment(Attachments.MODULE);                if (subDeploymentModule != null) {                    deploymentClassLoaders.add(subDeploymentModule.getClassLoader());                }            }        }        return deploymentClassLoaders;    }
public static boolean needClassFileTransformer(PersistenceUnitMetadata pu) {        boolean result = true;        String provider = pu.getPersistenceProviderClassName();        if (pu.getProperties().containsKey(Configuration.JPA_CONTAINER_CLASS_TRANSFORMER)) {            result = Boolean.parseBoolean(pu.getProperties().getProperty(Configuration.JPA_CONTAINER_CLASS_TRANSFORMER));        }        else if (isHibernateProvider(provider)) {            result = (Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_USE_CLASS_ENHANCER))                    || Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_ENABLE_DIRTY_TRACKING))                    || Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_ENABLE_LAZY_INITIALIZATION))                    || Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT)));        }        return result;    }
public static boolean allowTwoPhaseBootstrap(PersistenceUnitMetadata pu) {        boolean result = true;        if (EE_DEFAULT_DATASOURCE.equals(pu.getJtaDataSourceName())) {            result = false;        }        if (pu.getProperties().containsKey(Configuration.JPA_ALLOW_TWO_PHASE_BOOTSTRAP)) {            result = Boolean.parseBoolean(pu.getProperties().getProperty(Configuration.JPA_ALLOW_TWO_PHASE_BOOTSTRAP));        }        return result;    }
public static boolean allowDefaultDataSourceUse(PersistenceUnitMetadata pu) {        boolean result = true;        if (pu.getProperties().containsKey(Configuration.JPA_ALLOW_DEFAULT_DATA_SOURCE_USE)) {            result = Boolean.parseBoolean(pu.getProperties().getProperty(Configuration.JPA_ALLOW_DEFAULT_DATA_SOURCE_USE));        }        return result;    }
public static boolean deferEntityDetachUntilClose(final Map<String, Object> properties) {        boolean result = false;        if ( properties.containsKey(JPA_DEFER_DETACH))            result = Boolean.parseBoolean((String)properties.get(JPA_DEFER_DETACH));        return result;    }
public static boolean skipMixedSynchronizationTypeCheck(EntityManagerFactory emf, Map targetEntityManagerProperties) {        boolean result = false;        // EntityManager properties will take priority over persistence.xml level (emf) properties        if(targetEntityManagerProperties != null && targetEntityManagerProperties.containsKey(SKIPMIXEDSYNCTYPECHECKING)) {            result = Boolean.parseBoolean((String) targetEntityManagerProperties.get(SKIPMIXEDSYNCTYPECHECKING));        }        else if(emf.getProperties() != null && emf.getProperties().containsKey(SKIPMIXEDSYNCTYPECHECKING)) {            result = Boolean.parseBoolean((String) emf.getProperties().get(SKIPMIXEDSYNCTYPECHECKING));        }        return result;    }
public static boolean allowJoinedUnsyncPersistenceContext(EntityManagerFactory emf, Map targetEntityManagerProperties) {        boolean result = false;        // EntityManager properties will take priority over persistence.xml (emf) properties        if(targetEntityManagerProperties != null && targetEntityManagerProperties.containsKey(ALLOWJOINEDUNSYNCPC)) {            result = Boolean.parseBoolean((String) targetEntityManagerProperties.get(ALLOWJOINEDUNSYNCPC));        }        else if(emf.getProperties() != null && emf.getProperties().containsKey(ALLOWJOINEDUNSYNCPC)) {            result = Boolean.parseBoolean((String) emf.getProperties().get(ALLOWJOINEDUNSYNCPC));        }        return result;    }
@Override    protected void populateModel(ModelNode operation, ModelNode strictMaxPoolModel) throws OperationFailedException {        for (AttributeDefinition attr : StrictMaxPoolResourceDefinition.ATTRIBUTES.values()) {            attr.validateAndSet(operation, strictMaxPoolModel);        }    }
public static org.omg.CORBA.Object remoteToCorba(Remote remoteObj, ORB orb)            throws ClassNotFoundException, ConfigurationException {        synchronized (CorbaUtils.class) {            if (toStubMethod == null) {                initMethodHandles();            }        }// First, get remoteObj's stub        // javax.rmi.CORBA.Stub stub = PortableRemoteObject.toStub(remoteObj);        java.lang.Object stub;        try {            stub = toStubMethod.invoke(null, new java.lang.Object[]{remoteObj});        } catch (InvocationTargetException e) {            Throwable realException = e.getTargetException();            // realException.printStackTrace();            ConfigurationException ce = IIOPLogger.ROOT_LOGGER.problemInvokingPortableRemoteObjectToStub();            ce.setRootCause(realException);            throw ce;        } catch (IllegalAccessException e) {            ConfigurationException ce = IIOPLogger.ROOT_LOGGER.cannotInvokePortableRemoteObjectToStub();            ce.setRootCause(e);            throw ce;        }// Next, make sure that the stub is javax.rmi.CORBA.Stub        if (!corbaStubClass.isInstance(stub)) {            return null;  // JRMP implementation or JRMP stub        }// Next, make sure that the stub is connected        // Invoke stub.connect(orb)        try {            connectMethod.invoke(stub, new java.lang.Object[]{orb});        } catch (InvocationTargetException e) {            Throwable realException = e.getTargetException();            // realException.printStackTrace();            if (!(realException instanceof java.rmi.RemoteException)) {                ConfigurationException ce = IIOPLogger.ROOT_LOGGER.problemInvokingStubConnect();                ce.setRootCause(realException);                throw ce;            }            // ignore RemoteException because stub might have already            // been connected        } catch (IllegalAccessException e) {            ConfigurationException ce = IIOPLogger.ROOT_LOGGER.cannotInvokeStubConnect();            ce.setRootCause(e);            throw ce;        }// Finally, return stub        return (org.omg.CORBA.Object) stub;    }
public static ORB getOrb(String server, int port, Hashtable env) {        // See if we can get info from environment        Properties orbProp;        // Extract any org.omg.CORBA properties from environment        if (env != null) {            // Get all String properties            orbProp = new Properties();            final Enumeration envProp = env.keys();            while (envProp.hasMoreElements()) {                String key = (String) envProp.nextElement();                Object val = env.get(key);                if (val instanceof String) {                    orbProp.put(key, val);                }            }            final Enumeration mainProps = orbProperties.keys();            while (mainProps.hasMoreElements()) {                String key = (String) mainProps.nextElement();                Object val = orbProperties.get(key);                if (val instanceof String) {                    orbProp.put(key, val);                }            }        } else {            orbProp = orbProperties;        }        if (server != null) {            orbProp.put("org.omg.CORBA.ORBInitialHost", server);        }        if (port >= 0) {            orbProp.put("org.omg.CORBA.ORBInitialPort", "" + port);        }        // Get Applet from environment        if (env != null) {            Object applet = env.get(Context.APPLET);            if (applet != null) {                // Create ORBs for an applet                return initAppletORB(applet, orbProp);            }        }        // Create ORBs using orbProp for a standalone application        return ORB.init(new String[0], orbProp);    }
private static ORB initAppletORB(Object applet, Properties orbProp) {        try {            Class<?> appletClass = Class.forName("java.applet.Applet", true, null);            if (!appletClass.isInstance(applet)) {                throw new ClassCastException(applet.getClass().getName());            }            // invoke the static method ORB.init(applet, orbProp);            Method method = ORB.class.getMethod("init", appletClass, Properties.class);            return (ORB) method.invoke(null, applet, orbProp);        } catch (ClassNotFoundException e) {            // java.applet.Applet doesn't exist and the applet parameter is            // non-null; so throw CCE            throw new ClassCastException(applet.getClass().getName());        } catch (NoSuchMethodException e) {            throw new AssertionError(e);        } catch (InvocationTargetException e) {            Throwable cause = e.getCause();            if (cause instanceof RuntimeException) {                throw (RuntimeException) cause;            } else if (cause instanceof Error) {                throw (Error) cause;            }            throw new AssertionError(e);        } catch (IllegalAccessException iae) {            throw new AssertionError(iae);        }    }
private static void initMethodHandles() throws ClassNotFoundException {        // Get javax.rmi.CORBA.Stub class        corbaStubClass = Class.forName("javax.rmi.CORBA.Stub");        // Get javax.rmi.CORBA.Stub.connect(org.omg.CORBA.ORB) method        try {            connectMethod = corbaStubClass.getMethod("connect", new Class[]{org.omg.CORBA.ORB.class});        } catch (NoSuchMethodException e) {            throw IIOPLogger.ROOT_LOGGER.noMethodDefForStubConnect();        }        // Get javax.rmi.PortableRemoteObject method        Class proClass = Class.forName("javax.rmi.PortableRemoteObject");        // Get javax.rmi.PortableRemoteObject(java.rmi.Remote) method        try {            toStubMethod = proClass.getMethod("toStub", new Class[]{java.rmi.Remote.class});        } catch (NoSuchMethodException e) {            throw IIOPLogger.ROOT_LOGGER.noMethodDefForPortableRemoteObjectToStub();        }    }
public static void setActiveNamingStore(final NamingStore namingStore) {        if(WildFlySecurityManager.isChecking()) {            System.getSecurityManager().checkPermission(SET_ACTIVE_NAMING_STORE);        }        ACTIVE_NAMING_STORE = namingStore;    }
public static void initializeNamingManager() {        // Setup naming environment        final String property = WildFlySecurityManager.getPropertyPrivileged(Context.URL_PKG_PREFIXES, null);        if(property == null || property.isEmpty()) {            WildFlySecurityManager.setPropertyPrivileged(Context.URL_PKG_PREFIXES, PACKAGE_PREFIXES);        } else if(!Arrays.asList(property.split(":")).contains(PACKAGE_PREFIXES)) {            WildFlySecurityManager.setPropertyPrivileged(Context.URL_PKG_PREFIXES, PACKAGE_PREFIXES + ":" + property);        }        try {            //If we are reusing the JVM. e.g. in tests we should not set this again            if (!NamingManager.hasInitialContextFactoryBuilder())                NamingManager.setInitialContextFactoryBuilder(new InitialContextFactoryBuilder());        } catch (NamingException e) {            ROOT_LOGGER.failedToSet(e, "InitialContextFactoryBuilder");        }    }
public void bind(final Name name, final Object object) throws NamingException {        check(name, JndiPermission.ACTION_BIND);        if(namingStore instanceof WritableNamingStore) {            final Name absoluteName = getAbsoluteName(name);            final Object value;            if (object instanceof Referenceable) {                value = ((Referenceable) object).getReference();            } else {                value = object;            }            if (System.getSecurityManager() == null) {                getWritableNamingStore().bind(absoluteName, value);            } else {                // The permissions check has already happened for the binding further permissions should be allowed                final NamingException e = AccessController.doPrivileged(new PrivilegedAction<NamingException>() {                    @Override                    public NamingException run() {                        try {                            getWritableNamingStore().bind(absoluteName, value);                        } catch (NamingException e) {                            return e;                        }                        return null;                    }                });                // Check that a NamingException wasn't thrown during the bind                if (e != null) {                    throw e;                }            }        } else {            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();        }    }
public void bind(final String name, final Object obj) throws NamingException {        bind(parseName(name), obj);    }
public void rebind(final Name name, Object object) throws NamingException {        check(name, JndiPermission.ACTION_REBIND);        if(namingStore instanceof WritableNamingStore) {            final Name absoluteName = getAbsoluteName(name);            if (object instanceof Referenceable) {                object = ((Referenceable) object).getReference();            }            getWritableNamingStore().rebind(absoluteName, object);        } else {            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();        }    }
public void rebind(final String name, final Object object) throws NamingException {        rebind(parseName(name), object);    }
public void unbind(final Name name) throws NamingException {        check(name, JndiPermission.ACTION_UNBIND);        if(namingStore instanceof WritableNamingStore) {            final Name absoluteName = getAbsoluteName(name);            getWritableNamingStore().unbind(absoluteName);        } else {            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();        }    }
public void rename(final Name oldName, final Name newName) throws NamingException {        //check for appropriate permissions first so that no other info leaks from this context        //in case of insufficient perms (like the fact if it is readonly or not)        check(oldName, JndiPermission.ACTION_LOOKUP | JndiPermission.ACTION_UNBIND);        check(newName, JndiPermission.ACTION_BIND);        if (namingStore instanceof WritableNamingStore) {            bind(newName, lookup(oldName));            unbind(oldName);        } else {            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();        }    }
public void rename(final String oldName, final String newName) throws NamingException {        rename(parseName(oldName), parseName(newName));    }
public NamingEnumeration<NameClassPair> list(final Name name) throws NamingException {        check(name, JndiPermission.ACTION_LIST);        try {            return namingEnumeration(namingStore.list(getAbsoluteName(name)));        } catch(CannotProceedException cpe) {            final Context continuationContext = NamingManager.getContinuationContext(cpe);            return continuationContext.list(cpe.getRemainingName());        }  catch (RequireResolveException r) {            final Object o = lookup(r.getResolve());            if (o instanceof Context) {                return ((Context)o).list(name.getSuffix(r.getResolve().size()));            }            throw notAContextException(r.getResolve());        }    }
public void destroySubcontext(final Name name) throws NamingException {        check(name, JndiPermission.ACTION_DESTROY_SUBCONTEXT);        if(!(namingStore instanceof WritableNamingStore)) {            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();        }    }
public Context createSubcontext(Name name) throws NamingException {        check(name, JndiPermission.ACTION_CREATE_SUBCONTEXT);        if(namingStore instanceof WritableNamingStore) {            final Name absoluteName = getAbsoluteName(name);            return getWritableNamingStore().createSubcontext(absoluteName);        } else {            throw NamingLogger.ROOT_LOGGER.readOnlyNamingContext();        }    }
public Object lookupLink(Name name) throws NamingException {        check(name, JndiPermission.ACTION_LOOKUP);        if (name.isEmpty()) {            return lookup(name);        }        try {            final Name absoluteName = getAbsoluteName(name);            Object link = namingStore.lookup(absoluteName);            if (!(link instanceof LinkRef) && link instanceof Reference) {                link = getObjectInstance(link, name, null);            }            return link;        } catch (Exception e) {            throw namingException(NamingLogger.ROOT_LOGGER.cannotLookupLink(), e, name);        }    }
public Name composeName(Name name, Name prefix) throws NamingException {        final Name result = (Name) prefix.clone();        if (name instanceof CompositeName) {            if (name.size() == 1) {                // name could be a nested name                final String firstComponent = name.get(0);                result.addAll(parseName(firstComponent));            } else {                result.addAll(name);            }        } else {            result.addAll(new CompositeName(name.toString()));        }        return result;    }
public String composeName(String name, String prefix) throws NamingException {        return composeName(parseName(name), parseName(prefix)).toString();    }
public Object addToEnvironment(String propName, Object propVal) throws NamingException {        final Object existing = environment.get(propName);        environment.put(propName, propVal);        return existing;    }
public void addNamingListener(final Name target, final int scope, final NamingListener listener) throws NamingException {        check(target, JndiPermission.ACTION_ADD_NAMING_LISTENER);        namingStore.addNamingListener(target, scope, listener);    }
public void addNamingListener(final String target, final int scope, final NamingListener listener) throws NamingException {        addNamingListener(parseName(target), scope, listener);    }
public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration configuration) throws DeploymentUnitProcessingException {        final ComponentNamingMode namingMode = description.getNamingMode();        final InjectedEENamespaceContextSelector selector = new InjectedEENamespaceContextSelector();        final String applicationName = configuration.getApplicationName();        final String moduleName = configuration.getModuleName();        final String compName = configuration.getComponentName();        final ServiceName appContextServiceName = ContextNames.contextServiceNameOfApplication(applicationName);        final ServiceName moduleContextServiceName = ContextNames.contextServiceNameOfModule(applicationName, moduleName);        final ServiceName compContextServiceName = ContextNames.contextServiceNameOfComponent(applicationName, moduleName, compName);        final Injector<NamingStore> appInjector = selector.getAppContextInjector();        final Injector<NamingStore> moduleInjector = selector.getModuleContextInjector();        final Injector<NamingStore> compInjector = selector.getCompContextInjector();        final Injector<NamingStore> jbossInjector = selector.getJbossContextInjector();        final Injector<NamingStore> globalInjector = selector.getGlobalContextInjector();        final Injector<NamingStore> exportedInjector = selector.getExportedContextInjector();        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {            public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) {                serviceBuilder.addDependency(appContextServiceName, NamingStore.class, appInjector);                serviceBuilder.addDependency(moduleContextServiceName, NamingStore.class, moduleInjector);                if (namingMode == ComponentNamingMode.CREATE) {                    serviceBuilder.addDependency(compContextServiceName, NamingStore.class, compInjector);                } else if(namingMode == ComponentNamingMode.USE_MODULE) {                    serviceBuilder.addDependency(moduleContextServiceName, NamingStore.class, compInjector);                }                serviceBuilder.addDependency(ContextNames.GLOBAL_CONTEXT_SERVICE_NAME, NamingStore.class, globalInjector);                serviceBuilder.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, NamingStore.class, jbossInjector);                serviceBuilder.addDependency(ContextNames.EXPORTED_CONTEXT_SERVICE_NAME, NamingStore.class, exportedInjector);            }        });        final InterceptorFactory interceptorFactory = new ImmediateInterceptorFactory(new NamespaceContextInterceptor(selector, context.getDeploymentUnit().getServiceName()));        configuration.addPostConstructInterceptor(interceptorFactory, InterceptorOrder.ComponentPostConstruct.JNDI_NAMESPACE_INTERCEPTOR);        configuration.addPreDestroyInterceptor(interceptorFactory, InterceptorOrder.ComponentPreDestroy.JNDI_NAMESPACE_INTERCEPTOR);        if(description.isPassivationApplicable()) {            configuration.addPrePassivateInterceptor(interceptorFactory, InterceptorOrder.ComponentPassivation.JNDI_NAMESPACE_INTERCEPTOR);            configuration.addPostActivateInterceptor(interceptorFactory, InterceptorOrder.ComponentPassivation.JNDI_NAMESPACE_INTERCEPTOR);        }        configuration.setNamespaceContextInterceptorFactory(interceptorFactory);        configuration.setNamespaceContextSelector(selector);    }
@Override    public void registerOperations(ManagementResourceRegistration container) {        super.registerOperations(container);        container.registerOperationHandler(ADD_MIME, MimeMappingAdd.INSTANCE);        container.registerOperationHandler(REMOVE_MIME, MimeMappingRemove.INSTANCE);    }
private void validateDefaultValues(List<ParamDetail> detailList,                                       HashMap<String, List<Validator>> paramConverterMap)            throws DeploymentUnitProcessingException {        for(ParamDetail detail : detailList) {            // check param converter for specific return type            List<Validator> validators = paramConverterMap.get(                    detail.parameter.getName());            if (validators == null) {                // check for paramConverterProvider                validators = paramConverterMap.get(Object.class.getName());            }            boolean isCheckClazzMethods = true;            if (validators != null) {                for (Validator v : validators) {                    if (!v.isLazyLoad()) {                        try {                            Object obj = v.verify(detail);                            if (obj != null) {                                isCheckClazzMethods = false;                                break;                            }                        } catch (Exception e) {                            JAXRS_LOGGER.paramConverterFailed(detail.defaultValue.value(),                                    detail.parameter.getSimpleName(),                                    detail.method.toString(),                                    v.toString(), e.getClass().getName(),                                    e.getMessage());                        }                    }                }            }            if (isCheckClazzMethods) {                Class baseType = detail.parameter;                Method valueOf = null;                // constructor rule                try {                    Constructor<?> ctor = baseType.getConstructor(String.class);                    if (Modifier.isPublic(ctor.getModifiers())) {                        continue; // success move to next detail                    }                } catch (NoSuchMethodException ignored) { }                // method fromValue(String.class) rule                try {                    Method fromValue = baseType.getDeclaredMethod("fromValue", String.class);                    if (Modifier.isPublic(fromValue.getModifiers())) {                        for (Annotation ann : baseType.getAnnotations()) {                            if (ann.annotationType().getName()                                    .equals("javax.xml.bind.annotation.XmlEnum")) {                                valueOf = fromValue;                            }                        }                        validateBaseType(fromValue, detail.defaultValue.value(), detail);                        continue; // success move to next detail                    }                } catch (NoSuchMethodException ignoredA) { }                // method fromString(String.class) rule                Method fromString = null;                try {                    fromString = baseType.getDeclaredMethod("fromString", String.class);                    if (Modifier.isStatic(fromString.getModifiers())) {                        validateBaseType(fromString, detail.defaultValue.value(), detail);                        continue; // success move to next detail                    }                } catch (NoSuchMethodException ignoredB) {                }                // method valueof(String.class) rule                try {                    valueOf = baseType.getDeclaredMethod("valueOf", String.class);                    if (Modifier.isStatic(valueOf.getModifiers())) {                        validateBaseType(valueOf, detail.defaultValue.value(), detail);                        continue; // success move to next detail                    }                } catch (NoSuchMethodException ignored) {                }            }        }    }
private HashMap<String, List<Validator>>  getParamConverters(            final CompositeIndex index, final ClassLoader classLoader,            Set<String> knownProviderClasses, boolean isFromUnitTest) {        HashMap<String, List<Validator>> paramConverterMap = new HashMap<>();        List<Validator> converterProviderList = new ArrayList<>();        paramConverterMap.put(Object.class.getName(), converterProviderList);        Set<ClassInfo> paramConverterSet = new HashSet<ClassInfo>();        if(isFromUnitTest) {            Indexer indexer = new Indexer();            for (String className : knownProviderClasses) {                try {                    String pathName = className.replace(".", File.separator);                    InputStream stream = classLoader.getResourceAsStream(                            pathName + ".class");                    indexer.index(stream);                    stream.close();                } catch (IOException e) {                    JAXRS_LOGGER.classIntrospectionFailure(e.getClass().getName(),                            e.getMessage());                }            }            List<ClassInfo> paramConverterList =                    indexer.complete().getKnownDirectImplementors(PARAM_CONVERTER_DOTNAME);            List<ClassInfo> paramConverterProviderList =                    indexer.complete().getKnownDirectImplementors(PARAM_CONVERTER_PROVIDER_DOTNAME);            paramConverterSet.addAll(paramConverterList);            paramConverterSet.addAll(paramConverterProviderList);        } else {            for (String clazzName : knownProviderClasses) {                ClassInfo classInfo = index.getClassByName(DotName.createSimple(clazzName));                if (classInfo != null) {                    List<DotName> intfNamesList = classInfo.interfaceNames();                    for (DotName dotName : intfNamesList) {                        if (dotName.compareTo(PARAM_CONVERTER_DOTNAME) == 0                                || dotName.compareTo(PARAM_CONVERTER_PROVIDER_DOTNAME) == 0) {                            paramConverterSet.add(classInfo);                            break;                        }                    }                }            }        }        for (ClassInfo classInfo : paramConverterSet) {            Class<?> clazz = null;            Method method = null;            try {                String clazzName = classInfo.name().toString();                if (clazzName.endsWith("$1")) {                    clazzName = clazzName.substring(0, clazzName.length()-2);                }                clazz = classLoader.loadClass(clazzName);                Constructor<?> ctor = clazz.getConstructor();                Object object = ctor.newInstance();                List<AnnotationInstance> lazyLoadAnnotations =classInfo                        .annotations().get(PARAM_CONVERTER_LAZY_DOTNAME);                if (object instanceof ParamConverterProvider) {                    ParamConverterProvider pcpObj = (ParamConverterProvider) object;                    method = pcpObj.getClass().getMethod(                            "getConverter",                            Class.class,                            Type.class,                            Annotation[].class);                    converterProviderList.add(new ConverterProvider(pcpObj, method, lazyLoadAnnotations));                }                if (object instanceof ParamConverter) {                    ParamConverter pc = (ParamConverter) object;                    method = getFromStringMethod(pc.getClass());                    Class<?> returnClazz = method.getReturnType();                    List<Validator> verifiers = paramConverterMap.get(returnClazz.getName());                    PConverter pConverter = new PConverter(pc, method, lazyLoadAnnotations);                    if (verifiers == null){                        List<Validator> vList = new ArrayList<>();                        vList.add(pConverter);                        paramConverterMap.put(returnClazz.getName(), vList);                    } else {                        verifiers.add(pConverter);                    }                }            } catch(NoSuchMethodException nsne) {                JAXRS_LOGGER.classIntrospectionFailure(nsne.getClass().getName(),                        nsne.getMessage());            } catch (Exception e) {                JAXRS_LOGGER.classIntrospectionFailure(e.getClass().getName(),                        e.getMessage());            }        }        return paramConverterMap;    }
private ArrayList<ParamDetail> getResouceClasses(final CompositeIndex index,                                   final ClassLoader classLoader,                                   Set<String> knownResourceClasses,                                   boolean isFromUnitTest) {        ArrayList<ParamDetail> detailList = new ArrayList<>();        ArrayList<String> classNameArr = new ArrayList<>();        if (isFromUnitTest) {            Indexer indexer = new Indexer();            for (String className : knownResourceClasses) {                try {                    String pathName = className.replace(".", File.separator);                    InputStream stream = classLoader.getResourceAsStream(pathName + ".class");                    ClassInfo classInfo = indexer.index(stream);                    List<AnnotationInstance> defaultValuesList =                            classInfo.annotations().get(DEFAULT_VALUE_DOTNAME);                    if (!defaultValuesList.isEmpty()) {                        classNameArr.add((classInfo).name().toString());                    }                    stream.close();                } catch (IOException e) {                    JAXRS_LOGGER.classIntrospectionFailure(e.getClass().getName(),                            e.getMessage());                }            }        } else {            for (String clazzName : knownResourceClasses) {                ClassInfo classInfo = index.getClassByName(DotName.createSimple(clazzName));                if (classInfo != null) {                    Map<DotName, List<AnnotationInstance>> annotationsMap =                            classInfo.annotations();                    if (annotationsMap != null && !annotationsMap.isEmpty()) {                        List<AnnotationInstance> xInstance = annotationsMap.get(                                JaxrsAnnotations.PATH.getDotName());                        List<AnnotationInstance> xdefaultValuesList =                                annotationsMap.get(DEFAULT_VALUE_DOTNAME);                        if ((xInstance != null && !xInstance.isEmpty()) &&                             (xdefaultValuesList != null && !xdefaultValuesList.isEmpty())) {                            classNameArr.add((classInfo).name().toString());                        }                    }                }            }        }        // resource classes with @DefaultValue        // find methods and method params with @DefaultValue        for (String className : classNameArr) {            Class<?> clazz = null;            try {                clazz = classLoader.loadClass(className);                for (Method method : clazz.getMethods()) {                    if (clazz == method.getDeclaringClass()) {                        Type[] genParamTypeArr = method.getGenericParameterTypes();                        Annotation[][] annotationMatrix = method.getParameterAnnotations();                        for (int j = 0; j < genParamTypeArr.length; j++) {                            DefaultValue defaultValue = lookupDefaultValueAnn(annotationMatrix[j]);                            if (defaultValue != null) {                                Class paramClazz = checkParamType(genParamTypeArr[j],                                        method, j, classLoader);                                if (paramClazz != null) {                                    detailList.add(new ParamDetail(method,                                            defaultValue, paramClazz, annotationMatrix[j]));                                }                            }                        }                    }                }            } catch (ClassNotFoundException e) {                JAXRS_LOGGER.classIntrospectionFailure(e.getClass().getName(),                        e.getMessage());            }        }        return detailList;    }
private Class checkParamType(Type genParamType, final Method method,                                 final int paramPos, final ClassLoader classLoader){        Class paramClazz = null;        if (genParamType instanceof ParameterizedType) {            ParameterizedType pType = (ParameterizedType) genParamType;            Type[] actualTypeArgs = pType.getActualTypeArguments();            // skip Map types. Don't know how to set default value for these            if (actualTypeArgs.length == 1) {                try {                    paramClazz = classLoader.loadClass(actualTypeArgs[0].getTypeName());                } catch (Exception ee) {                    JAXRS_LOGGER.classIntrospectionFailure(ee.getClass().getName(),                            ee.getMessage());                }            }        } else {            Class<?>[] paramArr = method.getParameterTypes();            if (paramArr[paramPos].isArray()) {                Class compClazz = paramArr[paramPos].getComponentType();                if (!compClazz.isPrimitive()) {                    paramClazz = compClazz;                }            } else {                if (!paramArr[paramPos].isPrimitive()) {                    paramClazz = paramArr[paramPos];                }            }        }        return paramClazz;    }
private DefaultValue lookupDefaultValueAnn(Annotation[] annotationArr) {        for (Annotation ann :  annotationArr) {            if (ann instanceof DefaultValue) {                return (DefaultValue)ann;            }        }        return null;    }
private void validateBaseType(Method method, String defaultValue, ParamDetail detail)        throws DeploymentUnitProcessingException {        if (defaultValue != null) {            try {                method.invoke(method.getDeclaringClass(), defaultValue);            } catch (Exception e) {                JAXRS_LOGGER.baseTypeMethodFailed(defaultValue,                        detail.parameter.getSimpleName(), detail.method.toString(),                        method.toString(), e.getClass().getName(),                        e.getMessage());            }        }    }
@Override    public void initialize(ExtensionContext context) {        final boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        subsystem.registerXMLElementWriter(EJB3SubsystemXMLPersister.INSTANCE);        PathManager pathManager = context.getProcessType().isServer() ? context.getPathManager() : null;        subsystem.registerSubsystemModel(new EJB3SubsystemRootResourceDefinition(registerRuntimeOnly, pathManager));        if (registerRuntimeOnly) {            ResourceDefinition deploymentsDef = new SimpleResourceDefinition(new Parameters(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, SUBSYSTEM_NAME),                    getResourceDescriptionResolver("deployed")).setFeature(false));            final ManagementResourceRegistration deploymentsRegistration = subsystem.registerDeploymentModel(deploymentsDef);            deploymentsRegistration.registerSubModel(MessageDrivenBeanResourceDefinition.INSTANCE);            deploymentsRegistration.registerSubModel(SingletonBeanDeploymentResourceDefinition.INSTANCE);            deploymentsRegistration.registerSubModel(StatelessSessionBeanDeploymentResourceDefinition.INSTANCE);            deploymentsRegistration.registerSubModel(StatefulSessionBeanDeploymentResourceDefinition.INSTANCE);        }    }
@Override    public void initializeParsers(ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_0, EJB3Subsystem10Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_1, EJB3Subsystem11Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_2, EJB3Subsystem12Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_3, EJB3Subsystem13Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_4, EJB3Subsystem14Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_1_5, EJB3Subsystem15Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_2_0, EJB3Subsystem20Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_3_0, EJB3Subsystem30Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_4_0, EJB3Subsystem40Parser::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, NAMESPACE_5_0, EJB3Subsystem50Parser::new);    }
public static void registerPersistenceContext(ExtendedEntityManager xpc) {        if (xpc == null) {            throw JpaLogger.ROOT_LOGGER.nullParameter("SFSBXPCMap.RegisterPersistenceContext", "EntityManager");        }        final List<ExtendedEntityManager> store = deferToPostConstruct.get();        store.add(xpc);    }
public static ExtendedEntityManager[] getDeferredEntityManagers() {        List<ExtendedEntityManager> store = deferToPostConstruct.get();        try {            if(store.isEmpty()) {                return EMPTY;            } else {                return store.toArray(new ExtendedEntityManager[store.size()]);            }        } finally {            store.clear();        }    }
public static String statusAsString(int status) {        if (status >= Status.STATUS_ACTIVE && status <= Status.STATUS_ROLLING_BACK) {            return TxStatusStrings[status];        } else {            return "STATUS_INVALID(" + status + ")";        }    }
private void checkNoAttributesIsDefined(String definedAttributeName, PathAddress address, ModelNode model, AttributeDefinition... attrs) throws OperationFailedException {        List<String> definedAttributes = new ArrayList<>();        for(AttributeDefinition attr : attrs) {            if (model.get(attr.getName()).isDefined()) {                definedAttributes.add(attr.getName());            }        }        if (!definedAttributes.isEmpty()) {            MessagingLogger.ROOT_LOGGER.invalidConfiguration(address, definedAttributeName, definedAttributes);        }    }
public static void beforeEntityManagerFactoryCreate(Classification cacheType, PersistenceUnitMetadata persistenceUnitMetadata) {        for(EventListener eventListener: eventListeners) {            eventListener.beforeEntityManagerFactoryCreate(cacheType, persistenceUnitMetadata);        }    }
public static void afterEntityManagerFactoryCreate(Classification cacheType, PersistenceUnitMetadata persistenceUnitMetadata) {        for(EventListener eventListener: eventListeners) {            eventListener.afterEntityManagerFactoryCreate(cacheType, persistenceUnitMetadata);        }    }
public static Wrapper startCache(Classification cacheType, Properties properties) throws Exception {        Wrapper result = null;        for(EventListener eventListener: eventListeners) {            Wrapper value = eventListener.startCache(cacheType, properties);            if (value != null && result == null) {                result = value;     // return the first non-null wrapper value returned from a listener            }        }        return result;    }
public static void addCacheDependencies(Classification cacheType, Properties properties) {        for(EventListener eventListener: eventListeners) {            eventListener.addCacheDependencies(cacheType, properties);        }    }
public static void stopCache(Classification cacheType, Wrapper wrapper) {        for(EventListener eventListener: eventListeners) {            eventListener.stopCache(cacheType, wrapper);        }    }
@Override    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);        ModelNode node = context.getModelNode();        writer.writeStartElement(Element.CORE_ENVIRONMENT.getLocalName());        TransactionSubsystemRootResourceDefinition.NODE_IDENTIFIER.marshallAsAttribute(node, writer);        writeProcessId(writer, node);        writer.writeEndElement();        if (TransactionSubsystemRootResourceDefinition.BINDING.isMarshallable(node) ||                TransactionSubsystemRootResourceDefinition.STATUS_BINDING.isMarshallable(node) ||                TransactionSubsystemRootResourceDefinition.RECOVERY_LISTENER.isMarshallable(node)) {            writer.writeStartElement(Element.RECOVERY_ENVIRONMENT.getLocalName());            TransactionSubsystemRootResourceDefinition.BINDING.marshallAsAttribute(node, writer);            TransactionSubsystemRootResourceDefinition.STATUS_BINDING.marshallAsAttribute(node, writer);            TransactionSubsystemRootResourceDefinition.RECOVERY_LISTENER.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if (TransactionSubsystemRootResourceDefinition.STATISTICS_ENABLED.isMarshallable(node)                || TransactionSubsystemRootResourceDefinition.ENABLE_TSM_STATUS.isMarshallable(node)                || TransactionSubsystemRootResourceDefinition.DEFAULT_TIMEOUT.isMarshallable(node)                || TransactionSubsystemRootResourceDefinition.MAXIMUM_TIMEOUT.isMarshallable(node)) {            writer.writeStartElement(Element.COORDINATOR_ENVIRONMENT.getLocalName());            TransactionSubsystemRootResourceDefinition.STATISTICS_ENABLED.marshallAsAttribute(node, writer);            TransactionSubsystemRootResourceDefinition.ENABLE_TSM_STATUS.marshallAsAttribute(node, writer);            TransactionSubsystemRootResourceDefinition.DEFAULT_TIMEOUT.marshallAsAttribute(node, writer);            TransactionSubsystemRootResourceDefinition.MAXIMUM_TIMEOUT.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if (TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.isMarshallable(node)                || TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH.isMarshallable(node)) {            writer.writeStartElement(Element.OBJECT_STORE.getLocalName());            TransactionSubsystemRootResourceDefinition.OBJECT_STORE_PATH.marshallAsAttribute(node, writer);            TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if(node.hasDefined(CommonAttributes.JTS) && node.get(CommonAttributes.JTS).asBoolean()) {            writer.writeStartElement(Element.JTS.getLocalName());            writer.writeEndElement();        }        if(node.hasDefined(CommonAttributes.USE_JOURNAL_STORE) && node.get(CommonAttributes.USE_JOURNAL_STORE).asBoolean()) {            writer.writeStartElement(Element.USE_JOURNAL_STORE.getLocalName());            TransactionSubsystemRootResourceDefinition.JOURNAL_STORE_ENABLE_ASYNC_IO.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if (node.hasDefined(CommonAttributes.USE_JDBC_STORE) && node.get(CommonAttributes.USE_JDBC_STORE).asBoolean()) {            writer.writeStartElement(Element.JDBC_STORE.getLocalName());            TransactionSubsystemRootResourceDefinition.JDBC_STORE_DATASOURCE.marshallAsAttribute(node, writer);            if (TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_TABLE_PREFIX.isMarshallable(node)                    || TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_DROP_TABLE.isMarshallable(node)) {                writer.writeEmptyElement(Element.JDBC_ACTION_STORE.getLocalName());                TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_TABLE_PREFIX.marshallAsAttribute(node, writer);                TransactionSubsystemRootResourceDefinition.JDBC_ACTION_STORE_DROP_TABLE.marshallAsAttribute(node, writer);            }            if (TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_TABLE_PREFIX.isMarshallable(node)                    || TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_DROP_TABLE.isMarshallable(node)) {                writer.writeEmptyElement(Element.JDBC_COMMUNICATION_STORE.getLocalName());                TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_TABLE_PREFIX.marshallAsAttribute(node, writer);                TransactionSubsystemRootResourceDefinition.JDBC_COMMUNICATION_STORE_DROP_TABLE.marshallAsAttribute(node, writer);            }            if (TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_TABLE_PREFIX.isMarshallable(node)                    || TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_DROP_TABLE.isMarshallable(node)) {                writer.writeEmptyElement(Element.JDBC_STATE_STORE.getLocalName());                TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_TABLE_PREFIX.marshallAsAttribute(node, writer);                TransactionSubsystemRootResourceDefinition.JDBC_STATE_STORE_DROP_TABLE.marshallAsAttribute(node, writer);            }            writer.writeEndElement();        }        if (node.hasDefined(CommonAttributes.CM_RESOURCE) && node.get(CommonAttributes.CM_RESOURCE).asList().size() > 0) {            writer.writeStartElement(Element.CM_RESOURCES.getLocalName());            for (Property cmr : node.get(CommonAttributes.CM_RESOURCE).asPropertyList()) {                writer.writeStartElement(CommonAttributes.CM_RESOURCE);                writer.writeAttribute(Attribute.JNDI_NAME.getLocalName(), cmr.getName());                if (cmr.getValue().hasDefined(CMResourceResourceDefinition.CM_TABLE_NAME.getName()) ||                        cmr.getValue().hasDefined(CMResourceResourceDefinition.CM_TABLE_BATCH_SIZE.getName()) ||                        cmr.getValue().hasDefined(CMResourceResourceDefinition.CM_TABLE_IMMEDIATE_CLEANUP.getName())) {                    writer.writeStartElement(Element.CM_TABLE.getLocalName());                    CMResourceResourceDefinition.CM_TABLE_NAME.marshallAsAttribute(cmr.getValue(), writer);                    CMResourceResourceDefinition.CM_TABLE_BATCH_SIZE.marshallAsAttribute(cmr.getValue(), writer);                    CMResourceResourceDefinition.CM_TABLE_IMMEDIATE_CLEANUP.marshallAsAttribute(cmr.getValue(), writer);                    writer.writeEndElement();                }                writer.writeEndElement();            }            writer.writeEndElement();        }        writer.writeEndElement();    }
private void extractDialects() {        for (Object prop : sql.keySet()) {            int dot = ((String)prop).indexOf('.');            if (dot > 0) {                databaseDialects.add(((String)prop).substring(dot+1));            }        }    }
private void investigateDialect() {        Connection connection = null;        if (database == null) {            // no database dialect from configuration guessing from MetaData            try {                connection = dataSource.getConnection();                DatabaseMetaData metaData = connection.getMetaData();                String dbProduct = metaData.getDatabaseProductName();                database = identifyDialect(dbProduct);                if (database == null) {                    EjbLogger.EJB3_TIMER_LOGGER.debug("Attempting to guess on driver name.");                    database = identifyDialect(metaData.getDriverName());                }            } catch (Exception e) {                EjbLogger.EJB3_TIMER_LOGGER.debug("Unable to read JDBC metadata.", e);            } finally {                safeClose(connection);            }            if (database == null) {                EjbLogger.EJB3_TIMER_LOGGER.jdbcDatabaseDialectDetectionFailed(databaseDialects.toString());            } else {                EjbLogger.EJB3_TIMER_LOGGER.debugf("Detect database dialect as '%s'.  If this is incorrect, please specify the correct dialect using the 'database' attribute in your configuration.  Supported database dialect strings are %s", database, databaseDialects);            }        } else {            EjbLogger.EJB3_TIMER_LOGGER.debugf("Database dialect '%s' read from configuration, adjusting it to match the final database valid value.", database);            database = identifyDialect(database);            EjbLogger.EJB3_TIMER_LOGGER.debugf("New Database dialect is '%s'.", database);        }    }
private String identifyDialect(String name) {        String unified = null;        if (name != null) {            if (name.toLowerCase().contains("postgres")) {               unified = "postgresql";            } else if (name.toLowerCase().contains("mysql")) {                unified = "mysql";            } else if (name.toLowerCase().contains("mariadb")) {                unified = "mariadb";            } else if (name.toLowerCase().contains("db2")) {                unified = "db2";            } else if (name.toLowerCase().contains("hsql") || name.toLowerCase().contains("hypersonic")) {                unified = "hsql";            } else if (name.toLowerCase().contains("h2")) {                unified = "h2";            } else if (name.toLowerCase().contains("oracle")) {                unified = "oracle";            }else if (name.toLowerCase().contains("microsoft")) {                unified = "mssql";            }else if (name.toLowerCase().contains("jconnect")) {                unified = "sybase";            }         }        EjbLogger.EJB3_TIMER_LOGGER.debugf("Check dialect for '%s', result is '%s'", name, unified);        return unified;    }
private void checkDatabase() {        String loadTimer = sql(LOAD_TIMER);        Connection connection = null;        Statement statement = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try {            //test for the existence of the table by running the load timer query            connection = dataSource.getConnection();            if (connection.getTransactionIsolation() < Connection.TRANSACTION_READ_COMMITTED) {                EjbLogger.EJB3_TIMER_LOGGER.wrongTransactionIsolationConfiguredForTimer();            }            preparedStatement = connection.prepareStatement(loadTimer);            preparedStatement.setString(1, "NON-EXISTENT");            preparedStatement.setString(2, "NON-EXISTENT");            preparedStatement.setString(3, "NON-EXISTENT");            resultSet = preparedStatement.executeQuery();        } catch (SQLException e) {            //the query failed, assume it is because the table does not exist            if (connection != null) {                try {                    String createTable = sql(CREATE_TABLE);                    String[] statements = createTable.split(";");                    for (final String sql : statements) {                        try {                            statement = connection.createStatement();                            statement.executeUpdate(sql);                        } finally {                            safeClose(statement);                        }                    }                } catch (SQLException e1) {                    EjbLogger.EJB3_TIMER_LOGGER.couldNotCreateTable(e1);                }            } else {                EjbLogger.EJB3_TIMER_LOGGER.couldNotCreateTable(e);            }        } finally {            safeClose(resultSet);            safeClose(preparedStatement);            safeClose(statement);            safeClose(connection);        }    }
private Date stringAsSchedulerDate(final String date, final String timerId) {        if (date == null) {            return null;        }        try {            return new SimpleDateFormat(SCHEDULER_DATE_FORMAT).parse(date);        } catch (ParseException e) {            EjbLogger.EJB3_TIMER_LOGGER.scheduleExpressionDateFromTimerPersistenceInvalid(timerId, e.getMessage());            return null;        }    }
private void setNodeName(final TimerState timerState, PreparedStatement statement, int paramIndex) throws SQLException {        if(timerState == TimerState.IN_TIMEOUT || timerState == TimerState.RETRY_TIMEOUT) {            statement.setString(paramIndex, nodeName);        } else {            statement.setNull(paramIndex, Types.VARCHAR);        }    }
public static void mark(DeploymentUnit unit) {        unit.putAttachment(MARKER, Boolean.TRUE);        if (unit.getParent() != null) {            mark(unit.getParent());        }    }
public static boolean isPartOfWeldDeployment(DeploymentUnit unit) {        if (unit.getParent() == null) {            return unit.getAttachment(MARKER) != null;        } else {            return unit.getParent().getAttachment(MARKER) != null;        }    }
public Object[] readParams(InputStream in) {        int len = paramReaders.length;        Object[] params = new Object[len];        for (int i = 0; i < len; i++) {            params[i] = paramReaders[i].read(in);        }        return params;    }
public void writeRetval(OutputStream out, Object retVal) {        retvalWriter.write(out, RemoteObjectSubstitutionManager.writeReplaceRemote(retVal));    }
public void writeException(OutputStream out, Throwable e) {        int len = excepWriters.length;        for (int i = 0; i < len; i++) {            if (excepWriters[i].getExceptionClass().isInstance(e)) {                excepWriters[i].write(out, e);                return;            }        }        throw new UnknownException(e);    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.OperationDefHelper.narrow(                    servantToReference(new OperationDefPOATie(this)));        }        return ref;    }
public Description describe() {        String defined_in_id = "IR";        if (defined_in instanceof ContainedOperations)            defined_in_id = ((ContainedOperations) defined_in).id();        ExceptionDescription[] exds;        exds = new ExceptionDescription[exceptions.length];        for (int i = 0; i < exceptions.length; ++i) {            Description d = exceptions[i].describe();            exds[i] = ExceptionDescriptionHelper.extract(d.value);        }        OperationDescription od;        od = new OperationDescription(name, id, defined_in_id, version, typeCode,                mode(), contexts(), params(), exds);        Any any = getORB().create_any();        OperationDescriptionHelper.insert(any, od);        return new Description(DefinitionKind.dk_Operation, any);    }
public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {        final PathAddress address = PathAddress.pathAddress(MailExtension.SUBSYSTEM_PATH);        list.add(Util.createAddOperation(address));        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            switch (Namespace.forUri(reader.getNamespaceURI())) {                case MAIL_1_0:                case MAIL_1_1:                case MAIL_1_2: {                    final String element = reader.getLocalName();                    switch (element) {                        case MAIL_SESSION: {                            parseMailSession(reader, list, address);                            break;                        }                        default: {                            reader.handleAny(list);                            break;                        }                    }                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
protected <U> U lookup(Lookup<U> lookup, int start, int depth) {        int size;        synchronized (indexes) {            size = indexes.size();            for (int i = start; i < depth && i < size; i++) {                U result = lookup.lookup(indexes.get(i));                if (result != null)                    return result;            }        }        if (currentClass == null)            return null;        synchronized (indexes) {            ClassReflectionIndex cri = index.getClassIndex(currentClass);            indexes.add(cri);            currentClass = currentClass.getSuperclass();        }        return lookup(lookup, size, depth);    }
@Override    public void getResourceValue(ResolutionContext context, ServiceBuilder<?> serviceBuilder, DeploymentPhaseContext phaseContext, Injector<ManagedReferenceFactory> injector) throws DeploymentUnitProcessingException {        AgroalConnectionFactoryConfigurationSupplier connectionFactoryConfiguration = new AgroalConnectionFactoryConfigurationSupplier();        try {            Class<?> providerClass = phaseContext.getDeploymentUnit().getAttachment(MODULE).getClassLoader().loadClass(className);            if (providerClass != null && !DataSource.class.isAssignableFrom(providerClass) && !Driver.class.isAssignableFrom(providerClass)) {                throw AgroalLogger.SERVICE_LOGGER.invalidDeploymentConnectionProvider();            }            connectionFactoryConfiguration.connectionProviderClass(providerClass);        } catch (ClassNotFoundException e) {            throw AgroalLogger.SERVICE_LOGGER.loadClassDeploymentException(e, className);        }        for (Map.Entry<String, String> property : properties.entrySet()) {            connectionFactoryConfiguration.jdbcProperty(property.getKey(), property.getValue());        }        if (databaseName != null && !databaseName.isEmpty()) {            connectionFactoryConfiguration.jdbcProperty(DATABASE_NAME_PROP, databaseName);        }        if (description != null && !description.isEmpty()) {            connectionFactoryConfiguration.jdbcProperty(DESCRIPTION_PROP, description);        }        if (serverName != null && !serverName.isEmpty()) {            connectionFactoryConfiguration.jdbcProperty(SERVER_NAME_PROP, serverName);        }        if (portNumber >= 0) {            connectionFactoryConfiguration.jdbcProperty(PORT_NUMBER_PROP, Integer.toString(portNumber));        }        if (loginTimeout >= 0) {            connectionFactoryConfiguration.jdbcProperty(LOGIN_TIMEOUT_PROP, Integer.toString(loginTimeout));        }        if (maxStatements >= 0) {            connectionFactoryConfiguration.jdbcProperty(MAX_STATEMENTS_PROP, Integer.toString(maxStatements));        }        if (url != null && !url.isEmpty()) {            connectionFactoryConfiguration.jdbcUrl(url);        }        if (user != null && !user.isEmpty()) {            connectionFactoryConfiguration.principal(new NamePrincipal(user));        }        if (password != null && !password.isEmpty()) {            connectionFactoryConfiguration.credential(new SimplePassword(password));        }        connectionFactoryConfiguration.jdbcTransactionIsolation(AgroalConnectionFactoryConfiguration.TransactionIsolation.fromLevel(isolationLevel));        AgroalConnectionPoolConfigurationSupplier connectionPoolConfiguration = new AgroalConnectionPoolConfigurationSupplier();        connectionPoolConfiguration.connectionFactoryConfiguration(connectionFactoryConfiguration);        if (initialPoolSize >= 0) {            connectionPoolConfiguration.initialSize(initialPoolSize);        }        if (minPoolSize >= 0) {            connectionPoolConfiguration.minSize(minPoolSize);        }        if (maxPoolSize >= 0) {            connectionPoolConfiguration.maxSize(maxPoolSize);        }        if (maxIdleTime >= 0) {            connectionPoolConfiguration.reapTimeout(Duration.ofSeconds(maxIdleTime));        }        AgroalDataSourceConfigurationSupplier dataSourceConfiguration = new AgroalDataSourceConfigurationSupplier();        dataSourceConfiguration.connectionPoolConfiguration(connectionPoolConfiguration);        ContextNames.BindInfo bindInfo = ContextNames.bindInfoForEnvEntry(context.getApplicationName(), context.getModuleName(), context.getComponentName(), !context.isCompUsesModule(), jndiName);        ServiceName dataSourceServiceName = DATASOURCE_DEFINITION_SERVICE_PREFIX.append(bindInfo.getBinderServiceName().getCanonicalName());        // This is the service responsible for the JNDI binding, with a dependency on the datasource service that acts as a ManagedReferenceFactory and is used as the injection source        BinderService binderService = new BinderService(bindInfo.getBindName(), this);        phaseContext.getServiceTarget().addService(bindInfo.getBinderServiceName(), binderService)                    .addDependency(dataSourceServiceName, ManagedReferenceFactory.class, binderService.getManagedObjectInjector())                    .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())                    .install();        ServiceBuilder svcBuilder = phaseContext.getServiceTarget().addService(dataSourceServiceName);        Supplier<TransactionSynchronizationRegistry> tsrSupplier = null;        if (transactional) {            CapabilityServiceSupport css = phaseContext.getDeploymentUnit().getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);            ServiceName tsrName = css.getCapabilityServiceName("org.wildfly.transactions.transaction-synchronization-registry");            //noinspection unchecked            tsrSupplier = (Supplier<TransactionSynchronizationRegistry>) svcBuilder.requires(tsrName);        }        DataSourceDefinitionService dataSourceService = new DataSourceDefinitionService(bindInfo, transactional, dataSourceConfiguration, tsrSupplier);        svcBuilder.setInstance(dataSourceService).install();        serviceBuilder.requires(bindInfo.getBinderServiceName());        serviceBuilder.addDependency(dataSourceServiceName, ManagedReferenceFactory.class, injector);    }
public static void beginSfsbCreation() {        SFSBCallStackThreadData data = CURRENT.get();        int no = data.creationBeanNestingLevel;        if (no == 0) {            data.creationTimeXPCRegistration = new HashMap<String, ExtendedEntityManager>();            // create new tracking structure (passing in parent levels tracking structure or null if toplevel)            data.creationTimeInjectedXPCs = new SFSBInjectedXPCs(data.creationTimeInjectedXPCs, null);        }        else {            // create new tracking structure (passing in parent levels tracking structure or null if toplevel)            SFSBInjectedXPCs parent = data.creationTimeInjectedXPCs;            data.creationTimeInjectedXPCs = new SFSBInjectedXPCs(parent, parent.getTopLevel());        }        data.creationBeanNestingLevel++;    }
public static void endSfsbCreation() {        SFSBCallStackThreadData data = CURRENT.get();        int no =  data.creationBeanNestingLevel;        no--;        data.creationBeanNestingLevel = no;        if (no == 0) {            // Completed creating top level bean, remove 'xpc creation tracking' thread local            data.creationTimeXPCRegistration = null;            data.creationTimeInjectedXPCs = null;        }        else {            // finished creating a sub-bean, switch to parent level 'xpc creation tracking'            data.creationTimeInjectedXPCs = data.creationTimeInjectedXPCs.getParent();        }    }
public static Map<String, ExtendedEntityManager> currentSFSBCallStackInvocation() {        ArrayList<Map<String, ExtendedEntityManager>> stack = CURRENT.get().invocationStack;        if ( stack != null && stack.size() > 0) {            return stack.get(stack.size() - 1);        }        return null;    }
public static void pushCall(Map<String, ExtendedEntityManager> entityManagers) {        currentSFSBCallStack().add(entityManagers);        if (entityManagers != null) {            /**             * JPA 2.0 spec section 7.9.1 Container Responsibilities:             * "When a business method of the stateful session bean is invoked,             *  if the stateful session bean uses container managed transaction demarcation,             *  and the entity manager is not already associated with the current JTA transaction,             *  the container associates the entity manager with the current JTA transaction and             *  calls EntityManager.joinTransaction.             *  "             */            for(ExtendedEntityManager extendedEntityManager: entityManagers.values()) {                extendedEntityManager.internalAssociateWithJtaTx();            }        }    }
public static Map<String, ExtendedEntityManager> popCall() {        ArrayList<Map<String, ExtendedEntityManager>> stack = currentSFSBCallStack();        Map<String, ExtendedEntityManager> result = stack.remove(stack.size() - 1);        stack.trimToSize();        return result;    }
static Map<String, ExtendedEntityManager> getCurrentCall() {        ArrayList<Map<String, ExtendedEntityManager>> stack = currentSFSBCallStack();        Map<String, ExtendedEntityManager> result = null;        if (stack != null) {            result = stack.get(stack.size() - 1);        }        return result;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        final ModuleLoader moduleLoader = Module.getBootModuleLoader();        addDependency(moduleSpecification, moduleLoader, JAVAX_ENTERPRISE_API);        addDependency(moduleSpecification, moduleLoader, JAVAX_INJECT_API);        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {            return; // Skip if there are no beans.xml files in the deployment        }        addDependency(moduleSpecification, moduleLoader, JAVAX_PERSISTENCE_API_ID);        addDependency(moduleSpecification, moduleLoader, WELD_CORE_ID);        addDependency(moduleSpecification, moduleLoader, WELD_PROBE_ID, true);        addDependency(moduleSpecification, moduleLoader, WELD_API_ID);        addDependency(moduleSpecification, moduleLoader, WELD_SPI_ID);        ModuleDependency weldSubsystemDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_ID, false, false, false, false);        weldSubsystemDependency.addImportFilter(PathFilters.getMetaInfFilter(), true);        weldSubsystemDependency.addImportFilter(PathFilters.is("org/jboss/as/weld/injection"), true);        weldSubsystemDependency.addImportFilter(PathFilters.acceptAll(), false);        weldSubsystemDependency.addExportFilter(PathFilters.getMetaInfFilter(), true);        moduleSpecification.addSystemDependency(weldSubsystemDependency);        // Due to serialization of EJBs        ModuleDependency weldEjbDependency = new ModuleDependency(moduleLoader, JBOSS_AS_WELD_EJB_ID, true, false, false, false);        weldEjbDependency.addImportFilter(PathFilters.is("org/jboss/as/weld/ejb"), true);        weldEjbDependency.addImportFilter(PathFilters.acceptAll(), false);        moduleSpecification.addSystemDependency(weldEjbDependency);    }
private void processXmlManagedBeans(final DeploymentUnit deploymentUnit, final Set<String> managedBeanClasses) {        for (final VirtualFile facesConfig : getConfigurationFiles(deploymentUnit)) {            InputStream is = null;            try {                is = facesConfig.openStream();                final XMLInputFactory inputFactory = XMLInputFactory.newInstance();                inputFactory.setXMLResolver(NoopXMLResolver.create());                XMLStreamReader parser = inputFactory.createXMLStreamReader(is);                StringBuilder className = null;                int indent = 0;                boolean managedBean = false;                boolean managedBeanClass = false;                while (true) {                    int event = parser.next();                    if (event == XMLStreamConstants.END_DOCUMENT) {                        parser.close();                        break;                    }                    if (event == XMLStreamConstants.START_ELEMENT) {                        indent++;                        if (indent == 2) {                            if (parser.getLocalName().equals(MANAGED_BEAN)) {                                managedBean = true;                            }                        } else if (indent == 3 && managedBean) {                            if (parser.getLocalName().equals(MANAGED_BEAN_CLASS)) {                                managedBeanClass = true;                                className = new StringBuilder();                            }                        }                    } else if (event == XMLStreamConstants.END_ELEMENT) {                        indent--;                        managedBeanClass = false;                        if (indent == 1) {                            managedBean = false;                        }                        if (className != null) {                            managedBeanClasses.add(className.toString().trim());                            className = null;                        }                    } else if (managedBeanClass && event == XMLStreamConstants.CHARACTERS) {                        className.append(parser.getText());                    }                }            } catch (Exception e) {                JSFLogger.ROOT_LOGGER.managedBeansConfigParseFailed(facesConfig);            } finally {                try {                    if (is != null) {                        is.close();                    }                } catch (IOException e) {                    // Ignore                }            }        }    }
private void processPhaseListeners(final DeploymentUnit deploymentUnit, final Set<String> managedBeanClasses) {        for (final VirtualFile facesConfig : getConfigurationFiles(deploymentUnit)) {            InputStream is = null;            try {                is = facesConfig.openStream();                final XMLInputFactory inputFactory = XMLInputFactory.newInstance();                inputFactory.setXMLResolver(NoopXMLResolver.create());                XMLStreamReader parser = inputFactory.createXMLStreamReader(is);                StringBuilder phaseListenerName = null;                int indent = 0;                boolean lifecycle = false;                boolean phaseListener = false;                while (true) {                    int event = parser.next();                    if (event == XMLStreamConstants.END_DOCUMENT) {                        parser.close();                        break;                    }                    if (event == XMLStreamConstants.START_ELEMENT) {                        indent++;                        if (indent == 2) {                            if(parser.getLocalName().equals(LIFECYCLE)){                                lifecycle = true;                            }                        } else if (indent == 3 && lifecycle) {                            if(parser.getLocalName().equals(PHASE_LISTENER)){                                phaseListener = true;                                phaseListenerName = new StringBuilder();                            }                        }                    } else if (event == XMLStreamConstants.END_ELEMENT) {                        indent--;                        phaseListener = false;                        if (indent == 1) {                            lifecycle = false;                        }                        if(phaseListenerName != null){                            managedBeanClasses.add(phaseListenerName.toString().trim());                            phaseListenerName = null;                        }                    } else if (phaseListener && event == XMLStreamConstants.CHARACTERS) {                        phaseListenerName.append(parser.getText());                    }                }            } catch (Exception e) {                JSFLogger.ROOT_LOGGER.phaseListenersConfigParseFailed(facesConfig);            } finally {                try {                    if (is != null) {                        is.close();                    }                } catch (IOException e) {                    // Ignore                }            }        }    }
public static String getTypeIDLName(Class cls)            throws RMIIIOPViolationException {        if (cls.isPrimitive())            return PrimitiveAnalysis.getPrimitiveAnalysis(cls).getIDLName();        if (cls.isArray()) {            // boxedRMI 1.3.6            Class componentClass = cls;            int sequence = 0;            while (componentClass.isArray()) {                componentClass = componentClass.getComponentType();                ++sequence;            }            String idlName = getTypeIDLName(componentClass);            int idx = idlName.lastIndexOf("::");            String idlModule = idlName.substring(0, idx + 2);            String baseName = idlName.substring(idx + 2);            return "::org::omg::boxedRMI" + idlModule + "seq" + sequence + "_" + baseName;        }        // special classes        if (cls == java.lang.String.class)            return "::CORBA::WStringValue";        if (cls == java.lang.Object.class)            return "::java::lang::_Object";        if (cls == java.lang.Class.class)            return "::javax::rmi::CORBA::ClassDesc";        if (cls == java.io.Serializable.class)            return "::java::io::Serializable";        if (cls == java.io.Externalizable.class)            return "::java::io::Externalizable";        if (cls == java.rmi.Remote.class)            return "::java::rmi::Remote";        if (cls == org.omg.CORBA.Object.class)            return "::CORBA::Object";        // remote interface?        if (cls.isInterface() && java.rmi.Remote.class.isAssignableFrom(cls)) {            InterfaceAnalysis ia = InterfaceAnalysis.getInterfaceAnalysis(cls);            return ia.getIDLModuleName() + "::" + ia.getIDLName();        }        // IDL interface?        if (cls.isInterface() &&                org.omg.CORBA.Object.class.isAssignableFrom(cls) &&                org.omg.CORBA.portable.IDLEntity.class.isAssignableFrom(cls)) {            InterfaceAnalysis ia = InterfaceAnalysis.getInterfaceAnalysis(cls);            return ia.getIDLModuleName() + "::" + ia.getIDLName();        }        // exception?        if (Throwable.class.isAssignableFrom(cls)) {            if (Exception.class.isAssignableFrom(cls) &&                    !RuntimeException.class.isAssignableFrom(cls)) {                ExceptionAnalysis ea = ExceptionAnalysis.getExceptionAnalysis(cls);                return ea.getIDLModuleName() + "::" + ea.getIDLName();            }        }        // got to be value        ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);        return va.getIDLModuleName() + "::" + va.getIDLName();    }
public static boolean isValidRMIIIOP(Class cls)            throws RMIIIOPViolationException {        if (cls.isPrimitive())            return true;        if (cls.isArray())            return isValidRMIIIOP(cls.getComponentType());        // special interfaces        if (cls == Serializable.class || cls == Externalizable.class)            return true;        // interface?        if (cls.isInterface() && java.rmi.Remote.class.isAssignableFrom(cls)) {            InterfaceAnalysis.getInterfaceAnalysis(cls);            return true;        }        // exception?        if (Throwable.class.isAssignableFrom(cls)) {            if (Exception.class.isAssignableFrom(cls) &&                    !RuntimeException.class.isAssignableFrom(cls)) {                ExceptionAnalysis.getExceptionAnalysis(cls);            }            return true;        }        // special values        if (cls == Object.class || cls == String.class || cls == Class.class)            return true;        // got to be value        ValueAnalysis.getValueAnalysis(cls);        return true;    }
public static void insertAnyPrimitive(Any any, Object primitive) {        Class type = primitive.getClass();        if (type == Boolean.class)            any.insert_boolean(((Boolean) primitive).booleanValue());        else if (type == Character.class)            any.insert_wchar(((Character) primitive).charValue());        else if (type == Byte.class)            any.insert_octet(((Byte) primitive).byteValue());        else if (type == Short.class)            any.insert_short(((Short) primitive).shortValue());        else if (type == Integer.class)            any.insert_long(((Integer) primitive).intValue());        else if (type == Long.class)            any.insert_longlong(((Long) primitive).longValue());        else if (type == Float.class)            any.insert_float(((Float) primitive).floatValue());        else if (type == Double.class)            any.insert_double(((Double) primitive).doubleValue());        else            throw IIOPLogger.ROOT_LOGGER.notAPrimitive(type.getName());    }
public static String javaToIDLName(String name) {        if (name == null || "".equals(name) || name.indexOf('.') != -1)            throw IIOPLogger.ROOT_LOGGER.nameCannotBeNullEmptyOrQualified();        StringBuffer res = new StringBuffer(name.length());        if (name.charAt(0) == '_')            res.append('J'); // 1.3.2.3        for (int i = 0; i < name.length(); ++i) {            char c = name.charAt(i);            if (isLegalIDLIdentifierChar(c))                res.append(c);            else // 1.3.2.4                res.append('U').append(toHexString((int) c));        }        String s = res.toString();        if (isReservedIDLKeyword(s))            return "_" + s;        else            return s;    }
public static String getIRIdentifierOfClass(Class cls) {        if (cls.isPrimitive())            throw IIOPLogger.ROOT_LOGGER.primitivesHaveNoIRIds();        String result = (String) classIRIdentifierCache.get(cls);        if (result != null)            return result;        String name = cls.getName();        StringBuffer b = new StringBuffer("RMI:");        for (int i = 0; i < name.length(); ++i) {            char c = name.charAt(i);            if (c < 256)                b.append(c);            else                b.append("\\U").append(toHexString((int) c));        }        long clsHash = getClassHashCode(cls);        b.append(':').append(toHexString(clsHash));        ObjectStreamClass osClass = ObjectStreamClass.lookup(cls);        if (osClass != null) {            long serialVersionUID = osClass.getSerialVersionUID();            if (clsHash != serialVersionUID)                b.append(':').append(toHexString(serialVersionUID));        }        result = b.toString();        classIRIdentifierCache.put(cls, result);        return result;    }
private static boolean isReservedIDLKeyword(String s) {        // TODO: faster lookup        for (int i = 0; i < reservedIDLKeywords.length; ++i)            if (reservedIDLKeywords[i].equals(s))                return true;        return false;    }
private static boolean isLegalIDLIdentifierChar(char c) {        if (c >= 0x61 && c <= 0x7a)            return true; // lower case letter        if (c >= 0x30 && c <= 0x39)            return true; // digit        if (c >= 0x41 && c <= 0x5a)            return true; // upper case letter        if (c == '_')            return true; // underscore        return false;    }
static long getClassHashCode(Class cls) {        // The simple cases        if (cls.isInterface())            return 0;        if (!Serializable.class.isAssignableFrom(cls))            return 0;        if (Externalizable.class.isAssignableFrom(cls))            return 1;        // Try cache        Long l = (Long) classHashCodeCache.get(cls);        if (l != null)            return l.longValue();        // Has to calculate the hash.        ByteArrayOutputStream baos = new ByteArrayOutputStream(256);        DataOutputStream dos = new DataOutputStream(baos);        // Step 1        Class superClass = cls.getSuperclass();        if (superClass != null && superClass != Object.class) {            try {                dos.writeLong(getClassHashCode(superClass));            } catch (IOException ex) {                throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);            }        }        // Step 2        boolean hasWriteObject = false;        try {            Method m;            int mods;            m = cls.getDeclaredMethod("writeObject",                    new Class[]{ObjectOutputStream.class});            mods = m.getModifiers();            if (!Modifier.isPrivate(mods) && !Modifier.isStatic(mods))                hasWriteObject = true;        } catch (NoSuchMethodException ex) {            // ignore        }        try {            dos.writeInt(hasWriteObject ? 2 : 1);        } catch (IOException ex) {            throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);        }        // Step 3        Field[] fields = cls.getDeclaredFields();        SortedSet set = new TreeSet(new FieldComparator());        for (int i = 0; i < fields.length; ++i) {            int mods = fields[i].getModifiers();            if (!Modifier.isStatic(mods) && !Modifier.isTransient(mods))                set.add(fields[i]);        }        Iterator iter = set.iterator();        try {            while (iter.hasNext()) {                Field f = (Field) iter.next();                dos.writeUTF(f.getName());                dos.writeUTF(getSignature(f.getType()));            }        } catch (IOException ex) {            throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);        }        // Convert to byte[]        try {            dos.flush();        } catch (IOException ex) {            throw IIOPLogger.ROOT_LOGGER.unexpectedException(ex);        }        byte[] bytes = baos.toByteArray();        // Calculate SHA digest        MessageDigest digest;        try {            digest = MessageDigest.getInstance("SHA");        } catch (NoSuchAlgorithmException ex) {            throw IIOPLogger.ROOT_LOGGER.unavailableSHADigest(ex);        }        digest.update(bytes);        byte[] sha = digest.digest();        // Calculate hash as per section 10.6.2        long hash = 0;        for (int i = 0; i < Math.min(8, sha.length); i++) {            hash += (long) (sha[i] & 255) << (i * 8);        }        // Save in cache        classHashCodeCache.put(cls, new Long(hash));        return hash;    }
private static String getSignature(Class cls) {        if (cls.isArray())            return "[" + cls.getComponentType();        if (cls.isPrimitive()) {            if (cls == Byte.TYPE)                return "B";            if (cls == Character.TYPE)                return "C";            if (cls == Double.TYPE)                return "D";            if (cls == Float.TYPE)                return "F";            if (cls == Integer.TYPE)                return "I";            if (cls == Long.TYPE)                return "J";            if (cls == Short.TYPE)                return "S";            if (cls == Boolean.TYPE)                return "Z";            throw IIOPLogger.ROOT_LOGGER.unknownPrimitiveType(cls.getName());        }        return "L" + cls.getName().replace('.', '/') + ";";    }
private static String getSignature(Method method) {        StringBuffer b = new StringBuffer("(");        Class[] parameterTypes = method.getParameterTypes();        for (int i = 0; i < parameterTypes.length; ++i)            b.append(getSignature(parameterTypes[i]));        b.append(')').append(getSignature(method.getReturnType()));        return b.toString();    }
static String primitiveTypeIDLName(Class type) {        if (type == Void.TYPE)            return "void";        if (type == Boolean.TYPE)            return "boolean";        if (type == Character.TYPE)            return "wchar";        if (type == Byte.TYPE)            return "octet";        if (type == Short.TYPE)            return "short";        if (type == Integer.TYPE)            return "long";        if (type == Long.TYPE)            return "long long";        if (type == Float.TYPE)            return "float";        if (type == Double.TYPE)            return "double";        throw IIOPLogger.ROOT_LOGGER.notAPrimitive(type.getName());    }
@Override    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final VirtualFile deploymentRoot = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();        process(deploymentRoot);    }
public static BatchPermission forName(final String name) {        Assert.checkNotNullParam("name", name);        return "*".equals(name) ? allPermission : mapping.getItemByString(name);    }
private void bindServices(DeploymentUnit deploymentUnit, ServiceTarget serviceTarget, ServiceName contextServiceName) {        final ServiceName userTransactionServiceName = contextServiceName.append("UserTransaction");        final UserTransactionBindingService userTransactionBindingService = new UserTransactionBindingService("UserTransaction");        serviceTarget.addService(userTransactionServiceName, userTransactionBindingService)            .addDependency(UserTransactionAccessControlService.SERVICE_NAME, UserTransactionAccessControlService.class,userTransactionBindingService.getUserTransactionAccessControlServiceInjector())            .addDependency(UserTransactionService.INTERNAL_SERVICE_NAME, UserTransaction.class,                    new ManagedReferenceInjector<UserTransaction>(userTransactionBindingService.getManagedObjectInjector()))            .addDependency(contextServiceName, ServiceBasedNamingStore.class, userTransactionBindingService.getNamingStoreInjector())            .install();        final Map<ServiceName, Set<ServiceName>> jndiComponentDependencies = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPONENT_JNDI_DEPENDENCIES);        Set<ServiceName> jndiDependencies = jndiComponentDependencies.get(contextServiceName);        if (jndiDependencies == null) {            jndiComponentDependencies.put(contextServiceName, jndiDependencies = new HashSet<>());        }        jndiDependencies.add(userTransactionServiceName);        final ServiceName transactionSynchronizationRegistryName = contextServiceName.append("TransactionSynchronizationRegistry");        BinderService transactionSyncBinderService = new BinderService("TransactionSynchronizationRegistry");        serviceTarget.addService(transactionSynchronizationRegistryName, transactionSyncBinderService)            .addDependency(TransactionSynchronizationRegistryService.INTERNAL_SERVICE_NAME, TransactionSynchronizationRegistry.class,                    new ManagedReferenceInjector<TransactionSynchronizationRegistry>(transactionSyncBinderService.getManagedObjectInjector()))            .addDependency(contextServiceName, ServiceBasedNamingStore.class, transactionSyncBinderService.getNamingStoreInjector())            .install();        jndiDependencies.add(transactionSynchronizationRegistryName);    }
@Override    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {        final ModelNode ejb3SubsystemAddOperation = new ModelNode();        ejb3SubsystemAddOperation.get(OP).set(ADD);        ejb3SubsystemAddOperation.get(OP_ADDR).add(SUBSYSTEM, EJB3Extension.SUBSYSTEM_NAME);        operations.add(ejb3SubsystemAddOperation);        // elements        final EnumSet<EJB3SubsystemXMLElement> encountered = EnumSet.noneOf(EJB3SubsystemXMLElement.class);        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {            switch (EJB3SubsystemNamespace.forUri(reader.getNamespaceURI())) {                case EJB3_1_1: {                    final EJB3SubsystemXMLElement element = EJB3SubsystemXMLElement.forName(reader.getLocalName());                    if (!encountered.add(element)) {                        throw unexpectedElement(reader);                    }                    switch (element) {                        case MDB: {                            // read <mdb>                            this.parseMDB(reader, operations, ejb3SubsystemAddOperation);                            break;                        }                        case POOLS: {                            // read <pools>                            this.parsePools(reader, operations);                            break;                        }                        case SESSION_BEAN: {                            // read <session-bean>                            this.parseSessionBean(reader, operations, ejb3SubsystemAddOperation);                            break;                        }                        case TIMER_SERVICE: {                            parseTimerService(reader, operations);                            break;                        }                        default: {                            throw unexpectedElement(reader);                        }                    }                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
public static <T> WeldInjectionTarget<T> createInjectionTarget(Class<?> componentClass, Bean<T> bean, BeanManagerImpl beanManager,            boolean interceptionSupport) {        final ClassTransformer transformer = beanManager.getServices().get(ClassTransformer.class);        @SuppressWarnings("unchecked")        final Class<T> clazz = (Class<T>) componentClass;        EnhancedAnnotatedType<T> type = transformer.getEnhancedAnnotatedType(clazz, beanManager.getId());        if (!type.getJavaClass().equals(componentClass)) {            /*             * Jasper loads a class with multiple classloaders which is not supported by Weld.             * If this happens, use a combination of a bean archive identifier and class' classloader hashCode as the BDA ID.             * This breaks AnnotatedType serialization but that does not matter as these are non-contextual components.             */            final ClassLoader classLoader = WildFlySecurityManager.isChecking() ? doPrivileged(new GetClassLoaderAction(componentClass)) : componentClass.getClassLoader();            final String bdaId = beanManager.getId() + classLoader.hashCode();            type = transformer.getEnhancedAnnotatedType(clazz, bdaId);        }        if (Beans.getBeanConstructor(type) == null) {            /*             * For example, AsyncListeners may be CDI-incompatible as long as the application never calls javax.servletAsyncContext#createListener(Class)             * and only instantiates the listener itself.             */            return beanManager.getInjectionTargetFactory(type).createNonProducibleInjectionTarget();        }        WeldInjectionTargetBuilder<T> builder = beanManager.createInjectionTargetBuilder(type);        builder.setBean(bean);        builder.setResourceInjectionEnabled(false); // because these are all EE components where resource injection is not handled by Weld        if (interceptionSupport) {            return builder.build();        } else {            // suppress interception/decoration because this is a component for which WF provides interception support            return builder.setInterceptionEnabled(false).setTargetClassLifecycleCallbacksEnabled(false).setDecorationEnabled(false).build();        }    }
public void getResourceValue(final ResolutionContext resolutionContext, final ServiceBuilder<?> serviceBuilder, final DeploymentPhaseContext phaseContext, final Injector<ManagedReferenceFactory> injector) {        injector.inject(managedReferenceFactory);    }
private EntityManager getOrCreateTransactionScopedEntityManager(            final EntityManagerFactory emf,            final String scopedPuName,            final Map properties,            final SynchronizationType synchronizationType) {        EntityManager entityManager = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);        if (entityManager == null) {            entityManager = createEntityManager(emf, properties, synchronizationType);            if (ROOT_LOGGER.isDebugEnabled()) {                ROOT_LOGGER.debugf("%s: created entity manager session %s", TransactionUtil.getEntityManagerDetails(entityManager, scopedPuName),                        TransactionUtil.getTransaction(transactionManager).toString());            }            TransactionUtil.registerSynchronization(entityManager, scopedPuName, transactionSynchronizationRegistry, transactionManager);            TransactionUtil.putEntityManagerInTransactionRegistry(scopedPuName, entityManager, transactionSynchronizationRegistry);        }        else {            testForMixedSynchronizationTypes(emf, entityManager, puScopedName, synchronizationType, properties);            if (ROOT_LOGGER.isDebugEnabled()) {                ROOT_LOGGER.debugf("%s: reuse entity manager session already in tx %s", TransactionUtil.getEntityManagerDetails(entityManager, scopedPuName),                        TransactionUtil.getTransaction(transactionManager).toString());            }        }        return entityManager;    }
@Override    protected boolean deferEntityDetachUntilClose() {        if (deferDetach == null)            deferDetach =                    (true == Configuration.deferEntityDetachUntilClose(emf.getProperties())? Boolean.TRUE : Boolean.FALSE);        return deferDetach.booleanValue();    }
public boolean containsValue(Object value) {        if (value == null)            throw new NullPointerException();        // See explanation of modCount use above        final Segment<K,V>[] segments = this.segments;        int[] mc = new int[segments.length];        // Try a few times without locking        for (int k = 0; k < RETRIES_BEFORE_LOCK; ++k) {            int mcsum = 0;            for (int i = 0; i < segments.length; ++i) {                mcsum += mc[i] = segments[i].modCount;                if (segments[i].containsValue(value))                    return true;            }            boolean cleanSweep = true;            if (mcsum != 0) {                for (int i = 0; i < segments.length; ++i) {                    if (mc[i] != segments[i].modCount) {                        cleanSweep = false;                        break;                    }                }            }            if (cleanSweep)                return false;        }        // Resort to locking all segments        for (int i = 0; i < segments.length; ++i)            segments[i].lock();        boolean found = false;        try {            for (int i = 0; i < segments.length; ++i) {                if (segments[i].containsValue(value)) {                    found = true;                    break;                }            }        } finally {            for (int i = 0; i < segments.length; ++i)                segments[i].unlock();        }        return found;    }
public V put(K key, V value) {        if (value == null)            throw new NullPointerException();        int hash = hashOf(key);        return segmentFor(hash).put(key, hash, value, false);    }
public void putAll(Map<? extends K, ? extends V> m) {        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())            put(e.getKey(), e.getValue());    }    /**     * Removes the key (and its corresponding value) from this map.     * This method does nothing if the key is not in the map.     *     * @param  key the key that needs to be removed     * @return the previous value associated with <tt>key</tt>, or     *         <tt>null</tt> if there was no mapping for <tt>key</tt>     * @throws NullPointerException if the specified key is null     */    public V remove(Object key) {        int hash = hashOf(key);        return segmentFor(hash).remove(key, hash, null, false);    }    /**     * {@inheritDoc}     *     * @throws NullPointerException if the specified key is null     */    public boolean remove(Object key, Object value) {        int hash = hashOf(key);        if (value == null)            return false;        return segmentFor(hash).remove(key, hash, value, false) != null;    }    /**     * {@inheritDoc}     *     * @throws NullPointerException if any of the arguments are null     */    public boolean replace(K key, V oldValue, V newValue) {        if (oldValue == null || newValue == null)            throw new NullPointerException();        int hash = hashOf(key);        return segmentFor(hash).replace(key, hash, oldValue, newValue);    }    /**     * {@inheritDoc}     *     * @return the previous value associated with the specified key,     *         or <tt>null</tt> if there was no mapping for the key     * @throws NullPointerException if the specified key or value is null     */    public V replace(K key, V value) {        if (value == null)            throw new NullPointerException();        int hash = hashOf(key);        return segmentFor(hash).replace(key, hash, value);    }    /**     * Removes all of the mappings from this map.     */    public void clear() {        for (int i = 0; i < segments.length; ++i)            segments[i].clear();    }    /**     * Removes any stale entries whose keys have been finalized. Use of this     * method is normally not necessary since stale entries are automatically     * removed lazily, when blocking operations are required. However, there     * are some cases where this operation should be performed eagerly, such     * as cleaning up old references to a ClassLoader in a multi-classloader     * environment.     *     * Note: this method will acquire locks, one at a time, across all segments     * of this table, so if it is to be used, it should be used sparingly.     */    public void purgeStaleEntries() {        for (int i = 0; i < segments.length; ++i)            segments[i].removeStale();    }    /**     * Returns a {@link Set} view of the keys contained in this map.     * The set is backed by the map, so changes to the map are     * reflected in the set, and vice-versa.  The set supports element     * removal, which removes the corresponding mapping from this map,     * via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,     * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>     * operations.  It does not support the <tt>add</tt> or     * <tt>addAll</tt> operations.     *     * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator     * that will never throw {@link java.util.ConcurrentModificationException},     * and guarantees to traverse elements as they existed upon     * construction of the iterator, and may (but is not guaranteed to)     * reflect any modifications subsequent to construction.     */    public Set<K> keySet() {        Set<K> ks = keySet;        return (ks != null) ? ks : (keySet = new KeySet());    }    /**     * Returns a {@link Collection} view of the values contained in this map.     * The collection is backed by the map, so changes to the map are     * reflected in the collection, and vice-versa.  The collection     * supports element removal, which removes the corresponding     * mapping from this map, via the <tt>Iterator.remove</tt>,     * <tt>Collection.remove</tt>, <tt>removeAll</tt>,     * <tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not     * support the <tt>add</tt> or <tt>addAll</tt> operations.     *     * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator     * that will never throw {@link java.util.ConcurrentModificationException},     * and guarantees to traverse elements as they existed upon     * construction of the iterator, and may (but is not guaranteed to)     * reflect any modifications subsequent to construction.     */    public Collection<V> values() {        Collection<V> vs = values;        return (vs != null) ? vs : (values = new Values());    }    /**     * Returns a {@link Set} view of the mappings contained in this map.     * The set is backed by the map, so changes to the map are     * reflected in the set, and vice-versa.  The set supports element     * removal, which removes the corresponding mapping from the map,     * via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,     * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>     * operations.  It does not support the <tt>add</tt> or     * <tt>addAll</tt> operations.     *     * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator     * that will never throw {@link java.util.ConcurrentModificationException},     * and guarantees to traverse elements as they existed upon     * construction of the iterator, and may (but is not guaranteed to)     * reflect any modifications subsequent to construction.     */    public Set<Map.Entry<K,V>> entrySet() {        Set<Map.Entry<K,V>> es = entrySet;        return (es != null) ? es : (entrySet = new EntrySet());    }    /**     * Returns an enumeration of the keys in this table.     *     * @return an enumeration of the keys in this table     * @see #keySet()     */    public Enumeration<K> keys() {        return new KeyIterator();    }    /**     * Returns an enumeration of the values in this table.     *     * @return an enumeration of the values in this table     * @see #values()     */    public Enumeration<V> elements() {        return new ValueIterator();    }    /* ---------------- Iterator Support -------------- */    abstract class HashIterator {        int nextSegmentIndex;        int nextTableIndex;        HashEntry<K,V>[] currentTable;        HashEntry<K, V> nextEntry;        HashEntry<K, V> lastReturned;        K currentKey; // Strong reference to weak key (prevents gc)        HashIterator() {            nextSegmentIndex = segments.length - 1;            nextTableIndex = -1;            advance();        }        public boolean hasMoreElements() {            return hasNext();        }        final void advance() {            if (nextEntry != null && (nextEntry = nextEntry.next) != null)                return;            while (nextTableIndex >= 0) {                if ( (nextEntry = currentTable[nextTableIndex--]) != null)                    return;            }            while (nextSegmentIndex >= 0) {                Segment<K,V> seg = segments[nextSegmentIndex--];                if (seg.count != 0) {                    currentTable = seg.table;                    for (int j = currentTable.length - 1; j >= 0; --j) {                        if ( (nextEntry = currentTable[j]) != null) {                            nextTableIndex = j - 1;                            return;                        }                    }                }            }        }        public boolean hasNext() {            while (nextEntry != null) {                if (nextEntry.key() != null)                    return true;                advance();            }            return false;        }        HashEntry<K,V> nextEntry() {            do {                if (nextEntry == null)                    throw new NoSuchElementException();                lastReturned = nextEntry;                currentKey = lastReturned.key();                advance();            } while (currentKey == null); // Skip GC'd keys            return lastReturned;        }        public void remove() {            if (lastReturned == null)                throw new IllegalStateException();            ConcurrentReferenceHashMap.this.remove(currentKey);            lastReturned = null;        }    }    final class KeyIterator        extends HashIterator        implements Iterator<K>, Enumeration<K> {        public K next()        {            return super.nextEntry().key();        }        public K nextElement() {            return super.nextEntry().key();        }    }    final class ValueIterator        extends HashIterator        implements Iterator<V>, Enumeration<V> {        public V next()        {            return super.nextEntry().value();        }        public V nextElement() {            return super.nextEntry().value();        }    }     /*      * This class is needed for JDK5 compatibility.      */     static class SimpleEntry<K, V> implements Entry<K, V>,            java.io.Serializable {        private static final long serialVersionUID = -8499721149061103585L;        private final K key;        private V value;        public SimpleEntry(K key, V value) {            this.key = key;            this.value = value;        }        public SimpleEntry(Entry<? extends K, ? extends V> entry) {            this.key = entry.getKey();            this.value = entry.getValue();        }        public K getKey() {            return key;        }        public V getValue() {            return value;        }        public V setValue(V value) {            V oldValue = this.value;            this.value = value;            return oldValue;        }        public boolean equals(Object o) {            if (!(o instanceof Map.Entry))                return false;            Map.Entry<?,?> e = (Map.Entry<?,?>) o;            return eq(key, e.getKey()) && eq(value, e.getValue());        }        public int hashCode() {            return (key == null ? 0 : key.hashCode())                    ^ (value == null ? 0 : value.hashCode());        }        public String toString() {            return key + "=" + value;        }        private static boolean eq(Object o1, Object o2) {            return o1 == null ? o2 == null : o1.equals(o2);        }    }    /**     * Custom Entry class used by EntryIterator.next(), that relays setValue     * changes to the underlying map.     */    final class WriteThroughEntry extends SimpleEntry<K,V> {        private static final long serialVersionUID = -7900634345345313646L;        WriteThroughEntry(K k, V v) {            super(k,v);        }        /**         * Set our entry's value and write through to the map. The         * value to return is somewhat arbitrary here. Since a         * WriteThroughEntry does not necessarily track asynchronous         * changes, the most recent "previous" value could be         * different from what we return (or could even have been         * removed in which case the put will re-establish). We do not         * and cannot guarantee more.         */        public V setValue(V value) {            if (value == null) throw new NullPointerException();            V v = super.setValue(value);            ConcurrentReferenceHashMap.this.put(getKey(), value);            return v;        }    }    final class EntryIterator        extends HashIterator        implements Iterator<Entry<K,V>> {        public Map.Entry<K,V> next() {            HashEntry<K,V> e = super.nextEntry();            return new WriteThroughEntry(e.key(), e.value());        }    }    final class KeySet extends AbstractSet<K> {        public Iterator<K> iterator() {            return new KeyIterator();        }        public int size() {            return ConcurrentReferenceHashMap.this.size();        }        public boolean isEmpty() {            return ConcurrentReferenceHashMap.this.isEmpty();        }        public boolean contains(Object o) {            return ConcurrentReferenceHashMap.this.containsKey(o);        }        public boolean remove(Object o) {            return ConcurrentReferenceHashMap.this.remove(o) != null;        }        public void clear() {            ConcurrentReferenceHashMap.this.clear();        }    }    final class Values extends AbstractCollection<V> {        public Iterator<V> iterator() {            return new ValueIterator();        }        public int size() {            return ConcurrentReferenceHashMap.this.size();        }        public boolean isEmpty() {            return ConcurrentReferenceHashMap.this.isEmpty();        }        public boolean contains(Object o) {            return ConcurrentReferenceHashMap.this.containsValue(o);        }        public void clear() {            ConcurrentReferenceHashMap.this.clear();        }    }    final class EntrySet extends AbstractSet<Map.Entry<K,V>> {        public Iterator<Map.Entry<K,V>> iterator() {            return new EntryIterator();        }        public boolean contains(Object o) {            if (!(o instanceof Map.Entry))                return false;            Map.Entry<?,?> e = (Map.Entry<?,?>)o;            V v = ConcurrentReferenceHashMap.this.get(e.getKey());            return v != null && v.equals(e.getValue());        }        public boolean remove(Object o) {            if (!(o instanceof Map.Entry))                return false;            Map.Entry<?,?> e = (Map.Entry<?,?>)o;            return ConcurrentReferenceHashMap.this.remove(e.getKey(), e.getValue());        }        public int size() {            return ConcurrentReferenceHashMap.this.size();        }        public boolean isEmpty() {            return ConcurrentReferenceHashMap.this.isEmpty();        }        public void clear() {            ConcurrentReferenceHashMap.this.clear();        }    }    /* ---------------- Serialization Support -------------- */    /**     * Save the state of the <tt>ConcurrentReferenceHashMap</tt> instance to a     * stream (i.e., serialize it).     * @param s the stream     * @serialData     * the key (Object) and value (Object)     * for each key-value mapping, followed by a null pair.     * The key-value mappings are emitted in no particular order.     */    private void writeObject(java.io.ObjectOutputStream s) throws IOException  {        s.defaultWriteObject();        for (int k = 0; k < segments.length; ++k) {            Segment<K,V> seg = segments[k];            seg.lock();            try {                HashEntry<K,V>[] tab = seg.table;                for (int i = 0; i < tab.length; ++i) {                    for (HashEntry<K,V> e = tab[i]; e != null; e = e.next) {                        K key = e.key();                        if (key == null) // Skip GC'd keys                            continue;                        s.writeObject(key);                        s.writeObject(e.value());                    }                }            } finally {                seg.unlock();            }        }        s.writeObject(null);        s.writeObject(null);    }    /**     * Reconstitute the <tt>ConcurrentReferenceHashMap</tt> instance from a     * stream (i.e., deserialize it).     * @param s the stream     */    @SuppressWarnings("unchecked")    private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException  {        s.defaultReadObject();        // Initialize each segment to be minimally sized, and let grow.        for (int i = 0; i < segments.length; ++i) {            segments[i].setTable(new HashEntry[1]);        }        // Read the keys and values, and put the mappings in the table        for (;;) {            K key = (K) s.readObject();            V value = (V) s.readObject();            if (key == null)                break;            put(key, value);        }    }}
static ModelNode convertSecurityRole(final ModelNode camelCase) {        final ModelNode result = new ModelNode();        result.setEmptyList();        if (camelCase.isDefined()) {            for (ModelNode role : camelCase.asList()) {                final ModelNode roleNode = result.add();                for (Property prop : role.asPropertyList()) {                    String key = prop.getName();                    if ("createDurableQueue".equals(key)) {                        key = SecurityRoleDefinition.CREATE_DURABLE_QUEUE.getName();                    } else if ("deleteDurableQueue".equals(key)) {                        key = SecurityRoleDefinition.DELETE_DURABLE_QUEUE.getName();                    } else if ("createNonDurableQueue".equals(key)) {                        key = SecurityRoleDefinition.CREATE_NON_DURABLE_QUEUE.getName();                    } else if ("deleteNonDurableQueue".equals(key)) {                        key = SecurityRoleDefinition.DELETE_NON_DURABLE_QUEUE.getName();                    }                    roleNode.get(key).set(prop.getValue());                }            }        }        return result;    }
protected void considerUninstalls(List<Joinpoint> uninstalls, int index) {        if (uninstalls == null)            return;        for (int j = Math.min(index, uninstalls.size() - 1); j >= 0; j--) {            try {                uninstalls.get(j).dispatch();            } catch (Throwable t) {                PojoLogger.ROOT_LOGGER.ignoreUninstallError(uninstalls.get(j), t);            }        }    }
private static String javaNameOfClass(Class cls) {        if (cls == null)            throw IIOPLogger.ROOT_LOGGER.cannotAnalyzeNullClass();        String s = cls.getName();        return s.substring(s.lastIndexOf('.') + 1);    }
private TimerImpl mostRecentEntityVersion(final TimerImpl timerImpl) {        try {            final int status = ContextTransactionManager.getInstance().getStatus();            if (status == Status.STATUS_UNKNOWN ||                    status == Status.STATUS_NO_TRANSACTION) {                return timerImpl;            }            final String key = timerTransactionKey(timerImpl);            TimerImpl existing = (TimerImpl) transactionSynchronizationRegistry.getValue().getResource(key);            return existing != null ? existing : timerImpl;        } catch (SystemException e) {            throw new RuntimeException(e);        }    }
private Map<String, TimerImpl> getTimers(final String timedObjectId, final TimerServiceImpl timerService) {        return loadTimersFromFile(timedObjectId, timerService);    }
private String getDirectory(String timedObjectId) {        String dirName = directories.get(timedObjectId);        if (dirName == null) {            dirName = baseDir.getAbsolutePath() + File.separator + timedObjectId.replace(File.separator, "-");            File file = new File(dirName);            if (!file.exists()) {                if (!file.mkdirs()) {                    EJB3_TIMER_LOGGER.failToCreateDirectoryForPersistTimers(file);                }            }            directories.put(timedObjectId, dirName);        }        return dirName;    }
@Override    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit.getAttachment(JBossServiceXmlDescriptor.ATTACHMENT_KEY);        if (serviceXmlDescriptor == null) {            // Skip deployments without a service xml descriptor            return;        }        // assert module        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);        if (module == null)            throw SarLogger.ROOT_LOGGER.failedToGetAttachment("module", deploymentUnit);        // assert reflection index        final DeploymentReflectionIndex reflectionIndex = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);        if (reflectionIndex == null)            throw SarLogger.ROOT_LOGGER.failedToGetAttachment("reflection index", deploymentUnit);        // install services        final ClassLoader classLoader = module.getClassLoader();        final List<JBossServiceConfig> serviceConfigs = serviceXmlDescriptor.getServiceConfigs();        final ServiceTarget target = phaseContext.getServiceTarget();        final Map<String,ServiceComponentInstantiator> serviceComponents = deploymentUnit.getAttachment(ServiceAttachments.SERVICE_COMPONENT_INSTANTIATORS);        for (final JBossServiceConfig serviceConfig : serviceConfigs) {            addServices(target, serviceConfig, classLoader, reflectionIndex, serviceComponents != null ? serviceComponents.get(serviceConfig.getName()) : null, phaseContext);        }    }
public static Sanitizer pattern(String pattern, String replacement) throws Exception {        return new PatternSanitizer(pattern, replacement, Filters.suffix(".properties"));    }
@Override    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {        ReloadRequiredWriteAttributeHandler reloadWrtiteHandler = new ReloadRequiredWriteAttributeHandler(JNDI_NAME, CM_TABLE_NAME, CM_TABLE_BATCH_SIZE, CM_TABLE_IMMEDIATE_CLEANUP);        resourceRegistration.registerReadWriteAttribute(CM_TABLE_NAME, null, reloadWrtiteHandler);        resourceRegistration.registerReadWriteAttribute(CM_TABLE_BATCH_SIZE, null, reloadWrtiteHandler);        resourceRegistration.registerReadWriteAttribute(CM_TABLE_IMMEDIATE_CLEANUP, null, reloadWrtiteHandler);        //This comes from the address        resourceRegistration.registerReadOnlyAttribute(JNDI_NAME, ReadResourceNameOperationStepHandler.INSTANCE);    }
private boolean isApplicationException(final EJBComponent ejbComponent, final Class<?> exceptionClass, final Method invokedMethod) {        return ejbComponent.getApplicationException(exceptionClass, invokedMethod) != null;    }
synchronized void addListener(final String target, final int scope, final NamingListener namingListener) {        final TargetScope targetScope = new TargetScope(target, scope);        // Do we have a holder for this listener        ListenerHolder holder = holdersByListener.get(namingListener);        if (holder == null) {            holder = new ListenerHolder(namingListener, targetScope);            final Map<NamingListener, ListenerHolder> byListenerCopy = new FastCopyHashMap<NamingListener, ListenerHolder>(holdersByListener);            byListenerCopy.put(namingListener, holder);            holdersByListener = byListenerCopy;        } else {            holder.addTarget(targetScope);        }        List<ListenerHolder> holdersForTarget = holdersByTarget.get(targetScope);        if (holdersForTarget == null) {            holdersForTarget = new CopyOnWriteArrayList<ListenerHolder>();            final Map<TargetScope, List<ListenerHolder>> byTargetCopy = new FastCopyHashMap<TargetScope, List<ListenerHolder>>(holdersByTarget);            byTargetCopy.put(targetScope, holdersForTarget);            holdersByTarget = byTargetCopy;        }        holdersForTarget.add(holder);    }
synchronized void removeListener(final NamingListener namingListener) {        // Do we have a holder for this listener        final ListenerHolder holder = holdersByListener.get(namingListener);        if (holder == null) {            return;        }        final Map<NamingListener, ListenerHolder> byListenerCopy = new FastCopyHashMap<NamingListener, ListenerHolder>(holdersByListener);        byListenerCopy.remove(namingListener);        holdersByListener = byListenerCopy;        final Map<TargetScope, List<ListenerHolder>> byTargetCopy = new FastCopyHashMap<TargetScope, List<ListenerHolder>>(holdersByTarget);        for (TargetScope targetScope : holder.targets) {            final List<ListenerHolder> holders = holdersByTarget.get(targetScope);            holders.remove(holder);            if (holders.isEmpty()) {                byTargetCopy.remove(targetScope);            }        }        holdersByTarget = byTargetCopy;    }
void fireEvent(final EventContext context, final Name name, final Binding existingBinding, final Binding newBinding, int type, final String changeInfo, final Integer... scopes) {        final String target = name.toString();        final Set<Integer> scopeSet = new HashSet<Integer>(Arrays.asList(scopes));        final NamingEvent event = new NamingEvent(context, type, newBinding, existingBinding, changeInfo);        final Set<ListenerHolder> holdersToFire = new HashSet<ListenerHolder>();        // Check for OBJECT_SCOPE based listeners        if (scopeSet.contains(EventContext.OBJECT_SCOPE)) {            final TargetScope targetScope = new TargetScope(target, EventContext.OBJECT_SCOPE);            final List<ListenerHolder> holders = holdersByTarget.get(targetScope);            if (holders != null) {                for (ListenerHolder holder : holders) {                    holdersToFire.add(holder);                }            }        }        // Check for ONELEVEL_SCOPE based listeners        if (scopeSet.contains(EventContext.ONELEVEL_SCOPE) && !name.isEmpty()) {            final TargetScope targetScope = new TargetScope(name.getPrefix(name.size() - 1).toString(), EventContext.ONELEVEL_SCOPE);            final List<ListenerHolder> holders = holdersByTarget.get(targetScope);            if (holders != null) {                for (ListenerHolder holder : holders) {                    holdersToFire.add(holder);                }            }        }        // Check for SUBTREE_SCOPE based listeners        if (scopeSet.contains(EventContext.SUBTREE_SCOPE) && !name.isEmpty()) {            for (int i = 1; i < name.size(); i++) {                final Name parentName = name.getPrefix(i);                final TargetScope targetScope = new TargetScope(parentName.toString(), EventContext.SUBTREE_SCOPE);                final List<ListenerHolder> holders = holdersByTarget.get(targetScope);                if (holders != null) {                    for (ListenerHolder holder : holders) {                        holdersToFire.add(holder);                    }                }            }        }        executor.execute(new FireEventTask(holdersToFire, event));    }
public static <T extends AutoCloseable> Consumer<T> close() {        return value -> {            try {                value.close();            } catch (Throwable e) {                ClusteringLogger.ROOT_LOGGER.failedToClose(e, value);            }        };    }
public Subject createSubject() {        // If a authenticationContext was defined on the subsystem use that context, otherwise use capture the current        // configuration.        final Subject subject = this.createSubject(getAuthenticationContext());        if (ROOT_LOGGER.isTraceEnabled()) {            ROOT_LOGGER.subject(subject, Integer.toHexString(System.identityHashCode(subject)));        }        return subject;    }
public Subject createSubject(final String authenticationContextName) {        AuthenticationContext context;        if (authenticationContextName != null && !authenticationContextName.isEmpty()) {            final ServiceContainer container = this.currentServiceContainer();            final ServiceName authContextServiceName = AUTHENTICATION_CONTEXT_RUNTIME_CAPABILITY.getCapabilityServiceName(authenticationContextName);            context = (AuthenticationContext) container.getRequiredService(authContextServiceName).getValue();        }        else {            context = getAuthenticationContext();        }        final Subject subject = this.createSubject(context);        if (ROOT_LOGGER.isTraceEnabled()) {            ROOT_LOGGER.subject(subject, Integer.toHexString(System.identityHashCode(subject)));        }        return subject;    }
private Subject createSubject(final AuthenticationContext authenticationContext) {        final AuthenticationConfiguration configuration = AUTH_CONFIG_CLIENT.getAuthenticationConfiguration(this.targetURI, authenticationContext);        final CallbackHandler handler = AUTH_CONFIG_CLIENT.getCallbackHandler(configuration);        final NameCallback nameCallback = new NameCallback("Username: ");        final PasswordCallback passwordCallback = new PasswordCallback("Password: ", false);        final CredentialCallback credentialCallback = new CredentialCallback(GSSKerberosCredential.class);        try {            handler.handle(new Callback[]{nameCallback, passwordCallback, credentialCallback});            Subject subject = new Subject();            // if a GSSKerberosCredential was found, add the enclosed GSSCredential and KerberosTicket to the private set in the Subject.            if (credentialCallback.getCredential() != null) {                GSSKerberosCredential kerberosCredential = GSSKerberosCredential.class.cast(credentialCallback.getCredential());                this.addPrivateCredential(subject, kerberosCredential.getKerberosTicket());                this.addPrivateCredential(subject, kerberosCredential.getGssCredential());                // use the GSSName to build a kerberos principal and set it in the Subject.                GSSName gssName = kerberosCredential.getGssCredential().getName();                subject.getPrincipals().add(new KerberosPrincipal(gssName.toString()));            }            // use the name from the callback, if available, to build a principal and set it in the Subject.            if (nameCallback.getName() != null) {                subject.getPrincipals().add(new NamePrincipal(nameCallback.getName()));            }            // use the password from the callback, if available, to build a credential and set it as a private credential in the Subject.            if (passwordCallback.getPassword() != null) {                this.addPrivateCredential(subject, new PasswordCredential(nameCallback.getName(), passwordCallback.getPassword()));            }            return subject;        } catch(Exception e) {            throw new SecurityException(e);        }    }
private ServiceContainer currentServiceContainer() {        if(WildFlySecurityManager.isChecking()) {            return AccessController.doPrivileged(CurrentServiceContainer.GET_ACTION);        }        return CurrentServiceContainer.getServiceContainer();    }
private void addPrivateCredential(final Subject subject, final Object credential) {        if (!WildFlySecurityManager.isChecking()) {            subject.getPrivateCredentials().add(credential);        }        else {            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {                subject.getPrivateCredentials().add(credential);                return null;            });        }    }
protected static AgroalConnectionFactoryConfigurationSupplier connectionFactoryConfiguration(OperationContext context, ModelNode model) throws OperationFailedException {        AgroalConnectionFactoryConfigurationSupplier configuration = new AgroalConnectionFactoryConfigurationSupplier();        if (AbstractDataSourceDefinition.URL_ATTRIBUTE.resolveModelAttribute(context, model).isDefined()) {            configuration.jdbcUrl(AbstractDataSourceDefinition.URL_ATTRIBUTE.resolveModelAttribute(context, model).asString());        }        if (AbstractDataSourceDefinition.NEW_CONNECTION_SQL_ATTRIBUTE.resolveModelAttribute(context, model).isDefined()) {            configuration.initialSql(AbstractDataSourceDefinition.NEW_CONNECTION_SQL_ATTRIBUTE.resolveModelAttribute(context, model).asString());        }        if (AbstractDataSourceDefinition.TRANSACTION_ISOLATION_ATTRIBUTE.resolveModelAttribute(context, model).isDefined()) {            configuration.jdbcTransactionIsolation(TransactionIsolation.valueOf(AbstractDataSourceDefinition.TRANSACTION_ISOLATION_ATTRIBUTE.resolveModelAttribute(context, model).asString()));        }        if (AbstractDataSourceDefinition.CONNECTION_PROPERTIES_ATTRIBUTE.resolveModelAttribute(context, model).isDefined()) {            for (Property jdbcProperty : AbstractDataSourceDefinition.CONNECTION_PROPERTIES_ATTRIBUTE.resolveModelAttribute(context, model).asPropertyList()) {                configuration.jdbcProperty(jdbcProperty.getName(), jdbcProperty.getValue().asString());            }        }        if (AbstractDataSourceDefinition.USERNAME_ATTRIBUTE.resolveModelAttribute(context, model).isDefined()) {            configuration.principal(new NamePrincipal(AbstractDataSourceDefinition.USERNAME_ATTRIBUTE.resolveModelAttribute(context, model).asString()));        }        if (AbstractDataSourceDefinition.PASSWORD_ATTRIBUTE.resolveModelAttribute(context, model).isDefined()) {            configuration.credential(new SimplePassword(AbstractDataSourceDefinition.PASSWORD_ATTRIBUTE.resolveModelAttribute(context, model).asString()));        }        return configuration;    }
private static AgroalDataSource getDataSource(OperationContext context) throws OperationFailedException {        ServiceRegistry registry = context.getServiceRegistry(false);        String dataSourceName = context.getCurrentAddressValue();        switch (context.getCurrentAddress().getLastElement().getKey()) {            case DataSourceOperations.DATASOURCE_SERVICE_NAME:                ServiceController<?> controller = registry.getRequiredService(AbstractDataSourceDefinition.DATA_SOURCE_CAPABILITY.getCapabilityServiceName(dataSourceName));                return ((AgroalDataSource) controller.getValue());            case XADataSourceOperations.XADATASOURCE_SERVICE_NAME:                ServiceController<?> xaController = registry.getRequiredService(AbstractDataSourceDefinition.DATA_SOURCE_CAPABILITY.getCapabilityServiceName(dataSourceName));                return ((AgroalDataSource) xaController.getValue());            default:                throw AgroalLogger.SERVICE_LOGGER.unknownDatasourceServiceType(context.getCurrentAddress().getLastElement().getKey());        }    }
public Object processInvocation(final InterceptorContext context) throws Exception {        try {            return context.proceed();        } finally {            final ManagedReference managedReference = (ManagedReference) context.getPrivateData(ComponentInstance.class).getInstanceData(contextKey);            if (managedReference != null) {                managedReference.release();            }        }    }
public ObjectFactory createObjectFactory(final Object obj, Hashtable<?, ?> environment) throws NamingException {        try {            if (obj instanceof Reference) {                return factoryFromReference((Reference) obj, environment);            }        } catch (Throwable ignored) {        }        return this;    }
public Object getObjectInstance(final Object ref, final Name name, final Context nameCtx, final Hashtable<?, ?> environment) throws Exception {        final ClassLoader classLoader = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        if (classLoader == null) {            return ref;        }        final String factoriesProp = (String) environment.get(Context.OBJECT_FACTORIES);        if (factoriesProp != null) {            final String[] classes = factoriesProp.split(":");            for (String className : classes) {                try {                    final Class<?> factoryClass = classLoader.loadClass(className);                    final ObjectFactory objectFactory = ObjectFactory.class.cast(factoryClass.newInstance());                    final Object result = objectFactory.getObjectInstance(ref, name, nameCtx, environment);                    if (result != null) {                        return result;                    }                } catch (Throwable ignored) {                }            }        }        return ref;    }
@Override    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {        if (rewriteSessionImplementor &&                hasSessionImplementor(desc) &&                (opcode == Opcodes.INVOKESPECIAL || opcode == Opcodes.INVOKEVIRTUAL)) {            // if we have a user type calling a method from org.hibernate, we rewrite it to use SharedSessionContractImplementor            logger.debugf("Deprecated Hibernate51CompatibilityTransformer transformed application classes in '%s', " +                            "class '%s' is calling method %s.%s, which must be changed to use SharedSessionContractImplementor as parameter.",                    moduleName, className, owner, name);            mv.visitMethodInsn(opcode, owner, name, replaceSessionImplementor(desc), itf);            transformedState.setClassTransformed(true);        } else if (opcode == Opcodes.INVOKEINTERFACE &&                (owner.equals("org/hibernate/Session") || owner.equals("org/hibernate/BasicQueryContract"))                && name.equals("getFlushMode") && desc.equals("()Lorg/hibernate/FlushMode;")) {            logger.debugf("Deprecated Hibernate51CompatibilityTransformer transformed application classes in '%s', " +                            "class '%s' is calling %s.getFlushMode, which must be changed to call getHibernateFlushMode().",                    moduleName, className, owner);            name = "getHibernateFlushMode";            mv.visitMethodInsn(opcode, owner, name, desc, itf);            transformedState.setClassTransformed(true);        } else if (opcode == Opcodes.INVOKEINTERFACE &&                owner.equals("org/hibernate/Query") &&                name.equals("getFirstResult") &&                desc.equals("()Ljava/lang/Integer;")) {            logger.debugf("Deprecated Hibernate51CompatibilityTransformer transformed application classes in '%s', " +                            "class '%s', is calling org.hibernate.Query.getFirstResult, which must be changed to call getHibernateFirstResult() " +                            "so null can be returned when the value is uninitialized. Please note that if a negative value was set using " +                            "org.hibernate.Query.setFirstResult, then getHibernateFirstResult() will return 0.",                    moduleName, className);            name = "getHibernateFirstResult";            mv.visitMethodInsn(opcode, owner, name, desc, itf);            transformedState.setClassTransformed(true);        } else if (opcode == Opcodes.INVOKEINTERFACE &&                owner.equals("org/hibernate/Query") &&                name.equals("getMaxResults") &&                desc.equals("()Ljava/lang/Integer;")) {            logger.debugf("Deprecated Hibernate51CompatibilityTransformer transformed application classes in '%s', " +                            "class '%s', is calling org.hibernate.Query.getMaxResults, which must be changed to call getHibernateMaxResults() " +                            "so that null will be returned when the value is uninitialized or ORM 5.1 org.hibernate.Query#setMaxResults was " +                            "used to set a value <= 0"                    , moduleName, className);            name = "getHibernateMaxResults";            mv.visitMethodInsn(opcode, owner, name, desc, itf);            transformedState.setClassTransformed(true);        } else if (!disableAmbiguousChanges && opcode == Opcodes.INVOKEINTERFACE &&                owner.equals("org/hibernate/Query") &&                name.equals("setFirstResult") &&                desc.equals("(I)Lorg/hibernate/Query;")) {            logger.debugf("Deprecated Hibernate51CompatibilityTransformer transformed application classes in '%s', " +                            "class '%s', is calling org.hibernate.Query.setFirstResult, which must be changed to call setHibernateFirstResult() " +                            "so setting a value < 0 results in pagination starting with the 0th row as was done in Hibernate ORM 5.1 " +                            "(instead of throwing IllegalArgumentException as specified by JPA)."                    , moduleName, className);            name = "setHibernateFirstResult";            mv.visitMethodInsn(opcode, owner, name, desc, itf);            transformedState.setClassTransformed(true);        } else if (!disableAmbiguousChanges && opcode == Opcodes.INVOKEINTERFACE &&                owner.equals("org/hibernate/Query") &&                name.equals("setMaxResults") &&                desc.equals("(I)Lorg/hibernate/Query;")) {            logger.debugf("Deprecated Hibernate51CompatibilityTransformer transformed application classes in '%s', " +                            "class '%s', is calling org.hibernate.Query.setMaxResults, which must be changed to call setHibernateMaxResults() " +                            "so that values <= 0 are treated the same as uninitialized.  Review Hibernate ORM migration doc "                    , moduleName, className);            name = "setHibernateMaxResults";            mv.visitMethodInsn(opcode, owner, name, desc, itf);            transformedState.setClassTransformed(true);        } else {            mv.visitMethodInsn(opcode, owner, name, desc, itf);        }    }
protected static void addTxManagementInterceptorForView(ViewDescription view) {        // add a Tx configurator        view.getConfigurators().add(new ViewConfigurator() {            @Override            public void configure(DeploymentPhaseContext context, ComponentConfiguration componentConfiguration, ViewDescription description, ViewConfiguration configuration) throws DeploymentUnitProcessingException {                EJBComponentDescription ejbComponentDescription = (EJBComponentDescription) componentConfiguration.getComponentDescription();                // Add CMT interceptor factory                if (TransactionManagementType.CONTAINER.equals(ejbComponentDescription.getTransactionManagementType())) {                    configuration.addViewInterceptor(CMTTxInterceptor.FACTORY, InterceptorOrder.View.CMT_TRANSACTION_INTERCEPTOR);                }            }        });    }
public static Class<?> loadClass(String name, ClassLoader cl) throws ClassNotFoundException {        /*        * Handle Primitives        */        if (name.equals(void.class.getName())) {            return void.class;        }        if (name.equals(byte.class.getName())) {            return byte.class;        }        if (name.equals(short.class.getName())) {            return short.class;        }        if (name.equals(int.class.getName())) {            return int.class;        }        if (name.equals(long.class.getName())) {            return long.class;        }        if (name.equals(char.class.getName())) {            return char.class;        }        if (name.equals(boolean.class.getName())) {            return boolean.class;        }        if (name.equals(float.class.getName())) {            return float.class;        }        if (name.equals(double.class.getName())) {            return double.class;        }        // Now that we know its not a primitive, lets just allow        // the passed classloader to handle the request.        // Note that we are intentionally using Class.forName(name,boolean,cl)        // to handle issues with loading array types in Java 6 http://bugs.sun.com/view_bug.do?bug_id=6434149        return Class.forName(name, false, cl);    }
private String displayable(String query) {        if (query == null ||            query.length() == 0) {            return query;        }        StringBuilder buff = new StringBuilder(query);        // handle two character transforms first        subst(buff, SQL_NE, NOT_EQUAL__);        subst(buff, NE_BANG, BANG_NOT_EQUAL__);        subst(buff, NE_HAT, HAT_NOT_EQUAL__);        subst(buff, LE, LESS_THAN_EQUAL__);        subst(buff, GE, GREATER_THAN_EQUAL__);        subst(buff, CONCAT, CONCAT__);        subst(buff, LT, LESS_THAN__);        subst(buff, EQ, EQUAL__);        subst(buff, GT, GREATER__);        subst(buff, OPEN, LEFT_PAREN__);        subst(buff, CLOSE, RIGHT_PAREN__);        subst(buff, OPEN_BRACKET, LEFT_BRACKET__);        subst(buff, CLOSE_BRACKET, RIGHT_BRACKET__);        subst(buff, PLUS, PLUS__);        subst(buff, MINUS, MINUS__);        subst(buff, STAR, STAR__);        subst(buff, DIV, DIVIDE__);        subst(buff, MOD, MODULUS__);        subst(buff, COLON, COLON__);        subst(buff, PARAM, PARAM__);        subst(buff, COMMA, COMMA__);        subst(buff, SPACE, SPACE__);        subst(buff, TAB, TAB__);        subst(buff, NEWLINE, NEWLINE__);        subst(buff, LINEFEED, LINEFEED__);        subst(buff, QUOTE, QUOTE__);        subst(buff, DQUOTE, DQUOTE__);        subst(buff, TICK, TICK__);        subst(buff, OPEN_BRACE, OPEN_BRACE__);        subst(buff, CLOSE_BRACE, CLOSE_BRACE__);        subst(buff, HAT, HAT__);        subst(buff, AMPERSAND, AMPERSAND__);        return buff.toString();    }
private static void subst(final StringBuilder stringBuilder, final String from, final String to) {        int begin = 0, end = 0;        while ((end = stringBuilder.indexOf(from, end)) != -1) {            stringBuilder.delete(end, end + from.length());            stringBuilder.insert(end, to);            // update positions            begin = end + to.length();            end = begin;        }    }
@Override    public void transformResource(ResourceTransformationContext context, PathAddress address, Resource resource) throws OperationFailedException {        context.addTransformedResourceFromRoot(this.addressTransformer.transform(address), resource).processChildren(resource);    }
protected synchronized void stopService() {        if (deploymentMD != null) {            if (deploymentMD.getResourceAdapterKey() != null) {                try {                    raRepository.getValue().unregisterResourceAdapter(deploymentMD.getResourceAdapterKey());                } catch (org.jboss.jca.core.spi.rar.NotFoundException nfe) {                    ConnectorLogger.ROOT_LOGGER.exceptionDuringUnregistering(nfe);                }            }            if (deploymentMD.getResourceAdapter() != null) {                deploymentMD.getResourceAdapter().stop();                if (BootstrapContextCoordinator.getInstance() != null && deploymentMD.getBootstrapContextIdentifier() != null) {                    BootstrapContextCoordinator.getInstance().removeBootstrapContext(deploymentMD.getBootstrapContextIdentifier());                }            }            if (deploymentMD.getDataSources() != null && managementRepositoryValue.getValue() != null) {                for (org.jboss.jca.core.api.management.DataSource mgtDs : deploymentMD.getDataSources()) {                    managementRepositoryValue.getValue().getDataSources().remove(mgtDs);                }            }            if (deploymentMD.getConnectionManagers() != null) {                for (ConnectionManager cm : deploymentMD.getConnectionManagers()) {                    cm.shutdown();                }            }        }        sqlDataSource = null;    }
private TransportConfiguration createInVMTransportConfiguration(OperationContext context) throws OperationFailedException {        final Resource serverResource = context.readResource(EMPTY_ADDRESS, false);        Set<Resource.ResourceEntry> invmConnectors = serverResource.getChildren(CommonAttributes.IN_VM_CONNECTOR);        if (invmConnectors.isEmpty()) {            throw MessagingLogger.ROOT_LOGGER.noInVMConnector();        }        Resource.ResourceEntry connectorEntry = invmConnectors.iterator().next();        Resource connectorResource = context.readResource(PathAddress.pathAddress(connectorEntry.getPathElement()), false);        ModelNode model = connectorResource.getModel();        Map<String, Object> params = new HashMap<>(CommonAttributes.PARAMS.unwrap(context, model));        params.put(InVMTransportDefinition.SERVER_ID.getName(), InVMTransportDefinition.SERVER_ID.resolveModelAttribute(context, model).asInt());        TransportConfiguration transportConfiguration = new TransportConfiguration(InVMConnectorFactory.class.getName(), params);        return transportConfiguration;    }
private String addEarPrefixIfRelativeName(final String configuredName, final DeploymentUnit deploymentUnit,            final Class<?> componentClass) throws DeploymentUnitProcessingException {        if (!configuredName.startsWith("#")) {            return configuredName;        }        final DeploymentUnit parent = deploymentUnit.getParent();        if (parent == null) {            throw EjbLogger.ROOT_LOGGER.relativeResourceAdapterNameInStandaloneModule(deploymentUnit.getName(),                    componentClass.getName(), configuredName);        }        return new StringBuilder().append(parent.getName()).append(configuredName).toString();    }
public static DeploymentUnit getRootDeploymentUnit(DeploymentUnit deploymentUnit) {        if (deploymentUnit.getParent() == null) {            return deploymentUnit;        }        return deploymentUnit.getParent();    }
public ServiceName getServiceName() {        //TODO: need to set viewNameParts somewhere        if (!viewNameParts.isEmpty()) {            return componentDescription.getServiceName().append("VIEW").append(viewNameParts.toArray(new String[viewNameParts.size()]));        } else {            return componentDescription.getServiceName().append("VIEW").append(viewClassName);        }    }
public ViewConfiguration createViewConfiguration(final Class<?> viewClass, final ComponentConfiguration componentConfiguration, final ProxyFactory<?> proxyFactory) {        return new ViewConfiguration(viewClass, componentConfiguration, getServiceName(), proxyFactory);    }
protected InjectionSource createInjectionSource(final ServiceName serviceName, Value<ClassLoader> viewClassLoader, boolean appclient) {        return new ViewBindingInjectionSource(serviceName);    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.SequenceDefHelper.narrow(                    servantToReference(new SequenceDefPOATie(this)));        }        return ref;    }
public List<InterceptorFactory> getViewInterceptors(Method method) {        OrderedItemContainer<InterceptorFactory> container = viewInterceptors.get(method);        if (container == null) {            return Collections.emptyList();        }        return container.getSortedItems();    }
public void addViewInterceptor(InterceptorFactory interceptorFactory, int priority) {        for (Method method : proxyFactory.getCachedMethods()) {            addViewInterceptor(method, interceptorFactory, priority);        }    }
public void addViewInterceptor(Method method, InterceptorFactory interceptorFactory, int priority) {        OrderedItemContainer<InterceptorFactory> container = viewInterceptors.get(method);        if (container == null) {            viewInterceptors.put(method, container = new OrderedItemContainer<InterceptorFactory>());        }        container.add(interceptorFactory, priority);    }
public List<InterceptorFactory> getClientInterceptors(Method method) {        OrderedItemContainer<InterceptorFactory> container = clientInterceptors.get(method);        if (container == null) {            return Collections.emptyList();        }        return container.getSortedItems();    }
public void addClientInterceptor(InterceptorFactory interceptorFactory, int priority) {        for (Method method : proxyFactory.getCachedMethods()) {            addClientInterceptor(method, interceptorFactory, priority);        }    }
public void addClientInterceptor(Method method, InterceptorFactory interceptorFactory, int priority) {        OrderedItemContainer<InterceptorFactory> container = clientInterceptors.get(method);        if (container == null) {            clientInterceptors.put(method, container = new OrderedItemContainer<InterceptorFactory>());        }        container.add(interceptorFactory, priority);    }
public <T> void putPrivateData(final Class<T> type, T data ) {        privateData.put(type, data);    }
static ModuleClassLoaderLocator.CombinedClassLoader createCombinedClassLoader(final List<ClassLoader> classLoaders) {        if (WildFlySecurityManager.isChecking()) {            return doPrivileged(new PrivilegedAction<ModuleClassLoaderLocator.CombinedClassLoader>() {                @Override                public CombinedClassLoader run() {                    return new ModuleClassLoaderLocator.CombinedClassLoader(classLoaders);                }            });        } else {            return new ModuleClassLoaderLocator.CombinedClassLoader(classLoaders);        }    }
protected static void unexpectedElement(final XMLExtendedStreamReader reader) throws XMLStreamException {        throw EeLogger.ROOT_LOGGER.unexpectedElement(reader.getName(), reader.getLocation());    }
private static boolean removeInCurrentStep(Resource resource) {        for (String childType : resource.getChildTypes()) {            for (Resource.ResourceEntry entry : resource.getChildren(childType)) {                if (!entry.isRuntime() && resource.hasChild(entry.getPathElement())) {                    return false;                }            }        }        return true;    }
private static ConnectionFactoryAttribute[] define(ConnectionFactoryAttribute[] specific, ConnectionFactoryAttribute... common) {        int size = common.length + specific.length;        ConnectionFactoryAttribute[] result = new ConnectionFactoryAttribute[size];        arraycopy(specific, 0, result, 0, specific.length);        for (int i = 0; i < common.length; i++) {            ConnectionFactoryAttribute attr = common[i];            AttributeDefinition definition = attr.getDefinition();            ConnectionFactoryAttribute newAttr;            // replace the reconnect-attempts attribute to use a different default value for pooled CF            if (definition == Common.RECONNECT_ATTEMPTS) {                AttributeDefinition copy = copy(Pooled.RECONNECT_ATTEMPTS, AttributeAccess.Flag.RESTART_ALL_SERVICES);                newAttr = ConnectionFactoryAttribute.create(copy, Pooled.RECONNECT_ATTEMPTS_PROP_NAME, true);            } else if (definition == Common.CONNECTORS) {                StringListAttributeDefinition copy = new StringListAttributeDefinition.Builder(Common.CONNECTORS)                        .setAlternatives(CommonAttributes.DISCOVERY_GROUP)                        .setRequired(true)                        .setAttributeParser(AttributeParser.STRING_LIST)                        .setAttributeMarshaller(AttributeMarshaller.STRING_LIST)                        .setCapabilityReference(new AbstractTransportDefinition.TransportCapabilityReferenceRecorder(CAPABILITY_NAME, CONNECTOR_CAPABILITY_NAME, false))                        .setRestartAllServices()                        .build();                newAttr = ConnectionFactoryAttribute.create(copy, attr.getPropertyName(), attr.isResourceAdapterProperty(), attr.getConfigType());            }else {                AttributeDefinition copy = copy(definition, AttributeAccess.Flag.RESTART_ALL_SERVICES);                newAttr = ConnectionFactoryAttribute.create(copy, attr.getPropertyName(), attr.isResourceAdapterProperty(), attr.getConfigType());            }            result[specific.length + i] = newAttr;        }        return result;    }
public static List<EJBEndpoint> getJaxwsEjbs(final DeploymentUnit unit) {        final JAXWSDeployment jaxwsDeployment = getOptionalAttachment(unit, WSAttachmentKeys.JAXWS_ENDPOINTS_KEY);        return jaxwsDeployment != null ? jaxwsDeployment.getEjbEndpoints() : Collections.<EJBEndpoint>emptyList();    }
public static List<POJOEndpoint> getJaxwsPojos(final DeploymentUnit unit) {        final JAXWSDeployment jaxwsDeployment = unit.getAttachment(WSAttachmentKeys.JAXWS_ENDPOINTS_KEY);        return jaxwsDeployment != null ? jaxwsDeployment.getPojoEndpoints() : Collections.<POJOEndpoint>emptyList();    }
public static String getEndpointName(final ServletMetaData servletMD) {        final String endpointName = servletMD.getName();        return endpointName != null ? endpointName.trim() : null;    }
public static String getEndpointClassName(final ServletMetaData servletMD) {        final String endpointClass = servletMD.getServletClass();        return endpointClass != null ? endpointClass.trim() : null;    }
public static ServletMetaData getServletForName(final JBossWebMetaData jbossWebMD, final String servletName) {        for (JBossServletMetaData servlet : jbossWebMD.getServlets()) {            if (servlet.getName().equals(servletName)) {                return servlet;            }        }        return null;    }
public static <A> A getRequiredAttachment(final DeploymentUnit unit, final AttachmentKey<A> key) {        final A value = unit.getAttachment(key);        if (value == null) {            throw new IllegalStateException();        }        return value;    }
public static <A> A getOptionalAttachment(final DeploymentUnit unit, final AttachmentKey<A> key) {        return unit.getAttachment(key);    }
public static JBossWebMetaData getJBossWebMetaData(final DeploymentUnit unit) {        final WarMetaData warMetaData = getOptionalAttachment(unit, WarMetaData.ATTACHMENT_KEY);        JBossWebMetaData result = null;        if (warMetaData != null) {            result = warMetaData.getMergedJBossWebMetaData();            if (result == null) {                result = warMetaData.getJBossWebMetaData();            }        } else {            result = getOptionalAttachment(unit, WSAttachmentKeys.JBOSSWEB_METADATA_KEY);        }        return result;    }
public static JBossPortComponentMetaData getJBossWebserviceMetaDataPortComponent(        final DeploymentUnit unit, final String name) {        if (name != null) {            final JBossWebservicesMetaData jbossWebserviceMetaData = unit.getAttachment(JBOSS_WEBSERVICES_METADATA_KEY);            if (jbossWebserviceMetaData != null) {                JBossPortComponentMetaData[] portComponent = jbossWebserviceMetaData.getPortComponents();                if (portComponent != null) {                    for (JBossPortComponentMetaData component : portComponent) {                        if (name.equals(component.getEjbName())) {                            return component;                        }                    }                }            }        }        return null;    }
public static EJBEndpoint getWebserviceMetadataEJBEndpoint(final JAXWSDeployment jaxwsDeployment,                                                               final String className) {        java.util.List<EJBEndpoint> ejbEndpointList = jaxwsDeployment.getEjbEndpoints();        for (EJBEndpoint ejbEndpoint : ejbEndpointList) {            if (className.equals(ejbEndpoint.getClassName())) {                return ejbEndpoint;            }        }        return null;    }
public static String getContextRoot(final Deployment dep, final JBossWebMetaData jbossWebMD) {        final DeploymentUnit unit = WSHelper.getRequiredAttachment(dep, DeploymentUnit.class);        final JBossAppMetaData jbossAppMD = unit.getParent() == null ? null : ASHelper.getOptionalAttachment(unit.getParent(),                WSAttachmentKeys.JBOSS_APP_METADATA_KEY);        String contextRoot = null;        // prefer context root defined in application.xml over one defined in jboss-web.xml        if (jbossAppMD != null) {            final ModuleMetaData moduleMD = jbossAppMD.getModules().get(dep.getSimpleName());            if (moduleMD != null) {                final WebModuleMetaData webModuleMD = (WebModuleMetaData) moduleMD.getValue();                contextRoot = webModuleMD.getContextRoot();            }        }        if (contextRoot == null) {            contextRoot = jbossWebMD != null ? jbossWebMD.getContextRoot() : null;        }        return contextRoot;    }
@Override    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode originalOperation) throws OperationFailedException {        String originalName = Operations.getName(originalOperation);        PathAddress originalAddress = Operations.getPathAddress(originalOperation);        Deque<ModelNode> preSteps = new LinkedList<>();        Deque<ModelNode> postSteps = new LinkedList<>();        ModelNode operation = originalOperation;        for (OperationTransformer transformer: this.transformers) {            operation = transformer.transformOperation(context, address, operation).getTransformedOperation();            // If the transformed operation is a composite operation, locate the modified operation and record any pre/post operations            if (this.collate && operation.get(ModelDescriptionConstants.OP).asString().equals(ModelDescriptionConstants.COMPOSITE)) {                List<ModelNode> stepList = operation.get(ModelDescriptionConstants.STEPS).asList();                ListIterator<ModelNode> steps = stepList.listIterator();                while (steps.hasNext()) {                    ModelNode step = steps.next();                    String operationName = Operations.getName(step);                    PathAddress operationAddress = Operations.getPathAddress(step);                    if (operationName.equals(originalName) && operationAddress.equals(originalAddress)) {                        operation = step;                        break;                    }                    preSteps.addLast(step);                }                steps = stepList.listIterator(stepList.size());                while (steps.hasPrevious()) {                    ModelNode step = steps.previous();                    String operationName = Operations.getName(step);                    PathAddress operationAddress = Operations.getPathAddress(step);                    if (operationName.equals(originalName) && operationAddress.equals(originalAddress)) {                        break;                    }                    postSteps.addFirst(step);                }            }        }        if (this.collate) {            int count = preSteps.size() + postSteps.size() + 1;            // If there are any pre or post steps, we need a composite operation            if (count > 1) {                List<ModelNode> steps = new ArrayList<>(count);                steps.addAll(preSteps);                steps.add(operation);                steps.addAll(postSteps);                operation = Operations.createCompositeOperation(steps);            }        }        return new TransformedOperation(operation, OperationResultTransformer.ORIGINAL_RESULT);    }
@Override    public void start(StartContext context) throws StartException {        SecurityLogger.ROOT_LOGGER.debug("Starting JaasConfigurationService");        // set new configuration        synchronized(Configuration.class) {            Configuration.setConfiguration(configuration);        }    }
protected Properties getConfigurationProperties(OperationContext context, ModelNode model) throws OperationFailedException {        Properties props = new Properties();        getResourceProperties(props, IIOPRootDefinition.INSTANCE, context, model);        // check if the node contains a list of generic properties.        ModelNode configNode = model.get(Constants.CONFIGURATION);        if (configNode.hasDefined(Constants.PROPERTIES)) {            for (Property property : configNode.get(Constants.PROPERTIES).get(Constants.PROPERTY)                    .asPropertyList()) {                String name = property.getName();                String value = property.getValue().get(Constants.PROPERTY_VALUE).asString();                props.setProperty(name, value);            }        }        return props;    }
private void setupInitializers(Properties props) {        List<String> orbInitializers = new ArrayList<String>();        // check which groups of initializers are to be installed.        String installSecurity = (String) props.remove(Constants.ORB_INIT_SECURITY);        if (installSecurity.equalsIgnoreCase(Constants.CLIENT)) {            orbInitializers.addAll(Arrays.asList(IIOPInitializer.SECURITY_CLIENT.getInitializerClasses()));        } else if (installSecurity.equalsIgnoreCase(Constants.IDENTITY)) {            orbInitializers.addAll(Arrays.asList(IIOPInitializer.SECURITY_IDENTITY.getInitializerClasses()));        } else if (installSecurity.equalsIgnoreCase(Constants.ELYTRON)) {            final String authContext = props.getProperty(Constants.ORB_INIT_AUTH_CONTEXT);            ElytronSASClientInterceptor.setAuthenticationContextName(authContext);            orbInitializers.addAll(Arrays.asList(IIOPInitializer.SECURITY_ELYTRON.getInitializerClasses()));        }        String installTransaction = (String) props.remove(Constants.ORB_INIT_TRANSACTIONS);        if (installTransaction.equalsIgnoreCase(Constants.FULL)) {            orbInitializers.addAll(Arrays.asList(IIOPInitializer.TRANSACTIONS.getInitializerClasses()));        } else if (installTransaction.equalsIgnoreCase(Constants.SPEC)) {            orbInitializers.addAll(Arrays.asList(IIOPInitializer.SPEC_TRANSACTIONS.getInitializerClasses()));        }        // add the standard opendk initializer plus all configured initializers.        for (String initializerClass : orbInitializers) {            props.setProperty(Constants.ORB_INITIALIZER_PREFIX + initializerClass, "");        }    }
private boolean setupSSLFactories(final Properties props) throws OperationFailedException {        final boolean supportSSL = "true".equalsIgnoreCase(props.getProperty(Constants.SECURITY_SUPPORT_SSL));        final boolean sslConfigured;        if (supportSSL) {            // if the config is using Elytron supplied SSL contexts, install the SSLSocketFactory.            final String serverSSLContextName = props.getProperty(Constants.SERVER_SSL_CONTEXT);            final String clientSSLContextName = props.getProperty(Constants.CLIENT_SSL_CONTEXT);            if (serverSSLContextName != null && clientSSLContextName != null) {                SSLSocketFactory.setServerSSLContextName(serverSSLContextName);                SSLSocketFactory.setClientSSLContextName(clientSSLContextName);                props.setProperty(ORBConstants.SOCKET_FACTORY_CLASS_PROPERTY, SSLSocketFactory.class.getName());            }            else {                // if the config only has a legacy JSSE domain reference, install the LegacySSLSocketFactory.                final String securityDomain = props.getProperty(Constants.SECURITY_SECURITY_DOMAIN);                LegacySSLSocketFactory.setSecurityDomain(securityDomain);                props.setProperty(ORBConstants.SOCKET_FACTORY_CLASS_PROPERTY, LegacySSLSocketFactory.class.getName());            }            sslConfigured = true;        } else {            props.setProperty(ORBConstants.SOCKET_FACTORY_CLASS_PROPERTY, NoSSLSocketFactory.class.getName());            sslConfigured = false;        }        return sslConfigured;    }
@Override    public void start(StartContext context) throws StartException {        log.debugf("Starting SecurityBootstrapService");        //Print out the current version of PicketBox        SecurityLogger.ROOT_LOGGER.currentVersion(org.picketbox.Version.VERSION);        initializeJacc();        setupPolicyRegistration(context);    }
@SuppressWarnings("rawtypes")    @Override    public void stop(StopContext context) {        // remove handlers        Set handlerKeys = PolicyContext.getHandlerKeys();        handlerKeys.remove(SecurityConstants.CALLBACK_HANDLER_KEY);        handlerKeys.remove(SecurityConstants.SUBJECT_CONTEXT_KEY);        // Install the policy provider that existed on startup        if (initializeJacc && jaccPolicy != null)            Policy.setPolicy(oldPolicy);    }
@Override    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) {        ModelNode legacyOperation = Util.createRemoveOperation(this.addressTransformer.transform(address));        return new TransformedOperation(legacyOperation, OperationResultTransformer.ORIGINAL_RESULT);    }
@Override    public Class<?> classForName(String name) {        try {            if (classes.containsKey(name)) {                return classes.get(name);            }            final Class<?> clazz = module.getClassLoader().loadClass(name);            classes.put(name, clazz);            return clazz;        } catch (ClassNotFoundException | LinkageError e) {            throw new ResourceLoadingException(e);        }    }
@Override    public URL getResource(String name) {        try {            return module.getClassLoader().getResource(name);        } catch (Exception e) {            throw new ResourceLoadingException(e);        }    }
@Override    public Collection<URL> getResources(String name) {        try {            final HashSet<URL> resources = new HashSet<URL>();            Enumeration<URL> urls = module.getClassLoader().getResources(name);            while (urls.hasMoreElements()) {                resources.add(urls.nextElement());            }            return resources;        } catch (Exception e) {            throw new ResourceLoadingException(e);        }    }
public List<Resource> list(String path) {        try {            final List<Resource> ret = new ArrayList<>();            Resource res = deploymentResourceManager.getResource(path);            if (res != null) {                for (Resource child : res.list()) {                    ret.add(new ServletResource(this, child));                }            }            String p = path;            if (p.startsWith("/")) {                p = p.substring(1);            }            if (overlays != null) {                for (VirtualFile overlay : overlays) {                    VirtualFile child = overlay.getChild(p);                    if (child.exists()) {                        VirtualFileResource vfsResource = new VirtualFileResource(overlay.getPhysicalFile(), child, path);                        for (Resource c : vfsResource.list()) {                            ret.add(new ServletResource(this, c));                        }                    }                }            }            return ret;        } catch (IOException e) {            throw new RuntimeException(e); //this method really should have thrown IOException        }    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleLoader moduleLoader = Module.getBootModuleLoader();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, RESOURCE_API_ID, false, false, false, false));        if (phaseContext.getDeploymentUnit().getAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY) == null) {            return;  // Skip non ra deployments        }        //if a module depends on a rar it also needs a dep on all the rar's "local dependencies"        moduleSpecification.setLocalDependenciesTransitive(true);        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JMS_ID, false, false, false, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, VALIDATION_ID, false, false, false, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, IRON_JACAMAR_ID, false, false, false, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, IRON_JACAMAR_IMPL_ID, false, true, false, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, HIBERNATE_VALIDATOR_ID, false, false, true, false));        if (! appclient)            phaseContext.addDeploymentDependency(ConnectorServices.RESOURCEADAPTERS_SUBSYSTEM_SERVICE, ResourceAdaptersSubsystemService.ATTACHMENT_KEY);    }
public static void popCall() {        Map<String, EntityManager> emStack = nonTxStack.pop();        if (emStack != null) {            for (EntityManager entityManager : emStack.values()) {                try {                    if (entityManager.isOpen()) {                        entityManager.close();                    }                } catch (RuntimeException safeToIgnore) {                    if (ROOT_LOGGER.isTraceEnabled()) {                        ROOT_LOGGER.trace("Could not close (non-transactional) container managed entity manager." +                            "  This shouldn't impact application functionality (only read " +                            "operations occur in non-transactional mode)", safeToIgnore);                    }                }            }        }    }
public static EntityManager get(String puScopedName) {        Map<String, EntityManager> map = nonTxStack.peek();        if (map != null) {            return map.get(puScopedName);        }        return null;    }
void registerCleanUpListener(TransactionSynchronizationRegistry transactionSynchronizationRegistry, JMSContext contextInstance) {        //to avoid registration of more listeners for one context, flag in transaction is used.        Object alreadyRegistered = transactionSynchronizationRegistry.getResource(contextInstance);        if (alreadyRegistered == null) {            transactionSynchronizationRegistry.registerInterposedSynchronization(new AfterCompletionSynchronization(contextInstance));            transactionSynchronizationRegistry.putResource(contextInstance, AfterCompletionSynchronization.class.getName());        }    }
@Override    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {        final ModelNode ejb3SubsystemAddOperation = Util.createAddOperation(SUBSYSTEM_PATH);        operations.add(ejb3SubsystemAddOperation);        readAttributes(reader);        // elements        final EnumSet<EJB3SubsystemXMLElement> encountered = EnumSet.noneOf(EJB3SubsystemXMLElement.class);        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {            if (EJB3SubsystemNamespace.forUri(reader.getNamespaceURI()) != getExpectedNamespace()) {                throw unexpectedElement(reader);            }            final EJB3SubsystemXMLElement element = EJB3SubsystemXMLElement.forName(reader.getLocalName());            if (!encountered.add(element)) {                throw unexpectedElement(reader);            }            readElement(reader, element, operations, ejb3SubsystemAddOperation);        }    }
public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {            return; // Skip non web deployments        }        WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);        assert warMetaData != null;        Map<String, WebMetaData> annotationsMetaData = warMetaData.getAnnotationsMetaData();        if (annotationsMetaData == null) {            annotationsMetaData = new HashMap<String, WebMetaData>();            warMetaData.setAnnotationsMetaData(annotationsMetaData);        }        Map<ResourceRoot, Index> indexes = AnnotationIndexUtils.getAnnotationIndexes(deploymentUnit);        // Process lib/*.jar        for (final Entry<ResourceRoot, Index> entry : indexes.entrySet()) {            final Index jarIndex = entry.getValue();            annotationsMetaData.put(entry.getKey().getRootName(), processAnnotations(jarIndex));        }        Map<ModuleIdentifier, CompositeIndex> additionalModelAnnotations = deploymentUnit.getAttachment(Attachments.ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE);        if (additionalModelAnnotations != null) {            final List<WebMetaData> additional = new ArrayList<WebMetaData>();            for (Entry<ModuleIdentifier, CompositeIndex> entry : additionalModelAnnotations.entrySet()) {                for(Index index : entry.getValue().getIndexes()) {                    additional.add(processAnnotations(index));                }            }            warMetaData.setAdditionalModuleAnnotationsMetadata(additional);        }    }
protected WebMetaData processAnnotations(Index index)    throws DeploymentUnitProcessingException {        WebMetaData metaData = new WebMetaData();        // @WebServlet        final List<AnnotationInstance> webServletAnnotations = index.getAnnotations(webServlet);        if (webServletAnnotations != null && webServletAnnotations.size() > 0) {            ServletsMetaData servlets = new ServletsMetaData();            List<ServletMappingMetaData> servletMappings = new ArrayList<ServletMappingMetaData>();            for (final AnnotationInstance annotation : webServletAnnotations) {                ServletMetaData servlet = new ServletMetaData();                AnnotationTarget target = annotation.target();                if (!(target instanceof ClassInfo)) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidWebServletAnnotation(target));                }                ClassInfo classInfo = ClassInfo.class.cast(target);                servlet.setServletClass(classInfo.toString());                AnnotationValue nameValue = annotation.value("name");                if (nameValue == null || nameValue.asString().isEmpty()) {                    servlet.setName(classInfo.toString());                } else {                    servlet.setName(nameValue.asString());                }                AnnotationValue loadOnStartup = annotation.value("loadOnStartup");                if (loadOnStartup != null && loadOnStartup.asInt() >= 0) {                    servlet.setLoadOnStartupInt(loadOnStartup.asInt());                }                AnnotationValue asyncSupported = annotation.value("asyncSupported");                if (asyncSupported != null) {                    servlet.setAsyncSupported(asyncSupported.asBoolean());                }                AnnotationValue initParamsValue = annotation.value("initParams");                if (initParamsValue != null) {                    AnnotationInstance[] initParamsAnnotations = initParamsValue.asNestedArray();                    if (initParamsAnnotations != null && initParamsAnnotations.length > 0) {                        List<ParamValueMetaData> initParams = new ArrayList<ParamValueMetaData>();                        for (AnnotationInstance initParamsAnnotation : initParamsAnnotations) {                            ParamValueMetaData initParam = new ParamValueMetaData();                            AnnotationValue initParamName = initParamsAnnotation.value("name");                            AnnotationValue initParamValue = initParamsAnnotation.value();                            if (initParamName == null || initParamValue == null) {                                throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidWebInitParamAnnotation(target));                            }                            AnnotationValue initParamDescription = initParamsAnnotation.value("description");                            initParam.setParamName(initParamName.asString());                            initParam.setParamValue(initParamValue.asString());                            if (initParamDescription != null) {                                Descriptions descriptions = getDescription(initParamDescription.asString());                                if (descriptions != null) {                                    initParam.setDescriptions(descriptions);                                }                            }                            initParams.add(initParam);                        }                        servlet.setInitParam(initParams);                    }                }                AnnotationValue descriptionValue = annotation.value("description");                AnnotationValue displayNameValue = annotation.value("displayName");                AnnotationValue smallIconValue = annotation.value("smallIcon");                AnnotationValue largeIconValue = annotation.value("largeIcon");                DescriptionGroupMetaData descriptionGroup =                    getDescriptionGroup((descriptionValue == null) ? "" : descriptionValue.asString(),                            (displayNameValue == null) ? "" : displayNameValue.asString(),                            (smallIconValue == null) ? "" : smallIconValue.asString(),                            (largeIconValue == null) ? "" : largeIconValue.asString());                if (descriptionGroup != null) {                    servlet.setDescriptionGroup(descriptionGroup);                }                ServletMappingMetaData servletMapping = new ServletMappingMetaData();                servletMapping.setServletName(servlet.getName());                List<String> urlPatterns = new ArrayList<String>();                AnnotationValue urlPatternsValue = annotation.value("urlPatterns");                if (urlPatternsValue != null) {                    for (String urlPattern : urlPatternsValue.asStringArray()) {                        urlPatterns.add(urlPattern);                    }                }                urlPatternsValue = annotation.value();                if (urlPatternsValue != null) {                    for (String urlPattern : urlPatternsValue.asStringArray()) {                        urlPatterns.add(urlPattern);                    }                }                if (urlPatterns.size() > 0) {                    servletMapping.setUrlPatterns(urlPatterns);                    servletMappings.add(servletMapping);                }                servlets.add(servlet);            }            metaData.setServlets(servlets);            metaData.setServletMappings(servletMappings);        }        // @WebFilter        final List<AnnotationInstance> webFilterAnnotations = index.getAnnotations(webFilter);        if (webFilterAnnotations != null && webFilterAnnotations.size() > 0) {            FiltersMetaData filters = new FiltersMetaData();            List<FilterMappingMetaData> filterMappings = new ArrayList<FilterMappingMetaData>();            for (final AnnotationInstance annotation : webFilterAnnotations) {                FilterMetaData filter = new FilterMetaData();                AnnotationTarget target = annotation.target();                if (!(target instanceof ClassInfo)) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidWebFilterAnnotation(target));                }                ClassInfo classInfo = ClassInfo.class.cast(target);                filter.setFilterClass(classInfo.toString());                AnnotationValue nameValue = annotation.value("filterName");                if (nameValue == null || nameValue.asString().isEmpty()) {                    filter.setName(classInfo.toString());                } else {                    filter.setName(nameValue.asString());                }                AnnotationValue asyncSupported = annotation.value("asyncSupported");                if (asyncSupported != null) {                    filter.setAsyncSupported(asyncSupported.asBoolean());                }                AnnotationValue initParamsValue = annotation.value("initParams");                if (initParamsValue != null) {                    AnnotationInstance[] initParamsAnnotations = initParamsValue.asNestedArray();                    if (initParamsAnnotations != null && initParamsAnnotations.length > 0) {                        List<ParamValueMetaData> initParams = new ArrayList<ParamValueMetaData>();                        for (AnnotationInstance initParamsAnnotation : initParamsAnnotations) {                            ParamValueMetaData initParam = new ParamValueMetaData();                            AnnotationValue initParamName = initParamsAnnotation.value("name");                            AnnotationValue initParamValue = initParamsAnnotation.value();                            if (initParamName == null || initParamValue == null) {                                throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidWebInitParamAnnotation(target));                            }                            AnnotationValue initParamDescription = initParamsAnnotation.value("description");                            initParam.setParamName(initParamName.asString());                            initParam.setParamValue(initParamValue.asString());                            if (initParamDescription != null) {                                Descriptions descriptions = getDescription(initParamDescription.asString());                                if (descriptions != null) {                                    initParam.setDescriptions(descriptions);                                }                            }                            initParams.add(initParam);                        }                        filter.setInitParam(initParams);                    }                }                AnnotationValue descriptionValue = annotation.value("description");                AnnotationValue displayNameValue = annotation.value("displayName");                AnnotationValue smallIconValue = annotation.value("smallIcon");                AnnotationValue largeIconValue = annotation.value("largeIcon");                DescriptionGroupMetaData descriptionGroup =                    getDescriptionGroup((descriptionValue == null) ? "" : descriptionValue.asString(),                            (displayNameValue == null) ? "" : displayNameValue.asString(),                            (smallIconValue == null) ? "" : smallIconValue.asString(),                            (largeIconValue == null) ? "" : largeIconValue.asString());                if (descriptionGroup != null) {                    filter.setDescriptionGroup(descriptionGroup);                }                filters.add(filter);                FilterMappingMetaData filterMapping = new FilterMappingMetaData();                filterMapping.setFilterName(filter.getName());                List<String> urlPatterns = new ArrayList<String>();                List<String> servletNames = new ArrayList<String>();                List<DispatcherType> dispatchers = new ArrayList<DispatcherType>();                AnnotationValue urlPatternsValue = annotation.value("urlPatterns");                if (urlPatternsValue != null) {                    for (String urlPattern : urlPatternsValue.asStringArray()) {                        urlPatterns.add(urlPattern);                    }                }                urlPatternsValue = annotation.value();                if (urlPatternsValue != null) {                    for (String urlPattern : urlPatternsValue.asStringArray()) {                        urlPatterns.add(urlPattern);                    }                }                if (urlPatterns.size() > 0) {                    filterMapping.setUrlPatterns(urlPatterns);                }                AnnotationValue servletNamesValue = annotation.value("servletNames");                if (servletNamesValue != null) {                    for (String servletName : servletNamesValue.asStringArray()) {                        servletNames.add(servletName);                    }                }                if (servletNames.size() > 0) {                    filterMapping.setServletNames(servletNames);                }                AnnotationValue dispatcherTypesValue = annotation.value("dispatcherTypes");                if (dispatcherTypesValue != null) {                    for (String dispatcherValue : dispatcherTypesValue.asEnumArray()) {                        dispatchers.add(DispatcherType.valueOf(dispatcherValue));                    }                }                if (dispatchers.size() > 0) {                    filterMapping.setDispatchers(dispatchers);                }                if (urlPatterns.size() > 0 || servletNames.size() > 0) {                    filterMappings.add(filterMapping);                }            }            metaData.setFilters(filters);            metaData.setFilterMappings(filterMappings);        }        // @WebListener        final List<AnnotationInstance> webListenerAnnotations = index.getAnnotations(webListener);        if (webListenerAnnotations != null && webListenerAnnotations.size() > 0) {            List<ListenerMetaData> listeners = new ArrayList<ListenerMetaData>();            for (final AnnotationInstance annotation : webListenerAnnotations) {                ListenerMetaData listener = new ListenerMetaData();                AnnotationTarget target = annotation.target();                if (!(target instanceof ClassInfo)) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidWebListenerAnnotation(target));                }                ClassInfo classInfo = ClassInfo.class.cast(target);                listener.setListenerClass(classInfo.toString());                AnnotationValue descriptionValue = annotation.value();                if (descriptionValue != null) {                    DescriptionGroupMetaData descriptionGroup = getDescriptionGroup(descriptionValue.asString());                    if (descriptionGroup != null) {                        listener.setDescriptionGroup(descriptionGroup);                    }                }                listeners.add(listener);            }            metaData.setListeners(listeners);        }        // @RunAs        final List<AnnotationInstance> runAsAnnotations = index.getAnnotations(runAs);        if (runAsAnnotations != null && runAsAnnotations.size() > 0) {            AnnotationsMetaData annotations = metaData.getAnnotations();            if (annotations == null) {               annotations = new AnnotationsMetaData();               metaData.setAnnotations(annotations);            }            for (final AnnotationInstance annotation : runAsAnnotations) {                AnnotationTarget target = annotation.target();                if (!(target instanceof ClassInfo)) {                    continue;                }                ClassInfo classInfo = ClassInfo.class.cast(target);                AnnotationMetaData annotationMD = annotations.get(classInfo.toString());                if (annotationMD == null) {                    annotationMD = new AnnotationMetaData();                    annotationMD.setClassName(classInfo.toString());                    annotations.add(annotationMD);                }                if (annotation.value() == null) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidRunAsAnnotation(target));                }                RunAsMetaData runAs = new RunAsMetaData();                runAs.setRoleName(annotation.value().asString());                annotationMD.setRunAs(runAs);            }        }        // @DeclareRoles        final List<AnnotationInstance> declareRolesAnnotations = index.getAnnotations(declareRoles);        if (declareRolesAnnotations != null && declareRolesAnnotations.size() > 0) {            SecurityRolesMetaData securityRoles = metaData.getSecurityRoles();            if (securityRoles == null) {               securityRoles = new SecurityRolesMetaData();               metaData.setSecurityRoles(securityRoles);            }            for (final AnnotationInstance annotation : declareRolesAnnotations) {                if (annotation.value() == null) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidDeclareRolesAnnotation(annotation.target()));                }                for (String role : annotation.value().asStringArray()) {                    SecurityRoleMetaData sr = new SecurityRoleMetaData();                    sr.setRoleName(role);                    securityRoles.add(sr);                }            }        }        // @MultipartConfig        final List<AnnotationInstance> multipartConfigAnnotations = index.getAnnotations(multipartConfig);        if (multipartConfigAnnotations != null && multipartConfigAnnotations.size() > 0) {            AnnotationsMetaData annotations = metaData.getAnnotations();            if (annotations == null) {               annotations = new AnnotationsMetaData();               metaData.setAnnotations(annotations);            }            for (final AnnotationInstance annotation : multipartConfigAnnotations) {                AnnotationTarget target = annotation.target();                if (!(target instanceof ClassInfo)) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidMultipartConfigAnnotation(target));                }                ClassInfo classInfo = ClassInfo.class.cast(target);                AnnotationMetaData annotationMD = annotations.get(classInfo.toString());                if (annotationMD == null) {                    annotationMD = new AnnotationMetaData();                    annotationMD.setClassName(classInfo.toString());                    annotations.add(annotationMD);                }                MultipartConfigMetaData multipartConfig = new MultipartConfigMetaData();                AnnotationValue locationValue = annotation.value("location");                if (locationValue != null && locationValue.asString().length() > 0) {                    multipartConfig.setLocation(locationValue.asString());                }                AnnotationValue maxFileSizeValue = annotation.value("maxFileSize");                if (maxFileSizeValue != null && maxFileSizeValue.asLong() != -1L) {                    multipartConfig.setMaxFileSize(maxFileSizeValue.asLong());                }                AnnotationValue maxRequestSizeValue = annotation.value("maxRequestSize");                if (maxRequestSizeValue != null && maxRequestSizeValue.asLong() != -1L) {                    multipartConfig.setMaxRequestSize(maxRequestSizeValue.asLong());                }                AnnotationValue fileSizeThresholdValue = annotation.value("fileSizeThreshold");                if (fileSizeThresholdValue != null && fileSizeThresholdValue.asInt() != 0) {                    multipartConfig.setFileSizeThreshold(fileSizeThresholdValue.asInt());                }                annotationMD.setMultipartConfig(multipartConfig);            }        }        // @ServletSecurity        final List<AnnotationInstance> servletSecurityAnnotations = index.getAnnotations(servletSecurity);        if (servletSecurityAnnotations != null && servletSecurityAnnotations.size() > 0) {            AnnotationsMetaData annotations = metaData.getAnnotations();            if (annotations == null) {               annotations = new AnnotationsMetaData();               metaData.setAnnotations(annotations);            }            for (final AnnotationInstance annotation : servletSecurityAnnotations) {                AnnotationTarget target = annotation.target();                if (!(target instanceof ClassInfo)) {                    throw new DeploymentUnitProcessingException(UndertowLogger.ROOT_LOGGER.invalidServletSecurityAnnotation(target));                }                ClassInfo classInfo = ClassInfo.class.cast(target);                AnnotationMetaData annotationMD = annotations.get(classInfo.toString());                if (annotationMD == null) {                    annotationMD = new AnnotationMetaData();                    annotationMD.setClassName(classInfo.toString());                    annotations.add(annotationMD);                }                ServletSecurityMetaData servletSecurity = new ServletSecurityMetaData();                AnnotationValue httpConstraintValue = annotation.value();                List<String> rolesAllowed = new ArrayList<String>();                if (httpConstraintValue != null) {                    AnnotationInstance httpConstraint = httpConstraintValue.asNested();                    AnnotationValue httpConstraintERSValue = httpConstraint.value();                    if (httpConstraintERSValue != null) {                        servletSecurity.setEmptyRoleSemantic(EmptyRoleSemanticType.valueOf(httpConstraintERSValue.asEnum()));                    }                    AnnotationValue httpConstraintTGValue = httpConstraint.value("transportGuarantee");                    if (httpConstraintTGValue != null) {                        servletSecurity.setTransportGuarantee(TransportGuaranteeType.valueOf(httpConstraintTGValue.asEnum()));                    }                    AnnotationValue rolesAllowedValue = httpConstraint.value("rolesAllowed");                    if (rolesAllowedValue != null) {                        for (String role : rolesAllowedValue.asStringArray()) {                            rolesAllowed.add(role);                        }                    }                }                servletSecurity.setRolesAllowed(rolesAllowed);                AnnotationValue httpMethodConstraintsValue = annotation.value("httpMethodConstraints");                if (httpMethodConstraintsValue != null) {                    AnnotationInstance[] httpMethodConstraints = httpMethodConstraintsValue.asNestedArray();                    if (httpMethodConstraints.length > 0) {                        List<HttpMethodConstraintMetaData> methodConstraints = new ArrayList<HttpMethodConstraintMetaData>();                        for (AnnotationInstance httpMethodConstraint : httpMethodConstraints) {                            HttpMethodConstraintMetaData methodConstraint = new HttpMethodConstraintMetaData();                            AnnotationValue httpMethodConstraintValue = httpMethodConstraint.value();                            if (httpMethodConstraintValue != null) {                                methodConstraint.setMethod(httpMethodConstraintValue.asString());                            }                            AnnotationValue httpMethodConstraintERSValue = httpMethodConstraint.value("emptyRoleSemantic");                            if (httpMethodConstraintERSValue != null) {                                methodConstraint.setEmptyRoleSemantic(EmptyRoleSemanticType.valueOf(httpMethodConstraintERSValue.asEnum()));                            }                            AnnotationValue httpMethodConstraintTGValue = httpMethodConstraint.value("transportGuarantee");                            if (httpMethodConstraintTGValue != null) {                                methodConstraint.setTransportGuarantee(TransportGuaranteeType.valueOf(httpMethodConstraintTGValue.asEnum()));                            }                            AnnotationValue rolesAllowedValue = httpMethodConstraint.value("rolesAllowed");                            rolesAllowed = new ArrayList<String>();                            if (rolesAllowedValue != null) {                                for (String role : rolesAllowedValue.asStringArray()) {                                    rolesAllowed.add(role);                                }                            }                            methodConstraint.setRolesAllowed(rolesAllowed);                            methodConstraints.add(methodConstraint);                        }                        servletSecurity.setHttpMethodConstraints(methodConstraints);                    }                }                annotationMD.setServletSecurity(servletSecurity);            }        }        return metaData;    }
private boolean updateServerConfig(String attributeName, String value, boolean isRevert) throws OperationFailedException, DisabledOperationException {        final ServerConfigImpl config = (ServerConfigImpl) ServerConfigFactoryImpl.getConfig();        try {            if (MODIFY_WSDL_ADDRESS.equals(attributeName)) {                final boolean modifyWSDLAddress = value != null && Boolean.parseBoolean(value);                config.setModifySOAPAddress(modifyWSDLAddress, isRevert);            } else if (WSDL_HOST.equals(attributeName)) {                final String host = value != null ? value : null;                try {                    config.setWebServiceHost(host, isRevert);                } catch (final UnknownHostException e) {                    throw new OperationFailedException(e.getMessage(), e);                }            } else if (WSDL_PORT.equals(attributeName)) {                final int port = value != null ? Integer.parseInt(value) : -1;                config.setWebServicePort(port, isRevert);            } else if (WSDL_SECURE_PORT.equals(attributeName)) {                final int securePort = value != null ? Integer.parseInt(value) : -1;                config.setWebServiceSecurePort(securePort, isRevert);            } else if (WSDL_PATH_REWRITE_RULE.equals(attributeName)) {                final String path = value != null ? value : null;                config.setWebServicePathRewriteRule(path, isRevert);            } else if (WSDL_URI_SCHEME.equals(attributeName)) {                if (value == null || value.equals("http") || value.equals("https")) {                    config.setWebServiceUriScheme(value, isRevert);                } else {                    throw new IllegalArgumentException(attributeName + " = " + value);                }            } else if (STATISTICS_ENABLED.equals(attributeName)) {                final boolean enabled = value != null ? Boolean.parseBoolean(value) : false;                config.setStatisticsEnabled(enabled);            } else {                throw new IllegalArgumentException(attributeName);            }        } catch (DisabledOperationException doe) {            // the WS stack rejected the runtime update            if (!isRevert) {                return false;            } else {                throw doe;            }        }        return true;    }
@Override    public void initialize(ExtensionContext context) {        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        // Register the root subsystem resource.        final ManagementResourceRegistration rootResource = subsystem.registerSubsystemModel(EeSubsystemRootResource.create());        // Mandatory describe operation        rootResource.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);        // register submodels        rootResource.registerSubModel(ContextServiceResourceDefinition.INSTANCE);        rootResource.registerSubModel(ManagedThreadFactoryResourceDefinition.INSTANCE);        rootResource.registerSubModel(ManagedExecutorServiceResourceDefinition.INSTANCE);        rootResource.registerSubModel(ManagedScheduledExecutorServiceResourceDefinition.INSTANCE);        rootResource.registerSubModel(new DefaultBindingsResourceDefinition(new DefaultBindingsConfigurationProcessor()));        subsystem.registerXMLElementWriter(EESubsystemXmlPersister.INSTANCE);    }
@Override    public void initializeParsers(ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.EE_1_0.getUriString(), EESubsystemParser10::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.EE_1_1.getUriString(), EESubsystemParser11::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.EE_1_2.getUriString(), EESubsystemParser12::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.EE_2_0.getUriString(), EESubsystemParser20::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.EE_3_0.getUriString(), EESubsystemParser20::new);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.EE_4_0.getUriString(), EESubsystemParser40::new);        context.setProfileParsingCompletionHandler(new BeanValidationProfileParsingCompletionHandler());    }
public Object processInvocation(final InterceptorContext context) throws Exception {        final ManagedReference reference = (ManagedReference) context.getPrivateData(ComponentInstance.class).getInstanceData(contextKey);        final Object instance = reference.getInstance();        try {            return method.invoke(instance, context.getParameters());        } catch (IllegalAccessException e) {            final IllegalAccessError n = new IllegalAccessError(e.getMessage());            n.setStackTrace(e.getStackTrace());            throw n;        } catch (InvocationTargetException e) {            throw Interceptors.rethrow(e.getCause());        }    }
private void startQueue(final String queueName,                            final ServiceTarget serviceTarget,                            final ServiceName serverServiceName,                            final ServiceBuilder<?> serviceBuilder,                            final DeploymentUnit deploymentUnit,                            final Injector<ManagedReferenceFactory> injector,                            final boolean external) {        final String selector = properties.containsKey(SELECTOR.getName()) ? properties.get(SELECTOR.getName()) : null;        final boolean durable = properties.containsKey(DURABLE.getName()) ? Boolean.valueOf(properties.get(DURABLE.getName())) : DURABLE.getDefaultValue().asBoolean();        final String managementAddress =  properties.containsKey(MANAGEMENT_ADDRESS.getName()) ? properties.get(MANAGEMENT_ADDRESS.getName()) : MANAGEMENT_ADDRESS.getDefaultValue().asString();        final String user =  properties.containsKey("management-user") ? properties.get("management-user") : null;        final String password =  properties.containsKey("management-password") ? properties.get("\"management-password") : null;        ModelNode destination = new ModelNode();        destination.get(NAME).set(queueName);        destination.get(DURABLE.getName()).set(durable);        if (selector != null) {            destination.get(SELECTOR.getName()).set(selector);        }        destination.get(ENTRIES).add(jndiName);        Service<Queue> queueService;        if(external) {            ServiceName pcfName= JMSServices.getPooledConnectionFactoryBaseServiceName(serverServiceName).append(resourceAdapter);            final ServiceName jmsQueueServiceName = JMSServices.getJmsQueueBaseServiceName(serverServiceName).append(queueName);            queueService = ExternalJMSQueueService.installRuntimeQueueService(                    DestinationConfiguration.Builder.getInstance()                            .setResourceAdapter(resourceAdapter)                            .setName(queueName)                            .setManagementQueueAddress(managementAddress)                            .setDestinationServiceName(jmsQueueServiceName)                            .setDurable(durable)                            .setSelector(selector)                            .setManagementUsername(user)                            .setManagementPassword(password)                            .build(),                    serviceTarget,                    pcfName);        } else {           queueService = JMSQueueService.installService(queueName, serviceTarget, serverServiceName, selector, durable);        }        inject(serviceBuilder, injector, queueService);        //create the management registration        String serverName = null;        final DeploymentResourceSupport deploymentResourceSupport = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_RESOURCE_SUPPORT);        PathAddress registration;        if (external) {            final PathElement dest = PathElement.pathElement(EXTERNAL_JMS_QUEUE, queueName);            deploymentResourceSupport.getDeploymentSubsystemModel(MessagingExtension.SUBSYSTEM_NAME);            registration = PathAddress.pathAddress(dest);        } else {            serverName = getActiveMQServerName(properties);            final PathElement dest = PathElement.pathElement(JMS_QUEUE, queueName);            final PathElement serverElement = PathElement.pathElement(SERVER, serverName);            deploymentResourceSupport.getDeploymentSubModel(MessagingExtension.SUBSYSTEM_NAME, serverElement);            registration = PathAddress.pathAddress(serverElement, dest);        }        MessagingXmlInstallDeploymentUnitProcessor.createDeploymentSubModel(registration, deploymentUnit);        JMSQueueConfigurationRuntimeHandler.INSTANCE.registerResource(serverName, queueName, destination);    }
public static boolean throwsRemoteException(Method method) {        Class[] exception = method.getExceptionTypes();        for (int i = 0; i < exception.length; ++i)            if (exception[i].isAssignableFrom(java.rmi.RemoteException.class))                return true;        return false;    }
public static boolean isAllFieldsPublic(Class c) {        try {            final Field[] list = c.getFields();            for (int i = 0; i < list.length; i++)                if (!Modifier.isPublic(list[i].getModifiers()))                    return false;        } catch (Exception e) {            return false;        }        return true;    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.InterfaceDefHelper.narrow(                    servantToReference(new InterfaceDefPOATie(this)));        }        return ref;    }
public Contained lookup(String search_name) {        Contained res = delegate.lookup(search_name);        return res;    }
public InterfaceDef[] base_interfaces() {        if (base_interfaces_ref == null) {            base_interfaces_ref = new InterfaceDef[base_interfaces.length];            for (int i = 0; i < base_interfaces_ref.length; ++i) {                Contained c = repository.lookup_id(base_interfaces[i]);                base_interfaces_ref[i] = InterfaceDefHelper.narrow(c);            }        }        return base_interfaces_ref;    }
public TypeCode type() {        if (typeCode == null)            typeCode = getORB().create_interface_tc(id, name);        return typeCode;    }
public Description describe() {        String defined_in_id = "IR";        if (defined_in instanceof org.omg.CORBA.ContainedOperations)            defined_in_id = ((org.omg.CORBA.ContainedOperations) defined_in).id();        org.omg.CORBA.InterfaceDescription md =                new InterfaceDescription(name, id, defined_in_id, version,                        base_interfaces, false);        Any any = getORB().create_any();        InterfaceDescriptionHelper.insert(any, md);        return new Description(DefinitionKind.dk_Interface, any);    }
public static String decode(String s) throws MalformedURLException {        try {            return decode(s, "8859_1");        } catch (UnsupportedEncodingException e) {            // ISO-Latin-1 should always be available?            throw IIOPLogger.ROOT_LOGGER.unavailableISOLatin1Decoder();        }    }
public static String decode(String s, String enc)            throws MalformedURLException, UnsupportedEncodingException {        int length = s.length();        byte[] bytes = new byte[length];        int j = 0;        for (int i = 0; i < length; i++) {            if (s.charAt(i) == '%') {                i++;  // skip %                try {                    bytes[j++] = (byte)                            Integer.parseInt(s.substring(i, i + 2), 16);                } catch (Exception e) {                    throw IIOPLogger.ROOT_LOGGER.invalidURIEncoding(s);                }                i++;  // skip first hex char; for loop will skip second one            } else {                bytes[j++] = (byte) s.charAt(i);            }        }        return new String(bytes, 0, j, enc);    }
public static String encode(String s, String enc)            throws UnsupportedEncodingException {        byte[] bytes = s.getBytes(enc);        int count = bytes.length;        /*         * From RFC 2396:         *         *     mark = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"         * reserved = ";" | "/" | ":" | "?" | "@" | "&" | "=" | "+" | "$" | ","         */        final String allowed = "=,+;.'-@&/$_()!~*:"; // '?' is omitted        char[] buf = new char[3 * count];        int j = 0;        for (int i = 0; i < count; i++) {            if ((bytes[i] >= 0x61 && bytes[i] <= 0x7A) || // a..z                    (bytes[i] >= 0x41 && bytes[i] <= 0x5A) || // A..Z                    (bytes[i] >= 0x30 && bytes[i] <= 0x39) || // 0..9                    (allowed.indexOf(bytes[i]) >= 0)) {                buf[j++] = (char) bytes[i];            } else {                buf[j++] = '%';                buf[j++] = Character.forDigit(0xF & (bytes[i] >>> 4), 16);                buf[j++] = Character.forDigit(0xF & bytes[i], 16);            }        }        return new String(buf, 0, j);    }
public final void newDeploymentModel(final DeploymentUnit unit) {        final ArchiveDeployment dep;        if (unit.hasAttachment(DEPLOYMENT_KEY)) {            dep = (ArchiveDeployment) unit.getAttachment(DEPLOYMENT_KEY);        } else {            dep = newDeployment(unit);            propagateAttachments(unit, dep);        }        this.build(dep, unit);    }
protected final Endpoint newHttpEndpoint(final String endpointClass, final String endpointName, final Deployment dep) {        if (endpointName == null) throw WSLogger.ROOT_LOGGER.nullEndpointName();        if (endpointClass == null) throw WSLogger.ROOT_LOGGER.nullEndpointClass();        final Endpoint endpoint = this.deploymentModelFactory.newHttpEndpoint(endpointClass);        endpoint.setShortName(endpointName);        endpoint.setType(endpointType);        dep.getService().addEndpoint(endpoint);        return endpoint;    }
private ArchiveDeployment newDeployment(final DeploymentUnit unit) {        WSLogger.ROOT_LOGGER.tracef("Creating new unified WS deployment model for %s", unit);        final ResourceRoot deploymentRoot = unit.getAttachment(Attachments.DEPLOYMENT_ROOT);        final VirtualFile root = deploymentRoot != null ? deploymentRoot.getRoot() : null;        final ClassLoader classLoader;        final Module module = unit.getAttachment(Attachments.MODULE);        if (module == null) {            classLoader = unit.getAttachment(CLASSLOADER_KEY);            if (classLoader == null) {                throw WSLogger.ROOT_LOGGER.classLoaderResolutionFailed(unit);            }        } else {            classLoader = module.getClassLoader();        }        ArchiveDeployment parentDep = null;        if (unit.getParent() != null) {            final Module parentModule = unit.getParent().getAttachment(Attachments.MODULE);            if (parentModule == null) {                throw WSLogger.ROOT_LOGGER.classLoaderResolutionFailed(deploymentRoot);            }            WSLogger.ROOT_LOGGER.tracef("Creating new unified WS deployment model for %s", unit.getParent());            parentDep = this.newDeployment(null, unit.getParent().getName(), parentModule.getClassLoader(), null);        }        final UnifiedVirtualFile uvf = root != null ? new VirtualFileAdaptor(root) : new ResourceLoaderAdapter(classLoader);        final ArchiveDeployment dep = this.newDeployment(parentDep, unit.getName(), classLoader, uvf);        //add an AnnotationInfo attachment that uses composite jandex index        dep.addAttachment(AnnotationsInfo.class, new JandexAnnotationsInfo(unit));        return dep;    }
private URI getURI(final ClientRequestInfo clientRequestInfo) throws URISyntaxException {        final StringBuilder builder = new StringBuilder("iiop:");        if (clientRequestInfo instanceof ClientRequestInfoImpl) {            ClientRequestInfoImpl infoImpl = (ClientRequestInfoImpl) clientRequestInfo;            CorbaConnection connection = (CorbaConnection) infoImpl.connection();            if(connection == null) {                return null;            }            ContactInfo info = connection.getContactInfo();            if (info instanceof SocketOrChannelContactInfoImpl) {                String hostname = ((SocketOrChannelContactInfoImpl) info).getHost();                if (hostname != null)                    builder.append("//").append(hostname);                int port = ((SocketOrChannelContactInfoImpl) info).getPort();                if (port > 0)                    builder.append(":").append(port);            }        } else {            return null;        }        return new URI(builder.toString());    }
private byte[] createInitialContextToken(final URI uri, final CompoundSecMech secMech) throws Exception {        AuthenticationContext authContext = this.authContext == null ? AuthenticationContext.captureCurrent() : this.authContext;        // obtain the configuration that matches the URI.        final AuthenticationConfiguration configuration = AUTH_CONFIG_CLIENT.getAuthenticationConfiguration(uri, authContext, -1, null, null);        // get the callback handler from the configuration and use it to obtain a username/password pair.        final CallbackHandler handler = AUTH_CONFIG_CLIENT.getCallbackHandler(configuration);        final NameCallback nameCallback = new NameCallback("Username: ");        final PasswordCallback passwordCallback = new PasswordCallback("Password: ", false);        try {            handler.handle(new Callback[]{nameCallback, passwordCallback});        } catch (UnsupportedCallbackException e) {            return NO_AUTHENTICATION_TOKEN;        }        // if the name callback contains a valid username we create the initial context token.        if (nameCallback.getName() != null && !nameCallback.getName().equals(AnonymousPrincipal.getInstance().getName())) {            byte[] encodedTargetName = secMech.as_context_mech.target_name;            String name = nameCallback.getName();            if (name.indexOf('@') < 0) {                byte[] decodedTargetName = CSIv2Util.decodeGssExportedName(encodedTargetName);                String targetName = new String(decodedTargetName, StandardCharsets.UTF_8);                name += "@" + targetName; // "@default"            }            byte[] username = name.getBytes(StandardCharsets.UTF_8);            byte[] password = {};            if (passwordCallback.getPassword() != null)                password = new String(passwordCallback.getPassword()).getBytes(StandardCharsets.UTF_8);            // create the initial context token and ASN.1-encode it, as defined in RFC 2743.            InitialContextToken authenticationToken = new InitialContextToken(username, password, encodedTargetName);            return CSIv2Util.encodeInitialContextToken(authenticationToken, codec);        }        return NO_AUTHENTICATION_TOKEN;    }
public static boolean isJaxrsDeployment(DeploymentUnit deploymentUnit) {        DeploymentUnit deployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit.getParent();        Boolean val = deployment.getAttachment(ATTACHMENT_KEY);        return val != null && val;    }
@Override    public void cancel() throws IllegalStateException, EJBException {        try {            timerService.cancelTimer(this);        } catch (InterruptedException e) {            throw new EJBException(e);        }    }
@Override    public TimerHandle getHandle() throws IllegalStateException, EJBException {        // make sure it's in correct state        this.assertTimerState();        // for non-persistent timers throws an exception (mandated by EJB3 spec)        if (this.persistent == false) {            throw EjbLogger.EJB3_TIMER_LOGGER.invalidTimerHandlersForPersistentTimers("EJB3.1 Spec 18.2.6");        }        return this.handle;    }
@Override    public Date getNextTimeout() throws IllegalStateException, EJBException {        // first check the validity of the timer state        this.assertTimerState();        if (this.nextExpiration == null) {            throw EjbLogger.EJB3_TIMER_LOGGER.noMoreTimeoutForTimer(this);        }        return this.nextExpiration;    }
public void setNextTimeout(Date next) {        if(next == null) {            setTimerState(TimerState.EXPIRED, null);        }        this.nextExpiration = next;    }
@Override    public long getTimeRemaining() throws IllegalStateException, EJBException {        // TODO: Rethink this implementation        // first check the validity of the timer state        this.assertTimerState();        if (this.nextExpiration == null) {            throw EjbLogger.EJB3_TIMER_LOGGER.noMoreTimeoutForTimer(this);        }        long currentTimeInMillis = System.currentTimeMillis();        long nextTimeoutInMillis = this.nextExpiration.getTime();        // if the next expiration is *not* in future and the repeat interval isn't        // a positive number (i.e. no repeats) then there won't be any more timeouts.        // So throw a NoMoreTimeoutsException.        // NOTE: We check for intervalDuration and not just nextExpiration because,        // it's a valid case where the nextExpiration is in past (maybe the server was        // down when the timeout was expected)        //      if (nextTimeoutInMillis < currentTimeInMillis && this.intervalDuration <= 0)        //      {        //         throw new NoMoreTimeoutsException("No more timeouts for timer " + this);        //      }        return nextTimeoutInMillis - currentTimeInMillis;    }
public boolean isActive() {        return timerService.isStarted() && !isCanceled() && !isExpired() && (timerService.isScheduled(getId()) || timerState == TimerState.CREATED);    }
protected void assertTimerState() {        if (timerState == TimerState.EXPIRED)            throw EjbLogger.EJB3_TIMER_LOGGER.timerHasExpired();        if (timerState == TimerState.CANCELED)            throw EjbLogger.EJB3_TIMER_LOGGER.timerWasCanceled();        AllowedMethodsInformation.checkAllowed(MethodType.TIMER_SERVICE_METHOD);    }
protected void setTimerState(TimerState state, Thread thread) {        assert ((state == TimerState.IN_TIMEOUT || state == TimerState.RETRY_TIMEOUT) && thread != null) || thread == null : "Invalid to set timer state " + state + " with executing Thread " + thread;        this.timerState = state;        this.executingThread = thread;    }
public void merge(final List<ResteasyDeploymentData> deploymentData) throws DeploymentUnitProcessingException {        for (ResteasyDeploymentData data : deploymentData) {            scannedApplicationClasses.addAll(data.getScannedApplicationClasses());            if (scanResources) {                scannedResourceClasses.addAll(data.getScannedResourceClasses());                scannedJndiComponentResources.addAll(data.getScannedJndiComponentResources());            }            if (scanProviders) {                scannedProviderClasses.addAll(data.getScannedProviderClasses());            }        }    }
protected Set<Principal> getMethodRolesAsPrincipals() {        Set<Principal> methodRoles = new HashSet<Principal>();        if (this.ejbMethodSecurityMetaData.isDenyAll())            methodRoles.add(NobodyPrincipal.NOBODY_PRINCIPAL);        else if (this.ejbMethodSecurityMetaData.isPermitAll())            methodRoles.add(AnybodyPrincipal.ANYBODY_PRINCIPAL);        else {            for (String role : this.ejbMethodSecurityMetaData.getRolesAllowed())                methodRoles.add(new SimplePrincipal(role));        }        return methodRoles;    }    /**     * <p>     * Gets the {@code MethodInterfaceType} that corresponds to the specified {@code MethodIntf}.     * </p>     *     * @param viewType the {@code MethodIntf} type to be converted.     * @return the converted type or {@code null} if the type cannot be converted.     */    protected MethodInterfaceType getMethodInterfaceType(MethodIntf viewType) {        switch (viewType) {            case HOME:                return MethodInterfaceType.Home;            case LOCAL_HOME:                return MethodInterfaceType.LocalHome;            case SERVICE_ENDPOINT:                return MethodInterfaceType.ServiceEndpoint;            case LOCAL:                return MethodInterfaceType.Local;            case REMOTE:                return MethodInterfaceType.Remote;            case TIMER:                return MethodInterfaceType.Timer;            case MESSAGE_ENDPOINT:                return MethodInterfaceType.MessageEndpoint;            default:                return null;        }    }    /**     * <p>     * Sets the JACC contextID using a privileged action and returns the previousID from the {@code PolicyContext}.     * </p>     *     * @param contextID the JACC contextID to be set.     * @return the previous contextID as retrieved from the {@code PolicyContext}.     */    protected String setContextID(final String contextID) {        if (! WildFlySecurityManager.isChecking()) {            final String previousID = PolicyContext.getContextID();            PolicyContext.setContextID(contextID);            return previousID;        } else {            final PrivilegedAction<String> action = new SetContextIDAction(contextID);            return AccessController.doPrivileged(action);        }    }    /**     * PrivilegedAction that sets the {@code PolicyContext} id.     */    private static class SetContextIDAction implements PrivilegedAction<String> {        private String contextID;        SetContextIDAction(final String contextID) {            this.contextID = contextID;        }        @Override        public String run() {            final String previousID = PolicyContext.getContextID();            PolicyContext.setContextID(this.contextID);            return previousID;        }    }}
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.ModuleDefHelper.narrow(                    servantToReference(new ModuleDefPOATie(this)));        }        return ref;    }
public Description describe() {        String defined_in_id = "IR";        if (defined_in instanceof ContainedOperations)            defined_in_id = ((ContainedOperations) defined_in).id();        ModuleDescription md = new ModuleDescription(name, id, defined_in_id,                version);        Any any = getORB().create_any();        ModuleDescriptionHelper.insert(any, md);        return new Description(DefinitionKind.dk_Module, any);    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        final ModuleLoader moduleLoader = Module.getBootModuleLoader();        //add jboss-invocation classes needed by the proxies        ModuleDependency invocation = new ModuleDependency(moduleLoader, JBOSS_INVOCATION_ID, false, false, false, false);        invocation.addImportFilter(PathFilters.is("org/jboss/invocation/proxy/classloading"), true);        invocation.addImportFilter(PathFilters.acceptAll(), false);        moduleSpecification.addSystemDependency(invocation);        ModuleDependency ee = new ModuleDependency(moduleLoader, JBOSS_AS_EE, false, false, false, false);        ee.addImportFilter(PathFilters.is("org/jboss/as/ee/component/serialization"), true);        ee.addImportFilter(PathFilters.is("org/jboss/as/ee/concurrent"), true);        ee.addImportFilter(PathFilters.is("org/jboss/as/ee/concurrent/handle"), true);        ee.addImportFilter(PathFilters.acceptAll(), false);        moduleSpecification.addSystemDependency(ee);        // add dep for naming permission        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, ModuleIdentifier.create(WILDFLY_NAMING), false, false, false, false));        //we always add all Java EE API modules, as the platform spec requires them to always be available        //we do not just add the javaee.api module, as this breaks excludes        for (final ModuleIdentifier moduleIdentifier : JAVA_EE_API_MODULES) {            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, moduleIdentifier, true, false, true, false));        }    }
private void handleJASPIMechanism(final DeploymentInfo deploymentInfo) {        ApplicationPolicy applicationPolicy = SecurityConfiguration.getApplicationPolicy(this.securityDomain);        if (applicationPolicy != null && JASPIAuthenticationInfo.class.isInstance(applicationPolicy.getAuthenticationInfo())) {            String authMethod = null;            LoginConfig loginConfig = deploymentInfo.getLoginConfig();            if (loginConfig != null && loginConfig.getAuthMethods().size() > 0) {                authMethod = loginConfig.getAuthMethods().get(0).getName();            }            deploymentInfo.setJaspiAuthenticationMechanism(new JASPICAuthenticationMechanism(securityDomain, authMethod));            deploymentInfo.setSecurityContextFactory(new JASPICSecurityContextFactory(this.securityDomain));            deploymentInfo.addOuterHandlerChainWrapper(next -> new JASPICSecureResponseHandler(next));        }    }
private void handleJACCAuthorization(final DeploymentInfo deploymentInfo) {        // TODO make the authorization manager implementation configurable in Undertow or jboss-web.xml        ApplicationPolicy applicationPolicy = SecurityConfiguration.getApplicationPolicy(this.securityDomain);        if (applicationPolicy != null) {            AuthorizationInfo authzInfo = applicationPolicy.getAuthorizationInfo();            if (authzInfo != null) {                for (AuthorizationModuleEntry entry : authzInfo.getModuleEntries()) {                    if (JACCAuthorizationModule.class.getName().equals(entry.getPolicyModuleName())) {                        deploymentInfo.setAuthorizationManager(JACCAuthorizationManager.INSTANCE);                        break;                    }                }            }        }    }
private static List<AuthMethodConfig> authMethod(String configuredMethod) {        if (configuredMethod == null) {            return Collections.singletonList(new AuthMethodConfig(HttpServletRequest.BASIC_AUTH));        }        return AuthMethodParser.parse(configuredMethod, Collections.singletonMap("CLIENT-CERT", HttpServletRequest.CLIENT_CERT_AUTH));    }
protected void addRemoteTransactionsDependency() {        this.getConfigurators().add(new ComponentConfigurator() {            @Override            public void configure(DeploymentPhaseContext context, ComponentDescription description, ComponentConfiguration componentConfiguration) throws DeploymentUnitProcessingException {                if (this.hasRemoteView((EJBComponentDescription) description)) {                    // add a dependency on local transaction service                    componentConfiguration.getCreateDependencies().add((sb, cs) -> sb.requires(TxnServices.JBOSS_TXN_REMOTE_TRANSACTION_SERVICE));                }            }            /**             * Returns true if the passed EJB component description has at least one remote view             * @param ejbComponentDescription             * @return             */            private boolean hasRemoteView(final EJBComponentDescription ejbComponentDescription) {                final Set<ViewDescription> views = ejbComponentDescription.getViews();                for (final ViewDescription view : views) {                    if (!(view instanceof EJBViewDescription)) {                        continue;                    }                    final MethodIntf viewType = ((EJBViewDescription) view).getMethodIntf();                    if (viewType == MethodIntf.REMOTE || viewType == MethodIntf.HOME) {                        return true;                    }                }                return false;            }        });    }
protected void addTransactionManagerDependencies() {        this.getConfigurators().add(new ComponentConfigurator() {            @Override            public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration componentConfiguration) throws DeploymentUnitProcessingException {                componentConfiguration.getCreateDependencies().add(new DependencyConfigurator<EJBComponentCreateService>() {                    @Override                    public void configureDependency(final ServiceBuilder<?> serviceBuilder, final EJBComponentCreateService ejbComponentCreateService) throws DeploymentUnitProcessingException {                        CapabilityServiceSupport support = context.getDeploymentUnit().getAttachment(org.jboss.as.server.deployment.Attachments.CAPABILITY_SERVICE_SUPPORT);                        // add dependency on the local transaction provider                        serviceBuilder.requires(support.getCapabilityServiceName("org.wildfly.transactions.global-default-local-provider"));                        // add dependency on TransactionSynchronizationRegistry                        serviceBuilder.addDependency(support.getCapabilityServiceName("org.wildfly.transactions.transaction-synchronization-registry"), TransactionSynchronizationRegistry.class, ejbComponentCreateService.getTransactionSynchronizationRegistryInjector());                    }                });            }        });    }
protected void addEJBSuspendHandlerDependency() {        getConfigurators().add(new ComponentConfigurator() {            @Override            public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration componentConfiguration) throws DeploymentUnitProcessingException {                componentConfiguration.getCreateDependencies().add(new DependencyConfigurator<EJBComponentCreateService>() {                    @Override public void configureDependency(final ServiceBuilder<?> serviceBuilder, final EJBComponentCreateService ejbComponentCreateService)                            throws DeploymentUnitProcessingException {                        serviceBuilder.addDependency(EJBSuspendHandlerService.SERVICE_NAME, EJBSuspendHandlerService.class,                                ejbComponentCreateService.getEJBSuspendHandlerInjector());                    }                });            }        });    }
protected void addServerSecurityManagerDependency() {        getConfigurators().add(new ComponentConfigurator() {            @Override            public void configure(final DeploymentPhaseContext context, final ComponentDescription description, final ComponentConfiguration componentConfiguration) throws DeploymentUnitProcessingException {                if (! ((EJBComponentDescription) description).isSecurityDomainKnown()) {                    final DeploymentUnit deploymentUnit = context.getDeploymentUnit();                    final CapabilityServiceSupport support = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.CAPABILITY_SERVICE_SUPPORT);                    componentConfiguration.getCreateDependencies().add(new DependencyConfigurator<EJBComponentCreateService>() {                        @Override                        public void configureDependency(final ServiceBuilder<?> serviceBuilder, final EJBComponentCreateService ejbComponentCreateService) throws DeploymentUnitProcessingException {                            serviceBuilder.addDependency(support.getCapabilityServiceName("org.wildfly.legacy-security.server-security-manager"), ServerSecurityManager.class, ejbComponentCreateService.getServerSecurityManagerInjector());                        }                    });                }            }        });    }
public boolean hasBeanLevelSecurityMetadata() {     // if an explicit security-domain is present, then we consider it the bean to be processed by security interceptors        if (securityDomain != null) {            return true;        }        // if a run-as is present, then we consider it the bean to be processed by security interceptors        if (runAsRole != null) {            return true;        }        // if a run-as-principal is present, then we consider it the bean to be processed by security interceptors        if (runAsPrincipal != null) {            return true;        }        // if security roles are configured then we consider the bean to be processed by security interceptors        if (securityRoles != null && !securityRoles.isEmpty()) {            return true;        }        // if security role links are configured then we consider the bean to be processed by security interceptors        if (securityRoleLinks != null && !securityRoleLinks.isEmpty()) {            return true;        }        // if declared roles are configured then we consider the bean to be processed by security interceptors        if (declaredRoles != null && !declaredRoles.isEmpty()) {            return true;        }        // no security metadata at bean level        return false;    }
public Set<InterceptorDescription> getAllContainerInterceptors() {        if (this.allContainerInterceptors == null) {            this.allContainerInterceptors = new HashSet<InterceptorDescription>();            this.allContainerInterceptors.addAll(this.classLevelContainerInterceptors);            if (!this.excludeDefaultContainerInterceptors) {                this.allContainerInterceptors.addAll(this.defaultContainerInterceptors);            }            for (List<InterceptorDescription> interceptors : this.methodLevelContainerInterceptors.values()) {                this.allContainerInterceptors.addAll(interceptors);            }        }        return this.allContainerInterceptors;    }
public void setAttribute(MethodIntf methodIntf, String className, T attribute) {        if (methodIntf != null && className != null)            throw EjbLogger.ROOT_LOGGER.bothMethodIntAndClassNameSet(componentName);        if (methodIntf == null) {            style1.put(className, attribute);        } else            perViewStyle1.put(methodIntf, attribute);    }
public void setAttribute(MethodIntf methodIntf, T transactionAttribute, String methodName) {        if (methodIntf == null)            style2.put(methodName, transactionAttribute);        else            perViewStyle2.pick(methodIntf).put(methodName, transactionAttribute);    }
public void setAttribute(MethodIntf methodIntf, T transactionAttribute, final String className, String methodName, String... methodParams) {        ArrayKey methodParamsKey = new ArrayKey((Object[]) methodParams);        if (methodIntf == null)            style3.pick(className).pick(methodName).put(methodParamsKey, transactionAttribute);        else            perViewStyle3.pick(methodIntf).pick(methodName).put(methodParamsKey, transactionAttribute);    }
public boolean isMethodLevel(MethodIntf methodIntf, Method method, MethodIntf defaultMethodIntf) {        assert methodIntf != null : "methodIntf is null";        assert method != null : "method is null";        Method classMethod = resolveRealMethod(method);        String[] methodParams = MethodInfoHelper.getCanonicalParameterTypes(classMethod);        final String methodName = classMethod.getName();        final String className = classMethod.getDeclaringClass().getName();        ArrayKey methodParamsKey = new ArrayKey((Object[]) methodParams);        T attr = get(get(get(perViewStyle3, methodIntf), methodName), methodParamsKey);        if (attr != null)            return true;        attr = get(get(perViewStyle2, methodIntf), methodName);        if (attr != null)            return true;        attr = get(perViewStyle1, methodIntf);        if (attr != null)            return false;        attr = get(get(get(style3, className), methodName), methodParamsKey);        if (attr != null)            return true;        attr = get(style2, methodName);        if (attr != null)            return true;        attr = get(style1, className);        if (attr != null)            return false;        if(defaultMethodIntf == null) {            return false;        } else {            return isMethodLevel(defaultMethodIntf, method, null);        }    }
@Override    protected JaccService<WarMetaData> createService(String contextId, WarMetaData metaData, Boolean standalone) {        return new WarJACCService(contextId, metaData, standalone);    }
@Override    public int getPort(final String protocol, final boolean secure) {        Map<String, UndertowListener> listeners = getListenerMap();        UndertowListener listener = null;        for (String p : listeners.keySet()) {            if (protocol.toLowerCase().contains(p)) {                listener = listeners.get(p);            }        }        if (listener != null && listener.getProtocol() == HttpListenerService.PROTOCOL && secure) {            if (listeners.containsKey(HttpsListenerService.PROTOCOL)) {                listener = listeners.get(HttpsListenerService.PROTOCOL);            } else {                UndertowLogger.ROOT_LOGGER.secureListenerNotAvailableForPort(protocol);            }        }        if (listener != null) {            SocketBinding binding = listener.getSocketBinding();            return binding.getAbsolutePort();        }        throw UndertowLogger.ROOT_LOGGER.noPortListeningForProtocol(protocol);    }
public static ServiceName getServiceName(final String appName, final String moduleName, final String beanName, final String viewClassName) {        final ServiceName serviceName;        if (appName != null) {            serviceName = BASE_SERVICE_NAME.append(appName);        } else {            serviceName = BASE_SERVICE_NAME;        }        return serviceName.append(moduleName).append(beanName).append(viewClassName);    }
public static String abbrevFor(Class clz) {        if (clz == Boolean.TYPE) {            return "Z";        } else if (clz == Byte.TYPE) {            return "B";        } else if (clz == Character.TYPE) {            return "C";        } else if (clz == Double.TYPE) {            return "D";        } else if (clz == Float.TYPE) {            return "F";        } else if (clz == Integer.TYPE) {            return "I";        } else if (clz == Long.TYPE) {            return "J";        } else if (clz == Short.TYPE) {            return "S";        } else if (clz == Void.TYPE) {            return "V";        } else if (clz == String.class) {            return "G"; // strinG        } else if (RmiIdlUtil.isRMIIDLRemoteInterface(clz)) {            return "R" + clz.getName(); // Remote interface        } else if (clz == org.omg.CORBA.Object.class) {            return "M"; // oMg (CORBA Object)        } else if (org.omg.CORBA.Object.class.isAssignableFrom(clz)) {            return "N" + clz.getName(); // IDL iNterface        } else if (IDLEntity.class.isAssignableFrom(clz)) {            return "L" + clz.getName(); // vaLuetype        } else if (clz == Serializable.class) {            return "E"; // sErializablE        } else if (RmiIdlUtil.isAbstractInterface(clz)) {            return "A"; // Abstract interface        } else if (Serializable.class.isAssignableFrom(clz)) {            return "L" + clz.getName(); // vaLuetype        } else if (Externalizable.class.isAssignableFrom(clz)) {            return "X"; // eXternalizable        } else if (clz == Object.class) {            return "O"; // Object        } else {            return "L" + clz.getName(); // vaLuetype        }    }
public static CDRStreamReader readerFor(String s, ClassLoader cl) {        switch (s.charAt(0)) {            case 'A':                return AbstractInterfaceReader.instance;            case 'B':                return ByteReader.instance;            case 'C':                return CharReader.instance;            case 'D':                return DoubleReader.instance;            case 'E':                return SerializableReader.instance;            case 'F':                return FloatReader.instance;            case 'G':                return StringReader.instance;            case 'I':                return IntReader.instance;            case 'J':                return LongReader.instance;            case 'L':                try {                    // Use Class.forName() (rather than cl.loadClass()), because                    // Class.forName() loads Java array types (which are valuetypes).                    return new ValuetypeReader(Class.forName(s.substring(1),                            true,                            cl));                } catch (ClassNotFoundException e) {                    throw IIOPLogger.ROOT_LOGGER.errorLoadingClass(s.substring(1), e);                }            case 'M':                return CorbaObjectReader.instance;            case 'N':                try {                    return new IdlInterfaceReader(cl.loadClass(s.substring(1)));                } catch (ClassNotFoundException e) {                    throw IIOPLogger.ROOT_LOGGER.errorLoadingClass(s.substring(1), e);                }            case 'O':                return ObjectReader.instance;            case 'R':                try {                    return new RemoteReader(cl.loadClass(s.substring(1)));                } catch (ClassNotFoundException e) {                    throw IIOPLogger.ROOT_LOGGER.errorLoadingClass(s.substring(1), e);                }            case 'S':                return ShortReader.instance;            case 'V':                return null;            case 'X':                return ExternalizableReader.instance;            case 'Z':                return BooleanReader.instance;            default:                return null;        }    }
public static CDRStreamWriter writerFor(String s, ClassLoader cl) {        switch (s.charAt(0)) {            case 'A':                return AbstractInterfaceWriter.instance;            case 'B':                return ByteWriter.instance;            case 'C':                return CharWriter.instance;            case 'D':                return DoubleWriter.instance;            case 'E':                return SerializableWriter.instance;            case 'F':                return FloatWriter.instance;            case 'G':                return StringWriter.instance;            case 'I':                return IntWriter.instance;            case 'J':                return LongWriter.instance;            case 'L':                try {                    // Use Class.forName() (rather than cl.loadClass()), because                    // Class.forName() loads Java array types (which are valuetypes).                    return new ValuetypeWriter(Class.forName(s.substring(1),                            true,                            cl));                } catch (ClassNotFoundException e) {                    throw IIOPLogger.ROOT_LOGGER.errorLoadingClass(s.substring(1), e);                }            case 'M':                return CorbaObjectWriter.instance;            case 'N':                try {                    return new IdlInterfaceWriter(cl.loadClass(s.substring(1)));                } catch (ClassNotFoundException e) {                    throw IIOPLogger.ROOT_LOGGER.errorLoadingClass(s.substring(1), e);                }            case 'O':                return ObjectWriter.instance;            case 'R':                return RemoteWriter.instance;            case 'S':                return ShortWriter.instance;            case 'V':                return null;            case 'X':                return ExternalizableWriter.instance;            case 'Z':                return BooleanWriter.instance;            default:                return null;        }    }
public static CDRStreamReader readerFor(Class clz) {        if (clz == Boolean.TYPE) {            return BooleanReader.instance;        } else if (clz == Byte.TYPE) {            return ByteReader.instance;        } else if (clz == Character.TYPE) {            return CharReader.instance;        } else if (clz == Double.TYPE) {            return DoubleReader.instance;        } else if (clz == Float.TYPE) {            return FloatReader.instance;        } else if (clz == Integer.TYPE) {            return IntReader.instance;        } else if (clz == Long.TYPE) {            return LongReader.instance;        } else if (clz == Short.TYPE) {            return ShortReader.instance;        } else if (clz == Void.TYPE) {            return null;        } else if (clz == String.class) {            return StringReader.instance;        } else if (RmiIdlUtil.isRMIIDLRemoteInterface(clz)) {            return new RemoteReader(clz);        } else if (clz == org.omg.CORBA.Object.class) {            return CorbaObjectReader.instance;        } else if (org.omg.CORBA.Object.class.isAssignableFrom(clz)) {            return new IdlInterfaceReader(clz);        } else if (IDLEntity.class.isAssignableFrom(clz)) {            return new ValuetypeReader(clz);        } else if (clz == Serializable.class) {            return SerializableReader.instance;        } else if (RmiIdlUtil.isAbstractInterface(clz)) {            return AbstractInterfaceReader.instance;        } else if (Serializable.class.isAssignableFrom(clz)) {            return new ValuetypeReader(clz);        } else if (Externalizable.class.isAssignableFrom(clz)) {            return ExternalizableReader.instance;        } else if (clz == Object.class) {            return ObjectReader.instance;        } else {            return new ValuetypeReader(clz);        }    }
public static CDRStreamWriter writerFor(Class clz) {        if (clz == Boolean.TYPE) {            return BooleanWriter.instance;        } else if (clz == Byte.TYPE) {            return ByteWriter.instance;        } else if (clz == Character.TYPE) {            return CharWriter.instance;        } else if (clz == Double.TYPE) {            return DoubleWriter.instance;        } else if (clz == Float.TYPE) {            return FloatWriter.instance;        } else if (clz == Integer.TYPE) {            return IntWriter.instance;        } else if (clz == Long.TYPE) {            return LongWriter.instance;        } else if (clz == Short.TYPE) {            return ShortWriter.instance;        } else if (clz == String.class) {            return StringWriter.instance;        } else if (clz == Void.TYPE) {            return null;        } else if (RmiIdlUtil.isRMIIDLRemoteInterface(clz)) {            return RemoteWriter.instance;        } else if (clz == org.omg.CORBA.Object.class) {            return CorbaObjectWriter.instance;        } else if (org.omg.CORBA.Object.class.isAssignableFrom(clz)) {            return new IdlInterfaceWriter(clz);        } else if (IDLEntity.class.isAssignableFrom(clz)) {            return new ValuetypeWriter(clz);        } else if (clz == Serializable.class) {            return SerializableWriter.instance;        } else if (RmiIdlUtil.isAbstractInterface(clz)) {            return AbstractInterfaceWriter.instance;        } else if (Serializable.class.isAssignableFrom(clz)) {            return new ValuetypeWriter(clz);        } else if (Externalizable.class.isAssignableFrom(clz)) {            return ExternalizableWriter.instance;        } else if (clz == Object.class) {            return ObjectWriter.instance;        } else {            return new ValuetypeWriter(clz);        }    }
protected void mergeInjectionsForClass(final Class<?> clazz, final Class<?> actualClass, final EEModuleClassDescription classDescription, final EEModuleDescription moduleDescription, final DeploymentReflectionIndex deploymentReflectionIndex, final ComponentDescription description, final ComponentConfiguration configuration, final DeploymentPhaseContext context, final Deque<InterceptorFactory> injectors, final Object instanceKey, final Deque<InterceptorFactory> uninjectors, boolean metadataComplete) throws DeploymentUnitProcessingException {        final Map<InjectionTarget, ResourceInjectionConfiguration> mergedInjections = new HashMap<InjectionTarget, ResourceInjectionConfiguration>();        if (classDescription != null && !metadataComplete) {            mergedInjections.putAll(classDescription.getInjectionConfigurations());        }        mergedInjections.putAll(moduleDescription.getResourceInjections(clazz.getName()));        mergedInjections.putAll(description.getResourceInjections(clazz.getName()));        for (final ResourceInjectionConfiguration injectionConfiguration : mergedInjections.values()) {            if(!moduleDescription.isAppClient() && injectionConfiguration.getTarget().isStatic(context.getDeploymentUnit())) {                ROOT_LOGGER.debugf("Injection for a member with static modifier is only acceptable on application clients, ignoring injection for target %s",injectionConfiguration.getTarget());                continue;            }            if(injectionConfiguration.getTarget() instanceof MethodInjectionTarget) {                //we need to make sure that if this is a method injection it has not been overriden                final MethodInjectionTarget mt = (MethodInjectionTarget)injectionConfiguration.getTarget();                Method method = mt.getMethod(deploymentReflectionIndex, clazz);                if(!isNotOverriden(clazz, method, actualClass, deploymentReflectionIndex)) {                    continue;                }            }            final Object valueContextKey = new Object();            final InjectedValue<ManagedReferenceFactory> managedReferenceFactoryValue = new InjectedValue<ManagedReferenceFactory>();            configuration.getStartDependencies().add(new ComponentDescription.InjectedConfigurator(injectionConfiguration, configuration, context, managedReferenceFactoryValue));            injectors.addFirst(injectionConfiguration.getTarget().createInjectionInterceptorFactory(instanceKey, valueContextKey, managedReferenceFactoryValue, context.getDeploymentUnit(), injectionConfiguration.isOptional()));            uninjectors.addLast(new ImmediateInterceptorFactory(new ManagedReferenceReleaseInterceptor(valueContextKey)));        }    }
protected static void checkOnlyOneOfElements(XMLExtendedStreamReader reader, Set<Element> seen, Element element1, Element element2) throws XMLStreamException {        if (!seen.contains(element1) && !seen.contains(element2)) {            throw new XMLStreamException(MessagingLogger.ROOT_LOGGER.required(element1.getLocalName(), element2.getLocalName()), reader.getLocation());        }        if (seen.contains(element1) && seen.contains(element2)) {            throw new XMLStreamException(MessagingLogger.ROOT_LOGGER.onlyOneRequired(element1.getLocalName(), element2.getLocalName()), reader.getLocation());        }    }
private void refreshChildren() {        final List<JobExecution> executions = new ArrayList<>();        // Casting to (Supplier<List<JobInstance>>) is done here on purpose as a workaround for a bug in 1.8.0_45        final List<JobInstance> instances = jobOperator.allowMissingJob((Supplier<List<JobInstance>>)() -> jobOperator.getJobInstances(jobName, 0, jobOperator.getJobInstanceCount(jobName))                , Collections.emptyList());        for (JobInstance instance : instances) {            executions.addAll(jobOperator.getJobExecutions(instance));        }        children.clear();        for (JobExecution execution : executions) {            final String name = Long.toString(execution.getExecutionId());            children.add(name);        }    }
static boolean forwardToRuntimeQueue(OperationContext context, ModelNode operation, OperationStepHandler handler) {        PathAddress address = context.getCurrentAddress();        // do not forward if the current operation is for a runtime-queue already:        if (RUNTIME_QUEUE.equals(address.getLastElement().getKey())) {            return false;        }        String queueName = address.getLastElement().getValue();        PathAddress activeMQPathAddress = MessagingServices.getActiveMQServerPathAddress(address);        if (context.readResourceFromRoot(activeMQPathAddress, false).hasChild(address.getLastElement())) {            return false;        } else {            // there is no registered queue resource, forward to the runtime-queue address instead            ModelNode forwardOperation = operation.clone();            forwardOperation.get(ModelDescriptionConstants.OP_ADDR).set(activeMQPathAddress.append(RUNTIME_QUEUE, queueName).toModelNode());            context.addStep(forwardOperation, handler, OperationContext.Stage.RUNTIME, true);            return true;        }    }
private static ConnectionFactoryAttribute[] define(ConnectionFactoryAttribute[] specific, ConnectionFactoryAttribute... common) {        int size = common.length + specific.length;        ConnectionFactoryAttribute[] result = new ConnectionFactoryAttribute[size];        arraycopy(specific, 0, result, 0, specific.length);        for (int i = 0; i < common.length; i++) {            ConnectionFactoryAttribute attr = common[i];            AttributeDefinition definition = attr.getDefinition();            ConnectionFactoryAttribute newAttr;            // replace the reconnect-attempts attribute to use a different default value for pooled CF            if (definition == Common.RECONNECT_ATTEMPTS) {                AttributeDefinition copy = copy(Pooled.RECONNECT_ATTEMPTS, AttributeAccess.Flag.RESTART_ALL_SERVICES);                newAttr = ConnectionFactoryAttribute.create(copy, Pooled.RECONNECT_ATTEMPTS_PROP_NAME, true);            } else {                AttributeDefinition copy = copy(definition, AttributeAccess.Flag.RESTART_ALL_SERVICES);                newAttr = ConnectionFactoryAttribute.create(copy, attr.getPropertyName(), attr.isResourceAdapterProperty(), attr.isInboundConfig());            }            result[specific.length + i] = newAttr;        }        return result;    }
protected static BeanInfo getTempBeanInfo(ConfigVisitor visitor, String className) {        return getTempBeanInfo(visitor, getType(visitor, className));    }
@SuppressWarnings({"unchecked"})    protected static BeanInfo getTempBeanInfo(ConfigVisitor visitor, Class<?> clazz) {        return new DefaultBeanInfo(visitor.getReflectionIndex(), clazz);    }
protected static Class<?> getType(ConfigVisitor visitor, String className) {        if (className != null) {            try {                return visitor.getModule().getClassLoader().loadClass(className);            } catch (Exception e) {                throw new IllegalArgumentException(e);            }        }        return null;    }
static Type getComponentType(ParameterizedType type, int index) {        Type[] tp = type.getActualTypeArguments();        if (index + 1 > tp.length)            return null;        return tp[index];    }
public static ResourceDefinition getElytronRealmResourceDefinition() {        final AttributeDefinition[] attributes = new AttributeDefinition[] {LEGACY_JAAS_CONFIG, APPLY_ROLE_MAPPERS};        final AbstractAddStepHandler addHandler = new BasicAddHandler<SecurityRealm>(attributes, SECURITY_REALM_RUNTIME_CAPABILITY) {            @Override            protected BasicService.ValueSupplier<SecurityRealm> getValueSupplier(ServiceBuilder<SecurityRealm> serviceBuilder, OperationContext context, ModelNode model) throws OperationFailedException {                final String legacyJAASConfig = asStringIfDefined(context, LEGACY_JAAS_CONFIG, model);                final boolean applyRoleMappers = APPLY_ROLE_MAPPERS.resolveModelAttribute(context, model).asBoolean();                final InjectedValue<SecurityDomainContext> securityDomainContextInjector = new InjectedValue<>();                if (legacyJAASConfig != null) {                    serviceBuilder.addDependency(SecurityDomainService.SERVICE_NAME.append(legacyJAASConfig), SecurityDomainContext.class, securityDomainContextInjector);                }                return () -> {                    final SecurityDomainContext domainContext = securityDomainContextInjector.getValue();                    return new SecurityDomainContextRealm(domainContext, applyRoleMappers);                };            }        };        return new BasicResourceDefinition(Constants.ELYTRON_REALM, addHandler, attributes, SECURITY_REALM_RUNTIME_CAPABILITY);    }
public static ResourceDefinition getElytronKeyStoreResourceDefinition() {        final AttributeDefinition[] attributes = new AttributeDefinition[] {LEGACY_JSSE_CONFIG};        final AbstractAddStepHandler addHandler = new BasicAddHandler<KeyStore>(attributes, KEY_STORE_RUNTIME_CAPABILITY) {            @Override            protected BasicService.ValueSupplier<KeyStore> getValueSupplier(ServiceBuilder<KeyStore> serviceBuilder, OperationContext context, ModelNode model) throws OperationFailedException {                final String legacyJSSEConfig = asStringIfDefined(context, LEGACY_JSSE_CONFIG, model);                final InjectedValue<SecurityDomainContext> securityDomainContextInjector = new InjectedValue<>();                if (legacyJSSEConfig != null) {                    serviceBuilder.addDependency(SecurityDomainService.SERVICE_NAME.append(legacyJSSEConfig), SecurityDomainContext.class, securityDomainContextInjector);                }                return () -> {                    final SecurityDomainContext domainContext = securityDomainContextInjector.getValue();                    final JSSESecurityDomain jsseDomain = domainContext.getJSSE();                    if (jsseDomain == null) {                        throw SecurityLogger.ROOT_LOGGER.unableToLocateJSSEConfig(legacyJSSEConfig);                    }                    final KeyStore keyStore = jsseDomain.getKeyStore();                    if (keyStore == null) {                        throw SecurityLogger.ROOT_LOGGER.unableToLocateComponentInJSSEDomain("KeyStore", legacyJSSEConfig);                    }                    return keyStore;                };            }        };        return new BasicResourceDefinition(Constants.ELYTRON_KEY_STORE, addHandler, attributes, KEY_STORE_RUNTIME_CAPABILITY);    }
public static ResourceDefinition getElytronKeyManagersResourceDefinition() {        final AttributeDefinition[] attributes = new AttributeDefinition[] {LEGACY_JSSE_CONFIG};        final AbstractAddStepHandler addHandler = new BasicAddHandler<KeyManager>(attributes, KEY_MANAGER_RUNTIME_CAPABILITY) {            @Override            protected BasicService.ValueSupplier<KeyManager> getValueSupplier(ServiceBuilder<KeyManager> serviceBuilder, OperationContext context, ModelNode model) throws OperationFailedException {                final String legacyJSSEConfig = asStringIfDefined(context, LEGACY_JSSE_CONFIG, model);                final InjectedValue<SecurityDomainContext> securityDomainContextInjector = new InjectedValue<>();                if (legacyJSSEConfig != null) {                    serviceBuilder.addDependency(SecurityDomainService.SERVICE_NAME.append(legacyJSSEConfig), SecurityDomainContext.class, securityDomainContextInjector);                }                return () -> {                    final SecurityDomainContext domainContext = securityDomainContextInjector.getValue();                    final JSSESecurityDomain jsseDomain = domainContext.getJSSE();                    if (jsseDomain == null) {                        throw SecurityLogger.ROOT_LOGGER.unableToLocateJSSEConfig(legacyJSSEConfig);                    }                    final KeyManager[] keyManagers = jsseDomain.getKeyManagers();                    if (keyManagers == null) {                        throw SecurityLogger.ROOT_LOGGER.unableToLocateComponentInJSSEDomain("KeyManager", legacyJSSEConfig);                    }                    for (KeyManager keyManager : keyManagers) {                        if (keyManager instanceof X509ExtendedKeyManager) {                            return keyManager;                        }                    }                    throw SecurityLogger.ROOT_LOGGER.expectedManagerTypeNotFound("KeyManager", X509ExtendedKeyManager.class.getSimpleName(), legacyJSSEConfig);                };            }        };        return new BasicResourceDefinition(Constants.ELYTRON_KEY_MANAGER, addHandler, attributes, KEY_MANAGER_RUNTIME_CAPABILITY);    }
public static ResourceDefinition getElytronTrustManagersResourceDefinition() {        final AttributeDefinition[] attributes = new AttributeDefinition[] {LEGACY_JSSE_CONFIG};        final AbstractAddStepHandler addHandler = new BasicAddHandler<TrustManager>(attributes, TRUST_MANAGER_RUNTIME_CAPABILITY) {            @Override            protected BasicService.ValueSupplier<TrustManager> getValueSupplier(ServiceBuilder<TrustManager> serviceBuilder, OperationContext context, ModelNode model) throws OperationFailedException {                final String legacyJSSEConfig = asStringIfDefined(context, LEGACY_JSSE_CONFIG, model);                final InjectedValue<SecurityDomainContext> securityDomainContextInjector = new InjectedValue<>();                if (legacyJSSEConfig != null) {                    serviceBuilder.addDependency(SecurityDomainService.SERVICE_NAME.append(legacyJSSEConfig), SecurityDomainContext.class, securityDomainContextInjector);                }                return () -> {                    final SecurityDomainContext domainContext = securityDomainContextInjector.getValue();                    final JSSESecurityDomain jsseDomain = domainContext.getJSSE();                    if (jsseDomain == null) {                        throw SecurityLogger.ROOT_LOGGER.unableToLocateJSSEConfig(legacyJSSEConfig);                    }                    final TrustManager[] trustManagers = jsseDomain.getTrustManagers();                    if (trustManagers == null) {                        throw SecurityLogger.ROOT_LOGGER.unableToLocateComponentInJSSEDomain("TrustManager", legacyJSSEConfig);                    }                    for (TrustManager trustManager : trustManagers) {                        if (trustManager instanceof X509ExtendedTrustManager)                            return trustManager;                    }                    throw SecurityLogger.ROOT_LOGGER.expectedManagerTypeNotFound("TrustManager", X509ExtendedTrustManager.class.getSimpleName(), legacyJSSEConfig);                };            }        };        return new BasicResourceDefinition(Constants.ELYTRON_TRUST_MANAGER, addHandler, attributes, TRUST_MANAGER_RUNTIME_CAPABILITY);    }
public Name parse(String name) throws NamingException {        Vector comps = insStringToStringifiedComps(name);        return new CNCompoundName(comps.elements());    }
static NameComponent[] nameToCosName(Name name)            throws InvalidNameException {        int len = name.size();        if (len == 0) {            return new NameComponent[0];        }        NameComponent[] answer = new NameComponent[len];        for (int i = 0; i < len; i++) {            answer[i] = parseComponent(name.get(i));        }        return answer;    }
static String cosNameToInsString(NameComponent[] cname) {        StringBuffer str = new StringBuffer();        for (int i = 0; i < cname.length; i++) {            if (i > 0) {                str.append(compSeparator);            }            str.append(stringifyComponent(cname[i]));        }        return str.toString();    }
static Name cosNameToName(NameComponent[] cname) {        Name nm = new CompositeName();        for (int i = 0; cname != null && i < cname.length; i++) {            try {                nm.add(stringifyComponent(cname[i]));            } catch (InvalidNameException e) {                // ignore            }        }        return nm;    }
private static Vector insStringToStringifiedComps(String str)            throws InvalidNameException {        int len = str.length();        Vector components = new Vector(10);        char[] id = new char[len];        char[] kind = new char[len];        int idCount, kindCount;        boolean idMode;        for (int i = 0; i < len; ) {            idCount = kindCount = 0; // reset for new component            idMode = true;           // always start off parsing id            while (i < len) {                if (str.charAt(i) == compSeparator) {                    break;                } else if (str.charAt(i) == escapeChar) {                    if (i + 1 >= len) {                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(str);                    } else if (isMeta(str.charAt(i + 1))) {                        ++i; // skip escape and let meta through                        if (idMode) {                            id[idCount++] = str.charAt(i++);                        } else {                            kind[kindCount++] = str.charAt(i++);                        }                    } else {                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(str);                    }                } else if (idMode && str.charAt(i) == kindSeparator) {                    // just look for the first kindSeparator                    ++i; // skip kind separator                    idMode = false;                } else {                    if (idMode) {                        id[idCount++] = str.charAt(i++);                    } else {                        kind[kindCount++] = str.charAt(i++);                    }                }            }            components.addElement(stringifyComponent(                    new NameComponent(new String(id, 0, idCount),                            new String(kind, 0, kindCount))));            if (i < len) {                ++i; // skip separator            }        }        return components;    }
private static NameComponent parseComponent(String compStr)            throws InvalidNameException {        NameComponent comp = new NameComponent();        int kindSep = -1;        int len = compStr.length();        int j = 0;        char[] newStr = new char[len];        boolean escaped = false;        // Find the kind separator        for (int i = 0; i < len && kindSep < 0; i++) {            if (escaped) {                newStr[j++] = compStr.charAt(i);                escaped = false;            } else if (compStr.charAt(i) == escapeChar) {                if (i + 1 >= len) {                    throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(compStr);                } else if (isMeta(compStr.charAt(i + 1))) {                    escaped = true;                } else {                    throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(compStr);                }            } else if (compStr.charAt(i) == kindSeparator) {                kindSep = i;            } else {                newStr[j++] = compStr.charAt(i);            }        }        // Set id        comp.id = new String(newStr, 0, j);        // Set kind        if (kindSep < 0) {            comp.kind = "";  // no kind separator        } else {            // unescape kind            j = 0;            escaped = false;            for (int i = kindSep + 1; i < len; i++) {                if (escaped) {                    newStr[j++] = compStr.charAt(i);                    escaped = false;                } else if (compStr.charAt(i) == escapeChar) {                    if (i + 1 >= len) {                        throw IIOPLogger.ROOT_LOGGER.unescapedCharacter(compStr);                    } else if (isMeta(compStr.charAt(i + 1))) {                        escaped = true;                    } else {                        throw IIOPLogger.ROOT_LOGGER.invalidEscapedCharacter(compStr);                    }                } else {                    newStr[j++] = compStr.charAt(i);                }            }            comp.kind = new String(newStr, 0, j);        }        return comp;    }
private static String escape(String str) {        if (str.indexOf(kindSeparator) < 0 &&                str.indexOf(compSeparator) < 0 &&                str.indexOf(escapeChar) < 0) {            return str;                         // no meta characters to escape        } else {            int len = str.length();            int j = 0;            char[] newStr = new char[len + len];            for (int i = 0; i < len; i++) {                if (isMeta(str.charAt(i))) {                    newStr[j++] = escapeChar;   // escape meta character                }                newStr[j++] = str.charAt(i);            }            return new String(newStr, 0, j);        }    }
@Override    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) {        ModelNode legacyOperation = Operations.createDescribeOperation(this.addressTransformer.transform(address));        return new TransformedOperation(legacyOperation, OperationResultTransformer.ORIGINAL_RESULT);    }
public void shutdown() {        POA poa = getPOA();        try {            poa.deactivate_object(poa.reference_to_id(getReference()));        } catch (UserException ex) {            IIOPLogger.ROOT_LOGGER.warnCouldNotDeactivateIRObject(ex);        }    }
protected org.omg.CORBA.Object servantToReference(Servant servant) {        byte[] id = getObjectId();        try {            repository.poa.activate_object_with_id(id, servant);            org.omg.CORBA.Object ref = repository.poa.id_to_reference(id);            return ref;        } catch (WrongPolicy ex) {            IIOPLogger.ROOT_LOGGER.debug("Exception converting CORBA servant to reference", ex);        } catch (ServantAlreadyActive ex) {            IIOPLogger.ROOT_LOGGER.debug("Exception converting CORBA servant to reference", ex);        } catch (ObjectAlreadyActive ex) {            IIOPLogger.ROOT_LOGGER.debug("Exception converting CORBA servant to reference", ex);        } catch (ObjectNotActive ex) {            IIOPLogger.ROOT_LOGGER.debug("Exception converting CORBA servant to reference", ex);        }        return null;    }
private void cleanupStartAsync(final StartContext context, final String deploymentName, final Throwable cause,                                   final ServiceName duServiceName, final ClassLoader toUse) {        ExecutorService executorService = getLifecycleExecutorService();        Runnable r = new Runnable() {            @Override            public void run() {                ClassLoader old = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();                try {                    WritableServiceBasedNamingStore.pushOwner(duServiceName);                    WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(toUse);                    unregisterAll(deploymentName);                } finally {                    try {                        context.failed(ConnectorLogger.ROOT_LOGGER.failedToStartRaDeployment(cause, deploymentName));                    } finally {                        WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(old);                        WritableServiceBasedNamingStore.popOwner();                    }                }            }        };        try {            executorService.execute(r);        } catch (RejectedExecutionException e) {            r.run();        } finally {            context.asynchronous();        }    }
private SecurityIdentity authenticate(final String username, final String password) {        ServerAuthenticationContext context = this.securityDomain.createNewAuthenticationContext();        PasswordGuessEvidence evidence = null;        try {            if (password == null) {                if (username == null) {                    if (context.authorizeAnonymous()) {                        context.succeed();                        return context.getAuthorizedIdentity();                    } else {                        context.fail();                        return null;                    }                } else {                    // treat a non-null user name with a null password as a auth failure                    context.fail();                    return null;                }            }            context.setAuthenticationName(username);            evidence = new PasswordGuessEvidence(password.toCharArray());            if (context.verifyEvidence(evidence)) {                if (context.authorize()) {                    context.succeed();                    return context.getAuthorizedIdentity();                }                else {                    context.fail();                    MessagingLogger.ROOT_LOGGER.failedAuthorization(username);                }            } else {                context.fail();                MessagingLogger.ROOT_LOGGER.failedAuthentication(username);            }        } catch (IllegalArgumentException | IllegalStateException | RealmUnavailableException e) {            context.fail();            MessagingLogger.ROOT_LOGGER.failedAuthenticationWithException(e, username, e.getMessage());        } finally {            if (evidence != null) {                evidence.destroy();            }        }        return null;    }
private static boolean isTypeMatched(Class<?> clz) {        if (clz.equals(String.class)) {            return true;        } else if (clz.equals(byte.class) || clz.equals(Byte.class)) {            return true;        } else if (clz.equals(short.class) || clz.equals(Short.class)) {            return true;        } else if (clz.equals(int.class) || clz.equals(Integer.class)) {            return true;        } else if (clz.equals(long.class) || clz.equals(Long.class)) {            return true;        } else if (clz.equals(float.class) || clz.equals(Float.class)) {            return true;        } else if (clz.equals(double.class) || clz.equals(Double.class)) {            return true;        } else if (clz.equals(boolean.class) || clz.equals(Boolean.class)) {            return true;        } else if (clz.equals(char.class) || clz.equals(Character.class)) {            return true;        } else if (clz.equals(InetAddress.class)) {            return true;        } else if (clz.equals(Class.class)) {            return true;        } else if (clz.equals(Properties.class)) {            return true;        }        return false;    }
@Override    public Object lookup(String name) {        final ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(name);        ServiceController<?> bindingService = container.getService(bindInfo.getBinderServiceName());        if (bindingService == null) {            return null;        }        ManagedReferenceFactory managedReferenceFactory = ManagedReferenceFactory.class.cast(bindingService.getValue());        return managedReferenceFactory.getReference().getInstance();    }
@Override    public void unbind(String name) {        if (name == null || name.isEmpty()) {            throw MessagingLogger.ROOT_LOGGER.cannotUnbindJndiName();        }        final ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(name);        ServiceController<?> bindingService = container.getService(bindInfo.getBinderServiceName());        if (bindingService == null) {            ROOT_LOGGER.debugf("Cannot unbind %s since no binding exists with that name", name);            return;        }        // remove the binding service        bindingService.setMode(ServiceController.Mode.REMOVE);        final StabilityMonitor monitor = new StabilityMonitor();        monitor.addController(bindingService);        try {            monitor.awaitStability();            ROOT_LOGGER.unboundJndiName(bindInfo.getAbsoluteJndiName());        } catch (InterruptedException e) {            ROOT_LOGGER.failedToUnbindJndiName(name, 5, SECONDS.toString().toLowerCase(Locale.US));        } finally {            monitor.removeController(bindingService);        }    }
public static Object instantiateBean(BeanMetaDataConfig beanConfig, BeanInfo beanInfo, DeploymentReflectionIndex index, Module module) throws Throwable {        Joinpoint instantiateJoinpoint = null;        ValueConfig[] parameters = new ValueConfig[0];        String[] types = Configurator.NO_PARAMS_TYPES;        ConstructorConfig ctorConfig = beanConfig.getConstructor();        if (ctorConfig != null) {            parameters = ctorConfig.getParameters();            types = Configurator.getTypes(parameters);            String factoryClass = ctorConfig.getFactoryClass();            FactoryConfig factory = ctorConfig.getFactory();            if (factoryClass != null || factory != null) {                String factoryMethod = ctorConfig.getFactoryMethod();                if (factoryMethod == null)                    throw PojoLogger.ROOT_LOGGER.missingFactoryMethod(beanConfig);                if (factoryClass != null) {                    // static factory                    Class<?> factoryClazz = Class.forName(factoryClass, false, module.getClassLoader());                    Method method = Configurator.findMethod(index, factoryClazz, factoryMethod, types, true, true, true);                    MethodJoinpoint mj = new MethodJoinpoint(method);                    mj.setTarget(new ImmediateValue<Object>(null)); // null, since this is static call                    mj.setParameters(parameters);                    instantiateJoinpoint = mj;                } else if (factory != null) {                    ReflectionJoinpoint rj = new ReflectionJoinpoint(factory.getBeanInfo(), factoryMethod, types);                    // null type is ok, as this should be plain injection                    rj.setTarget(new ImmediateValue<Object>(factory.getValue(null)));                    rj.setParameters(parameters);                    instantiateJoinpoint = rj;                }            }        }        // plain bean's ctor        if (instantiateJoinpoint == null) {            if (beanInfo == null)                throw new StartException(PojoLogger.ROOT_LOGGER.missingBeanInfo(beanConfig));            Constructor ctor = (types.length == 0) ? beanInfo.getConstructor() : beanInfo.findConstructor(types);            ConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint(ctor);            constructorJoinpoint.setParameters(parameters);            instantiateJoinpoint = constructorJoinpoint;        }        return instantiateJoinpoint.dispatch();    }
public static void configure(BeanMetaDataConfig beanConfig, BeanInfo beanInfo, Module module, Object bean, boolean nullify) throws Throwable {        Set<PropertyConfig> properties = beanConfig.getProperties();        if (properties != null) {            List<PropertyConfig> used = new ArrayList<PropertyConfig>();            for (PropertyConfig pc : properties) {                try {                    configure(beanInfo, module, bean, pc, nullify);                    used.add(pc);                } catch (Throwable t) {                    if (nullify == false) {                        for (PropertyConfig upc : used) {                            try {                                configure(beanInfo, module, bean,upc, true);                            } catch (Throwable ignored) {                            }                        }                        throw new StartException(t);                    }                }            }        }    }
public static void dispatchLifecycleJoinpoint(BeanInfo beanInfo, Object bean, LifecycleConfig config, String defaultMethod) throws Throwable {        if (config != null && config.isIgnored())            return;        Joinpoint joinpoint = createJoinpoint(beanInfo, bean, config, defaultMethod);        if (joinpoint != null)            joinpoint.dispatch();    }
public RemotingReceiverConfiguration addRemotingReceiverConnectionRef(final String outboundConnectionRef) {        if (outboundConnectionRef == null || outboundConnectionRef.trim().isEmpty()) {            throw new IllegalArgumentException("Cannot add a remoting receiver which references a null/empty outbound connection");        }        final RemotingReceiverConfiguration remotingReceiverConfiguration = new RemotingReceiverConfiguration(outboundConnectionRef);        this.remotingReceiverConfigurations.put(outboundConnectionRef, remotingReceiverConfiguration);        return remotingReceiverConfiguration;    }
public static Reference createReference(final ServiceName service, Class<? extends ServiceReferenceObjectFactory> factory) {        return ModularReference.create(Context.class, new ServiceNameRefAdr("srof", service), factory);    }
public Object getObjectInstance(Object serviceValue, Object obj, Name name, Context nameCtx,                                             Hashtable<?, ?> environment) throws Exception {        return serviceValue;    }
public static NamespaceContextSelector getCurrentSelector() {        NamespaceContextSelector selector = currentSelector.peek();        if(selector != null) {            return selector;        }        return defaultSelector;    }
public static ServiceName toBeanName(String name, BeanState state) {        if (state == null)            state = BeanState.INSTALLED;        return JBOSS_POJO.append(name).append(state.name());    }
public static ServiceName toInstancesName(Class<?> clazz, BeanState state) {        String clName;        ClassLoader classLoader = clazz.getClassLoader();        if (classLoader != null)            clName = classLoader.toString();        else            clName = "SystemClassLoader";        if (state == null)            state = BeanState.INSTALLED;        return JBOSS_POJO.append(clName, clazz.getName(), state.name());    }
public static List<ClassInfo> getAnnotatedClasses(List<AnnotationInstance> instances) {        List<ClassInfo> result = new ArrayList<ClassInfo>();        for (AnnotationInstance instance : instances) {            AnnotationTarget target = instance.target();            if (target instanceof ClassInfo) {                result.add((ClassInfo) target);            }        }        return result;    }
public EEModuleClassDescription getClassByName(String name) {        for(EEModuleDescription module : availableModules) {            final EEModuleClassDescription desc = module.getClassDescription(name);            if(desc != null) {                return desc;            }        }        return null;    }
@Override    protected void processAnnotations(final DeploymentUnit deploymentUnit, final CompositeIndex compositeIndex) throws DeploymentUnitProcessingException {        if (MetadataCompleteMarker.isMetadataComplete(deploymentUnit)) {            return;        }        // Find and process any @Stateless bean annotations        final List<AnnotationInstance> slsbAnnotations = compositeIndex.getAnnotations(STATELESS_ANNOTATION);        if (!slsbAnnotations.isEmpty()) {            processSessionBeans(deploymentUnit, slsbAnnotations, SessionBeanComponentDescription.SessionBeanType.STATELESS);        }        // Find and process any @Stateful bean annotations        final List<AnnotationInstance> sfsbAnnotations = compositeIndex.getAnnotations(STATEFUL_ANNOTATION);        if (!sfsbAnnotations.isEmpty()) {            processSessionBeans(deploymentUnit, sfsbAnnotations, SessionBeanComponentDescription.SessionBeanType.STATEFUL);        }        // Find and process any @Singleton bean annotations        final List<AnnotationInstance> sbAnnotations = compositeIndex.getAnnotations(SINGLETON_ANNOTATION);        if (!sbAnnotations.isEmpty()) {            processSessionBeans(deploymentUnit, sbAnnotations, SessionBeanComponentDescription.SessionBeanType.SINGLETON);        }    }
private static boolean assertSessionBeanClassValidity(final ClassInfo sessionBeanClass) {        final short flags = sessionBeanClass.flags();        final String className = sessionBeanClass.name().toString();        // must *not* be an interface        if (Modifier.isInterface(flags)) {            EjbLogger.DEPLOYMENT_LOGGER.sessionBeanClassCannotBeAnInterface(className);            return false;        }        // bean class must be public, must *not* be abstract or final        if (!Modifier.isPublic(flags) || Modifier.isAbstract(flags) || Modifier.isFinal(flags)) {            EjbLogger.DEPLOYMENT_LOGGER.sessionBeanClassMustBePublicNonAbstractNonFinal(className);            return false;        }        // valid class        return true;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final EEResourceReferenceProcessorRegistry registry = deploymentUnit.getAttachment(Attachments.RESOURCE_REFERENCE_PROCESSOR_REGISTRY);        //setup ejb context jndi handlers        registry.registerResourceReferenceProcessor(new EjbContextResourceReferenceProcessor(EJBContext.class));        registry.registerResourceReferenceProcessor(new EjbContextResourceReferenceProcessor(SessionContext.class));        registry.registerResourceReferenceProcessor(new EjbContextResourceReferenceProcessor(EntityContext.class));        registry.registerResourceReferenceProcessor(new EjbContextResourceReferenceProcessor(MessageDrivenContext.class));        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(Attachments.EE_MODULE_DESCRIPTION);        final Collection<ComponentDescription> componentConfigurations = eeModuleDescription.getComponentDescriptions();        if (componentConfigurations == null || componentConfigurations.isEmpty()) {            return;        }        for (ComponentDescription componentConfiguration : componentConfigurations) {            final CompositeIndex index = deploymentUnit.getAttachment(org.jboss.as.server.deployment.Attachments.COMPOSITE_ANNOTATION_INDEX);            if (index != null) {                processComponentConfig(componentConfiguration);            }        }    }
@Override    protected JaccService<EarMetaData> createService(String contextId, EarMetaData metaData, Boolean standalone) {        return new EarJaccService(contextId, metaData, standalone);    }
private void postParseSteps(        final VirtualFile persistence_xml,        final PersistenceUnitMetadataHolder puHolder,        final DeploymentUnit deploymentUnit ) {        for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {            // set URLs            List<URL> jarfilesUrls = new ArrayList<URL>();            if (pu.getJarFiles() != null) {                for (String jar : pu.getJarFiles()) {                    jarfilesUrls.add(getRelativeURL(persistence_xml, jar));                }            }            pu.setJarFileUrls(jarfilesUrls);            URL url = getPersistenceUnitURL(persistence_xml);            pu.setPersistenceUnitRootUrl(url);            String scopedPersistenceUnitName;            /**             * WFLY-5478 allow custom scoped persistence unit name hint in persistence unit definition.             * Specified scoped persistence unit name needs to be unique across application server deployments.             * Application is responsible for picking a unique name.             * Currently, a non-unique name will result in a DuplicateServiceException deployment failure:             *   org.jboss.msc.service.DuplicateServiceException: Service jboss.persistenceunit.my2lccustom#test_pu.__FIRST_PHASE__ is already registered             */            scopedPersistenceUnitName = Configuration.getScopedPersistenceUnitName(pu);            if (scopedPersistenceUnitName == null) {                scopedPersistenceUnitName = createBeanName(deploymentUnit, pu.getPersistenceUnitName());            } else {                ROOT_LOGGER.tracef("persistence unit '%s' specified a custom scoped persistence unit name hint " +                        "(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments.",                        pu.getPersistenceUnitName(),                        scopedPersistenceUnitName);                if (scopedPersistenceUnitName.indexOf('/') != -1) {                    throw JpaLogger.ROOT_LOGGER.invalidScopedName(scopedPersistenceUnitName, '/');                }            }            pu.setScopedPersistenceUnitName(scopedPersistenceUnitName);        }    }
private PersistenceUnitMetadataHolder normalize(List<PersistenceUnitMetadataHolder> listPUHolders) {        // eliminate duplicates (keeping the first instance of each PU by name)        Map<String, PersistenceUnitMetadata> flattened = new HashMap<String, PersistenceUnitMetadata>();        for (PersistenceUnitMetadataHolder puHolder : listPUHolders) {            for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {                if (!flattened.containsKey(pu.getPersistenceUnitName())) {                    flattened.put(pu.getPersistenceUnitName(), pu);                } else {                    PersistenceUnitMetadata first = flattened.get(pu.getPersistenceUnitName());                    PersistenceUnitMetadata duplicate = pu;                    ROOT_LOGGER.duplicatePersistenceUnitDefinition(duplicate.getPersistenceUnitName(), first.getScopedPersistenceUnitName(), duplicate.getScopedPersistenceUnitName());                }            }        }        PersistenceUnitMetadataHolder holder = new PersistenceUnitMetadataHolder(new ArrayList<PersistenceUnitMetadata>(flattened.values()));        return holder;    }
public static String createBeanName(DeploymentUnit deploymentUnit, String persistenceUnitName) {        // persistenceUnitName must be a simple name        if (persistenceUnitName.indexOf('/') != -1) {            throw JpaLogger.ROOT_LOGGER.invalidPersistenceUnitName(persistenceUnitName, '/');        }        if (persistenceUnitName.indexOf('#') != -1) {            throw JpaLogger.ROOT_LOGGER.invalidPersistenceUnitName(persistenceUnitName, '#');        }        String unitName = getScopedDeploymentUnitPath(deploymentUnit) + "#" + persistenceUnitName;        return unitName;    }
private static ConnectionFactoryAttribute[] define(ConnectionFactoryAttribute[] specific, ConnectionFactoryAttribute... common) {        int size = common.length + specific.length;        ConnectionFactoryAttribute[] result = new ConnectionFactoryAttribute[size];        for (int i = 0; i < specific.length; i++) {            ConnectionFactoryAttribute attr = specific[i];            AttributeDefinition definition = attr.getDefinition();            if (definition == ConnectionFactoryAttributes.Pooled.INITIAL_CONNECT_ATTEMPTS) {                result[i] = ConnectionFactoryAttribute.create(                        SimpleAttributeDefinitionBuilder                                .create(ConnectionFactoryAttributes.Pooled.INITIAL_CONNECT_ATTEMPTS)                                .setDefaultValue(new ModelNode(-1))                                .build(),                        attr.getPropertyName(),                        true);            } else {                result[i] = attr;            }        }        for (int i = 0; i < common.length; i++) {            ConnectionFactoryAttribute attr = common[i];            AttributeDefinition definition = attr.getDefinition();            ConnectionFactoryAttribute newAttr;            // replace the reconnect-attempts attribute to use a different default value for pooled CF            if (definition == Common.RECONNECT_ATTEMPTS) {                AttributeDefinition copy = copy(Pooled.RECONNECT_ATTEMPTS, AttributeAccess.Flag.RESTART_ALL_SERVICES);                newAttr = ConnectionFactoryAttribute.create(copy, Pooled.RECONNECT_ATTEMPTS_PROP_NAME, true);            } else if (definition == CommonAttributes.HA) {                newAttr = ConnectionFactoryAttribute.create(                        SimpleAttributeDefinitionBuilder                                .create(CommonAttributes.HA)                                .setDefaultValue(ModelNode.TRUE)                                .setFlags(AttributeAccess.Flag.RESTART_ALL_SERVICES)                                .build(),                        attr.getPropertyName(),                        true);            } else if (definition == Common.CONNECTORS) {                StringListAttributeDefinition copy = new StringListAttributeDefinition.Builder(Common.CONNECTORS)                        .setAlternatives(CommonAttributes.DISCOVERY_GROUP)                        .setRequired(true)                        .setAttributeParser(AttributeParser.STRING_LIST)                        .setAttributeMarshaller(AttributeMarshaller.STRING_LIST)                        .setCapabilityReference(new AbstractTransportDefinition.TransportCapabilityReferenceRecorder(CAPABILITY_NAME, CONNECTOR_CAPABILITY_NAME, true))                        .setRestartAllServices()                        .build();                newAttr = ConnectionFactoryAttribute.create(copy, attr.getPropertyName(), attr.isResourceAdapterProperty(), attr.getConfigType());            } else {                AttributeDefinition copy = copy(definition, AttributeAccess.Flag.RESTART_ALL_SERVICES);                newAttr = ConnectionFactoryAttribute.create(copy, attr.getPropertyName(), attr.isResourceAdapterProperty(), attr.getConfigType());            }            result[specific.length + i] = newAttr;        }        return result;    }
public static String[] parameterDescriptors(String methodDescriptor) {        int i = 1; // char 0 is a '('        List<String> ret = new ArrayList<String>();        int arrayStart = -1;        while (methodDescriptor.charAt(i) != ')') {            String type = null;            if (methodDescriptor.charAt(i) == '[') {                if (arrayStart == -1) {                    arrayStart = i;                }            } else {                if (methodDescriptor.charAt(i) == 'L') {                    int start = i;                    i++;                    while (methodDescriptor.charAt(i) != ';') {                        ++i;                    }                    if (arrayStart == -1) {                        type = methodDescriptor.substring(start, i);                    } else {                        type = methodDescriptor.substring(arrayStart, i);                    }                } else {                    if (arrayStart == -1) {                        type = methodDescriptor.charAt(i) + "";                    } else {                        type = methodDescriptor.substring(arrayStart, i + 1);                    }                }                arrayStart = -1;                ret.add(type);            }            ++i;        }        String[] r = new String[ret.size()];        for (int j = 0; j < ret.size(); ++j) {            r[j] = ret.get(j);        }        return r;    }
public static String validateDescriptor(String descriptor) {        if (descriptor.length() == 0) {            throw EeLogger.ROOT_LOGGER.cannotBeEmpty("descriptors");        }        if (descriptor.length() > 1) {            if (descriptor.startsWith("L")) {                if (!descriptor.endsWith(";")) {                    throw EeLogger.ROOT_LOGGER.invalidDescriptor(descriptor);                }            } else if (descriptor.startsWith("[")) {            } else {                    throw EeLogger.ROOT_LOGGER.invalidDescriptor(descriptor);            }        } else {            char type = descriptor.charAt(0);            switch (type) {                case 'I':                case 'Z':                case 'S':                case 'B':                case 'F':                case 'D':                case 'V':                case 'J':                case 'C':                    break;                default:                    throw EeLogger.ROOT_LOGGER.invalidDescriptor(descriptor);            }        }        return descriptor;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit unit = phaseContext.getDeploymentUnit();        final List<KernelDeploymentXmlDescriptor> kdXmlDescriptors = unit.getAttachment(KernelDeploymentXmlDescriptor.ATTACHMENT_KEY);        if (kdXmlDescriptors == null || kdXmlDescriptors.isEmpty())            return;        final Module module = unit.getAttachment(Attachments.MODULE);        if (module == null)            throw PojoLogger.ROOT_LOGGER.noModuleFound(unit);        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();        final DeploymentReflectionIndex index = unit.getAttachment(Attachments.REFLECTION_INDEX);        if (index == null)            throw PojoLogger.ROOT_LOGGER.missingReflectionIndex(unit);        for (KernelDeploymentXmlDescriptor kdXmlDescriptor : kdXmlDescriptors) {            final List<BeanMetaDataConfig> beanConfigs = kdXmlDescriptor.getBeans();            for (final BeanMetaDataConfig beanConfig : beanConfigs) {                describeBean(module, serviceTarget, index, beanConfig);            }            // TODO -- KD::classloader, KD::aliases        }    }
public ManagedReference getReference() {        try {            return view.createInstance();        } catch (Exception e) {            throw EeLogger.ROOT_LOGGER.componentViewConstructionFailure(e);        }    }
void create(final Deployment dep) {        final DeploymentUnit unit = WSHelper.getRequiredAttachment(dep, DeploymentUnit.class);        WarMetaData warMD = ASHelper.getOptionalAttachment(unit, WarMetaData.ATTACHMENT_KEY);        JBossWebMetaData jbossWebMD = warMD != null ? warMD.getMergedJBossWebMetaData() : null;        if (warMD == null) {            warMD = new WarMetaData();        }        if (jbossWebMD == null) {            jbossWebMD = new JBossWebMetaData();            warMD.setMergedJBossWebMetaData(jbossWebMD);            unit.putAttachment(WarMetaData.ATTACHMENT_KEY, warMD);        }        createWebAppDescriptor(dep, jbossWebMD);        createJBossWebAppDescriptor(dep, jbossWebMD);        dep.addAttachment(JBossWebMetaData.class, jbossWebMD);    }
private void createWebAppDescriptor(final Deployment dep, final JBossWebMetaData jbossWebMD) {        WSLogger.ROOT_LOGGER.trace("Creating web.xml descriptor");        createServlets(dep, jbossWebMD);        createServletMappings(dep, jbossWebMD);        createSecurityConstraints(dep, jbossWebMD);        createLoginConfig(dep, jbossWebMD);        createSecurityRoles(dep, jbossWebMD);    }
private void createJBossWebAppDescriptor(final Deployment dep, final JBossWebMetaData jbossWebMD) {         WSLogger.ROOT_LOGGER.trace("Creating jboss-web.xml descriptor");        // Set security domain        final String securityDomain = ejb3SecurityAccessor.getSecurityDomain(dep);        final boolean hasSecurityDomain = securityDomain != null;        if (hasSecurityDomain) {             WSLogger.ROOT_LOGGER.tracef("Setting security domain: %s", securityDomain);            jbossWebMD.setSecurityDomain(securityDomain);        }        // Set virtual host        final String virtualHost = dep.getService().getVirtualHost();        ServerHostInfo serverHostInfo = new ServerHostInfo(virtualHost);        if (serverHostInfo.getHost() != null) {            WSLogger.ROOT_LOGGER.tracef("Setting virtual host: %s", serverHostInfo.getHost());            jbossWebMD.setVirtualHosts(Arrays.asList(serverHostInfo.getHost()));            if (serverHostInfo.getServerInstanceName() != null) {                jbossWebMD.setServerInstanceName(serverHostInfo.getServerInstanceName());            }        }    }
private void createServlets(final Deployment dep, final JBossWebMetaData jbossWebMD) {         WSLogger.ROOT_LOGGER.trace("Creating servlets");        final JBossServletsMetaData servlets = WebMetaDataHelper.getServlets(jbossWebMD);        for (final Endpoint endpoint : dep.getService().getEndpoints()) {            final String endpointName = endpoint.getShortName();            final String endpointClassName = endpoint.getTargetBeanName();             WSLogger.ROOT_LOGGER.tracef("Servlet name: %s, class: %s", endpointName, endpointClassName);            WebMetaDataHelper.newServlet(endpointName, endpointClassName, servlets);        }    }
private void createServletMappings(final Deployment dep, final JBossWebMetaData jbossWebMD) {         WSLogger.ROOT_LOGGER.trace("Creating servlet mappings");        final List<ServletMappingMetaData> servletMappings = WebMetaDataHelper.getServletMappings(jbossWebMD);        for (final Endpoint ep : dep.getService().getEndpoints()) {            if (ep instanceof HttpEndpoint) {                final String endpointName = ep.getShortName();                final List<String> urlPatterns = WebMetaDataHelper.getUrlPatterns(((HttpEndpoint) ep).getURLPattern());                 WSLogger.ROOT_LOGGER.tracef("Servlet name: %s, URL patterns: %s", endpointName, urlPatterns);                WebMetaDataHelper.newServletMapping(endpointName, urlPatterns, servletMappings);            }        }    }
private void createSecurityConstraints(final Deployment dep, final JBossWebMetaData jbossWebMD) {         WSLogger.ROOT_LOGGER.trace("Creating security constraints");        for (final Endpoint ejbEndpoint : dep.getService().getEndpoints()) {            final boolean secureWsdlAccess = ejb3SecurityAccessor.isSecureWsdlAccess(ejbEndpoint);            final String transportGuarantee = ejb3SecurityAccessor.getTransportGuarantee(ejbEndpoint);            final boolean hasTransportGuarantee = transportGuarantee != null;            final String authMethod = ejb3SecurityAccessor.getAuthMethod(ejbEndpoint);            final boolean hasAuthMethod = authMethod != null;            if (ejbEndpoint instanceof HttpEndpoint && (hasAuthMethod || hasTransportGuarantee)) {                final List<SecurityConstraintMetaData> securityConstraints = WebMetaDataHelper                        .getSecurityConstraints(jbossWebMD);                // security-constraint                final SecurityConstraintMetaData securityConstraint = WebMetaDataHelper                        .newSecurityConstraint(securityConstraints);                // web-resource-collection                final WebResourceCollectionsMetaData webResourceCollections = WebMetaDataHelper                        .getWebResourceCollections(securityConstraint);                final String endpointName = ejbEndpoint.getShortName();                final String urlPattern = ((HttpEndpoint) ejbEndpoint).getURLPattern();                 WSLogger.ROOT_LOGGER.tracef("Creating web resource collection for endpoint: %s, URL pattern: %s", endpointName, urlPattern);                WebMetaDataHelper.newWebResourceCollection(endpointName, urlPattern, secureWsdlAccess,                        webResourceCollections);                // auth-constraint                if (hasAuthMethod) {                     WSLogger.ROOT_LOGGER.tracef("Creating auth constraint for endpoint: %s", endpointName);                    WebMetaDataHelper.newAuthConstraint(WebMetaDataHelper.getAllRoles(), securityConstraint);                }                // user-data-constraint                if (hasTransportGuarantee) {                     WSLogger.ROOT_LOGGER.tracef("Creating new user data constraint for endpoint: %s, transport guarantee: %s", endpointName, transportGuarantee);                    WebMetaDataHelper.newUserDataConstraint(transportGuarantee, securityConstraint);                }            }        }    }
private void createLoginConfig(final Deployment dep, final JBossWebMetaData jbossWebMD) {        final String authMethod = getAuthMethod(dep);        final boolean hasAuthMethod = authMethod != null;        final String realmName = getRealmName(dep);        if (hasAuthMethod) {             WSLogger.ROOT_LOGGER.tracef("Creating new login config: %s, auth method: %s", EJB_WEBSERVICE_REALM, authMethod);            final LoginConfigMetaData loginConfig = WebMetaDataHelper.getLoginConfig(jbossWebMD);            if (realmName != null) {                loginConfig.setRealmName(realmName);            } else {                loginConfig.setRealmName(WebMetaDataCreator.EJB_WEBSERVICE_REALM);            }            loginConfig.setAuthMethod(authMethod);        }    }
private void createSecurityRoles(final Deployment dep, final JBossWebMetaData jbossWebMD) {        final String authMethod = getAuthMethod(dep);        final boolean hasAuthMethod = authMethod != null;        if (hasAuthMethod) {            final SecurityRolesMetaData securityRolesMD = ejb3SecurityAccessor.getSecurityRoles(dep);            final boolean hasSecurityRolesMD = securityRolesMD != null && !securityRolesMD.isEmpty();            if (hasSecurityRolesMD) {                 WSLogger.ROOT_LOGGER.trace("Setting security roles");                jbossWebMD.setSecurityRoles(securityRolesMD);            }        }        //merge security roles from the ear        //TODO: is there somewhere better to put this?        final DeploymentUnit unit = dep.getAttachment(DeploymentUnit.class);        DeploymentUnit parent = unit.getParent();        if (parent != null) {            final EarMetaData earMetaData = parent.getAttachment(org.jboss.as.ee.structure.Attachments.EAR_METADATA);            if (earMetaData != null) {                if (jbossWebMD.getSecurityRoles() == null) {                    jbossWebMD.setSecurityRoles(new SecurityRolesMetaData());                }                SecurityRolesMetaData earSecurityRolesMetaData = earMetaData.getSecurityRoles();                if (earSecurityRolesMetaData != null) {                    SecurityRolesMetaDataMerger.merge(jbossWebMD.getSecurityRoles(), jbossWebMD.getSecurityRoles(), earSecurityRolesMetaData);                }            }        }    }
private String getAuthMethod(final Deployment dep) {        for (final Endpoint ejbEndpoint : dep.getService().getEndpoints()) {            final String beanAuthMethod = ejb3SecurityAccessor.getAuthMethod(ejbEndpoint);            final boolean hasBeanAuthMethod = beanAuthMethod != null;            if (hasBeanAuthMethod) {                // First found auth-method defines war                // login-config/auth-method                return beanAuthMethod;            }        }        return null;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final VirtualFile deploymentRoot = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();        if(deploymentRoot == null || !deploymentRoot.exists())            return;        VirtualFile serviceXmlFile = null;        if(deploymentRoot.isDirectory()) {            serviceXmlFile = deploymentRoot.getChild(SERVICE_DESCRIPTOR_PATH);        } else if(deploymentRoot.getName().toLowerCase(Locale.ENGLISH).endsWith(SERVICE_DESCRIPTOR_SUFFIX)) {            serviceXmlFile = deploymentRoot;        }        if(serviceXmlFile == null || !serviceXmlFile.exists())            return;        final XMLMapper xmlMapper = XMLMapper.Factory.create();        final JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser(JBossDescriptorPropertyReplacement.propertyReplacer(phaseContext.getDeploymentUnit()));        xmlMapper.registerRootElement(new QName("urn:jboss:service:7.0", "server"), jBossServiceXmlDescriptorParser);        xmlMapper.registerRootElement(new QName(null, "server"), jBossServiceXmlDescriptorParser);        InputStream xmlStream = null;        try {            xmlStream = serviceXmlFile.openStream();            final XMLStreamReader reader = inputFactory.createXMLStreamReader(xmlStream);            final ParseResult<JBossServiceXmlDescriptor> result = new ParseResult<JBossServiceXmlDescriptor>();            xmlMapper.parseDocument(result, reader);            final JBossServiceXmlDescriptor xmlDescriptor = result.getResult();            if(xmlDescriptor != null)                phaseContext.getDeploymentUnit().putAttachment(JBossServiceXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);            else                throw SarLogger.ROOT_LOGGER.failedXmlParsing(serviceXmlFile);        } catch(Exception e) {            throw SarLogger.ROOT_LOGGER.failedXmlParsing(e, serviceXmlFile);        } finally {            VFSUtils.safeClose(xmlStream);        }    }
private void handleStatelessSessionBean(final EJBComponentDescription component, final Module module, final DeploymentReflectionIndex reflectionIndex) throws ClassNotFoundException, DeploymentUnitProcessingException {        final Class<?> componentClass = ClassLoadingUtils.loadClass(component.getComponentClassName(), module);        final MethodIdentifier ejbCreateId = MethodIdentifier.getIdentifier(void.class, "ejbCreate");        final Method ejbCreate = ClassReflectionIndexUtil.findMethod(reflectionIndex, componentClass, ejbCreateId);        if (ejbCreate != null) {            final InterceptorClassDescription.Builder builder = InterceptorClassDescription.builder();            builder.setPostConstruct(ejbCreateId);            component.addInterceptorMethodOverride(ejbCreate.getDeclaringClass().getName(), builder.build());        }        final MethodIdentifier ejbRemoveId = MethodIdentifier.getIdentifier(void.class, "ejbRemove");        final Method ejbRemove = ClassReflectionIndexUtil.findMethod(reflectionIndex, componentClass, ejbRemoveId);        if (ejbRemove != null) {            final InterceptorClassDescription.Builder builder = InterceptorClassDescription.builder();            builder.setPreDestroy(ejbRemoveId);            component.addInterceptorMethodOverride(ejbRemove.getDeclaringClass().getName(), builder.build());        }    }
public static Class<?> makeStubClass(final Class<?> myClass) {        final String stubClassName = myClass + "_Stub";        ClassLoader cl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        if (cl == null) {            cl = myClass.getClassLoader();        }        if (cl == null) {            throw EjbLogger.ROOT_LOGGER.couldNotFindClassLoaderForStub(stubClassName);        }        Class<?> theClass;        try {            theClass = cl.loadClass(stubClassName);        } catch (ClassNotFoundException e) {            try {                final ClassFile clazz = IIOPStubCompiler.compile(myClass, stubClassName);                theClass = clazz.define(cl, myClass.getProtectionDomain());            } catch (Throwable ex) {                //there is a possibility that another thread may have defined the same class in the meantime                try {                    theClass = cl.loadClass(stubClassName);                } catch (ClassNotFoundException e1) {                    EjbLogger.ROOT_LOGGER.dynamicStubCreationFailed(stubClassName, ex);                    throw ex;                }            }        }        return theClass;    }
public Contained lookup_id(java.lang.String search_id) {        LocalContained c = _lookup_id(search_id);        if (c == null)            return null;        return ContainedHelper.narrow(c.getReference());    }
protected byte[] getAnonymousObjectId(long n) {        String s = anonOidPrefix + Long.toString(n);        return s.getBytes(StandardCharsets.UTF_8);    }
private String scopedName(String id) {        if (id == null)            return null;        if (id.startsWith("IDL:")) {            // OMG IDL format            // Check for base types            if ("IDL:omg.org/CORBA/Object:1.0".equals(id) ||                    "IDL:omg.org/CORBA/ValueBase:1.0".equals(id))                return null;            // Get 2nd component of ID            int idx2 = id.indexOf(':', 4); // 2nd colon            if (idx2 == -1)                return null; // invalid ID, version part missing            String base = id.substring(4, id.indexOf(':', 4));            // Check special prefixes            if (base.startsWith("omg.org"))                base = "org/omg" + base.substring(7);            if (base.startsWith("w3c.org"))                base = "org/w3c" + base.substring(7);            // convert '/' to "::"            StringBuffer b = new StringBuffer();            for (int i = 0; i < base.length(); ++i) {                char c = base.charAt(i);                if (c != '/')                    b.append(c);                else                    b.append("::");            }            return b.toString();        } else if (id.startsWith("RMI:")) {            // RMI hashed format            // Get 2nd component of ID            int idx2 = id.indexOf(':', 4); // 2nd colon            if (idx2 == -1)                return null; // invalid ID, version part missing            String base = id.substring(4, id.indexOf(':', 4));            // convert '.' to "::"            StringBuffer b = new StringBuffer();            for (int i = 0; i < base.length(); ++i) {                char c = base.charAt(i);                if (c != '.')                    b.append(c);                else                    b.append("::");            }            return b.toString();        } else            return null;    }
@Override    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) {        return new TransformedOperation(this.operationTransformer.transformOperation(operation), this.resultTransformer);    }
@Override    public void initialize(final ExtensionContext context) {        WeldLogger.ROOT_LOGGER.debug("Activating Weld Extension");        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WeldResourceDefinition.INSTANCE);        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);        subsystem.registerXMLElementWriter(WeldSubsystem40Parser.INSTANCE);    }
@Override    public void initializeParsers(final ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldSubsystem10Parser.NAMESPACE, () -> WeldSubsystem10Parser.INSTANCE);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldSubsystem20Parser.NAMESPACE, () -> WeldSubsystem20Parser.INSTANCE);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldSubsystem30Parser.NAMESPACE, () -> WeldSubsystem30Parser.INSTANCE);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldSubsystem40Parser.NAMESPACE, () -> WeldSubsystem40Parser.INSTANCE);    }
public void start(final StartContext context) {        super.start(context);        if (SarLogger.ROOT_LOGGER.isTraceEnabled()) {            SarLogger.ROOT_LOGGER.tracef("Creating Service: %s", context.getController().getName());        }        final Runnable task = new Runnable() {            @Override            public void run() {                try {                    injectDependencies();                    invokeLifecycleMethod(createMethod, context);                    if (componentInstantiator != null) {                        managedReference = componentInstantiator.initializeInstance(mBeanInstance);                    }                    context.complete();                } catch (Throwable e) {                    uninjectDependencies();                    context.failed(new StartException(SarLogger.ROOT_LOGGER.failedExecutingLegacyMethod("create()"), e));                }            }        };        try {            executorSupplier.get().submit(task);        } catch (RejectedExecutionException e) {            task.run();        } finally {            context.asynchronous();        }    }
@Override    protected void validateUpdatedModel(OperationContext context, Resource model) throws OperationFailedException {        SecurityDomainResourceDefinition.CACHE_TYPE.validateOperation(model.getModel());    }
@Override    public void validateParameter(String parameterName, ModelNode value) throws OperationFailedException {        super.validateParameter(parameterName, value);        if (value.isDefined() && value.getType() != ModelType.EXPRESSION) {            String val = value.asString();            try {                PredicateParser.parse(val, getClass().getClassLoader());            } catch (Exception e) {                throw new OperationFailedException(UndertowLogger.ROOT_LOGGER.predicateNotValid(val, e.getMessage()), e);            }        }    }
@Override    public List<PersistenceProvider> getPersistenceProviders() {        List<PersistenceProvider> providersCopy = new ArrayList<>(providers.size());        /**         * Add the application specified providers first so they are found before the global providers         */        synchronized(persistenceProviderPerClassLoader) {            if (persistenceProviderPerClassLoader.size() > 0) {                // get the deployment or subdeployment classloader                ClassLoader deploymentClassLoader = findParentModuleCl(WildFlySecurityManager.getCurrentContextClassLoaderPrivileged());                ROOT_LOGGER.tracef("get application level Persistence Provider for classloader %s" , deploymentClassLoader);                // collect persistence providers associated with deployment/each sub-deployment                List<Class<? extends PersistenceProvider>> deploymentSpecificPersistenceProviders = persistenceProviderPerClassLoader.get(deploymentClassLoader);                ROOT_LOGGER.tracef("got application level Persistence Provider list %s" , deploymentSpecificPersistenceProviders);                if (deploymentSpecificPersistenceProviders != null) {                    for (Class<? extends PersistenceProvider> providerClass : deploymentSpecificPersistenceProviders) {                        try {                            ROOT_LOGGER.tracef("application has its own Persistence Provider %s", providerClass.getName());                            providersCopy.add(providerClass.newInstance());                        } catch (InstantiationException e) {                            throw JpaLogger.ROOT_LOGGER.couldNotCreateInstanceProvider(e, providerClass.getName());                        } catch (IllegalAccessException e) {                            throw JpaLogger.ROOT_LOGGER.couldNotCreateInstanceProvider(e, providerClass.getName());                        }                    }                }            }        }        // add global persistence providers last (so application packaged providers have priority)        for (Class<?> providerClass : providers) {            try {                providersCopy.add((PersistenceProvider) providerClass.newInstance());                ROOT_LOGGER.tracef("returning global (module) Persistence Provider %s", providerClass.getName());            } catch (InstantiationException e) {                throw JpaLogger.ROOT_LOGGER.couldNotCreateInstanceProvider(e, providerClass.getName());            } catch (IllegalAccessException e) {                throw JpaLogger.ROOT_LOGGER.couldNotCreateInstanceProvider(e, providerClass.getName());            }        }        return providersCopy;    }
public void clearCachedDeploymentSpecificProviders(Set<ClassLoader> deploymentClassLoaders) {        synchronized(persistenceProviderPerClassLoader) {            for (ClassLoader deploymentClassLoader: deploymentClassLoaders) {                persistenceProviderPerClassLoader.remove(deploymentClassLoader);            }        }    }
public void addDeploymentSpecificPersistenceProvider(PersistenceProvider persistenceProvider, Set<ClassLoader> deploymentClassLoaders) {        synchronized(persistenceProviderPerClassLoader) {            for (ClassLoader deploymentClassLoader: deploymentClassLoaders) {                List<Class<? extends PersistenceProvider>> list = persistenceProviderPerClassLoader.get(deploymentClassLoader);                ROOT_LOGGER.tracef("getting persistence provider list (%s) for deployment (%s)", list, deploymentClassLoader );                if (list == null) {                    list = new ArrayList<>();                    persistenceProviderPerClassLoader.put(deploymentClassLoader, list);                    ROOT_LOGGER.tracef("saving new persistence provider list (%s) for deployment (%s)", list, deploymentClassLoader );                }                list.add(persistenceProvider.getClass());                ROOT_LOGGER.tracef("added new persistence provider (%s) to provider list (%s)", persistenceProvider.getClass().getName(), list);            }        }    }
private ClassLoader findParentModuleCl(ClassLoader classLoader) {        ClassLoader c = classLoader;        while (c != null && !(c instanceof ModuleClassLoader)) {            c = c.getParent();        }        return c;    }
private void readElement_1_0(Namespace namespace, XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            // check the element namespace.            if (Namespace.JacORB_1_0 != Namespace.forUri(reader.getNamespaceURI()))                throw unexpectedElement(reader);            final Element element = Element.forName(reader.getLocalName());            // there can be multiple property elements.            if (!encountered.add(element) && element != Element.PROPERTY) {                throw duplicateNamedElement(reader, element.getLocalName());            }            switch (element) {                case ORB: {                    this.parseORBConfig_1_0(reader, node);                    break;                }                case POA: {                    this.parsePOAConfig(namespace, reader, node);                    break;                }                case INTEROP: {                    this.parseInteropConfig(reader, node);                    break;                }                case SECURITY: {                    this.parseSecurityConfig_1_0(reader, node);                    break;                }                case PROPERTY: {                    ModelNode propertiesNode = node.get(JacORBSubsystemConstants.PROPERTIES);                    this.parseGenericProperty_1_0(reader, propertiesNode);                    break;                }                case ORB_INITIALIZERS: {                    this.parseORBInitializersConfig_1_0(reader, node);                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
private void readElement_1_1(Namespace namespace, XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            // check the element namespace.            if (namespace != Namespace.forUri(reader.getNamespaceURI()))                throw unexpectedElement(reader);            final Element element = Element.forName(reader.getLocalName());            if (!encountered.add(element)) {                throw duplicateNamedElement(reader, element.getLocalName());            }            switch (element) {                case ORB: {                    this.parseORBConfig(namespace, reader, node);                    break;                }                case POA: {                    this.parsePOAConfig(namespace, reader, node);                    break;                }                case NAMING: {                    this.parseNamingConfig(reader, node);                    break;                }                case INTEROP: {                    this.parseInteropConfig(reader, node);                    break;                }                case SECURITY: {                    this.parseSecurityConfig(reader, node);                    break;                }                case PROPERTIES: {                    this.parsePropertiesConfig(namespace, reader, node);                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
private void parseORBConfig_1_0(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse the orb config attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.NAME, Attribute.ORB_PRINT_VERSION,                Attribute.ORB_GIOP_MINOR_VERSION, Attribute.ORB_USE_BOM, Attribute.ORB_USE_IMR,                Attribute.ORB_CACHE_POA_NAMES, Attribute.ORB_CACHE_TYPECODES);        this.parseAttributes(reader, node, expectedAttributes, null);        // parse the orb config elements.        EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            // check the element namespace.            if (Namespace.JacORB_1_0 != Namespace.forUri(reader.getNamespaceURI()))                throw unexpectedElement(reader);            final Element element = Element.forName(reader.getLocalName());            // check for duplicate elements.            if (!encountered.add(element)) {                throw duplicateNamedElement(reader, element.getLocalName());            }            switch (element) {                case ORB_CONNECTION: {                    this.parseORBConnectionConfig(reader, node);                    break;                }                case NAMING: {                    this.parseNamingConfig(reader, node);                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
private void parseORBConfig(Namespace namespace, XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse the orb config attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.NAME, Attribute.ORB_PRINT_VERSION,                Attribute.ORB_GIOP_MINOR_VERSION, Attribute.ORB_USE_BOM, Attribute.ORB_USE_IMR,                Attribute.ORB_CACHE_POA_NAMES, Attribute.ORB_CACHE_TYPECODES);        // version 1.2 of the schema allows for the configuration of the ORB socket bindings.        if (namespace.ordinal() >= Namespace.JacORB_1_2.ordinal()) {            expectedAttributes.add(Attribute.ORB_SOCKET_BINDING);            expectedAttributes.add(Attribute.ORB_SSL_SOCKET_BINDING);        }        if (namespace.ordinal() >= Namespace.JacORB_2_0.ordinal()) {            expectedAttributes.add(Attribute.ORB_PERSISTENT_SERVER_ID);        }        this.parseAttributes(reader, node, expectedAttributes, null);        // parse the orb config elements.        EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            // check the element namespace.            if (namespace != Namespace.forUri(reader.getNamespaceURI()))                throw unexpectedElement(reader);            final Element element = Element.forName(reader.getLocalName());            // check for duplicate elements.            if (!encountered.add(element)) {                throw duplicateNamedElement(reader, element.getLocalName());            }            switch (element) {                case ORB_CONNECTION: {                    this.parseORBConnectionConfig(reader, node);                    break;                }                case ORB_INITIALIZERS: {                    this.parseORBInitializersConfig(reader, node);                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
private void parseORBConnectionConfig(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse the orb connection config attributes.        EnumSet<Attribute> attributes = EnumSet.of(Attribute.ORB_CONN_RETRIES, Attribute.ORB_CONN_RETRY_INTERVAL,                Attribute.ORB_CONN_CLIENT_TIMEOUT, Attribute.ORB_CONN_SERVER_TIMEOUT,                Attribute.ORB_CONN_MAX_SERVER_CONNECTIONS, Attribute.ORB_CONN_MAX_MANAGED_BUF_SIZE,                Attribute.ORB_CONN_OUTBUF_SIZE, Attribute.ORB_CONN_OUTBUF_CACHE_TIMEOUT);        this.parseAttributes(reader, node, attributes, null);        // the connection sub-element doesn't have child elements.        requireNoContent(reader);    }
private void parseORBInitializersConfig_1_0(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        requireNoAttributes(reader);        // read the element text - a comma-separated list of initializers.        String initializersList = reader.getElementText();        if (initializersList != null) {            String[] initializers = initializersList.split(",");            // read each configured initializer and set the appropriate values in the model node.            for (String initializer : initializers) {                SimpleAttributeDefinition definition = (SimpleAttributeDefinition)JacORBSubsystemDefinitions.valueOf(initializer);                if (definition != null && JacORBSubsystemDefinitions.ORB_INIT_ATTRIBUTES.contains(definition))                    node.get(definition.getName()).set(JacORBSubsystemConstants.ON);                else                    throw JacORBLogger.ROOT_LOGGER.invalidInitializerConfig(initializer, reader.getLocation());            }        }    }
private void parseORBInitializersConfig(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse the initializers config attributes.        EnumSet<Attribute> attributes = EnumSet.of(Attribute.ORB_INIT_SECURITY, Attribute.ORB_INIT_TRANSACTIONS);        this.parseAttributes(reader, node, attributes, null);        // the initializers element doesn't have child elements.        requireNoContent(reader);        //if security="on" change it to security="identity"        if(node.has(SECURITY) && node.get(SECURITY).asString().equals(JacORBSubsystemConstants.ON)) {            node.get(SECURITY).set(SecurityAllowedValues.IDENTITY.toString());        }    }
private void parsePOAConfig(Namespace namespace, XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse the poa config attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.POA_MONITORING, Attribute.POA_QUEUE_WAIT,                Attribute.POA_QUEUE_MIN, Attribute.POA_QUEUE_MAX);        this.parseAttributes(reader, node, expectedAttributes, null);        // parse the poa config elements.        EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            // check the element namespace.            if (namespace != Namespace.forUri(reader.getNamespaceURI()))                throw unexpectedElement(reader);            final Element element = Element.forName(reader.getLocalName());            // check for duplicate elements.            if (!encountered.add(element)) {                throw duplicateNamedElement(reader, element.getLocalName());            }            switch (element) {                case POA_REQUEST_PROC: {                    // parse the poa request-processors config attributes.                    EnumSet<Attribute> attributes =                            EnumSet.of(Attribute.POA_REQUEST_PROC_POOL_SIZE, Attribute.POA_REQUEST_PROC_MAX_THREADS);                    this.parseAttributes(reader, node, attributes, null);                    // the request-processors element doesn't have child elements.                    requireNoContent(reader);                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
private void parseNamingConfig(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse all naming attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.NAMING_ROOT_CONTEXT, Attribute.NAMING_EXPORT_CORBALOC);        this.parseAttributes(reader, node, expectedAttributes, null);        // the naming element doesn't have child elements.        requireNoContent(reader);    }
private void parseInteropConfig(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse all interop attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.INTEROP_SUN, Attribute.INTEROP_COMET,                Attribute.INTEROP_IONA, Attribute.INTEROP_CHUNK_RMI_VALUETYPES, Attribute.INTEROP_LAX_BOOLEAN_ENCODING,                Attribute.INTEROP_INDIRECTION_ENCODING_DISABLE, Attribute.INTEROP_STRICT_CHECK_ON_TC_CREATION);        this.parseAttributes(reader, node, expectedAttributes, null);        // the interop element doesn't have child elements.        requireNoContent(reader);    }
private void parseSecurityConfig_1_0(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse all security attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.SECURITY_SUPPORT_SSL,                Attribute.SECURITY_ADD_COMPONENT_INTERCEPTOR, Attribute.SECURITY_CLIENT_SUPPORTS,                Attribute.SECURITY_CLIENT_REQUIRES, Attribute.SECURITY_SERVER_SUPPORTS, Attribute.SECURITY_SERVER_REQUIRES,                Attribute.SECURITY_USE_DOMAIN_SF, Attribute.SECURITY_USE_DOMAIN_SSF);        EnumSet<Attribute> parsedAttributes = EnumSet.noneOf(Attribute.class);        for (int i = 0; i < reader.getAttributeCount(); i++) {            requireNoNamespaceAttribute(reader, i);            String attrValue = reader.getAttributeValue(i);            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            // check for unexpected attributes.            if (!expectedAttributes.contains(attribute))                throw unexpectedAttribute(reader, i);            // check for duplicate attributes.            if (!parsedAttributes.add(attribute)) {                throw duplicateAttribute(reader, attribute.getLocalName());            }            switch (attribute) {                // check the attributes that need to be converted from int to string.                case SECURITY_CLIENT_SUPPORTS:                case SECURITY_CLIENT_REQUIRES:                case SECURITY_SERVER_SUPPORTS:                case SECURITY_SERVER_REQUIRES:                    SSLConfigValue value = SSLConfigValue.fromValue(attrValue);                    if (value == null)                        throw JacORBLogger.ROOT_LOGGER.invalidSSLConfig(attrValue, reader.getLocation());                    attrValue = value.toString();                default:                    SimpleAttributeDefinition definition = ((SimpleAttributeDefinition) JacORBSubsystemDefinitions.                        valueOf(attribute.getLocalName()));                    // a null definition represents an attribute that has been deprecated and is no longer used.                    if (definition != null)                        definition.parseAndSetParameter(attrValue, node, reader);            }        }        // the security element doesn't have child elements.        requireNoContent(reader);    }
private void parseSecurityConfig(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        // parse all security attributes.        EnumSet<Attribute> expectedAttributes = EnumSet.of(Attribute.SECURITY_SUPPORT_SSL, Attribute.SECURITY_SECURITY_DOMAIN,                Attribute.SECURITY_ADD_COMPONENT_INTERCEPTOR, Attribute.SECURITY_CLIENT_SUPPORTS,                Attribute.SECURITY_CLIENT_REQUIRES, Attribute.SECURITY_SERVER_SUPPORTS, Attribute.SECURITY_SERVER_REQUIRES);        this.parseAttributes(reader, node, expectedAttributes, null);        // the security element doesn't have child elements.        requireNoContent(reader);    }
private void parsePropertiesConfig(Namespace namespace, XMLExtendedStreamReader reader, ModelNode node)            throws XMLStreamException {        // the properties element doesn't define any attributes, just sub-elements.        requireNoAttributes(reader);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            // check the element namespace.            if (namespace != Namespace.forUri(reader.getNamespaceURI()))                throw unexpectedElement(reader);            final Element element = Element.forName(reader.getLocalName());            switch (element) {                case PROPERTY: {                    // parse the property element.                    this.parseGenericProperty(reader, node.get(JacORBSubsystemConstants.PROPERTIES));                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
private void parseGenericProperty_1_0(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        String name = null;        String val = null;        EnumSet<Attribute> required = EnumSet.of(Attribute.PROP_KEY, Attribute.PROP_VALUE);        final int count = reader.getAttributeCount();        for (int i = 0; i < count; i++) {            requireNoNamespaceAttribute(reader, i);            final String value = reader.getAttributeValue(i);            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            required.remove(attribute);            switch (attribute) {                case PROP_KEY: {                    name = value;                    break;                }                case PROP_VALUE: {                    val = value;                    break;                }                default:                    throw unexpectedAttribute(reader, i);            }        }        if (!required.isEmpty()) {            throw missingRequired(reader, required);        }        node.get(name).set(val);        requireNoContent(reader);    }
private void parseGenericProperty(XMLExtendedStreamReader reader, ModelNode node) throws XMLStreamException {        String name = null;        ModelNode val = null;        EnumSet<Attribute> required = EnumSet.of(Attribute.NAME, Attribute.PROP_VALUE);        final int count = reader.getAttributeCount();        for (int i = 0; i < count; i++) {            requireNoNamespaceAttribute(reader, i);            final String value = reader.getAttributeValue(i);            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            required.remove(attribute);            switch (attribute) {                case NAME: {                    name = value;                    break;                }                case PROP_VALUE: {                    val = JacORBSubsystemDefinitions.PROPERTIES.parse(value, reader.getLocation());                    break;                }                default:                    throw unexpectedAttribute(reader, i);            }        }        if (!required.isEmpty()) {            throw missingRequired(reader, required);        }        node.get(name).set(val);        requireNoContent(reader);    }
private void parseAttributes(XMLExtendedStreamReader reader, ModelNode node, EnumSet<Attribute> expectedAttributes,                                 EnumSet<Attribute> requiredAttributes) throws XMLStreamException {        EnumSet<Attribute> parsedAttributes = EnumSet.noneOf(Attribute.class);        if (requiredAttributes == null) {            requiredAttributes = EnumSet.noneOf(Attribute.class);        }        for (int i = 0; i < reader.getAttributeCount(); i++) {            requireNoNamespaceAttribute(reader, i);            final String attrValue = reader.getAttributeValue(i);            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            // check for unexpected attributes.            if (!expectedAttributes.contains(attribute))                throw unexpectedAttribute(reader, i);            // check for duplicate attributes.            if (!parsedAttributes.add(attribute)) {                throw duplicateAttribute(reader, attribute.getLocalName());            }            requiredAttributes.remove(attribute);            ((SimpleAttributeDefinition)JacORBSubsystemDefinitions.valueOf(attribute.getLocalName())).                    parseAndSetParameter(attrValue, node, reader);        }        // throw an exception if a required attribute wasn't found.        if (!requiredAttributes.isEmpty()) {            throw missingRequired(reader, requiredAttributes);        }    }
private void writeORBConfig(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {        boolean writeORB = this.isWritable(node, JacORBSubsystemDefinitions.ORB_ATTRIBUTES);        boolean writeORBConnection = this.isWritable(node, JacORBSubsystemDefinitions.ORB_CONN_ATTRIBUTES);        boolean writeORBInitializer = this.isWritable(node, JacORBSubsystemDefinitions.ORB_INIT_ATTRIBUTES);        // if no connection or initializers properties are available, just write the orb properties (if any) in an empty element.        if (!writeORBConnection && !writeORBInitializer) {            if (writeORB) {                writer.writeEmptyElement(JacORBSubsystemConstants.ORB);                this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_ATTRIBUTES);            }        }        // otherwise write the orb element with the appropriate sub-elements.        else {            writer.writeStartElement(JacORBSubsystemConstants.ORB);            this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_ATTRIBUTES);            if (writeORBConnection) {                writer.writeEmptyElement(JacORBSubsystemConstants.ORB_CONN);                this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_CONN_ATTRIBUTES);            }            if (writeORBInitializer) {                writer.writeEmptyElement(JacORBSubsystemConstants.ORB_INIT);                this.writeAttributes(writer, node, JacORBSubsystemDefinitions.ORB_INIT_ATTRIBUTES);            }            writer.writeEndElement();        }    }
private void writePOAConfig(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {        boolean writePOA = this.isWritable(node, JacORBSubsystemDefinitions.POA_ATTRIBUTES);        boolean writePOARP = this.isWritable(node, JacORBSubsystemDefinitions.POA_RP_ATTRIBUTES);        // if no request processor properties are available, just write the poa properties (if any) in an empty element.        if (!writePOARP) {            if (writePOA) {                writer.writeEmptyElement(JacORBSubsystemConstants.POA);                this.writeAttributes(writer, node, JacORBSubsystemDefinitions.POA_ATTRIBUTES);            }        }        // otherwise write the poa element with the appropriate sub-elements.        else {            writer.writeStartElement(JacORBSubsystemConstants.POA);            this.writeAttributes(writer, node, JacORBSubsystemDefinitions.POA_ATTRIBUTES);            writer.writeEmptyElement(JacORBSubsystemConstants.POA_RP);            this.writeAttributes(writer, node, JacORBSubsystemDefinitions.POA_RP_ATTRIBUTES);            writer.writeEndElement();        }    }
private void writeNamingConfig(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {        boolean writeNaming = this.isWritable(node, JacORBSubsystemDefinitions.NAMING_ATTRIBUTES);        if (writeNaming) {            writer.writeEmptyElement(JacORBSubsystemConstants.NAMING);            this.writeAttributes(writer, node, JacORBSubsystemDefinitions.NAMING_ATTRIBUTES);        }    }
private void writeInteropConfig(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {        boolean writeInterop = this.isWritable(node, JacORBSubsystemDefinitions.INTEROP_ATTRIBUTES);        if (writeInterop) {            writer.writeEmptyElement(JacORBSubsystemConstants.INTEROP);            this.writeAttributes(writer, node, JacORBSubsystemDefinitions.INTEROP_ATTRIBUTES);        }    }
private void writeSecurityConfig(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {        boolean writeSecurity = this.isWritable(node, JacORBSubsystemDefinitions.SECURITY_ATTRIBUTES);        if (writeSecurity) {            writer.writeEmptyElement(SECURITY);            this.writeAttributes(writer, node, JacORBSubsystemDefinitions.SECURITY_ATTRIBUTES);        }    }
private void writeGenericProperties(XMLExtendedStreamWriter writer, ModelNode node) throws XMLStreamException {        writer.writeStartElement(JacORBSubsystemConstants.PROPERTIES);        for (Property prop : node.asPropertyList()) {            writer.writeEmptyElement(JacORBSubsystemConstants.PROPERTY);            writer.writeAttribute(JacORBSubsystemConstants.NAME, prop.getName());            writer.writeAttribute(JacORBSubsystemConstants.PROPERTY_VALUE, prop.getValue().asString());        }        writer.writeEndElement();    }
private void writeAttributes(XMLExtendedStreamWriter writer, ModelNode node, List<SimpleAttributeDefinition> attributes)            throws XMLStreamException {        for (SimpleAttributeDefinition definition : attributes)            definition.marshallAsAttribute(node, writer);    }
private boolean isWritable(ModelNode node, List<SimpleAttributeDefinition> attributeDefinitions) {        boolean isWritable = false;        for (SimpleAttributeDefinition attributeDefinition : attributeDefinitions) {            if (attributeDefinition.isMarshallable(node)) {                isWritable = true;                break;            }        }        return isWritable;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        if (DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {            return;        }        EEModuleDescription moduleDescription = deploymentUnit.getAttachment(EE_MODULE_DESCRIPTION);        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();        final ServiceName appContextServiceName = ContextNames.contextServiceNameOfApplication(moduleDescription.getApplicationName());        final ServiceName moduleContextServiceName = ContextNames.contextServiceNameOfModule(moduleDescription.getApplicationName(), moduleDescription.getModuleName());        final NamingStoreService contextService = new NamingStoreService(true);        serviceTarget.addService(moduleContextServiceName, contextService).install();        final ServiceName moduleNameServiceName = moduleContextServiceName.append("ModuleName");        final BinderService moduleNameBinder = new BinderService("ModuleName");        moduleNameBinder.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(Values.immediateValue(moduleDescription.getModuleName())));        serviceTarget.addService(moduleNameServiceName, moduleNameBinder)                .addDependency(moduleContextServiceName, ServiceBasedNamingStore.class, moduleNameBinder.getNamingStoreInjector())                .install();        deploymentUnit.addToAttachmentList(org.jboss.as.server.deployment.Attachments.JNDI_DEPENDENCIES, moduleNameServiceName);        deploymentUnit.putAttachment(MODULE_CONTEXT_CONFIG, moduleContextServiceName);        final InjectedEENamespaceContextSelector selector = new InjectedEENamespaceContextSelector();        phaseContext.addDependency(appContextServiceName, NamingStore.class, selector.getAppContextInjector());        phaseContext.addDependency(moduleContextServiceName, NamingStore.class, selector.getModuleContextInjector());        phaseContext.addDependency(moduleContextServiceName, NamingStore.class, selector.getCompContextInjector());        phaseContext.addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, NamingStore.class, selector.getJbossContextInjector());        phaseContext.addDependency(ContextNames.EXPORTED_CONTEXT_SERVICE_NAME, NamingStore.class, selector.getExportedContextInjector());        phaseContext.addDependency(ContextNames.GLOBAL_CONTEXT_SERVICE_NAME, NamingStore.class, selector.getGlobalContextInjector());        moduleDescription.setNamespaceContextSelector(selector);        final Set<ServiceName> serviceNames = new HashSet<ServiceName>();        serviceNames.add(appContextServiceName);        serviceNames.add(moduleContextServiceName);        serviceNames.add(ContextNames.JBOSS_CONTEXT_SERVICE_NAME);        serviceNames.add(ContextNames.GLOBAL_CONTEXT_SERVICE_NAME);        // add the arquillian setup action, so the module namespace is available in arquillian tests        final JavaNamespaceSetup setupAction = new JavaNamespaceSetup(selector, deploymentUnit.getServiceName());        deploymentUnit.addToAttachmentList(SETUP_ACTIONS, setupAction);        deploymentUnit.addToAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS, setupAction);        deploymentUnit.putAttachment(Attachments.JAVA_NAMESPACE_SETUP_ACTION, setupAction);    }
private List<BindingConfiguration> getPersistenceUnitRefs(DeploymentUnit deploymentUnit, DeploymentDescriptorEnvironment environment, ClassLoader classLoader, DeploymentReflectionIndex deploymentReflectionIndex, ResourceInjectionTarget resourceInjectionTarget) throws        DeploymentUnitProcessingException {        final List<BindingConfiguration> bindingConfigurations = new ArrayList<BindingConfiguration>();        if (environment.getEnvironment() == null) {            return bindingConfigurations;        }        PersistenceUnitReferencesMetaData persistenceUnitRefs = environment.getEnvironment().getPersistenceUnitRefs();        if (persistenceUnitRefs != null) {            if (persistenceUnitRefs.size() > 0) {                JPADeploymentMarker.mark(deploymentUnit);            }            for (PersistenceUnitReferenceMetaData puRef : persistenceUnitRefs) {                String name = puRef.getName();                String persistenceUnitName = puRef.getPersistenceUnitName();                String lookup = puRef.getLookupName();                if (!isEmpty(lookup) && !isEmpty(persistenceUnitName)) {                    throw JpaLogger.ROOT_LOGGER.cannotSpecifyBoth("<lookup-name>", lookup, "persistence-unit-name", persistenceUnitName, "<persistence-unit-ref/>", resourceInjectionTarget);                }                if (!name.startsWith("java:")) {                    name = environment.getDefaultContext() + name;                }                // our injection (source) comes from the local (ENC) lookup, no matter what.                LookupInjectionSource injectionSource = new LookupInjectionSource(name);                //add any injection targets                processInjectionTargets(resourceInjectionTarget, injectionSource, classLoader, deploymentReflectionIndex, puRef, EntityManagerFactory.class);                BindingConfiguration bindingConfiguration = null;                if (!isEmpty(lookup)) {                    bindingConfiguration = new BindingConfiguration(name, new LookupInjectionSource(lookup));                } else {                    InjectionSource puBindingSource = this.getPersistenceUnitBindingSource(deploymentUnit, persistenceUnitName);                    bindingConfiguration = new BindingConfiguration(name, puBindingSource);                }                bindingConfigurations.add(bindingConfiguration);            }        }        return bindingConfigurations;    }
private List<BindingConfiguration> getPersistenceContextRefs(DeploymentUnit deploymentUnit, DeploymentDescriptorEnvironment environment, ClassLoader classLoader, DeploymentReflectionIndex deploymentReflectionIndex, ResourceInjectionTarget resourceInjectionTarget) throws        DeploymentUnitProcessingException {        List<BindingConfiguration> bindingConfigurations = new ArrayList<BindingConfiguration>();        final RemoteEnvironment remoteEnvironment = environment.getEnvironment();        if (remoteEnvironment == null) {            return bindingConfigurations;        }        if (remoteEnvironment instanceof Environment) {            PersistenceContextReferencesMetaData persistenceUnitRefs = ((Environment) remoteEnvironment).getPersistenceContextRefs();            if (persistenceUnitRefs != null) {                for (PersistenceContextReferenceMetaData puRef : persistenceUnitRefs) {                    String name = puRef.getName();                    String persistenceUnitName = puRef.getPersistenceUnitName();                    String lookup = puRef.getLookupName();                    if (!isEmpty(lookup) && !isEmpty(persistenceUnitName)) {                        throw JpaLogger.ROOT_LOGGER.cannotSpecifyBoth("<lookup-name>", lookup, "persistence-unit-name", persistenceUnitName, "<persistence-context-ref/>", resourceInjectionTarget);                    }                    if (!name.startsWith("java:")) {                        name = environment.getDefaultContext() + name;                    }                    // our injection (source) comes from the local (ENC) lookup, no matter what.                    LookupInjectionSource injectionSource = new LookupInjectionSource(name);                    //add any injection targets                    processInjectionTargets(resourceInjectionTarget, injectionSource, classLoader, deploymentReflectionIndex, puRef, EntityManager.class);                    BindingConfiguration bindingConfiguration = null;                    if (!isEmpty(lookup)) {                        bindingConfiguration = new BindingConfiguration(name, new LookupInjectionSource(lookup));                    } else {                        PropertiesMetaData properties = puRef.getProperties();                        Map<String, String> map = new HashMap<>();                        if (properties != null) {                            for (PropertyMetaData prop : properties) {                                map.put(prop.getKey(), prop.getValue());                            }                        }                        PersistenceContextType type = (puRef.getPersistenceContextType() == null || puRef.getPersistenceContextType() == PersistenceContextTypeDescription.TRANSACTION) ? PersistenceContextType.TRANSACTION : PersistenceContextType.EXTENDED ;                        SynchronizationType synchronizationType =                                (puRef.getPersistenceContextSynchronization() == null || PersistenceContextSynchronizationType.Synchronized.equals(puRef.getPersistenceContextSynchronization()))?                                        SynchronizationType.SYNCHRONIZED: SynchronizationType.UNSYNCHRONIZED;                        InjectionSource pcBindingSource = this.getPersistenceContextBindingSource(deploymentUnit, persistenceUnitName, type, synchronizationType, map);                        bindingConfiguration = new BindingConfiguration(name, pcBindingSource);                    }                    bindingConfigurations.add(bindingConfiguration);                }            }        }        return bindingConfigurations;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        final JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit.getAttachment(JBossServiceXmlDescriptor.ATTACHMENT_KEY);        if(serviceXmlDescriptor == null) {            return; // Skip deployments with out a service xml descriptor        }        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), JBOSS_MODULES_ID, false, false, false, false));        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), JBOSS_AS_SYSTEM_JMX_ID, true, false, false, false));        // depend on Properties editor module which uses ServiceLoader approach to load the appropriate org.jboss.common.beans.property.finder.PropertyEditorFinder        moduleSpecification.addSystemDependency(new ModuleDependency(Module.getBootModuleLoader(), PROPERTIES_EDITOR_MODULE_ID, false, false, true, false));        // All SARs require the ability to register MBeans.        moduleSpecification.addPermissionFactory(REGISTER_PERMISSION_FACTORY);    }
public void runWork(Runnable work) {        // if we have an authenticated subject we check if it contains a security identity and use the identity to run the work.        if (this.authenticatedSubject != null) {            Set<SecurityIdentity> authenticatedIdentities = this.getPrivateCredentials(SecurityIdentity.class);            if (!authenticatedIdentities.isEmpty()) {                SecurityIdentity identity = authenticatedIdentities.iterator().next();                identity.runAs(work);                return;            }        }        // no authenticated subject found or the subject didn't have a security identity - just run the work.        work.run();    }
@Override    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {        // no attributes        if (reader.getAttributeCount() > 0) {            throw unexpectedAttribute(reader, 0);        }        final ModelNode address = new ModelNode();        address.add(ModelDescriptionConstants.SUBSYSTEM, TransactionExtension.SUBSYSTEM_NAME);        address.protect();        final ModelNode subsystem = new ModelNode();        subsystem.get(OP).set(ADD);        subsystem.get(OP_ADDR).set(address);        list.add(subsystem);        final ModelNode logStoreAddress = address.clone();        final ModelNode logStoreOperation = new ModelNode();        logStoreOperation.get(OP).set(ADD);        logStoreAddress.add(LogStoreConstants.LOG_STORE, LogStoreConstants.LOG_STORE);        logStoreAddress.protect();        logStoreOperation.get(OP_ADDR).set(logStoreAddress);        list.add(logStoreOperation);        // elements        final EnumSet<Element> required = EnumSet.of(Element.RECOVERY_ENVIRONMENT, Element.CORE_ENVIRONMENT);        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        choiceObjectStoreEncountered = false;        needsDefaultRelativeTo = true;        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            if (Namespace.forUri(reader.getNamespaceURI()) != getExpectedNamespace()) {                throw unexpectedElement(reader);            }            final Element element = Element.forName(reader.getLocalName());            required.remove(element);            if (!encountered.add(element)) {                throw unexpectedElement(reader);            }            readElement(reader, element, list, subsystem, logStoreOperation);        }        if(needsDefaultRelativeTo && relativeToHasDefaultValue) {            TransactionSubsystemRootResourceDefinition.OBJECT_STORE_RELATIVE_TO.parseAndSetParameter("jboss.server.data.dir", subsystem, reader);        }        if (!required.isEmpty()) {            throw missingRequiredElement(reader, required);        }    }
public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {        if (context.isNormalServer()) {            context.addStep(new OperationStepHandler() {                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {                    final ServiceRegistry registry = context.getServiceRegistry(false);                    if (registry != null) {                        try {                            context.getResult().set(getEndpointMetricsFragment(operation, registry));                        } catch (Exception e) {                            throw new OperationFailedException(getFallbackMessage() + ": " + e.getMessage());                        }                    } else {                        context.getResult().set(getFallbackMessage());                    }                }            }, OperationContext.Stage.RUNTIME);        } else {            context.getResult().set(getFallbackMessage());        }    }
void rejectIncomingContext() {        CurrentRequestInfo threadLocal = threadLocalData.get();        if (threadLocal.sasContextReceived) {            threadLocal.sasReply = (threadLocal.contextId == 0) ? msgCtx0Rejected :                    createMsgCtxError(threadLocal.contextId, 1 /* major status: invalid evidence */);            threadLocal.sasReplyIsAccept = false;        }    }
private static void addPuService(final DeploymentPhaseContext phaseContext, final ArrayList<PersistenceUnitMetadataHolder> puList,                                     final boolean startEarly, final Platform platform)        throws DeploymentUnitProcessingException {        if (puList.size() > 0) {            final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();            final Module module = deploymentUnit.getAttachment(Attachments.MODULE);            final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();            final ModuleClassLoader classLoader = module.getClassLoader();            for (PersistenceUnitMetadataHolder holder : puList) {                setAnnotationIndexes(holder, deploymentUnit);                for (PersistenceUnitMetadata pu : holder.getPersistenceUnits()) {                    // only start the persistence unit if JPA_CONTAINER_MANAGED is true                    String jpaContainerManaged = pu.getProperties().getProperty(Configuration.JPA_CONTAINER_MANAGED);                    boolean deployPU = (jpaContainerManaged == null? true : Boolean.parseBoolean(jpaContainerManaged));                    if (deployPU) {                        final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder(deploymentUnit);                        final PersistenceProvider provider = lookupProvider(pu, persistenceProviderDeploymentHolder, deploymentUnit);                        final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor(pu, persistenceProviderDeploymentHolder, deploymentUnit, provider, platform);                        final boolean twoPhaseBootStrapCapable = (adaptor instanceof TwoPhaseBootstrapCapable) && Configuration.allowTwoPhaseBootstrap(pu);                        if (startEarly) {                            if (twoPhaseBootStrapCapable) {                                deployPersistenceUnitPhaseOne(deploymentUnit, eeModuleDescription, serviceTarget, classLoader, pu, adaptor);                            }                            else if (false == Configuration.needClassFileTransformer(pu)) {                                // will start later when startEarly == false                                ROOT_LOGGER.tracef("persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed",                                    pu.getPersistenceUnitName(), deploymentUnit.getName());                            }                            else {                                // we need class file transformer to work, don't allow cdi bean manager to be access since that                                // could cause application classes to be loaded (workaround by setting jboss.as.jpa.classtransformer to false).  WFLY-1463                                final boolean allowCdiBeanManagerAccess = false;                                deployPersistenceUnit(deploymentUnit, eeModuleDescription, serviceTarget, classLoader, pu, provider, adaptor, allowCdiBeanManagerAccess);                            }                        }                        else { // !startEarly                            if (twoPhaseBootStrapCapable) {                                deployPersistenceUnitPhaseTwo(deploymentUnit, eeModuleDescription, serviceTarget, classLoader, pu, provider, adaptor);                            } else if (false == Configuration.needClassFileTransformer(pu)) {                                final boolean allowCdiBeanManagerAccess = true;                                // PUs that have Configuration.JPA_CONTAINER_CLASS_TRANSFORMER = false will start during INSTALL phase                                deployPersistenceUnit(deploymentUnit, eeModuleDescription, serviceTarget, classLoader, pu, provider, adaptor, allowCdiBeanManagerAccess);                            }                        }                    }                    else {                        ROOT_LOGGER.tracef("persistence unit %s in deployment %s is not container managed (%s is set to false)",                                pu.getPersistenceUnitName(), deploymentUnit.getName(), Configuration.JPA_CONTAINER_MANAGED);                    }                }            }        }    }
private static void deployPersistenceUnit(            final DeploymentUnit deploymentUnit,            final EEModuleDescription eeModuleDescription,            final ServiceTarget serviceTarget,            final ModuleClassLoader classLoader,            final PersistenceUnitMetadata pu,            final PersistenceProvider provider,            final PersistenceProviderAdaptor adaptor,            final boolean allowCdiBeanManagerAccess) throws DeploymentUnitProcessingException {        pu.setClassLoader(classLoader);        TransactionManager transactionManager = ContextTransactionManager.getInstance();        TransactionSynchronizationRegistry transactionSynchronizationRegistry = deploymentUnit.getAttachment(JpaAttachments.TRANSACTION_SYNCHRONIZATION_REGISTRY);        CapabilityServiceSupport capabilitySupport = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);        try {            ValidatorFactory validatorFactory = null;            final HashMap<String, ValidatorFactory> properties = new HashMap<>();            CapabilityServiceSupport css = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);            if (!ValidationMode.NONE.equals(pu.getValidationMode())) {                if (css.hasCapability("org.wildfly.bean-validation")) {                    // Get the CDI-enabled ValidatorFactory                    validatorFactory = deploymentUnit.getAttachment(BeanValidationAttachments.VALIDATOR_FACTORY);                }            }            BeanManagerAfterDeploymentValidation beanManagerAfterDeploymentValidation = registerJPAEntityListenerRegister(deploymentUnit, capabilitySupport);            final PersistenceAdaptorRemoval persistenceAdaptorRemoval = new PersistenceAdaptorRemoval(pu, adaptor);            deploymentUnit.addToAttachmentList(REMOVAL_KEY, persistenceAdaptorRemoval);            // add persistence provider specific properties            adaptor.addProviderProperties(properties, pu);            final ServiceName puServiceName = PersistenceUnitServiceImpl.getPUServiceName(pu);            deploymentUnit.putAttachment(JpaAttachments.PERSISTENCE_UNIT_SERVICE_KEY, puServiceName);            deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, puServiceName);            deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, puServiceName);            final PersistenceUnitServiceImpl service =                    new PersistenceUnitServiceImpl(properties, classLoader, pu, adaptor, provider, PersistenceUnitRegistryImpl.INSTANCE,                            deploymentUnit.getServiceName(), validatorFactory, deploymentUnit.getAttachment(org.jboss.as.ee.naming.Attachments.JAVA_NAMESPACE_SETUP_ACTION),                            beanManagerAfterDeploymentValidation );            ServiceBuilder<PersistenceUnitService> builder = serviceTarget.addService(puServiceName, service);            boolean useDefaultDataSource = Configuration.allowDefaultDataSourceUse(pu);            final String jtaDataSource = adjustJndi(pu.getJtaDataSourceName());            final String nonJtaDataSource = adjustJndi(pu.getNonJtaDataSourceName());            if (jtaDataSource != null && jtaDataSource.length() > 0) {                if (jtaDataSource.equals(EE_DEFAULT_DATASOURCE)) { // explicit use of default datasource                    useDefaultDataSource = true;                }                else {                    builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, jtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getJtaDataSourceInjector()));                    useDefaultDataSource = false;                }            }            if (nonJtaDataSource != null && nonJtaDataSource.length() > 0) {                builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, nonJtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getNonJtaDataSourceInjector()));                useDefaultDataSource = false;            }            // JPA 2.0 8.2.1.5, container provides default JTA datasource            if (useDefaultDataSource) {                // try the default datasource defined in the ee subsystem                String defaultJtaDataSource = null;                if (eeModuleDescription != null) {                    defaultJtaDataSource = eeModuleDescription.getDefaultResourceJndiNames().getDataSource();                }                if (defaultJtaDataSource == null ||                        defaultJtaDataSource.isEmpty()) {                    // try the datasource defined in the jpa subsystem                    defaultJtaDataSource = adjustJndi(JPAService.getDefaultDataSourceName());                }                if (defaultJtaDataSource != null &&                    !defaultJtaDataSource.isEmpty()) {                    builder.addDependency(ContextNames.bindInfoFor(defaultJtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getJtaDataSourceInjector()));                    ROOT_LOGGER.tracef("%s is using the default data source '%s'", puServiceName, defaultJtaDataSource);                }            }            // JPA 2.1 sections 3.5.1 + 9.1 require the CDI bean manager to be passed to the peristence provider            // if the persistence unit is contained in a deployment that is a CDI bean archive (has beans.xml).            final CapabilityServiceSupport support = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);            if (support.hasCapability(WELD_CAPABILITY_NAME) && allowCdiBeanManagerAccess) {                support.getOptionalCapabilityRuntimeAPI(WELD_CAPABILITY_NAME, WeldCapability.class).get()                        .addBeanManagerService(deploymentUnit, builder, service.getBeanManagerInjector());            }            try {                // save a thread local reference to the builder for setting up the second level cache dependencies                CacheDeploymentListener.setInternalDeploymentSupport(builder, capabilitySupport);                adaptor.addProviderDependencies(pu);            }            finally {                CacheDeploymentListener.clearInternalDeploymentSupport();            }            /**             * handle extension that binds a transaction scoped entity manager to specified JNDI location             */            entityManagerBind(eeModuleDescription, serviceTarget, pu, puServiceName, transactionManager, transactionSynchronizationRegistry);            /**             * handle extension that binds an entity manager factory to specified JNDI location             */            entityManagerFactoryBind(eeModuleDescription, serviceTarget, pu, puServiceName);            // get async executor from Services.addServerExecutorDependency            addServerExecutorDependency(builder, service.getExecutorInjector());            builder.install();            ROOT_LOGGER.tracef("added PersistenceUnitService for '%s'.  PU is ready for injector action.", puServiceName);            addManagementConsole(deploymentUnit, pu, adaptor, persistenceAdaptorRemoval);        } catch (ServiceRegistryException e) {            throw JpaLogger.ROOT_LOGGER.failedToAddPersistenceUnit(e, pu.getPersistenceUnitName());        }    }
private static void deployPersistenceUnitPhaseOne(            final DeploymentUnit deploymentUnit,            final EEModuleDescription eeModuleDescription,            final ServiceTarget serviceTarget,            final ModuleClassLoader classLoader,            final PersistenceUnitMetadata pu,            final PersistenceProviderAdaptor adaptor) throws DeploymentUnitProcessingException {        CapabilityServiceSupport capabilitySupport = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);        pu.setClassLoader(classLoader);        try {            final HashMap<String, ValidatorFactory> properties = new HashMap<>();            ProxyBeanManager proxyBeanManager = null;            // JPA 2.1 sections 3.5.1 + 9.1 require the CDI bean manager to be passed to the peristence provider            // if the persistence unit is contained in a deployment that is a CDI bean archive (has beans.xml).            final CapabilityServiceSupport support = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);            boolean partOfWeldDeployment = false;            if (support.hasCapability(WELD_CAPABILITY_NAME)) {                partOfWeldDeployment = support.getOptionalCapabilityRuntimeAPI(WELD_CAPABILITY_NAME, WeldCapability.class).get()                        .isPartOfWeldDeployment(deploymentUnit);            }            if (partOfWeldDeployment) {                proxyBeanManager = new ProxyBeanManager();                registerJPAEntityListenerRegister(deploymentUnit, support); // register CDI extension before WeldDeploymentProcessor, which is important for                                                                            // EAR deployments that contain a WAR that has persistence units defined.            }            deploymentUnit.addToAttachmentList(REMOVAL_KEY, new PersistenceAdaptorRemoval(pu, adaptor));            // add persistence provider specific properties            adaptor.addProviderProperties(properties, pu);            final ServiceName puServiceName = PersistenceUnitServiceImpl.getPUServiceName(pu).append(FIRST_PHASE);            deploymentUnit.putAttachment(JpaAttachments.PERSISTENCE_UNIT_SERVICE_KEY, puServiceName);            deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, puServiceName);            deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, puServiceName);            final PhaseOnePersistenceUnitServiceImpl service = new PhaseOnePersistenceUnitServiceImpl(classLoader, pu, adaptor, deploymentUnit.getServiceName(), proxyBeanManager);            service.getPropertiesInjector().inject(properties);            ServiceBuilder<PhaseOnePersistenceUnitServiceImpl> builder = serviceTarget.addService(puServiceName, service);            boolean useDefaultDataSource = Configuration.allowDefaultDataSourceUse(pu);            final String jtaDataSource = adjustJndi(pu.getJtaDataSourceName());            final String nonJtaDataSource = adjustJndi(pu.getNonJtaDataSourceName());            if (jtaDataSource != null && jtaDataSource.length() > 0) {                if (jtaDataSource.equals(EE_DEFAULT_DATASOURCE)) { // explicit use of default datasource                    useDefaultDataSource = true;                }                else {                    builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, jtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getJtaDataSourceInjector()));                    useDefaultDataSource = false;                }            }            if (nonJtaDataSource != null && nonJtaDataSource.length() > 0) {                builder.addDependency(ContextNames.bindInfoForEnvEntry(eeModuleDescription.getApplicationName(), eeModuleDescription.getModuleName(), eeModuleDescription.getModuleName(), false, nonJtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getNonJtaDataSourceInjector()));                useDefaultDataSource = false;            }            // JPA 2.0 8.2.1.5, container provides default JTA datasource            if (useDefaultDataSource) {                // try the one defined in the jpa subsystem                String defaultJtaDataSource = null;                if (eeModuleDescription != null) {                    defaultJtaDataSource = eeModuleDescription.getDefaultResourceJndiNames().getDataSource();                }                if (defaultJtaDataSource == null ||                        defaultJtaDataSource.isEmpty()) {                    // try the datasource defined in the JPA subsystem                    defaultJtaDataSource = adjustJndi(JPAService.getDefaultDataSourceName());                }                if (defaultJtaDataSource != null &&                    !defaultJtaDataSource.isEmpty()) {                    builder.addDependency(ContextNames.bindInfoFor(defaultJtaDataSource).getBinderServiceName(), ManagedReferenceFactory.class, new ManagedReferenceFactoryInjector(service.getJtaDataSourceInjector()));                    ROOT_LOGGER.tracef("%s is using the default data source '%s'", puServiceName, defaultJtaDataSource);                }            }            try {                // save a thread local reference to the builder for setting up the second level cache dependencies                CacheDeploymentListener.setInternalDeploymentSupport(builder, capabilitySupport);                adaptor.addProviderDependencies(pu);            }            finally {                CacheDeploymentListener.clearInternalDeploymentSupport();            }            // get async executor from Services.addServerExecutorDependency            addServerExecutorDependency(builder, service.getExecutorInjector());            builder.install();            ROOT_LOGGER.tracef("added PersistenceUnitService (phase 1 of 2) for '%s'.  PU is ready for injector action.", puServiceName);        } catch (ServiceRegistryException e) {            throw JpaLogger.ROOT_LOGGER.failedToAddPersistenceUnit(e, pu.getPersistenceUnitName());        }    }
private static void setAnnotationIndexes(            final PersistenceUnitMetadataHolder puHolder,            DeploymentUnit deploymentUnit ) {        final Map<URL, Index> annotationIndexes = new HashMap<>();        do {            for (ResourceRoot root : DeploymentUtils.allResourceRoots(deploymentUnit)) {                final Index index = root.getAttachment(Attachments.ANNOTATION_INDEX);                if (index != null) {                    try {                        ROOT_LOGGER.tracef("adding '%s' to annotation index map", root.getRoot().toURL());                        annotationIndexes.put(root.getRoot().toURL(), index);                    } catch (MalformedURLException e) {                        throw new RuntimeException(e);                    }                }            }            deploymentUnit = deploymentUnit.getParent(); // get annotation indexes for top level also        }        while (deploymentUnit != null);        for (PersistenceUnitMetadata pu : puHolder.getPersistenceUnits()) {            pu.setAnnotationIndex(annotationIndexes);   // hold onto the annotation index for Persistence Provider use during deployment        }    }
private static PersistenceProviderAdaptor getPersistenceProviderAdaptor(            final PersistenceUnitMetadata pu,            final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder,            final DeploymentUnit deploymentUnit,            final PersistenceProvider provider,            final Platform platform) throws        DeploymentUnitProcessingException {        String adapterClass = pu.getProperties().getProperty(Configuration.ADAPTER_CLASS);        /**         * use adapter packaged in application deployment.         */        if (persistenceProviderDeploymentHolder != null && adapterClass != null) {            List<PersistenceProviderAdaptor> persistenceProviderAdaptors = persistenceProviderDeploymentHolder.getAdapters();            for(PersistenceProviderAdaptor persistenceProviderAdaptor:persistenceProviderAdaptors) {                if(adapterClass.equals(persistenceProviderAdaptor.getClass().getName())) {                    return persistenceProviderAdaptor;                }            }        }        String adaptorModule = pu.getProperties().getProperty(Configuration.ADAPTER_MODULE);        PersistenceProviderAdaptor adaptor;        adaptor = getPerDeploymentSharedPersistenceProviderAdaptor(deploymentUnit, adaptorModule, provider);        if (adaptor == null) {            try {                // will load the persistence provider adaptor (integration classes).  if adaptorModule is null                // the noop adaptor is returned (can be used against any provider but the integration classes                // are handled externally via properties or code in the persistence provider).                if (adaptorModule != null) { // legacy way of loading adapter module                    adaptor = PersistenceProviderAdaptorLoader.loadPersistenceAdapterModule(adaptorModule, platform, createManager(deploymentUnit));                }                else {                    adaptor = PersistenceProviderAdaptorLoader.loadPersistenceAdapter(provider, platform, createManager(deploymentUnit));                }            } catch (ModuleLoadException e) {                throw JpaLogger.ROOT_LOGGER.persistenceProviderAdaptorModuleLoadError(e, adaptorModule);            }            adaptor = savePerDeploymentSharedPersistenceProviderAdaptor(deploymentUnit, adaptorModule, adaptor, provider);        }        if (adaptor == null) {            throw JpaLogger.ROOT_LOGGER.failedToGetAdapter(pu.getPersistenceProviderClassName());        }        return adaptor;    }
private static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor(DeploymentUnit deploymentUnit, String adaptorModule, PersistenceProviderAdaptor adaptor, PersistenceProvider provider) {        if (deploymentUnit.getParent() != null) {            deploymentUnit = deploymentUnit.getParent();        }        synchronized (deploymentUnit) {            Map<String,PersistenceProviderAdaptor> map = deploymentUnit.getAttachment(providerAdaptorMapKey);            String key;            if (adaptorModule != null) {                key = adaptorModule;  // handle legacy adapter module            }            else {                key = provider.getClass().getName();            }            PersistenceProviderAdaptor current = map.get(key);            // saved if not already set by another thread            if (current == null) {                map.put(key, adaptor);                current = adaptor;            }            return current;        }    }
private static PersistenceProvider lookupProvider(            PersistenceUnitMetadata pu,            PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder,            DeploymentUnit deploymentUnit) throws DeploymentUnitProcessingException {        /**         * check if the deployment is already associated with the specified persistence provider         */        Map<String, PersistenceProvider> providerMap = persistenceProviderDeploymentHolder != null ?                persistenceProviderDeploymentHolder.getProviders() : null;        if (providerMap != null) {            synchronized (providerMap) {                if(providerMap.containsKey(pu.getPersistenceProviderClassName())){                    ROOT_LOGGER.tracef("deployment %s is using %s", deploymentUnit.getName(), pu.getPersistenceProviderClassName());                    return providerMap.get(pu.getPersistenceProviderClassName());                }            }        }        String configuredPersistenceProviderModule = pu.getProperties().getProperty(Configuration.PROVIDER_MODULE);        String persistenceProviderClassName = pu.getPersistenceProviderClassName();        if (persistenceProviderClassName == null) {            persistenceProviderClassName = Configuration.PROVIDER_CLASS_DEFAULT;        }        /**         * locate persistence provider in specified static module         */        if (configuredPersistenceProviderModule != null) {            List<PersistenceProvider> providers;            if (Configuration.PROVIDER_MODULE_APPLICATION_SUPPLIED.equals(configuredPersistenceProviderModule)) {                try {                    // load the persistence provider from the application deployment                    final ModuleClassLoader classLoader = deploymentUnit.getAttachment(Attachments.MODULE).getClassLoader();                    PersistenceProvider provider = PersistenceProviderLoader.loadProviderFromDeployment(classLoader, persistenceProviderClassName);                    providers = new ArrayList<>();                    providers.add(provider);                    PersistenceProviderDeploymentHolder.savePersistenceProviderInDeploymentUnit(deploymentUnit, providers, null);                    return provider;                } catch (ClassNotFoundException e) {                    throw JpaLogger.ROOT_LOGGER.cannotDeployApp(e, persistenceProviderClassName);                } catch (InstantiationException e) {                    throw JpaLogger.ROOT_LOGGER.cannotDeployApp(e, persistenceProviderClassName);                } catch (IllegalAccessException e) {                    throw JpaLogger.ROOT_LOGGER.cannotDeployApp(e, persistenceProviderClassName);                }            } else {                try {                    providers = PersistenceProviderLoader.loadProviderModuleByName(configuredPersistenceProviderModule);                    PersistenceProviderDeploymentHolder.savePersistenceProviderInDeploymentUnit(deploymentUnit, providers, null);                    PersistenceProvider provider = getProviderByName(pu, providers);                    if (provider != null) {                        return provider;                    }                } catch (ModuleLoadException e) {                    throw JpaLogger.ROOT_LOGGER.cannotLoadPersistenceProviderModule(e, configuredPersistenceProviderModule, persistenceProviderClassName);                }            }        }        // try to determine the static module name based on the persistence provider class name        String providerNameDerivedFromClassName = Configuration.getProviderModuleNameFromProviderClassName(persistenceProviderClassName);        // see if the providerNameDerivedFromClassName has been loaded yet        PersistenceProvider provider = getProviderByName(pu);        // if we haven't loaded the provider yet, try loading now        if (provider == null && providerNameDerivedFromClassName != null) {            try {                List<PersistenceProvider> providers = PersistenceProviderLoader.loadProviderModuleByName(providerNameDerivedFromClassName);                PersistenceProviderDeploymentHolder.savePersistenceProviderInDeploymentUnit(deploymentUnit, providers, null);                provider = getProviderByName(pu, providers);            } catch (ModuleLoadException e) {                throw JpaLogger.ROOT_LOGGER.cannotLoadPersistenceProviderModule(e, providerNameDerivedFromClassName, persistenceProviderClassName);            }        }        if (provider == null)            throw JpaLogger.ROOT_LOGGER.persistenceProviderNotFound(persistenceProviderClassName);        return provider;    }
private static void nextPhaseDependsOnPersistenceUnit(final DeploymentPhaseContext phaseContext, final Platform platform) throws DeploymentUnitProcessingException {        final DeploymentUnit topDeploymentUnit = DeploymentUtils.getTopDeploymentUnit(phaseContext.getDeploymentUnit());        final PersistenceUnitsInApplication persistenceUnitsInApplication = topDeploymentUnit.getAttachment(PersistenceUnitsInApplication.PERSISTENCE_UNITS_IN_APPLICATION);        for(final PersistenceUnitMetadataHolder holder: persistenceUnitsInApplication.getPersistenceUnitHolders()) {            for (final PersistenceUnitMetadata pu : holder.getPersistenceUnits()) {                String jpaContainerManaged = pu.getProperties().getProperty(Configuration.JPA_CONTAINER_MANAGED);                boolean deployPU = (jpaContainerManaged == null? true : Boolean.parseBoolean(jpaContainerManaged));                if (deployPU) {                    final ServiceName puServiceName = PersistenceUnitServiceImpl.getPUServiceName(pu);                    final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder(phaseContext.getDeploymentUnit());                    final PersistenceProvider provider = lookupProvider(pu, persistenceProviderDeploymentHolder, phaseContext.getDeploymentUnit());                    final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor(pu, persistenceProviderDeploymentHolder, phaseContext.getDeploymentUnit(), provider, platform);                    final boolean twoPhaseBootStrapCapable = (adaptor instanceof TwoPhaseBootstrapCapable) && Configuration.allowTwoPhaseBootstrap(pu);                    // only add the next phase dependency, if the persistence unit service is starting early.                    if( Configuration.needClassFileTransformer(pu)) {                        // wait until the persistence unit service is started before starting the next deployment phase                        phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, twoPhaseBootStrapCapable ? puServiceName.append(FIRST_PHASE) : puServiceName);                    }                }            }        }    }
private static void addManagementConsole(final DeploymentUnit deploymentUnit, final PersistenceUnitMetadata pu,                                             final PersistenceProviderAdaptor adaptor, PersistenceAdaptorRemoval persistenceAdaptorRemoval) {        ManagementAdaptor managementAdaptor = adaptor.getManagementAdaptor();        // workaround for AS7-4441, if a custom hibernate.cache.region_prefix is specified, don't show the persistence        // unit in management console.        if (managementAdaptor != null &&                adaptor.doesScopedPersistenceUnitNameIdentifyCacheRegionName(pu)) {            final String providerLabel = managementAdaptor.getIdentificationLabel();            final String scopedPersistenceUnitName = pu.getScopedPersistenceUnitName();            Resource providerResource = JPAService.createManagementStatisticsResource(managementAdaptor, scopedPersistenceUnitName, deploymentUnit);            // Resource providerResource = managementAdaptor.createPersistenceUnitResource(scopedPersistenceUnitName, providerLabel);            ModelNode perPuNode = providerResource.getModel();            perPuNode.get(SCOPED_UNIT_NAME.getName()).set(pu.getScopedPersistenceUnitName());            // TODO this is a temporary hack into internals until DeploymentUnit exposes a proper Resource-based API            final Resource deploymentResource = deploymentUnit.getAttachment(DeploymentModelUtils.DEPLOYMENT_RESOURCE);            Resource subsystemResource;            synchronized (deploymentResource) {                subsystemResource = getOrCreateResource(deploymentResource, PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, "jpa"));            }            synchronized (subsystemResource) {                subsystemResource.registerChild(PathElement.pathElement(providerLabel, scopedPersistenceUnitName), providerResource);                // save the subsystemResource reference + path to scoped pu, so we can remove it during undeploy                persistenceAdaptorRemoval.registerManagementConsoleChild(subsystemResource, PathElement.pathElement(providerLabel, scopedPersistenceUnitName));            }        }    }
private static Resource getOrCreateResource(final Resource parent, final PathElement element) {        synchronized (parent) {            if (parent.hasChild(element)) {                return parent.requireChild(element);            } else {                final Resource resource = Resource.Factory.create();                parent.registerChild(element, resource);                return resource;            }        }    }
@Override    public Map<Class<? extends Annotation>, Set<Class<?>>> getAnnotatedClasses(final Set uris) {        return annotations; // TODO:  Should this be limited by URI    }
final EJBArchiveMetaData create(final Deployment dep) {        if (WSLogger.ROOT_LOGGER.isTraceEnabled()) {            WSLogger.ROOT_LOGGER.tracef("Building JBoss agnostic meta data for EJB webservice deployment: %s", dep.getSimpleName());        }        final EJBArchiveMetaData.Builder ejbArchiveMDBuilder = new EJBArchiveMetaData.Builder();        this.buildEnterpriseBeansMetaData(dep, ejbArchiveMDBuilder);        this.buildWebservicesMetaData(dep, ejbArchiveMDBuilder);        return ejbArchiveMDBuilder.build();    }
private void buildWebservicesMetaData(final Deployment dep, final EJBArchiveMetaData.Builder ejbArchiveMDBuilder) {       final JBossWebservicesMetaData webservicesMD = WSHelper.getOptionalAttachment(dep, JBossWebservicesMetaData.class);       if (webservicesMD == null) return;       // set context root       final String contextRoot = webservicesMD.getContextRoot();       ejbArchiveMDBuilder.setWebServiceContextRoot(contextRoot);        WSLogger.ROOT_LOGGER.tracef("Setting context root: %s", contextRoot);       // set config name       final String configName = webservicesMD.getConfigName();       ejbArchiveMDBuilder.setConfigName(configName);        WSLogger.ROOT_LOGGER.tracef("Setting config name: %s", configName);       // set config file       final String configFile = webservicesMD.getConfigFile();       ejbArchiveMDBuilder.setConfigFile(configFile);        WSLogger.ROOT_LOGGER.tracef("Setting config file: %s", configFile);       // set wsdl location resolver       final JBossWebserviceDescriptionMetaData[] wsDescriptionsMD = webservicesMD.getWebserviceDescriptions();       final PublishLocationAdapter resolver = new PublishLocationAdapterImpl(wsDescriptionsMD);       ejbArchiveMDBuilder.setPublishLocationAdapter(resolver);    }
protected void buildEnterpriseBeanMetaData(final List<EJBMetaData> wsEjbsMD, final EJBEndpoint ejbEndpoint, final JBossWebservicesMetaData jbossWebservicesMD) {        final SLSBMetaData.Builder wsEjbMDBuilder = new SLSBMetaData.Builder();        // set EJB name and class        wsEjbMDBuilder.setEjbName(ejbEndpoint.getName());        wsEjbMDBuilder.setEjbClass(ejbEndpoint.getClassName());        final JBossPortComponentMetaData portComponentMD = getPortComponent(ejbEndpoint.getName(), jbossWebservicesMD);        if (portComponentMD != null) {            // set port component meta data            wsEjbMDBuilder.setPortComponentName(portComponentMD.getPortComponentName());            wsEjbMDBuilder.setPortComponentURI(portComponentMD.getPortComponentURI());        }        // set security meta data        // auth method        final String authMethod = getAuthMethod(ejbEndpoint, portComponentMD);        // transport guarantee        final String transportGuarantee = getTransportGuarantee(ejbEndpoint, portComponentMD);        // secure wsdl access        final boolean secureWsdlAccess = isSecureWsdlAccess(ejbEndpoint, portComponentMD);        final String realmName = getRealmName(ejbEndpoint, portComponentMD);        // propagate        wsEjbMDBuilder.setSecurityMetaData(new EJBSecurityMetaData(authMethod, realmName, transportGuarantee, secureWsdlAccess));        wsEjbsMD.add(wsEjbMDBuilder.build());    }
static void validateModel(OperationContext context, ModelNode operation, Resource resource) throws OperationFailedException {        String addressSetting = PathAddress.pathAddress(operation.require(OP_ADDR)).getLastElement().getValue();        PathAddress address = pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR));        Resource activeMQServer = context.readResourceFromRoot(MessagingServices.getActiveMQServerPathAddress(address), true);        checkExpiryAddress(context, resource.getModel(), activeMQServer, addressSetting);        checkDeadLetterAddress(context, resource.getModel(), activeMQServer, addressSetting);    }
void refreshParticipant(OperationContext context) {        context.addStep(refreshHandler, OperationContext.Stage.MODEL, true);    }
private String getApplicationName(DeploymentUnit deploymentUnit) {        final DeploymentUnit parentDU = deploymentUnit.getParent();        if (parentDU == null) {            final EarMetaData earMetaData = deploymentUnit.getAttachment(org.jboss.as.ee.structure.Attachments.EAR_METADATA);            if (earMetaData != null) {                final String overriddenAppName = earMetaData.getApplicationName();                if (overriddenAppName == null) {                    return this.getEarName(deploymentUnit);                }                return overriddenAppName;            } else {                return this.getEarName(deploymentUnit);            }        }        // traverse to top level DU        return this.getApplicationName(parentDU);    }
private String getEarName(final DeploymentUnit deploymentUnit) {        final String duName = deploymentUnit.getName();        if (duName.endsWith(".ear")) {            return duName.substring(0, duName.length() - ".ear".length());        }        return null;    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.ExceptionDefHelper.narrow(                    servantToReference(new ExceptionDefPOATie(this)));        }        return ref;    }
public Description describe() {        String defined_in_id = "IR";        if (defined_in instanceof ContainedOperations)            defined_in_id = ((ContainedOperations) defined_in).id();        ExceptionDescription ed = new ExceptionDescription(name, id,                defined_in_id,                version, type());        Any any = getORB().create_any();        ExceptionDescriptionHelper.insert(any, ed);        return new Description(DefinitionKind.dk_Exception, any);    }
@Override    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> operations) throws XMLStreamException {        PathAddress address = PathAddress.pathAddress(SUBSYSTEM_PATH);        final ModelNode ejb3SubsystemAddOperation = Util.createAddOperation(address);        operations.add(ejb3SubsystemAddOperation);        // elements        final EnumSet<NamingSubsystemXMLElement> encountered = EnumSet.noneOf(NamingSubsystemXMLElement.class);        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {            if (validNamespace == NamingSubsystemNamespace.forUri(reader.getNamespaceURI())) {                final NamingSubsystemXMLElement element = NamingSubsystemXMLElement.forName(reader.getLocalName());                if (!encountered.add(element)) {                    throw unexpectedElement(reader);                }                switch (element) {                    case BINDINGS: {                        parseBindings(reader, operations, address);                        break;                    }                    case REMOTE_NAMING: {                        parseRemoteNaming(reader, operations, address);                        break;                    }                    default: {                        throw unexpectedElement(reader);                    }                }            }            else {                throw unexpectedElement(reader);            }        }    }
private void parseObjectFactoryBindingEnvironment(XMLExtendedStreamReader reader, ModelNode bindingAdd) throws XMLStreamException {        // no attributes expected        requireNoAttributes(reader);        while (reader.hasNext() && reader.nextTag() != XMLStreamConstants.END_ELEMENT) {            switch (NamingSubsystemXMLElement.forName(reader.getLocalName())) {                case ENVIRONMENT_PROPERTY: {                    final String[] array = requireAttributes(reader, org.jboss.as.controller.parsing.Attribute.NAME.getLocalName(), org.jboss.as.controller.parsing.Attribute.VALUE.getLocalName());                    NamingBindingResourceDefinition.ENVIRONMENT.parseAndAddParameterElement(array[0], array[1], bindingAdd, reader);                    requireNoContent(reader);                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }    }
public static String virtualNodesToSegments(String virtualNodesValue) {        int segments = SEGMENTS_DEFAULT;        try {            segments =  virtualNodesToSegments(Integer.parseInt(virtualNodesValue));        }        catch(NumberFormatException nfe) {            // in case of expression        }        return Integer.toString(segments);    }
protected Exception handleException(final InterceptorContext invocation, Throwable ex) throws Exception {        ApplicationExceptionDetails ae = component.getApplicationException(ex.getClass(), invocation.getMethod());        // it's an application exception, so just throw it back as-is        if (ae != null) {            throw (Exception)ex;        }        if (ex instanceof EJBException) {            throw (EJBException) ex;        } else if(ex instanceof Exception){            throw new EJBException((Exception)ex);        } else {            throw new EJBException(new RuntimeException(ex));        }    }
private void bindService(final ServiceTarget serviceTarget, final ServiceName contextServiceName, final Module module) {        final ServiceName orbServiceName = contextServiceName.append("ORB");        final BinderService orbService = new BinderService("ORB");        serviceTarget.addService(orbServiceName, orbService)                .addDependency(CorbaORBService.SERVICE_NAME, ORB.class,                        new ManagedReferenceInjector<ORB>(orbService.getManagedObjectInjector()))                .addDependency(contextServiceName, ServiceBasedNamingStore.class, orbService.getNamingStoreInjector())                .install();        final ServiceName handleDelegateServiceName = contextServiceName.append("HandleDelegate");        final BinderService handleDelegateBindingService = new BinderService("HandleDelegate");        handleDelegateBindingService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(new ImmediateValue(new HandleDelegateImpl(module.getClassLoader()))));        serviceTarget.addService(handleDelegateServiceName, handleDelegateBindingService)                .addDependency(contextServiceName, ServiceBasedNamingStore.class, handleDelegateBindingService.getNamingStoreInjector())                .install();    }
@Override    public void registerChildren(ManagementResourceRegistration resourceRegistration) {        super.registerChildren(resourceRegistration);        // /deployment=DU/**/subsystem=ejb3/*=EJBName/service=timer-service        final AbstractEJBComponentRuntimeHandler<?> handler = componentType.getRuntimeHandler();        resourceRegistration.registerSubModel(new TimerServiceResourceDefinition(handler));    }
ContainerAnalysis getAnalysis(final Class cls) throws RMIIIOPViolationException {        ContainerAnalysis ret = null;        boolean created = false;        try {            synchronized (this) {                ret = lookupDone(cls);                if (ret != null) {                    return ret;                }                // is it work-in-progress?                final ContainerAnalysis inProgress = workInProgress.get(new InProgressKey(cls, Thread.currentThread()));                if (inProgress != null) {                        return inProgress; // return unfinished                    // Do not wait for the other thread: We may deadlock                    // Double work is better that deadlock...                }                ret = createWorkInProgress(cls);            }            created = true;            // Do the work            doTheWork(cls, ret);        } finally {            // We did it            synchronized (this) {                if(created) {                    workInProgress.remove(new InProgressKey(cls, Thread.currentThread()));                    workDone.put(cls, new SoftReference<ContainerAnalysis>(ret));                    ClassLoader classLoader = cls.getClassLoader();                    if (classLoader != null) {                        Set<Class<?>> classes = classesByLoader.get(classLoader);                        if (classes == null) {                            classesByLoader.put(classLoader, classes = new HashSet<Class<?>>());                        }                        classes.add(cls);                    }                }                notifyAll();            }        }        return ret;    }
private ContainerAnalysis lookupDone(Class cls) {        SoftReference ref = (SoftReference) workDone.get(cls);        if (ref == null)            return null;        ContainerAnalysis ret = (ContainerAnalysis) ref.get();        if (ret == null)            workDone.remove(cls); // clear map entry if soft ref. was cleared.        return ret;    }
private ContainerAnalysis createWorkInProgress(final Class cls) {        final ContainerAnalysis analysis;        try {            analysis = (ContainerAnalysis) constructor.newInstance(cls);        } catch (InstantiationException ex) {            throw new RuntimeException(ex.toString());        } catch (IllegalAccessException ex) {            throw new RuntimeException(ex.toString());        } catch (InvocationTargetException ex) {            throw new RuntimeException(ex.toString());        }        workInProgress.put(new InProgressKey(cls, Thread.currentThread()), analysis);        return analysis;    }
public String getIDLModuleName() {        if (idlModuleName == null) {            String pkgName = cls.getPackage().getName();            StringBuffer b = new StringBuffer();            while (!"".equals(pkgName)) {                int idx = pkgName.indexOf('.');                String n = (idx == -1) ? pkgName : pkgName.substring(0, idx);                b.append("::").append(Util.javaToIDLName(n));                pkgName = (idx == -1) ? "" : pkgName.substring(idx + 1);            }            idlModuleName = b.toString();        }        return idlModuleName;    }
protected String toHexString(int i) {        String s = Integer.toHexString(i).toUpperCase(Locale.ENGLISH);        if (s.length() < 8)            return "00000000".substring(0, 8 - s.length()) + s;        else            return s;    }
protected String toHexString(long l) {        String s = Long.toHexString(l).toUpperCase(Locale.ENGLISH);        if (s.length() < 16)            return "0000000000000000".substring(0, 16 - s.length()) + s;        else            return s;    }
protected boolean isAccessor(Method m) {        Class returnType = m.getReturnType();        // JBAS-4473, look for get<name>()        String name = m.getName();        if (!(name.startsWith("get") && name.length() > "get".length()))            if (!(name.startsWith("is") && name.length() > "is".length())                    || !(returnType == Boolean.TYPE))                return false;        if (returnType == Void.TYPE)            return false;        if (m.getParameterTypes().length != 0)            return false;        return hasNonAppExceptions(m);    }
protected boolean isMutator(Method m) {        // JBAS-4473, look for set<name>()        String name = m.getName();        if (!(name.startsWith("set") && name.length() > "set".length()))            return false;        if (m.getReturnType() != Void.TYPE)            return false;        if (m.getParameterTypes().length != 1)            return false;        return hasNonAppExceptions(m);    }
protected boolean hasNonAppExceptions(Method m) {        Class[] ex = m.getExceptionTypes();        for (int i = 0; i < ex.length; ++i)            if (!java.rmi.RemoteException.class.isAssignableFrom(ex[i]))                return false;        return true;    }
protected void analyzeFields() {        //fields = cls.getFields();        fields = cls.getDeclaredFields();        f_flags = new byte[fields.length];        for (int i = 0; i < fields.length; ++i) {            int mods = fields[i].getModifiers();            if (Modifier.isFinal(mods) &&                    Modifier.isStatic(mods) &&                    Modifier.isPublic(mods))                f_flags[i] |= F_CONSTANT;        }    }
protected void analyzeInterfaces() throws RMIIIOPViolationException {        Class[] intfs = cls.getInterfaces();        ArrayList a = new ArrayList();        ArrayList b = new ArrayList();        for (int i = 0; i < intfs.length; ++i) {            // Ignore java.rmi.Remote            if (intfs[i] == java.rmi.Remote.class)                continue;            // Ignore java.io.Serializable            if (intfs[i] == java.io.Serializable.class)                continue;            // Ignore java.io.Externalizable            if (intfs[i] == java.io.Externalizable.class)                continue;            if (!RmiIdlUtil.isAbstractValueType(intfs[i])) {                a.add(InterfaceAnalysis.getInterfaceAnalysis(intfs[i]));            } else {                b.add(ValueAnalysis.getValueAnalysis(intfs[i]));            }        }        interfaces = new InterfaceAnalysis[a.size()];        interfaces = (InterfaceAnalysis[]) a.toArray(interfaces);        abstractBaseValuetypes = new ValueAnalysis[b.size()];        abstractBaseValuetypes = (ValueAnalysis[]) b.toArray(abstractBaseValuetypes);    }
protected void analyzeMethods() {        // The dynamic stub and skeleton strategy generation mechanism        // requires the inclusion of inherited methods in the analysis of        // remote interfaces. To speed things up, inherited methods are        // not considered in the analysis of a class or non-remote interface.        if (cls.isInterface() && java.rmi.Remote.class.isAssignableFrom(cls))            methods = cls.getMethods();        else            methods = cls.getDeclaredMethods();        m_flags = new byte[methods.length];        mutators = new int[methods.length];        // Find read-write properties        for (int i = 0; i < methods.length; ++i)            mutators[i] = -1; // no mutator here        for (int i = 0; i < methods.length; ++i) {            if (isAccessor(methods[i]) && (m_flags[i] & M_READ) == 0) {                String attrName = attributeReadName(methods[i].getName());                Class iReturn = methods[i].getReturnType();                for (int j = i + 1; j < methods.length; ++j) {                    if (isMutator(methods[j]) && (m_flags[j] & M_WRITE) == 0 &&                            attrName.equals(attributeWriteName(methods[j].getName()))) {                        Class[] jParams = methods[j].getParameterTypes();                        if (jParams.length == 1 && jParams[0] == iReturn) {                            m_flags[i] |= M_READ;                            m_flags[j] |= M_WRITE;                            mutators[i] = j;                            break;                        }                    }                }            } else if (isMutator(methods[i]) && (m_flags[i] & M_WRITE) == 0) {                String attrName = attributeWriteName(methods[i].getName());                Class[] iParams = methods[i].getParameterTypes();                for (int j = i + 1; j < methods.length; ++j) {                    if (isAccessor(methods[j]) && (m_flags[j] & M_READ) == 0 &&                            attrName.equals(attributeReadName(methods[j].getName()))) {                        Class jReturn = methods[j].getReturnType();                        if (iParams.length == 1 && iParams[0] == jReturn) {                            m_flags[i] |= M_WRITE;                            m_flags[j] |= M_READ;                            mutators[j] = i;                            break;                        }                    }                }            }        }        // Find read-only properties        for (int i = 0; i < methods.length; ++i)            if ((m_flags[i] & (M_READ | M_WRITE)) == 0 && isAccessor(methods[i]))                m_flags[i] |= M_READONLY;        // Check for overloaded and inherited methods        for (int i = 0; i < methods.length; ++i) {            if ((m_flags[i] & (M_READ | M_WRITE | M_READONLY)) == 0) {                String iName = methods[i].getName();                for (int j = i + 1; j < methods.length; ++j) {                    if (iName.equals(methods[j].getName())) {                        m_flags[i] |= M_OVERLOADED;                        m_flags[j] |= M_OVERLOADED;                    }                }            }            if (methods[i].getDeclaringClass() != cls)                m_flags[i] |= M_INHERITED;        }    }
protected String attributeReadName(String name) {        if (name.startsWith("get"))            name = name.substring(3);        else if (name.startsWith("is"))            name = name.substring(2);        else            throw IIOPLogger.ROOT_LOGGER.notAnAccessor(name);        return name;    }
protected String attributeWriteName(String name) {        if (name.startsWith("set"))            name = name.substring(3);        else            throw IIOPLogger.ROOT_LOGGER.notAnAccessor(name);        return name;    }
protected void analyzeConstants()            throws RMIIIOPViolationException {        ArrayList a = new ArrayList();        for (int i = 0; i < fields.length; ++i) {            if ((f_flags[i] & F_CONSTANT) == 0)                continue;            Class type = fields[i].getType();            // Only map primitives and java.lang.String            if (!type.isPrimitive() && type != java.lang.String.class) {                // It is an RMI/IIOP violation for interfaces.                if (cls.isInterface())                    throw IIOPLogger.ROOT_LOGGER.badRMIIIOPConstantType(fields[i].getName(), cls.getName(), "1.2.3");                continue;            }            String name = fields[i].getName();            Object value;            try {                value = fields[i].get(null);            } catch (Exception ex) {                throw new RuntimeException(ex.toString());            }            a.add(new ConstantAnalysis(name, type, value));        }        constants = new ConstantAnalysis[a.size()];        constants = (ConstantAnalysis[]) a.toArray(constants);    }
protected void analyzeAttributes() throws RMIIIOPViolationException {        ArrayList a = new ArrayList();        for (int i = 0; i < methods.length; ++i) {            //if ((m_flags[i]&M_INHERITED) != 0)            //  continue;            if ((m_flags[i] & (M_READ | M_READONLY)) != 0) {                // Read method of an attribute.                String name = attributeReadName(methods[i].getName());                if ((m_flags[i] & M_READONLY) != 0)                    a.add(new AttributeAnalysis(name, methods[i]));                else                    a.add(new AttributeAnalysis(name, methods[i],                            methods[mutators[i]]));            }        }        attributes = new AttributeAnalysis[a.size()];        attributes = (AttributeAnalysis[]) a.toArray(attributes);    }
protected void fixupOverloadedOperationNames()            throws RMIIIOPViolationException {        for (int i = 0; i < methods.length; ++i) {            if ((m_flags[i] & M_OVERLOADED) == 0)                continue;            // Find the operation            OperationAnalysis oa = null;            String javaName = methods[i].getName();            for (int opIdx = 0; oa == null && opIdx < operations.length; ++opIdx)                if (operations[opIdx].getMethod().equals(methods[i]))                    oa = operations[opIdx];            if (oa == null)                continue; // This method is not mapped.            // Calculate new IDL name            ParameterAnalysis[] params = oa.getParameters();            StringBuffer b = new StringBuffer(oa.getIDLName());            if (params.length == 0)                b.append("__");            for (int j = 0; j < params.length; ++j) {                String s = params[j].getTypeIDLName();                if (s.startsWith("::"))                    s = s.substring(2);                if (s.startsWith("_")) {                    // remove leading underscore in IDL escaped identifier                    s = s.substring(1);                }                b.append('_');                while (!"".equals(s)) {                    int idx = s.indexOf("::");                    b.append('_');                    if (idx == -1) {                        b.append(s);                        s = "";                    } else {                        b.append(s.substring(0, idx));                        if (s.length() > idx + 2 && s.charAt(idx + 2) == '_') {                            // remove leading underscore in IDL escaped identifier                            s = s.substring(idx + 3);                        } else {                            s = s.substring(idx + 2);                        }                    }                }            }            // Set new IDL name            oa.setIDLName(b.toString());        }    }
protected void fixupCaseNames()            throws RMIIIOPViolationException {        ArrayList entries = getContainedEntries();        boolean[] clash = new boolean[entries.size()];        String[] upperNames = new String[entries.size()];        for (int i = 0; i < entries.size(); ++i) {            AbstractAnalysis aa = (AbstractAnalysis) entries.get(i);            clash[i] = false;            upperNames[i] = aa.getIDLName().toUpperCase(Locale.ENGLISH);            for (int j = 0; j < i; ++j) {                if (upperNames[i].equals(upperNames[j])) {                    clash[i] = true;                    clash[j] = true;                }            }        }        for (int i = 0; i < entries.size(); ++i) {            if (!clash[i])                continue;            AbstractAnalysis aa = (AbstractAnalysis) entries.get(i);            boolean noUpper = true;            String name = aa.getIDLName();            StringBuffer b = new StringBuffer(name);            b.append('_');            for (int j = 0; j < name.length(); ++j) {                if (!Character.isUpperCase(name.charAt(j)))                    continue;                if (noUpper)                    noUpper = false;                else                    b.append('_');                b.append(j);            }            aa.setIDLName(b.toString());        }    }
protected void calculateClassHashCode() {        // The simple cases        if (cls.isInterface())            classHashCode = 0;        else if (!Serializable.class.isAssignableFrom(cls))            classHashCode = 0;        else if (Externalizable.class.isAssignableFrom(cls))            classHashCode = 1;        else // Go ask Util class for the hash code            classHashCode = Util.getClassHashCode(cls);    }
protected String escapeIRName(String name) {        StringBuffer b = new StringBuffer();        for (int i = 0; i < name.length(); ++i) {            char c = name.charAt(i);            if (c < 256)                b.append(c);            else                b.append("\\U").append(toHexString((int) c));        }        return b.toString();    }
protected void calculateRepositoryId() {        if (cls.isArray() || cls.isPrimitive())            throw IIOPLogger.ROOT_LOGGER.notAnClassOrInterface(cls.getName());        if (cls.isInterface() &&                org.omg.CORBA.Object.class.isAssignableFrom(cls) &&                org.omg.CORBA.portable.IDLEntity.class.isAssignableFrom(cls)) {            StringBuffer b = new StringBuffer("IDL:");            b.append(cls.getPackage().getName().replace('.', '/'));            b.append('/');            String base = cls.getName();            base = base.substring(base.lastIndexOf('.') + 1);            b.append(base).append(":1.0");            repositoryId = b.toString();        } else {            StringBuffer b = new StringBuffer("RMI:");            b.append(escapeIRName(cls.getName()));            memberPrefix = b.toString() + ".";            String hashStr = toHexString(classHashCode);            b.append(':').append(hashStr);            ObjectStreamClass osClass = ObjectStreamClass.lookup(cls);            if (osClass != null) {                long serialVersionUID = osClass.getSerialVersionUID();                String SVUID = toHexString(serialVersionUID);                if (classHashCode != serialVersionUID)                    b.append(':').append(SVUID);                memberPostfix = ":" + hashStr + ":" + SVUID;            } else                memberPostfix = ":" + hashStr;            repositoryId = b.toString();        }    }
@Override    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {        // no attributes        if (reader.getAttributeCount() > 0) {            throw ParseUtils.unexpectedAttribute(reader, 0);        }        final ModelNode subsystem = Util.getEmptyOperation(ADD, PathAddress.pathAddress(XTSExtension.SUBSYSTEM_PATH)                .toModelNode());        list.add(subsystem);        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);        final List<Element> expected = getExpectedElements(reader);        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            final Element element = Element.forName(reader.getLocalName());            if (!expected.contains(element) || !encountered.add(element)) {                throw ParseUtils.unexpectedElement(reader);            }            switch (element) {                case HOST: {                    parseHostElement(reader, subsystem);                    break;                }                case XTS_ENVIRONMENT: {                    parseXTSEnvironmentElement(reader,subsystem);                    break;                }                case DEFAULT_CONTEXT_PROPAGATION: {                    parseDefaultContextPropagationElement(reader, subsystem);                    break;                }                case ASYNC_REGISTRATION: {                    parseAsyncRegistrationElement(reader, subsystem);                    break;                }                default: {                    throw ParseUtils.unexpectedElement(reader);                }            }        }    }
@Override    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);        ModelNode node = context.getModelNode();        if (node.hasDefined(HOST_NAME.getName())) {            writer.writeStartElement(Element.HOST.getLocalName());            HOST_NAME.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if (node.hasDefined(ENVIRONMENT_URL.getName())) {            writer.writeStartElement(Element.XTS_ENVIRONMENT.getLocalName());            ENVIRONMENT_URL.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if (node.hasDefined(DEFAULT_CONTEXT_PROPAGATION.getName())) {            writer.writeStartElement(Element.DEFAULT_CONTEXT_PROPAGATION.getLocalName());            DEFAULT_CONTEXT_PROPAGATION.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        if (node.hasDefined(ASYNC_REGISTRATION.getName())) {            writer.writeStartElement(Element.ASYNC_REGISTRATION.getLocalName());            ASYNC_REGISTRATION.marshallAsAttribute(node, writer);            writer.writeEndElement();        }        writer.writeEndElement();    }
private void parseXTSEnvironmentElement(XMLExtendedStreamReader reader, ModelNode subsystem) throws XMLStreamException {        processAttributes(reader, (index, attribute) -> {            final String value = reader.getAttributeValue(index);            switch (attribute) {                case URL:                    ENVIRONMENT_URL.parseAndSetParameter(value, subsystem, reader);                    break;                default:                    throw ParseUtils.unexpectedAttribute(reader, index);            }        });        // Handle elements        ParseUtils.requireNoContent(reader);    }
private void parseDefaultContextPropagationElement(XMLExtendedStreamReader reader, ModelNode subsystem) throws XMLStreamException {        processAttributes(reader, (index, attribute) -> {            final String value = reader.getAttributeValue(index);            switch (attribute) {                case ENABLED:                    if (value == null || (!value.toLowerCase().equals("true") && !value.toLowerCase().equals("false"))) {                        throw ParseUtils.invalidAttributeValue(reader, index);                    }                    DEFAULT_CONTEXT_PROPAGATION.parseAndSetParameter(value, subsystem, reader);                    break;                default:                    throw ParseUtils.unexpectedAttribute(reader, index);            }        });        // Handle elements        ParseUtils.requireNoContent(reader);    }
private void processAttributes(final XMLExtendedStreamReader reader, AttributeProcessor<Integer, Attribute> attributeProcessorCallback) throws XMLStreamException {        final int count = reader.getAttributeCount();        for (int i = 0; i < count; i++) {            ParseUtils.requireNoNamespaceAttribute(reader, i);            // final String value = reader.getAttributeValue(i);            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            attributeProcessorCallback.process(i, attribute);        }    }
public static List<PersistenceProvider> loadProviderModuleByName(String moduleName) throws ModuleLoadException {        final ModuleLoader moduleLoader = Module.getBootModuleLoader();        Module module = moduleLoader.loadModule(ModuleIdentifier.fromString(moduleName));        final ServiceLoader<PersistenceProvider> serviceLoader =            module.loadService(PersistenceProvider.class);        List<PersistenceProvider> result = new ArrayList<>();        if (serviceLoader != null) {            for (PersistenceProvider provider1 : serviceLoader) {                // persistence provider jar may contain multiple provider service implementations                // save each provider                PersistenceProviderResolverImpl.getInstance().addPersistenceProvider(provider1);                result.add(provider1);            }        }        return result;    }
public static void main(String[] args) {        if (java.util.logging.LogManager.getLogManager().getClass().getName().equals("org.jboss.logmanager.LogManager")) {            // Make sure our original stdio is properly captured.            try {                Class.forName(org.jboss.logmanager.handlers.ConsoleHandler.class.getName(), true, org.jboss.logmanager.handlers.ConsoleHandler.class.getClassLoader());            } catch (Throwable ignored) {            }            // Install JBoss Stdio to avoid any nasty crosstalk, after command line arguments are processed.            StdioContext.install();            final StdioContext context = StdioContext.create(                    new NullInputStream(),                    new LoggingOutputStream(org.jboss.logmanager.Logger.getLogger("stdout"), org.jboss.logmanager.Level.INFO),                    new LoggingOutputStream(org.jboss.logmanager.Logger.getLogger("stderr"), org.jboss.logmanager.Level.ERROR)            );            StdioContext.setStdioContextSelector(new SimpleStdioContextSelector(context));        }        try {            Module.registerURLStreamHandlerFactoryModule(Module.getBootModuleLoader().loadModule(ModuleIdentifier.create("org.jboss.vfs")));            final ParsedOptions options = determineEnvironment(args, new Properties(WildFlySecurityManager.getSystemPropertiesPrivileged()), WildFlySecurityManager.getSystemEnvironmentPrivileged(), ServerEnvironment.LaunchType.APPCLIENT);            if(options == null) {                //this happens if --version was specified                return;            }            ServerEnvironment serverEnvironment = options.environment;            final List<String> clientArgs = options.clientArguments;            if (clientArgs.isEmpty()) {                STDERR.println(AppClientLogger.ROOT_LOGGER.appClientNotSpecified());                usage();                abort(null);            } else {                final QName rootElement = new QName(Namespace.CURRENT.getUriString(), "server");                final String file = clientArgs.get(0);                final List<String> params = clientArgs.subList(1, clientArgs.size());                final String deploymentName;                final String earPath;                int pos = file.lastIndexOf("#");                if (pos == -1) {                    earPath = file;                    deploymentName = null;                } else {                    deploymentName = file.substring(pos + 1);                    earPath = file.substring(0, pos);                }                File realFile = new File(earPath);                if (!realFile.exists()) {                    throw AppClientLogger.ROOT_LOGGER.cannotFindAppClientFile(realFile.getAbsoluteFile());                }                final Bootstrap bootstrap = Bootstrap.Factory.newInstance();                final Bootstrap.Configuration configuration = new Bootstrap.Configuration(serverEnvironment);                configuration.setModuleLoader(Module.getBootModuleLoader());                final ExtensionRegistry extensionRegistry = configuration.getExtensionRegistry();                final AppClientXml parser = new AppClientXml(Module.getBootModuleLoader(), extensionRegistry);                final Bootstrap.ConfigurationPersisterFactory configurationPersisterFactory = new Bootstrap.ConfigurationPersisterFactory() {                    @Override                    public ExtensibleConfigurationPersister createConfigurationPersister(ServerEnvironment serverEnvironment, ExecutorService executorService) {                        ApplicationClientConfigurationPersister persister = new ApplicationClientConfigurationPersister(earPath, deploymentName, options.hostUrl,options.propertiesFile, params,                                serverEnvironment.getServerConfigurationFile().getBootFile(), rootElement, parser);                        for (Namespace namespace : Namespace.domainValues()) {                            if (!namespace.equals(Namespace.CURRENT)) {                                persister.registerAdditionalRootElement(new QName(namespace.getUriString(), "server"), parser);                            }                        }                        extensionRegistry.setWriterRegistry(persister);                        return persister;                    }                };                configuration.setConfigurationPersisterFactory(configurationPersisterFactory);                bootstrap.bootstrap(configuration, Collections.<ServiceActivator>emptyList()).get();            }        } catch (Throwable t) {            abort(t);        }    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.AttributeDefHelper.narrow(                    servantToReference(new AttributeDefPOATie(this)));        }        return ref;    }
public Description describe() {        String defined_in_id = "IR";        if (defined_in instanceof ContainedOperations)            defined_in_id = ((ContainedOperations) defined_in).id();        AttributeDescription d =                new AttributeDescription(name, id, defined_in_id, version,                        typeCode, mode);        Any any = getORB().create_any();        AttributeDescriptionHelper.insert(any, d);        return new Description(DefinitionKind.dk_Attribute, any);    }
static AbstractAddStepHandler createAddOperation(final String childType, final boolean allowSibling, Collection<? extends AttributeDefinition> attributes) {        return new ActiveMQReloadRequiredHandlers.AddStepHandler(attributes) {            @Override            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {                super.execute(context, operation);                if (!allowSibling) {                    context.addStep(checkNoOtherSibling(childType), MODEL);                }            }        };    }
@Override    public void start(StartContext context) throws StartException {        try {            Connector cmd = mdr.getValue().getResourceAdapter(deployment);            File root = mdr.getValue().getRoot(deployment);            Activation localRaXml = getRaxml();            cmd = (new Merger()).mergeConnectorWithCommonIronJacamar(localRaXml, cmd);            String id = ((ModifiableResourceAdapter) raxml).getId();            final ServiceName raServiceName;            if (id == null || id.trim().isEmpty()) {                raServiceName = ConnectorServices.getResourceAdapterServiceName(raName);                this.connectorServicesRegistrationName = raName;            } else {                raServiceName = ConnectorServices.getResourceAdapterServiceName(id);                this.connectorServicesRegistrationName = id;            }            final WildFlyRaXmlDeployer raDeployer = new WildFlyRaXmlDeployer(context.getChildTarget(), connectorXmlDescriptor.getUrl(),                raName, root, module.getClassLoader(), cmd, localRaXml, deploymentServiceName);            raDeployer.setConfiguration(config.getValue());            WritableServiceBasedNamingStore.pushOwner(duServiceName);            ClassLoader old = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();            try {                WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(module.getClassLoader());                raxmlDeployment = raDeployer.doDeploy();            } finally {                WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(old);                WritableServiceBasedNamingStore.popOwner();            }            value = new ResourceAdapterDeployment(raxmlDeployment, raName, raServiceName);            managementRepository.getValue().getConnectors().add(value.getDeployment().getConnector());            registry.getValue().registerResourceAdapterDeployment(value);            final ServiceBuilder raServiceSB = context.getChildTarget()                .addService(raServiceName,                        new ResourceAdapterService(raServiceName, value.getDeployment().getResourceAdapter()));            raServiceSB.requires(deploymentServiceName);            raServiceSB.setInitialMode(ServiceController.Mode.ACTIVE).install();        } catch (Throwable t) {            cleanupStartAsync(context, raName, deploymentServiceName, t);        }    }
@Override    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        // get hold of the deployment unit        DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleLoader moduleLoader = Module.getBootModuleLoader();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        //always add EE API        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_API, false, false, true, false));        // previously exported by EJB_API prior to WFLY-5922 TODO WFLY-5967 look into moving this to WS subsystem        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JAX_RPC_API, false, false, true, false));        //we always give them the EJB client        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_CLIENT, false, false, true, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_NAMING_CLIENT, false, false, true, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_IIOP_CLIENT, false, false, false, false));        //we always have to add this, as even non-ejb deployments may still lookup IIOP ejb's        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, EJB_SUBSYSTEM, false, false, true, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, HTTP_EJB, false, false, true, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, HTTP_NAMING, false, false, true, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, HTTP_TRANSACTION, false, false, true, false));        if (IIOPDeploymentMarker.isIIOPDeployment(deploymentUnit)) {            //needed for dynamic IIOP stubs            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, IIOP_OPENJDK, false, false, false, false));        }        // fetch the EjbJarMetaData        //TODO: remove the app client bit after the next EJB release        if (!isEjbDeployment(deploymentUnit) && !DeploymentTypeMarker.isType(DeploymentType.APPLICATION_CLIENT, deploymentUnit)) {            // nothing to do            return;        }        // FIXME: still not the best way to do it        //this must be the first dep listed in the module        if (Boolean.getBoolean("org.jboss.as.ejb3.EMBEDDED"))            moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, ModuleIdentifier.CLASSPATH, false, false, false, false));    }
@Override    public Object getContext(String key, Object data) throws PolicyContextException {        if (!key.equalsIgnoreCase(SecurityConstants.WEB_REQUEST_KEY))            return null;        return SecurityContextAssociationHandler.getActiveRequest();    }
@Override    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);        ModelNode node = context.getModelNode();        WebDefinition.DEFAULT_VIRTUAL_SERVER.marshallAsAttribute(node, true, writer);        WebDefinition.INSTANCE_ID.marshallAsAttribute(node, false, writer);        WebDefinition.NATIVE.marshallAsAttribute(node, true, writer);        WebDefinition.DEFAULT_SESSION_TIMEOUT.marshallAsAttribute(node, false, writer);        if (node.hasDefined(CONFIGURATION)) {            writeContainerConfig(writer, node.get(CONFIGURATION));        }        if (node.hasDefined(CONNECTOR)) {            for (final Property connector : node.get(CONNECTOR).asPropertyList()) {                final ModelNode config = connector.getValue();                writer.writeStartElement(Element.CONNECTOR.getLocalName());                writer.writeAttribute(NAME, connector.getName());                 List<AttributeDefinition> connectorAttributes =  new ArrayList<>(Arrays.asList(WebConnectorDefinition.CONNECTOR_ATTRIBUTES));                if(config.hasDefined(Constants.PROXY_BINDING)) {                    connectorAttributes.remove(WebConnectorDefinition.PROXY_PORT);                    connectorAttributes.remove(WebConnectorDefinition.PROXY_NAME);                } else {                    connectorAttributes.remove(WebConnectorDefinition.PROXY_BINDING);                }                if(config.hasDefined(Constants.REDIRECT_BINDING)) {                    connectorAttributes.remove(WebConnectorDefinition.REDIRECT_PORT);                } else {                    connectorAttributes.remove(WebConnectorDefinition.REDIRECT_BINDING);                }                for (AttributeDefinition attr : connectorAttributes) {                    if (attr instanceof SimpleAttributeDefinition) {                        ((SimpleAttributeDefinition) attr).marshallAsAttribute(config, true, writer);                    }                }                if (config.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {                    ModelNode sslConfig = config.get(SSL_PATH.getKey(), SSL_PATH.getValue());                    writer.writeStartElement(Element.SSL.getLocalName());                    WebSSLDefinition.NAME.marshallAsAttribute(sslConfig, writer);                    for (SimpleAttributeDefinition attr : WebSSLDefinition.SSL_ATTRIBUTES) {                        attr.marshallAsAttribute(sslConfig, false, writer);                    }                    writer.writeEndElement();                }                if (config.hasDefined(VIRTUAL_SERVER)) {                    for (final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {                        writer.writeEmptyElement(VIRTUAL_SERVER);                        writer.writeAttribute(NAME, virtualServer.asString());                    }                }                writer.writeEndElement();            }        }        if (node.hasDefined(VIRTUAL_SERVER)) {            for (final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {                final ModelNode config = host.getValue();                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());                writer.writeAttribute(NAME, host.getName());                WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.marshallAsAttribute(config, true, writer);                WebVirtualHostDefinition.DEFAULT_WEB_MODULE.marshallAsAttribute(config, true, writer);                if (config.hasDefined(ALIAS)) {                    for (final ModelNode alias : config.get(ALIAS).asList()) {                        writer.writeEmptyElement(ALIAS);                        writer.writeAttribute(NAME, alias.asString());                    }                }                if (config.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue()).isDefined()) {                    ModelNode accessLog = config.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue());                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());                    for (SimpleAttributeDefinition attr : WebAccessLogDefinition.ACCESS_LOG_ATTRIBUTES) {                        attr.marshallAsAttribute(accessLog, false, writer);                    }                    if (accessLog.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue()).isDefined()) {                        ModelNode directory = accessLog.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue());                        String name = Element.DIRECTORY.getLocalName();                        boolean startwritten = false;                        startwritten = writeAttribute(writer, WebAccessLogDirectoryDefinition.PATH, directory, startwritten,                                name);                        startwritten = writeAttribute(writer, WebAccessLogDirectoryDefinition.RELATIVE_TO, directory,                                startwritten, name);                        if (startwritten) {                            writer.writeEndElement();                        }                    }                    writer.writeEndElement();                }                if (config.hasDefined(REWRITE)) {                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {                        Property prop = rewritenode.asProperty();                        ModelNode rewrite = prop.getValue();                        writer.writeStartElement(REWRITE);                        writer.writeAttribute(NAME, prop.getName());                        WebReWriteDefinition.PATTERN.marshallAsAttribute(rewrite, false, writer);                        WebReWriteDefinition.SUBSTITUTION.marshallAsAttribute(rewrite, false, writer);                        WebReWriteDefinition.FLAGS.marshallAsAttribute(rewrite, false, writer);                        if (rewrite.hasDefined(CONDITION)) {                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {                                Property conditionProp = conditionnode.asProperty();                                ModelNode condition = conditionProp.getValue();                                writer.writeStartElement(CONDITION);                                writer.writeAttribute(NAME, conditionProp.getName());                                WebReWriteConditionDefinition.TEST.marshallAsAttribute(condition, false, writer);                                WebReWriteConditionDefinition.PATTERN.marshallAsAttribute(condition, false, writer);                                WebReWriteConditionDefinition.FLAGS.marshallAsAttribute(condition, false, writer);                                writer.writeEndElement();                            }                        }                        writer.writeEndElement();                    }                }                if (config.get(SSO_PATH.getKey(), SSO_PATH.getValue()).isDefined()) {                    final ModelNode sso;                    sso = config.get(SSO_PATH.getKey(), SSO_PATH.getValue());                    writer.writeStartElement(SSO);                    for (SimpleAttributeDefinition attr : WebSSODefinition.SSO_ATTRIBUTES) {                        attr.marshallAsAttribute(sso, false, writer);                    }                    writer.writeEndElement();                }                // End of the VIRTUAL_SERVER                writer.writeEndElement();            }            if (node.hasDefined(VALVE)) {                for (final Property valve : node.get(VALVE).asPropertyList()) {                    final ModelNode config = valve.getValue();                    writer.writeStartElement(Element.VALVE.getLocalName());                    writer.writeAttribute(NAME, valve.getName());                    for (AttributeDefinition attr : WebValveDefinition.ATTRIBUTES) {                        if (attr instanceof SimpleAttributeDefinition) {                            ((SimpleAttributeDefinition) attr).marshallAsAttribute(config, false, writer);                        }                    }                    if (config.hasDefined(PARAM)) {                        for (final Property entry : config.get(PARAM).asPropertyList()) {                            writer.writeEmptyElement(Element.PARAM.getLocalName());                            writer.writeAttribute(Attribute.PARAM_NAME.getLocalName(), entry.getName());                            writer.writeAttribute(Attribute.PARAM_VALUE.getLocalName(), entry.getValue().asString());                        }                    }                    writer.writeEndElement();                }            }        }        writer.writeEndElement();    }
@Override    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {        PathAddress address = PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, WebExtension.SUBSYSTEM_NAME));        final ModelNode subsystem = new ModelNode();        subsystem.get(OP).set(ADD);        subsystem.get(OP_ADDR).set(address.toModelNode());        final int count = reader.getAttributeCount();        for (int i = 0; i < count; i++) {            requireNoNamespaceAttribute(reader, i);            final String value = reader.getAttributeValue(i);            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            switch (attribute) {                case NATIVE:                    WebDefinition.NATIVE.parseAndSetParameter(value, subsystem, reader);                    break;                case DEFAULT_VIRTUAL_SERVER:                    WebDefinition.DEFAULT_VIRTUAL_SERVER.parseAndSetParameter(value, subsystem, reader);                    break;                case INSTANCE_ID:                    WebDefinition.INSTANCE_ID.parseAndSetParameter(value, subsystem, reader);                    break;                case DEFAULT_SESSION_TIMEOUT:                    attributeSupportedSince(Namespace.WEB_2_2, reader, i);                    WebDefinition.DEFAULT_SESSION_TIMEOUT.parseAndSetParameter(value, subsystem, reader);                    break;                default:                    throw unexpectedAttribute(reader, i);            }        }        list.add(subsystem);        boolean containerConfigDefined = false;        final Namespace namespace = Namespace.forUri(reader.getNamespaceURI());        // elements        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            switch (namespace) {                case WEB_1_0:                case WEB_1_1:                case WEB_1_2:                case WEB_1_3: {                    final Element element = Element.forName(reader.getLocalName());                    switch (element) {                        case CONTAINER_CONFIG: {                            parseContainerConfig(reader, address, list);                            containerConfigDefined = true;                            break;                        }                        case CONNECTOR: {                            parseConnector(reader, address, list);                            break;                        }                        case VIRTUAL_SERVER: {                            parseHost(reader, address, list);                            break;                        }                        default: {                            throw unexpectedElement(reader);                        }                    }                    break;                }                case WEB_1_4:                case WEB_1_5:                case WEB_2_0:                case WEB_2_1:                case WEB_2_2:                {                    final Element element = Element.forName(reader.getLocalName());                    switch (element) {                        case CONTAINER_CONFIG: {                            parseContainerConfig(reader, address, list);                            containerConfigDefined = true;                            break;                        }                        case CONNECTOR: {                            parseConnector(reader, address, list);                            break;                        }                        case VIRTUAL_SERVER: {                            parseHost(reader, address, list);                            break;                        }                        case VALVE: {                            parseValve(reader, address, list);                            break;                        }                        default: {                            throw unexpectedElement(reader);                        }                    }                    break;                }                default: {                    throw unexpectedElement(reader);                }            }        }        if (!containerConfigDefined) {            addDefaultContainerConfig(address, list);        }    }
private boolean writeAttribute(XMLExtendedStreamWriter writer, SimpleAttributeDefinition attribute, ModelNode node,                                   boolean startWriten, String origin) throws XMLStreamException {        if (attribute.isMarshallable(node, false)) {            if (!startWriten) {                startWriten = true;                writer.writeStartElement(origin);            }            attribute.marshallAsAttribute(node, false, writer);        }        return startWriten;    }
@Override    public void registerOperations(ManagementResourceRegistration registration) {        super.registerOperations(registration);        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);    }
public void start(final StartContext context) throws StartException {        final Runnable task = new Runnable() {            @Override            public void run() {                try {                    getValue().start();                    context.complete();                } catch (Throwable e) {                    context.failed(new StartException(e));                }            }        };        try {            executor.getValue().submit(task);        } catch (RejectedExecutionException e) {            task.run();        } finally {            context.asynchronous();        }    }
public OutputStream _invoke(final String opName, final InputStream in, final ResponseHandler handler) {        EjbLogger.ROOT_LOGGER.tracef("EJBObject invocation: %s", opName);        SkeletonStrategy op = methodInvokerMap.get(opName);        if (op == null) {            EjbLogger.ROOT_LOGGER.debugf("Unable to find opname '%s' valid operations:%s", opName, methodInvokerMap.keySet());            throw new BAD_OPERATION(opName);        }        final NamespaceContextSelector selector = componentView.getComponent().getNamespaceContextSelector();        final ClassLoader oldCl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        NamespaceContextSelector.pushCurrentSelector(selector);        try {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(classLoader);            org.omg.CORBA_2_3.portable.OutputStream out;            try {                Object retVal;                if (!home && opName.equals("_get_handle")) {                    retVal = new HandleImplIIOP(orb.object_to_string(_this_object()));                } else if (home && opName.equals("_get_homeHandle")) {                    retVal = homeHandle;                } else if (home && opName.equals("_get_EJBMetaData")) {                    retVal = ejbMetaData;                } else {                    Principal identityPrincipal = null;                    Principal principal = null;                    Object credential = null;                    if (this.sasCurrent != null) {                        final byte[] incomingIdentity = this.sasCurrent.get_incoming_principal_name();                        //we have an identity token, which is a trust based mechanism                        if (incomingIdentity != null && incomingIdentity.length > 0) {                            String name = new String(incomingIdentity, StandardCharsets.UTF_8);                            int domainIndex = name.indexOf('@');                            if (domainIndex > 0)                                name = name.substring(0, domainIndex);                            identityPrincipal = new NamePrincipal(name);                        }                        final byte[] incomingUsername = this.sasCurrent.get_incoming_username();                        if (incomingUsername != null && incomingUsername.length > 0) {                            final byte[] incomingPassword = this.sasCurrent.get_incoming_password();                            String name = new String(incomingUsername, StandardCharsets.UTF_8);                            int domainIndex = name.indexOf('@');                            if (domainIndex > 0) {                                name = name.substring(0, domainIndex);                            }                            principal = new NamePrincipal(name);                            credential = new String(incomingPassword, StandardCharsets.UTF_8).toCharArray();                        }                    }                    final Object[] params = op.readParams((org.omg.CORBA_2_3.portable.InputStream) in);                    if (!this.home && opName.equals("isIdentical") && params.length == 1) {                        //handle isIdentical specially                        Object val = params[0];                        retVal = val instanceof org.omg.CORBA.Object && handleIsIdentical((org.omg.CORBA.Object) val);                    } else {                        if (this.securityDomain != null) {                            // an elytron security domain is available: authenticate and authorize the client before invoking the component.                            SecurityIdentity identity = this.securityDomain.getAnonymousSecurityIdentity();                            AuthenticationConfiguration authenticationConfiguration = AuthenticationConfiguration.EMPTY;                            if (identityPrincipal != null) {                                // we have an identity token principal - check if the TLS identity, if available,                                // has permission to run as the identity token principal.                                // TODO use the TLS identity when that becomes available to us.                                // no TLS identity found, check if an initial context token was also sent. If it was,                                // authenticate the incoming username/password and check if the resulting identity has                                // permission to run as the identity token principal.                                if (principal != null) {                                    char[] password = (char[]) credential;                                    authenticationConfiguration = authenticationConfiguration.useName(principal.getName())                                            .usePassword(password);                                    SecurityIdentity authenticatedIdentity = this.authenticate(principal, password);                                    identity = authenticatedIdentity.createRunAsIdentity(identityPrincipal.getName(), true);                                } else {                                    // no TLS nor initial context token found - check if the anonymous identity has                                    // permission to run as the identity principal.                                    identity = this.securityDomain.getAnonymousSecurityIdentity().createRunAsIdentity(identityPrincipal.getName(), true);                                }                            } else if (principal != null) {                                char[] password = (char[]) credential;                                // we have an initial context token containing a username/password pair.                                authenticationConfiguration = authenticationConfiguration.useName(principal.getName())                                        .usePassword(password);                                identity = this.authenticate(principal, password);                            }                            final InterceptorContext interceptorContext = new InterceptorContext();                            this.prepareInterceptorContext(op, params, interceptorContext);                            try {                                final AuthenticationContext context = AuthenticationContext.captureCurrent().with(MatchRule.ALL.matchProtocol("iiop"), authenticationConfiguration);                                retVal = identity.runAs((PrivilegedExceptionAction<Object>) () -> context.run((PrivilegedExceptionAction<Object>) () -> this.componentView.invoke(interceptorContext)));                            } catch (PrivilegedActionException e) {                                throw e.getCause();                            }                        } else {                            // legacy security behavior: setup the security context if a SASCurrent is available and invoke the component.                            // One of the EJB security interceptors will authenticate and authorize the client.                            SecurityContext legacyContext = null;                            if (this.legacySecurityDomain != null && (identityPrincipal != null || principal != null)) {                                // we don't have any real way to establish trust in identity based auth so we just use                                // the SASCurrent as a credential, and a custom legacy login module can make a decision for us.                                final Object finalCredential = identityPrincipal != null ? this.sasCurrent : credential;                                final Principal finalPrincipal = identityPrincipal != null ? identityPrincipal : principal;                                if (WildFlySecurityManager.isChecking()) {                                    legacyContext = AccessController.doPrivileged((PrivilegedExceptionAction<SecurityContext>) () -> {                                        SecurityContext sc = SecurityContextFactory.createSecurityContext(this.legacySecurityDomain);                                        sc.getUtil().createSubjectInfo(finalPrincipal, finalCredential, null);                                        return sc;                                    });                                } else {                                    legacyContext = SecurityContextFactory.createSecurityContext(this.legacySecurityDomain);                                    legacyContext.getUtil().createSubjectInfo(finalPrincipal, finalCredential, null);                                }                            }                            if (legacyContext != null) {                                setSecurityContextOnAssociation(legacyContext);                            }                            try {                                final InterceptorContext interceptorContext = new InterceptorContext();                                if (legacyContext != null) {                                    interceptorContext.putPrivateData(SecurityContext.class, legacyContext);                                }                                prepareInterceptorContext(op, params, interceptorContext);                                retVal = this.componentView.invoke(interceptorContext);                            } finally {                                if (legacyContext != null) {                                    clearSecurityContextOnAssociation();                                }                            }                        }                    }                }                out = (org.omg.CORBA_2_3.portable.OutputStream)                        handler.createReply();                if (op.isNonVoid()) {                    op.writeRetval(out, retVal);                }            } catch (Throwable e) {                EjbLogger.ROOT_LOGGER.trace("Exception in EJBObject invocation", e);                if (e instanceof MBeanException) {                    e = ((MBeanException) e).getTargetException();                }                RmiIdlUtil.rethrowIfCorbaSystemException(e);                out = (org.omg.CORBA_2_3.portable.OutputStream)                        handler.createExceptionReply();                op.writeException(out, e);            }            return out;        } finally {            NamespaceContextSelector.popCurrentSelector();            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(oldCl);        }    }
public Object invoke(String opName,                         Object[] arguments,                         Transaction tx,                         Principal identity,                         Object credential)            throws Exception {        EjbLogger.ROOT_LOGGER.tracef("EJBObject local invocation: %s", opName);        SkeletonStrategy op = methodInvokerMap.get(opName);        if (op == null) {            throw new BAD_OPERATION(opName);        }        if (tx != null) {            transactionManager.resume(tx);        }        try {            final InterceptorContext interceptorContext = new InterceptorContext();            prepareInterceptorContext(op, arguments, interceptorContext);            return componentView.invoke(interceptorContext);        } finally {            if (tx != null) {                if (transactionManager.getStatus() != Status.STATUS_NO_TRANSACTION) {                    transactionManager.suspend();                }            }        }    }
private SecurityIdentity authenticate(final Principal principal, final char[] credential) throws Exception {        final ServerAuthenticationContext context = this.securityDomain.createNewAuthenticationContext();        final PasswordGuessEvidence evidence = new PasswordGuessEvidence(credential != null ? credential : null);        try {            context.setAuthenticationPrincipal(principal);            if (context.verifyEvidence(evidence)) {                if (context.authorize()) {                    context.succeed();                    return context.getAuthorizedIdentity();                } else {                    context.fail();                    throw new SecurityException("Authorization failed");                }            } else {                context.fail();                throw new SecurityException("Authentication failed");            }        } catch (IllegalArgumentException | IllegalStateException | RealmUnavailableException e) {            context.fail();            throw e;        } finally {            evidence.destroy();        }    }
public static MethodIntf of(final InterceptorContext invocation) {        //for timer invocations there is no view, so the methodInf is attached directly        //to the context. Otherwise we retrieve it from the invoked view        MethodIntf methodIntf = invocation.getPrivateData(MethodIntf.class);        if (methodIntf == null) {            final ComponentView componentView = invocation.getPrivateData(ComponentView.class);            if (componentView != null) {                methodIntf = componentView.getPrivateData(MethodIntf.class);            } else {                methodIntf = MethodIntf.BEAN;            }        }        return methodIntf;    }
private void setupJNDIBindings(EJBComponentDescription sessionBean, DeploymentUnit deploymentUnit) throws DeploymentUnitProcessingException {        final Collection<ViewDescription> views = sessionBean.getViews();        if (views == null || views.isEmpty()) {            EjbLogger.DEPLOYMENT_LOGGER.noJNDIBindingsForSessionBean(sessionBean.getEJBName());            return;        }        // In case of EJB bindings, appname == .ear file name/application-name set in the application.xml (if it's an .ear deployment)        // NOTE: Do NOT use the app name from the EEModuleDescription.getApplicationName() because the Java EE spec has a different and conflicting meaning for app name        // (where app name == module name in the absence of a .ear). Use EEModuleDescription.getEarApplicationName() instead        final String applicationName = sessionBean.getModuleDescription().getEarApplicationName();        final String distinctName = sessionBean.getModuleDescription().getDistinctName(); // default to empty string        final String globalJNDIBaseName = "java:global/" + (applicationName != null ? applicationName + "/" : "") + sessionBean.getModuleName() + "/" + sessionBean.getEJBName();        final String appJNDIBaseName = "java:app/" + sessionBean.getModuleName() + "/" + sessionBean.getEJBName();        final String moduleJNDIBaseName = "java:module/" + sessionBean.getEJBName();        final String remoteExportedJNDIBaseName = "java:jboss/exported/" + (applicationName != null ? applicationName + "/" : "") + sessionBean.getModuleName() + "/" + sessionBean.getEJBName();        final String ejbNamespaceBindingBaseName = "ejb:" + (applicationName != null ? applicationName : "") + "/" + sessionBean.getModuleName() + "/" + (distinctName != "" ? distinctName + "/" : "") + sessionBean.getEJBName();        // the base ServiceName which will be used to create the ServiceName(s) for each of the view bindings        final StringBuilder jndiBindingsLogMessage = new StringBuilder();        jndiBindingsLogMessage.append(System.lineSeparator()).append(System.lineSeparator());        // now create the bindings for each view under the java:global, java:app and java:module namespaces        EJBViewDescription ejbViewDescription = null;        for (ViewDescription viewDescription : views) {            ejbViewDescription = (EJBViewDescription) viewDescription;            if (appclient && ejbViewDescription.getMethodIntf() != MethodIntf.REMOTE && ejbViewDescription.getMethodIntf() != MethodIntf.HOME) {                continue;            }            if (!ejbViewDescription.hasJNDIBindings()) continue;            final String viewClassName = ejbViewDescription.getViewClassName();            // java:global bindings            final String globalJNDIName = globalJNDIBaseName + "!" + viewClassName;            registerBinding(sessionBean, viewDescription, globalJNDIName);            logBinding(jndiBindingsLogMessage, globalJNDIName);            // java:app bindings            final String appJNDIName = appJNDIBaseName + "!" + viewClassName;            registerBinding(sessionBean, viewDescription, appJNDIName);            logBinding(jndiBindingsLogMessage, appJNDIName);            // java:module bindings            final String moduleJNDIName = moduleJNDIBaseName + "!" + viewClassName;            registerBinding(sessionBean, viewDescription, moduleJNDIName);            logBinding(jndiBindingsLogMessage, moduleJNDIName);            // If it a remote or (remote) home view then bind the java:jboss/exported jndi names for the view            if(ejbViewDescription.getMethodIntf() == MethodIntf.REMOTE || ejbViewDescription.getMethodIntf() == MethodIntf.HOME) {                final String remoteJNDIName = remoteExportedJNDIBaseName + "!" + viewClassName;                if(RequestControllerActivationMarker.isRequestControllerEnabled(deploymentUnit)) {                    registerControlPointBinding(sessionBean, viewDescription, remoteJNDIName, deploymentUnit);                } else {                    registerBinding(sessionBean, viewDescription, remoteJNDIName);                }                logBinding(jndiBindingsLogMessage, remoteJNDIName);            }            // log EJB's ejb:/ namespace binding            final String ejbNamespaceBindingName = sessionBean.isStateful() ? ejbNamespaceBindingBaseName + "!" + viewClassName + "?stateful" : ejbNamespaceBindingBaseName + "!" + viewClassName;            logBinding(jndiBindingsLogMessage, ejbNamespaceBindingName);        }        // EJB3.1 spec, section 4.4.1 Global JNDI Access states:        // In addition to the previous requirements, if the bean exposes only one of the        // applicable client interfaces(or alternatively has only a no-interface view), the container        // registers an entry for that view with the following syntax :        //        // java:global[/<app-name>]/<module-name>/<bean-name>        //        // Note that this also applies to java:app and java:module bindings        // as can be seen by the examples in 4.4.2.1        if (views.size() == 1) {            final EJBViewDescription viewDescription = (EJBViewDescription) views.iterator().next();            if (ejbViewDescription.hasJNDIBindings()) {                // java:global binding                registerBinding(sessionBean, viewDescription, globalJNDIBaseName);                logBinding(jndiBindingsLogMessage, globalJNDIBaseName);                // java:app binding                registerBinding(sessionBean, viewDescription, appJNDIBaseName);                logBinding(jndiBindingsLogMessage, appJNDIBaseName);                // java:module binding                registerBinding(sessionBean, viewDescription, moduleJNDIBaseName);                logBinding(jndiBindingsLogMessage, moduleJNDIBaseName);            }        }        // log the jndi bindings        EjbLogger.DEPLOYMENT_LOGGER.jndiBindings(sessionBean.getEJBName(), deploymentUnit, jndiBindingsLogMessage);    }
public SessionID createSessionRemote() {        ControlPoint controlPoint = getControlPoint();        if(controlPoint == null) {            return createSession();        } else {            try {                RunResult result = controlPoint.beginRequest();                if (result == RunResult.REJECTED) {                    throw EjbLogger.ROOT_LOGGER.containerSuspended();                }                try {                    return createSession();                } finally {                    controlPoint.requestComplete();                }            } catch (EJBComponentUnavailableException | ComponentIsStoppedException e) {                throw e;            } catch (Exception e) {                throw new EJBException(e);            }        }    }
private String inferDestinationName(String address) {        if (address.startsWith(JMS_QUEUE_PREFIX)) {            return address.substring(JMS_QUEUE_PREFIX.length());        } else if (address.startsWith(JMS_TOPIC_PREFIX)) {            return address.substring(JMS_TOPIC_PREFIX.length());        } else {            return address;        }    }
@Override    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        AbstractSecurityDeployer<?> deployer = null;        if (DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {            deployer = new EarSecurityDeployer();            JaccService<?> service = deployer.deploy(deploymentUnit);            if (service != null) {                final ServiceName jaccServiceName = deploymentUnit.getServiceName().append(JaccService.SERVICE_NAME);                final ServiceTarget serviceTarget = phaseContext.getServiceTarget();                ServiceBuilder<?> builder = serviceTarget.addService(jaccServiceName, service);                if (deploymentUnit.getParent() != null) {                    // add dependency to parent policy                    final DeploymentUnit parentDU = deploymentUnit.getParent();                    builder.addDependency(parentDU.getServiceName().append(JaccService.SERVICE_NAME), PolicyConfiguration.class,                            service.getParentPolicyInjector());                }                builder.setInitialMode(Mode.ACTIVE).install();            }        }    }
@Override    public void undeploy(DeploymentUnit context) {        AbstractSecurityDeployer<?> deployer = null;        if (DeploymentTypeMarker.isType(DeploymentType.EAR, context)) {            deployer = new EarSecurityDeployer();            deployer.undeploy(context);        }    }
public synchronized void start(final StartContext context) throws StartException {        final JMSServerManager jmsManager = jmsServer.getValue();        final Runnable task = new Runnable() {            @Override            public void run() {                try {                    jmsManager.createConnectionFactory(false, configuration, configuration.getBindings());                    context.complete();                } catch (Throwable e) {                    context.failed(MessagingLogger.ROOT_LOGGER.failedToCreate(e, "connection-factory"));                }            }        };        try {            executorInjector.getValue().execute(task);        } catch (RejectedExecutionException e) {            task.run();        } finally {            context.asynchronous();        }    }
public synchronized void stop(final StopContext context) {        final JMSServerManager jmsManager = jmsServer.getValue();        final Runnable task = new Runnable() {            @Override            public void run() {                try {                    jmsManager.destroyConnectionFactory(name);                } catch (Throwable e) {                    MessagingLogger.ROOT_LOGGER.failedToDestroy("connection-factory", name);                }                context.complete();            }        };        // JMS Server Manager uses locking which waits on service completion, use async to prevent starvation        try {            executorInjector.getValue().execute(task);        } catch (RejectedExecutionException e) {            task.run();        } finally {            context.asynchronous();        }    }
protected void endTransaction(final Transaction tx) {        ContextTransactionManager tm = ContextTransactionManager.getInstance();        try {            if (! tx.equals(tm.getTransaction())) {                throw EjbLogger.ROOT_LOGGER.wrongTxOnThread(tx, tm.getTransaction());            }            final int txStatus = tx.getStatus();            if (txStatus == Status.STATUS_ACTIVE) {                // Commit tx                // This will happen if                // a) everything goes well                // b) app. exception was thrown                tm.commit();            } else if (txStatus == Status.STATUS_MARKED_ROLLBACK) {                tm.rollback();            } else if (txStatus == Status.STATUS_ROLLEDBACK || txStatus == Status.STATUS_ROLLING_BACK) {                // handle reaper canceled (rolled back) tx case (see WFLY-1346)                // clear current tx state and throw RollbackException (EJBTransactionRolledbackException)                tm.rollback();                throw EjbLogger.ROOT_LOGGER.transactionAlreadyRolledBack(tx);            } else if (txStatus == Status.STATUS_UNKNOWN) {                // STATUS_UNKNOWN isn't expected to be reached here but if it does, we need to clear current thread tx.                // It is possible that calling tm.commit() could succeed but we call tm.rollback, since this is an unexpected                // tx state that are are handling.                tm.rollback();                // if the tm.rollback doesn't fail, we throw an EJBException to reflect the unexpected tx state.                throw EjbLogger.ROOT_LOGGER.transactionInUnexpectedState(tx, statusAsString(txStatus));            } else {                // logically, all of the following (unexpected) tx states are handled here:                //  Status.STATUS_PREPARED                //  Status.STATUS_PREPARING                //  Status.STATUS_COMMITTING                //  Status.STATUS_NO_TRANSACTION                //  Status.STATUS_COMMITTED                tm.suspend();                       // clear current tx state and throw EJBException                throw EjbLogger.ROOT_LOGGER.transactionInUnexpectedState(tx, statusAsString(txStatus));            }        } catch (RollbackException e) {            throw new EJBTransactionRolledbackException(e.toString(), e);        } catch (HeuristicMixedException | SystemException | HeuristicRollbackException e) {            throw new EJBException(e);        }    }
protected void setRollbackOnly(Transaction tx, final Throwable t) {        try {            tx.setRollbackOnly();        } catch (Throwable t2) {            EjbLogger.ROOT_LOGGER.failedToSetRollbackOnly(t2);            if (t != null) {                t.addSuppressed(t2);            }        }    }
private boolean isMetricEnabled(Class metricClass) {        for (LoadMetric enabledMetric : enabledMetrics) {            if (metricClass.isInstance(enabledMetric)) {                return true;            }        }        return false;    }
public void registerEndpointHandlers(final String endpointClass, final Set<String> endpointHandlers) {        if ((endpointClass == null) || (endpointHandlers == null)) {            throw new IllegalArgumentException();        }        endpointHandlersMap.put(endpointClass, Collections.unmodifiableSet(endpointHandlers));    }
@SuppressWarnings("deprecation")    private static void registerPassivationStoreTransformers_1_2_1_and_1_3_0(ResourceTransformationDescriptionBuilder parent) {        ResourceTransformationDescriptionBuilder child = parent.addChildRedirection(PassivationStoreResourceDefinition.INSTANCE.getPathElement(), PathElement.pathElement(EJB3SubsystemModel.CLUSTER_PASSIVATION_STORE));        child.getAttributeBuilder()                .setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode(true), true), EJB3SubsystemModel.PASSIVATE_EVENTS_ON_REPLICATE)                .setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode("default"), true), EJB3SubsystemModel.CLIENT_MAPPINGS_CACHE)                .setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode().set(Long.valueOf(Integer.MAX_VALUE)), true), EJB3SubsystemModel.IDLE_TIMEOUT)                .setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode().set(TimeUnit.SECONDS.name()), true), EJB3SubsystemModel.IDLE_TIMEOUT_UNIT)        ;    }
private Policy[] createPolicies(POA poa) {        List<Policy> policies = new ArrayList<Policy>();        if(this.sslOnly)            policies.add(ZeroPortPolicy.getPolicy());        if (this.idAssignmentPolicyValue != null)            policies.add(poa.create_id_assignment_policy(this.idAssignmentPolicyValue));        if (this.idUniquenessPolicyValue != null)            policies.add(poa.create_id_uniqueness_policy(this.idUniquenessPolicyValue));        if (this.implicitActivationPolicyValue != null)            policies.add(poa.create_implicit_activation_policy(this.implicitActivationPolicyValue));        if (this.lifespanPolicyValue != null)            policies.add(poa.create_lifespan_policy(this.lifespanPolicyValue));        if (this.requestProcessingPolicyValue != null)            policies.add(poa.create_request_processing_policy(this.requestProcessingPolicyValue));        if (this.servantRetentionPolicyValue != null)            policies.add(poa.create_servant_retention_policy(this.servantRetentionPolicyValue));        if (this.threadPolicyValue != null)            policies.add(poa.create_thread_policy(this.threadPolicyValue));        return policies.toArray(new Policy[policies.size()]);    }
private static void generateMethodCode(ClassFile asm,                                           Class<?> superclass,                                           Method m,                                           String idlName,                                           String strategyField,                                           String initMethod) {        Class<?> returnType = m.getReturnType();        Class<?>[] paramTypes = m.getParameterTypes();        Class<?>[] exceptions = m.getExceptionTypes();        // Generate a static field with the StubStrategy for the method        asm.addField(Modifier.PRIVATE + Modifier.STATIC, strategyField, StubStrategy.class);        // Generate the method code        final CodeAttribute ca = asm.addMethod(m).getCodeAttribute();        // The method code issues a call        // super.invoke*(idlName, strategyField, args)        ca.aload(0);        ca.ldc(idlName);        ca.getstatic(asm.getName(), strategyField, StubStrategy.class);        // Push args        if (paramTypes.length == 0) {            ca.iconst(0);            ca.anewarray(Object.class.getName());            //asm.pushField(Util.class, "NOARGS");        } else {            ca.iconst(paramTypes.length);            ca.anewarray(Object.class.getName());            int index = 1;            for (int j = 0; j < paramTypes.length; j++) {                Class<?> type = paramTypes[j];                ca.dup();                ca.iconst(j);                if (!type.isPrimitive()) {                    // object or array                    ca.aload(index);                } else if (type.equals(double.class)) {                    ca.dload(index);                    Boxing.boxDouble(ca);                    index++;                } else if (type.equals(long.class)) {                    ca.lload(index);                    Boxing.boxLong(ca);                    index++;                } else if (type.equals(float.class)) {                    ca.fload(index);                    Boxing.boxFloat(ca);                } else {                    ca.iload(index);                    Boxing.boxIfNessesary(ca, DescriptorUtils.makeDescriptor(type));                }                index++;                ca.aastore();            }        }        // Generate the call to an invoke* method ot the superclass        String invoke = "invoke";        String ret = "Ljava/lang/Object;";        if (returnType.isPrimitive() && returnType != Void.TYPE) {            String typeName = returnType.getName();            invoke += (Character.toUpperCase(typeName.charAt(0))                    + typeName.substring(1));            ret = DescriptorUtils.makeDescriptor(returnType);        }        ca.invokevirtual(superclass.getName(), invoke, "(Ljava/lang/String;Lorg/wildfly/iiop/openjdk/rmi/marshal/strategy/StubStrategy;[Ljava/lang/Object;)" + ret);        if (!returnType.isPrimitive() && returnType != Object.class) {            ca.checkcast(returnType);        }        ca.returnInstruction();        // Generate a static method that initializes the method's strategy field        final CodeAttribute init = asm.addMethod(Modifier.PRIVATE + Modifier.STATIC,initMethod, "V").getCodeAttribute();            int i;            int len;            // Push first argument for StubStrategy constructor:            // array with abbreviated names of the param marshallers            len = paramTypes.length;            init.iconst(len);            init.anewarray(String.class.getName());            for (i = 0; i < len; i++) {                init.dup();                init.iconst(i);                init.ldc(CDRStream.abbrevFor(paramTypes[i]));                init.aastore();            }            // Push second argument for StubStrategy constructor:            // array with exception repository ids            len = exceptions.length;            int n = 0;            for (i = 0; i < len; i++) {                if (!RemoteException.class.isAssignableFrom(exceptions[i])) {                    n++;                }            }            init.iconst(n);            init.anewarray(String.class.getName());            try {                int j = 0;                for (i = 0; i < len; i++) {                    if (!RemoteException.class.isAssignableFrom(exceptions[i])) {                        init.dup();                        init.iconst(j);                        init.ldc(                                ExceptionAnalysis.getExceptionAnalysis(exceptions[i])                                        .getExceptionRepositoryId());                        init.aastore();                        j++;                    }                }            } catch (RMIIIOPViolationException e) {                throw EjbLogger.ROOT_LOGGER.exceptionRepositoryNotFound(exceptions[i].getName(), e.getLocalizedMessage());            }            // Push third argument for StubStrategy constructor:            // array with exception class names            init.iconst(n);            init.anewarray(String.class.getName());            int j = 0;            for (i = 0; i < len; i++) {                if (!RemoteException.class.isAssignableFrom(exceptions[i])) {                    init.dup();                    init.iconst(j);                    init.ldc(exceptions[i].getName());                    init.aastore();                    j++;                }            }            // Push fourth argument for StubStrategy constructor:            // abbreviated name of the return value marshaller            init.ldc(CDRStream.abbrevFor(returnType));            // Push fifth argument for StubStrategy constructor:            // null (no ClassLoader specified)            init.aconstNull();            // Constructs the StubStrategy            init.invokestatic(StubStrategy.class.getName(), "forMethod", "([Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)Lorg/wildfly/iiop/openjdk/rmi/marshal/strategy/StubStrategy;");            // Set the strategy field of this stub class            init.putstatic(asm.getName(), strategyField, StubStrategy.class);            init.returnInstruction();    }
private static ClassFile generateCode(InterfaceAnalysis interfaceAnalysis,                                       Class<?> superclass, String stubClassName) {        final ClassFile asm =                new ClassFile(stubClassName, superclass.getName(), null, ModuleClassFactory.INSTANCE, interfaceAnalysis.getCls().getName());        int methodIndex = 0;        AttributeAnalysis[] attrs = interfaceAnalysis.getAttributes();        for (int i = 0; i < attrs.length; i++) {            OperationAnalysis op = attrs[i].getAccessorAnalysis();            generateMethodCode(asm, superclass, op.getMethod(), op.getIDLName(),                    strategy(methodIndex), init(methodIndex));            methodIndex++;            op = attrs[i].getMutatorAnalysis();            if (op != null) {                generateMethodCode(asm, superclass,                        op.getMethod(), op.getIDLName(),                        strategy(methodIndex), init(methodIndex));                methodIndex++;            }        }        final OperationAnalysis[] ops = interfaceAnalysis.getOperations();        for (int i = 0; i < ops.length; i++) {            generateMethodCode(asm, superclass,                    ops[i].getMethod(), ops[i].getIDLName(),                    strategy(methodIndex), init(methodIndex));            methodIndex++;        }        // Generate the constructor        final ClassMethod ctor = asm.addMethod(Modifier.PUBLIC, "<init>", "V");        ctor.getCodeAttribute().aload(0);        ctor.getCodeAttribute().invokespecial(superclass.getName(), "<init>", "()V");        ctor.getCodeAttribute().returnInstruction();        // Generate the method _ids(), declared as abstract in ObjectImpl        final String[] ids = interfaceAnalysis.getAllTypeIds();        asm.addField(Modifier.PRIVATE + Modifier.STATIC, ID_FIELD_NAME, String[].class);        final CodeAttribute idMethod = asm.addMethod(Modifier.PUBLIC + Modifier.FINAL, "_ids", "[Ljava/lang/String;").getCodeAttribute();        idMethod.getstatic(stubClassName, ID_FIELD_NAME, "[Ljava/lang/String;");        idMethod.returnInstruction();        // Generate the static initializer        final CodeAttribute clinit = asm.addMethod(Modifier.STATIC, "<clinit>", "V").getCodeAttribute();        clinit.iconst(ids.length);        clinit.anewarray(String.class.getName());        for (int i = 0; i < ids.length; i++) {            clinit.dup();            clinit.iconst(i);            clinit.ldc(ids[i]);            clinit.aastore();        }        clinit.putstatic(stubClassName, ID_FIELD_NAME, "[Ljava/lang/String;");        int n = methodIndex; // last methodIndex + 1        for (methodIndex = 0; methodIndex < n; methodIndex++) {            clinit.invokestatic(stubClassName, init(methodIndex), "()V");        }        clinit.returnInstruction();        return asm;    }
private static ClassFile makeCode(InterfaceAnalysis interfaceAnalysis,                                   Class<?> superclass, String stubClassName) {        ClassFile code = generateCode(interfaceAnalysis, superclass, stubClassName);        //try {        //   String fname = stubClassName;        //   fname = fname.substring(1 + fname.lastIndexOf('.')) + ".class";        //   fname = "/tmp/" + fname;        //   java.io.OutputStream cf = new java.io.FileOutputStream(fname);        //   cf.write(code);        //   cf.close();        //   System.err.println("wrote " + fname);        //}        //catch(java.io.IOException ee) {        //}        return code;    }
public static ClassFile compile(Class<?> intf, String stubClassName) {        InterfaceAnalysis interfaceAnalysis = null;        try {            interfaceAnalysis = InterfaceAnalysis.getInterfaceAnalysis(intf);        } catch (RMIIIOPViolationException e) {            throw EjbLogger.ROOT_LOGGER.rmiIiopVoliation(e.getLocalizedMessage());        }        return makeCode(interfaceAnalysis, DynamicIIOPStub.class, stubClassName);    }
public static WildFlyJobXmlResolver forDeployment(final DeploymentUnit deploymentUnit) throws DeploymentUnitProcessingException {        // If this deployment unit already has a resolver, just use it        if (deploymentUnit.hasAttachment(BatchAttachments.JOB_XML_RESOLVER)) {            return deploymentUnit.getAttachment(BatchAttachments.JOB_XML_RESOLVER);        }        // Get the module for it's class loader        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);        final ClassLoader classLoader = module.getClassLoader();        WildFlyJobXmlResolver resolver;        // If we're an EAR we need to skip sub-deployments as they'll be process later, however all sub-deployments have        // access to the EAR/lib directory so those resources need to be processed        if (DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {            // Create a new WildFlyJobXmlResolver without jobs from sub-deployments as they'll be processed later            final List<ResourceRoot> resources = new ArrayList<>();            for (ResourceRoot r : deploymentUnit.getAttachmentList(Attachments.RESOURCE_ROOTS)) {                if (! SubDeploymentMarker.isSubDeployment(r)) {                    resources.add(r);                }            }            resolver = create(classLoader, resources);            deploymentUnit.putAttachment(BatchAttachments.JOB_XML_RESOLVER, resolver);        } else {            // Create a new resolver for this deployment            if (deploymentUnit.hasAttachment(Attachments.RESOURCE_ROOTS)) {                resolver = create(classLoader, deploymentUnit.getAttachmentList(Attachments.RESOURCE_ROOTS));            } else {                resolver = create(classLoader, Collections.singletonList(deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT)));            }            deploymentUnit.putAttachment(BatchAttachments.JOB_XML_RESOLVER, resolver);            // Process all accessible sub-deployments            final List<DeploymentUnit> accessibleDeployments = deploymentUnit.getAttachmentList(Attachments.ACCESSIBLE_SUB_DEPLOYMENTS);            for (DeploymentUnit subDeployment : accessibleDeployments) {                // Skip our self                if (deploymentUnit.equals(subDeployment)) {                    continue;                }                if (subDeployment.hasAttachment(BatchAttachments.JOB_XML_RESOLVER)) {                    final WildFlyJobXmlResolver toCopy = subDeployment.getAttachment(BatchAttachments.JOB_XML_RESOLVER);                    WildFlyJobXmlResolver.merge(resolver, toCopy);                } else {                    // We need to create a resolver for the sub-deployment and merge the two                    final WildFlyJobXmlResolver toCopy = forDeployment(subDeployment);                    subDeployment.putAttachment(BatchAttachments.JOB_XML_RESOLVER, toCopy);                    WildFlyJobXmlResolver.merge(resolver, toCopy);                }            }        }        return resolver;    }
Set<String> getJobXmlNames(final String jobName) {        if (jobNames.containsKey(jobName)) {            return Collections.unmodifiableSet(jobNames.get(jobName));        }        return Collections.emptySet();    }
private void init(final ClassLoader classLoader) {        // Load the user defined resolvers        for (JobXmlResolver resolver : ServiceLoader.load(JobXmlResolver.class, classLoader)) {            jobXmlResolvers.add(resolver);            for (String jobXml : resolver.getJobXmlNames(classLoader)) {                addJob(jobXml, resolver.resolveJobName(jobXml, classLoader));            }        }        // Load the default names        for (Map.Entry<String, VirtualFile> entry : jobXmlFiles.entrySet()) {            try {                // Parsing the entire job XML seems excessive to just get the job name. There are two reasons for this:                //  1) If an error occurs during parsing there's no real need to consider this a valid job                //  2) Using the implementation parser seems less error prone for future-proofing                final Job job = JobParser.parseJob(entry.getValue().openStream(), classLoader, new XMLResolver() {                    // this is essentially what JBeret does, but it's ugly. JBeret might need an API to handle this                    @Override                    public Object resolveEntity(final String publicID, final String systemID, final String baseURI, final String namespace) throws XMLStreamException {                        try {                            return (jobXmlFiles.containsKey(systemID) ? jobXmlFiles.get(systemID).openStream() : null);                        } catch (IOException e) {                            throw new XMLStreamException(e);                        }                    }                });                addJob(entry.getKey(), job.getId());            } catch (XMLStreamException | IOException e) {                // Report the possible error as we don't want to fail the deployment. The job may never be run.                BatchLogger.LOGGER.invalidJobXmlFile(entry.getKey());            }        }    }
protected String requestURI(HttpServerExchange request) {        String uri = request.getRelativePath();        if (uri == null || uri.equals("/")) {            uri = "";        }        return uri;    }
public static ResolveResult createUsingURL(String url, Hashtable env)            throws NamingException {        CNCtx ctx = new CNCtx();        if (env != null) {            env = (Hashtable) env.clone();        }        ctx._env = env;        String rest = ctx.initUsingUrl(env != null ? (org.omg.CORBA.ORB) env.get("java.naming.corba.orb") : null,                url, env);        // rest is the INS name        // Return the parsed form to prevent subsequent lookup        // from parsing the string as a composite name        // The caller should be aware that a toString() of the name        // will yield its INS syntax, rather than a composite syntax        return new ResolveResult(ctx, parser.parse(rest));    }
private void initOrbAndRootContext(Hashtable env) throws NamingException {        org.omg.CORBA.ORB inOrb = null;        String ncIor = null;        if (env != null) {            inOrb = (org.omg.CORBA.ORB) env.get("java.naming.corba.orb");        }        // Extract PROVIDER_URL from environment        String provUrl = null;        if (env != null) {            provUrl = (String) env.get(javax.naming.Context.PROVIDER_URL);        }        if (provUrl != null && !isCorbaUrl(provUrl)) {            // Initialize the root naming context by using the IOR supplied            // in the PROVIDER_URL            ncIor = getStringifiedIor(provUrl);            if (inOrb == null) {                // no ORB instance specified; create one using env and defaults                inOrb = CorbaORBService.getCurrent();            }            setOrbAndRootContext(inOrb, ncIor);        } else if (provUrl != null) {            // Initialize the root naming context by using the URL supplied            // in the PROVIDER_URL            String insName = initUsingUrl(inOrb, provUrl, env);            // If name supplied in URL, resolve it to a NamingContext            if (insName.length() > 0) {                _name = parser.nameToCosName(parser.parse(insName));                try {                    org.omg.CORBA.Object obj = _nc.resolve(_name);                    _nc = NamingContextHelper.narrow(obj);                    if (_nc == null) {                        throw IIOPLogger.ROOT_LOGGER.notANamingContext(insName);                    }                } catch (org.omg.CORBA.BAD_PARAM e) {                    throw IIOPLogger.ROOT_LOGGER.notANamingContext(insName);                } catch (Exception e) {                    throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, _name);                }            }        } else {            // No PROVIDER_URL supplied; initialize using defaults            if (inOrb == null) {                // No ORB instance specified; create one using env and defaults                inOrb = CorbaORBService.getCurrent();                IIOPLogger.ROOT_LOGGER.debugf("Getting default ORB %s", inOrb);            }            setOrbAndRootContext(inOrb, (String) null);        }    }
private String initUsingIiopUrl(ORB defOrb, String url, Hashtable env)            throws NamingException {        try {            IiopUrl parsedUrl = new IiopUrl(url);            Vector addrs = parsedUrl.getAddresses();            IiopUrl.Address addr;            NamingException savedException = null;            for (int i = 0; i < addrs.size(); i++) {                addr = (IiopUrl.Address) addrs.elementAt(i);                try {                    if (defOrb != null) {                        try {                            String tmpUrl = "corbaloc:iiop:" + addr.host + ":" + addr.port + "/NameService";                            org.omg.CORBA.Object rootCtx = defOrb.string_to_object(tmpUrl);                            setOrbAndRootContext(defOrb, rootCtx);                            return parsedUrl.getStringName();                        } catch (Exception e) {                        } // keep going                    }                    // Get ORB                    ORB orb = CorbaUtils.getOrb(addr.host, addr.port, env);                    // Assign to fields                    setOrbAndRootContext(orb, (String) null);                    return parsedUrl.getStringName();                } catch (NamingException ne) {                    savedException = ne;                }            }            if (savedException != null) {                throw savedException;            } else {                throw IIOPLogger.ROOT_LOGGER.invalidURLOrIOR(url);            }        } catch (MalformedURLException e) {            throw new ConfigurationException(e.getMessage());        }    }
private String initUsingCorbanameUrl(ORB orb, String url, Hashtable env)            throws NamingException {        try {            org.wildfly.iiop.openjdk.naming.jndi.CorbanameUrl parsedUrl = new org.wildfly.iiop.openjdk.naming.jndi.CorbanameUrl(url);            String corbaloc = parsedUrl.getLocation();            String cosName = parsedUrl.getStringName();            if (orb == null) {                // No ORB instance specified; create one using env and defaults                orb = CorbaORBService.getCurrent();            }            setOrbAndRootContext(orb, corbaloc);            return parsedUrl.getStringName();        } catch (MalformedURLException e) {            throw new ConfigurationException(e.getMessage());        }    }
java.lang.Object callResolve(NameComponent[] path)            throws NamingException {        try {            org.omg.CORBA.Object obj = _nc.resolve(path);            try {                NamingContext nc = NamingContextHelper.narrow(obj);                if (nc != null) {                    return new CNCtx(_orb, nc, _env, makeFullName(path));                } else {                    return obj;                }            } catch (org.omg.CORBA.SystemException e) {                return obj;            }        } catch (Exception e) {            throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);        }    }
public java.lang.Object lookup(String name) throws NamingException {        return lookup(new CompositeName(name));    }
public java.lang.Object lookup(Name name)            throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());        if (name.size() == 0)            return this; // %%% should clone() so that env can be changed        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);        try {            java.lang.Object answer = callResolve(path);            try {                return NamingManager.getObjectInstance(answer, name, this, _env);            } catch (NamingException e) {                throw e;            } catch (Exception e) {                NamingException ne = IIOPLogger.ROOT_LOGGER.errorGeneratingObjectViaFactory();                ne.setRootCause(e);                throw ne;            }        } catch (CannotProceedException cpe) {            javax.naming.Context cctx = getContinuationContext(cpe);            return cctx.lookup(cpe.getRemainingName());        }    }
private void callBindOrRebind(NameComponent[] pth, Name name,                                  java.lang.Object obj, boolean rebind) throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());        try {            // Call state factories to convert            obj = NamingManager.getStateToBind(obj, name, this, _env);            if (obj instanceof CNCtx) {                // Use naming context object reference                obj = ((CNCtx) obj)._nc;            }            if (obj instanceof org.omg.CosNaming.NamingContext) {                NamingContext nobj = NamingContextHelper.narrow((org.omg.CORBA.Object) obj);                if (rebind)                    _nc.rebind_context(pth, nobj);                else                    _nc.bind_context(pth, nobj);            } else if (obj instanceof org.omg.CORBA.Object) {                if (rebind)                    _nc.rebind(pth, (org.omg.CORBA.Object) obj);                else                    _nc.bind(pth, (org.omg.CORBA.Object) obj);            } else                throw IIOPLogger.ROOT_LOGGER.notACorbaObject();        } catch (BAD_PARAM e) {            // probably narrow() failed?            NamingException ne = new NotContextException(name.toString());            ne.setRootCause(e);            throw ne;        } catch (Exception e) {            throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, pth);        }    }
public void bind(Name name, java.lang.Object obj)            throws NamingException {        if (name.size() == 0) {            throw IIOPLogger.ROOT_LOGGER.invalidEmptyName();        }        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);        try {            callBindOrRebind(path, name, obj, false);        } catch (CannotProceedException e) {            javax.naming.Context cctx = getContinuationContext(e);            cctx.bind(e.getRemainingName(), obj);        }    }
public void bind(String name, java.lang.Object obj) throws NamingException {        bind(new CompositeName(name), obj);    }
private void callUnbind(NameComponent[] path) throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(path.toString());        try {            _nc.unbind(path);        } catch (NotFound e) {            // If leaf is the one missing, return success            // as per JNDI spec            if (leafNotFound(e, path[path.length - 1])) {                // do nothing            } else {                throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);            }        } catch (Exception e) {            throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);        }    }
public void unbind(Name name)            throws NamingException {        if (name.size() == 0)            throw IIOPLogger.ROOT_LOGGER.invalidEmptyName();        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);        try {            callUnbind(path);        } catch (CannotProceedException e) {            javax.naming.Context cctx = getContinuationContext(e);            cctx.unbind(e.getRemainingName());        }    }
public void rename(String oldName, String newName)            throws NamingException {        rename(new CompositeName(oldName), new CompositeName(newName));    }
public void rename(Name oldName, Name newName)            throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(oldName.toString());        if (oldName.size() == 0 || newName.size() == 0)            throw IIOPLogger.ROOT_LOGGER.invalidEmptyName();        java.lang.Object obj = lookup(oldName);        bind(newName, obj);        unbind(oldName);    }
public NamingEnumeration listBindings(Name name)            throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());        if (name.size() > 0) {            try {                java.lang.Object obj = lookup(name);                if (obj instanceof CNCtx) {                    return new org.wildfly.iiop.openjdk.naming.jndi.CNBindingEnumeration(                            (CNCtx) obj, true, _env);                } else {                    throw new NotContextException(name.toString());                }            } catch (NamingException ne) {                throw ne;            } catch (BAD_PARAM e) {                NamingException ne =                        new NotContextException(name.toString());                ne.setRootCause(e);                throw ne;            }        }        return new org.wildfly.iiop.openjdk.naming.jndi.CNBindingEnumeration(this, false, _env);    }
private void callDestroy(NamingContext nc)            throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(nc.toString());        try {            nc.destroy();        } catch (Exception e) {            throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, null);        }    }
public void destroySubcontext(Name name)            throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());        NamingContext the_nc = _nc;        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);        if (name.size() > 0) {            try {                javax.naming.Context ctx =                        (javax.naming.Context) callResolve(path);                CNCtx cnc = (CNCtx) ctx;                the_nc = cnc._nc;                cnc.close(); //remove the reference to the context            } catch (ClassCastException e) {                throw new NotContextException(name.toString());            } catch (CannotProceedException e) {                javax.naming.Context cctx = getContinuationContext(e);                cctx.destroySubcontext(e.getRemainingName());                return;            } catch (NameNotFoundException e) {                // If leaf is the one missing, return success                // as per JNDI spec                if (e.getRootCause() instanceof NotFound &&                        leafNotFound((NotFound) e.getRootCause(),                                path[path.length - 1])) {                    return; // leaf missing OK                }                throw e;            } catch (NamingException e) {                throw e;            }        }        callDestroy(the_nc);        callUnbind(path);    }
private javax.naming.Context callBindNewContext(NameComponent[] path)            throws NamingException {        if (_nc == null)            throw IIOPLogger.ROOT_LOGGER.notANamingContext(path.toString());        try {            NamingContext nctx = _nc.bind_new_context(path);            return new CNCtx(_orb, nctx, _env, makeFullName(path));        } catch (Exception e) {            throw org.wildfly.iiop.openjdk.naming.jndi.ExceptionMapper.mapException(e, this, path);        }    }
public javax.naming.Context createSubcontext(String name)            throws NamingException {        return createSubcontext(new CompositeName(name));    }
public java.lang.Object lookupLink(String name) throws NamingException {        return lookupLink(new CompositeName(name));    }
public java.lang.Object addToEnvironment(String propName,                                             java.lang.Object propValue)            throws NamingException {        if (_env == null) {            _env = new Hashtable(7, 0.75f);        } else {            // copy-on-write            _env = (Hashtable) _env.clone();        }        return _env.put(propName, propValue);    }
public java.lang.Object removeFromEnvironment(String propName)            throws NamingException {        if (_env != null && _env.get(propName) != null) {            // copy-on-write            _env = (Hashtable) _env.clone();            return _env.remove(propName);        }        return null;    }
@SuppressWarnings("deprecation")    static void addTransformations(ModelVersion version, ResourceTransformationDescriptionBuilder builder) {        if (JGroupsModel.VERSION_5_0_0.requiresTransformation(version)) {            builder.getAttributeBuilder()                    .setDiscard(DiscardAttributeChecker.UNDEFINED, Attribute.STATISTICS_ENABLED.getDefinition())                    .addRejectCheck(RejectAttributeChecker.DEFINED, Attribute.STATISTICS_ENABLED.getDefinition())                    .end();        }        if (JGroupsModel.VERSION_3_0_0.requiresTransformation(version)) {            AttributeConverter typeConverter = new AttributeConverter.DefaultAttributeConverter() {                @Override                protected void convertAttribute(PathAddress address, String name, ModelNode value, TransformationContext context) {                    if (!value.isDefined()) {                        value.set(address.getLastElement().getValue());                    }                }            };            builder.getAttributeBuilder()                    .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(Attribute.MODULE.getDefinition().getDefaultValue()), Attribute.MODULE.getDefinition())                    .addRejectCheck(RejectAttributeChecker.DEFINED, Attribute.MODULE.getDefinition())                    .setValueConverter(typeConverter, DeprecatedAttribute.TYPE.getDefinition())                    .end();            builder.addRawOperationTransformationOverride(MapOperations.MAP_GET_DEFINITION.getName(), new SimpleOperationTransformer(new LegacyPropertyMapGetOperationTransformer()));            for (String opName : Operations.getAllWriteAttributeOperationNames()) {                builder.addOperationTransformationOverride(opName)                        .inheritResourceAttributeDefinitions()                        .setCustomOperationTransformer(new LegacyPropertyWriteOperationTransformer());            }        }        PropertyResourceDefinition.buildTransformation(version, builder);    }
@Override    protected DsSecurity parseDsSecurity(XMLStreamReader reader) throws XMLStreamException, ParserException,            ValidateException {        String userName = null;        String password = null;        String securityDomain = null;        boolean elytronEnabled = false;        String authenticationContext = null;        Extension reauthPlugin = null;        while (reader.hasNext()) {            switch (reader.nextTag()) {                case END_ELEMENT: {                    if (DataSource.Tag.forName(reader.getLocalName()) ==                            DataSource.Tag.SECURITY) {                        return new DsSecurityImpl(userName, password,elytronEnabled? authenticationContext: securityDomain,                                elytronEnabled, null, reauthPlugin);                    } else {                        if (DsSecurity.Tag.forName(reader.getLocalName()) == DsSecurity.Tag.UNKNOWN) {                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));                        }                    }                    break;                }                case START_ELEMENT: {                    DsSecurity.Tag tag = DsSecurity.Tag.forName(reader.getLocalName());                    switch (tag) {                        case PASSWORD: {                            password = elementAsString(reader);                            boolean resolved = false;                            if (propertyReplacer != null && password != null && password.trim().length() != 0) {                                String resolvedPassword = propertyReplacer.replaceProperties(password);                                if (resolvedPassword != null) {                                    password = resolvedPassword;                                    resolved = true;                                }                            }                            // Previous releases directly passed the text into PropertyResolver, which would not                            // deal properly with ${ and }, :defaultValue etc. But it would resolve e.g. "sys.prop.foo"                            // to "123" if there was a system property "sys.prop.foo". So, to avoid breaking folks                            // who learned to use that behavior, pass any unresolved password in to the PropertyResolver                            if (!resolved && propertyResolver != null && password != null && password.trim().length() != 0) {                                String resolvedPassword = propertyResolver.resolve(password);                                if (resolvedPassword != null) {                                    password = resolvedPassword;                                }                            }                            break;                        }                        case USER_NAME: {                            userName = elementAsString(reader);                            break;                        }                        case SECURITY_DOMAIN: {                            securityDomain = elementAsString(reader);                            break;                        }                        case ELYTRON_ENABLED: {                            Boolean value = elementAsBoolean(reader);                            elytronEnabled = value == null? true : value;                            break;                        }                        case AUTHENTICATION_CONTEXT: {                            authenticationContext = elementAsString(reader);                            break;                        }                        case REAUTH_PLUGIN: {                            reauthPlugin = parseExtension(reader, tag.getLocalName());                            break;                        }                        default:                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));                    }                    break;                }            }        }        throw new ParserException(bundle.unexpectedEndOfDocument());    }
@Override    protected Credential parseCredential(XMLStreamReader reader) throws XMLStreamException, ParserException,            ValidateException {        String userName = null;        String password = null;        String securityDomain = null;        boolean elytronEnabled = false;        String authenticationContext = null;        while (reader.hasNext()) {            switch (reader.nextTag()) {                case END_ELEMENT: {                    if (DataSource.Tag.forName(reader.getLocalName()) == DataSource.Tag.SECURITY ||                            Recovery.Tag.forName(reader.getLocalName()) == Recovery.Tag.RECOVER_CREDENTIAL) {                        return new CredentialImpl(userName, password, elytronEnabled? authenticationContext: securityDomain,                                elytronEnabled, null);                    } else {                        if (Credential.Tag.forName(reader.getLocalName()) == Credential.Tag.UNKNOWN) {                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));                        }                    }                    break;                }                case START_ELEMENT: {                    switch (Credential.Tag.forName(reader.getLocalName())) {                        case PASSWORD: {                            password = elementAsString(reader);                            if (propertyResolver != null && password != null) {                                String resolvedPassword = propertyResolver.resolve(password);                                if (resolvedPassword != null)                                    password = resolvedPassword;                            }                            break;                        }                        case USER_NAME: {                            userName = elementAsString(reader);                            break;                        }                        case SECURITY_DOMAIN: {                            securityDomain = elementAsString(reader);                            break;                        }                        case ELYTRON_ENABLED: {                            Boolean value = elementAsBoolean(reader);                            elytronEnabled = value == null? true : value;                            break;                        }                        case AUTHENTICATION_CONTEXT: {                            authenticationContext = elementAsString(reader);                            break;                        }                        default:                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));                    }                    break;                }            }        }        throw new ParserException(bundle.unexpectedEndOfDocument());    }
@Override    public void writeContent(final XMLExtendedStreamWriter writer, final SubsystemMarshallingContext context) throws XMLStreamException {        context.startSubsystemElement(EJB3SubsystemNamespace.EJB3_5_0.getUriString(), false);        writeElements(writer, context);        // write the subsystem end element        writer.writeEndElement();    }
private void writeMDB(final XMLExtendedStreamWriter writer, final ModelNode mdbModelNode) throws XMLStreamException {        if (mdbModelNode.hasDefined(EJB3SubsystemModel.DEFAULT_RESOURCE_ADAPTER_NAME)) {            // <resource-adapter-ref>            writer.writeStartElement(EJB3SubsystemXMLElement.RESOURCE_ADAPTER_REF.getLocalName());            final String resourceAdapterName = mdbModelNode.get(EJB3SubsystemModel.DEFAULT_RESOURCE_ADAPTER_NAME).asString();            // write the value            writer.writeAttribute(EJB3SubsystemXMLAttribute.RESOURCE_ADAPTER_NAME.getLocalName(), resourceAdapterName);            // </resource-adapter-ref>            writer.writeEndElement();        }        if (mdbModelNode.hasDefined(EJB3SubsystemModel.DEFAULT_MDB_INSTANCE_POOL)) {            // <bean-instance-pool-ref>            writer.writeStartElement(EJB3SubsystemXMLElement.BEAN_INSTANCE_POOL_REF.getLocalName());            final String poolRefName = mdbModelNode.get(EJB3SubsystemModel.DEFAULT_MDB_INSTANCE_POOL).asString();            // write the value            writer.writeAttribute(EJB3SubsystemXMLAttribute.POOL_NAME.getLocalName(), poolRefName);            // </bean-instance-pool-ref>            writer.writeEndElement();        }        if (mdbModelNode.hasDefined(EJB3SubsystemModel.MDB_DELIVERY_GROUP)) {            //<delivery-groups>            writer.writeStartElement(EJB3SubsystemXMLElement.DELIVERY_GROUPS.getLocalName());            for (Property property : mdbModelNode.get(EJB3SubsystemModel.MDB_DELIVERY_GROUP).asPropertyList()) {                // <delivery-group                writer.writeStartElement(EJB3SubsystemXMLElement.DELIVERY_GROUP.getLocalName());                // name=                writer.writeAttribute(EJB3SubsystemXMLAttribute.NAME.getLocalName(), property.getName());                // active=                MdbDeliveryGroupResourceDefinition.ACTIVE.marshallAsAttribute(mdbModelNode.get(EJB3SubsystemModel.MDB_DELIVERY_GROUP, property.getName()), writer);                // />                writer.writeEndElement();            }            //</delivery-groups>            writer.writeEndElement();        }    }
private void writeEntityBean(final XMLExtendedStreamWriter writer, final ModelNode entityModelNode) throws XMLStreamException {        if (entityModelNode.hasDefined(EJB3SubsystemModel.DEFAULT_ENTITY_BEAN_INSTANCE_POOL)) {            // <bean-instance-pool-ref>            writer.writeStartElement(EJB3SubsystemXMLElement.BEAN_INSTANCE_POOL_REF.getLocalName());            final String poolRefName = entityModelNode.get(EJB3SubsystemModel.DEFAULT_ENTITY_BEAN_INSTANCE_POOL).asString();            // write the value            writer.writeAttribute(EJB3SubsystemXMLAttribute.POOL_NAME.getLocalName(), poolRefName);            // </bean-instance-pool-ref>            writer.writeEndElement();        }        if (entityModelNode.hasDefined(EJB3SubsystemModel.DEFAULT_ENTITY_BEAN_OPTIMISTIC_LOCKING)) {            // <optimistic-locking>            writer.writeStartElement(EJB3SubsystemXMLElement.OPTIMISTIC_LOCKING.getLocalName());            final Boolean locking = entityModelNode.get(EJB3SubsystemModel.DEFAULT_ENTITY_BEAN_OPTIMISTIC_LOCKING).asBoolean();            // write the value            writer.writeAttribute(EJB3SubsystemXMLAttribute.ENABLED.getLocalName(), locking.toString());            // <optimistic-locking>            writer.writeEndElement();        }    }
private void writeClusterPassivationStores(XMLExtendedStreamWriter writer, ModelNode model) throws XMLStreamException {        if (model.hasDefined(EJB3SubsystemModel.CLUSTER_PASSIVATION_STORE)) {            List<Property> caches = model.get(EJB3SubsystemModel.CLUSTER_PASSIVATION_STORE).asPropertyList();            for (Property property : caches) {                // <strict-max-pool>                writer.writeStartElement(EJB3SubsystemXMLElement.CLUSTER_PASSIVATION_STORE.getLocalName());                ModelNode store = property.getValue();                writer.writeAttribute(EJB3SubsystemXMLAttribute.NAME.getLocalName(), property.getName());                LegacyPassivationStoreResourceDefinition.IDLE_TIMEOUT.marshallAsAttribute(store, writer);                LegacyPassivationStoreResourceDefinition.IDLE_TIMEOUT_UNIT.marshallAsAttribute(store, writer);                ClusterPassivationStoreResourceDefinition.MAX_SIZE.marshallAsAttribute(store, writer);                ClusterPassivationStoreResourceDefinition.CACHE_CONTAINER.marshallAsAttribute(store, writer);                ClusterPassivationStoreResourceDefinition.BEAN_CACHE.marshallAsAttribute(store, writer);                ClusterPassivationStoreResourceDefinition.CLIENT_MAPPINGS_CACHE.marshallAsAttribute(store, writer);                ClusterPassivationStoreResourceDefinition.PASSIVATE_EVENTS_ON_REPLICATE.marshallAsAttribute(store, writer);                writer.writeEndElement();            }        }    }
private void writeFilePassivationStores(XMLExtendedStreamWriter writer, ModelNode model) throws XMLStreamException {        if (model.hasDefined(EJB3SubsystemModel.FILE_PASSIVATION_STORE)) {            List<Property> caches = model.get(EJB3SubsystemModel.FILE_PASSIVATION_STORE).asPropertyList();            for (Property property : caches) {                // <strict-max-pool>                writer.writeStartElement(EJB3SubsystemXMLElement.FILE_PASSIVATION_STORE.getLocalName());                ModelNode store = property.getValue();                writer.writeAttribute(EJB3SubsystemXMLAttribute.NAME.getLocalName(), property.getName());                LegacyPassivationStoreResourceDefinition.IDLE_TIMEOUT.marshallAsAttribute(store, writer);                LegacyPassivationStoreResourceDefinition.IDLE_TIMEOUT_UNIT.marshallAsAttribute(store, writer);                FilePassivationStoreResourceDefinition.MAX_SIZE.marshallAsAttribute(store, writer);                FilePassivationStoreResourceDefinition.RELATIVE_TO.marshallAsAttribute(store, writer);                FilePassivationStoreResourceDefinition.GROUPS_PATH.marshallAsAttribute(store, writer);                FilePassivationStoreResourceDefinition.SESSIONS_PATH.marshallAsAttribute(store, writer);                FilePassivationStoreResourceDefinition.SUBDIRECTORY_COUNT.marshallAsAttribute(store, writer);                writer.writeEndElement();            }        }    }
public AuditManager getAuditManager(String securityDomain) {        AuditManager am = null;        try {            am = auditMgrMap.get(securityDomain);            if (am == null) {                am = (AuditManager) lookUpJNDI(securityDomain + "/auditMgr");                auditMgrMap.put(securityDomain, am);            }        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef(e, "Exception getting AuditManager for domain=%s", securityDomain);        }        return am;    }
public AuthenticationManager getAuthenticationManager(String securityDomain) {        AuthenticationManager am = null;        try {            am = authMgrMap.get(securityDomain);            if (am == null) {                am = (AuthenticationManager) lookUpJNDI(securityDomain + "/authenticationMgr");                authMgrMap.put(securityDomain, am);            }        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef(e, "Exception getting AuthenticationManager for domain=%s", securityDomain);        }        return am;    }
public AuthorizationManager getAuthorizationManager(String securityDomain) {        AuthorizationManager am = null;        try {            am = authzMgrMap.get(securityDomain);            if (am == null) {                am = (AuthorizationManager) lookUpJNDI(securityDomain + "/authorizationMgr");                authzMgrMap.put(securityDomain, am);            }        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef(e, "Exception getting AuthorizationManager for domain=%s", securityDomain);        }        return am;    }
public IdentityTrustManager getIdentityTrustManager(String securityDomain) {        IdentityTrustManager itm = null;        try {            itm = idmMgrMap.get(securityDomain);            if (itm == null) {                itm = (IdentityTrustManager) lookUpJNDI(securityDomain + "/identityTrustMgr");                idmMgrMap.put(securityDomain, itm);            }        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef(e, "Exception getting IdentityTrustManager for domain=%s" + securityDomain);        }        return itm;    }
public MappingManager getMappingManager(String securityDomain) {        MappingManager mm = null;        try {            mm = mappingMgrMap.get(securityDomain);            if (mm == null) {                mm = (MappingManager) lookUpJNDI(securityDomain + "/mappingMgr");                mappingMgrMap.put(securityDomain, mm);            }        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef(e, "Exception getting MappingManager for domain=%s", securityDomain);        }        return mm;    }
public JSSESecurityDomain getJSSE(String securityDomain) {        JSSESecurityDomain jsse = null;        try {            jsse = jsseMap.get(securityDomain);            if (jsse == null) {                jsse = (JSSESecurityDomain) lookUpJNDI(securityDomain + "/jsse");                jsseMap.put(securityDomain, jsse);            }        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef(e, "Exception getting JSSESecurityDomain for domain=%s", securityDomain);        }        return jsse;    }
public void removeSecurityDomain(String securityDomain) {        securityMgrMap.remove(securityDomain);        auditMgrMap.remove(securityDomain);        authMgrMap.remove(securityDomain);        authzMgrMap.remove(securityDomain);        idmMgrMap.remove(securityDomain);        mappingMgrMap.remove(securityDomain);        jsseMap.remove(securityDomain);    }
private Object lookUpJNDI(String contextName) {        Object result = null;        try {            Context ctx = new InitialContext();            if (contextName.startsWith(SecurityConstants.JAAS_CONTEXT_ROOT))                result = ctx.lookup(contextName);            else                result = ctx.lookup(SecurityConstants.JAAS_CONTEXT_ROOT + contextName);        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef("Look up of JNDI for %s failed with %s", contextName, e.getLocalizedMessage());            return null;        }        return result;    }
public SecurityDomainContext createSecurityDomainContext(String securityDomain, AuthenticationCacheFactory cacheFactory) throws Exception {        return createSecurityDomainContext(securityDomain, cacheFactory, null);    }
public SecurityDomainContext createSecurityDomainContext(String securityDomain,                                                                    AuthenticationCacheFactory cacheFactory,                                                                    JSSESecurityDomain jsseSecurityDomain) throws Exception {        SecurityLogger.ROOT_LOGGER.debugf("Creating SDC for domain = %s", securityDomain);        AuthenticationManager am = createAuthenticationManager(securityDomain);        if (cacheFactory != null && am instanceof CacheableManager) {            // create authentication cache            final Map<Principal, ?> cache = cacheFactory.getCache();            if (cache != null) {                @SuppressWarnings({ "unchecked", "rawtypes" })                CacheableManager<Map, Principal> cm = (CacheableManager<Map, Principal>) am;                cm.setCache(cache);            }        }        // set DeepCopySubject option if supported        if (deepCopySubjectMode) {            setDeepCopySubjectMode(am);        }        return new SecurityDomainContext(am,                createAuthorizationManager(securityDomain),                createAuditManager(securityDomain),                createIdentityTrustManager(securityDomain), createMappingManager(securityDomain),                jsseSecurityDomain);    }
private AuthenticationManager createAuthenticationManager(String securityDomain) throws Exception {        int i = callbackHandlerClassName.lastIndexOf(":");        if (i == -1)            throw SecurityLogger.ROOT_LOGGER.missingModuleName("default-callback-handler-class-name attribute");        String moduleSpec = callbackHandlerClassName.substring(0, i);        String className = callbackHandlerClassName.substring(i + 1);        Class<?> callbackHandlerClazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);        CallbackHandler ch = (CallbackHandler) callbackHandlerClazz.newInstance();        i = authenticationManagerClassName.lastIndexOf(":");        if (i == -1)            throw SecurityLogger.ROOT_LOGGER.missingModuleName("authentication-manager-class-name attribute");        moduleSpec = authenticationManagerClassName.substring(0, i);        className = authenticationManagerClassName.substring(i + 1);        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class, CallbackHandler.class });        return (AuthenticationManager) ctr.newInstance(new Object[] { securityDomain, ch });    }
private AuthorizationManager createAuthorizationManager(String securityDomain) throws Exception {        int i = authorizationManagerClassName.lastIndexOf(":");        if (i == -1)            throw SecurityLogger.ROOT_LOGGER.missingModuleName("authorization manager class");        String moduleSpec = authorizationManagerClassName.substring(0, i);        String className = authorizationManagerClassName.substring(i + 1);        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });        return (AuthorizationManager) ctr.newInstance(new Object[] { securityDomain });    }
private AuditManager createAuditManager(String securityDomain) throws Exception {        int i = auditManagerClassName.lastIndexOf(":");        if (i == -1)            throw SecurityLogger.ROOT_LOGGER.missingModuleName("audit manager class");        String moduleSpec = auditManagerClassName.substring(0, i);        String className = auditManagerClassName.substring(i + 1);        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });        return (AuditManager) ctr.newInstance(new Object[] { securityDomain });    }
private IdentityTrustManager createIdentityTrustManager(String securityDomain) throws Exception {        int i = identityTrustManagerClassName.lastIndexOf(":");        if (i == -1)            throw SecurityLogger.ROOT_LOGGER.missingModuleName("identity trust manager class");        String moduleSpec = identityTrustManagerClassName.substring(0, i);        String className = identityTrustManagerClassName.substring(i + 1);        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });        return (IdentityTrustManager) ctr.newInstance(new Object[] { securityDomain });    }
private MappingManager createMappingManager(String securityDomain) throws Exception {        int i = mappingManagerClassName.lastIndexOf(":");        if (i == -1)            throw SecurityLogger.ROOT_LOGGER.missingModuleName("mapping manager class");        String moduleSpec = mappingManagerClassName.substring(0, i);        String className = mappingManagerClassName.substring(i + 1);        Class<?> clazz = SecurityActions.getModuleClassLoader(loader, moduleSpec).loadClass(className);        Constructor<?> ctr = clazz.getConstructor(new Class[] { String.class });        return (MappingManager) ctr.newInstance(new Object[] { securityDomain });    }
private static void setDeepCopySubjectMode(AuthenticationManager authenticationManager) {        try {            Class<?>[] argsType = { Boolean.class };            Method m = authenticationManager.getClass().getMethod("setDeepCopySubjectOption", argsType);            Object[] deepCopyArgs = { Boolean.TRUE };            m.invoke(authenticationManager, deepCopyArgs);        } catch (Exception e) {            SecurityLogger.ROOT_LOGGER.tracef("Optional setDeepCopySubjectMode failed: %s", e.getLocalizedMessage());        }    }
public static ScheduleExpressionType getType(String value) {        if (value == null) {            throw EjbLogger.EJB3_TIMER_LOGGER.valueIsNull();        }        // Order of check is important.        // TODO: Explain why this order is important        if (value.trim().equals("*")) {            return ScheduleExpressionType.WILDCARD;        }        if (value.contains(",")) {            return ScheduleExpressionType.LIST;        }        if (value.contains("-") && RangeValue.accepts(value)) {            return ScheduleExpressionType.RANGE;        }        if (value.contains("/")) {            return ScheduleExpressionType.INCREMENT;        }        return ScheduleExpressionType.SINGLE_VALUE;    }
public static ModularReference create(final Class<?> type, final Class<?> factoryClass) {        return create(type.getName(), factoryClass);    }
public static ModularReference create(final String className, final Class<?> factoryClass) {        return new ModularReference(className, factoryClass.getName(), Module.forClass(factoryClass).getIdentifier());    }
public static ModularReference create(final Class<?> type, final RefAddr addr, final Class<?> factoryClass) {        return create(type.getName(), addr, factoryClass);    }
public void start(final StartContext context) {        super.start(context);        if (SarLogger.ROOT_LOGGER.isTraceEnabled()) {            SarLogger.ROOT_LOGGER.tracef("Starting Service: %s", context.getController().getName());        }        final Runnable task = new Runnable() {            @Override            public void run() {            try {                invokeLifecycleMethod(startMethod, context);                context.complete();            } catch (Throwable e) {                context.failed(new StartException(SarLogger.ROOT_LOGGER.failedExecutingLegacyMethod("start()"), e));            }            }        };        try {            executorSupplier.get().submit(task);        } catch (RejectedExecutionException e) {            task.run();        } finally {            context.asynchronous();        }    }
public void stop(final StopContext context) {        super.stop(context);        if (SarLogger.ROOT_LOGGER.isTraceEnabled()) {            SarLogger.ROOT_LOGGER.tracef("Stopping Service: %s", context.getController().getName());        }        final Runnable task = new Runnable() {            @Override            public void run() {                try {                    invokeLifecycleMethod(stopMethod, context);                } catch (Exception e) {                    SarLogger.ROOT_LOGGER.error(SarLogger.ROOT_LOGGER.failedExecutingLegacyMethod("stop()"), e);                } finally {                    context.complete();                }            }        };        try {            executorSupplier.get().submit(task);        } catch (RejectedExecutionException e) {            task.run();        } finally {            context.asynchronous();        }    }
public static void main(String[] args) {        int port = 9990;        String host = "localhost";        String protocol = "remote+http";        String config = null;        try {            CommandLine line = parser.parse(options, args, false);            if (line.hasOption("help")) {                formatter.printHelp(usage, NEW_LINE + JdrLogger.ROOT_LOGGER.jdrDescriptionMessage(), options, null);                return;            }            if (line.hasOption("host")) {                host = line.getOptionValue("host");            }            if (line.hasOption("port")) {                port = Integer.parseInt(line.getOptionValue("port"));            }            if (line.hasOption("protocol")) {                protocol = line.getOptionValue("protocol");            }            if (line.hasOption("config")) {                config = line.getOptionValue("config");            }        } catch (ParseException e) {            System.out.println(e.getMessage());            formatter.printHelp(usage, options);            return;        } catch (NumberFormatException nfe) {            System.out.println(nfe.getMessage());            formatter.printHelp(usage, options);            return;        }        System.out.println("Initializing JBoss Diagnostic Reporter...");        // Try to run JDR on the Wildfly JVM        CLI cli = CLI.newInstance();        boolean embedded = false;        JdrReport report = null;        try {            System.out.println(String.format("Trying to connect to %s %s:%s", protocol, host, port));            cli.connect(protocol, host, port, null, null);        } catch (IllegalStateException ex) {            System.out.println("Starting embedded server");            String startEmbeddedServer = "embed-server --std-out=echo " + ((config != null && ! config.isEmpty()) ? (" --server-config=" + config) : "");            cli.getCommandContext().handleSafe(startEmbeddedServer);            embedded = true;        }        try {            Result cmdResult = cli.cmd("/subsystem=jdr:generate-jdr-report()");            ModelNode response = cmdResult.getResponse();            if(Operations.isSuccessfulOutcome(response) || !embedded) {                reportFailure(response);                ModelNode result = response.get(ClientConstants.RESULT);                report = new JdrReport(result);            } else {                report = standaloneCollect(cli, protocol, host, port);            }        } catch(IllegalStateException ise) {            System.out.println(ise.getMessage());            report = standaloneCollect(cli, protocol, host, port);        } finally {            if(cli != null) {                try {                    if(embedded)                        cli.getCommandContext().handleSafe("stop-embedded-server");                    else                        cli.disconnect();                } catch(Exception e) {                    System.out.println("Caught exception while disconnecting: " + e.getMessage());                }            }        }        printJdrReportInfo(report);        System.exit(0);    }
protected void parseRemotingReceiver(final XMLExtendedStreamReader reader,            final EJBClientDescriptorMetaData ejbClientDescriptorMetaData) throws XMLStreamException {        String outboundConnectionRef = null;        final Set<EJBClientDescriptorXMLAttribute> required = EnumSet                .of(EJBClientDescriptorXMLAttribute.OUTBOUND_CONNECTION_REF);        final int count = reader.getAttributeCount();        EJBClientDescriptorMetaData.RemotingReceiverConfiguration remotingReceiverConfiguration = null;        long connectTimeout = 5000;        for (int i = 0; i < count; i++) {            final EJBClientDescriptorXMLAttribute attribute = EJBClientDescriptorXMLAttribute.forName(reader                    .getAttributeLocalName(i));            required.remove(attribute);            final String value = readResolveValue(reader, i);            switch (attribute) {                case OUTBOUND_CONNECTION_REF:                    outboundConnectionRef = value;                    remotingReceiverConfiguration = ejbClientDescriptorMetaData                            .addRemotingReceiverConnectionRef(outboundConnectionRef);                    break;                case CONNECT_TIMEOUT:                    connectTimeout = Long.parseLong(value);                    break;                default:                    unexpectedContent(reader);            }        }        if (!required.isEmpty()) {            missingAttributes(reader.getLocation(), required);        }        // set the timeout        remotingReceiverConfiguration.setConnectionTimeout(connectTimeout);        while (reader.hasNext()) {            switch (reader.nextTag()) {                case END_ELEMENT: {                    return;                }                case START_ELEMENT: {                    final EJBClientDescriptorXMLElement element = EJBClientDescriptorXMLElement.forName(reader.getLocalName());                    switch (element) {                        case CHANNEL_CREATION_OPTIONS:                            final Properties channelCreationOptions = this.parseChannelCreationOptions(reader);                            remotingReceiverConfiguration.setChannelCreationOptions(channelCreationOptions);                            break;                        default:                            unexpectedElement(reader);                    }                    break;                }                default: {                    unexpectedContent(reader);                }            }        }        unexpectedEndOfDocument(reader.getLocation());    }
static LocalIDLType getIDLType(TypeCode typeCode, RepositoryImpl repository) {        TCKind tcKind = typeCode.kind();        if (PrimitiveDefImpl.isPrimitiveTCKind(tcKind))            return new PrimitiveDefImpl(typeCode, repository);        if (tcKind == TCKind.tk_sequence)            return repository.getSequenceImpl(typeCode);        if (tcKind == TCKind.tk_value || tcKind == TCKind.tk_value_box ||                tcKind == TCKind.tk_alias || tcKind == TCKind.tk_struct ||                tcKind == TCKind.tk_union || tcKind == TCKind.tk_enum ||                tcKind == TCKind.tk_objref) {            try {                return (LocalIDLType) repository._lookup_id(typeCode.id());            } catch (BadKind ex) {                throw IIOPLogger.ROOT_LOGGER.badKindForTypeCode(tcKind.value());            }        }        throw IIOPLogger.ROOT_LOGGER.badKindForTypeCode(tcKind.value());    }
private static void waitForService(final ServiceController<?> controller) throws OperationFailedException {        if (controller.getState() == ServiceController.State.UP) return;        final StabilityMonitor monitor = new StabilityMonitor();        monitor.addController(controller);        try {            monitor.awaitStability(100, MILLISECONDS);        } catch (final InterruptedException e) {            Thread.currentThread().interrupt();            throw SecurityLogger.ROOT_LOGGER.interruptedWaitingForSecurityDomain(controller.getName().getSimpleName());        } finally {            monitor.removeController(controller);        }        if (controller.getState() != ServiceController.State.UP) {            throw SecurityLogger.ROOT_LOGGER.requiredSecurityDomainServiceNotAvailable(controller.getName().getSimpleName());        }    }
private String computeMaskedPassword() throws Exception {        // Create the PBE secret key        SecretKeyFactory factory = SecretKeyFactory.getInstance(VAULT_ENC_ALGORITHM);        char[] password = "somearbitrarycrazystringthatdoesnotmatter".toCharArray();        PBEParameterSpec cipherSpec = new PBEParameterSpec(salt.getBytes(CHARSET), iterationCount);        PBEKeySpec keySpec = new PBEKeySpec(password);        SecretKey cipherKey = factory.generateSecret(keySpec);        String maskedPass = PBEUtils.encode64(keystorePassword.getBytes(CHARSET), VAULT_ENC_ALGORITHM, cipherKey, cipherSpec);        return PicketBoxSecurityVault.PASS_MASK_PREFIX + maskedPass;    }
private void initSecurityVault() throws Exception {        try {            this.vault = SecurityVaultFactory.get();            this.vault.init(getVaultOptionsMap());            handshake();        } catch (SecurityVaultException e) {            throw SecurityLogger.ROOT_LOGGER.securityVaultException(e);        }    }
public void startVaultSession(String vaultAlias) throws Exception {        if (vaultAlias == null) {            throw SecurityLogger.ROOT_LOGGER.vaultAliasNotSpecified();        }        this.keystoreMaskedPassword = (org.jboss.security.Util.isPasswordCommand(keystorePassword))                ? keystorePassword                : computeMaskedPassword();        this.vaultAlias = vaultAlias;        initSecurityVault();    }
public String addSecuredAttribute(String vaultBlock, String attributeName, char[] attributeValue) throws Exception {        vault.store(vaultBlock, attributeName, attributeValue, null);        return securedAttributeConfigurationString(vaultBlock, attributeName);    }
public void addSecuredAttributeWithDisplay(String vaultBlock, String attributeName, char[] attributeValue) throws Exception {        vault.store(vaultBlock, attributeName, attributeValue, null);        attributeCreatedDisplay(vaultBlock, attributeName);    }
public boolean checkSecuredAttribute(String vaultBlock, String attributeName) throws Exception {        return vault.exists(vaultBlock, attributeName);    }
public boolean removeSecuredAttribute(String vaultBlock, String attributeName) throws Exception {        return vault.remove(vaultBlock, attributeName, null);    }
public char[] retrieveSecuredAttribute(String vaultBlock, String attributeName) throws Exception {        return vault.retrieve(vaultBlock, attributeName, null);    }
private void attributeCreatedDisplay(String vaultBlock, String attributeName) {        System.out.println(SecurityLogger.ROOT_LOGGER.vaultAttributeCreateDisplay(vaultBlock, attributeName, securedAttributeConfigurationString(vaultBlock, attributeName)));    }
public void vaultConfigurationDisplay() {        final String configuration = vaultConfiguration();        System.out.println(SecurityLogger.ROOT_LOGGER.vaultConfigurationTitle());        System.out.println("********************************************");        System.out.println("For standalone mode:");        System.out.println(configuration);        System.out.println("********************************************");        System.out.println("For domain mode:");        System.out.println("/host=the_host" + configuration);        System.out.println("********************************************");    }
public String vaultConfiguration() {        StringBuilder sb = new StringBuilder();        sb.append("/core-service=vault:add(vault-options=[");        sb.append("(\"KEYSTORE_URL\" => \"").append(keystoreURL).append("\")").append(",");        sb.append("(\"KEYSTORE_PASSWORD\" => \"").append(keystoreMaskedPassword).append("\")").append(",");        sb.append("(\"KEYSTORE_ALIAS\" => \"").append(vaultAlias).append("\")").append(",");        sb.append("(\"SALT\" => \"").append(salt).append("\")").append(",");        sb.append("(\"ITERATION_COUNT\" => \"").append(iterationCount).append("\")").append(",");        sb.append("(\"ENC_FILE_DIR\" => \"").append(encryptionDirectory).append("\")");        sb.append("])");        return sb.toString();    }
public void getResourceValue(final ResolutionContext resolutionContext, final ServiceBuilder<?> serviceBuilder, final DeploymentPhaseContext phaseContext, final Injector<ManagedReferenceFactory> injector) {        serviceBuilder.addDependency(serviceName, ComponentView.class, new ViewManagedReferenceFactory.Injector(injector));    }
public static <T> T notNull(T value) {        if (value == null)            throw ConnectorLogger.ROOT_LOGGER.serviceNotStarted();        return value;    }
public static synchronized ServiceName getDeploymentServiceName(final String raName, final Activation raxml) {        if (raName == null)            throw ConnectorLogger.ROOT_LOGGER.undefinedVar("RaName");        ServiceName serviceName = null;        ModifiableResourceAdapter ra = (ModifiableResourceAdapter) raxml;        if (ra != null && ra.getId() != null) {            serviceName = getDeploymentServiceName(raName,ra.getId());        } else {            serviceName = getDeploymentServiceName(raName,(String)null);        }        ROOT_LOGGER.tracef("ConnectorServices: getDeploymentServiceName(%s,%s) -> %s", raName, raxml,serviceName);        return serviceName;    }
public static void registerResourceAdapterIdentifier(final String raName, final String raIdentifier) {        synchronized (resourceAdapterRepositoryIdentifiers) {            resourceAdapterRepositoryIdentifiers.put(raName, raIdentifier);        }    }
public void insertValue(Any any) {        if (type == String.class)            any.insert_wstring((String) value); // 1.3.5.10 Map to wstring        else            Util.insertAnyPrimitive(any, value);    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ManagementResourceRegistration baseRegistration = deploymentUnit.getAttachment(DeploymentModelUtils.MUTABLE_REGISTRATION_ATTACHMENT);        final ManagementResourceRegistration registration;        final Resource deploymentResource = deploymentUnit.getAttachment(DeploymentModelUtils.DEPLOYMENT_RESOURCE);        final ConnectorXmlDescriptor connectorXmlDescriptor = deploymentUnit.getAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY);        final CapabilityServiceSupport support = deploymentUnit.getAttachment(CAPABILITY_SERVICE_SUPPORT);        if (connectorXmlDescriptor == null) {            return; // Skip non ra deployments        }        if (deploymentUnit.getParent() != null) {            registration = baseRegistration.getSubModel(PathAddress.pathAddress(PathElement.pathElement("subdeployment")));        } else {            registration = baseRegistration;        }        ResourceAdaptersService.ModifiableResourceAdaptors raxmls = null;        final ServiceController<?> raService = phaseContext.getServiceRegistry().getService(                ConnectorServices.RESOURCEADAPTERS_SERVICE);        if (raService != null)            raxmls = ((ResourceAdaptersService.ModifiableResourceAdaptors) raService.getValue());        ROOT_LOGGER.tracef("processing Raxml");        Module module = deploymentUnit.getAttachment(Attachments.MODULE);        try {            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();            String deploymentUnitPrefix = "";            if (deploymentUnit.getParent() != null) {                deploymentUnitPrefix = deploymentUnit.getParent().getName() + "#";            }            final String deploymentUnitName = deploymentUnitPrefix + deploymentUnit.getName();            if (raxmls != null) {                for (Activation raxml : raxmls.getActivations()) {                    String rarName = raxml.getArchive();                    if (deploymentUnitName.equals(rarName)) {                        RaServicesFactory.createDeploymentService(registration, connectorXmlDescriptor, module, serviceTarget, deploymentUnitName, deploymentUnit.getServiceName(), deploymentUnitName, raxml, deploymentResource, phaseContext.getServiceRegistry(), support);                    }                }            }            //create service pointing to rar for other future activations            ServiceName serviceName = ConnectorServices.INACTIVE_RESOURCE_ADAPTER_SERVICE.append(deploymentUnitName);            InactiveResourceAdapterDeploymentService service = new InactiveResourceAdapterDeploymentService(connectorXmlDescriptor, module, deploymentUnitName, deploymentUnitName, deploymentUnit.getServiceName(), registration, serviceTarget, deploymentResource);            ServiceBuilder builder = serviceTarget                    .addService(serviceName, service);            builder.setInitialMode(Mode.ACTIVE).install();        } catch (Throwable t) {            throw new DeploymentUnitProcessingException(t);        }    }
public boolean implies(final JndiPermission permission) {        return permission != null && ((actionBits & permission.actionBits) == permission.actionBits) && impliesPath(permission.getName());    }
public boolean implies(final String name, final int actionBits) {        Assert.checkNotNullParam("name", name);        final int maskedBits = actionBits & ACTION_ALL;        return (this.actionBits & maskedBits) == maskedBits && impliesPath(name);    }
public String getActions() {        final String actionString = this.actionString;        if (actionString != null) {            return actionString;        }        int actionBits = this.actionBits;        if (actionBits == ACTION_ALL) {            return this.actionString = "*";        }        int m = Integer.lowestOneBit(actionBits);        if (m != 0) {            StringBuilder b = new StringBuilder();            b.append(getAction(m));            actionBits &= ~m;            while (actionBits != 0) {                m = Integer.lowestOneBit(actionBits);                b.append(',').append(getAction(m));                actionBits &= ~m;            }            return this.actionString = b.toString();        } else {            return this.actionString = "";        }    }
public JndiPermission withNewActions(int actionBits) {        actionBits &= ACTION_ALL;        if (actionBits == this.actionBits) {            return this;        } else {            return new JndiPermission(getName(), actionBits);        }    }
private boolean impliesPath0(final String yourName) {        // segment-by-segment comparison        final String myName = getName();        final Iterator<String> myIter = JndiPermissionNameParser.nameIterator(myName);        final Iterator<String> yourIter = JndiPermissionNameParser.nameIterator(yourName);        // even if it's just "", there is always a first element        assert myIter.hasNext() && yourIter.hasNext();        String myNext;        String yourNext;        for (;;) {            myNext = myIter.next();            yourNext = yourIter.next();            if (myNext.equals("-")) {                // "-" implies everything including ""                return true;            }            if (! myNext.equals("*") && ! myNext.equals(yourNext)) {                // "foo/bar" does not imply "foo/baz"                return false;            }            if (myIter.hasNext()) {                if (! yourIter.hasNext()) {                    // "foo/bar" does not imply "foo"                    return false;                }            } else {                // if neither has next, "foo/bar" implies "foo/bar", else "foo" does not imply "foo/bar"                return ! yourIter.hasNext();            }        }    }
public String getName() {        final String s = log.getName();        final int i = s.lastIndexOf(".");        return i != -1 ? s.substring(i + 1, s.length()) : s;    }
public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {        this.server = server;        serviceName = getObjectName(server, name);        return serviceName;    }
private void sendStateChangeNotification(int oldState, int newState, String msg, Throwable t) {        long now = System.currentTimeMillis();        AttributeChangeNotification stateChangeNotification = new AttributeChangeNotification(this,                getNextNotificationSequenceNumber(), now, msg, "State", "java.lang.Integer", new Integer(oldState),                new Integer(newState));        stateChangeNotification.setUserData(t);        sendNotification(stateChangeNotification);    }
@Override    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        DeploymentUnit unit = phaseContext.getDeploymentUnit();        final VirtualFile deploymentRoot = unit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();        parseDescriptors(unit, deploymentRoot);        final List<ResourceRoot> resourceRoots = unit.getAttachmentList(Attachments.RESOURCE_ROOTS);        for (ResourceRoot root : resourceRoots)            parseDescriptors(unit, root.getRoot());    }    /**     * Find and parse -jboss-beans.xml files.     *     * @param unit the deployment unit     * @param root the root     * @throws DeploymentUnitProcessingException     *          for any error     */    protected void parseDescriptors(DeploymentUnit unit, VirtualFile root) throws DeploymentUnitProcessingException {        if (root == null || root.exists() == false)            return;        Collection<VirtualFile> beans;        final String name = root.getName();        if (name.endsWith("jboss-beans.xml")) {            beans = Collections.singleton(root);        } else {            VirtualFileFilter filter = new SuffixMatchFilter("jboss-beans.xml");            beans = new ArrayList<VirtualFile>();            try {                // try plain .jar/META-INF                VirtualFile metainf = root.getChild("META-INF");                if (metainf.exists())                    beans.addAll(metainf.getChildren(filter));                // allow for WEB-INF/*-jboss-beans.xml                VirtualFile webinf = root.getChild("WEB-INF");                if (webinf.exists()) {                    beans.addAll(webinf.getChildren(filter));                    // allow WEB-INF/classes/META-INF                    metainf = webinf.getChild("classes/META-INF");                    if (metainf.exists())                        beans.addAll(metainf.getChildren(filter));                }            } catch (IOException e) {                throw new DeploymentUnitProcessingException(e);            }        }        for (VirtualFile beansXmlFile : beans)            parseDescriptor(unit, beansXmlFile);    }    /**     * Parse -jboss-beans.xml file.     *     * @param unit         the deployment unit     * @param beansXmlFile the beans xml file     * @throws DeploymentUnitProcessingException     *          for any error     */    protected void parseDescriptor(DeploymentUnit unit, VirtualFile beansXmlFile) throws DeploymentUnitProcessingException {        if (beansXmlFile == null || beansXmlFile.exists() == false)            return;        InputStream xmlStream = null;        try {            xmlStream = beansXmlFile.openStream();            final XMLStreamReader reader = inputFactory.createXMLStreamReader(xmlStream);            final ParseResult<KernelDeploymentXmlDescriptor> result = new ParseResult<KernelDeploymentXmlDescriptor>();            xmlMapper.parseDocument(result, reader);            final KernelDeploymentXmlDescriptor xmlDescriptor = result.getResult();            if (xmlDescriptor != null)                unit.addToAttachmentList(KernelDeploymentXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);            else                throw PojoLogger.ROOT_LOGGER.failedToParse(beansXmlFile);        } catch (DeploymentUnitProcessingException e) {            throw e;        } catch (Exception e) {            throw PojoLogger.ROOT_LOGGER.parsingException(beansXmlFile, e);        } finally {            VFSUtils.safeClose(xmlStream);        }    }    @Override    public void undeploy(DeploymentUnit context) {    }}
@Override    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {        ModelNode node = context.getModelNode();        boolean hasChildren = node.hasDefined(RESOURCEADAPTER_NAME) && node.get(RESOURCEADAPTER_NAME).asPropertyList().size() > 0;        context.startSubsystemElement(Namespace.CURRENT.getUriString(), !hasChildren);        if (hasChildren) {            writer.writeStartElement(Element.RESOURCE_ADAPTERS.getLocalName());            ModelNode ras = node.get(RESOURCEADAPTER_NAME);            for (String name : ras.keys()) {                final ModelNode ra = ras.get(name);                writeRaElement(writer, ra, name);            }            writer.writeEndElement();            // Close the subsystem element            writer.writeEndElement();        }    }
private EntityManager getOrCreateTransactionalEntityManager(TransactionManager transactionManager) {        try {            if (transactionManager.getStatus() == Status.STATUS_ACTIVE) {                EntityManager entityManager = this.transactionalEntityManagerHelper.getTransactionScopedEntityManager(getPersistenceUnitName());                if (entityManager == null) {                    entityManager = createEntityManager(transactionManager);                    this.transactionalEntityManagerHelper.putEntityManagerInTransactionRegistry(getPersistenceUnitName(), entityManager);                }                return entityManager;            }        } catch (Exception e) {            throw ROOT_LOGGER.idmJpaFailedCreateTransactionEntityManager(e);        }        return null;    }
@Override    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);        final boolean resolveProperties = Util.shouldResolveSpec(deploymentUnit);        final VirtualFile file = deploymentRoot.getRoot();        if (file == null || !file.exists())            return;        final String deploymentRootName = file.getName().toLowerCase(Locale.ENGLISH);        if (!deploymentRootName.endsWith(".rar")) {            return;        }        final VirtualFile alternateDescriptor = deploymentRoot.getAttachment(org.jboss.as.ee.structure.Attachments.ALTERNATE_CONNECTOR_DEPLOYMENT_DESCRIPTOR);        String prefix = "";        if (deploymentUnit.getParent() != null) {            prefix = deploymentUnit.getParent().getName() + "#";        }        String deploymentName = prefix + file.getName();        ConnectorXmlDescriptor xmlDescriptor = process(resolveProperties, file, alternateDescriptor, deploymentName);        phaseContext.getDeploymentUnit().putAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);    }
protected boolean hasBootClasses(JBossWebMetaData webdata) throws DeploymentUnitProcessingException {        if (webdata.getServlets() != null) {            for (ServletMetaData servlet : webdata.getServlets()) {                String servletClass = servlet.getServletClass();                if (BOOT_CLASSES.contains(servletClass))                    return true;            }        }        if (webdata.getFilters() != null) {            for (FilterMetaData filter : webdata.getFilters()) {                if (BOOT_CLASSES.contains(filter.getFilterClass()))                    return true;            }        }        return false;    }
public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {        final Interceptor interceptor = interceptors.get(method);        if (interceptor == null) {            throw new NoSuchMethodError(method.toString());        }        final InterceptorContext context = new InterceptorContext();        // special location for original proxy        context.putPrivateData(Object.class, proxy);        context.putPrivateData(Component.class, componentView.getComponent());        context.putPrivateData(ComponentView.class, componentView);        context.putPrivateData(SecurityDomain.class, WildFlySecurityManager.isChecking() ?                AccessController.doPrivileged((PrivilegedAction<SecurityDomain>) SecurityDomain::getCurrent) :                SecurityDomain.getCurrent());        instance.prepareInterceptorContext(context);        context.setParameters(args);        context.setMethod(method);        // setup the public context data        context.setContextData(new HashMap<String, Object>());        context.setBlockingCaller(true);        return interceptor.processInvocation(context);    }
public Object getStateToBind(Object orig, Name name, Context ctx,                                 Hashtable<?, ?> env) throws NamingException {        if (orig instanceof org.omg.CORBA.Object) {            // Already a CORBA object, just use it            return null;        }        if (orig instanceof Remote) {            // Turn remote object into org.omg.CORBA.Object            try {                // Returns null if JRMP; let next factory try                // CNCtx will eventually throw IllegalArgumentException if                // no CORBA object gotten                return                        CorbaUtils.remoteToCorba((Remote) orig, ((CNCtx) ctx)._orb);            } catch (ClassNotFoundException e) {                // RMI-IIOP library not available                throw IIOPLogger.ROOT_LOGGER.unavailableRMIPackages();            }        }        return null; // pass and let next state factory try    }
public Object getValue(Type type) {        if (type == null || (type instanceof Class)) {            return getClassValue((Class) type);        } else if (type instanceof ParameterizedType) {            ParameterizedType pt = (ParameterizedType) type;            return getPtValue(pt);        } else {            throw PojoLogger.ROOT_LOGGER.unknownType(type);        }    }
public ServiceName getContextServiceName() {        if (contextServiceName != null) return contextServiceName;        if (getNamingMode() == ComponentNamingMode.CREATE) {            return ContextNames.contextServiceNameOfComponent(getApplicationName(), getModuleName(), getComponentName());        } else if (getNamingMode() == ComponentNamingMode.USE_MODULE) {            return ContextNames.contextServiceNameOfModule(getApplicationName(), getModuleName());        } else {            throw new IllegalStateException();        }    }
public Set<InterceptorDescription> getAllInterceptors() {        if (allInterceptors == null) {            allInterceptors = new HashSet<InterceptorDescription>();            allInterceptors.addAll(classInterceptors);            if (!excludeDefaultInterceptors) {                allInterceptors.addAll(defaultInterceptors);            }            for (List<InterceptorDescription> interceptors : methodInterceptors.values()) {                allInterceptors.addAll(interceptors);            }        }        return allInterceptors;    }
public InterceptorDescription getClassInterceptor(String interceptorClassName) {        for (InterceptorDescription interceptor : classInterceptors) {            if (interceptor.getInterceptorClassName().equals(interceptorClassName)) {                return interceptor;            }        }        return null;    }
public void addMethodInterceptor(MethodIdentifier method, InterceptorDescription description) {        //we do not add method level interceptors to the set of interceptor classes,        //as their around invoke annotations        List<InterceptorDescription> interceptors = methodInterceptors.get(method);        if (interceptors == null) {            methodInterceptors.put(method, interceptors = new ArrayList<InterceptorDescription>());        }        final String name = description.getInterceptorClassName();        // add the interceptor class to the EEModuleDescription        interceptors.add(description);        this.allInterceptors = null;    }
public void setMethodInterceptors(MethodIdentifier identifier, List<InterceptorDescription> interceptorDescriptions) {        methodInterceptors.put(identifier, interceptorDescriptions);        methodExcludeClassInterceptors.add(identifier);        methodExcludeDefaultInterceptors.add(identifier);    }
public void addInterceptorMethodOverride(final String className, final InterceptorClassDescription override) {        interceptorClassOverrides.put(className, InterceptorClassDescription.merge(interceptorClassOverrides.get(className), override));    }
public void setNamingMode(final ComponentNamingMode namingMode) {        if (namingMode == null) {            throw EeLogger.ROOT_LOGGER.nullVar("namingMode", "component", componentName);        }        this.namingMode = namingMode;    }
public void addDependency(ServiceName serviceName) {        if (serviceName == null) {            throw EeLogger.ROOT_LOGGER.nullVar("serviceName", "component", componentName);        }        dependencies.add(serviceName);    }
public List<InterceptorFactory> getComponentInterceptors(Method method) {        Map<Method, OrderedItemContainer<List<InterceptorFactory>>> map = componentInterceptors;        OrderedItemContainer<List<InterceptorFactory>> interceptors = map.get(method);        if (interceptors == null) {            return Collections.emptyList();        }        List<List<InterceptorFactory>> sortedItems = interceptors.getSortedItems();        List<InterceptorFactory> ret = new ArrayList<>();        for(List<InterceptorFactory> item : sortedItems) {            ret.addAll(item);        }        return ret;    }
public List<InterceptorFactory> getAroundTimeoutInterceptors(Method method) {        Map<Method, OrderedItemContainer<InterceptorFactory>> map = timeoutInterceptors;        OrderedItemContainer<InterceptorFactory> interceptors = map.get(method);        if (interceptors == null) {            return Collections.emptyList();        }        return interceptors.getSortedItems();    }
public void addComponentInterceptor(InterceptorFactory factory, int priority, boolean publicOnly) {        addComponentInterceptors(Collections.singletonList(factory), priority, publicOnly);    }
public void addComponentInterceptors(List<InterceptorFactory> factory, int priority, boolean publicOnly) {        for (Method method : (Iterable<Method>)classIndex.getClassMethods()) {            if (publicOnly && !Modifier.isPublic(method.getModifiers())) {                continue;            }            OrderedItemContainer<List<InterceptorFactory>> interceptors = componentInterceptors.get(method);            if (interceptors == null) {                componentInterceptors.put(method, interceptors = new OrderedItemContainer<List<InterceptorFactory>>());            }            interceptors.add(factory, priority);        }    }
public void addComponentInterceptor(Method method, InterceptorFactory factory, int priority) {        addComponentInterceptors(method, Collections.singletonList(factory), priority);    }
public void addComponentInterceptors(Method method, List<InterceptorFactory> factory, int priority) {        OrderedItemContainer<List<InterceptorFactory>> interceptors = componentInterceptors.get(method);        if (interceptors == null) {            componentInterceptors.put(method, interceptors = new OrderedItemContainer<List<InterceptorFactory>>());        }        interceptors.add(factory, priority);    }
public void addTimeoutViewInterceptor(final Method method, InterceptorFactory factory, int priority) {        OrderedItemContainer<InterceptorFactory> interceptors = timeoutInterceptors.get(method);        if (interceptors == null) {            timeoutInterceptors.put(method, interceptors = new OrderedItemContainer<InterceptorFactory>());        }        interceptors.add(factory, priority);    }
public List<InterceptorFactory> getAroundConstructInterceptors() {        List<List<InterceptorFactory>> sortedItems = aroundConstructInterceptors.getSortedItems();        List<InterceptorFactory> interceptorFactories = new ArrayList<>();        for(List<InterceptorFactory> i : sortedItems) {            interceptorFactories.addAll(i);        }        return interceptorFactories;    }
public void addAroundConstructInterceptor(InterceptorFactory interceptorFactory, int priority) {        aroundConstructInterceptors.add(Collections.singletonList(interceptorFactory), priority);    }
public List<InterceptorFactory> getPostConstructInterceptors() {        List<List<InterceptorFactory>> sortedItems = postConstructInterceptors.getSortedItems();        List<InterceptorFactory> interceptorFactories = new ArrayList<>();        for(List<InterceptorFactory> i : sortedItems) {            interceptorFactories.addAll(i);        }        return interceptorFactories;    }
public void addPostConstructInterceptor(InterceptorFactory interceptorFactory, int priority) {        postConstructInterceptors.add(Collections.singletonList(interceptorFactory), priority);    }
public List<InterceptorFactory> getPreDestroyInterceptors() {        List<List<InterceptorFactory>> sortedItems = preDestroyInterceptors.getSortedItems();        List<InterceptorFactory> interceptorFactories = new ArrayList<>();        for(List<InterceptorFactory> i : sortedItems) {            interceptorFactories.addAll(i);        }        return interceptorFactories;    }
public void addPreDestroyInterceptor(InterceptorFactory interceptorFactory, int priority) {        preDestroyInterceptors.add(Collections.singletonList(interceptorFactory), priority);    }
public List<InterceptorFactory> getPrePassivateInterceptors() {        List<List<InterceptorFactory>> sortedItems = prePassivateInterceptors.getSortedItems();        List<InterceptorFactory> interceptorFactories = new ArrayList<>();        for(List<InterceptorFactory> i : sortedItems) {            interceptorFactories.addAll(i);        }        return interceptorFactories;    }
public void addPrePassivateInterceptor(InterceptorFactory interceptorFactory, int priority) {        prePassivateInterceptors.add(Collections.singletonList(interceptorFactory), priority);    }
public List<InterceptorFactory> getPostActivateInterceptors() {        List<List<InterceptorFactory>> sortedItems = postActivateInterceptors.getSortedItems();        List<InterceptorFactory> interceptorFactories = new ArrayList<>();        for(List<InterceptorFactory> i : sortedItems) {            interceptorFactories.addAll(i);        }        return interceptorFactories;    }
public void addPostActivateInterceptor(InterceptorFactory interceptorFactory, int priority) {        postActivateInterceptors.add(Collections.singletonList(interceptorFactory), priority);    }
public void setComponentCreateServiceFactory(final ComponentCreateServiceFactory componentCreateServiceFactory) {        if (componentCreateServiceFactory == null) {            throw EeLogger.ROOT_LOGGER.nullVar("componentCreateServiceFactory", "component", getComponentName());        }        this.componentCreateServiceFactory = componentCreateServiceFactory;    }
public synchronized Component getValue() throws IllegalStateException, IllegalArgumentException {        Component component = this.component;        if (component == null) {            throw EeLogger.ROOT_LOGGER.serviceNotStarted();        }        return component;    }
private Module getModule(Class<?> originalClass) {        if (originalClass.getName().startsWith("java")) {            return module;        } else {            Module definingModule = Module.forClass(originalClass);            Boolean hasWeldDependencies = processedStaticModules.get(definingModule.getIdentifier());            boolean logWarning = false; // only log for the first class in the module            if (hasWeldDependencies == null) {                hasWeldDependencies = canLoadWeldProxies(definingModule); // may be run multiple times but that does not matter                logWarning = processedStaticModules.putIfAbsent(definingModule.getIdentifier(), hasWeldDependencies) == null;            }            if (hasWeldDependencies) {                // this module declares Weld dependencies - we can use module's classloader to load the proxy class                // pros: package-private members will work fine                // cons: proxy classes will remain loaded by the module's classloader after undeployment (nothing else leaks)                return definingModule;            } else {                // no weld dependencies - we use deployment's classloader to load the proxy class                // pros: proxy classes unloaded with undeployment                // cons: package-private methods and constructors will yield IllegalAccessException                if (logWarning) {                    WeldLogger.ROOT_LOGGER.loadingProxiesUsingDeploymentClassLoader(definingModule.getIdentifier(), Arrays.toString(REQUIRED_WELD_DEPENDENCIES));                }                return this.module;            }        }    }
private ProtectionDomain getProtectionDomain(final Class<?> clazz) {        final SecurityManager sm = System.getSecurityManager();        if (sm != null) {            return doPrivileged((PrivilegedAction<ProtectionDomain>) clazz::getProtectionDomain);        } else {            return clazz.getProtectionDomain();        }    }
private Map<URL, URL> findExportedResources(Module dependencyModule) {        Set<URL> beanXmls = findExportedResource(dependencyModule, META_INF_BEANS_XML);        if (beanXmls.isEmpty()) {            return Collections.emptyMap();        }        Set<URL> indexes = findExportedResource(dependencyModule, META_INF_JANDEX_IDX);        Map<URL, URL> ret = new HashMap<>();        for (URL beansXml : beanXmls) {            String urlBase = beansXml.toString().substring(0, beansXml.toString().length() - META_INF_BEANS_XML.length());            URL idx = null;            for (URL index : indexes) {                if (index.toString().startsWith(urlBase)) {                    idx = index;                    break;                }            }            ret.put(beansXml, idx);        }        return ret;    }
protected void removeJNDIAliases(OperationContext context, List<ModelNode> entries) {        if (entries.size() > 1) {            for (int i = 1; i < entries.size() ; i++) {                ContextNames.BindInfo aliasBindInfo = ContextNames.bindInfoFor(entries.get(i).asString());                context.removeService(aliasBindInfo.getBinderServiceName());            }        }    }
public static void setTransactionSynchronizationRegistry(TransactionSynchronizationRegistry tsr) {        if ((Assert.checkNotNullParam("tsr", tsr)) != transactionSynchronizationRegistry) {            synchronized (WildFlyCustomJtaPlatform.class) {                if (tsr != transactionSynchronizationRegistry) {                    transactionSynchronizationRegistry = tsr;                }            }        }    }
public void accept(final EJBClientContext.Builder builder) {        final EJBTransportProvider remoteTransportProvider = this.remoteTransportProvider;        if (remoteTransportProvider != null) {            builder.addTransportProvider(remoteTransportProvider);            builder.addTransportProvider(remoteHttpTransportProvider);        }    }
public static ServiceName contextServiceNameOfComponent(String app, String module, String comp) {        return COMPONENT_CONTEXT_SERVICE_NAME.append(app, module, comp);    }
public static ServiceName contextServiceNameOfModule(String app, String module) {        return MODULE_CONTEXT_SERVICE_NAME.append(app, module);    }
public static BindInfo bindInfoFor(String app, String module, String comp, String context) {        if (context.startsWith("java:")) {            final String namespace;            final int i = context.indexOf('/');            if (i == -1) {                namespace = context.substring(5);            } else if (i == 5) {                // Absolute path                return new BindInfo(JAVA_CONTEXT_SERVICE_NAME, context.substring(6));            } else {                namespace = context.substring(5, i);            }            sanitazeNameSpace(namespace,context);            if (namespace.equals("global")) {                return new BindInfo(GLOBAL_CONTEXT_SERVICE_NAME, context.substring(12));            } else if (namespace.equals("jboss")) {                String rest = context.substring(i);                if(rest.startsWith("/exported/")) {                    return new BindInfo(EXPORTED_CONTEXT_SERVICE_NAME, context.substring(20));                } else {                    return new BindInfo(JBOSS_CONTEXT_SERVICE_NAME, context.substring(11));                }            } else if (namespace.equals("app")) {                return new BindInfo(contextServiceNameOfApplication(app), context.substring(9));            } else if (namespace.equals("module")) {                return new BindInfo(contextServiceNameOfModule(app, module), context.substring(12));            } else if (namespace.equals("comp")) {                return new BindInfo(contextServiceNameOfComponent(app, module, comp), context.substring(10));            } else {                return new BindInfo(JBOSS_CONTEXT_SERVICE_NAME, context);            }        } else {            return null;        }    }
public static BindInfo bindInfoForEnvEntry(String app, String module, String comp, boolean useCompNamespace, final String envEntryName) {        if (envEntryName.startsWith("java:")) {            if (useCompNamespace) {                return bindInfoFor(app, module, comp, envEntryName);            } else {                if (envEntryName.startsWith("java:comp")) {                    return bindInfoFor(app, module, module, "java:module" + envEntryName.substring("java:comp".length()));                } else {                    return bindInfoFor(app, module, module, envEntryName);                }            }        } else {            if (useCompNamespace) {                return bindInfoFor(app, module, comp, "java:comp/env/" + envEntryName);            } else {                return bindInfoFor(app, module, module, "java:module/env/" + envEntryName);            }        }    }
public static BindInfo bindInfoFor(final String jndiName) {        // TODO: handle non java: schemes        String bindName;        if (jndiName.startsWith("java:")) {            bindName = jndiName.substring(5);        } else if (!jndiName.startsWith("jboss") && !jndiName.startsWith("global") && !jndiName.startsWith("/")) {            bindName = "/" + jndiName;        } else {            bindName = jndiName;        }        final ServiceName parentContextName;        if(bindName.startsWith("jboss/exported/")) {            parentContextName = EXPORTED_CONTEXT_SERVICE_NAME;            bindName = bindName.substring(15);        } else if (bindName.startsWith("jboss/")) {            parentContextName = JBOSS_CONTEXT_SERVICE_NAME;            bindName = bindName.substring(6);        } else if (bindName.startsWith("global/")) {            parentContextName = GLOBAL_CONTEXT_SERVICE_NAME;            bindName = bindName.substring(7);        } else if (bindName.startsWith("/")) {            parentContextName = JAVA_CONTEXT_SERVICE_NAME;            bindName = bindName.substring(1);        } else {            throw NamingLogger.ROOT_LOGGER.illegalContextInName(jndiName);        }        return new BindInfo(parentContextName, bindName);    }
public  void putEntityManagerInTransactionRegistry(String scopedPuName, EntityManager entityManager) {        try {            Transaction transaction = this.transactionManager.getTransaction();            transaction.registerSynchronization(new TransactionalEntityManagerSynchronization(entityManager));            this.transactionSynchronizationRegistry.putResource(scopedPuName, entityManager);        } catch (Exception e) {            throw PicketLinkLogger.ROOT_LOGGER.idmJpaFailedCreateTransactionEntityManager(e);        }    }
public String rawAttributeText(XMLStreamReader reader, String attributeName) {        return rawAttributeText(reader, attributeName, null);    }
@Override    protected JaccService<AttachmentList<EjbJaccConfig>> createService(String contextId, AttachmentList<EjbJaccConfig> metaData, Boolean standalone) {        return new EjbJaccService(contextId, metaData, standalone);    }
public static void bindObject(final ServiceTarget target, final String contextName, final Object value) {        final BinderService binderService = new BinderService(contextName);        binderService.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(Values.immediateValue(value)));        target.addService(ContextNames.buildServiceName(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, contextName), binderService)                .addDependency(ContextNames.JBOSS_CONTEXT_SERVICE_NAME, ServiceBasedNamingStore.class, binderService.getNamingStoreInjector())                .install();    }
public ConcurrentMap<Principal, DomainInfo> getCache() {        return new LRUCache<>(1000, (key, value) -> {            if (value != null) {                value.logout();            }        });    }
public IRObject getReference() {        if (ref == null) {            ref = org.omg.CORBA.ValueDefHelper.narrow(                    servantToReference(new ValueDefPOATie(this)));        }        return ref;    }
public TypeCode type() {        if (typeCode == null) {            short modifier = VM_NONE.value;            if (is_custom)                modifier = VM_CUSTOM.value;            else if (is_abstract)                modifier = VM_ABSTRACT.value;            typeCode = getORB().create_value_tc(id, name, modifier,                    baseValueTypeCode,                    getValueMembersForTypeCode());        }        return typeCode;    }
public Description describe() {        String defined_in_id = "IR";        if (defined_in instanceof org.omg.CORBA.ContainedOperations)            defined_in_id = ((org.omg.CORBA.ContainedOperations) defined_in).id();        ValueDescription md = new ValueDescription(name, id, is_abstract,                is_custom,                defined_in_id, version,                supported_interfaces,                abstract_base_valuetypes,                false,                baseValue);        Any any = getORB().create_any();        ValueDescriptionHelper.insert(any, md);        return new Description(DefinitionKind.dk_Value, any);    }
private ValueMember[] getValueMembers() {        if (valueMembers != null)            return valueMembers;        LocalContained[] c = _contents(DefinitionKind.dk_ValueMember, false);        valueMembers = new ValueMember[c.length];        for (int i = 0; i < c.length; ++i) {            ValueMemberDefImpl vmdi = (ValueMemberDefImpl) c[i];            valueMembers[i] = new ValueMember(vmdi.name(), vmdi.id(),                    ((LocalContained) vmdi.defined_in).id(),                    vmdi.version(),                    vmdi.type(), vmdi.type_def(),                    vmdi.access());        }        return valueMembers;    }
private ValueMember[] getValueMembersForTypeCode() {        LocalContained[] c = _contents(DefinitionKind.dk_ValueMember, false);        ValueMember[] vms = new ValueMember[c.length];        for (int i = 0; i < c.length; ++i) {            ValueMemberDefImpl vmdi = (ValueMemberDefImpl) c[i];            vms[i] = new ValueMember(vmdi.name(),                    null, // ignore id                    null, // ignore defined_in                    null, // ignore version                    vmdi.type(),                    null, // ignore type_def                    vmdi.access());        }        return vms;    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        if (deploymentUnit.getParent() != null) {            return;        }        EEModuleDescription moduleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();        final ServiceName applicationContextServiceName = ContextNames.contextServiceNameOfApplication(moduleDescription.getApplicationName());        final NamingStoreService contextService = new NamingStoreService(true);        serviceTarget.addService(applicationContextServiceName, contextService).install();        final ServiceName appNameServiceName = applicationContextServiceName.append("AppName");        final BinderService applicationNameBinder = new BinderService("AppName");        applicationNameBinder.getManagedObjectInjector().inject(new ValueManagedReferenceFactory(Values.immediateValue(moduleDescription.getApplicationName())));        serviceTarget.addService(appNameServiceName, applicationNameBinder)                .addDependency(applicationContextServiceName, ServiceBasedNamingStore.class, applicationNameBinder.getNamingStoreInjector())                .install();        deploymentUnit.addToAttachmentList(org.jboss.as.server.deployment.Attachments.JNDI_DEPENDENCIES, appNameServiceName);        deploymentUnit.putAttachment(Attachments.APPLICATION_CONTEXT_CONFIG, applicationContextServiceName);    }
private ModelNode createSubsystemRoot() {        ModelNode subsystemAddress = new ModelNode();        subsystemAddress.add(ModelDescriptionConstants.SUBSYSTEM, FederationExtension.SUBSYSTEM_NAME);        subsystemAddress.protect();        return Util.getEmptyOperation(ADD, subsystemAddress);    }
protected ModelNode parseConfig(XMLExtendedStreamReader reader, ModelElement xmlElement, String key, ModelNode lastNode,        List<SimpleAttributeDefinition> attributes, List<ModelNode> addOperations) throws XMLStreamException {        if (!reader.getLocalName().equals(xmlElement.getName())) {            return null;        }        ModelNode modelNode = Util.getEmptyOperation(ADD, null);        int attributeCount = reader.getAttributeCount();        for (int i = 0; i < attributeCount; i++) {            String attributeLocalName = reader.getAttributeLocalName(i);            if (ModelElement.forName(attributeLocalName) == null) {                throw unexpectedAttribute(reader, i);            }        }        for (SimpleAttributeDefinition simpleAttributeDefinition : attributes) {            String attributeValue = reader.getAttributeValue("", simpleAttributeDefinition.getXmlName());            simpleAttributeDefinition.parseAndSetParameter(attributeValue, modelNode, reader);        }        String name = xmlElement.getName();        if (key != null) {            name = key;            if (modelNode.hasDefined(key)) {                name = modelNode.get(key).asString();            } else {                String attributeValue = reader.getAttributeValue("", key);                if (attributeValue != null) {                    name = attributeValue;                }            }        }        modelNode.get(ModelDescriptionConstants.OP_ADDR).set(lastNode.clone().get(OP_ADDR).add(xmlElement.getName(), name));        addOperations.add(modelNode);        return modelNode;    }
@Override    public void writeContent(final XMLExtendedStreamWriter writer, final SubsystemMarshallingContext context) throws XMLStreamException {        context.startSubsystemElement(NamingExtension.NAMESPACE_2_0, false);        ModelNode model = context.getModelNode();        // bindings        if (model.hasDefined(BINDING)) {            writer.writeStartElement(NamingSubsystemXMLElement.BINDINGS.getLocalName());            final ModelNode bindingModel = model.get(BINDING);            this.writeBindings(writer, bindingModel);            // </timer-service>            writer.writeEndElement();        }        if (model.hasDefined(SERVICE)) {            final ModelNode service = model.get(SERVICE);            if (service.has(REMOTE_NAMING)) {                writer.writeEmptyElement(REMOTE_NAMING);            }        }        // write the subsystem end element        writer.writeEndElement();    }
@Override    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {        String str = PathAddress.pathAddress(operation.get(OP_ADDR)).getLastElement().getValue();        if (!str.startsWith("java:/") && !str.startsWith("java:jboss/")) {            throw ROOT_LOGGER.jndiNameInvalidFormat();        }        CMResourceResourceDefinition.CM_TABLE_NAME.validateAndSet(operation, model);        CMResourceResourceDefinition.CM_TABLE_BATCH_SIZE.validateAndSet(operation, model);        CMResourceResourceDefinition.CM_TABLE_IMMEDIATE_CLEANUP.validateAndSet(operation, model);    }
@Override    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {        PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));        final String jndiName = address.getLastElement().getValue();        final String tableName = CMResourceResourceDefinition.CM_TABLE_NAME.resolveModelAttribute(context, model).asString();        final int batchSize =  CMResourceResourceDefinition.CM_TABLE_BATCH_SIZE.resolveModelAttribute(context, model).asInt();        final boolean immediateCleanup = CMResourceResourceDefinition.CM_TABLE_IMMEDIATE_CLEANUP.resolveModelAttribute(context, model).asBoolean();        ROOT_LOGGER.debugf("adding commit-markable-resource: jndi-name=%s, table-name=%s, batch-size=%d, immediate-cleanup=%b", jndiName, tableName, batchSize, immediateCleanup);        CMResourceService service = new CMResourceService(jndiName, tableName, immediateCleanup, batchSize);        context.getServiceTarget().addService(TxnServices.JBOSS_TXN_CMR.append(jndiName), service)                .addDependency(TxnServices.JBOSS_TXN_JTA_ENVIRONMENT, JTAEnvironmentBean.class, service.getJTAEnvironmentBeanInjector())                .setInitialMode(ServiceController.Mode.ACTIVE)                .install();        if (!context.isBooting()) {            context.reloadRequired();        }    }
public void start(StartContext context) throws StartException {        ROOT_LOGGER.startingService();        try {            NamingContext.setActiveNamingStore(namingStore.getValue());        } catch (Throwable t) {            throw new StartException(NamingLogger.ROOT_LOGGER.failedToStart("naming service"), t);        }    }
@Override    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {        ParseUtils.requireNoAttributes(reader);        ParseUtils.requireNoContent(reader);        list.add(Util.createAddOperation(PathAddress.pathAddress(NamingExtension.SUBSYSTEM_PATH)));        if(!appclient) {            //we do not add remote naming to the application client            //note that this is a bi            list.add(Util.createAddOperation(PathAddress.pathAddress(NamingExtension.SUBSYSTEM_PATH).append(NamingSubsystemModel.SERVICE, NamingSubsystemModel.REMOTE_NAMING)));        }    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        setClassLoaderTransformer(deploymentUnit);    }
private void addWeldIntegration(final Iterable<ComponentIntegrator> componentIntegrators, final ComponentInterceptorSupport componentInterceptorSupport, final ServiceTarget target, final ComponentConfiguration configuration, final ComponentDescription description, final Class<?> componentClass, final String beanName, final ServiceName weldServiceName, final ServiceName weldStartService, final ServiceName beanManagerService, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId) {        final ServiceName serviceName = configuration.getComponentDescription().getServiceName().append("WeldInstantiator");        final ServiceBuilder<?> builder = target.addService(serviceName);        builder.requires(weldStartService);        configuration.setInstanceFactory(WeldManagedReferenceFactory.INSTANCE);        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {            @Override            public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {                serviceBuilder.requires(serviceName);            }        });        boolean isComponentIntegrationPerformed = false;        for (ComponentIntegrator componentIntegrator : componentIntegrators) {            Supplier<ServiceName> bindingServiceNameSupplier = () -> {                if (componentInterceptorSupport == null) {                    throw WeldLogger.DEPLOYMENT_LOGGER.componentInterceptorSupportNotAvailable(componentClass);                }                return addWeldInterceptorBindingService(target, configuration, componentClass, beanName, weldServiceName, weldStartService,                        beanDeploymentArchiveId, componentInterceptorSupport);            };            DefaultInterceptorIntegrationAction integrationAction = (bindingServiceName) -> {                if (componentInterceptorSupport == null) {                    throw WeldLogger.DEPLOYMENT_LOGGER.componentInterceptorSupportNotAvailable(componentClass);                }                addJsr299BindingsCreateInterceptor(configuration, description, beanName, weldServiceName, builder, bindingServiceName,                        componentInterceptorSupport);                addCommonLifecycleInterceptionSupport(configuration, builder, bindingServiceName, beanManagerService, componentInterceptorSupport);                configuration.addComponentInterceptor(                        new UserInterceptorFactory(factory(InterceptionType.AROUND_INVOKE, builder, bindingServiceName, componentInterceptorSupport),                                factory(InterceptionType.AROUND_TIMEOUT, builder, bindingServiceName, componentInterceptorSupport)),                        InterceptorOrder.Component.CDI_INTERCEPTORS, false);            };            if (componentIntegrator.integrate(beanManagerService, configuration, description, builder, bindingServiceNameSupplier, integrationAction,                    componentInterceptorSupport)) {                isComponentIntegrationPerformed = true;                break;            }        }
public static ServiceName jobOperatorServiceName(final String deploymentRuntimeName, final String subdeploymentName) {        return Services.deploymentUnitName(deploymentRuntimeName, subdeploymentName).append("batch").append("job-operator");    }
public void addComponent(final ComponentDescription description, final VirtualFile deploymentRoot) {        for (final ViewDescription viewDescription : description.getViews()) {            List<ViewInformation> viewComponents = componentsByViewName.get(viewDescription.getViewClassName());            if (viewComponents == null) {                viewComponents = new ArrayList<ViewInformation>(1);                componentsByViewName.put(viewDescription.getViewClassName(), viewComponents);            }            viewComponents.add(new ViewInformation(viewDescription, deploymentRoot, description.getComponentName()));        }        List<Description> components = componentsByName.get(description.getComponentName());        if (components == null) {            componentsByName.put(description.getComponentName(), components = new ArrayList<Description>(1));        }        components.add(new Description(description, deploymentRoot));    }
public void addMessageDestination(final String name, final String resolvedName, final VirtualFile deploymentRoot) {        List<MessageDestinationMapping> components = messageDestinationJndiMapping.get(name);        if (components == null) {            messageDestinationJndiMapping.put(name, components = new ArrayList<MessageDestinationMapping>(1));        }        components.add(new MessageDestinationMapping(resolvedName, deploymentRoot));    }
public Set<ViewDescription> getComponentsForViewName(final String viewType, final VirtualFile deploymentRoot) {        final List<ViewInformation> info = componentsByViewName.get(viewType);        if (info == null) {            return Collections.<ViewDescription>emptySet();        }        final Set<ViewDescription> ret = new HashSet<ViewDescription>();        final Set<ViewDescription> currentDep = new HashSet<ViewDescription>();        for (ViewInformation i : info) {            if (deploymentRoot.equals(i.deploymentRoot)) {                currentDep.add(i.viewDescription);            }            ret.add(i.viewDescription);        }        if(!currentDep.isEmpty()) {            return currentDep;        }        return ret;    }
public Set<ComponentDescription> getComponents(final String componentName, final VirtualFile deploymentRoot) {        if (componentName.contains("#")) {            final String[] parts = componentName.split("#");            String path = parts[0];            if (!path.startsWith("../")) {                path = "../" + path;            }            final VirtualFile virtualPath = deploymentRoot.getChild(path);            final String name = parts[1];            final List<Description> info = componentsByName.get(name);            if (info == null) {                return Collections.emptySet();            }            final Set<ComponentDescription> ret = new HashSet<ComponentDescription>();            for (Description i : info) {                //now we need to check the path                if (virtualPath.equals(i.deploymentRoot)) {                    ret.add(i.componentDescription);                }            }            return ret;        } else {            final List<Description> info = componentsByName.get(componentName);            if (info == null) {                return Collections.emptySet();            }            final Set<ComponentDescription> all = new HashSet<ComponentDescription>();            final Set<ComponentDescription> thisDeployment = new HashSet<ComponentDescription>();            for (Description i : info) {                all.add(i.componentDescription);                if (i.deploymentRoot.equals(deploymentRoot)) {                    thisDeployment.add(i.componentDescription);                }            }            //if there are multiple e            if (all.size() > 1) {                return thisDeployment;            }            return all;        }    }
public Set<ViewDescription> getComponents(final String componentName, final String viewName, final VirtualFile deploymentRoot) {        final List<ViewInformation> info = componentsByViewName.get(viewName);        if (info == null) {            return Collections.<ViewDescription>emptySet();        }        if (componentName.contains("#")) {            final String[] parts = componentName.split("#");            String path = parts[0];            if (!path.startsWith("../")) {                path = "../" + path;            }            final VirtualFile virtualPath = deploymentRoot.getChild(path);            final String name = parts[1];            final Set<ViewDescription> ret = new HashSet<ViewDescription>();            for (ViewInformation i : info) {                if (i.beanName.equals(name)) {                    //now we need to check the path                    if (virtualPath.equals(i.deploymentRoot)) {                        ret.add(i.viewDescription);                    }                }            }            return ret;        } else {            final Set<ViewDescription> all = new HashSet<ViewDescription>();            final Set<ViewDescription> thisDeployment = new HashSet<ViewDescription>();            for (ViewInformation i : info) {                if (i.beanName.equals(componentName)) {                    all.add(i.viewDescription);                    if (i.deploymentRoot.equals(deploymentRoot)) {                        thisDeployment.add(i.viewDescription);                    }                }            }            if (all.size() > 1) {                return thisDeployment;            }            return all;        }    }
public Set<String> resolveMessageDestination(final String messageDestName, final VirtualFile deploymentRoot) {        if (messageDestName.contains("#")) {            final String[] parts = messageDestName.split("#");            String path = parts[0];            if (!path.startsWith("../")) {                path = "../" + path;            }            final VirtualFile virtualPath = deploymentRoot.getChild(path);            final String name = parts[1];            final Set<String> ret = new HashSet<String>();            final List<MessageDestinationMapping> data = messageDestinationJndiMapping.get(name);            if (data != null) {                for (final MessageDestinationMapping i : data) {                    //now we need to check the path                    if (virtualPath.equals(i.deploymentRoot)) {                        ret.add(i.jndiName);                    }                }            }            return ret;        } else {            final Set<String> all = new HashSet<String>();            final Set<String> thisDeployment = new HashSet<String>();            final List<MessageDestinationMapping> data = messageDestinationJndiMapping.get(messageDestName);            if (data != null) {                for (final MessageDestinationMapping i : data) {                    all.add(i.jndiName);                    if (i.deploymentRoot.equals(deploymentRoot)) {                        thisDeployment.add(i.jndiName);                    }                }            }            if (all.size() > 1) {                return thisDeployment;            }            return all;        }    }
private static void buildTransformers2_1_0(ResourceTransformationDescriptionBuilder builder) {        ResourceTransformationDescriptionBuilder hornetqServer = builder.addChildResource(pathElement(HORNETQ_SERVER));        ResourceTransformationDescriptionBuilder addressSetting = hornetqServer.addChildResource(AddressSettingDefinition.PATH);        rejectDefinedAttributeWithDefaultValue(addressSetting, MAX_REDELIVERY_DELAY, REDELIVERY_MULTIPLIER);        ResourceTransformationDescriptionBuilder bridge = hornetqServer.addChildResource(BridgeDefinition.PATH);        bridge.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);        ResourceTransformationDescriptionBuilder clusterConnection = hornetqServer.addChildResource(ClusterConnectionDefinition.PATH);        clusterConnection.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);        ResourceTransformationDescriptionBuilder connectionFactory = hornetqServer.addChildResource(ConnectionFactoryDefinition.PATH);        connectionFactory.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);        ResourceTransformationDescriptionBuilder pooledConnectionFactory = hornetqServer.addChildResource(PooledConnectionFactoryDefinition.PATH);        pooledConnectionFactory.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);    }
private static void buildTransformers1_4_0(ResourceTransformationDescriptionBuilder builder) {        ResourceTransformationDescriptionBuilder hornetqServer = builder.addChildResource(pathElement(HORNETQ_SERVER));        renameAttribute(hornetqServer, CommonAttributes.STATISTICS_ENABLED, CommonAttributes.MESSAGE_COUNTER_ENABLED);        ResourceTransformationDescriptionBuilder bridge = hornetqServer.addChildResource(BridgeDefinition.PATH);        rejectDefinedAttributeWithDefaultValue(bridge, BridgeDefinition.RECONNECT_ATTEMPTS_ON_SAME_NODE, BridgeDefinition.INITIAL_CONNECT_ATTEMPTS);        ResourceTransformationDescriptionBuilder clusterConnection = hornetqServer.addChildResource(ClusterConnectionDefinition.PATH);        rejectDefinedAttributeWithDefaultValue(clusterConnection, ClusterConnectionDefinition.INITIAL_CONNECT_ATTEMPTS);        ResourceTransformationDescriptionBuilder addressSetting = hornetqServer.addChildResource(AddressSettingDefinition.PATH);        rejectDefinedAttributeWithDefaultValue(addressSetting, AddressSettingDefinition.EXPIRY_DELAY);    }
private static void buildTransformers1_3_0(ResourceTransformationDescriptionBuilder builder) {        ResourceTransformationDescriptionBuilder hornetqServer = builder.addChildResource(pathElement(HORNETQ_SERVER));        rejectDefinedAttributeWithDefaultValue(hornetqServer, OVERRIDE_IN_VM_SECURITY);        hornetqServer.rejectChildResource(HTTPAcceptorDefinition.PATH);        hornetqServer.rejectChildResource(pathElement(CommonAttributes.HTTP_CONNECTOR));        ResourceTransformationDescriptionBuilder addressSetting = hornetqServer.addChildResource(AddressSettingDefinition.PATH);        rejectDefinedAttributeWithDefaultValue(addressSetting, SLOW_CONSUMER_CHECK_PERIOD, SLOW_CONSUMER_POLICY, SLOW_CONSUMER_THRESHOLD);    }
private static void rejectDefinedAttributeWithDefaultValue(ResourceTransformationDescriptionBuilder builder, AttributeDefinition... attrs) {        for (AttributeDefinition attr : attrs) {            builder.getAttributeBuilder()                    .setDiscard(new DiscardAttributeValueChecker(attr.getDefaultValue()), attr)                    .addRejectCheck(DEFINED, attr);        }    }
private static void renameAttribute(ResourceTransformationDescriptionBuilder builder,                                        AttributeDefinition attribute, AttributeDefinition alias) {        builder.getAttributeBuilder().addRename(attribute, alias.getName());    }
public static Collection<Principal> getConnectionPrincipals() {        RemoteConnection con = RemotingContext.getRemoteConnection();        if (con != null) {            Collection<Principal> principals = new HashSet<>();            SecurityIdentity localIdentity = con.getSecurityIdentity();            if (localIdentity != null) {                final Principal principal = localIdentity.getPrincipal();                final String realm = principal instanceof RealmPrincipal ? ((RealmPrincipal) principal).getRealm() : null;                principals.add(new RealmUser(realm, principal.getName()));                for (String role : localIdentity.getRoles()) {                    principals.add(new RealmGroup(role));                    principals.add(new RealmRole(role));                }                return principals;            } else {                return Collections.emptySet();            }        }        return null;    }
public static ContextStateCache pushIdentity(final Principal principal, final Object credential) throws Exception {        SecurityContext current = SecurityContextAssociation.getSecurityContext();        SecurityContext nextContext = SecurityContextFactory.createSecurityContext(principal, credential, new Subject(), "USER_DELEGATION");        SecurityContextAssociation.setSecurityContext(nextContext);        RemoteConnection con = RemotingContext.getRemoteConnection();        RemotingContext.clear();        return new ContextStateCache(con, current);    }
public static void popIdentity(final ContextStateCache stateCache) {        RemotingContext.setConnection(stateCache.getConnection());        SecurityContextAssociation.setSecurityContext(stateCache.getSecurityContext());    }
public ManagedReference getReference() {        final ClassLoader loader;        try {            loader = SecurityActions.getModuleClassLoader();        } catch (ModuleLoadException e) {            throw SecurityLogger.ROOT_LOGGER.unableToGetModuleClassLoader(e);        }        Class<?>[] interfaces = { Context.class };        return new ValueManagedReference(new ImmediateValue<Object>(Proxy.newProxyInstance(loader, interfaces, this)));    }
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        Context ctx = new InitialContext();        NameParser parser = ctx.getNameParser("");        String securityDomain = null;        Name name = null;        final JNDIBasedSecurityManagement securityManagement = JNDIBasedSecurityManagement.class.cast(securityManagementValue                .getValue());        final ConcurrentHashMap<String, SecurityDomainContext> securityManagerMap = securityManagement.getSecurityManagerMap();        String methodName = method.getName();        if (methodName.equals("toString"))            return SecurityConstants.JAAS_CONTEXT_ROOT + " Context proxy";        if (methodName.equals("list"))            return new DomainEnumeration(securityManagerMap.keys(), securityManagerMap);        if (methodName.equals("bind") || methodName.equals("rebind")) {            if (args[0] instanceof String)                name = parser.parse((String) args[0]);            else                name = (Name) args[0];            securityDomain = name.get(0);            SecurityDomainContext val = (SecurityDomainContext) args[1];            securityManagerMap.put(securityDomain, val);            return proxy;        }        if (!methodName.equals("lookup"))            throw SecurityLogger.ROOT_LOGGER.operationNotSupported(method);        if (args[0] instanceof String)            name = parser.parse((String) args[0]);        else            name = (Name) args[0];        securityDomain = name.get(0);        SecurityDomainContext securityDomainCtx = lookupSecurityDomain(securityManagement, securityManagerMap, securityDomain);        Object binding = securityDomainCtx.getAuthenticationManager();        // Look for requests against the security domain context        if (name.size() == 2) {            String request = name.get(1);            binding = lookup(securityDomainCtx, request);        }        return binding;    }
private SecurityDomainContext lookupSecurityDomain(final JNDIBasedSecurityManagement securityManagement,            final ConcurrentHashMap<String, SecurityDomainContext> securityManagerMap, final String securityDomain)            throws Exception {        SecurityDomainContext sdc = securityManagerMap.get(securityDomain);        if (sdc == null) {            sdc = securityManagement.createSecurityDomainContext(securityDomain, new DefaultAuthenticationCacheFactory());            securityManagerMap.put(securityDomain, sdc);        }        return sdc;    }
private void loadIdsManually() {        implIds.put("main", ModuleIdentifier.create(IMPL_MODULE));        apiIds.put("main", ModuleIdentifier.create(API_MODULE));        injectionIds.put("main", ModuleIdentifier.create(INJECTION_MODULE));        allVersions.add("main");        activeVersions.add("main");    }
private void checkVersionIntegrity() {        activeVersions.addAll(allVersions);        for (String version : allVersions) {            if (!apiIds.containsKey(version)) {                JSFLogger.ROOT_LOGGER.missingJSFModule(version, API_MODULE);                activeVersions.remove(version);            }            if (!implIds.containsKey(version)) {                JSFLogger.ROOT_LOGGER.missingJSFModule(version, IMPL_MODULE);                activeVersions.remove(version);            }            if (!injectionIds.containsKey(version)) {                JSFLogger.ROOT_LOGGER.missingJSFModule(version, INJECTION_MODULE);                activeVersions.remove(version);            }        }    }
String computeSlot(String jsfVersion) {        if (jsfVersion == null) return defaultSlot;        if (JsfVersionMarker.JSF_2_0.equals(jsfVersion)) return defaultSlot;        return jsfVersion;    }
@Override    public void initialize(final ExtensionContext context) {        JSFLogger.ROOT_LOGGER.debug("Activating JSF(Mojarra) Extension");        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        subsystem.registerSubsystemModel(JSFResourceDefinition.INSTANCE);        subsystem.registerXMLElementWriter(JSFSubsystemParser_1_1.INSTANCE);    }
@Override    public void initializeParsers(final ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JSFExtension.NAMESPACE_1_0, () -> JSFSubsystemParser_1_0.INSTANCE);        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, JSFExtension.NAMESPACE_1_1, () -> JSFSubsystemParser_1_1.INSTANCE);    }
@Override    public void start(StartContext context) throws StartException {        SecurityLogger.ROOT_LOGGER.debugf("Starting SecurityManagementService");        // set properties of JNDIBasedSecurityManagement        JNDIBasedSecurityManagement securityManagement = new JNDIBasedSecurityManagement(serviceModuleLoaderValue.getValue());        securityManagement.setAuthenticationManagerClassName(authenticationManagerClassName);        securityManagement.setDeepCopySubjectMode(deepCopySubjectMode);        securityManagement.setCallbackHandlerClassName(callbackHandlerClassName);        securityManagement.setAuthorizationManagerClassName(authorizationManagerClassName);        securityManagement.setAuditManagerClassName(auditManagerClassName);        securityManagement.setIdentityTrustManagerClassName(identityTrustManagerClassName);        securityManagement.setMappingManagerClassName(mappingManagerClassName);        this.securityManagement = securityManagement;        previousSecurityManagement = SecurityFactory.getSecurityManagement();        SecurityFactory.setSecurityManagement(securityManagement);    }
public Object getInstance() {        ManagedReference managedReference = (ManagedReference) getInstanceData(INSTANCE_KEY);        if(managedReference == null) {            //can happen if around construct chain returns null            return null;        }        return managedReference.getInstance();    }
public Interceptor getInterceptor(final Method method) throws IllegalStateException {        Interceptor interceptor = methodMap.get(method);        if (interceptor == null) {            throw EeLogger.ROOT_LOGGER.methodNotFound(method);        }        return interceptor;    }
public final void destroy() {        if (doneUpdater.compareAndSet(this, 0, 1)) try {            preDestroy();            final Object instance = getInstance();            if (instance != null) {                final InterceptorContext interceptorContext = prepareInterceptorContext();                interceptorContext.setTarget(instance);                interceptorContext.putPrivateData(InvocationType.class, InvocationType.PRE_DESTROY);                preDestroy.processInvocation(interceptorContext);            }        } catch (Exception e) {            ROOT_LOGGER.componentDestroyFailure(e, this);        } finally {            component.finishDestroy();        }    }
private void configureCredential(List<ConfigProperty> properties) {        // if a credential-reference has been defined, get the password property from it        if (credentialSourceSupplier != null) {            try {                CredentialSource credentialSource = credentialSourceSupplier.get();                if (credentialSource != null) {                    char[] password = credentialSource.getCredential(PasswordCredential.class).getPassword(ClearPassword.class).getPassword();                    if (password != null) {                        // add the password property                        properties.add(simpleProperty15("password", String.class.getName(), new String(password)));                    }                }            } catch (Exception e) {                throw new RuntimeException(e);            }        }    }
public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        final ServiceModuleLoader loader = deploymentUnit.getAttachment(Attachments.SERVICE_MODULE_LOADER);        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {            return; // Skip non web deployments        }        WarMetaData warMetaData = deploymentUnit.getAttachment(WarMetaData.ATTACHMENT_KEY);        assert warMetaData != null;        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);        if (module == null) {            throw UndertowLogger.ROOT_LOGGER.failedToResolveModule(deploymentUnit);        }        final ClassLoader classLoader = module.getClassLoader();        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);        if (scisMetaData == null) {            scisMetaData = new ScisMetaData();            deploymentUnit.putAttachment(ScisMetaData.ATTACHMENT_KEY, scisMetaData);        }        Set<ServletContainerInitializer> scis = scisMetaData.getScis();        Set<Class<? extends ServletContainerInitializer>> sciClasses = new HashSet<>();        if (scis == null) {            scis = new LinkedHashSet<>();            scisMetaData.setScis(scis);        }        Map<ServletContainerInitializer, Set<Class<?>>> handlesTypes = scisMetaData.getHandlesTypes();        if (handlesTypes == null) {            handlesTypes = new HashMap<ServletContainerInitializer, Set<Class<?>>>();            scisMetaData.setHandlesTypes(handlesTypes);        }        // Find the SCIs from shared modules        for (ModuleDependency dependency : moduleSpecification.getAllDependencies()) {            // Should not include SCI if services is not included            if (!dependency.isImportServices()) {                continue;            }            try {                Module depModule = loader.loadModule(dependency.getIdentifier());                ServiceLoader<ServletContainerInitializer> serviceLoader = depModule.loadService(ServletContainerInitializer.class);                for (ServletContainerInitializer service : serviceLoader) {                    if(sciClasses.add(service.getClass())) {                        scis.add(service);                    }                }            } catch (ModuleLoadException e) {                if (!dependency.isOptional()) {                    throw UndertowLogger.ROOT_LOGGER.errorLoadingSCIFromModule(dependency.getIdentifier().toString(), e);                }            }        }        // Find local ServletContainerInitializer services        List<String> order = warMetaData.getOrder();        Map<String, VirtualFile> localScis = warMetaData.getScis();        if (order != null && localScis != null) {            for (String jar : order) {                VirtualFile sci = localScis.get(jar);                if (sci != null) {                    scis.addAll(loadSci(classLoader, sci, jar, true, sciClasses));                }            }        }        //SCI's deployed in the war itself        if(localScis != null) {            VirtualFile warDeployedScis = localScis.get("classes");            if(warDeployedScis != null) {                scis.addAll(loadSci(classLoader, warDeployedScis, deploymentUnit.getName(), true, sciClasses));            }        }        // Process HandlesTypes for ServletContainerInitializer        Map<Class<?>, Set<ServletContainerInitializer>> typesMap = new HashMap<Class<?>, Set<ServletContainerInitializer>>();        for (ServletContainerInitializer service : scis) {            if (service.getClass().isAnnotationPresent(HandlesTypes.class)) {                HandlesTypes handlesTypesAnnotation = service.getClass().getAnnotation(HandlesTypes.class);                Class<?>[] typesArray = handlesTypesAnnotation.value();                if (typesArray != null) {                    for (Class<?> type : typesArray) {                        Set<ServletContainerInitializer> servicesSet = typesMap.get(type);                        if (servicesSet == null) {                            servicesSet = new HashSet<ServletContainerInitializer>();                            typesMap.put(type, servicesSet);                        }                        servicesSet.add(service);                        handlesTypes.put(service, new HashSet<Class<?>>());                    }                }            }        }        Class<?>[] typesArray = typesMap.keySet().toArray(new Class<?>[0]);        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);        if (index == null) {            throw UndertowLogger.ROOT_LOGGER.unableToResolveAnnotationIndex(deploymentUnit);        }        final CompositeIndex parent;        if(deploymentUnit.getParent() != null) {            parent = deploymentUnit.getParent().getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);        } else {            parent = null;        }        //WFLY-4205, look in the parent as well as the war        CompositeIndex parentIndex = deploymentUnit.getParent() == null ? null : deploymentUnit.getParent().getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);        // Find classes which extend, implement, or are annotated by HandlesTypes        for (Class<?> type : typesArray) {            DotName className = DotName.createSimple(type.getName());            Set<ClassInfo> classInfos = new HashSet<>();            classInfos.addAll(processHandlesType(className, type, index, parent));            if(parentIndex != null) {                classInfos.addAll(processHandlesType(className, type, parentIndex, parent));            }            Set<Class<?>> classes = loadClassInfoSet(classInfos, classLoader);            Set<ServletContainerInitializer> sciSet = typesMap.get(type);            for (ServletContainerInitializer sci : sciSet) {                handlesTypes.get(sci).addAll(classes);            }        }    }
protected void populateModel(ModelNode operation, ModelNode timerServiceModel) throws OperationFailedException {        for (AttributeDefinition attr : TimerServiceResourceDefinition.ATTRIBUTES.values()) {            attr.validateAndSet(operation, timerServiceModel);        }    }
private TypeCode getConstantTypeCode(Class cls)            throws IRConstructionException {        if (cls == null)            throw IIOPLogger.ROOT_LOGGER.invalidNullClass();        TypeCode ret = constantTypeCodeMap.get(cls);        if (ret == null)            throw IIOPLogger.ROOT_LOGGER.badClassForConstant(cls.getName());        return ret;    }
private TypeCode getTypeCode(Class cls)            throws IRConstructionException, RMIIIOPViolationException {        if (cls == null)            throw IIOPLogger.ROOT_LOGGER.invalidNullClass();        TypeCode ret = (TypeCode) typeCodeMap.get(cls);        if (ret == null) {            if (cls == java.lang.String.class)                ret = getJavaLangString().type();            else if (cls == java.lang.Object.class)                ret = getJavaLang_Object().type();            else if (cls == java.lang.Class.class)                ret = getJavaxRmiCORBAClassDesc().type();            else if (cls == java.io.Serializable.class)                ret = getJavaIoSerializable().type();            else if (cls == java.io.Externalizable.class)                ret = getJavaIoExternalizable().type();            else {                // Try adding a mapping of the the class to the IR                addClass(cls);                // Lookup again, it should be there now.                ret = (TypeCode) typeCodeMap.get(cls);                if (ret == null)                    throw IIOPLogger.ROOT_LOGGER.unknownTypeCodeForClass(cls.getName());                else                    return ret;            }            typeCodeMap.put(cls, ret);        }        return ret;    }
private void addTypeCode(Class cls, TypeCode typeCode)            throws IRConstructionException {        if (cls == null)            throw IIOPLogger.ROOT_LOGGER.invalidNullClass();        TypeCode tc = (TypeCode) typeCodeMap.get(cls);        if (tc != null)            throw IIOPLogger.ROOT_LOGGER.duplicateTypeCodeForClass(cls.getName());        typeCodeMap.put(cls, typeCode);    }
private AliasDefImpl getJavaLang_Object()            throws IRConstructionException {        if (javaLang_Object == null) {            final String id = "IDL:java/lang/_Object:1.0";            final String name = "_Object";            final String version = "1.0";            // Get module to add typedef to.            ModuleDefImpl m = ensurePackageExists("java.lang");            TypeCode typeCode = orb.create_alias_tc(id, name,                    orb.get_primitive_tc(TCKind.tk_any));//         TypeCode typeCode = new TypeCodeImpl(TCKind._tk_alias, id, name,//                                            new TypeCodeImpl(TCKind.tk_any));            javaLang_Object = new AliasDefImpl(id, name, version, m,                    typeCode, impl);            m.add(name, javaLang_Object);        }        return javaLang_Object;    }
private ValueDefImpl getJavaLangString()            throws IRConstructionException {        if (javaLangString == null) {            ModuleDefImpl m = ensurePackageExists("org.omg.CORBA");            ValueDefImpl val =                    new ValueDefImpl("IDL:omg.org/CORBA/WStringValue:1.0",                            "WStringValue", "1.0",                            m, false, false,                            new String[0], new String[0],                            orb.get_primitive_tc(TCKind.tk_null),                            impl);            ValueMemberDefImpl vmdi =                    new ValueMemberDefImpl("IDL:omg.org/CORBA/WStringValue.data:1.0",                            "data", "1.0", orb.create_wstring_tc(0),                            true, val, impl);            val.add("data", vmdi);            m.add("WStringValue", val);            javaLangString = val;        }        return javaLangString;    }
private ValueDefImpl getJavaxRmiCORBAClassDesc()            throws IRConstructionException, RMIIIOPViolationException {        if (javaxRmiCORBAClassDesc == null) {            // Just map the right value class            ValueAnalysis va = ValueAnalysis.getValueAnalysis(javax.rmi.CORBA.ClassDesc.class);            ValueDefImpl val = addValue(va);            // Warn if it does not conform to the specification.            if (!"RMI:javax.rmi.CORBA.ClassDesc:B7C4E3FC9EBDC311:CFBF02CF5294176B".equals(val.id()))                IIOPLogger.ROOT_LOGGER.warnClassDescDoesNotConformToSpec();            javaxRmiCORBAClassDesc = val;        }        return javaxRmiCORBAClassDesc;    }
private ModuleDefImpl ensurePackageExists(LocalContainer c,                                              String previous,                                              String remainder)            throws IRConstructionException {        if ("".equals(remainder))            return (ModuleDefImpl) c; // done        int idx = remainder.indexOf('.');        String base;        if (idx == -1)            base = remainder;        else            base = remainder.substring(0, idx);        base = Util.javaToIDLName(base);        if (previous.equals(""))            previous = base;        else            previous = previous + "/" + base;        if (idx == -1)            remainder = "";        else            remainder = remainder.substring(idx + 1);        LocalContainer next = null;        LocalContained contained = (LocalContained) c._lookup(base);        if (contained instanceof LocalContainer)            next = (LocalContainer) contained;        else if (contained != null)            throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();        if (next == null) {            String id = "IDL:" + previous + ":1.0";            // Create module            ModuleDefImpl m = new ModuleDefImpl(id, base, "1.0", c, impl);            c.add(base, m);            if (idx == -1)                return m; // done            next = (LocalContainer) c._lookup(base); // Better be there now...        } else // Check that next _is_ a module            if (next.def_kind() != DefinitionKind.dk_Module)                throw IIOPLogger.ROOT_LOGGER.collisionWhileCreatingPackage();        return ensurePackageExists(next, previous, remainder);    }
private void addConstants(LocalContainer container,                              ContainerAnalysis ca)            throws RMIIIOPViolationException, IRConstructionException {        ConstantAnalysis[] consts = ca.getConstants();        for (int i = 0; i < consts.length; ++i) {            ConstantDefImpl cDef;            String cid = ca.getMemberRepositoryId(consts[i].getJavaName());            String cName = consts[i].getIDLName();            Class cls = consts[i].getType();            TypeCode typeCode = getConstantTypeCode(cls);            Any value = orb.create_any();            consts[i].insertValue(value);            cDef = new ConstantDefImpl(cid, cName, "1.0",                    typeCode, value, container, impl);            container.add(cName, cDef);        }    }
private void addAttributes(LocalContainer container,                               ContainerAnalysis ca)            throws RMIIIOPViolationException, IRConstructionException {        AttributeAnalysis[] attrs = ca.getAttributes();        for (int i = 0; i < attrs.length; ++i) {            AttributeDefImpl aDef;            String aid = ca.getMemberRepositoryId(attrs[i].getJavaName());            String aName = attrs[i].getIDLName();            Class cls = attrs[i].getCls();            TypeCode typeCode = getTypeCode(cls);            aDef = new AttributeDefImpl(aid, aName, "1.0", attrs[i].getMode(),                    typeCode, container, impl);            container.add(aName, aDef);        }    }
private void addOperations(LocalContainer container,                               ContainerAnalysis ca)            throws RMIIIOPViolationException, IRConstructionException {        OperationAnalysis[] ops = ca.getOperations();        for (int i = 0; i < ops.length; ++i) {            OperationDefImpl oDef;            String oName = ops[i].getIDLName();            String oid = ca.getMemberRepositoryId(oName);            Class cls = ops[i].getReturnType();            TypeCode typeCode = getTypeCode(cls);            ParameterAnalysis[] ps = ops[i].getParameters();            ParameterDescription[] params = new ParameterDescription[ps.length];            for (int j = 0; j < ps.length; ++j) {                params[j] = new ParameterDescription(ps[j].getIDLName(),                        getTypeCode(ps[j].getCls()),                        null, // filled in later                        ParameterMode.PARAM_IN);            }            ExceptionAnalysis[] exc = ops[i].getMappedExceptions();            ExceptionDef[] exceptions = new ExceptionDef[exc.length];            for (int j = 0; j < exc.length; ++j) {                ExceptionDefImpl e = addException(exc[j]);                exceptions[j] = ExceptionDefHelper.narrow(e.getReference());            }            oDef = new OperationDefImpl(oid, oName, "1.0", container,                    typeCode, params, exceptions, impl);            container.add(oName, oDef);        }    }
private String[] addInterfaces(ContainerAnalysis ca)            throws RMIIIOPViolationException, IRConstructionException {        InterfaceAnalysis[] interfaces = ca.getInterfaces();        List base_interfaces = new ArrayList();        for (int i = 0; i < interfaces.length; ++i) {            InterfaceDefImpl idi = addInterface(interfaces[i]);            base_interfaces.add(idi.id());        }        String[] strArr = new String[base_interfaces.size()];        return (String[]) base_interfaces.toArray(strArr);    }
private String[] addAbstractBaseValuetypes(ContainerAnalysis ca)            throws RMIIIOPViolationException, IRConstructionException {        ValueAnalysis[] abstractValuetypes = ca.getAbstractBaseValuetypes();        List abstract_base_valuetypes = new ArrayList();        for (int i = 0; i < abstractValuetypes.length; ++i) {            ValueDefImpl vdi = addValue(abstractValuetypes[i]);            abstract_base_valuetypes.add(vdi.id());        }        String[] strArr = new String[abstract_base_valuetypes.size()];        return (String[]) abstract_base_valuetypes.toArray(strArr);    }
private void addClass(Class cls)            throws RMIIIOPViolationException, IRConstructionException {        if (cls.isPrimitive())            return; // No need to add primitives.        if (cls.isArray()) {            // Add array mapping            addArray(cls);        } else if (cls.isInterface()) {            if (!RmiIdlUtil.isAbstractValueType(cls)) {                // Analyse the interface                InterfaceAnalysis ia = InterfaceAnalysis.getInterfaceAnalysis(cls);                // Add analyzed interface (which may be abstract)                addInterface(ia);            } else {                // Analyse the value                ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);                // Add analyzed value                addValue(va);            }        } else if (Exception.class.isAssignableFrom(cls)) { // Exception type.            // Analyse the exception            ExceptionAnalysis ea = ExceptionAnalysis.getExceptionAnalysis(cls);            // Add analyzed exception            addException(ea);        } else { // Got to be a value type.            // Analyse the value            ValueAnalysis va = ValueAnalysis.getValueAnalysis(cls);            // Add analyzed value            addValue(va);        }    }
private ValueBoxDefImpl addArray(Class cls)            throws RMIIIOPViolationException, IRConstructionException {        if (!cls.isArray())            throw IIOPLogger.ROOT_LOGGER.classIsNotArray(cls.getName());        ValueBoxDefImpl vbDef;        // Lookup: Has it already been added?        vbDef = (ValueBoxDefImpl) arrayMap.get(cls);        if (vbDef != null)            return vbDef; // Yes, just return it.        int dimensions = 0;        Class compType = cls;        do {            compType = compType.getComponentType();            ++dimensions;        } while (compType.isArray());        String typeName;        String moduleName;        TypeCode typeCode;        if (compType.isPrimitive()) {            if (compType == Boolean.TYPE) {                typeName = "boolean";                typeCode = orb.get_primitive_tc(TCKind.tk_boolean);            } else if (compType == Character.TYPE) {                typeName = "wchar";                typeCode = orb.get_primitive_tc(TCKind.tk_wchar);            } else if (compType == Byte.TYPE) {                typeName = "octet";                typeCode = orb.get_primitive_tc(TCKind.tk_octet);            } else if (compType == Short.TYPE) {                typeName = "short";                typeCode = orb.get_primitive_tc(TCKind.tk_short);            } else if (compType == Integer.TYPE) {                typeName = "long";                typeCode = orb.get_primitive_tc(TCKind.tk_long);            } else if (compType == Long.TYPE) {                typeName = "long_long";                typeCode = orb.get_primitive_tc(TCKind.tk_longlong);            } else if (compType == Float.TYPE) {                typeName = "float";                typeCode = orb.get_primitive_tc(TCKind.tk_float);            } else if (compType == Double.TYPE) {                typeName = "double";                typeCode = orb.get_primitive_tc(TCKind.tk_double);            } else {                throw IIOPLogger.ROOT_LOGGER.unknownPrimitiveType(compType.getName());            }            moduleName = "org.omg.boxedRMI";        } else {            typeCode = getTypeCode(compType); // map the component type.            if (compType == java.lang.String.class)                typeName = getJavaLangString().name();            else if (compType == java.lang.Object.class)                typeName = getJavaLang_Object().name();            else if (compType == java.lang.Class.class)                typeName = getJavaxRmiCORBAClassDesc().name();            else if (compType == java.io.Serializable.class)                typeName = getJavaIoSerializable().name();            else if (compType == java.io.Externalizable.class)                typeName = getJavaIoExternalizable().name();            else if (compType.isInterface() &&                    !RmiIdlUtil.isAbstractValueType(compType))                typeName = ((InterfaceDefImpl) interfaceMap.get(compType)).name();            else if (Exception.class.isAssignableFrom(compType)) // exception type                typeName = ((ExceptionDefImpl) exceptionMap.get(compType)).name();            else // must be value type                typeName = ((ValueDefImpl) valueMap.get(compType)).name();            moduleName = "org.omg.boxedRMI." + compType.getPackage().getName();        }        // Get module to add array to.        ModuleDefImpl m = ensurePackageExists(moduleName);        // Create an array of the types for the dimensions        Class[] types = new Class[dimensions];        types[dimensions - 1] = cls;        for (int i = dimensions - 2; i >= 0; --i)            types[i] = types[i + 1].getComponentType();        // Create boxed sequences for all dimensions.        for (int i = 0; i < dimensions; ++i) {            Class type = types[i];            typeCode = orb.create_sequence_tc(0, typeCode);            vbDef = (ValueBoxDefImpl) arrayMap.get(type);            if (vbDef == null) {                String id = Util.getIRIdentifierOfClass(type);                SequenceDefImpl sdi = new SequenceDefImpl(typeCode, impl);                String name = "seq" + (i + 1) + "_" + typeName;//            TypeCode boxTypeCode = new TypeCodeImpl(TCKind._tk_value_box,//                                                    id, name, typeCode);                TypeCode boxTypeCode = orb.create_value_box_tc(id, name, typeCode);                vbDef = new ValueBoxDefImpl(id, name, "1.0", m, boxTypeCode, impl);                addTypeCode(type, vbDef.type());                m.add(name, vbDef);                impl.putSequenceImpl(id, typeCode, sdi, vbDef);                arrayMap.put(type, vbDef); // Remember we mapped this.                typeCode = boxTypeCode;            } else                typeCode = vbDef.type();        }        // Return the box of highest dimension.        return vbDef;    }
private InterfaceDefImpl addInterface(InterfaceAnalysis ia)            throws RMIIIOPViolationException, IRConstructionException {        InterfaceDefImpl iDef;        Class cls = ia.getCls();        // Lookup: Has it already been added?        iDef = (InterfaceDefImpl) interfaceMap.get(cls);        if (iDef != null)            return iDef; // Yes, just return it.        // Get module to add interface to.        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());        // Add superinterfaces        String[] base_interfaces = addInterfaces(ia);        // Create the interface        String base = cls.getName();        base = base.substring(base.lastIndexOf('.') + 1);        base = Util.javaToIDLName(base);        iDef = new InterfaceDefImpl(ia.getRepositoryId(),                base, "1.0", m,                base_interfaces, impl);        addTypeCode(cls, iDef.type());        m.add(base, iDef);        interfaceMap.put(cls, iDef); // Remember we mapped this.        // Fill in constants        addConstants(iDef, ia);        // Add attributes        addAttributes(iDef, ia);        // Fill in operations        addOperations(iDef, ia);        return iDef;    }
private ValueDefImpl addValue(ValueAnalysis va)            throws RMIIIOPViolationException, IRConstructionException {        ValueDefImpl vDef;        Class cls = va.getCls();        // Lookup: Has it already been added?        vDef = (ValueDefImpl) valueMap.get(cls);        if (vDef != null)            return vDef; // Yes, just return it.        // Get module to add value to.        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());        // Add implemented interfaces        String[] supported_interfaces = addInterfaces(va);        // Add abstract base valuetypes        String[] abstract_base_valuetypes = addAbstractBaseValuetypes(va);        // Add superclass        ValueDefImpl superValue = null;        ValueAnalysis superAnalysis = va.getSuperAnalysis();        if (superAnalysis != null)            superValue = addValue(superAnalysis);        // Create the value        String base = cls.getName();        base = base.substring(base.lastIndexOf('.') + 1);        base = Util.javaToIDLName(base);        TypeCode baseTypeCode;        if (superValue == null)            baseTypeCode = orb.get_primitive_tc(TCKind.tk_null);        else            baseTypeCode = superValue.type();        vDef = new ValueDefImpl(va.getRepositoryId(), base, "1.0",                m,                va.isAbstractValue(),                va.isCustom(),                supported_interfaces,                abstract_base_valuetypes,                baseTypeCode,                impl);        addTypeCode(cls, vDef.type());        m.add(base, vDef);        valueMap.put(cls, vDef); // Remember we mapped this.        // Fill in constants.        addConstants(vDef, va);        // Add value members        ValueMemberAnalysis[] vmas = va.getMembers();        for (int i = 0; i < vmas.length; ++i) {            ValueMemberDefImpl vmDef;            String vmid = va.getMemberRepositoryId(vmas[i].getJavaName());            String vmName = vmas[i].getIDLName();            Class vmCls = vmas[i].getCls();            TypeCode typeCode = getTypeCode(vmCls);            boolean vmPublic = vmas[i].isPublic();            vmDef = new ValueMemberDefImpl(vmid, vmName, "1.0",                    typeCode, vmPublic, vDef, impl);            vDef.add(vmName, vmDef);        }        // Add attributes        addAttributes(vDef, va);        // TODO: Fill in operations.        return vDef;    }
private ExceptionDefImpl addException(ExceptionAnalysis ea)            throws RMIIIOPViolationException, IRConstructionException {        ExceptionDefImpl eDef;        Class cls = ea.getCls();        // Lookup: Has it already been added?        eDef = (ExceptionDefImpl) exceptionMap.get(cls);        if (eDef != null)            return eDef; // Yes, just return it.        // 1.3.7.1: map to value        ValueDefImpl vDef = addValue(ea);        // 1.3.7.2: map to exception        ModuleDefImpl m = ensurePackageExists(cls.getPackage().getName());        String base = cls.getName();        base = base.substring(base.lastIndexOf('.') + 1);        if (base.endsWith("Exception"))            base = base.substring(0, base.length() - 9);        base = Util.javaToIDLName(base + "Ex");        StructMember[] members = new StructMember[1];        members[0] = new StructMember("value", vDef.type(), null/*ignored*/);        TypeCode typeCode                = orb.create_exception_tc(ea.getExceptionRepositoryId(),                base, members);        eDef = new ExceptionDefImpl(ea.getExceptionRepositoryId(), base, "1.0",                typeCode, vDef, m, impl);        m.add(base, eDef);        exceptionMap.put(cls, eDef); // Remember we mapped this.        return eDef;    }
private String getClassLevelInjectionType(final AnnotationInstance annotation) {        boolean isPC = annotation.name().local().equals("PersistenceContext");        return isPC ? ENTITY_MANAGER_CLASS : ENTITY_MANAGERFACTORY_CLASS;    }
private void registerConfigMapping(String endpointClassName, EndpointConfig config, DeploymentUnit unit) {        WSEndpointConfigMapping mapping = unit.getAttachment(WSAttachmentKeys.WS_ENDPOINT_CONFIG_MAPPING_KEY);        if (mapping == null) {            mapping = new WSEndpointConfigMapping();            unit.putAttachment(WSAttachmentKeys.WS_ENDPOINT_CONFIG_MAPPING_KEY, mapping);        }        mapping.registerEndpointConfig(endpointClassName, config);    }
private boolean checkJtsEnabled(final OperationContext context) {        try {            final ModelNode jtsNode = context.readResourceFromRoot(PathAddress.pathAddress("subsystem", "transactions"), false)                    .getModel().get("jts");            return jtsNode.isDefined() ? jtsNode.asBoolean() : false;        } catch (NoSuchResourceException ex) {            return false;        }    }
public void start(final StartContext context) throws StartException {        if(store == null) {            final ServiceRegistry serviceRegistry = context.getController().getServiceContainer();            final ServiceName serviceNameBase = context.getController().getName();            final ServiceTarget serviceTarget = context.getChildTarget();            store = readOnly ? new ServiceBasedNamingStore(serviceRegistry, serviceNameBase) : new WritableServiceBasedNamingStore(serviceRegistry, serviceNameBase, serviceTarget);        }    }
public void stop(StopContext context) {        if(store != null) {            try {                store.close();                store = null;            } catch (NamingException e) {                throw NamingLogger.ROOT_LOGGER.failedToDestroyRootContext(e);            }        }    }
@Override    public void validateParameter(String parameterName, ModelNode value) throws OperationFailedException {        super.validateParameter(parameterName, value);        if (value.isDefined() && value.getType() != ModelType.EXPRESSION) {            String address = value.asString();            if (address.startsWith("[") && address.endsWith("]")) {                address = address.substring(1, address.length() - 1);            }            if (!AddressUtils.isValidAddress(address)) {                throw new OperationFailedException(Messages.MESSAGES.invalidAddressProvided(address));            }        }    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        final ModuleLoader moduleLoader = Module.getBootModuleLoader();        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, PICKETBOX_ID, false, false, false, false));        //add the remoting login module        final ModuleDependency remoting = new ModuleDependency(moduleLoader, REMOTING_LOGIN_MODULE, false, false, false, false);        remoting.addImportFilter(PathFilters.is(RemotingLoginModule.class.getName().replace(".","/")), true);        moduleSpecification.addSystemDependency(remoting);        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, JACC_API, false, false, true, false));        moduleSpecification.addSystemDependency(new ModuleDependency(moduleLoader, AUTH_MESSAGE_API, false, false, true, false));    }
private void configureTokenProviders() {        STSType stsType = getFederationService().getValue().getStsType();        if (stsType != null) {            int tokenTimeout = stsType.getTokenTimeout();            int clockSkew = stsType.getClockSkew();            STSType providerStsType = getPicketLinkType().getStsType();            providerStsType.setTokenTimeout(tokenTimeout);            providerStsType.setClockSkew(clockSkew);            List<TokenProviderType> tokenProviders = providerStsType.getTokenProviders().getTokenProvider();            for (TokenProviderType tokenProviderType : tokenProviders) {                if (tokenProviderType.getTokenType().equals(JBossSAMLURIConstants.ASSERTION_NSURI.get())) {                    KeyValueType keyValueTypeTokenTimeout = new KeyValueType();                    keyValueTypeTokenTimeout.setKey(GeneralConstants.ASSERTIONS_VALIDITY);                    keyValueTypeTokenTimeout.setValue(String.valueOf(tokenTimeout));                    KeyValueType keyValueTypeClockSkew = new KeyValueType();                    keyValueTypeClockSkew.setKey(GeneralConstants.CLOCK_SKEW);                    keyValueTypeClockSkew.setValue(String.valueOf(clockSkew));                    tokenProviderType.add(keyValueTypeTokenTimeout);                    tokenProviderType.add(keyValueTypeClockSkew);                }            }        }    }
private void configureHandlers() {        Handlers actualHandlers = new Handlers();        actualHandlers.setHandlers(new ArrayList<Handler>());        if (this.handlers.isEmpty()) {            for (Class<? extends SAML2Handler> commonHandlerClass : getDefaultHandlers()) {                addHandler(commonHandlerClass, actualHandlers);            }        } else {            for (Handler handler : this.handlers) {                actualHandlers.add(handler);            }        }        getPicketLinkType().setHandlers(actualHandlers);    }
public static void checkAllowed(final MethodType methodType) {        final InterceptorContext context = CurrentInvocationContext.get();        if (context == null) {            return;        }        final Component component = context.getPrivateData(Component.class);        if (!(component instanceof EJBComponent)) {            return;        }        final InvocationType invocationType = context.getPrivateData(InvocationType.class);        ((EJBComponent) component).getAllowedMethodsInformation().realCheckPermission(methodType, invocationType);    }
private void checkTransactionSync(MethodType methodType) {        //first we have to check the synchronization status        //as the sync is not affected by the current invocation        final CurrentSynchronizationCallback.CallbackType currentSync = CurrentSynchronizationCallback.get();        if (currentSync != null) {            if (deniedSyncMethods.contains(new DeniedSyncMethodKey(currentSync, methodType))) {                throwException(methodType, currentSync);            }        }    }
protected void throwException(MethodType methodType, InvocationType invocationType) {        throw EjbLogger.ROOT_LOGGER.cannotCallMethod(methodType.getLabel(), invocationType.getLabel());    }
protected void throwException(MethodType methodType, CurrentSynchronizationCallback.CallbackType callback) {        throw EjbLogger.ROOT_LOGGER.cannotCallMethod(methodType.getLabel(), callback.name());    }
private String getJBossAppSecurityDomain(final DeploymentUnit deploymentUnit) {        String securityDomain = null;        DeploymentUnit parent = deploymentUnit.getParent();        if (parent != null) {            final EarMetaData jbossAppMetaData = parent.getAttachment(Attachments.EAR_METADATA);            if (jbossAppMetaData instanceof JBossAppMetaData) {                securityDomain = ((JBossAppMetaData) jbossAppMetaData).getSecurityDomain();            }        }        return securityDomain;    }
private Set<String> getAllComponentClasses(DeploymentUnit deploymentUnit, CompositeIndex index, WarMetaData metaData, TldsMetaData tldsMetaData) {        final Set<String> classes = new HashSet<String>();        getAllComponentClasses(metaData.getMergedJBossWebMetaData(), classes);        if (tldsMetaData == null)            return classes;        if (tldsMetaData.getSharedTlds(deploymentUnit) != null)            for (TldMetaData tldMetaData : tldsMetaData.getSharedTlds(deploymentUnit)) {                getAllComponentClasses(tldMetaData, classes);            }        if (tldsMetaData.getTlds() != null)            for (Map.Entry<String, TldMetaData> tldMetaData : tldsMetaData.getTlds().entrySet()) {                getAllComponentClasses(tldMetaData.getValue(), classes);            }        getAllAsyncListenerClasses(index, classes);        return classes;    }
@Override    public Timer createCalendarTimer(ScheduleExpression schedule) throws IllegalArgumentException,            IllegalStateException, EJBException {        return this.createCalendarTimer(schedule, null);    }
@Override    public Timer createCalendarTimer(ScheduleExpression schedule, TimerConfig timerConfig)            throws IllegalArgumentException, IllegalStateException, EJBException {        assertTimerServiceState();        Serializable info = timerConfig == null ? null : timerConfig.getInfo();        boolean persistent = timerConfig == null || timerConfig.isPersistent();        return this.createCalendarTimer(schedule, info, persistent, null);    }
@Override    public Timer createIntervalTimer(Date initialExpiration, long intervalDuration, TimerConfig timerConfig)            throws IllegalArgumentException, IllegalStateException, EJBException {        assertTimerServiceState();        if (initialExpiration == null) {            throw EJB3_TIMER_LOGGER.initialExpirationIsNullCreatingTimer();        }        if (initialExpiration.getTime() < 0) {            throw EJB3_TIMER_LOGGER.invalidInitialExpiration("initialExpiration.getTime()");        }        if (intervalDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidInitialExpiration("intervalDuration");        }        return this.createTimer(initialExpiration, intervalDuration, timerConfig.getInfo(), timerConfig.isPersistent());    }
@Override    public Timer createIntervalTimer(long initialDuration, long intervalDuration, TimerConfig timerConfig)            throws IllegalArgumentException, IllegalStateException, EJBException {        assertTimerServiceState();        if (initialDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidInitialExpiration("intervalDuration");        }        if (intervalDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidInitialExpiration("intervalDuration");        }        return this.createIntervalTimer(new Date(System.currentTimeMillis() + initialDuration), intervalDuration, timerConfig);    }
@Override    public Timer createSingleActionTimer(Date expiration, TimerConfig timerConfig) throws IllegalArgumentException,            IllegalStateException, EJBException {        assertTimerServiceState();        if (expiration == null) {            throw EJB3_TIMER_LOGGER.expirationIsNull();        }        if (expiration.getTime() < 0) {            throw EJB3_TIMER_LOGGER.invalidExpirationActionTimer();        }        return this.createTimer(expiration, 0, timerConfig.getInfo(), timerConfig.isPersistent());    }
@Override    public Timer createSingleActionTimer(long duration, TimerConfig timerConfig) throws IllegalArgumentException,            IllegalStateException, EJBException {        assertTimerServiceState();        if (duration < 0)            throw EJB3_TIMER_LOGGER.invalidDurationActionTimer();        return createTimer(new Date(System.currentTimeMillis() + duration), 0, timerConfig.getInfo(), timerConfig                .isPersistent());    }
@Override    public Timer createTimer(long duration, Serializable info) throws IllegalArgumentException, IllegalStateException,            EJBException {        assertTimerServiceState();        if (duration < 0)            throw EJB3_TIMER_LOGGER.invalidDurationTimer();        return createTimer(new Date(System.currentTimeMillis() + duration), 0, info, true);    }
@Override    public Timer createTimer(Date expiration, Serializable info) throws IllegalArgumentException, IllegalStateException,            EJBException {        assertTimerServiceState();        if (expiration == null) {            throw EJB3_TIMER_LOGGER.expirationDateIsNull();        }        if (expiration.getTime() < 0) {            throw EJB3_TIMER_LOGGER.invalidExpirationTimer();        }        return this.createTimer(expiration, 0, info, true);    }
@Override    public Timer createTimer(long initialDuration, long intervalDuration, Serializable info)            throws IllegalArgumentException, IllegalStateException, EJBException {        assertTimerServiceState();        if (initialDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidInitialDurationTimer();        }        if (intervalDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidIntervalTimer();        }        return this.createTimer(new Date(System.currentTimeMillis() + initialDuration), intervalDuration, info, true);    }
@Override    public Timer createTimer(Date initialExpiration, long intervalDuration, Serializable info)            throws IllegalArgumentException, IllegalStateException, EJBException {        assertTimerServiceState();        if (initialExpiration == null) {            throw EJB3_TIMER_LOGGER.initialExpirationDateIsNull();        }        if (initialExpiration.getTime() < 0) {            throw EJB3_TIMER_LOGGER.invalidExpirationTimer();        }        if (intervalDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidIntervalDurationTimer();        }        return this.createTimer(initialExpiration, intervalDuration, info, true);    }
@Override    public Collection<Timer> getTimers() throws IllegalStateException, EJBException {        assertTimerServiceState();        Object pk = currentPrimaryKey();        final Set<Timer> activeTimers = new HashSet<Timer>();        // get all active timers for this timerservice        synchronized (this.timers) {            for (final TimerImpl timer : this.timers.values()) {                // Less disruptive way to get WFLY-8457 fixed.                if (timer.isActive() || (!timer.isActive() && timer.getState() == TimerState.ACTIVE)) {                    if (timer.getPrimaryKey() == null || timer.getPrimaryKey().equals(pk)) {                        activeTimers.add(timer);                    }                }            }        }        // get all active timers which are persistent, but haven't yet been        // persisted (waiting for tx to complete) that are in the current transaction        for (final TimerImpl timer : getWaitingOnTxCompletionTimers().values()) {            if (timer.isActive()) {                if (timer.getPrimaryKey() == null || timer.getPrimaryKey().equals(pk)) {                    activeTimers.add(timer);                }            }        }        return activeTimers;    }
@Override    public Collection<Timer> getAllTimers() throws IllegalStateException, EJBException {        // query the registry        if (this.timerServiceRegistry != null) {            return this.timerServiceRegistry.getAllActiveTimers();        }        // if we don't have the registry (shouldn't really happen) which stores the timer services applicable for the EJB module to which        // this timer service belongs, then let's at least return the active timers that are applicable only for this timer service        return this.getTimers();    }
private Timer createTimer(Date initialExpiration, long intervalDuration, Serializable info, boolean persistent) {        if (this.isLifecycleCallbackInvocation() && !this.isSingletonBeanInvocation()) {            throw EJB3_TIMER_LOGGER.failToCreateTimerDoLifecycle();        }        if (initialExpiration == null) {            throw EJB3_TIMER_LOGGER.initialExpirationIsNull();        }        if (intervalDuration < 0) {            throw EJB3_TIMER_LOGGER.invalidIntervalDuration();        }        // create an id for the new timer instance        UUID uuid = UUID.randomUUID();        // create the timer        TimerImpl timer = TimerImpl.builder()                .setNewTimer(true)                .setId(uuid.toString())                .setInitialDate(initialExpiration)                .setRepeatInterval(intervalDuration)                .setInfo(info)                .setPersistent(persistent)                .setPrimaryKey(currentPrimaryKey())                .setTimerState(TimerState.CREATED)                .setTimedObjectId(getInvoker().getTimedObjectId())                .build(this);        // now "start" the timer. This involves, moving the timer to an ACTIVE state        // and scheduling the timer task        this.persistTimer(timer, true);        this.startTimer(timer);        // return the newly created timer        return timer;    }
private TimerImpl createCalendarTimer(ScheduleExpression schedule,                                          Serializable info, boolean persistent, Method timeoutMethod) {        if (this.isLifecycleCallbackInvocation() && !this.isSingletonBeanInvocation()) {            throw EJB3_TIMER_LOGGER.failToCreateTimerDoLifecycle();        }        if (schedule == null) {            throw EJB3_TIMER_LOGGER.scheduleIsNull();        }        // generate an id for the timer        UUID uuid = UUID.randomUUID();        // create the timer        TimerImpl timer = CalendarTimer.builder()                .setAutoTimer(timeoutMethod != null)                .setScheduleExprSecond(schedule.getSecond())                .setScheduleExprMinute(schedule.getMinute())                .setScheduleExprHour(schedule.getHour())                .setScheduleExprDayOfWeek(schedule.getDayOfWeek())                .setScheduleExprDayOfMonth(schedule.getDayOfMonth())                .setScheduleExprMonth(schedule.getMonth())                .setScheduleExprYear(schedule.getYear())                .setScheduleExprStartDate(schedule.getStart())                .setScheduleExprEndDate(schedule.getEnd())                .setScheduleExprTimezone(schedule.getTimezone())                .setTimeoutMethod(timeoutMethod)                .setTimerState(TimerState.CREATED)                .setId(uuid.toString())                .setPersistent(persistent)                .setPrimaryKey(currentPrimaryKey())                .setTimedObjectId(getInvoker().getTimedObjectId())                .setInfo(info)                .setNewTimer(true)                .build(this);        this.persistTimer(timer, true);        // now "start" the timer. This involves, moving the timer to an ACTIVE state        // and scheduling the timer task        this.startTimer(timer);        // return the timer        return timer;    }
public TimerImpl getTimer(TimerHandle handle) {        TimerHandleImpl timerHandle = (TimerHandleImpl) handle;        TimerImpl timer = timers.get(timerHandle.getId());        if (timer != null) {            return timer;        }        return getWaitingOnTxCompletionTimers().get(timerHandle.getId());    }
public void persistTimer(final TimerImpl timer, boolean newTimer) {        if (timer == null) {            return;        }        if (timer.isTimerPersistent()) {            try {                if (timerPersistence.getOptionalValue() == null) {                    EJB3_TIMER_LOGGER.timerPersistenceNotEnable();                    return;                }                final ContextTransactionManager transactionManager = ContextTransactionManager.getInstance();                Transaction clientTX = transactionManager.getTransaction();                if (newTimer || timer.isCanceled()) {                    if( clientTX == null ){                        transactionManager.begin();                    }                    try {                        if( newTimer ) timerPersistence.getValue().addTimer(timer);                        else timerPersistence.getValue().persistTimer(timer);                        if(clientTX == null) transactionManager.commit();                    } catch (Exception e){                        if(clientTX == null) {                            try {                                transactionManager.rollback();                            } catch (Exception ee){                                EjbLogger.EJB3_TIMER_LOGGER.timerUpdateFailedAndRollbackNotPossible(ee);                            }                        }                        throw e;                    }                } else {                    new TaskPostPersist(timer).persistTimer();                }            } catch (Throwable t) {                this.setRollbackOnly();                throw new RuntimeException(t);            }        }    }
public void suspendTimers() {        // get all active timers (persistent/non-persistent inclusive)        Collection<Timer> timers = this.getTimers();        for (Timer timer : timers) {            if (!(timer instanceof TimerImpl)) {                continue;            }            // suspend the timer            ((TimerImpl) timer).suspend();        }    }
public void restoreTimers(final List<ScheduleTimer> autoTimers) {        // get the persisted timers which are considered active        List<TimerImpl> restorableTimers = this.getActivePersistentTimers();        //timers are removed from the list as they are loaded        final List<ScheduleTimer> newAutoTimers = new LinkedList<ScheduleTimer>(autoTimers);        if (EJB3_TIMER_LOGGER.isDebugEnabled()) {            EJB3_TIMER_LOGGER.debug("Found " + restorableTimers.size() + " active persistentTimers for timedObjectId: "                    + getInvoker().getTimedObjectId());        }        // now "start" each of the restorable timer. This involves, moving the timer to an ACTIVE state        // and scheduling the timer task        for (final TimerImpl activeTimer : restorableTimers) {            if (activeTimer.isAutoTimer()) {                CalendarTimer calendarTimer = (CalendarTimer) activeTimer;                boolean found = false;                //so we know we have an auto timer. We need to try and match it up with the auto timers.                ListIterator<ScheduleTimer> it = newAutoTimers.listIterator();                while (it.hasNext()) {                    ScheduleTimer timer = it.next();                    final String methodName = timer.getMethod().getName();                    final String[] params = new String[timer.getMethod().getParameterTypes().length];                    for (int i = 0; i < timer.getMethod().getParameterTypes().length; ++i) {                        params[i] = timer.getMethod().getParameterTypes()[i].getName();                    }                    if (doesTimeoutMethodMatch(calendarTimer.getTimeoutMethod(), methodName, params)) {                        //the timers have the same method.                        //now lets make sure the schedule is the same                        // and the timer does not change the persistence                        if (this.doesScheduleMatch(calendarTimer.getScheduleExpression(), timer.getScheduleExpression()) && timer.getTimerConfig().isPersistent()) {                            it.remove();                            found = true;                            break;                        }                    }                }                if (!found) {                    activeTimer.setTimerState(TimerState.CANCELED, null);                } else {                    // ensure state switch to active if was TIMEOUT in the DB                    // if the persistence is shared it must be ensured to not update                    // timers of other nodes in the cluster                    activeTimer.setTimerState(TimerState.ACTIVE, null);                    calendarTimer.handleRestorationCalculation();                }                try {                    this.persistTimer(activeTimer, false);                } catch (Exception e) {                    EJB3_TIMER_LOGGER.failedToPersistTimerOnStartup(activeTimer, e);                }                if (found) {                    startTimer(activeTimer);                    EJB3_TIMER_LOGGER.debugv("Started existing auto timer: {0}", activeTimer);                }            } else if (!ineligibleTimerStates.contains(activeTimer.getState())) {                startTimer(activeTimer);            }            EJB3_TIMER_LOGGER.debugv("Started timer: {0}",  activeTimer);        }        for (ScheduleTimer timer : newAutoTimers) {            this.loadAutoTimer(timer.getScheduleExpression(), timer.getTimerConfig(), timer.getMethod());        }    }
protected void startTimer(TimerImpl timer) {        // if there's no transaction, then trigger a schedule immediately.        // Else, the timer will be scheduled on tx synchronization callback        if (!transactionActive()) {            this.timers.put(timer.getId(), timer);            // set active if the timer is started if it was read            // from persistence as current running to ensure correct schedule here            timer.setTimerState(TimerState.ACTIVE, null);            // create and schedule a timer task            this.registerTimerResource(timer.getId());            timer.scheduleTimeout(true);        } else {            addWaitingOnTxCompletionTimer(timer);            registerSynchronization(new TimerCreationTransactionSynchronization(timer));        }    }
protected boolean isLifecycleCallbackInvocation() {        final InterceptorContext currentInvocationContext = CurrentInvocationContext.get();        if (currentInvocationContext == null) {            return false;        }        // If the method in current invocation context is null,        // then it represents a lifecycle callback invocation        Method invokedMethod = currentInvocationContext.getMethod();        if (invokedMethod == null) {            // it's a lifecycle callback            return true;        }        // not a lifecycle callback        return false;    }
protected void scheduleTimeout(TimerImpl timer, boolean newTimer) {        synchronized (scheduledTimerFutures) {            if (!newTimer && !scheduledTimerFutures.containsKey(timer.getId())) {                //this timer has been cancelled by another thread. We just return                return;            }            Date nextExpiration = timer.getNextExpiration();            if (nextExpiration == null) {                EJB3_TIMER_LOGGER.nextExpirationIsNull(timer);                return;            }            // create the timer task            final TimerTask<?> timerTask = timer.getTimerTask();            // find out how long is it away from now            long delay = nextExpiration.getTime() - System.currentTimeMillis();            // if in past, then trigger immediately            if (delay < 0) {                delay = 0;            }            long intervalDuration = timer.getInterval();            final Task task = new Task(timerTask, ejbComponentInjectedValue.getValue().getControlPoint());            if (intervalDuration > 0) {                EJB3_TIMER_LOGGER.debugv("Scheduling timer {0} at fixed rate, starting at {1} milliseconds from now with repeated interval={2}",                        timer, delay, intervalDuration);                // schedule the task                this.timerInjectedValue.getValue().scheduleAtFixedRate(task, delay, intervalDuration);                // maintain it in timerservice for future use (like cancellation)                this.scheduledTimerFutures.put(timer.getId(), task);            } else {                EJB3_TIMER_LOGGER.debugv("Scheduling a single action timer {0} starting at {1} milliseconds from now", timer, delay);                // schedule the task                this.timerInjectedValue.getValue().schedule(task, delay);                // maintain it in timerservice for future use (like cancellation)                this.scheduledTimerFutures.put(timer.getId(), task);            }        }    }
protected void cancelTimeout(final TimerImpl timer) {        synchronized (this.scheduledTimerFutures) {            java.util.TimerTask timerTask = this.scheduledTimerFutures.remove(timer.getId());            if (timerTask != null) {                timerTask.cancel();            }        }    }
private Map<String, TimerImpl> getWaitingOnTxCompletionTimers() {        Map<String, TimerImpl> timers = null;        if (getTransaction() != null) {            timers = (Map<String, TimerImpl>) tsr.getResource(waitingOnTxCompletionKey);        }        return timers == null ? Collections.<String, TimerImpl>emptyMap() : timers;    }
private void setRollbackOnly() {        try {            Transaction tx = ContextTransactionManager.getInstance().getTransaction();            if (tx != null) {                tx.setRollbackOnly();            }        } catch (IllegalStateException ise) {            EJB3_TIMER_LOGGER.ignoringException(ise);        } catch (SystemException se) {            EJB3_TIMER_LOGGER.ignoringException(se);        }    }
public boolean shouldRun(TimerImpl timer) {        // check peristent without further check to prevent from Exception (WFLY-6152)        return !timer.isTimerPersistent() || timerPersistence.getValue().shouldRun(timer, ContextTransactionManager.getInstance());    }
private boolean exposesNoInterfaceView(Class<?> beanClass) {        Class<?>[] interfaces = beanClass.getInterfaces();        if (interfaces.length == 0) {            return true;        }        // As per section 4.9.8 (bullet 1.3) of EJB3.1 spec        // java.io.Serializable; java.io.Externalizable; any of the interfaces defined by the javax.ejb        // are excluded from interface check        List<Class<?>> implementedInterfaces = new ArrayList<Class<?>>(Arrays.asList(interfaces));        List<Class<?>> filteredInterfaces = this.filterInterfaces(implementedInterfaces);        // Now that we have removed the interfaces that should be excluded from the check,        // if the filtered interfaces collection is empty then this bean can be considered for no-interface view        return filteredInterfaces.isEmpty();    }
private Class<?> getDefaultLocalView(Class<?> beanClass) {        Class<?>[] interfaces = beanClass.getInterfaces();        if (interfaces.length == 0) {            return null;        }        List<Class<?>> implementedInterfaces = new ArrayList<Class<?>>(Arrays.asList(interfaces));        List<Class<?>> filteredInterfaces = this.filterInterfaces(implementedInterfaces);        if (filteredInterfaces.isEmpty() || filteredInterfaces.size() > 1) {            return null;        }        return filteredInterfaces.get(0);    }
private List<Class<?>> filterInterfaces(List<Class<?>> interfaces) {        if (interfaces == null) {            return null;        }        List<Class<?>> filteredInterfaces = new ArrayList<Class<?>>();        for (Class<?> intf : interfaces) {            if (intf.equals(java.io.Serializable.class)                    || intf.equals(java.io.Externalizable.class)                    || intf.getName().startsWith("javax.ejb.")) {                continue;            }            filteredInterfaces.add(intf);        }        return filteredInterfaces;    }
static void processAcceptors(final OperationContext context, final Configuration configuration, final ModelNode params, final Set<String> bindings) throws OperationFailedException {        final Map<String, TransportConfiguration> acceptors = new HashMap<>();        if (params.hasDefined(ACCEPTOR)) {            for (final Property property : params.get(ACCEPTOR).asPropertyList()) {                final String acceptorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, ACCEPTOR_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(TransportConstants.ALLOWABLE_ACCEPTOR_KEYS, parameters);                final String clazz = config.get(FACTORY_CLASS.getName()).asString();                ModelNode socketBinding = GenericTransportDefinition.SOCKET_BINDING.resolveModelAttribute(context, config);                if (socketBinding.isDefined()) {                    bindings.add(socketBinding.asString());                    // uses the parameters to pass the socket binding name that will be read in ActiveMQServerService.start()                    parameters.put(GenericTransportDefinition.SOCKET_BINDING.getName(), socketBinding.asString());                }                acceptors.put(acceptorName, new TransportConfiguration(clazz, parameters, acceptorName, extraParameters));            }        }        if (params.hasDefined(REMOTE_ACCEPTOR)) {            for (final Property property : params.get(REMOTE_ACCEPTOR).asPropertyList()) {                final String acceptorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, ACCEPTOR_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(TransportConstants.ALLOWABLE_ACCEPTOR_KEYS, parameters);                final String binding = config.get(RemoteTransportDefinition.SOCKET_BINDING.getName()).asString();                bindings.add(binding);                // uses the parameters to pass the socket binding name that will be read in ActiveMQServerService.start()                parameters.put(RemoteTransportDefinition.SOCKET_BINDING.getName(), binding);                acceptors.put(acceptorName, new TransportConfiguration(NettyAcceptorFactory.class.getName(), parameters, acceptorName, extraParameters));            }        }        if (params.hasDefined(IN_VM_ACCEPTOR)) {            for (final Property property : params.get(IN_VM_ACCEPTOR).asPropertyList()) {                final String acceptorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, ACCEPTOR_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(IN_VM_ALLOWABLE_KEYS, parameters);                parameters.put(SERVER_ID_PROP_NAME, InVMTransportDefinition.SERVER_ID.resolveModelAttribute(context, config).asInt());                acceptors.put(acceptorName, new TransportConfiguration(InVMAcceptorFactory.class.getName(), parameters, acceptorName, extraParameters));            }        }        if (params.hasDefined(HTTP_ACCEPTOR)) {            for (final Property property : params.get(HTTP_ACCEPTOR).asPropertyList()) {                final String acceptorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, ACCEPTOR_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(TransportConstants.ALLOWABLE_ACCEPTOR_KEYS, parameters);                parameters.put(TransportConstants.HTTP_UPGRADE_ENABLED_PROP_NAME, true);                acceptors.put(acceptorName, new TransportConfiguration(NettyAcceptorFactory.class.getName(), parameters, acceptorName, extraParameters));            }        }        configuration.setAcceptorConfigurations(new HashSet<>(acceptors.values()));    }
private static Map<String, Object> getExtraParameters(final Set<String> allowedKeys, final Map<String, Object> parameters) {        Map<String, Object> extraParameters = new HashMap<>();        for(Map.Entry<String, Object> parameter : parameters.entrySet()) {            if(!allowedKeys.contains(parameter.getKey())) {                extraParameters.put(parameter.getKey(), parameter.getValue());            }        }        for (String extraParam : extraParameters.keySet()) {            parameters.remove(extraParam);        }        return extraParameters;    }
public static Map<String, Object> getParameters(final OperationContext context, final ModelNode config, final Map<String, String> mapping) throws OperationFailedException {        Map<String, String> fromModel = CommonAttributes.PARAMS.unwrap(context, config);        Map<String, Object> parameters = new HashMap<>();        for (Map.Entry<String, String> entry : fromModel.entrySet()) {            parameters.put(mapping.getOrDefault(entry.getKey(), entry.getKey()), entry.getValue());        }        return parameters;    }
static Map<String, TransportConfiguration> processConnectors(final OperationContext context, final String configServerName, final ModelNode params, final Set<String> bindings) throws OperationFailedException {        final Map<String, TransportConfiguration> connectors = new HashMap<String, TransportConfiguration>();        if (params.hasDefined(CONNECTOR)) {            for (final Property property : params.get(CONNECTOR).asPropertyList()) {                final String connectorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, CONNECTORS_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(TransportConstants.ALLOWABLE_CONNECTOR_KEYS, parameters);                ModelNode socketBinding = GenericTransportDefinition.SOCKET_BINDING.resolveModelAttribute(context, config);                if (socketBinding.isDefined()) {                    bindings.add(socketBinding.asString());                    // uses the parameters to pass the socket binding name that will be read in ActiveMQServerService.start()                    parameters.put(GenericTransportDefinition.SOCKET_BINDING.getName(), socketBinding.asString());                }                final String clazz = FACTORY_CLASS.resolveModelAttribute(context, config).asString();                connectors.put(connectorName, new TransportConfiguration(clazz, parameters, connectorName, extraParameters));            }        }        if (params.hasDefined(REMOTE_CONNECTOR)) {            for (final Property property : params.get(REMOTE_CONNECTOR).asPropertyList()) {                final String connectorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, CONNECTORS_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(TransportConstants.ALLOWABLE_CONNECTOR_KEYS, parameters);                final String binding = config.get(RemoteTransportDefinition.SOCKET_BINDING.getName()).asString();                bindings.add(binding);                // uses the parameters to pass the socket binding name that will be read in ActiveMQServerService.start()                parameters.put(RemoteTransportDefinition.SOCKET_BINDING.getName(), binding);                connectors.put(connectorName, new TransportConfiguration(NettyConnectorFactory.class.getName(), parameters, connectorName, extraParameters));            }        }        if (params.hasDefined(IN_VM_CONNECTOR)) {            for (final Property property : params.get(IN_VM_CONNECTOR).asPropertyList()) {                final String connectorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, CONNECTORS_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(IN_VM_ALLOWABLE_KEYS, parameters);                parameters.put(CONNECTORS_KEYS_MAP.get(InVMTransportDefinition.SERVER_ID.getName()), InVMTransportDefinition.SERVER_ID.resolveModelAttribute(context, config).asInt());                connectors.put(connectorName, new TransportConfiguration(InVMConnectorFactory.class.getName(), parameters, connectorName, extraParameters));            }        }        if (params.hasDefined(HTTP_CONNECTOR)) {            for (final Property property : params.get(HTTP_CONNECTOR).asPropertyList()) {                final String connectorName = property.getName();                final ModelNode config = property.getValue();                final Map<String, Object> parameters = getParameters(context, config, CONNECTORS_KEYS_MAP);                final Map<String, Object> extraParameters = getExtraParameters(TransportConstants.ALLOWABLE_CONNECTOR_KEYS, parameters);                final String binding = HTTPConnectorDefinition.SOCKET_BINDING.resolveModelAttribute(context, config).asString();                bindings.add(binding);                // ARTEMIS-803 Artemis knows that is must not offset the HTTP port when it is used by colocated backups                parameters.put(TransportConstants.HTTP_UPGRADE_ENABLED_PROP_NAME, true);                parameters.put(TransportConstants.HTTP_UPGRADE_ENDPOINT_PROP_NAME, HTTPConnectorDefinition.ENDPOINT.resolveModelAttribute(context, config).asString());                // uses the parameters to pass the socket binding name that will be read in ActiveMQServerService.start()                parameters.put(HTTPConnectorDefinition.SOCKET_BINDING.getName(), binding);                ModelNode serverNameModelNode = HTTPConnectorDefinition.SERVER_NAME.resolveModelAttribute(context, config);                // use the name of this server if the server-name attribute is undefined                String serverName = serverNameModelNode.isDefined() ? serverNameModelNode.asString() : configServerName;                parameters.put(ACTIVEMQ_SERVER_NAME, serverName);                connectors.put(connectorName, new TransportConfiguration(NettyConnectorFactory.class.getName(), parameters, connectorName, extraParameters));            }        }        return connectors;    }
public static Map<String, Boolean> listOutBoundSocketBinding(OperationContext context, Collection<String> names) throws OperationFailedException {        Map<String, Boolean> result = new HashMap<>();        Resource root = context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS, false);        Set<String> groups = root.getChildrenNames(ModelDescriptionConstants.SOCKET_BINDING_GROUP);        for (String groupName : groups) {            Resource socketBindingGroup = context.readResourceFromRoot(PathAddress.pathAddress(ModelDescriptionConstants.SOCKET_BINDING_GROUP, groupName));            for (String name : names) {                if (socketBindingGroup.getChildrenNames(ModelDescriptionConstants.SOCKET_BINDING).contains(name)) {                    result.put(name, Boolean.FALSE);                } else if (socketBindingGroup.getChildrenNames(ModelDescriptionConstants.LOCAL_DESTINATION_OUTBOUND_SOCKET_BINDING).contains(name)                        || socketBindingGroup.getChildrenNames(ModelDescriptionConstants.REMOTE_DESTINATION_OUTBOUND_SOCKET_BINDING).contains(name)) {                    result.put(name, Boolean.TRUE);                }            }        }        if (result.size() != names.size()) {            for(String name : names) {                if(!result.containsKey(name)) {                    throw MessagingLogger.ROOT_LOGGER.noSocketBinding(name);                }            }        }        return result;    }
@Deprecated    public static ServiceName deploymentServiceName(final String serverName, final String virtualHost, final String contextPath) {        return WEB_DEPLOYMENT_BASE.append(serverName).append(virtualHost).append("".equals(contextPath) ? "/" : contextPath);    }
public static Class<?> toClass(Type type) {        if (type instanceof Class) {            return (Class) type;        } else if (type instanceof ParameterizedType) {            ParameterizedType pt = (ParameterizedType) type;            return toClass(pt.getRawType());        } else {            throw PojoLogger.ROOT_LOGGER.unknownType(type);        }    }
@SuppressWarnings("unchecked")    public static Object convertValue(Class<?> clazz, Object value, boolean replaceProperties, boolean trim) throws Throwable {        if (clazz == null)            return value;        if (value == null)            return null;        Class<?> valueClass = value.getClass();        // If we have a string, trim and replace any system properties when requested        if (valueClass == String.class) {            String string = (String) value;            if (trim)                string = string.trim();            if (replaceProperties)                value = PropertiesValueResolver.replaceProperties(string);        }        if (clazz.isAssignableFrom(valueClass))            return value;        // First see if this is an Enum        if (clazz.isEnum()) {            Class<? extends Enum> eclazz = clazz.asSubclass(Enum.class);            return Enum.valueOf(eclazz, value.toString());        }        // Next look for a property editor        if (valueClass == String.class) {            PropertyEditor editor = PropertyEditorManager.findEditor(clazz);            if (editor != null) {                editor.setAsText((String) value);                return editor.getValue();            }        }        // Try a static clazz.valueOf(value)        try {            Method method = clazz.getMethod("valueOf", valueClass);            int modifiers = method.getModifiers();            if (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers)                    && clazz.isAssignableFrom(method.getReturnType()))                return method.invoke(null, value);        } catch (Exception ignored) {        }        if (valueClass == String.class) {            try {                Constructor constructor = clazz.getConstructor(valueClass);                if (Modifier.isPublic(constructor.getModifiers()))                    return constructor.newInstance(value);            } catch (Exception ignored) {            }        }        return value;    }
public static String[] getTypes(ValueConfig[] values) {        if (values == null || values.length == 0)            return NO_PARAMS_TYPES;        String[] types = new String[values.length];        for (int i =0; i < types.length; i++)            types[i] = values[i].getType();        return types;    }
@SuppressWarnings("unchecked")    public static Method findMethod(DeploymentReflectionIndex index, Class classInfo, String name, String[] paramTypes, boolean isStatic, boolean isPublic, boolean strict) throws IllegalArgumentException {        if (name == null)            throw PojoLogger.ROOT_LOGGER.nullName();        if (classInfo == null)            throw PojoLogger.ROOT_LOGGER.nullClassInfo();        if (paramTypes == null)            paramTypes = NO_PARAMS_TYPES;        Class current = classInfo;        while (current != null) {            ClassReflectionIndex cri = index.getClassIndex(classInfo);            Method result = locateMethod(cri, name, paramTypes, isStatic, isPublic, strict);            if (result != null)                return result;            current = current.getSuperclass();        }        throw PojoLogger.ROOT_LOGGER.methodNotFound(name, Arrays.toString(paramTypes), classInfo.getName());    }
@SuppressWarnings("unchecked")    private static Method locateMethod(ClassReflectionIndex classInfo, String name, String[] paramTypes, boolean isStatic, boolean isPublic, boolean strict) {        Collection<Method> methods = classInfo.getMethods();        if (methods != null) {            for (Method method : methods) {                if (name.equals(method.getName()) &&                        equals(paramTypes, method.getParameterTypes()) &&                        (strict == false || (Modifier.isStatic(method.getModifiers()) == isStatic && Modifier.isPublic(method.getModifiers()) == isPublic)))                    return method;            }        }        return null;    }
protected static boolean simpleCheck(String[] typeNames, Class<?>[] typeInfos) {        return typeNames != null && typeInfos != null && typeNames.length == typeInfos.length;    }
private static PersistenceUnitMetadata parsePU(XMLStreamReader reader, Version version, final PropertyReplacer propertyReplacer) throws XMLStreamException {        PersistenceUnitMetadata pu = new PersistenceUnitMetadataImpl();        List<String> classes = new ArrayList<String>(1);        List<String> jarFiles = new ArrayList<String>(1);        List<String> mappingFiles = new ArrayList<String>(1);        Properties properties = new Properties();        // set defaults        pu.setTransactionType(PersistenceUnitTransactionType.JTA);        pu.setValidationMode(ValidationMode.AUTO);        pu.setSharedCacheMode(SharedCacheMode.UNSPECIFIED);        pu.setPersistenceProviderClassName(Configuration.PROVIDER_CLASS_DEFAULT);        if (version.equals(Version.JPA_1_0)) {            pu.setPersistenceXMLSchemaVersion("1.0");        } else if (version.equals(Version.JPA_2_0)) {            pu.setPersistenceXMLSchemaVersion("2.0");        } else if (version.equals(Version.JPA_2_1)) {            pu.setPersistenceXMLSchemaVersion("2.1");        } else {            pu.setPersistenceXMLSchemaVersion("2.2");        }        final int count = reader.getAttributeCount();        for (int i = 0; i < count; i++) {            final String value = reader.getAttributeValue(i);            if (traceEnabled) {                ROOT_LOGGER.tracef("parse persistence.xml: attribute value(%d) = %s", i, value);            }            final String attributeNamespace = reader.getAttributeNamespace(i);            if (attributeNamespace != null && !attributeNamespace.isEmpty()) {                continue;            }            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));            switch (attribute) {                case NAME:                    pu.setPersistenceUnitName(value);                    break;                case TRANSACTIONTYPE:                    if (value.equalsIgnoreCase("RESOURCE_LOCAL"))                        pu.setTransactionType(PersistenceUnitTransactionType.RESOURCE_LOCAL);                    break;                default:                    throw unexpectedAttribute(reader, i);            }        }        // until the ending PERSISTENCEUNIT tag        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {            final Element element = Element.forName(reader.getLocalName());            if (traceEnabled) {                ROOT_LOGGER.tracef("parse persistence.xml: element=%s", element.getLocalName());            }            switch (element) {                case CLASS:                    classes.add(getElement(reader, propertyReplacer));                    break;                case DESCRIPTION:                    final String description = getElement(reader, propertyReplacer);                    break;                case EXCLUDEUNLISTEDCLASSES:                    String text = getElement(reader, propertyReplacer);                    if (text == null || text.isEmpty()) {                        //the spec has examples where an empty                        //exclude-unlisted-classes element has the same                        //effect as setting it to true                        pu.setExcludeUnlistedClasses(true);                    } else {                        pu.setExcludeUnlistedClasses(Boolean.valueOf(text));                    }                    break;                case JARFILE:                    String file = getElement(reader, propertyReplacer);                    jarFiles.add(file);                    break;                case JTADATASOURCE:                    pu.setJtaDataSourceName(getElement(reader, propertyReplacer));                    break;                case NONJTADATASOURCE:                    pu.setNonJtaDataSourceName(getElement(reader, propertyReplacer));                    break;                case MAPPINGFILE:                    mappingFiles.add(getElement(reader, propertyReplacer));                    break;                case PROPERTIES:                    parseProperties(reader, properties, propertyReplacer);                    break;                case PROVIDER:                    pu.setPersistenceProviderClassName(getElement(reader, propertyReplacer));                    break;                case SHAREDCACHEMODE:                    String cm = getElement(reader, propertyReplacer);                    pu.setSharedCacheMode(SharedCacheMode.valueOf(cm));                    break;                case VALIDATIONMODE:                    String validationMode = getElement(reader, propertyReplacer);                    pu.setValidationMode(ValidationMode.valueOf(validationMode));                    break;                default:                    throw unexpectedElement(reader);            }        }        if (traceEnabled) {            ROOT_LOGGER.trace("parse persistence.xml: reached ending persistence-unit tag");        }        pu.setManagedClassNames(classes);        pu.setJarFiles(jarFiles);        pu.setMappingFiles(mappingFiles);        pu.setProperties(properties);        return pu;    }
public java.lang.Object next() throws NamingException {        if (more && counter >= _bindingList.value.length) {            getMore();        }        if (more && counter < _bindingList.value.length) {            org.omg.CosNaming.Binding bndg = _bindingList.value[counter];            counter++;            return mapBinding(bndg);        } else {            throw new NoSuchElementException();        }    }
private boolean getMore() throws NamingException {        try {            more = _bindingIter.next_n(batchsize, _bindingList);            counter = 0; // reset        } catch (Exception e) {            more = false;            NamingException ne = IIOPLogger.ROOT_LOGGER.errorGettingBindingList();            ne.setRootCause(e);            throw ne;        }        return more;    }
private javax.naming.Binding mapBinding(org.omg.CosNaming.Binding bndg)            throws NamingException {        java.lang.Object obj = _ctx.callResolve(bndg.binding_name);        Name cname = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.cosNameToName(bndg.binding_name);        try {            obj = NamingManager.getObjectInstance(obj, cname, _ctx, _env);        } catch (NamingException e) {            throw e;        } catch (Exception e) {            NamingException ne = IIOPLogger.ROOT_LOGGER.errorGeneratingObjectViaFactory();            ne.setRootCause(e);            throw ne;        }        // Use cname.toString() instead of bindingName because the name        // in the binding should be a composite name        String cnameStr = cname.toString();        javax.naming.Binding jbndg = new javax.naming.Binding(cnameStr, obj);        NameComponent[] comps = _ctx.makeFullName(bndg.binding_name);        String fullName = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.cosNameToInsString(comps);        jbndg.setNameInNamespace(fullName);        return jbndg;    }
public void addProperties(final String[] annotationProperties, final PropertyReplacer propertyReplacer) {        if (annotationProperties != null) {            for (String annotationProperty : annotationProperties) {                if (propertyReplacer != null) {                    annotationProperty = propertyReplacer.replaceProperties(annotationProperty);                }                final int index = annotationProperty.indexOf('=');                String propertyName;                String propertyValue;                if (index != -1) {                    propertyName = annotationProperty.substring(0, index);                    propertyValue = annotationProperty.length() > index ? annotationProperty.substring(index + 1, annotationProperty.length()) : "";                } else {                    propertyName = annotationProperty;                    propertyValue = "";                }                this.properties.put(propertyName, propertyValue);            }        }    }
public void addProperties(final PropertiesMetaData descriptorProperties) {        if (descriptorProperties != null) {            for (PropertyMetaData descriptorProperty : descriptorProperties) {                this.properties.put(descriptorProperty.getName(), descriptorProperty.getValue());            }        }    }
public void observeResources(@Observes @WithAnnotations({Health.class})  ProcessAnnotatedType<? extends HealthCheck> event) {        AnnotatedType<? extends HealthCheck> annotatedType = event.getAnnotatedType();        Class<? extends HealthCheck> javaClass = annotatedType.getJavaClass();        MicroProfileHealthLogger.LOGGER.infof("Discovered health check procedure %s", javaClass);        delegates.add(annotatedType);    }
private void afterDeploymentValidation(@Observes final AfterDeploymentValidation avd, BeanManager bm) {        for (AnnotatedType delegate : delegates) {            try {                Unmanaged<HealthCheck> unmanagedHealthCheck = new Unmanaged<HealthCheck>(bm, delegate.getJavaClass());                UnmanagedInstance<HealthCheck> healthCheckInstance = unmanagedHealthCheck.newInstance();                HealthCheck healthCheck =  healthCheckInstance.produce().inject().postConstruct().get();                healthCheckInstances.add(healthCheckInstance);                healthReporter.addHealthCheck(healthCheck);            } catch (Exception e) {                throw new RuntimeException("Failed to register health bean", e);            }        }    }
public void close(@Observes final BeforeShutdown bs) {        healthCheckInstances.forEach(healthCheck -> {            healthReporter.removeHealthCheck(healthCheck.get());            healthCheck.preDestroy().dispose();        });        healthCheckInstances.clear();    }
public org.omg.CORBA.Object referenceForLocator(final EJBLocator<?> locator) {        final EJBComponent ejbComponent = ejbComponentInjectedValue.getValue();        try {            final String earApplicationName = ejbComponent.getEarApplicationName() == null ? "" : ejbComponent.getEarApplicationName();            if (locator.getBeanName().equals(ejbComponent.getComponentName()) &&                    locator.getAppName().equals(earApplicationName) &&                    locator.getModuleName().equals(ejbComponent.getModuleName()) &&                    locator.getDistinctName().equals(ejbComponent.getDistinctName())) {                if (locator instanceof EJBHomeLocator) {                    return (org.omg.CORBA.Object) ejbHome;                } else if (locator instanceof StatelessEJBLocator) {                    return beanReferenceFactory.createReference(beanRepositoryIds[0]);                } else if (locator instanceof StatefulEJBLocator) {                    final Marshaller marshaller = factory.createMarshaller(configuration);                    final ByteArrayOutputStream stream = new ByteArrayOutputStream();                    marshaller.start(new OutputStreamByteOutput(stream));                    marshaller.writeObject(((StatefulEJBLocator<?>) locator).getSessionId());                    marshaller.finish();                    return beanReferenceFactory.createReferenceWithId(stream.toByteArray(), beanRepositoryIds[0]);                } else if (locator instanceof EntityEJBLocator) {                    final Marshaller marshaller = factory.createMarshaller(configuration);                    final ByteArrayOutputStream stream = new ByteArrayOutputStream();                    marshaller.start(new OutputStreamByteOutput(stream));                    marshaller.writeObject(((EntityEJBLocator<?>) locator).getPrimaryKey());                    marshaller.finish();                    return beanReferenceFactory.createReferenceWithId(stream.toByteArray(), beanRepositoryIds[0]);                }                throw EjbLogger.ROOT_LOGGER.unknownEJBLocatorType(locator);            } else {                throw EjbLogger.ROOT_LOGGER.incorrectEJBLocatorForBean(locator, ejbComponent.getComponentName());            }        } catch (Exception e) {            throw EjbLogger.ROOT_LOGGER.couldNotCreateCorbaObject(e, locator);        }    }
public Object handleForLocator(final EJBLocator<?> locator) {        final org.omg.CORBA.Object reference = referenceForLocator(locator);        if(locator instanceof EJBHomeLocator) {            return new HomeHandleImplIIOP(orb.getValue().object_to_string(reference));        }        return new HandleImplIIOP(orb.getValue().object_to_string(reference));    }
public static synchronized void rebind(final NamingContextExt ctx, final String strName, final org.omg.CORBA.Object obj) throws Exception {        final NameComponent[] name = ctx.to_name(strName);        NamingContext intermediateCtx = ctx;        for (int i = 0; i < name.length - 1; i++) {            final NameComponent[] relativeName = new NameComponent[]{name[i]};            try {                intermediateCtx = NamingContextHelper.narrow(                        intermediateCtx.resolve(relativeName));            } catch (NotFound e) {                intermediateCtx = intermediateCtx.bind_new_context(relativeName);            }        }        intermediateCtx.rebind(new NameComponent[]{name[name.length - 1]}, obj);    }
@Override    public void start(StartContext context) throws StartException {        SecurityLogger.ROOT_LOGGER.debugf("Starting SecurityDomainService(%s)", name);        if (applicationPolicy != null) {            final ApplicationPolicyRegistration applicationPolicyRegistration = (ApplicationPolicyRegistration) configurationValue                    .getValue();            applicationPolicyRegistration.addApplicationPolicy(applicationPolicy.getName(), applicationPolicy);        }        final JNDIBasedSecurityManagement securityManagement = (JNDIBasedSecurityManagement) securityManagementValue.getValue();        AuthenticationCacheFactory cacheFactory = null;        if ("infinispan".equals(cacheType)) {            cacheFactory = () -> this.cacheValue.getValue();        } else if ("default".equals(cacheType)) {            cacheFactory = new DefaultAuthenticationCacheFactory();        }        SecurityDomainContext sdc;        try {            sdc = securityManagement.createSecurityDomainContext(name, cacheFactory, jsseSecurityDomain);        } catch (Exception e) {            throw SecurityLogger.ROOT_LOGGER.unableToStartException("SecurityDomainService", e);        }        if (jsseSecurityDomain != null) {            try {                jsseSecurityDomain.reloadKeyAndTrustStore();            } catch (Exception e) {                throw SecurityLogger.ROOT_LOGGER.unableToStartException("SecurityDomainService", e);            }        }        securityManagement.getSecurityManagerMap().put(name, sdc);        this.securityDomainContext = sdc;    }
@Override    public void stop(StopContext context) {        SecurityLogger.ROOT_LOGGER.debugf("Stopping security domain service %s", name);        final JNDIBasedSecurityManagement securityManagement = (JNDIBasedSecurityManagement) securityManagementValue.getValue();        securityManagement.removeSecurityDomain(name);        // TODO clear auth cache?        final ApplicationPolicyRegistration applicationPolicyRegistration = (ApplicationPolicyRegistration) configurationValue                .getValue();        applicationPolicyRegistration.removeApplicationPolicy(name);    }
public static <E extends Enum<E>> E asEnum(ModelNode value, Class<E> targetClass) {        return Enum.valueOf(targetClass, value.asString());    }
public static Optional<Boolean> optionalBoolean(ModelNode value) {        return value.isDefined() ? Optional.of(value.asBoolean()) : Optional.empty();    }
public static OptionalDouble optionalDouble(ModelNode value) {        return value.isDefined() ? OptionalDouble.of(value.asDouble()) : OptionalDouble.empty();    }
public static Optional<Float> optionalFloat(ModelNode value) {        return value.isDefined() ? Optional.of(asFloat(value)) : Optional.empty();    }
public static OptionalInt optionalInt(ModelNode value) {        return value.isDefined() ? OptionalInt.of(value.asInt()) : OptionalInt.empty();    }
public static OptionalLong optionalLong(ModelNode value) {        return value.isDefined() ? OptionalLong.of(value.asInt()) : OptionalLong.empty();    }
public static Optional<String> optionalString(ModelNode value) {        return value.isDefined() ? Optional.of(value.asString()) : Optional.empty();    }
public static Optional<Property> optionalProperty(ModelNode value) {        return value.isDefined() ? Optional.of(value.asProperty()) : Optional.empty();    }
public static Optional<List<Property>> optionalPropertyList(ModelNode value) {        return value.isDefined() ? Optional.of(value.asPropertyList()) : Optional.empty();    }
public static Optional<List<ModelNode>> optionalList(ModelNode value) {        return value.isDefined() ? Optional.of(value.asList()) : Optional.empty();    }
public static <E extends Enum<E>> Optional<E> optionalEnum(ModelNode value, Class<E> targetClass) {        return value.isDefined() ? Optional.of(asEnum(value, targetClass)) : Optional.empty();    }
private ResourceRoot createResourceRoot(final DeploymentUnit deploymentUnit, final VirtualFile file, final boolean markAsSubDeployment, final boolean explodeDuringMount) throws IOException {        final boolean war = file.getName().toLowerCase(Locale.ENGLISH).endsWith(WAR_EXTENSION);        final Closeable closable = file.isFile() ? mount(file, explodeDuringMount) : exportExplodedWar(war, file, deploymentUnit);        final MountHandle mountHandle = new MountHandle(closable);        final ResourceRoot resourceRoot = new ResourceRoot(file, mountHandle);        deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, resourceRoot);        if (markAsSubDeployment) {            SubDeploymentMarker.mark(resourceRoot);        }        if (war) {            resourceRoot.putAttachment(Attachments.INDEX_RESOURCE_ROOT, false);            SubExplodedDeploymentMarker.mark(resourceRoot);        }        return resourceRoot;    }
public static SimpleOperationDefinitionBuilder runtimeReadOnlyOperation(String operationName, ResourceDescriptionResolver resolver) {        return new SimpleOperationDefinitionBuilder(operationName, resolver)                .setRuntimeOnly()                .setReadOnly();    }
public static SimpleOperationDefinitionBuilder runtimeOnlyOperation(String operationName, ResourceDescriptionResolver resolver) {        return new SimpleOperationDefinitionBuilder(operationName, resolver)                .setRuntimeOnly();    }
public static Principal[] getGrantedRoles(SecurityIdentity securityIdentity) {        Set<String> roles = new HashSet<>();        for (String s : securityIdentity.getRoles("ejb")) {            roles.add(s);        }        List<Principal> list = new ArrayList<>();        Function<String, Principal> mapper = roleName -> (Principal) () -> roleName;        for (String role : roles) {            Principal principal = mapper.apply(role);            list.add(principal);        }        return list.toArray(NO_PRINCIPALS);    }
public static void skip(InputStream is, long amount) throws IOException {        long leftToSkip = amount;        long amountSkipped = 0;        while(leftToSkip > 0 && amountSkipped >= 0){            amountSkipped = is.skip(leftToSkip);            leftToSkip -= amountSkipped;        }    }
@Override    protected List<String> parseRolesAttribute(XMLExtendedStreamReader reader, int index) throws XMLStreamException {        String roles = reader.getAttributeValue(index);        return asList(roles.split("[,\\s]+"));    }
protected static void checkNotBothElements(XMLExtendedStreamReader reader, Set<Element> seen, Element element1, Element element2) throws XMLStreamException {        if (seen.contains(element1) && seen.contains(element2)) {            throw new XMLStreamException(MessagingLogger.ROOT_LOGGER.onlyOneRequired(element1.getLocalName(), element2.getLocalName()), reader.getLocation());        }    }
public Object invoke(String operationName, final StubStrategy stubStrategy, Object[] params) throws Throwable {        if (operationName.equals("_get_handle")                && this instanceof javax.ejb.EJBObject) {            if (handle == null) {                handle = new HandleImplIIOP(this);            }            return handle;        } else if (operationName.equals("_get_homeHandle")                && this instanceof javax.ejb.EJBHome) {            if (handle == null) {                handle = new HomeHandleImplIIOP(this);            }            return handle;        } else {            //FIXME            // all invocations are now made using remote invocation            // local invocations between two different applications cause            // ClassCastException between Stub and Interface            // (two different modules are loading the classes)            // problem was unnoticeable with JacORB because it uses            // remote invocations to all stubs to which interceptors are            // registered and a result all that JacORB always used            // remote invocations            // remote call path            // To check whether this is a local stub or not we must call            // org.omg.CORBA.portable.ObjectImpl._is_local(), and _not_            // javax.rmi.CORBA.Util.isLocal(Stub s), which in Sun's JDK            // always return false.            InputStream in = null;            try {                try {                    OutputStream out =                            (OutputStream) _request(operationName, true);                    stubStrategy.writeParams(out, params);                    tracef("sent request: %s", operationName);                    in = (InputStream) _invoke(out);                    if (stubStrategy.isNonVoid()) {                        trace("received reply");                        final InputStream finalIn = in;                        return doPrivileged(new PrivilegedAction<Object>() {                            public Object run() {                                return stubStrategy.readRetval(finalIn);                            }                        });                    } else {                        return null;                    }                } catch (final ApplicationException ex) {                    trace("got application exception");                    in = (InputStream) ex.getInputStream();                    final InputStream finalIn1 = in;                    throw doPrivileged(new PrivilegedAction<Exception>() {                        public Exception run() {                            return stubStrategy.readException(ex.getId(), finalIn1);                        }                    });                } catch (RemarshalException ex) {                    trace("got remarshal exception");                    return invoke(operationName, stubStrategy, params);                }            } catch (SystemException ex) {                if (EjbLogger.EJB3_INVOCATION_LOGGER.isTraceEnabled()) {                    EjbLogger.EJB3_INVOCATION_LOGGER.trace("CORBA system exception in IIOP stub", ex);                }                throw Util.mapSystemException(ex);            } finally {                _releaseReply(in);            }        }    }
public boolean invokeBoolean(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Boolean) invoke(operationName,                stubStrategy, params)).booleanValue();    }
public byte invokeByte(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Number) invoke(operationName,                stubStrategy, params)).byteValue();    }
public char invokeChar(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Character) invoke(operationName,                stubStrategy, params)).charValue();    }
public short invokeShort(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Number) invoke(operationName,                stubStrategy, params)).shortValue();    }
public int invokeInt(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Number) invoke(operationName, stubStrategy, params)).intValue();    }
public long invokeLong(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Number) invoke(operationName, stubStrategy, params)).longValue();    }
public float invokeFloat(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Number) invoke(operationName, stubStrategy, params)).floatValue();    }
public double invokeDouble(String operationName, StubStrategy stubStrategy, Object[] params) throws Throwable {        return ((Number) invoke(operationName,                stubStrategy, params)).doubleValue();    }
static AddressSettings createSettings(final OperationContext context, final ModelNode config) throws OperationFailedException {        final AddressSettings settings = new AddressSettings();        if (config.hasDefined(AddressSettingDefinition.ADDRESS_FULL_MESSAGE_POLICY.getName())) {            final AddressFullMessagePolicy addressPolicy = AddressFullMessagePolicy.valueOf(AddressSettingDefinition.ADDRESS_FULL_MESSAGE_POLICY.resolveModelAttribute(context, config).asString());            settings.setAddressFullMessagePolicy(addressPolicy);        }        if (config.hasDefined(DEAD_LETTER_ADDRESS.getName())) {            settings.setDeadLetterAddress(asSimpleString(DEAD_LETTER_ADDRESS.resolveModelAttribute(context, config), null));        }        if (config.hasDefined(AddressSettingDefinition.LAST_VALUE_QUEUE.getName())) {            settings.setDefaultLastValueQueue(AddressSettingDefinition.LAST_VALUE_QUEUE.resolveModelAttribute(context, config).asBoolean());        }        if (config.hasDefined(AddressSettingDefinition.MAX_DELIVERY_ATTEMPTS.getName())) {            settings.setMaxDeliveryAttempts(AddressSettingDefinition.MAX_DELIVERY_ATTEMPTS.resolveModelAttribute(context, config).asInt());        }        if (config.hasDefined(AddressSettingDefinition.MAX_SIZE_BYTES.getName())) {            settings.setMaxSizeBytes(AddressSettingDefinition.MAX_SIZE_BYTES.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.MESSAGE_COUNTER_HISTORY_DAY_LIMIT.getName())) {            settings.setMessageCounterHistoryDayLimit(AddressSettingDefinition.MESSAGE_COUNTER_HISTORY_DAY_LIMIT.resolveModelAttribute(context, config).asInt());        }        if (config.hasDefined(CommonAttributes.EXPIRY_ADDRESS.getName())) {            settings.setExpiryAddress(asSimpleString(EXPIRY_ADDRESS.resolveModelAttribute(context, config), null));        }        if (config.hasDefined(AddressSettingDefinition.EXPIRY_DELAY.getName())) {            settings.setExpiryDelay(AddressSettingDefinition.EXPIRY_DELAY.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.REDELIVERY_DELAY.getName())) {            settings.setRedeliveryDelay(AddressSettingDefinition.REDELIVERY_DELAY.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.REDELIVERY_MULTIPLIER.getName())) {            settings.setRedeliveryMultiplier(AddressSettingDefinition.REDELIVERY_MULTIPLIER.resolveModelAttribute(context, config).asDouble());        }        if (config.hasDefined(AddressSettingDefinition.MAX_REDELIVERY_DELAY.getName())) {            settings.setMaxRedeliveryDelay(AddressSettingDefinition.MAX_REDELIVERY_DELAY.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.REDISTRIBUTION_DELAY.getName())) {            settings.setRedistributionDelay(AddressSettingDefinition.REDISTRIBUTION_DELAY.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.PAGE_SIZE_BYTES.getName())) {            settings.setPageSizeBytes(AddressSettingDefinition.PAGE_SIZE_BYTES.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.PAGE_MAX_CACHE_SIZE.getName())) {            settings.setPageCacheMaxSize(AddressSettingDefinition.PAGE_MAX_CACHE_SIZE.resolveModelAttribute(context, config).asInt());        }        if (config.hasDefined(AddressSettingDefinition.SEND_TO_DLA_ON_NO_ROUTE.getName())) {            settings.setSendToDLAOnNoRoute(AddressSettingDefinition.SEND_TO_DLA_ON_NO_ROUTE.resolveModelAttribute(context, config).asBoolean());        }        if (config.hasDefined(AddressSettingDefinition.SLOW_CONSUMER_CHECK_PERIOD.getName())) {            settings.setSlowConsumerCheckPeriod(AddressSettingDefinition.SLOW_CONSUMER_CHECK_PERIOD.resolveModelAttribute(context, config).asLong());        }        if (config.hasDefined(AddressSettingDefinition.SLOW_CONSUMER_POLICY.getName())) {            final SlowConsumerPolicy slowConsumerPolicy = SlowConsumerPolicy.valueOf(AddressSettingDefinition.SLOW_CONSUMER_POLICY.resolveModelAttribute(context, config).asString());            settings.setSlowConsumerPolicy(slowConsumerPolicy);        }        if (config.hasDefined(AddressSettingDefinition.SLOW_CONSUMER_THRESHOLD.getName())) {            settings.setSlowConsumerThreshold(AddressSettingDefinition.SLOW_CONSUMER_THRESHOLD.resolveModelAttribute(context, config).asLong());        }        // always set the auto-create|delete-jms-queues attributes as their default attribute values differ from Artemis defaults.        settings.setAutoCreateJmsQueues(AddressSettingDefinition.AUTO_CREATE_JMS_QUEUES.resolveModelAttribute(context, config).asBoolean());        settings.setAutoDeleteJmsQueues(AddressSettingDefinition.AUTO_DELETE_JMS_QUEUES.resolveModelAttribute(context, config).asBoolean());        settings.setAutoCreateQueues(AddressSettingDefinition.AUTO_CREATE_QUEUES.resolveModelAttribute(context, config).asBoolean());        settings.setAutoDeleteQueues(AddressSettingDefinition.AUTO_DELETE_QUEUES.resolveModelAttribute(context, config).asBoolean());        settings.setAutoCreateAddresses(AddressSettingDefinition.AUTO_CREATE_ADDRESSES.resolveModelAttribute(context, config).asBoolean());        settings.setAutoDeleteAddresses(AddressSettingDefinition.AUTO_DELETE_ADDRESSES.resolveModelAttribute(context, config).asBoolean());        return settings;    }
public EEModuleClassDescription addOrGetLocalClassDescription(final String className) {        if (className == null) {            throw EeLogger.ROOT_LOGGER.nullVar("className", "module", moduleName);        }        EEModuleClassDescription ret = classDescriptions.get(className);        if (ret == null) {            classDescriptions.put(className, ret = new EEModuleClassDescription(className));        }        return ret;    }
public void addComponent(ComponentDescription description) {        final String componentName = description.getComponentName();        final String componentClassName = description.getComponentClassName();        if (componentName == null) {            throw EeLogger.ROOT_LOGGER.nullVar("componentName", "module", moduleName);        }        if (componentClassName == null) {            throw EeLogger.ROOT_LOGGER.nullVar("componentClassName","module", moduleName);        }        if (componentsByName.containsKey(componentName)) {            throw EeLogger.ROOT_LOGGER.componentAlreadyDefined(componentName);        }        componentsByName.put(componentName, description);        List<ComponentDescription> list = componentsByClassName.get(componentClassName);        if (list == null) {            componentsByClassName.put(componentClassName, list = new ArrayList<ComponentDescription>(1));        }        list.add(description);    }
public static void addClassLoaders(ClassLoader topLevel, Set<ClassLoader> allClassLoaders) {        deploymentClassLoaders.put(topLevel, allClassLoaders);    }
@Override    public TransformedOperation transformOperation(TransformationContext context, PathAddress address, ModelNode operation) {        String name = Operations.getAttributeName(operation);        ModelNode value = Operations.getAttributeValue(operation);        ModelNode legacyOperation = org.jboss.as.controller.client.helpers.Operations.createWriteAttributeOperation(this.addressTransformer.transform(address).toModelNode(), name, value);        return new TransformedOperation(legacyOperation, OperationResultTransformer.ORIGINAL_RESULT);    }
public void bind(Name name, Object object) throws NamingException {        bind(name, object, object.getClass());    }
public void bind(final Name name, final Object object, final Class<?> bindType) throws NamingException {        if (isLastComponentEmpty(name)) {            throw emptyNameException();        }        writeLock.lock();        try {            root.accept(new BindVisitor(true, name, object, bindType.getName()));        } finally {            writeLock.unlock();        }    }
public void rebind(Name name, Object object) throws NamingException {        rebind(name, object, object.getClass());    }
public void rebind(final Name name, final Object object, final Class<?> bindType) throws NamingException {        if (isLastComponentEmpty(name)) {            throw emptyNameException();        }        writeLock.lock();        try {            root.accept(new RebindVisitor(name, object, bindType.getName()));        } finally {            writeLock.unlock();        }    }
public void unbind(final Name name) throws NamingException {        if (isLastComponentEmpty(name)) {            throw emptyNameException();        }        writeLock.lock();        try {            root.accept(new UnbindVisitor(name));        } finally {            writeLock.unlock();        }    }
public Object lookup(final Name name) throws NamingException {        if (isEmpty(name)) {            final Name emptyName = new CompositeName("");            return new NamingContext(emptyName, this, new Hashtable<String, Object>());        }        return root.accept(new LookupVisitor(name));    }
public List<NameClassPair> list(final Name name) throws NamingException {        final Name nodeName = name.isEmpty() ? new CompositeName("") : name;        return root.accept(new ListVisitor(nodeName));    }
public List<Binding> listBindings(final Name name) throws NamingException {        final Name nodeName = name.isEmpty() ? new CompositeName("") : name;        return root.accept(new ListBindingsVisitor(nodeName));    }
public void addNamingListener(final Name target, final int scope, final NamingListener listener) {        final NamingEventCoordinator coordinator = eventCoordinator;        if (coordinator != null) {            coordinator.addListener(target.toString(), scope, listener);        }    }
public void removeNamingListener(final NamingListener listener) {        final NamingEventCoordinator coordinator = eventCoordinator;        if (coordinator != null) {            coordinator.removeListener(listener);        }    }
private Principal getPrincipal(Subject subject) {        Principal principal = null;        Principal callerPrincipal = null;        if (subject != null) {            Set<Principal> principals = subject.getPrincipals();            if (principals != null && !principals.isEmpty()) {                for (Principal p : principals) {                    if (!(p instanceof Group) && principal == null) {                        principal = p;                    }                    if (p instanceof Group) {                        Group g = Group.class.cast(p);                        if (g.getName().equals(SecurityConstants.CALLER_PRINCIPAL_GROUP) && callerPrincipal == null) {                            Enumeration<? extends Principal> e = g.members();                            if (e.hasMoreElements())                                callerPrincipal = e.nextElement();                        }                    }                }            }        }        return callerPrincipal == null ? principal : callerPrincipal;    }
private void readServerElement_1_0(final XMLExtendedStreamReader reader, final ModelNode address, final List<ModelNode> list)            throws XMLStreamException {        parseNamespaces(reader, address, list);        String serverName = null;        // attributes        final int count = reader.getAttributeCount();        for (int i = 0; i < count; i++) {            switch (Namespace.forUri(reader.getAttributeNamespace(i))) {                case NONE: {                    final String value = reader.getAttributeValue(i);                    final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));                    switch (attribute) {                        case NAME: {                            serverName = value;                            break;                        }                        default:                            throw unexpectedAttribute(reader, i);                    }                    break;                }                case XML_SCHEMA_INSTANCE: {                    switch (Attribute.forName(reader.getAttributeLocalName(i))) {                        case SCHEMA_LOCATION: {                            parseSchemaLocations(reader, address, list, i);                            break;                        }                        case NO_NAMESPACE_SCHEMA_LOCATION: {                            // todo, jeez                            break;                        }                        default: {                            throw unexpectedAttribute(reader, i);                        }                    }                    break;                }                default:                    throw unexpectedAttribute(reader, i);            }        }        setServerName(address, list, serverName);        // elements - sequence        Element element = nextElement(reader, DOMAIN_1_0);        if (element == Element.EXTENSIONS) {            extensionXml.parseExtensions(reader, address, DOMAIN_1_0, list);            element = nextElement(reader, DOMAIN_1_0);        }        // System properties        if (element == Element.SYSTEM_PROPERTIES) {            parseSystemProperties(reader, address, DOMAIN_1_0, list, true);            element = nextElement(reader, DOMAIN_1_0);        }        if (element == Element.PATHS) {            parsePaths(reader, address, DOMAIN_1_0, list, true);            element = nextElement(reader, DOMAIN_1_0);        }        // Single profile        if (element == Element.PROFILE) {            parseServerProfile(reader, address, list);            element = nextElement(reader, DOMAIN_1_0);        }        // Interfaces        final Set<String> interfaceNames = new HashSet<String>();        if (element == Element.INTERFACES) {            parseInterfaces(reader, interfaceNames, address, DOMAIN_1_0, list, true);            element = nextElement(reader, DOMAIN_1_0);        }        // Single socket binding group        if (element == Element.SOCKET_BINDING_GROUP) {            parseSocketBindingGroup(reader, interfaceNames, address, DOMAIN_1_0, list);            element = nextElement(reader, DOMAIN_1_0);        }        if (element != null) {            throw unexpectedElement(reader);        }    }
public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        if (phaseContext.getDeploymentUnit().getAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY) == null) {            return;  // Skip non ra deployments        }        CopyOnWriteArrayListMultiMap<String,ServiceName> resourceAdaptersMap = phaseContext.getDeploymentUnit().getAttachment(ResourceAdaptersSubsystemService.ATTACHMENT_KEY);        String deploymentUnitPrefix = "";        if (deploymentUnit.getParent() != null) {            deploymentUnitPrefix = deploymentUnit.getParent().getName() + "#";        }        final String deploymentUnitName = deploymentUnitPrefix + deploymentUnit.getName();        if (resourceAdaptersMap != null && resourceAdaptersMap.get(deploymentUnitName) != null) {            for (ServiceName serviceName : resourceAdaptersMap.get(deploymentUnitName)) {                phaseContext.addDeploymentDependency(serviceName, AttachmentKey                        .create(ModifiableResourceAdapter.class));            }        }    }
@Override    public Object writeReplace(Object object) {        return EJBClient.isEJBProxy(object) ? new SerializableEJBProxy(object) : object;    }
public synchronized void addFactory(ContextHandleFactory factory) {        final String factoryName = factory.getName();        if(factoryMap.containsKey(factoryName)) {            throw EeLogger.ROOT_LOGGER.factoryAlreadyExists(this, factoryName);        }        factoryMap.put(factoryName, factory);        final Comparator<ContextHandleFactory> comparator = new Comparator<ContextHandleFactory>() {            @Override            public int compare(ContextHandleFactory o1, ContextHandleFactory o2) {                return Integer.compare(o1.getChainPriority(),o2.getChainPriority());            }        };        SortedSet<ContextHandleFactory> sortedSet = new TreeSet<>(comparator);        sortedSet.addAll(factoryMap.values());        factoryOrderedList = new ArrayList<>(sortedSet);    }
public SetupContextHandle saveContext(ContextService contextService, Map<String, String> contextObjectProperties) {        final List<SetupContextHandle> handles = new ArrayList<>(factoryOrderedList.size());        for (ContextHandleFactory factory : factoryOrderedList) {            handles.add(factory.saveContext(contextService, contextObjectProperties));        }        return new ChainedSetupContextHandle(this, handles);    }
public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {        return new NamingContext(name != null ? name : new CompositeName(""), environment);    }
public void addBeanDeploymentArchives(Collection<? extends BeanDeploymentArchive> archives) {        for (BeanDeploymentArchive bda : archives) {            if (bda != this) {                beanDeploymentArchives.add(bda);            }        }    }
public boolean isAccessible(BeanDeploymentArchive target) {        if (this == target) {            return true;        }        BeanDeploymentArchiveImpl that = (BeanDeploymentArchiveImpl) target;        if (that.getModule() == null) {            /*             * The target BDA is the bootstrap BDA - it bundles classes loaded by the bootstrap classloader.             * Everyone can see the bootstrap classloader.             */            return true;        }        if (module == null) {            /*             * This BDA is the bootstrap BDA - it bundles classes loaded by the bootstrap classloader. We assume that a             * bean whose class is loaded by the bootstrap classloader can only see other beans in the "bootstrap BDA".             */            return that.getModule() == null;        }        if (module.equals(that.getModule())) {            return true;        }        // basic check whether the module is our dependency        for (DependencySpec dependency : module.getDependencies()) {            if (dependency instanceof ModuleDependencySpec) {                ModuleDependencySpec moduleDependency = (ModuleDependencySpec) dependency;                if (moduleDependency.getIdentifier().equals(that.getModule().getIdentifier())) {                    return true;                }                // moduleDependency might be an alias - try to load it to get lined module                Module module = loadModule(moduleDependency);                if (module != null && module.getIdentifier().equals(that.getModule().getIdentifier())) {                    return true;                }            }        }        /*         * full check - we try to load a class from the target bean archive and check whether its module         * is the same as the one of the bean archive         * See WFLY-4250 for more info         */        Iterator<String> iterator = target.getBeanClasses().iterator();        if (iterator.hasNext()) {            Class<?> clazz = Reflections.loadClass(iterator.next(), module.getClassLoader());            if (clazz != null) {                Module classModule = Module.forClass(clazz);                return classModule != null && classModule.equals(that.getModule());            }        }        return false;    }
private SSLInformation createSecurityRealm(OperationContext context, Map<PathAddress, ModelNode> migrationOperations, ModelNode legacyModelAddOps, String connector, ModelNode legacyAddOp, List<String> warnings, boolean domainMode) {        //read all the info from the SSL definition        ModelNode keyAlias = legacyAddOp.get(WebSSLDefinition.KEY_ALIAS.getName());        ModelNode password = legacyAddOp.get(WebSSLDefinition.PASSWORD.getName());        ModelNode certificateKeyFile = legacyAddOp.get(WebSSLDefinition.CERTIFICATE_KEY_FILE.getName());        ModelNode cipherSuite = legacyAddOp.get(WebSSLDefinition.CIPHER_SUITE.getName());        ModelNode protocol = legacyAddOp.get(WebSSLDefinition.PROTOCOL.getName());        ModelNode verifyClient = legacyAddOp.get(WebSSLDefinition.VERIFY_CLIENT.getName());        ModelNode verifyDepth = legacyAddOp.get(WebSSLDefinition.VERIFY_DEPTH.getName());        ModelNode certificateFile = legacyAddOp.get(WebSSLDefinition.CERTIFICATE_FILE.getName());        ModelNode caCertificateFile = legacyAddOp.get(WebSSLDefinition.CA_CERTIFICATE_FILE.getName());        ModelNode caCertificatePassword = legacyAddOp.get(WebSSLDefinition.CA_CERTIFICATE_PASSWORD.getName());        ModelNode csRevocationURL = legacyAddOp.get(WebSSLDefinition.CA_REVOCATION_URL.getName());        ModelNode trustStoreType = legacyAddOp.get(WebSSLDefinition.TRUSTSTORE_TYPE.getName());        ModelNode keystoreType = legacyAddOp.get(WebSSLDefinition.KEYSTORE_TYPE.getName());        ModelNode sessionCacheSize = legacyAddOp.get(WebSSLDefinition.SESSION_CACHE_SIZE.getName());        ModelNode sessionTimeout = legacyAddOp.get(WebSSLDefinition.SESSION_TIMEOUT.getName());        ModelNode sslProvider = legacyAddOp.get(WebSSLDefinition.SSL_PROTOCOL.getName());        if(verifyDepth.isDefined()) {            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.VERIFY_DEPTH.getName(), pathAddress(legacyAddOp.get(ADDRESS))));        }        if(certificateFile.isDefined()) {            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.CERTIFICATE_FILE.getName(), pathAddress(legacyAddOp.get(ADDRESS))));        }        if(sslProvider.isDefined()) {            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.SSL_PROTOCOL.getName(), pathAddress(legacyAddOp.get(ADDRESS))));        }        if(csRevocationURL.isDefined()) {            warnings.add(WebLogger.ROOT_LOGGER.couldNotMigrateResource(WebSSLDefinition.CA_REVOCATION_URL.getName(), pathAddress(legacyAddOp.get(ADDRESS))));        }        String realmName;        PathAddress managementCoreService;        if(domainMode) {            Set<String> hosts = new HashSet<>();            Resource hostResource = context.readResourceFromRoot(pathAddress(), false);            hosts.addAll(hostResource.getChildrenNames(HOST));            //now we need to find a unique name            //in domain mode different profiles could have different SSL configurations            //but the realms are not scoped to a profile            //if we hard coded a name migration would fail when migrating domains with multiple profiles            int counter = 1;            realmName = REALM_NAME + counter;            while(true) {                boolean hostOk = true;                for(String host : hosts) {                    Resource root = context.readResourceFromRoot(pathAddress(pathElement(HOST, host), pathElement(CORE_SERVICE, MANAGEMENT)), false);                    if (root.getChildrenNames(SECURITY_REALM).contains(realmName)) {                        counter++;                        realmName = REALM_NAME + counter;                        hostOk = false;                        break;                    }                }                if(hostOk) {                    break;                }            }            for (String host : hosts) {                createHostSSLConfig(realmName, migrationOperations, keyAlias, password, certificateKeyFile, protocol, caCertificateFile, caCertificatePassword, trustStoreType, keystoreType, pathAddress(pathElement(HOST, host), pathElement(CORE_SERVICE, MANAGEMENT)));            }        } else {            managementCoreService = pathAddress(CORE_SERVICE, MANAGEMENT);            //now we need to find a unique name            //in domain mode different profiles could have different SSL configurations            //but the realms are not scoped to a profile            //if we hard coded a name migration would fail when migrating domains with multiple profiles            int counter = 1;            realmName = REALM_NAME + counter;            boolean ok = false;            do {                Resource root = context.readResourceFromRoot(managementCoreService, false);                if (root.getChildrenNames(SECURITY_REALM).contains(realmName)) {                    counter++;                    realmName = REALM_NAME + counter;                } else {                    ok = true;                }            } while (!ok);            //we have a unique realm name            createHostSSLConfig(realmName, migrationOperations, keyAlias, password, certificateKeyFile, protocol, caCertificateFile, caCertificatePassword, trustStoreType, keystoreType, managementCoreService);        }        return new SSLInformation(realmName, verifyClient, sessionCacheSize, sessionTimeout, protocol, cipherSuite);    }
private void createIoSubsystem(OperationContext context, Map<PathAddress, ModelNode> migrationOperations, PathAddress baseAddress) {        Resource root = context.readResourceFromRoot(baseAddress, false);        if (root.getChildrenNames(SUBSYSTEM).contains(IOExtension.SUBSYSTEM_NAME)) {            // subsystem is already added, do nothing            return;        }        //these addresses will be fixed later, no need to use the base address        PathAddress address = pathAddress(pathElement(SUBSYSTEM, IOExtension.SUBSYSTEM_NAME));        migrationOperations.put(address, createAddOperation(address));        address = pathAddress(pathElement(SUBSYSTEM, IOExtension.SUBSYSTEM_NAME), pathElement("worker", "default"));        migrationOperations.put(address, createAddOperation(address));        address = pathAddress(pathElement(SUBSYSTEM, IOExtension.SUBSYSTEM_NAME), pathElement("buffer-pool", "default"));        migrationOperations.put(address, createAddOperation(address));    }
private void createWelcomeContentHandler(Map<PathAddress, ModelNode> migrationOperations) {        PathAddress address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), pathElement(Constants.CONFIGURATION, Constants.HANDLER));        migrationOperations.put(address, createAddOperation(address));        address = pathAddress(pathElement(SUBSYSTEM, UndertowExtension.SUBSYSTEM_NAME), pathElement(Constants.CONFIGURATION, Constants.HANDLER), pathElement(Constants.FILE, "welcome-content"));        final ModelNode add = createAddOperation(address);        add.get(Constants.PATH).set(new ModelNode(new ValueExpression("${jboss.home.dir}/welcome-content")));        migrationOperations.put(address, add);    }
private String getDefaultResourceAdapterName(final ServiceRegistry serviceRegistry) {        if (appclient) {            // we must report the MDB, but we can't use any MDB/JCA facilities            return "n/a";        }        final ServiceController<DefaultResourceAdapterService> serviceController = (ServiceController<DefaultResourceAdapterService>) serviceRegistry.getRequiredService(DefaultResourceAdapterService.DEFAULT_RA_NAME_SERVICE_NAME);        return serviceController.getValue().getDefaultResourceAdapterName();    }
public T get() {        try {            boolean acquired = semaphore.tryAcquire(timeout, timeUnit);            if (!acquired)                throw EjbLogger.ROOT_LOGGER.failedToAcquirePermit(timeout, timeUnit);        } catch (InterruptedException e) {            throw EjbLogger.ROOT_LOGGER.acquireSemaphoreInterrupted();        }        T bean = pool.poll();        if( bean !=null) {            //we found a bean instance in the pool, return it            return bean;        }        try {            // Pool is empty, create an instance            bean = create();        } finally {            if (bean == null) {                semaphore.release();            }        }        return bean;    }
public void release(T obj) {        if (ROOT_LOGGER.isTraceEnabled()) {            ROOT_LOGGER.tracef("%s/%s Free instance: %s", pool.size(), maxSize, this);        }        pool.add(obj);        semaphore.release();    }
protected ArrayList getContainedEntries() {        final ArrayList ret = new ArrayList(constants.length + attributes.length + operations.length);        for (int i = 0; i < constants.length; ++i)            ret.add(constants[i]);        for (int i = 0; i < attributes.length; ++i)            ret.add(attributes[i]);        for (int i = 0; i < operations.length; ++i)            ret.add(operations[i]);        return ret;    }
protected void analyzeOperations() throws RMIIIOPViolationException {        if (!cls.isInterface())            throw IIOPLogger.ROOT_LOGGER.notAnInterface(cls.getName());        abstractInterface = RmiIdlUtil.isAbstractInterface(cls);        calculateAllTypeIds();        int operationCount = 0;        for (int i = 0; i < methods.length; ++i)            if ((m_flags[i] & (M_READ | M_WRITE | M_READONLY)) == 0)                ++operationCount;        operations = new OperationAnalysis[operationCount];        operationCount = 0;        for (int i = 0; i < methods.length; ++i) {            if ((m_flags[i] & (M_READ | M_WRITE | M_READONLY)) == 0) {                operations[operationCount] = new OperationAnalysis(methods[i]);                ++operationCount;            }        }    }
protected void calculateOperationAnalysisMap() {        operationAnalysisMap = new HashMap();        OperationAnalysis oa;        // Map the operations        for (int i = 0; i < operations.length; ++i) {            oa = operations[i];            operationAnalysisMap.put(oa.getIDLName(), oa);        }        // Map the attributes        for (int i = 0; i < attributes.length; ++i) {            AttributeAnalysis attr = attributes[i];            oa = attr.getAccessorAnalysis();            // Not having an accessor analysis means that            // the attribute is not in a remote interface            if (oa != null) {                operationAnalysisMap.put(oa.getIDLName(), oa);                oa = attr.getMutatorAnalysis();                if (oa != null)                    operationAnalysisMap.put(oa.getIDLName(), oa);            }        }    }
protected void calculateAllTypeIds() {        if (!isRmiIdlRemoteInterface()) {            allTypeIds = new String[0];        } else {            ArrayList a = new ArrayList();            InterfaceAnalysis[] intfs = getInterfaces();            for (int i = 0; i < intfs.length; ++i) {                String[] ss = intfs[i].getAllTypeIds();                for (int j = 0; j < ss.length; ++j)                    if (!a.contains(ss[j]))                        a.add(ss[j]);            }            allTypeIds = new String[a.size() + 1];            allTypeIds[0] = getRepositoryId();            for (int i = 1; i <= a.size(); ++i)                allTypeIds[i] = (String) a.get(a.size() - i);        }    }
public MetricRegistration collectResourceMetrics(final Resource resource,                                              ImmutableManagementResourceRegistration managementResourceRegistration,                                              Function<PathAddress, PathAddress> resourceAddressResolver) {        MetricRegistration registration = new MetricRegistration();        collectResourceMetrics0(resource, managementResourceRegistration, EMPTY_ADDRESS, resourceAddressResolver, registration);        return registration;    }
protected DeploymentUnit doPrepare(String context, ClassLoader loader,            Map<String, String> urlPatternToClassNameMap, JBossWebMetaData jbwmd, WebservicesMetaData metadata, JBossWebservicesMetaData jbwsMetadata) {        ClassLoader origClassLoader = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        WSEndpointDeploymentUnit unit = new WSEndpointDeploymentUnit(loader, context, urlPatternToClassNameMap, jbwmd, metadata, jbwsMetadata);        try {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader());            WSDeploymentBuilder.getInstance().build(unit);            return unit;        } finally {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(origClassLoader);        }    }
protected void doDeploy(ServiceTarget target, DeploymentUnit unit) {        List<DeploymentAspect> aspects = getDeploymentAspects();        ClassLoader origClassLoader = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        Deployment dep = null;        try {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(ClassLoaderProvider.getDefaultProvider().getServerIntegrationClassLoader());            dep = unit.getAttachment(WSAttachmentKeys.DEPLOYMENT_KEY);            dep.addAttachment(ServiceTarget.class, target);            DeploymentAspectManager dam = new DeploymentAspectManagerImpl();            dam.setDeploymentAspects(aspects);            dam.deploy(dep);        } finally {            if (dep != null) {                dep.removeAttachment(ServiceTarget.class);            }            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(origClassLoader);        }    }
protected Context doPublish(ServiceTarget target, DeploymentUnit unit) throws Exception {        Deployment deployment = unit.getAttachment(WSAttachmentKeys.DEPLOYMENT_KEY);        List<Endpoint> endpoints = deployment.getService().getEndpoints();        //If we're running in a Service, that will already have proper dependencies set on the installed endpoint services,        //otherwise we need to explicitly wait for the endpoint services to be started before creating the webapp.        if (!runningInService) {            final ServiceRegistry registry = unit.getServiceRegistry();            final StabilityMonitor monitor = new StabilityMonitor();            for (Endpoint ep : endpoints) {                final ServiceName serviceName = EndpointService.getServiceName(unit, ep.getShortName());                monitor.addController(registry.getRequiredService(serviceName));            }            try {                monitor.awaitStability();            } finally {                monitor.clear();            }        }        deployment.addAttachment(WebDeploymentController.class, startWebApp(host, unit)); //TODO simplify and use findChild later in destroy()/stopWebApp()        return new Context(unit.getAttachment(WSAttachmentKeys.JBOSSWEB_METADATA_KEY).getContextRoot(), endpoints);    }
protected void stopWebApp(Deployment deployment) throws Exception {        WebDeploymentController context;        try {            context = deployment.getAttachment(WebDeploymentController.class);            context.stop();        } catch (Exception e) {            throw WSLogger.ROOT_LOGGER.stopContextPhaseFailed(e);        }        try {            context.destroy();        } catch (Exception e) {            throw WSLogger.ROOT_LOGGER.destroyContextPhaseFailed(e);        }    }
public synchronized void start(final StartContext context) {        if (started) {            throw WeldLogger.ROOT_LOGGER.alreadyRunning("WeldContainer");        }        started = true;        WeldLogger.DEPLOYMENT_LOGGER.startingWeldService(deploymentName);        // set up injected services        addWeldService(SecurityServices.class, securityServicesSupplier.get());        TransactionServices transactionServices = weldTransactionServicesSupplier != null ? weldTransactionServicesSupplier.get() : null;        if (transactionServices != null) {            addWeldService(TransactionServices.class, transactionServices);        }        if (!deployment.getServices().contains(ExecutorServices.class)) {            addWeldService(ExecutorServices.class, executorServicesSupplier.get());        }        ModuleGroupSingletonProvider.addClassLoaders(deployment.getModule().getClassLoader(),                deployment.getSubDeploymentClassLoaders());        ClassLoader oldTccl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();        try {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(deployment.getModule().getClassLoader());            bootstrap.startContainer(deploymentName, environment, deployment);            WeldProvider.containerInitialized(Container.instance(deploymentName), getBeanManager(), deployment);        } finally {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(oldTccl);        }        weldBootstrapServiceConsumer.accept(this);    }
public synchronized void stop(final StopContext context) {        weldBootstrapServiceConsumer.accept(null);        if (started) {            // WeldStartService#stop() not completed - attempt to perform the container cleanup            final Container container = Container.instance(deploymentName);            if (container != null && !ContainerState.SHUTDOWN.equals(container.getState())) {                final ExecutorService executorService = serverExecutorSupplier.get();                final Runnable task = new Runnable() {                    @Override                    public void run() {                        WeldLogger.DEPLOYMENT_LOGGER.debugf("Weld container cleanup for deployment %s", deploymentName);                        ClassLoader oldTccl = WildFlySecurityManager.getCurrentContextClassLoaderPrivileged();                        try {                            WildFlySecurityManager                                    .setCurrentContextClassLoaderPrivileged(deployment.getModule().getClassLoader());                            WeldProvider.containerShutDown(container);                            container.setState(ContainerState.SHUTDOWN);                            container.cleanup();                            setStarted(false);                        } finally {                            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(oldTccl);                            ModuleGroupSingletonProvider.removeClassLoader(deployment.getModule().getClassLoader());                            context.complete();                        }                    }                };                try {                    executorService.execute(task);                } catch (RejectedExecutionException e) {                    task.run();                } finally {                    context.asynchronous();                }            }        }    }
public BeanManagerImpl getBeanManager(String beanArchiveId) {        if (!started) {            throw WeldLogger.ROOT_LOGGER.notStarted("WeldContainer");        }        BeanDeploymentArchive beanDeploymentArchive = beanDeploymentArchives.get(beanArchiveId);        if (beanDeploymentArchive == null) {            throw WeldLogger.ROOT_LOGGER.beanDeploymentNotFound(beanArchiveId);        }        return bootstrap.getManager(beanDeploymentArchive);    }
public <T extends org.jboss.weld.bootstrap.api.Service> void addWeldService(Class<T> type, T service) {        deployment.addWeldService(type, service);    }
public void registerEndpointConfig(final String endpointClass, final EndpointConfig config) {        if ((endpointClass == null) || (config == null)) {            throw new IllegalArgumentException();        }        endpointConfigMap.put(endpointClass, config);    }
private void addSetMessageDrivenContextMethodInvocationInterceptor() {        // add the setMessageDrivenContext(MessageDrivenContext) method invocation interceptor for MDB        // implementing the javax.ejb.MessageDrivenBean interface        this.getConfigurators().add(new ComponentConfigurator() {            @Override            public void configure(DeploymentPhaseContext context, ComponentDescription description, ComponentConfiguration configuration) throws DeploymentUnitProcessingException {                if (MessageDrivenBean.class.isAssignableFrom(configuration.getComponentClass())) {                    configuration.addPostConstructInterceptor(new ImmediateInterceptorFactory(MessageDrivenBeanSetMessageDrivenContextInterceptor.INSTANCE), InterceptorOrder.ComponentPostConstruct.EJB_SET_CONTEXT_METHOD_INVOCATION_INTERCEPTOR);                }            }        });    }
@Override    public void initializeParsers(final ExtensionParsingContext context) {        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, EESecurityExtension.NAMESPACE, new Supplier<XMLElementReader<List<ModelNode>>>() {            @Override            public XMLElementReader<List<ModelNode>> get() {                return parser;            }        });    }
@Override    public void run() {        ClassLoader old = WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(getClass());        try {            final TimerImpl timer = timerService.getTimer(timerId);            try {                if (cancelled) {                    EJB3_TIMER_LOGGER.debugf("Timer task was cancelled for %s", timer);                    return;                }                Date now = new Date();                EJB3_TIMER_LOGGER.debugf("Timer task invoked at: %s for timer %s", now, timer);                //we lock the timer for this check, because if a cancel is in progress or a running timeout is about to finish                //and try to update the timer state after finish the inTimeout method,                //we do not want to do the isActive check, but wait for the other transaction to finish                //one way or another                timer.lock();                try {                    // If a retry thread is in progress, we don't want to allow another                    // interval to execute until the retry is complete. See JIRA-1926.                    if (timer.isInRetry()) {                        EJB3_TIMER_LOGGER.skipInvokeTimeoutDuringRetry(timer, now);                        // compute the next timeout, See JIRA AS7-2995.                        timer.setNextTimeout(calculateNextTimeout(timer));                        timerService.persistTimer(timer, false);                        scheduleTimeoutIfRequired(timer);                        return;                    }                    // Check whether the timer is running local                    // If the recurring timer running longer than the interval is, we don't want to allow another                    // execution until it is complete. See JIRA AS7-3119                    if (timer.getState() == TimerState.IN_TIMEOUT || timer.getState() == TimerState.RETRY_TIMEOUT) {                        EJB3_TIMER_LOGGER.skipOverlappingInvokeTimeout(timer, now);                        if (EJB3_TIMER_LOGGER.isDebugEnabled()) {                            // WFLY-10542 log thread stack trace which is processing timer task in debug level to diagnose timer overlap                            Thread otherThread = timer.getExecutingThread();                            // can be null for clustered timers if the timer is executing on another node.                            if (otherThread != null) {                                final StringBuilder debugMsg = new StringBuilder()                                        .append("Thread: ")                                        .append(otherThread.getName())                                        .append(" Id: ")                                        .append(otherThread.getId())                                        .append(" of group ")                                        .append(otherThread.getThreadGroup())                                        .append(" is in state: ")                                        .append(otherThread.getState());                                for (StackTraceElement ste : otherThread.getStackTrace()) {                                    debugMsg.append(System.lineSeparator()).append(ste.toString());                                }                                EJB3_TIMER_LOGGER.debugf(debugMsg.toString());                            }                        }                        Date newD = this.calculateNextTimeout(timer);                        timer.setNextTimeout(newD);                        timerService.persistTimer(timer, false);                        scheduleTimeoutIfRequired(timer);                        return;                    }                    // Check whether we want to run the timer                    if (!timerService.shouldRun(timer)) {                        EJB3_TIMER_LOGGER.debugf("Skipping execution of timer for %s as it is being run on another node or the execution is suppressed by configuration", timer.getTimedObjectId());                        timer.setNextTimeout(calculateNextTimeout(timer));                        scheduleTimeoutIfRequired(timer);                        return;                    }                    if (!timer.isActive()) {                        EJB3_TIMER_LOGGER.debug("Timer is not active, skipping this scheduled execution at: " + now + "for " + timer);                        return;                    }                    // set the current date as the "previous run" of the timer.                    timer.setPreviousRun(new Date());                    Date nextTimeout = this.calculateNextTimeout(timer);                    timer.setNextTimeout(nextTimeout);                    // change the state to mark it as in timeout method                    timer.setTimerState(TimerState.IN_TIMEOUT, Thread.currentThread());                    // persist changes                    timerService.persistTimer(timer, false);                } finally {                    timer.unlock();                }                try {                    // invoke timeout                    this.callTimeout(timer);                } catch (Exception e) {                    EJB3_TIMER_LOGGER.errorInvokeTimeout(timer, e);                    try {                        EJB3_TIMER_LOGGER.timerRetried(timer);                        retryTimeout(timer);                    } catch (Exception retryException) {                        // that's it, we can't do anything more. Let's just log the exception                        // and return                        EJB3_TIMER_LOGGER.errorDuringRetryTimeout(timer, retryException);                    }                } finally {                    this.postTimeoutProcessing(timer);                }            } catch (Exception e) {                EJB3_TIMER_LOGGER.exceptionRunningTimerTask(timer, timedObjectId, e);            }        } finally {            WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(old);        }    }
protected void retryTimeout(TimerImpl timer) throws Exception {        boolean callTimeout = false;        timer.lock();        try {            if (timer.isActive()) {                EJB3_TIMER_LOGGER.retryingTimeout(timer);                timer.setTimerState(TimerState.RETRY_TIMEOUT, Thread.currentThread());                timerService.persistTimer(timer, false);                callTimeout = true;            } else {                EJB3_TIMER_LOGGER.timerNotActive(timer);            }        } finally {            timer.unlock();        }        if(callTimeout) {            this.callTimeout(timer);        }    }
protected void postTimeoutProcessing(TimerImpl timer) throws InterruptedException {        timer.lock();        try {            TimerState timerState = timer.getState();            if (timerState != TimerState.CANCELED                    && timerState != TimerState.EXPIRED) {                if (timer.getInterval() == 0) {                    timerService.expireTimer(timer);                } else {                    timer.setTimerState(TimerState.ACTIVE, null);                }                timerService.persistTimer(timer, false);            }        } finally {            timer.unlock();        }    }
@Override    public void initialize(ExtensionContext context) {        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);        // Register the root subsystem resource.        final ManagementResourceRegistration rootResource = subsystem.registerSubsystemModel(new JSR77ManagementRootResource(context.getProcessType() == ProcessType.APPLICATION_CLIENT));        // Mandatory describe operation        rootResource.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);        subsystem.registerXMLElementWriter(parser);    }
static Method[] getDeclaredMethods(final Class<?> c) {        if (System.getSecurityManager() == null)            return c.getDeclaredMethods();        return AccessController.doPrivileged(new PrivilegedAction<Method[]>() {            public Method[] run() {                return c.getDeclaredMethods();            }        });    }
static Field[] getDeclaredFields(final Class<?> c) {        if (System.getSecurityManager() == null)            return c.getDeclaredFields();        return AccessController.doPrivileged(new PrivilegedAction<Field[]>() {            public Field[] run() {                return c.getDeclaredFields();            }        });    }
static void setAccessible(final AccessibleObject ao) {        if (System.getSecurityManager() == null)            ao.setAccessible(true);        AccessController.doPrivileged(new PrivilegedAction<Object>() {            public Object run() {                ao.setAccessible(true);                return null;            }        });    }
static Constructor<?> getConstructor(final Class<?> c, final Class<?>... params)            throws NoSuchMethodException {        if (System.getSecurityManager() == null)            return c.getConstructor(params);        Constructor<?> result = AccessController.doPrivileged(new PrivilegedAction<Constructor<?>>() {            public Constructor<?> run() {                try {                    return c.getConstructor(params);                } catch (NoSuchMethodException e) {                    return null;                }            }        });        if (result != null)            return result;        throw new NoSuchMethodException();    }
static Method getMethod(final Class<?> c, final String name, final Class<?>... params)            throws NoSuchMethodException {        if (System.getSecurityManager() == null)            return c.getMethod(name, params);        Method result = AccessController.doPrivileged(new PrivilegedAction<Method>() {            public Method run() {                try {                    return c.getMethod(name, params);                } catch (NoSuchMethodException e) {                    return null;                }            }        });        if (result != null)            return result;        throw new NoSuchMethodException();    }
private void fixAddressesForDomainMode(PathAddress parentAddress, Map<PathAddress, ModelNode> migrationOperations) {        // in standalone mode, do nothing        if (parentAddress.size() == 0) {            return;        }        // use a linked hash map to preserve operations order        Map<PathAddress, ModelNode> fixedMigrationOperations = new LinkedHashMap<>(migrationOperations);        migrationOperations.clear();        for (Map.Entry<PathAddress, ModelNode> entry : fixedMigrationOperations.entrySet()) {            PathAddress fixedAddress = parentAddress.append(entry.getKey());            entry.getValue().get(ADDRESS).set(fixedAddress.toModelNode());            migrationOperations.put(fixedAddress, entry.getValue());        }    }
private void addMessagingActiveMQExtension(OperationContext context, Map<PathAddress, ModelNode> migrationOperations, boolean describe) {        Resource root = context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS, false);        if (root.getChildrenNames(EXTENSION).contains(MESSAGING_ACTIVEMQ_EXTENSION)) {            // extension is already added, do nothing            return;        }        PathAddress extensionAddress = pathAddress(EXTENSION, MESSAGING_ACTIVEMQ_EXTENSION);        OperationEntry addEntry = context.getRootResourceRegistration().getOperationEntry(extensionAddress, ADD);        ModelNode addOperation = createAddOperation(extensionAddress);        addOperation.get(MODULE).set(MESSAGING_ACTIVEMQ_MODULE);        if (describe) {            migrationOperations.put(extensionAddress, addOperation);        } else {            context.addStep(context.getResult().get(extensionAddress.toString()), addOperation, addEntry.getOperationHandler(), MODEL);        }    }
private boolean parameterIsAllowed(String name, String resourceType) {        switch (resourceType) {            case REMOTE_ACCEPTOR:            case HTTP_ACCEPTOR:            case REMOTE_CONNECTOR:            case HTTP_CONNECTOR:                // WFLY-5667 - for now remove only use-nio. Revisit this code when Artemis offers an API                // to know which parameters are ignored.                if ("use-nio".equals(name)) {                    return false;                } else {                    return true;                }            default:                // accept any parameter for other resources.                return true;        }    }
private void migrateGenericTransport(ModelNode addOperation) {        String factoryClass = addOperation.get(FACTORY_CLASS.getName()).asString();        final String newFactoryClass;        switch (factoryClass) {            case HORNETQ_NETTY_ACCEPTOR_FACTORY:                newFactoryClass = ARTEMIS_NETTY_ACCEPTOR_FACTORY;                break;            case HORNETQ_NETTY_CONNECTOR_FACTORY:                newFactoryClass = ARTEMIS_NETTY_CONNECTOR_FACTORY;                break;            default:                newFactoryClass = factoryClass;        }        addOperation.get(FACTORY_CLASS.getName()).set(newFactoryClass);    }
private void setAndDiscard(ModelNode setNode, ModelNode discardNode, AttributeDefinition legacyAttributeDefinition, String newAttributeName) {        ModelNode attribute = discardNode.get(legacyAttributeDefinition.getName());        if (attribute.isDefined()) {            setNode.get(newAttributeName).set(attribute);            discardNode.remove(legacyAttributeDefinition.getName());        }    }
@Override    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);        ModelNode eeSubSystem = context.getModelNode();        GlobalModulesDefinition.INSTANCE.marshallAsElement(eeSubSystem, writer);        EeSubsystemRootResource.EAR_SUBDEPLOYMENTS_ISOLATED.marshallAsElement(eeSubSystem, writer);        EeSubsystemRootResource.SPEC_DESCRIPTOR_PROPERTY_REPLACEMENT.marshallAsElement(eeSubSystem, writer);        EeSubsystemRootResource.JBOSS_DESCRIPTOR_PROPERTY_REPLACEMENT.marshallAsElement(eeSubSystem, writer);        EeSubsystemRootResource.ANNOTATION_PROPERTY_REPLACEMENT.marshallAsElement(eeSubSystem, writer);        writeConcurrentElement(writer,eeSubSystem);        writeDefaultBindingsElement(writer,eeSubSystem);        writer.writeEndElement();    }
@Override    protected void processBeanMetaData(final SessionBeanMetaData sessionBean, final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();        // get the module description        final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);        final String beanName = sessionBean.getName();        ComponentDescription bean = moduleDescription.getComponentByName(beanName);        if (appclient) {            if (bean == null) {                for (final ComponentDescription component : deploymentUnit.getAttachmentList(Attachments.ADDITIONAL_RESOLVABLE_COMPONENTS)) {                    if (component.getComponentName().equals(beanName)) {                        bean = component;                        break;                    }                }            }        }        if (!(bean instanceof SessionBeanComponentDescription)) {            //TODO: this is a hack to deal with descriptor merging            //if this is a GenericBeanMetadata it may actually represent an MDB            return;        }        SessionBeanComponentDescription sessionBeanDescription = (SessionBeanComponentDescription) bean;        sessionBeanDescription.setDeploymentDescriptorEnvironment(new DeploymentDescriptorEnvironment("java:comp/env/", sessionBean));        // mapped-name        sessionBeanDescription.setMappedName(sessionBean.getMappedName());        // local business interface views        final BusinessLocalsMetaData businessLocals = sessionBean.getBusinessLocals();        if (businessLocals != null && !businessLocals.isEmpty()) {            sessionBeanDescription.addLocalBusinessInterfaceViews(businessLocals);        }        final String local = sessionBean.getLocal();        if (local != null) {            sessionBeanDescription.addEjbLocalObjectView(local);        }        final String remote = sessionBean.getRemote();        if (remote != null) {            sessionBeanDescription.addEjbObjectView(remote);        }        // remote business interface views        final BusinessRemotesMetaData businessRemotes = sessionBean.getBusinessRemotes();        if (businessRemotes != null && !businessRemotes.isEmpty()) {            sessionBeanDescription.addRemoteBusinessInterfaceViews(businessRemotes);        }        // process EJB3.1 specific session bean description        if (sessionBean instanceof SessionBean31MetaData) {            this.processSessionBean31((SessionBean31MetaData) sessionBean, sessionBeanDescription);        }    }
public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {        // deploy any persistence providers found in deployment        PersistenceProviderHandler.deploy(phaseContext, platform);        // start each PU service (except the PUs with property Configuration.JPA_CONTAINER_CLASS_TRANSFORMER = false)        PersistenceUnitServiceHandler.deploy(phaseContext, true, platform);    }
public boolean cancel(boolean setFlag) {        final AtomicInteger stateRef = this.stateRef;        int oldVal, newVal;        do {            oldVal = stateRef.get();            if (oldVal == ST_WAITING) {                newVal = ST_CANCELLED;            } else if (oldVal == ST_CANCELLED) {                if (! setFlag) {                    return true;                }                newVal = ST_CANCELLED_FLAG_SET;            } else if (oldVal == ST_CANCELLED_FLAG_SET) {                // do nothing                return true;            } else if (oldVal == ST_STARTED) {                if (! setFlag) {                    return false;                }                newVal = ST_STARTED_FLAG_SET;            } else {                assert oldVal == ST_STARTED_FLAG_SET;                return false;            }        } while (! stateRef.compareAndSet(oldVal, newVal));        return newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET;    }
public boolean runIfNotCancelled() {        final AtomicInteger stateRef = this.stateRef;        int oldVal;        do {            oldVal = stateRef.get();            if (oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET) {                return false;            } else if (oldVal != ST_WAITING) {                throw Assert.unreachableCode();            }        } while (! stateRef.compareAndSet(oldVal, ST_STARTED));        return true;    }
protected void setTypeInternal(final OType iType) {    getDatabase().checkSecurity(ORule.ResourceGeneric.SCHEMA, ORole.PERMISSION_UPDATE);    acquireSchemaWriteLock();    try {      if (iType == globalRef.getType())        // NO CHANGES        return;      if (!iType.getCastable().contains(globalRef.getType()))        throw new IllegalArgumentException("Cannot change property type from " + globalRef.getType() + " to " + iType);      this.globalRef = owner.owner.findOrCreateGlobalProperty(this.globalRef.getName(), iType);    } finally {      releaseSchemaWriteLock();    }  }
@SuppressWarnings("unused")  public static void getPageData(final ByteBuffer buffer, final byte[] data, final int offset, final int length) {    buffer.position(0);    buffer.get(data, offset, length);  }
@SuppressWarnings("unused")  public static OLogSequenceNumber getLogSequenceNumber(final int offset, final byte[] data) {    final long segment = OLongSerializer.INSTANCE.deserializeNative(data, offset + WAL_SEGMENT_OFFSET);    final long position = OLongSerializer.INSTANCE.deserializeNative(data, offset + WAL_POSITION_OFFSET);    return new OLogSequenceNumber(segment, position);  }
@SuppressWarnings({ "rawtypes", "unchecked" })  public static Object cloneObject(final Object objectToClone, final Object previousClone) {    // ***************************************************************************************************************************************    // 1. Class by class cloning (only clones known types)    // ***************************************************************************************************************************************    // Clone any Map (shallow clone should be enough at this level)    if (objectToClone instanceof Map) {      Map recycledMap = (Map) previousClone;      if (recycledMap == null)        recycledMap = new HashMap();      else        recycledMap.clear();      recycledMap.putAll((Map<?, ?>) objectToClone);      return recycledMap;      // Clone any collection (shallow clone should be enough at this level)    } else if (objectToClone instanceof Collection) {      Collection recycledCollection = (Collection) previousClone;      if (recycledCollection == null)        recycledCollection = new ArrayList();      else        recycledCollection.clear();      recycledCollection.addAll((Collection<?>) objectToClone);      return recycledCollection;      // Clone String    } else if (objectToClone instanceof String) {      return objectToClone;    } else if (objectToClone instanceof Number) {      return objectToClone;      // Clone Date    } else if (objectToClone instanceof Date) {      return (Date) ((Date) objectToClone).clone();    } else {      // ***************************************************************************************************************************************      // 2. Polymorphic clone (by reflection, looks for a clone() method in hierarchy and invoke it)      // ***************************************************************************************************************************************      try {        Object newClone;        for (Class<?> obj = objectToClone.getClass(); !obj.equals(Object.class); obj = obj.getSuperclass()) {          Method m[] = obj.getDeclaredMethods();          for (int i = 0; i < m.length; i++) {            if (m[i].getName().equals("clone")) {              m[i].setAccessible(true);              newClone = m[i].invoke(objectToClone);              System.out.println(objectToClone.getClass()                  + " cloned by Reflection. Performance can be improved by adding the class to the list of known types");              return newClone;            }          }        }        throw new Exception("Method clone not found");        // ***************************************************************************************************************************************        // 3. Polymorphic clone (Deep cloning by Serialization)        // ***************************************************************************************************************************************      } catch (Exception e1) {        try {          final ByteArrayOutputStream bytes = new ByteArrayOutputStream() {            public synchronized byte[] toByteArray() {              return buf;            }          };          final ObjectOutputStream out = new ObjectOutputStream(bytes);          out.writeObject(objectToClone);          out.close();          final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray()));          System.out.println(objectToClone.getClass()              + " cloned by Serialization. Performance can be improved by adding the class to the list of known types");          return in.readObject();          // ***************************************************************************************************************************************          // 4. Impossible to clone          // ***************************************************************************************************************************************        } catch (Exception e2) {          OLogManager.instance()              .error(null, "[GremlinHelper] error on cloning object %s, previous %s", e2, objectToClone, previousClone);          return null;        }      }    }  }
public void inputGraph(final String filename, int bufferSize, final Set<String> edgePropertyKeys,      final Set<String> vertexPropertyKeys) throws IOException {    final File file = new File(filename);    if (!file.exists())      throw new ODatabaseImportException("File '" + filename + "' not found");    inputSize = file.length();    final FileInputStream fis = new FileInputStream(filename);    try {      inputGraph(fis, bufferSize, edgePropertyKeys, vertexPropertyKeys);    } finally {      fis.close();    }  }
public void inputGraph(final InputStream jsonInputStream, int bufferSize, final Set<String> edgePropertyKeys,      final Set<String> vertexPropertyKeys) throws IOException {    final JsonParser jp = jsonFactory.createJsonParser(jsonInputStream);    // if this is a transactional localGraph then we're buffering    final BatchGraph batchGraph = BatchGraph.wrap(graph, bufferSize);    final ElementFactory elementFactory = new GraphElementFactory(batchGraph);    OGraphSONUtility graphson = new OGraphSONUtility(GraphSONMode.NORMAL, elementFactory, vertexPropertyKeys, edgePropertyKeys);    long importedVertices = 0;    long importedEdges = 0;    while (jp.nextToken() != JsonToken.END_OBJECT) {      final String fieldname = jp.getCurrentName() == null ? "" : jp.getCurrentName();      if (fieldname.equals(GraphSONTokens.MODE)) {        jp.nextToken();        final GraphSONMode mode = GraphSONMode.valueOf(jp.getText());        graphson = new OGraphSONUtility(mode, elementFactory, vertexPropertyKeys, edgePropertyKeys);      } else if (fieldname.equals(GraphSONTokens.VERTICES)) {        jp.nextToken();        while (jp.nextToken() != JsonToken.END_ARRAY) {          final JsonNode node = jp.readValueAsTree();          graphson.vertexFromJson(node);          importedVertices++;          printStatus(jp, importedVertices, importedEdges);          if (importedVertices % 1000 == 0)            ODatabaseRecordThreadLocal.instance().get().getLocalCache().invalidate();        }      } else if (fieldname.equals(GraphSONTokens.EDGES)) {        jp.nextToken();        while (jp.nextToken() != JsonToken.END_ARRAY) {          final JsonNode node = jp.readValueAsTree();          final Vertex inV = batchGraph.getVertex(OGraphSONUtility.getTypedValueFromJsonNode(node.get(GraphSONTokens._IN_V)));          final Vertex outV = batchGraph.getVertex(OGraphSONUtility.getTypedValueFromJsonNode(node.get(GraphSONTokens._OUT_V)));          graphson.edgeFromJson(node, outV, inV);          importedEdges++;          printStatus(jp, importedVertices, importedEdges);          if (importedEdges % 1000 == 0)            ODatabaseRecordThreadLocal.instance().get().getLocalCache().invalidate();        }      }    }    jp.close();    batchGraph.commit();  }
public static OIndexDefinition createIndexDefinition(final OClass oClass, final List<String> fieldNames, final List<OType> types,      List<OCollate> collates, String indexKind, String algorithm) {    checkTypes(oClass, fieldNames, types);    if (fieldNames.size() == 1)      return createSingleFieldIndexDefinition(oClass, fieldNames.get(0), types.get(0), collates == null ? null : collates.get(0),          indexKind, algorithm);    else      return createMultipleFieldIndexDefinition(oClass, fieldNames, types, collates, indexKind, algorithm);  }
public static String extractFieldName(final String fieldDefinition) {    String[] fieldNameParts = FILED_NAME_PATTERN.split(fieldDefinition);    if (fieldNameParts.length == 0) {      throw new IllegalArgumentException(          "Illegal field name format, should be '<property> [by key|value]' but was '" + fieldDefinition + '\'');    }    if (fieldNameParts.length == 3 && "by".equalsIgnoreCase(fieldNameParts[1]))      return fieldNameParts[0];    if (fieldNameParts.length == 1)      return fieldDefinition;    StringBuilder result = new StringBuilder();    result.append(fieldNameParts[0]);    for (int i = 1; i < fieldNameParts.length; i++) {      result.append(" ");      result.append(fieldNameParts[i]);    }    return result.toString();  }
public boolean canExecuteIndexedFunctionWithoutIndex(OFromClause target, OCommandContext context, OBinaryCompareOperator operator,      Object right) {    if (this.identifier == null) {      return false;    }    return identifier.canExecuteIndexedFunctionWithoutIndex(target, context, operator, right);  }
public long estimate(OClass oClass, long threshold, OCommandContext ctx) {    long count = oClass.count();    if (count > 1) {      count = count / 2;    }    if (count < threshold) {      return count;    }    long indexesCount = 0l;    List<OAndBlock> flattenedConditions = flatten();    Set<OIndex<?>> indexes = oClass.getIndexes();    for (OAndBlock condition : flattenedConditions) {      List<OBinaryCondition> indexedFunctConditions = condition          .getIndexedFunctionConditions(oClass, (ODatabaseDocumentInternal) ctx.getDatabase());      long conditionEstimation = Long.MAX_VALUE;      if (indexedFunctConditions != null) {        for (OBinaryCondition cond : indexedFunctConditions) {          OFromClause from = new OFromClause(-1);          OFromItem item = new OFromItem(-1);          from.item = item;          from.item.setIdentifier(new OIdentifier(oClass.getName()));          long newCount = cond.estimateIndexed(from, ctx);          if (newCount < conditionEstimation) {            conditionEstimation = newCount;          }        }      } else {        Map<String, Object> conditions = getEqualityOperations(condition, ctx);        for (OIndex index : indexes) {          if (index.getType().equals(OClass.INDEX_TYPE.FULLTEXT.name()) || index.getType()              .equals(OClass.INDEX_TYPE.FULLTEXT_HASH_INDEX.name())) {            continue;          }          List<String> indexedFields = index.getDefinition().getFields();          int nMatchingKeys = 0;          for (String indexedField : indexedFields) {            if (conditions.containsKey(indexedField)) {              nMatchingKeys++;            } else {              break;            }          }          if (nMatchingKeys > 0) {            long newCount = estimateFromIndex(index, conditions, nMatchingKeys);            if (newCount < conditionEstimation) {              conditionEstimation = newCount;            }          }        }      }      if (conditionEstimation > count) {        return count;      }      indexesCount += conditionEstimation;    }    return Math.min(indexesCount, count);  }
private static List<Class<?>> findClasses(final File iDirectory, String iPackageName, ClassLoader iClassLoader)      throws ClassNotFoundException {    final List<Class<?>> classes = new ArrayList<Class<?>>();    if (!iDirectory.exists())      return classes;    iPackageName += "." + iDirectory.getName();    String className;    final File[] files = iDirectory.listFiles();    if (files != null)      for (File file : files) {        if (file.isDirectory()) {          if (file.getName().contains("."))            continue;          classes.addAll(findClasses(file, iPackageName, iClassLoader));        } else if (file.getName().endsWith(CLASS_EXTENSION)) {          className = file.getName().substring(0, file.getName().length() - CLASS_EXTENSION.length());          classes.add(Class.forName(iPackageName + '.' + className, true, iClassLoader));        }      }    return classes;  }
public static List<Class<?>> getClassessOfInterface(String thePackage, Class<?> theInterface, final ClassLoader iClassLoader) {    List<Class<?>> classList = new ArrayList<Class<?>>();    try {      for (Class<?> discovered : getClassesFor(thePackage, iClassLoader)) {        if (Arrays.asList(discovered.getInterfaces()).contains(theInterface)) {          classList.add(discovered);        }      }    } catch (ClassNotFoundException ex) {      OLogManager.instance().error(null, "Error finding classes", ex);    }    return classList;  }
public static Type[] getGenericTypes(final Class<?> iClass) {    final Type genericType = iClass.getGenericInterfaces()[0];    if (genericType != null && genericType instanceof ParameterizedType) {      final ParameterizedType pt = (ParameterizedType) genericType;      if (pt.getActualTypeArguments() != null && pt.getActualTypeArguments().length > 1)        return pt.getActualTypeArguments();    }    return null;  }
public static Class<?> getGenericMultivalueType(final Field p) {    if (p.getType() instanceof Class<?>) {      final Type genericType = p.getGenericType();      if (genericType != null && genericType instanceof ParameterizedType) {        final ParameterizedType pt = (ParameterizedType) genericType;        if (pt.getActualTypeArguments() != null && pt.getActualTypeArguments().length > 0) {          if (((Class<?>) pt.getRawType()).isAssignableFrom(Map.class)) {            if (pt.getActualTypeArguments()[1] instanceof Class<?>) {              return (Class<?>) pt.getActualTypeArguments()[1];            } else if (pt.getActualTypeArguments()[1] instanceof ParameterizedType)              return (Class<?>) ((ParameterizedType) pt.getActualTypeArguments()[1]).getRawType();          } else if (pt.getActualTypeArguments()[0] instanceof Class<?>) {            return (Class<?>) pt.getActualTypeArguments()[0];          } else if (pt.getActualTypeArguments()[0] instanceof ParameterizedType)            return (Class<?>) ((ParameterizedType) pt.getActualTypeArguments()[0]).getRawType();        }      } else if (p.getType().isArray())        return p.getType().getComponentType();    }    return null;  }
public static boolean isJavaType(Class<?> clazz) {    if (clazz.isPrimitive())      return true;    else if (clazz.getName().startsWith("java.lang"))      return true;    else if (clazz.getName().startsWith("java.util"))      return true;    else if (clazz.isArray())      return true;    return false;  }
public Object execute(final Object iThis, final OIdentifiable iCurrentRecord, final Object iCurrentResult,      final OCommandContext iContext) {    if (iThis == null)      return null;    if (configuredParameters != null) {      // RESOLVE VALUES USING THE CURRENT RECORD      for (int i = 0; i < configuredParameters.length; ++i) {        runtimeParameters[i] = configuredParameters[i];        if (method.evaluateParameters()) {          if (configuredParameters[i] instanceof OSQLFilterItemField) {            runtimeParameters[i] = ((OSQLFilterItemField) configuredParameters[i]).getValue(iCurrentRecord, iCurrentResult,                iContext);            if (runtimeParameters[i] == null && iCurrentResult instanceof OIdentifiable)              // LOOK INTO THE CURRENT RESULT              runtimeParameters[i] = ((OSQLFilterItemField) configuredParameters[i]).getValue((OIdentifiable) iCurrentResult,                  iCurrentResult, iContext);          } else if (configuredParameters[i] instanceof OSQLMethodRuntime)            runtimeParameters[i] = ((OSQLMethodRuntime) configuredParameters[i]).execute(iThis, iCurrentRecord, iCurrentResult,                iContext);          else if (configuredParameters[i] instanceof OSQLFunctionRuntime)            runtimeParameters[i] = ((OSQLFunctionRuntime) configuredParameters[i]).execute(iCurrentRecord, iCurrentRecord, iCurrentResult,                iContext);          else if (configuredParameters[i] instanceof OSQLFilterItemVariable) {            runtimeParameters[i] = ((OSQLFilterItemVariable) configuredParameters[i]).getValue(iCurrentRecord, iCurrentResult,                iContext);            if (runtimeParameters[i] == null && iCurrentResult instanceof OIdentifiable)              // LOOK INTO THE CURRENT RESULT              runtimeParameters[i] = ((OSQLFilterItemVariable) configuredParameters[i]).getValue((OIdentifiable) iCurrentResult,                  iCurrentResult, iContext);          } else if (configuredParameters[i] instanceof OCommandSQL) {            try {              runtimeParameters[i] = ((OCommandSQL) configuredParameters[i]).setContext(iContext).execute();            } catch (OCommandExecutorNotFoundException ignore) {              // TRY WITH SIMPLE CONDITION              final String text = ((OCommandSQL) configuredParameters[i]).getText();              final OSQLPredicate pred = new OSQLPredicate(text);              runtimeParameters[i] = pred.evaluate(iCurrentRecord instanceof ORecord ? (ORecord) iCurrentRecord : null,                  (ODocument) iCurrentResult, iContext);              // REPLACE ORIGINAL PARAM              configuredParameters[i] = pred;            }          } else if (configuredParameters[i] instanceof OSQLPredicate)            runtimeParameters[i] = ((OSQLPredicate) configuredParameters[i]).evaluate(iCurrentRecord.getRecord(),                (iCurrentRecord instanceof ODocument ? (ODocument) iCurrentResult : null), iContext);          else if (configuredParameters[i] instanceof String) {            if (configuredParameters[i].toString().startsWith("\"") || configuredParameters[i].toString().startsWith("'"))              runtimeParameters[i] = OIOUtils.getStringContent(configuredParameters[i]);          }        }      }      if (method.getMaxParams() == -1 || method.getMaxParams() > 0) {        if (runtimeParameters.length < method.getMinParams()            || (method.getMaxParams() > -1 && runtimeParameters.length > method.getMaxParams()))          throw new OCommandExecutionException("Syntax error: function '"              + method.getName()              + "' needs "              + (method.getMinParams() == method.getMaxParams() ? method.getMinParams() : method.getMinParams() + "-"                  + method.getMaxParams()) + " argument(s) while has been received " + runtimeParameters.length);      }    }    final Object functionResult = method.execute(iThis, iCurrentRecord, iContext, iCurrentResult, runtimeParameters);    return transformValue(iCurrentRecord, iContext, functionResult);  }
@Override  public Object evaluateRecord(final OIdentifiable iRecord, ODocument iCurrentResult, final OSQLFilterCondition iCondition,      final Object iLeft, final Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {    if (iLeft == null || iRight == null)      return false;    return iLeft.toString().indexOf(iRight.toString()) > -1;  }
protected OType deriveFieldType(ODocument iRecord, String fieldName, OType requestedFieldType) {    // Schema defined types can not be ignored    if (iRecord.getSchemaClass().existsProperty(fieldName)) {      return iRecord.getSchemaClass().getProperty(fieldName).getType();    }    // New type    if (requestedFieldType != null) {      return requestedFieldType;    }    // Existing type (not fixed by the schema)    return iRecord.fieldType(fieldName);  }
public Object execute(final Map<Object, Object> iArgs) {    if (role == null)      throw new OCommandExecutionException("Cannot execute the command because it has not yet been parsed");    role.revoke(resource, privilege);    role.save();    return role;  }
public void updateRecord(final ORecord record) {    if (record.getIdentity().getClusterId() != excludedCluster && record.getIdentity().isValid() && !record.isDirty()        && !ORecordVersionHelper.isTombstone(record.getVersion())) {      if (underlying.get(record.getIdentity()) != record)        underlying.put(record);    }  }
public ORecord findRecord(final ORID rid) {    ORecord record;    record = underlying.get(rid);    if (record != null)      Orient.instance().getProfiler().updateCounter(CACHE_HIT, "Record found in Level1 Cache", 1L, "db.*.cache.level1.cache.found");    else      Orient.instance().getProfiler().updateCounter(CACHE_MISS, "Record not found in Level1 Cache", 1L,          "db.*.cache.level1.cache.notFound");    return record;  }
public Object execute(final Map<Object, Object> iArgs) {    if (name == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    if (name.equals("*")) {      long totalIndexed = 0;      for (OIndex<?> idx : getDatabase().getMetadata().getIndexManager().getIndexes()) {        getDatabase().getMetadata().getIndexManager().dropIndex(idx.getName());        totalIndexed++;      }      return totalIndexed;    } else      getDatabase().getMetadata().getIndexManager().dropIndex(name);    return 1;  }
@Override  public void serializeInByteBufferObject(T object, ByteBuffer buffer, Object... hints) {    init(object, hints);    buffer.put(binarySerializer.getId());    binarySerializer.serializeInByteBufferObject(object, buffer);  }
@Override  public T deserializeFromByteBufferObject(ByteBuffer buffer) {    final byte typeId = buffer.get();    init(typeId);    return (T) binarySerializer.deserializeFromByteBufferObject(buffer);  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer) {    final byte serializerId = buffer.get();    init(serializerId);    return OBinarySerializerFactory.TYPE_IDENTIFIER_SIZE + binarySerializer.getObjectSizeInByteBuffer(buffer);  }
@Override  public T deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final byte typeId = walChanges.getByteValue(buffer, offset++);    init(typeId);    return (T) binarySerializer.deserializeFromByteBufferObject(buffer, walChanges, offset);  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return OBinarySerializerFactory.TYPE_IDENTIFIER_SIZE + binarySerializer        .getObjectSizeInByteBuffer(buffer, walChanges, OBinarySerializerFactory.TYPE_IDENTIFIER_SIZE + offset);  }
public void begin() {    walActive = OGlobalConfiguration.USE_WAL.getValueAsBoolean();    if (walActive)      OGlobalConfiguration.USE_WAL.setValue(false);    if (averageEdgeNumberPerNode > 0) {      OGlobalConfiguration.RID_BAG_EMBEDDED_DEFAULT_SIZE.setValue(averageEdgeNumberPerNode);      OGlobalConfiguration.RID_BAG_EMBEDDED_TO_SBTREEBONSAI_THRESHOLD.setValue(bonsaiThreshold);    }    db = new ODatabaseDocumentTx(dbUrl);    if (db.exists()) {      db.open(userName, password);    } else {      db.create();    }    if (this.useLightWeigthEdges == null) {      final List<OStorageEntryConfiguration> custom = (List<OStorageEntryConfiguration>) db.get(ODatabase.ATTRIBUTES.CUSTOM);      for (OStorageEntryConfiguration c : custom) {        if (c.name.equalsIgnoreCase("useLightweightEdges")) {          this.useLightWeigthEdges = Boolean.parseBoolean(c.value);          break;        }      }      if (this.useLightWeigthEdges == null) {        this.useLightWeigthEdges = true;      }    }    createBaseSchema();    out = estimatedEntries > 0 ? new HashMap<Long, List<Object>>(estimatedEntries) : new HashMap<Long, List<Object>>();    in = estimatedEntries > 0 ? new HashMap<Long, List<Object>>(estimatedEntries) : new HashMap<Long, List<Object>>();    OClass vClass = db.getMetadata().getSchema().getClass(this.vertexClass);    int[] existingClusters = vClass.getClusterIds();    for (int c = existingClusters.length; c <= parallel; c++) {      vClass.addCluster(vClass.getName() + "_" + c);    }    clusterIds = vClass.getClusterIds();    lastClusterPositions = new long[clusterIds.length];    nextVerticesToCreate = new long[clusterIds.length];    for (int i = 0; i < clusterIds.length; i++) {      int clusterId = clusterIds[i];      try {        nextVerticesToCreate[i] = i;        //THERE IS NO PUBLIC API FOR RETRIEVE THE LAST CLUSTER POSITION        lastClusterPositions[i] = ((ODatabaseDocumentInternal)db).getStorage().getClusterById(clusterId).getLastPosition();      } catch (Exception e) {        throw new RuntimeException(e);      }    }  }
public void createEdge(final Long from, final Long to, Map<String, Object> properties) {    if (settingProperties) {      throw new IllegalStateException("Cannot create new edges when already set properties on vertices");    }    if (from < 0) {      throw new IllegalArgumentException(" Invalid vertex id: " + from);    }    if (to < 0) {      throw new IllegalArgumentException(" Invalid vertex id: " + to);    }    if (useLightWeigthEdges && (properties == null || properties.size() == 0)) {      last = last < from ? from : last;      last = last < to ? to : last;      putInList(from, out, to);      putInList(to, in, from);    } else {      ODocument edgeDoc = new ODocument(edgeClass);      edgeDoc.fromMap(properties);      edgeDoc.field("out", new ORecordId(getClusterId(from), getClusterPosition(from)));      edgeDoc.field("in", new ORecordId(getClusterId(to), getClusterPosition(to)));      db.save(edgeDoc);      ORecordId rid = (ORecordId) edgeDoc.getIdentity();      putInList(from, out, rid);      putInList(to, in, rid);    }  }
private void calculateShardingStrategy(QueryPlanningInfo info, OCommandContext ctx) {    ODatabaseDocumentInternal db = (ODatabaseDocumentInternal) ctx.getDatabase();    info.distributedFetchExecutionPlans = new LinkedHashMap<>();    Map<String, Set<String>> clusterMap = db.getActiveClusterMap();    Set<String> queryClusters = calculateTargetClusters(info, ctx);    if (queryClusters == null || queryClusters.size() == 0) {//no target      String localNode = db.getLocalNodeName();      info.serverToClusters = new LinkedHashMap<>();      info.serverToClusters.put(localNode, clusterMap.get(localNode));      info.distributedFetchExecutionPlans.put(localNode, new OSelectExecutionPlan(ctx));      return;    }//    Set<String> serversWithAllTheClusers = getServersThatHasAllClusters(clusterMap, queryClusters);//    if (serversWithAllTheClusers.isEmpty()) {    // sharded query    Map<String, Set<String>> minimalSetOfNodes = getMinimalSetOfNodesForShardedQuery(db.getLocalNodeName(), clusterMap,        queryClusters);    if (minimalSetOfNodes == null) {      throw new OCommandExecutionException("Cannot execute sharded query");    }    info.serverToClusters = minimalSetOfNodes;    for (String node : info.serverToClusters.keySet()) {      info.distributedFetchExecutionPlans.put(node, new OSelectExecutionPlan(ctx));    }//    } else {//      // all on a node//      String targetNode = serversWithAllTheClusers.contains(db.getLocalNodeName()) ?//          db.getLocalNodeName() ://          serversWithAllTheClusers.iterator().next();//      info.serverToClusters = new HashMap<>();//      info.serverToClusters.put(targetNode, queryClusters);//    }  }
private Map<String, Set<String>> getMinimalSetOfNodesForShardedQuery(String localNode, Map<String, Set<String>> clusterMap,      Set<String> queryClusters) {    //approximate algorithm, the problem is NP-complete    Map<String, Set<String>> result = new LinkedHashMap<>();    Set<String> uncovered = new HashSet<>();    uncovered.addAll(queryClusters);    uncovered = uncovered.stream().filter(x -> x != null).map(x -> x.toLowerCase(Locale.ENGLISH)).collect(Collectors.toSet());    //try local node first    Set<String> nextNodeClusters = new HashSet<>();    Set<String> clustersForNode = clusterMap.get(localNode);    if (clustersForNode != null) {      nextNodeClusters.addAll(clustersForNode);    }    nextNodeClusters.retainAll(uncovered);    if (nextNodeClusters.size() > 0) {      result.put(localNode, nextNodeClusters);      uncovered.removeAll(nextNodeClusters);    }    while (uncovered.size() > 0) {      String nextNode = findItemThatCoversMore(uncovered, clusterMap);      nextNodeClusters = new HashSet<>();      nextNodeClusters.addAll(clusterMap.get(nextNode));      nextNodeClusters.retainAll(uncovered);      if (nextNodeClusters.size() == 0) {        throw new OCommandExecutionException(            "Cannot execute a sharded query: clusters [" + uncovered.stream().collect(Collectors.joining(", "))                + "] are not present on any node" + "\n [" + clusterMap.entrySet().stream()                .map(x -> "" + x.getKey() + ":(" + x.getValue().stream().collect(Collectors.joining(",")) + ")")                .collect(Collectors.joining(", ")) + "]");      }      result.put(nextNode, nextNodeClusters);      uncovered.removeAll(nextNodeClusters);    }    return result;  }
private Set<String> getServersThatHasAllClusters(Map<String, Set<String>> clusterMap, Set<String> queryClusters) {    Set<String> remainingServers = clusterMap.keySet();    for (String cluster : queryClusters) {      for (Map.Entry<String, Set<String>> serverConfig : clusterMap.entrySet()) {        if (!serverConfig.getValue().contains(cluster)) {          remainingServers.remove(serverConfig.getKey());        }      }    }    return remainingServers;  }
private Set<String> calculateTargetClusters(QueryPlanningInfo info, OCommandContext ctx) {    if (info.target == null) {      return Collections.EMPTY_SET;    }    Set<String> result = new HashSet<>();    ODatabase db = ctx.getDatabase();    OFromItem item = info.target.getItem();    if (item.getRids() != null && item.getRids().size() > 0) {      if (item.getRids().size() == 1) {        OInteger cluster = item.getRids().get(0).getCluster();        if (cluster.getValue().longValue() > ORID.CLUSTER_MAX) {          throw new OCommandExecutionException("Invalid cluster Id:" + cluster + ". Max allowed value = " + ORID.CLUSTER_MAX);        }        result.add(db.getClusterNameById(cluster.getValue().intValue()));      } else {        for (ORid rid : item.getRids()) {          OInteger cluster = rid.getCluster();          result.add(db.getClusterNameById(cluster.getValue().intValue()));        }      }      return result;    } else if (item.getInputParams() != null && item.getInputParams().size() > 0) {      if (((ODatabaseInternal) ctx.getDatabase()).isSharded()) {        throw new UnsupportedOperationException("Sharded query with input parameter as a target is not supported yet");      }      return null;    } else if (item.getCluster() != null) {      String name = item.getCluster().getClusterName();      if (name == null) {        name = db.getClusterNameById(item.getCluster().getClusterNumber());      }      if (name != null) {        result.add(name);        return result;      } else {        return null;      }    } else if (item.getClusterList() != null) {      for (OCluster cluster : item.getClusterList().toListOfClusters()) {        String name = cluster.getClusterName();        if (name == null) {          name = db.getClusterNameById(cluster.getClusterNumber());        }        if (name != null) {          result.add(name);        }      }      return result;    } else if (item.getIndex() != null) {      String indexName = item.getIndex().getIndexName();      OIndex<?> idx = db.getMetadata().getIndexManager().getIndex(indexName);      if (idx == null) {        throw new OCommandExecutionException("Index " + indexName + " does not exist");      }      result.addAll(idx.getClusters());      if (result.isEmpty()) {        return null;      }      return result;    } else if (item.getInputParam() != null) {      if (((ODatabaseInternal) ctx.getDatabase()).isSharded()) {        throw new UnsupportedOperationException("Sharded query with input parameter as a target is not supported yet");      }      return null;    } else if (item.getIdentifier() != null) {      String className = item.getIdentifier().getStringValue();      OClass clazz = getSchemaFromContext(ctx).getClass(className);      if (clazz == null) {        clazz = getSchemaFromContext(ctx).getView(className);      }      if (clazz == null) {        return null;      }      int[] clusterIds = clazz.getPolymorphicClusterIds();      for (int clusterId : clusterIds) {        String clusterName = db.getClusterNameById(clusterId);        if (clusterName != null) {          result.add(clusterName);        }      }      return result;    }    return null;  }
protected static OProjection translateDistinct(OProjection projection) {    if (projection != null && projection.getItems().size() == 1) {      if (isDistinct(projection.getItems().get(0))) {        projection = projection.copy();        OProjectionItem item = projection.getItems().get(0);        OFunctionCall function = ((OBaseExpression) item.getExpression().getMathExpression()).getIdentifier().getLevelZero()            .getFunctionCall();        OExpression exp = function.getParams().get(0);        OProjectionItem resultItem = new OProjectionItem(-1);        resultItem.setAlias(item.getAlias());        resultItem.setExpression(exp.copy());        OProjection result = new OProjection(-1);        result.setItems(new ArrayList<>());        result.setDistinct(true);        result.getItems().add(resultItem);        return result;      }    }    return projection;  }
private static boolean isDistinct(OProjectionItem item) {    if (item.getExpression() == null) {      return false;    }    if (item.getExpression().getMathExpression() == null) {      return false;    }    if (!(item.getExpression().getMathExpression() instanceof OBaseExpression)) {      return false;    }    OBaseExpression base = (OBaseExpression) item.getExpression().getMathExpression();    if (base.getIdentifier() == null) {      return false;    }    if (base.getModifier() != null) {      return false;    }    if (base.getIdentifier().getLevelZero() == null) {      return false;    }    OFunctionCall function = base.getIdentifier().getLevelZero().getFunctionCall();    if (function == null) {      return false;    }    return function.getName().getStringValue().equalsIgnoreCase("distinct");  }
private boolean isMinimalQuery(QueryPlanningInfo info) {    return info.projectionAfterOrderBy == null && info.globalLetClause == null && info.perRecordLetClause == null        && info.whereClause == null && info.flattenedWhereClause == null && info.groupBy == null && info.orderBy == null        && info.unwind == null && info.skip == null;  }
private static void splitLet(QueryPlanningInfo info, OCommandContext ctx) {    if (info.perRecordLetClause != null && info.perRecordLetClause.getItems() != null) {      Iterator<OLetItem> iterator = info.perRecordLetClause.getItems().iterator();      while (iterator.hasNext()) {        OLetItem item = iterator.next();        if (item.getExpression() != null && item.getExpression().isEarlyCalculated(ctx)) {          iterator.remove();          addGlobalLet(info, item.getVarName(), item.getExpression());        } else if (item.getQuery() != null && !item.getQuery().refersToParent()) {          iterator.remove();          addGlobalLet(info, item.getVarName(), item.getQuery());        }      }    }  }
private static List<OAndBlock> moveFlattededEqualitiesLeft(List<OAndBlock> flattenedWhereClause) {    if (flattenedWhereClause == null) {      return null;    }    List<OAndBlock> result = new ArrayList<>();    for (OAndBlock block : flattenedWhereClause) {      List<OBooleanExpression> equalityExpressions = new ArrayList<>();      List<OBooleanExpression> nonEqualityExpressions = new ArrayList<>();      OAndBlock newBlock = block.copy();      for (OBooleanExpression exp : newBlock.getSubBlocks()) {        if (exp instanceof OBinaryCondition) {          if (((OBinaryCondition) exp).getOperator() instanceof OEqualsCompareOperator) {            equalityExpressions.add(exp);          } else {            nonEqualityExpressions.add(exp);          }        } else {          nonEqualityExpressions.add(exp);        }      }      OAndBlock newAnd = new OAndBlock(-1);      newAnd.getSubBlocks().addAll(equalityExpressions);      newAnd.getSubBlocks().addAll(nonEqualityExpressions);      result.add(newAnd);    }    return result;  }
private static void addOrderByProjections(QueryPlanningInfo info) {    if (info.orderApplied || info.expand || info.unwind != null || info.orderBy == null || info.orderBy.getItems().size() == 0        || info.projection == null || info.projection.getItems() == null || (info.projection.getItems().size() == 1        && info.projection.getItems().get(0).isAll())) {      return;    }    OOrderBy newOrderBy = info.orderBy == null ? null : info.orderBy.copy();    List<OProjectionItem> additionalOrderByProjections = calculateAdditionalOrderByProjections(info.projection.getAllAliases(),        newOrderBy);    if (additionalOrderByProjections.size() > 0) {      info.orderBy = newOrderBy;//the ORDER BY has changed    }    if (additionalOrderByProjections.size() > 0) {      info.projectionAfterOrderBy = new OProjection(-1);      info.projectionAfterOrderBy.setItems(new ArrayList<>());      for (String alias : info.projection.getAllAliases()) {        info.projectionAfterOrderBy.getItems().add(projectionFromAlias(new OIdentifier(alias)));      }      for (OProjectionItem item : additionalOrderByProjections) {        if (info.preAggregateProjection != null) {          info.preAggregateProjection.getItems().add(item);          info.aggregateProjection.getItems().add(projectionFromAlias(item.getAlias()));          info.projection.getItems().add(projectionFromAlias(item.getAlias()));        } else {          info.projection.getItems().add(item);        }      }    }  }
private static List<OProjectionItem> calculateAdditionalOrderByProjections(Set<String> allAliases, OOrderBy orderBy) {    List<OProjectionItem> result = new ArrayList<>();    int nextAliasCount = 0;    if (orderBy != null && orderBy.getItems() != null || !orderBy.getItems().isEmpty()) {      for (OOrderByItem item : orderBy.getItems()) {        if (!allAliases.contains(item.getAlias())) {          OProjectionItem newProj = new OProjectionItem(-1);          if (item.getAlias() != null) {            newProj.setExpression(new OExpression(new OIdentifier(item.getAlias()), item.getModifier()));          } else if (item.getRecordAttr() != null) {            ORecordAttribute attr = new ORecordAttribute(-1);            attr.setName(item.getRecordAttr());            newProj.setExpression(new OExpression(attr, item.getModifier()));          } else if (item.getRid() != null) {            OExpression exp = new OExpression(-1);            exp.setRid(item.getRid().copy());            newProj.setExpression(exp);          }          OIdentifier newAlias = new OIdentifier("_$$$ORDER_BY_ALIAS$$$_" + (nextAliasCount++));          newProj.setAlias(newAlias);          item.setAlias(newAlias.getStringValue());          item.setModifier(null);          result.add(newProj);        }      }    }    return result;  }
private static void splitProjectionsForGroupBy(QueryPlanningInfo info, OCommandContext ctx) {    if (info.projection == null) {      return;    }    OProjection preAggregate = new OProjection(-1);    preAggregate.setItems(new ArrayList<>());    OProjection aggregate = new OProjection(-1);    aggregate.setItems(new ArrayList<>());    OProjection postAggregate = new OProjection(-1);    postAggregate.setItems(new ArrayList<>());    boolean isSplitted = false;    //split for aggregate projections    AggregateProjectionSplit result = new AggregateProjectionSplit();    for (OProjectionItem item : info.projection.getItems()) {      result.reset();      if (isAggregate(item)) {        isSplitted = true;        OProjectionItem post = item.splitForAggregation(result, ctx);        OIdentifier postAlias = item.getProjectionAlias();        postAlias = new OIdentifier(postAlias, true);        post.setAlias(postAlias);        postAggregate.getItems().add(post);        aggregate.getItems().addAll(result.getAggregate());        preAggregate.getItems().addAll(result.getPreAggregate());      } else {        preAggregate.getItems().add(item);        //also push the alias forward in the chain        OProjectionItem aggItem = new OProjectionItem(-1);        aggItem.setExpression(new OExpression(item.getProjectionAlias()));        aggregate.getItems().add(aggItem);        postAggregate.getItems().add(aggItem);      }    }    //bind split projections to the execution planner    if (isSplitted) {      info.preAggregateProjection = preAggregate;      if (info.preAggregateProjection.getItems() == null || info.preAggregateProjection.getItems().size() == 0) {        info.preAggregateProjection = null;      }      info.aggregateProjection = aggregate;      if (info.aggregateProjection.getItems() == null || info.aggregateProjection.getItems().size() == 0) {        info.aggregateProjection = null;      }      info.projection = postAggregate;      addGroupByExpressionsToProjections(info);    }  }
private static void addGroupByExpressionsToProjections(QueryPlanningInfo info) {    if (info.groupBy == null || info.groupBy.getItems() == null || info.groupBy.getItems().size() == 0) {      return;    }    OGroupBy newGroupBy = new OGroupBy(-1);    int i = 0;    for (OExpression exp : info.groupBy.getItems()) {      if (exp.isAggregate()) {        throw new OCommandExecutionException("Cannot group by an aggregate function");      }      boolean found = false;      if (info.preAggregateProjection != null) {        for (String alias : info.preAggregateProjection.getAllAliases()) {          //if it's a simple identifier and it's the same as one of the projections in the query,          //then the projection itself is used for GROUP BY without recalculating; in all the other cases, it is evaluated separately          if (alias.equals(exp.getDefaultAlias().getStringValue()) && exp.isBaseIdentifier()) {            found = true;            newGroupBy.getItems().add(exp);            break;          }        }      }      if (!found) {        OProjectionItem newItem = new OProjectionItem(-1);        newItem.setExpression(exp);        OIdentifier groupByAlias = new OIdentifier("_$$$GROUP_BY_ALIAS$$$_" + (i++));        newItem.setAlias(groupByAlias);        if (info.preAggregateProjection == null) {          info.preAggregateProjection = new OProjection(-1);        }        if (info.preAggregateProjection.getItems() == null) {          info.preAggregateProjection.setItems(new ArrayList<>());        }        info.preAggregateProjection.getItems().add(newItem);        newGroupBy.getItems().add(new OExpression(groupByAlias));      }      info.groupBy = newGroupBy;    }  }
private static void extractSubQueries(QueryPlanningInfo info) {    SubQueryCollector collector = new SubQueryCollector();    if (info.perRecordLetClause != null) {      info.perRecordLetClause.extractSubQueries(collector);    }    int i = 0;    int j = 0;    for (Map.Entry<OIdentifier, OStatement> entry : collector.getSubQueries().entrySet()) {      OIdentifier alias = entry.getKey();      OStatement query = entry.getValue();      if (query.refersToParent()) {        addRecordLevelLet(info, alias, query, j++);      } else {        addGlobalLet(info, alias, query, i++);      }    }    collector.reset();    if (info.whereClause != null) {      info.whereClause.extractSubQueries(collector);    }    if (info.projection != null) {      info.projection.extractSubQueries(collector);    }    if (info.orderBy != null) {      info.orderBy.extractSubQueries(collector);    }    if (info.groupBy != null) {      info.groupBy.extractSubQueries(collector);    }    for (Map.Entry<OIdentifier, OStatement> entry : collector.getSubQueries().entrySet()) {      OIdentifier alias = entry.getKey();      OStatement query = entry.getValue();      if (query.refersToParent()) {        addRecordLevelLet(info, alias, query);      } else {        addGlobalLet(info, alias, query);      }    }  }
private boolean isFromClusters(ORid rid, Set<String> filterClusters, ODatabase database) {    if (filterClusters == null) {      throw new IllegalArgumentException();    }    String clusterName = database.getClusterNameById(rid.getCluster().getValue().intValue());    return filterClusters.contains(clusterName);  }
private boolean handleClassWithIndexForSortOnly(OSelectExecutionPlan plan, OIdentifier queryTarget, Set<String> filterClusters,      QueryPlanningInfo info, OCommandContext ctx, boolean profilingEnabled) {    OSchema schema = getSchemaFromContext(ctx);    OClass clazz = schema.getClass(queryTarget.getStringValue());    if (clazz == null) {      clazz = schema.getView(queryTarget.getStringValue());      if (clazz == null) {        throw new OCommandExecutionException("Class not found: " + queryTarget);      }    }    for (OIndex idx : clazz.getIndexes().stream().filter(i -> i.supportsOrderedIterations()).filter(i -> i.getDefinition() != null)        .collect(Collectors.toList())) {      List<String> indexFields = idx.getDefinition().getFields();      if (indexFields.size() < info.orderBy.getItems().size()) {        continue;      }      boolean indexFound = true;      String orderType = null;      for (int i = 0; i < info.orderBy.getItems().size(); i++) {        OOrderByItem orderItem = info.orderBy.getItems().get(i);        if (orderItem.getCollate() != null) {          return false;        }        String indexField = indexFields.get(i);        if (i == 0) {          orderType = orderItem.getType();        } else {          if (orderType == null || !orderType.equals(orderItem.getType())) {            indexFound = false;            break;//ASC/DESC interleaved, cannot be used with index.          }        }        if (!(indexField.equals(orderItem.getAlias()) || isInOriginalProjection(indexField, orderItem.getAlias()))) {          indexFound = false;          break;        }      }      if (indexFound && orderType != null) {        plan.chain(new FetchFromIndexValuesStep(idx, orderType.equals(OOrderByItem.ASC), ctx, profilingEnabled));        int[] filterClusterIds = null;        if (filterClusters != null) {          filterClusterIds = filterClusters.stream().map(name -> ctx.getDatabase().getClusterIdByName(name)).mapToInt(i -> i)              .toArray();        }        plan.chain(new GetValueFromIndexEntryStep(ctx, filterClusterIds, profilingEnabled));        if (info.serverToClusters.size() == 1) {          info.orderApplied = true;        }        return true;      }    }    return false;  }
private boolean isDiamondHierarchy(OClass clazz) {    Set<OClass> traversed = new HashSet<>();    List<OClass> stack = new ArrayList<>();    stack.add(clazz);    while (!stack.isEmpty()) {      OClass current = stack.remove(0);      traversed.add(current);      for (OClass sub : current.getSubclasses()) {        if (traversed.contains(sub)) {          return true;        }        stack.add(sub);        traversed.add(sub);      }    }    return false;  }
private Boolean getOrderDirection(QueryPlanningInfo info) {    if (info.orderBy == null) {      return null;    }    String result = null;    for (OOrderByItem item : info.orderBy.getItems()) {      if (result == null) {        result = item.getType() == null ? OOrderByItem.ASC : item.getType();      } else {        String newType = item.getType() == null ? OOrderByItem.ASC : item.getType();        if (!newType.equals(result)) {          return null;        }      }    }    return result == null || result.equals(OOrderByItem.ASC);  }
private boolean requiresMultipleIndexLookups(OAndBlock keyCondition) {    for (OBooleanExpression oBooleanExpression : keyCondition.getSubBlocks()) {      if (!(oBooleanExpression instanceof OBinaryCondition)) {        return true;      }    }    return false;  }
private IndexSearchDescriptor findBestIndexFor(OCommandContext ctx, Set<OIndex<?>> indexes, OAndBlock block, OClass clazz) {    //get all valid index descriptors    List<IndexSearchDescriptor> descriptors = indexes.stream().filter(x -> x.getInternal().canBeUsedInEqualityOperators())        .map(index -> buildIndexSearchDescriptor(ctx, index, block, clazz)).filter(Objects::nonNull)        .filter(x -> x.keyCondition != null).filter(x -> x.keyCondition.getSubBlocks().size() > 0).collect(Collectors.toList());    List<IndexSearchDescriptor> fullTextIndexDescriptors = indexes.stream()        .filter(idx->idx.getType().equalsIgnoreCase("FULLTEXT"))        .filter(idx->!idx.getAlgorithm().equalsIgnoreCase("LUCENE"))        .map(idx -> buildIndexSearchDescriptorForFulltext(ctx, idx, block, clazz)).filter(Objects::nonNull)        .filter(x -> x.keyCondition != null).filter(x -> x.keyCondition.getSubBlocks().size() > 0).collect(Collectors.toList());    descriptors.addAll(fullTextIndexDescriptors);    //remove the redundant descriptors (eg. if I have one on [a] and one on [a, b], the first one is redundant, just discard it)    descriptors = removePrefixIndexes(descriptors);    //sort by cost    List<OPair<Integer, IndexSearchDescriptor>> sortedDescriptors = descriptors.stream()        .map(x -> (OPair<Integer, IndexSearchDescriptor>) new OPair(x.cost(ctx), x)).sorted().collect(Collectors.toList());    //get only the descriptors with the lowest cost    descriptors = sortedDescriptors.isEmpty() ?        Collections.emptyList() :        sortedDescriptors.stream().filter(x -> x.key.equals(sortedDescriptors.get(0).key)).map(x -> x.value)            .collect(Collectors.toList());    //sort remaining by the number of indexed fields    descriptors = descriptors.stream().sorted(Comparator.comparingInt(x -> x.keyCondition.getSubBlocks().size()))        .collect(Collectors.toList());    //get the one that has more indexed fields    return descriptors.isEmpty() ? null : descriptors.get(descriptors.size() - 1);  }
private List<IndexSearchDescriptor> findPrefixes(IndexSearchDescriptor desc, List<IndexSearchDescriptor> descriptors) {    List<IndexSearchDescriptor> result = new ArrayList<>();    for (IndexSearchDescriptor item : descriptors) {      if (isPrefixOf(item, desc)) {        result.add(item);      }    }    return result;  }
private boolean isPrefixOf(IndexSearchDescriptor item, IndexSearchDescriptor desc) {    List<OBooleanExpression> left = item.keyCondition.getSubBlocks();    List<OBooleanExpression> right = desc.keyCondition.getSubBlocks();    if (left.size() > right.size()) {      return false;    }    for (int i = 0; i < left.size(); i++) {      if (!left.get(i).equals(right.get(i))) {        return false;      }    }    return true;  }
private IndexSearchDescriptor buildIndexSearchDescriptor(OCommandContext ctx, OIndex<?> index, OAndBlock block, OClass clazz) {    List<String> indexFields = index.getDefinition().getFields();    OBinaryCondition keyCondition = new OBinaryCondition(-1);    OIdentifier key = new OIdentifier("key");    keyCondition.setLeft(new OExpression(key));    boolean allowsRange = allowsRangeQueries(index);    boolean found = false;    OAndBlock blockCopy = block.copy();    Iterator<OBooleanExpression> blockIterator;    OAndBlock indexKeyValue = new OAndBlock(-1);    IndexSearchDescriptor result = new IndexSearchDescriptor();    result.idx = index;    result.keyCondition = indexKeyValue;    for (String indexField : indexFields) {      blockIterator = blockCopy.getSubBlocks().iterator();      boolean breakHere = false;      boolean indexFieldFound = false;      while (blockIterator.hasNext()) {        OBooleanExpression singleExp = blockIterator.next();        if (singleExp instanceof OBinaryCondition) {          OExpression left = ((OBinaryCondition) singleExp).getLeft();          if (left.isBaseIdentifier()) {            String fieldName = left.getDefaultAlias().getStringValue();            if (indexField.equals(fieldName)) {              OBinaryCompareOperator operator = ((OBinaryCondition) singleExp).getOperator();              if (!((OBinaryCondition) singleExp).getRight().isEarlyCalculated(ctx)) {                continue; //this cannot be used because the value depends on single record              }              if (operator instanceof OEqualsCompareOperator) {                found = true;                indexFieldFound = true;                OBinaryCondition condition = new OBinaryCondition(-1);                condition.setLeft(left);                condition.setOperator(operator);                condition.setRight(((OBinaryCondition) singleExp).getRight().copy());                indexKeyValue.getSubBlocks().add(condition);                blockIterator.remove();                break;              } else if (operator instanceof OContainsKeyOperator && isMap(clazz, indexField) && isIndexByKey(index, indexField)) {                found = true;                indexFieldFound = true;                OBinaryCondition condition = new OBinaryCondition(-1);                condition.setLeft(left);                condition.setOperator(operator);                condition.setRight(((OBinaryCondition) singleExp).getRight().copy());                indexKeyValue.getSubBlocks().add(condition);                blockIterator.remove();                break;              } else if (allowsRange && operator.isRangeOperator()) {                found = true;                indexFieldFound = true;                breakHere = true;//this is last element, no other fields can be added to the key because this is a range condition                OBinaryCondition condition = new OBinaryCondition(-1);                condition.setLeft(left);                condition.setOperator(operator);                condition.setRight(((OBinaryCondition) singleExp).getRight().copy());                indexKeyValue.getSubBlocks().add(condition);                blockIterator.remove();                //look for the opposite condition, on the same field, for range queries (the other side of the range)                while (blockIterator.hasNext()) {                  OBooleanExpression next = blockIterator.next();                  if (createsRangeWith((OBinaryCondition) singleExp, next)) {                    result.additionalRangeCondition = (OBinaryCondition) next;                    blockIterator.remove();                    break;                  }                }                break;              }            }          }        } else if (singleExp instanceof OContainsValueCondition && ((OContainsValueCondition) singleExp).getExpression() != null            && isMap(clazz, indexField) && isIndexByValue(index, indexField)) {          OExpression left = ((OContainsValueCondition) singleExp).getLeft();          if (left.isBaseIdentifier()) {            String fieldName = left.getDefaultAlias().getStringValue();            if (indexField.equals(fieldName)) {              found = true;              indexFieldFound = true;              OBinaryCondition condition = new OBinaryCondition(-1);              condition.setLeft(left);              condition.setOperator(new OContainsValueOperator(-1));              condition.setRight(((OContainsValueCondition) singleExp).getExpression().copy());              indexKeyValue.getSubBlocks().add(condition);              blockIterator.remove();              break;            }          }        } else if (singleExp instanceof OContainsAnyCondition) {          OExpression left = ((OContainsAnyCondition) singleExp).getLeft();          if (left.isBaseIdentifier()) {            String fieldName = left.getDefaultAlias().getStringValue();            if (indexField.equals(fieldName)) {              if (!((OContainsAnyCondition) singleExp).getRight().isEarlyCalculated(ctx)) {                continue; //this cannot be used because the value depends on single record              }              found = true;              indexFieldFound = true;              OContainsAnyCondition condition = new OContainsAnyCondition(-1);              condition.setLeft(left);              condition.setRight(((OContainsAnyCondition) singleExp).getRight().copy());              indexKeyValue.getSubBlocks().add(condition);              blockIterator.remove();              break;            }          }        } else if (singleExp instanceof OInCondition) {          OExpression left = ((OInCondition) singleExp).getLeft();          if (left.isBaseIdentifier()) {            String fieldName = left.getDefaultAlias().getStringValue();            if (indexField.equals(fieldName)) {              if (((OInCondition) singleExp).getRightMathExpression() != null) {                if (!((OInCondition) singleExp).getRightMathExpression().isEarlyCalculated(ctx)) {                  continue; //this cannot be used because the value depends on single record                }                found = true;                indexFieldFound = true;                OInCondition condition = new OInCondition(-1);                condition.setLeft(left);                condition.setRightMathExpression(((OInCondition) singleExp).getRightMathExpression().copy());                indexKeyValue.getSubBlocks().add(condition);                blockIterator.remove();                break;              } else if (((OInCondition) singleExp).getRightParam() != null) {                found = true;                indexFieldFound = true;                OInCondition condition = new OInCondition(-1);                condition.setLeft(left);                condition.setRightParam(((OInCondition) singleExp).getRightParam().copy());                indexKeyValue.getSubBlocks().add(condition);                blockIterator.remove();                break;              }            }          }        }      }      if (breakHere || !indexFieldFound) {        break;      }    }    if (result.keyCondition.getSubBlocks().size() < index.getDefinition().getFields().size() && !index        .supportsOrderedIterations()) {      //hash indexes do not support partial key match      return null;    }    if (found) {      result.remainingCondition = blockCopy;      return result;    }    return null;  }
private IndexSearchDescriptor buildIndexSearchDescriptorForFulltext(OCommandContext ctx, OIndex<?> index, OAndBlock block, OClass clazz) {    List<String> indexFields = index.getDefinition().getFields();    OBinaryCondition keyCondition = new OBinaryCondition(-1);    OIdentifier key = new OIdentifier("key");    keyCondition.setLeft(new OExpression(key));    boolean found = false;    OAndBlock blockCopy = block.copy();    Iterator<OBooleanExpression> blockIterator;    OAndBlock indexKeyValue = new OAndBlock(-1);    IndexSearchDescriptor result = new IndexSearchDescriptor();    result.idx = index;    result.keyCondition = indexKeyValue;    for (String indexField : indexFields) {      blockIterator = blockCopy.getSubBlocks().iterator();      boolean breakHere = false;      boolean indexFieldFound = false;      while (blockIterator.hasNext()) {        OBooleanExpression singleExp = blockIterator.next();        if (singleExp instanceof OContainsTextCondition) {          OExpression left = ((OContainsTextCondition) singleExp).getLeft();          if (left.isBaseIdentifier()) {            String fieldName = left.getDefaultAlias().getStringValue();            if (indexField.equals(fieldName)) {              found = true;              indexFieldFound = true;              OContainsTextCondition condition = new OContainsTextCondition(-1);              condition.setLeft(left);              condition.setRight(((OContainsTextCondition) singleExp).getRight().copy());              indexKeyValue.getSubBlocks().add(condition);              blockIterator.remove();              break;            }          }        }      }      if (breakHere || !indexFieldFound) {        break;      }    }    if (result.keyCondition.getSubBlocks().size() < index.getDefinition().getFields().size() && !index        .supportsOrderedIterations()) {      //hash indexes do not support partial key match      return null;    }    if (found) {      result.remainingCondition = blockCopy;      return result;    }    return null;  }
private List<IndexSearchDescriptor> commonFactor(List<IndexSearchDescriptor> indexSearchDescriptors) {    //index, key condition, additional filter (to aggregate in OR)    Map<OIndex, Map<IndexCondPair, OOrBlock>> aggregation = new HashMap<>();    for (IndexSearchDescriptor item : indexSearchDescriptors) {      Map<IndexCondPair, OOrBlock> filtersForIndex = aggregation.get(item.idx);      if (filtersForIndex == null) {        filtersForIndex = new HashMap<>();        aggregation.put(item.idx, filtersForIndex);      }      IndexCondPair extendedCond = new IndexCondPair(item.keyCondition, item.additionalRangeCondition);      OOrBlock existingAdditionalConditions = filtersForIndex.get(extendedCond);      if (existingAdditionalConditions == null) {        existingAdditionalConditions = new OOrBlock(-1);        filtersForIndex.put(extendedCond, existingAdditionalConditions);      }      existingAdditionalConditions.getSubBlocks().add(item.remainingCondition);    }    List<IndexSearchDescriptor> result = new ArrayList<>();    for (Map.Entry<OIndex, Map<IndexCondPair, OOrBlock>> item : aggregation.entrySet()) {      for (Map.Entry<IndexCondPair, OOrBlock> filters : item.getValue().entrySet()) {        result.add(new IndexSearchDescriptor(item.getKey(), filters.getKey().mainCondition, filters.getKey().additionalRange,            filters.getValue()));      }    }    return result;  }
public ODocumentFieldHandlingStrategy create(int strategy) {    Optional<ODocumentFieldHandlingStrategy> registered = ODocumentFieldHandlingStrategyRegistry.getInstance()        .getStrategy(strategy);    if (registered.isPresent()) {      return registered.get();    }    Map<OType, ODocumentFieldOTypeHandlingStrategy> typeHandlingStrategies = new HashMap<OType, ODocumentFieldOTypeHandlingStrategy>();    switch (strategy) {    case SINGLE_ORECORD_BYTES:      typeHandlingStrategies.put(OType.BINARY, new ODocumentSingleRecordBytesOTypeHandlingStrategy());      break;    case SPLIT_ORECORD_BYTES:      typeHandlingStrategies.put(OType.BINARY, new ODocumentSplitRecordBytesOTypeHandlingStrategy());      break;    case SIMPLE:    default:      break;    }    ODocumentSmartFieldHandlingStrategy strategyInstance = new ODocumentSmartFieldHandlingStrategy(typeHandlingStrategies);    ODocumentFieldHandlingStrategyRegistry.getInstance().registerStrategy(strategy, strategyInstance);    return strategyInstance;  }
public Object fromStream(final String iStream) {    if (iStream == null || iStream.length() == 0)      // NULL VALUE      return null;    OSerializableStream instance = null;    int propertyPos = iStream.indexOf(':');    int pos = iStream.indexOf(OStringSerializerEmbedded.SEPARATOR);    if (pos < 0 || propertyPos > -1 && pos > propertyPos) {      instance = new ODocument();      pos = -1;    } else {      final String className = iStream.substring(0, pos);      try {        final Class<?> clazz = Class.forName(className);        instance = (OSerializableStream) clazz.newInstance();      } catch (Exception e) {        final String message = "Error on unmarshalling content. Class: " + className;        OLogManager.instance().error(this, message, e);        throw OException.wrapException(new OSerializationException(message), e);      }    }    instance.fromStream(Base64.getDecoder().decode(iStream.substring(pos + 1)));    return instance;  }
public StringBuilder toStream(final StringBuilder iOutput, Object iValue) {    if (iValue != null) {      if (!(iValue instanceof OSerializableStream))        throw new OSerializationException("Cannot serialize the object since it's not implements the OSerializableStream interface");      OSerializableStream stream = (OSerializableStream) iValue;      iOutput.append(iValue.getClass().getName());      iOutput.append(OStringSerializerEmbedded.SEPARATOR);      iOutput.append(Base64.getEncoder().encodeToString(stream.toStream()));    }    return iOutput;  }
public Object execute(final Object iThis, final OIdentifiable iCurrentRecord, final Object iCurrentResult,      final OCommandContext iContext) {    // RESOLVE VALUES USING THE CURRENT RECORD    for (int i = 0; i < configuredParameters.length; ++i) {      runtimeParameters[i] = configuredParameters[i];      if (configuredParameters[i] instanceof OSQLFilterItemField) {        runtimeParameters[i] = ((OSQLFilterItemField) configuredParameters[i]).getValue(iCurrentRecord, iCurrentResult, iContext);      } else if (configuredParameters[i] instanceof OSQLFunctionRuntime)        runtimeParameters[i] = ((OSQLFunctionRuntime) configuredParameters[i]).execute(iThis, iCurrentRecord, iCurrentResult,            iContext);      else if (configuredParameters[i] instanceof OSQLFilterItemVariable) {        runtimeParameters[i] = ((OSQLFilterItemVariable) configuredParameters[i])            .getValue(iCurrentRecord, iCurrentResult, iContext);      } else if (configuredParameters[i] instanceof OCommandSQL) {        try {          runtimeParameters[i] = ((OCommandSQL) configuredParameters[i]).setContext(iContext).execute();        } catch (OCommandExecutorNotFoundException ignore) {          // TRY WITH SIMPLE CONDITION          final String text = ((OCommandSQL) configuredParameters[i]).getText();          final OSQLPredicate pred = new OSQLPredicate(text);          runtimeParameters[i] = pred.evaluate(iCurrentRecord instanceof ORecord ? (ORecord) iCurrentRecord : null,              (ODocument) iCurrentResult, iContext);          // REPLACE ORIGINAL PARAM          configuredParameters[i] = pred;        }      } else if (configuredParameters[i] instanceof OSQLPredicate)        runtimeParameters[i] = ((OSQLPredicate) configuredParameters[i]).evaluate(iCurrentRecord.getRecord(),            (iCurrentRecord instanceof ODocument ? (ODocument) iCurrentResult : null), iContext);      else if (configuredParameters[i] instanceof String) {        if (configuredParameters[i].toString().startsWith("\"") || configuredParameters[i].toString().startsWith("'"))          runtimeParameters[i] = OIOUtils.getStringContent(configuredParameters[i]);      }    }    if (function.getMaxParams() == -1 || function.getMaxParams() > 0) {      if (runtimeParameters.length < function.getMinParams()          || (function.getMaxParams() > -1 && runtimeParameters.length > function.getMaxParams()))        throw new OCommandExecutionException("Syntax error: function '"            + function.getName()            + "' needs "            + (function.getMinParams() == function.getMaxParams() ? function.getMinParams() : function.getMinParams() + "-"                + function.getMaxParams()) + " argument(s) while has been received " + runtimeParameters.length);    }    final Object functionResult = function.execute(iThis, iCurrentRecord, iCurrentResult, runtimeParameters, iContext);    if (functionResult instanceof OAutoConvertToRecord)      // FORCE AVOIDING TO CONVERT IN RECORD      ((OAutoConvertToRecord) functionResult).setAutoConvertToRecord(false);    return transformValue(iCurrentRecord, iContext, functionResult);  }
public ORole allow(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {    if (roles == null || roles.isEmpty()) {      if (document.field("roles") != null && !((Collection<OIdentifiable>) document.field("roles")).isEmpty()) {        final ODocument doc = document;        document = null;        fromStream(doc);      } else        throw new OSecurityAccessException(document.getDatabase().getName(),            "User '" + document.field("name") + "' has no role defined");    }    final ORole role = checkIfAllowed(resourceGeneric, resourceSpecific, iOperation);    if (role == null)      throw new OSecurityAccessException(document.getDatabase().getName(),          "User '" + document.field("name") + "' does not have permission to execute the operation '" + ORole              .permissionToString(iOperation) + "' against the resource: " + resourceGeneric + "." + resourceSpecific);    return role;  }
public boolean isRuleDefined(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific) {    for (ORole r : roles)      if (r == null)        OLogManager.instance()            .warn(this, "User '%s' has a null role, bypass it. Consider to fix this user roles before to continue", getName());      else if (r.hasRule(resourceGeneric, resourceSpecific))        return true;    return false;  }
public static String getCompactServerStatus(final ODistributedServerManager manager, final ODocument distribCfg) {    final StringBuilder buffer = new StringBuilder();    final Collection<ODocument> members = distribCfg.field("members");    if (members != null) {      buffer.append(members.size());      buffer.append(":[");      int memberCount = 0;      for (ODocument m : members) {        if (m == null)          continue;        if (memberCount++ > 0)          buffer.append(",");        final String serverName = m.field("name");        buffer.append(serverName);        buffer.append((Object)m.field("status"));        final Collection<String> databases = m.field("databases");        if (databases != null) {          buffer.append("{");          int dbCount = 0;          for (String dbName : databases) {            final ODistributedConfiguration dbCfg = manager.getDatabaseConfiguration(dbName, false);            if (dbCfg == null)              continue;            if (dbCount++ > 0)              buffer.append(",");            buffer.append(dbName);            buffer.append("=");            buffer.append(manager.getDatabaseStatus(serverName, dbName));            buffer.append(" (");            buffer.append(dbCfg.getServerRole(serverName));            buffer.append(")");          }          buffer.append("}");        }      }      buffer.append("]");    }    return buffer.toString();  }
protected void initSystemDatabase() {    final ODocument defaultCfg = getStorage(OSystemDatabase.SYSTEM_DB_NAME)        .loadDatabaseConfiguration(getDefaultDatabaseConfigFile());    defaultCfg.field("autoDeploy", false);    final OModifiableDistributedConfiguration sysCfg = new OModifiableDistributedConfiguration(defaultCfg);    sysCfg.removeServer("<NEW_NODE>");    messageService.registerDatabase(OSystemDatabase.SYSTEM_DB_NAME, sysCfg);    sysCfg.addNewNodeInServerList(getLocalNodeName());  }
protected void loadLocalDatabases() {    final List<String> dbs = new ArrayList<String>(serverInstance.getAvailableStorageNames().keySet());    Collections.sort(dbs);    for (final String databaseName : dbs) {      if (messageService.getDatabase(databaseName) == null) {        ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, "Opening database '%s'...", databaseName);        // INIT THE STORAGE        final ODistributedStorage stg = getStorage(databaseName);        executeInDistributedDatabaseLock(databaseName, 60000, null, new OCallable<Object, OModifiableDistributedConfiguration>() {          @Override          public Object call(OModifiableDistributedConfiguration cfg) {            ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, "Current node started as %s for database '%s'",                cfg.getServerRole(nodeName), databaseName);            final ODistributedDatabaseImpl ddb = messageService.registerDatabase(databaseName, cfg);            ddb.resume();            // 1ST NODE TO HAVE THE DATABASE            cfg.addNewNodeInServerList(nodeName);            // COLLECT ALL THE CLUSTERS WITH REMOVED NODE AS OWNER            reassignClustersOwnership(nodeName, databaseName, cfg, true);            try {              ddb.getSyncConfiguration().setLastLSN(nodeName, ((OAbstractPaginatedStorage) stg.getUnderlying()).getLSN(), false);            } catch (IOException e) {              ODistributedServerLog                  .error(this, nodeName, null, DIRECTION.NONE, "Error on saving distributed LSN for database '%s' (err=%s).",                      databaseName, e.getMessage());            }            ddb.setOnline();            return null;          }        });      }    }  }
@Override  public void memberRemoved(final MembershipEvent iEvent) {    try {      updateLastClusterChange();      if (iEvent.getMember() == null)        return;      final String nodeLeftName = getNodeName(iEvent.getMember());      if (nodeLeftName == null)        return;      removeServer(nodeLeftName, true);    } catch (HazelcastInstanceNotActiveException | RetryableHazelcastException e) {      OLogManager.instance().error(this, "Hazelcast is not running", e);    } catch (Exception e) {      OLogManager.instance().error(this, "Error on removing the server '%s'", e, getNodeName(iEvent.getMember()));    }  }
@Override  public String electNewLockManager() {    if (hazelcastInstance == null)      throw new HazelcastInstanceNotActiveException();    final ILock lock = hazelcastInstance.getLock("orientdb.lockManagerElection");    lock.lock();    try {      // TRY ALL THE SERVERS IN ORDER (ALL THE SERVERS HAVE THE SAME LIST)      String lockManagerServer = getLockManagerRequester().getServer();      // PROTECT FROM DOUBLE LOCK MANAGER ELECTION IN CASE OF REMOVE OF LOCK MANAGER      if (lockManagerServer != null && getActiveServers().contains(lockManagerServer))        return lockManagerServer;      final String originalLockManager = lockManagerServer;      ODistributedServerLog          .debug(this, nodeName, originalLockManager, DIRECTION.OUT, "lock '%s' is unreachable, electing a new lock...",              originalLockManager);      int lockManagerServerId = -1;      if (lockManagerServer != null && registeredNodeByName.containsKey(lockManagerServer))        lockManagerServerId = registeredNodeByName.get(lockManagerServer);      String newServer = null;      int currIndex = lockManagerServerId;      for (int i = 0; i < registeredNodeById.size(); ++i) {        currIndex++;        if (currIndex >= registeredNodeById.size())          // RESTART FROM THE FIRST          currIndex = 0;        newServer = registeredNodeById.get(currIndex);        if (newServer == null)          throw new OConfigurationException("Found null server at index " + currIndex + " of server list " + registeredNodeById);        if (newServer.equalsIgnoreCase(getLocalNodeName()) || activeNodes.containsKey(newServer)) {          // TODO: IMPROVE ELECTION BY CHECKING AL THE NODES AGREE ON IT          ODistributedServerLog              .debug(this, nodeName, newServer, DIRECTION.OUT, "Trying to elected server '%s' as new lock (old=%s)...", newServer,                  originalLockManager);          try {            getLockManagerRequester().setServer(newServer);            configurationMap.put(CONFIG_LOCKMANAGER, getLockManagerRequester().getServer());            ODistributedServerLog                .info(this, nodeName, newServer, DIRECTION.OUT, "Elected server '%s' as new lock (old=%s)", newServer,                    originalLockManager);            break;          } catch (Exception e) {            // NO SERVER RESPONDED, THE SERVER COULD BE ISOLATED, GO AHEAD WITH THE NEXT IN THE LIST            ODistributedServerLog                .info(this, nodeName, newServer, DIRECTION.OUT, "Error on electing server '%s' as new lock (error: %s)", newServer,                    e);          }        }      }      return newServer;    } finally {      lock.unlock();    }  }
private void assignLockManagerFromCluster() {    String lockManagerServer = null;    while (lockManagerServer == null) {      if (activeNodes.size() == 1) {        // ONLY CURRENT NODE ONLINE, SET IT AS INITIAL LOCK MANAGER        lockManagerServer = nodeName;        if (configurationMap.putIfAbsent(CONFIG_LOCKMANAGER, lockManagerServer) == null)          break;      } else {        lockManagerServer = (String) configurationMap.get(CONFIG_LOCKMANAGER);        if (lockManagerServer != null && lockManagerServer.equals(nodeName)) {          // LAST LOCK MANAGER WAS CURRENT NODE? TRY TO FORCE A NEW ELECTION          OLogManager.instance().info(this, "Found lock as current node, even if it was offline. Forcing a new election...");          getLockManagerRequester().setServer(lockManagerServer);          lockManagerServer = electNewLockManager();          break;        }        if (lockManagerServer != null)          break;      }      try {        Thread.sleep(100);      } catch (InterruptedException e) {        break;      }    }    getLockManagerRequester().setServer(lockManagerServer);    OLogManager.instance().info(this, "Distributed Lock Manager server is '%s'", lockManagerServer);  }
@Override  public void serializeInByteBufferObject(Double object, ByteBuffer buffer, Object... hints) {    buffer.putLong(Double.doubleToLongBits(object));  }
@Override  public Double deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return Double.longBitsToDouble(walChanges.getLongValue(buffer, offset));  }
@Override  public void serializeInByteBufferObject(OIdentifiable object, ByteBuffer buffer, Object... hints) {    OLinkSerializer.INSTANCE.serializeInByteBufferObject(object, buffer);  }
@Override  public OIdentifiable deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return OLinkSerializer.INSTANCE.deserializeFromByteBufferObject(buffer, walChanges, offset);  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return OLinkSerializer.INSTANCE.getObjectSizeInByteBuffer(buffer, walChanges, offset);  }
public void commit() {    if (!active)      throw error("Inactive micro-transaction on commit");    if (level < 1)      throw error("Unbalanced micro-transaction, level = " + level);    --level;    if (level == 0) {      active = false;      doCommit();    }  }
public void rollback() {    if (!active)      throw error("Inactive micro-transaction on rollback");    if (level < 1)      throw error("Unbalanced micro-transaction, level = " + level);    --level;    if (level == 0) {      active = false;      doRollback();    }  }
public void updateIdentityAfterRecordCommit(final ORID oldRid, final ORID newRid) {    if (oldRid.equals(newRid))      return; // no change, ignore    // XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep    // the OTransactionIndexChanges.changesPerKey in a consistent state.    final List<KeyChangesUpdateRecord> keyRecordsToReinsert = new ArrayList<>();    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();    for (Map.Entry<String, OTransactionIndexChanges> entry : indexOperations.entrySet()) {      final OIndex<?> index = indexManager.getIndex(entry.getKey());      if (index == null)        throw new OTransactionException("Cannot find index '" + entry.getValue() + "' while committing transaction");      final Dependency[] fieldRidDependencies = getIndexFieldRidDependencies(index);      if (!isIndexMayDependOnRids(fieldRidDependencies))        continue;      final OTransactionIndexChanges indexChanges = entry.getValue();      for (final Iterator<OTransactionIndexChangesPerKey> iterator = indexChanges.changesPerKey.values().iterator(); iterator          .hasNext(); ) {        final OTransactionIndexChangesPerKey keyChanges = iterator.next();        if (isIndexKeyMayDependOnRid(keyChanges.key, oldRid, fieldRidDependencies)) {          keyRecordsToReinsert.add(new KeyChangesUpdateRecord(keyChanges, indexChanges));          iterator.remove();        }      }    }    // Update the identity.    final ORecordOperation rec = resolveRecordOperation(oldRid);    if (rec != null) {      updatedRids.put(newRid.copy(), oldRid.copy());      if (!rec.getRecord().getIdentity().equals(newRid)) {        ORecordInternal.onBeforeIdentityChanged(rec.getRecord());        final ORecordId recordId = (ORecordId) rec.getRecord().getIdentity();        if (recordId == null) {          ORecordInternal.setIdentity(rec.getRecord(), new ORecordId(newRid));        } else {          recordId.setClusterPosition(newRid.getClusterPosition());          recordId.setClusterId(newRid.getClusterId());        }        ORecordInternal.onAfterIdentityChanged(rec.getRecord());      }    }    // Reinsert the potentially affected index keys.    for (KeyChangesUpdateRecord record : keyRecordsToReinsert)      record.indexChanges.changesPerKey.put(record.keyChanges.key, record.keyChanges);    // Update the indexes.    final List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(translateRid(oldRid));    if (transactionIndexOperations != null) {      for (final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations) {        OTransactionIndexChanges indexEntryChanges = indexOperations.get(indexOperation.index);        if (indexEntryChanges == null)          continue;        final OTransactionIndexChangesPerKey keyChanges;        if (indexOperation.key == null) {          keyChanges = indexEntryChanges.nullKeyChanges;        } else {          keyChanges = indexEntryChanges.changesPerKey.get(indexOperation.key);        }        if (keyChanges != null)          updateChangesIdentity(oldRid, newRid, keyChanges);      }    }  }
public void updateRecordCacheAfterRollback() {    final OLocalRecordCache databaseLocalCache = database.getLocalCache();    for (ORecordOperation recordOperation : recordOperations.values())      databaseLocalCache.deleteRecord(recordOperation.getRecord().getIdentity());  }
public static void prepareForFileCreationOrReplacement(Path path, Object requester, String operation) throws IOException {    if (Files.deleteIfExists(path))      OLogManager.instance().warn(requester, "'%s' deleted while %s", path, operation);    final Path parent = path.getParent();    if (parent != null)      Files.createDirectories(parent);  }
public static void atomicMoveWithFallback(Path source, Path target, Object requester) throws IOException {    try {      Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);    } catch (AtomicMoveNotSupportedException ignore) {      OLogManager.instance()          .warn(requester, "atomic file move is not possible, falling back to regular move (moving '%s' to '%s')", source, target);      Files.move(source, target);    }  }
public List<Pattern> getDisjointPatterns() {    Map<PatternNode, String> reverseMap = new IdentityHashMap<>();    reverseMap.putAll(this.aliasToNode.entrySet().stream().collect(Collectors.toMap(x -> x.getValue(), x -> x.getKey())));    List<Pattern> result = new ArrayList<>();    while (!reverseMap.isEmpty()) {      Pattern pattern = new Pattern();      result.add(pattern);      Map.Entry<PatternNode, String> nextNode = reverseMap.entrySet().iterator().next();      Set<PatternNode> toVisit = new HashSet<>();      toVisit.add(nextNode.getKey());      while (toVisit.size() > 0) {        PatternNode currentNode = toVisit.iterator().next();        toVisit.remove(currentNode);        if (reverseMap.containsKey(currentNode)) {          pattern.aliasToNode.put(reverseMap.get(currentNode), currentNode);          reverseMap.remove(currentNode);          for (PatternEdge x : currentNode.out) {            toVisit.add(x.in);          }          for (PatternEdge x : currentNode.in) {            toVisit.add(x.out);          }        }      }      pattern.recalculateNumOfEdges();    }    return result;  }
protected boolean executeOnlyLocally(final String localNodeName, final ODistributedConfiguration dbCfg,      final OCommandExecutor exec, final Collection<String> involvedClusters, final Collection<String> nodes) {    boolean executeLocally = false;    if (exec.isIdempotent()) {      final int availableNodes = nodes.size();      // IDEMPOTENT: CHECK IF CAN WORK LOCALLY ONLY      int maxReadQuorum;      if (involvedClusters.isEmpty())        maxReadQuorum = dbCfg.getReadQuorum(null, availableNodes, localNodeName);      else {        maxReadQuorum = 0;        for (String cl : involvedClusters)          maxReadQuorum = Math.max(maxReadQuorum, dbCfg.getReadQuorum(cl, availableNodes, localNodeName));      }      if (nodes.contains(localNodeName) && maxReadQuorum <= 1)        executeLocally = true;    }    return executeLocally;  }  public boolean isLocalEnv() {    return localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal.INSTANCE        .isRunModeDistributed();  }  public OStorageOperationResult<ORawBuffer> readRecord(final ORecordId iRecordId, final String iFetchPlan,      final boolean iIgnoreCache, final boolean prefetchRecords, final ORecordCallback<ORawBuffer> iCallback) {    if (isLocalEnv()) {      // ALREADY DISTRIBUTED      return wrapped.readRecord(iRecordId, iFetchPlan, iIgnoreCache, prefetchRecords, iCallback);    }    final ORawBuffer memCopy = localDistributedDatabase.getRecordIfLocked(iRecordId);    if (memCopy != null)      return new OStorageOperationResult<ORawBuffer>(memCopy);    try {      final String clusterName = getClusterNameByRID(iRecordId);      final ODistributedConfiguration dbCfg = distributedConfiguration;      final List<String> nodes = dbCfg.getServers(clusterName, null);      final int availableNodes = nodes.size();      // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER      final String localNodeName = dManager.getLocalNodeName();      if (nodes.isEmpty()          || nodes.contains(dManager.getLocalNodeName()) && dbCfg.getReadQuorum(clusterName, availableNodes, localNodeName) <= 1) {        // DON'T REPLICATE        return (OStorageOperationResult<ORawBuffer>) OScenarioThreadLocal.executeAsDistributed(new Callable() {          @Override          public Object call() throws Exception {            return wrapped.readRecord(iRecordId, iFetchPlan, iIgnoreCache, prefetchRecords, iCallback);          }        });      }      final OReadRecordTask task = ((OReadRecordTask) dManager.getTaskFactoryManager().getFactoryByServerNames(nodes)          .createTask(OReadRecordTask.FACTORYID)).init(iRecordId);      // DISTRIBUTE IT      final ODistributedResponse response = dManager          .sendRequest(getName(), Collections.singleton(clusterName), nodes, task, dManager.getNextMessageIdCounter(),              EXECUTION_MODE.RESPONSE, null, null, null);      final Object dResult = response != null ? response.getPayload() : null;      if (dResult instanceof ONeedRetryException)        throw (ONeedRetryException) dResult;      else if (dResult instanceof Exception)        throw OException            .wrapException(new ODistributedException("Error on execution distributed read record"), (Exception) dResult);      return new OStorageOperationResult<ORawBuffer>((ORawBuffer) dResult);    } catch (ONeedRetryException e) {      // PASS THROUGH      throw e;    } catch (Exception e) {      handleDistributedException("Cannot route read record operation for %s to the distributed node", e, iRecordId);      // UNREACHABLE      return null;    }  }  @Override  public OStorageOperationResult<ORawBuffer> readRecordIfVersionIsNotLatest(final ORecordId rid, final String fetchPlan,      final boolean ignoreCache, final int recordVersion) throws ORecordNotFoundException {    if (isLocalEnv()) {      return wrapped.readRecordIfVersionIsNotLatest(rid, fetchPlan, ignoreCache, recordVersion);    }    final ORawBuffer memCopy = localDistributedDatabase.getRecordIfLocked(rid);    if (memCopy != null)      return new OStorageOperationResult<ORawBuffer>(memCopy);    try {      final String clusterName = getClusterNameByRID(rid);      final ODistributedConfiguration dbCfg = distributedConfiguration;      final List<String> nodes = dbCfg.getServers(clusterName, null);      final int availableNodes = nodes.size();      // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER      final String localNodeName = dManager.getLocalNodeName();      if (nodes.isEmpty()          || nodes.contains(dManager.getLocalNodeName()) && dbCfg.getReadQuorum(clusterName, availableNodes, localNodeName) <= 1) {        // DON'T REPLICATE        return (OStorageOperationResult<ORawBuffer>) OScenarioThreadLocal.executeAsDistributed(new Callable() {          @Override          public Object call() throws Exception {            return wrapped.readRecordIfVersionIsNotLatest(rid, fetchPlan, ignoreCache, recordVersion);          }        });      }      final OReadRecordIfNotLatestTask task = (OReadRecordIfNotLatestTask) dManager.getTaskFactoryManager()          .getFactoryByServerNames(nodes).createTask(OReadRecordIfNotLatestTask.FACTORYID);      task.init(rid, recordVersion);      // DISTRIBUTE IT      final Object result = dManager          .sendRequest(getName(), Collections.singleton(clusterName), nodes, task, dManager.getNextMessageIdCounter(),              EXECUTION_MODE.RESPONSE, null, null, null).getPayload();      if (result instanceof ONeedRetryException)        throw (ONeedRetryException) result;      else if (result instanceof Exception)        throw OException.wrapException(new ODistributedException("Error on execution distributed read record"), (Exception) result);      return new OStorageOperationResult<ORawBuffer>((ORawBuffer) result);    } catch (ONeedRetryException e) {      // PASS THROUGH      throw e;    } catch (Exception e) {      handleDistributedException("Cannot route read record operation for %s to the distributed node", e, rid);      // UNREACHABLE      return null;    }  }  @Override  public OStorageOperationResult<Boolean> deleteRecord(final ORecordId iRecordId, final int iVersion, final int iMode,      final ORecordCallback<Boolean> iCallback) {    // IF is a real delete should be with a tx    return wrapped.deleteRecord(iRecordId, iVersion, iMode, iCallback);  }
@Override  public void characters(char[] ch, int start, int length) throws SAXException {    builder.append(ch, start, length);  }
public static Date stringToDate(String dateString) throws ParseException {    try {      SimpleDateFormat format = RESOLUTIONS[dateString.length()].format();      return format.parse(dateString);    } catch (Exception e) {      OLogManager.instance().error(OLuceneDateTools.class, "Exception is suppressed, original exception is ", e);      //noinspection ThrowInsideCatchBlockWhichIgnoresCaughtException      throw new ParseException("Input is not a valid date string: " + dateString, 0);    }  }
public boolean isConnected() {    final Socket s = socket;    return s != null && !s.isClosed() && s.isConnected() && !s.isInputShutdown() && !s.isOutputShutdown();  }
public Object execute(final Map<Object, Object> iArgs) {    if (name == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    if (name.isEmpty())      throw new OCommandExecutionException("Syntax Error. You must specify a function name: " + getSyntax());    if (code == null || code.isEmpty())      throw new OCommandExecutionException("Syntax Error. You must specify the function code: " + getSyntax());    ODatabaseDocument database = getDatabase();    final OFunction f = database.getMetadata().getFunctionLibrary().createFunction(name);    f.setCode(code);    f.setIdempotent(idempotent);    if (parameters != null)      f.setParameters(parameters);    if (language != null)      f.setLanguage(language);    f.save();    return f.getId();  }
public static short mergeShortFromBuffers(final ByteBuffer buffer, final ByteBuffer buffer1) {    short result = 0;    result = (short) (result | (buffer.get() & MASK));    result = (short) (result << SIZE_OF_BYTE_IN_BITS);    result = (short) (result | (buffer1.get() & MASK));    return result;  }
public static int mergeIntFromBuffers(final ByteBuffer buffer, final ByteBuffer buffer1) {    int result = 0;    final int remaining = buffer.remaining();    for (int i = 0; i < remaining; ++i) {      result = result | (buffer.get() & MASK);      result = result << SIZE_OF_BYTE_IN_BITS;    }    for (int i = 0; i < SIZE_OF_INT - remaining - 1; ++i) {      result = result | (buffer1.get() & MASK);      result = result << SIZE_OF_BYTE_IN_BITS;    }    result = result | (buffer1.get() & MASK);    return result;  }
public static long mergeLongFromBuffers(final ByteBuffer buffer, final ByteBuffer buffer1) {    long result = 0;    final int remaining = buffer.remaining();    for (int i = 0; i < remaining; ++i) {      result = result | (MASK & buffer.get());      result = result << SIZE_OF_BYTE_IN_BITS;    }    for (int i = 0; i < SIZE_OF_LONG - remaining - 1; ++i) {      result = result | (MASK & buffer1.get());      result = result << SIZE_OF_BYTE_IN_BITS;    }    result = result | (MASK & buffer1.get());    return result;  }
public static void splitShortToBuffers(final ByteBuffer buffer, final ByteBuffer buffer1, final short iValue) {    buffer.put((byte) (MASK & (iValue >>> SIZE_OF_BYTE_IN_BITS)));    buffer1.put((byte) (MASK & iValue));  }
public static void splitIntToBuffers(final ByteBuffer buffer, final ByteBuffer buffer1, final int iValue) {    final int remaining = buffer.remaining();    int i;    for (i = 0; i < remaining; ++i) {      buffer.put((byte) (MASK & (iValue >>> SIZE_OF_BYTE_IN_BITS * (SIZE_OF_INT - i - 1))));    }    for (int j = 0; j < SIZE_OF_INT - remaining; ++j) {      buffer1.put((byte) (MASK & (iValue >>> SIZE_OF_BYTE_IN_BITS * (SIZE_OF_INT - i - j - 1))));    }  }
public static void splitLongToBuffers(final ByteBuffer buffer, final ByteBuffer buffer1, final long iValue) {    final int remaining = buffer.remaining();    int i;    for (i = 0; i < remaining; ++i) {      buffer.put((byte) (iValue >> SIZE_OF_BYTE_IN_BITS * (SIZE_OF_LONG - i - 1)));    }    for (int j = 0; j < SIZE_OF_LONG - remaining; ++j) {      buffer1.put((byte) (iValue >> SIZE_OF_BYTE_IN_BITS * (SIZE_OF_LONG - i - j - 1)));    }  }
public Object execute(final Map<Object, Object> iArgs) {    if (type == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocument database = getDatabase();    final OClassEmbedded sourceClass = (OClassEmbedded) database.getMetadata().getSchema().getClass(className);    if (sourceClass == null)      throw new OCommandExecutionException("Source class '" + className + "' not found");    OPropertyImpl prop = (OPropertyImpl) sourceClass.getProperty(fieldName);    if (prop != null) {      if (ifNotExists) {        return sourceClass.properties().size();      }      throw new OCommandExecutionException(          "Property '" + className + "." + fieldName + "' already exists. Remove it before to retry.");    }    // CREATE THE PROPERTY    OClass linkedClass = null;    OType linkedType = null;    if (linked != null) {      // FIRST SEARCH BETWEEN CLASSES      linkedClass = database.getMetadata().getSchema().getClass(linked);      if (linkedClass == null)        // NOT FOUND: SEARCH BETWEEN TYPES        linkedType = OType.valueOf(linked.toUpperCase(Locale.ENGLISH));    }    // CREATE IT LOCALLY    OPropertyImpl internalProp = sourceClass.addPropertyInternal(fieldName, type, linkedType, linkedClass, unsafe);    if (readonly) {      internalProp.setReadonly(true);    }    if (mandatory) {      internalProp.setMandatory(true);    }    if (notnull) {      internalProp.setNotNull(true);    }    if (max != null) {      internalProp.setMax(max);    }    if (min != null) {      internalProp.setMin(min);    }    if (defaultValue != null) {      internalProp.setDefaultValue(defaultValue);    }    return sourceClass.properties().size();  }
public Object execute(final Map<Object, Object> iArgs) {    if (attribute == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final List<OCluster> clusters = getClusters();    if (clusters.isEmpty())      throw new OCommandExecutionException("Cluster '" + clusterName + "' not found");    Object result = null;    for (OCluster cluster : getClusters()) {      if (clusterId > -1 && clusterName.equals(String.valueOf(clusterId))) {        clusterName = cluster.getName();      } else {        clusterId = cluster.getId();      }      try {        if (attribute == ATTRIBUTES.STATUS && OStorageClusterConfiguration.STATUS.OFFLINE.toString().equalsIgnoreCase(value))          // REMOVE CACHE OF COMMAND RESULTS IF ACTIVE          getDatabase().getMetadata().getCommandCache().invalidateResultsOfCluster(clusterName);        if (attribute == ATTRIBUTES.NAME)          // REMOVE CACHE OF COMMAND RESULTS IF ACTIVE          getDatabase().getMetadata().getCommandCache().invalidateResultsOfCluster(clusterName);        result = cluster.set(attribute, value);      } catch (IOException ioe) {        throw OException.wrapException(new OCommandExecutionException("Error altering cluster '" + clusterName + "'"), ioe);      }    }    return result;  }
@Override  public OIndexFullText put(Object key, final OIdentifiable singleValue) {    if (key == null) {      return this;    }    key = getCollatingValue(key);    final Set<String> words = splitIntoWords(key.toString());    // FOREACH WORD CREATE THE LINK TO THE CURRENT DOCUMENT    for (final String word : words) {      acquireSharedLock();      try {        if (apiVersion == 0) {          doPutV0(singleValue, word);        } else if (apiVersion == 1) {          doPutV1(singleValue, word);        } else {          throw new IllegalStateException("Invalid API version, " + apiVersion);        }      } finally {        releaseSharedLock();      }    }    return this;  }
@Override  public boolean remove(Object key, final OIdentifiable value) {    if (key == null) {      return false;    }    key = getCollatingValue(key);    final Set<String> words = splitIntoWords(key.toString());    final OModifiableBoolean removed = new OModifiableBoolean(false);    for (final String word : words) {      acquireSharedLock();      try {        if (apiVersion == 0) {          removeV0(value, removed, word);        } else if (apiVersion == 1) {          removeV1(value, removed, word);        } else {          throw new IllegalStateException("Invalid API version, " + apiVersion);        }      } finally {        releaseSharedLock();      }    }    return removed.getValue();  }
@SuppressWarnings("unchecked")  public List<T> run(final Object... iArgs) {    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();    if (database == null)      throw new OQueryParsingException("No database configured");    ((OMetadataInternal) database.getMetadata()).makeThreadLocalSchemaSnapshot();    try {      setParameters(iArgs);      Object o = database.getStorage().command(this);      if (o instanceof List) {        return (List<T>) o;      } else {        return (List<T>) Collections.singletonList(o);      }    } finally {      ((OMetadataInternal) database.getMetadata()).clearThreadLocalSchemaSnapshot();    }  }
public T runFirst(final Object... iArgs) {    setLimit(1);    final List<T> result = execute(iArgs);    return result != null && !result.isEmpty() ? result.get(0) : null;  }
public OSBTreeValue<V> getValue(int entryIndex) {    assert isLeaf;    int entryPosition = getIntValue(entryIndex * OIntegerSerializer.INT_SIZE + positionsArrayOffset);    // skip key    if (encryption == null) {      entryPosition += getObjectSizeInDirectMemory(keySerializer, entryPosition);    } else {      final int encryptedSize = getIntValue(entryPosition);      entryPosition += OIntegerSerializer.INT_SIZE + encryptedSize;    }    boolean isLinkValue = getByteValue(entryPosition) > 0;    long link = -1;    V value = null;    if (isLinkValue)      link = deserializeFromDirectMemory(OLongSerializer.INSTANCE, entryPosition + OByteSerializer.BYTE_SIZE);    else      value = deserializeFromDirectMemory(valueSerializer, entryPosition + OByteSerializer.BYTE_SIZE);    return new OSBTreeValue<>(link >= 0, link, value);  }
public void shrink(final long size) throws IOException {    int attempts = 0;    while (true) {      try {        acquireWriteLock();        try {          //noinspection resource          channel.truncate(HEADER_SIZE + size);          this.size = size;          assert this.size >= 0;          break;        } finally {          releaseWriteLock();          attempts++;        }      } catch (final IOException e) {        OLogManager.instance().error(this, "Error during file shrink for file '" + getName() + "' " + attempts + "-th attempt", e);        reopenFile(attempts, e);      }    }  }
public void create() throws IOException {    acquireWriteLock();    try {      acquireExclusiveAccess();      openChannel();      init();      setVersion(OFileClassic.CURRENT_VERSION);      version = OFileClassic.CURRENT_VERSION;      initAllocationMode();    } finally {      releaseWriteLock();    }  }
private long checkRegions(final long iOffset, final long iLength) {    acquireReadLock();    try {      if (iOffset < 0 || iOffset + iLength > size) {        throw new OIOException(            "You cannot access outside the file size (" + size + " bytes). You have requested portion " + iOffset + "-" + (iOffset                + iLength) + " bytes. File: " + this);      }      return iOffset + HEADER_SIZE;    } finally {      releaseReadLock();    }  }
public void open() {    acquireWriteLock();    try {      if (!Files.exists(osFile)) {        throw new FileNotFoundException("File: " + osFile);      }      acquireExclusiveAccess();      openChannel();      init();      OLogManager.instance().debug(this, "Checking file integrity of " + osFile.getFileName() + "...");      if (version < CURRENT_VERSION) {        setVersion(CURRENT_VERSION);        version = CURRENT_VERSION;      }      initAllocationMode();    } catch (final IOException e) {      throw OException.wrapException(new OIOException("Error during file open"), e);    } finally {      releaseWriteLock();    }  }
public void close() {    int attempts = 0;    while (true) {      try {        acquireWriteLock();        try {          if (channel != null && channel.isOpen()) {            channel.close();            channel = null;          }          if (frnd != null) {            frnd.close();            frnd = null;          }          closeFD();        } finally {          releaseWriteLock();          attempts++;        }        releaseExclusiveAccess();        break;      } catch (final IOException ioe) {        OLogManager.instance().error(this, "Error during closing of file '" + getName() + "' " + attempts + "-th attempt", ioe);        try {          reopenFile(attempts, ioe);        } catch (final IOException e) {          throw OException.wrapException(new OIOException("Error during file close"), e);        }      }    }  }
public void delete() throws IOException {    int attempts = 0;    while (true) {      try {        acquireWriteLock();        try {          close();          if (osFile != null) {            Files.deleteIfExists(osFile);          }        } finally {          releaseWriteLock();          attempts++;        }        break;      } catch (final IOException ioe) {        OLogManager.instance().error(this, "Error during deletion of file '" + getName() + "' " + attempts + "-th attempt", ioe);        reopenFile(attempts, ioe);      }    }  }
public void replaceContentWith(final Path newContentFile) throws IOException {    acquireWriteLock();    try {      close();      Files.copy(newContentFile, osFile, StandardCopyOption.REPLACE_EXISTING);      open();    } finally {      releaseWriteLock();    }  }
public Object command(final OCommandRequestText iCommand) {    final boolean live = iCommand instanceof OLiveQuery;    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();    final boolean asynch = iCommand instanceof OCommandRequestAsynch && ((OCommandRequestAsynch) iCommand).isAsynchronous();    OCommandRequest request = new OCommandRequest(database, asynch, iCommand, live);    OCommandResponse response = networkOperation(request, "Error on executing command: " + iCommand);    return response.getResult();  }
public void endRequest(final OChannelBinaryAsynchClient iNetwork) throws IOException {    if (iNetwork == null)      return;    iNetwork.flush();    iNetwork.releaseWriteLock();  }
protected void parseServerURLs() {    String lastHost = null;    int dbPos = url.indexOf('/');    if (dbPos == -1) {      // SHORT FORM      addHost(url);      lastHost = url;      name = url;    } else {      name = url.substring(url.lastIndexOf("/") + 1);      for (String host : url.substring(0, dbPos).split(ADDRESS_SEPARATOR)) {        lastHost = host;        addHost(host);      }    }    synchronized (serverURLs) {      if (serverURLs.size() == 1 && getClientConfiguration()          .getValueAsBoolean(OGlobalConfiguration.NETWORK_BINARY_DNS_LOADBALANCING_ENABLED)) {        // LOOK FOR LOAD BALANCING DNS TXT RECORD        final String primaryServer = lastHost;        OLogManager.instance().debug(this, "Retrieving URLs from DNS '%s' (timeout=%d)...", primaryServer,            getClientConfiguration().getValueAsInteger(OGlobalConfiguration.NETWORK_BINARY_DNS_LOADBALANCING_TIMEOUT));        try {          final Hashtable<String, String> env = new Hashtable<String, String>();          env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");          env.put("com.sun.jndi.ldap.connect.timeout",              getClientConfiguration().getValueAsString(OGlobalConfiguration.NETWORK_BINARY_DNS_LOADBALANCING_TIMEOUT));          final DirContext ictx = new InitialDirContext(env);          final String hostName = !primaryServer.contains(":") ?              primaryServer :              primaryServer.substring(0, primaryServer.indexOf(":"));          final Attributes attrs = ictx.getAttributes(hostName, new String[] { "TXT" });          final Attribute attr = attrs.get("TXT");          if (attr != null) {            for (int i = 0; i < attr.size(); ++i) {              String configuration = (String) attr.get(i);              if (configuration.startsWith("\""))                configuration = configuration.substring(1, configuration.length() - 1);              if (configuration != null) {                final String[] parts = configuration.split(" ");                List<String> toAdd = new ArrayList<>();                for (String part : parts) {                  if (part.startsWith("s=")) {                    toAdd.add(part.substring("s=".length()));                  }                }                if (toAdd.size() > 0) {                  serverURLs.clear();                  for (String host : toAdd)                    addHost(host);                }              }            }          }        } catch (NamingException ignore) {        }      }    }  }
protected String addHost(String host) {    if (host.startsWith(LOCALHOST))      host = LOCAL_IP + host.substring("localhost".length());    if (host.contains("/"))      host = host.substring(0, host.indexOf("/"));    // REGISTER THE REMOTE SERVER+PORT    if (!host.contains(":"))      host += ":" + (clientConfiguration.getValueAsBoolean(OGlobalConfiguration.CLIENT_USE_SSL) ?          getDefaultSSLPort() :          getDefaultPort());    else if (host.split(":").length < 2 || host.split(":")[1].trim().length() == 0)      host += (clientConfiguration.getValueAsBoolean(OGlobalConfiguration.CLIENT_USE_SSL) ? getDefaultSSLPort() : getDefaultPort());    // DISABLED BECAUSE THIS DID NOT ALLOW TO CONNECT TO LOCAL HOST ANYMORE IF THE SERVER IS BOUND TO 127.0.0.1    // CONVERT 127.0.0.1 TO THE PUBLIC IP IF POSSIBLE    // if (host.startsWith(LOCAL_IP)) {    // try {    // final String publicIP = InetAddress.getLocalHost().getHostAddress();    // host = publicIP + host.substring(LOCAL_IP.length());    // } catch (UnknownHostException e) {    // // IGNORE IT    // }    // }    synchronized (serverURLs) {      if (!serverURLs.contains(host)) {        serverURLs.add(host);        OLogManager.instance().debug(this, "Registered the new available server '%s'", host);      }    }    return host;  }
public OChannelBinaryAsynchClient beginRequest(final OChannelBinaryAsynchClient network, final byte iCommand,      OStorageRemoteSession session) throws IOException {    network.beginRequest(iCommand, session);    return network;  }
@Override  public void serializeInByteBufferObject(Short object, ByteBuffer buffer, Object... hints) {    buffer.putShort(object);  }
@Override  public Short deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return walChanges.getShortValue(buffer, offset);  }
protected static OObjectDatabaseTx getDatabase() {    ODatabaseInternal<?> databaseOwner = ODatabaseRecordThreadLocal.instance().get().getDatabaseOwner();    if (databaseOwner instanceof OObjectDatabaseTx) {      return (OObjectDatabaseTx) databaseOwner;    } else if (databaseOwner instanceof ODatabaseDocumentInternal) {      return new OObjectDatabaseTx((ODatabaseDocumentInternal) databaseOwner);    }    throw new IllegalStateException("Current database not of expected type");  }
public String toCreateIndexDDL(final String indexName, final String indexType, final String engine) {    return createIndexDDLWithFieldType(indexName, indexType, engine).toString();  }
protected void init(final Configuration configuration) {    final Boolean saveOriginalIds = configuration.getBoolean("blueprints.orientdb.saveOriginalIds", null);    if (saveOriginalIds != null)      setSaveOriginalIds(saveOriginalIds);    final Boolean keepInMemoryReferences = configuration.getBoolean("blueprints.orientdb.keepInMemoryReferences", null);    if (keepInMemoryReferences != null)      setKeepInMemoryReferences(keepInMemoryReferences);    final Boolean useCustomClassesForEdges = configuration.getBoolean("blueprints.orientdb.useCustomClassesForEdges", null);    if (useCustomClassesForEdges != null)      setUseClassForEdgeLabel(useCustomClassesForEdges);    final Boolean useCustomClassesForVertex = configuration.getBoolean("blueprints.orientdb.useCustomClassesForVertex", null);    if (useCustomClassesForVertex != null)      setUseClassForVertexLabel(useCustomClassesForVertex);    final Boolean useVertexFieldsForEdgeLabels = configuration.getBoolean("blueprints.orientdb.useVertexFieldsForEdgeLabels", null);    if (useVertexFieldsForEdgeLabels != null)      setUseVertexFieldsForEdgeLabels(useVertexFieldsForEdgeLabels);    final Boolean lightweightEdges = configuration.getBoolean("blueprints.orientdb.lightweightEdges", null);    if (lightweightEdges != null)      setUseLightweightEdges(lightweightEdges);    final Boolean autoScaleEdgeType = configuration.getBoolean("blueprints.orientdb.autoScaleEdgeType", null);    if (autoScaleEdgeType != null)      setAutoScaleEdgeType(autoScaleEdgeType);    final Boolean requireTransaction = configuration.getBoolean("blueprints.orientdb.requireTransaction", null);    if (requireTransaction != null)      setRequireTransaction(requireTransaction);    final Boolean txRequiredForSQLGraphOperations = configuration        .getBoolean("blueprints.orientdb.txRequiredForSQLGraphOperations", null);    if (txRequiredForSQLGraphOperations != null)      setTxRequiredForSQLGraphOperations(txRequiredForSQLGraphOperations);    final Integer maxRetries = configuration.getInt("blueprints.orientdb.maxRetries", 50);    if (maxRetries != null)      setMaxRetries(maxRetries);  }
public OClientConnection connect(final ONetworkProtocol iProtocol) {    final OClientConnection connection;    connection = new OClientConnection(connectionSerial.incrementAndGet(), iProtocol);    connections.put(connection.getId(), connection);    OLogManager.instance().config(this, "Remote client connected from: " + connection);    OServerPluginHelper.invokeHandlerCallbackOnClientConnection(iProtocol.getServer(), connection);    return connection;  }
public OClientConnection connect(final ONetworkProtocol iProtocol, final OClientConnection connection, final byte[] tokenBytes,      final OTokenHandler handler) {    final OToken token;    try {      token = handler.parseBinaryToken(tokenBytes);    } catch (Exception e) {      throw OException.wrapException(new OTokenSecurityException("Error on token parsing"), e);    }    OClientSessions session;    synchronized (sessions) {      session = new OClientSessions(tokenBytes, token);      sessions.put(new OHashToken(tokenBytes), session);    }    connection.setTokenBytes(tokenBytes);    connection.setTokenBased(true);    connection.setToken(token);    session.addConnection(connection);    OLogManager.instance().config(this, "Remote client connected from: " + connection);    OServerPluginHelper.invokeHandlerCallbackOnClientConnection(iProtocol.getServer(), connection);    return connection;  }
public OClientConnection getConnection(final int iChannelId, ONetworkProtocol protocol) {    // SEARCH THE CONNECTION BY ID    OClientConnection connection = connections.get(iChannelId);    if (connection != null)      connection.setProtocol(protocol);    return connection;  }
public OClientConnection getConnection(final String iAddress) {    for (OClientConnection conn : connections.values()) {      if (iAddress.equals(conn.getRemoteAddress()))        return conn;    }    return null;  }
public void kill(final OClientConnection connection) {    if (connection != null) {      final ONetworkProtocol protocol = connection.getProtocol();      try {        // INTERRUPT THE NEWTORK MANAGER TOO        protocol.interrupt();      } catch (Exception e) {        OLogManager.instance().error(this, "Error during interruption of binary protocol", e);      }      disconnect(connection);      // KILL THE NETWORK MANAGER TOO      protocol.sendShutdown();    }  }
public void interrupt(final int iChannelId) {    final OClientConnection connection = connections.get(iChannelId);    if (connection != null) {      final ONetworkProtocol protocol = connection.getProtocol();      if (protocol != null)        // INTERRUPT THE NEWTORK MANAGER        protocol.softShutdown();    }  }
public boolean disconnect(final int iChannelId) {    OLogManager.instance().debug(this, "Disconnecting connection with id=%d", iChannelId);    final OClientConnection connection = connections.remove(iChannelId);    if (connection != null) {      OServerPluginHelper.invokeHandlerCallbackOnClientDisconnection(server, connection);      connection.close();      removeConnectionFromSession(connection);      // CHECK IF THERE ARE OTHER CONNECTIONS      for (Entry<Integer, OClientConnection> entry : connections.entrySet()) {        if (entry.getValue().getProtocol().equals(connection.getProtocol())) {          OLogManager.instance()              .debug(this, "Disconnected connection with id=%d but are present other active channels", iChannelId);          return false;        }      }      OLogManager.instance().debug(this, "Disconnected connection with id=%d, no other active channels found", iChannelId);      return true;    }    OLogManager.instance().debug(this, "Cannot find connection with id=%d", iChannelId);    return false;  }
public void pushDistribCfg2Clients(final ODocument iConfig) {    if (iConfig == null)      return;    final Set<String> pushed = new HashSet<String>();    for (OClientConnection c : connections.values()) {      if (!c.getData().supportsLegacyPushMessages)        continue;      try {        final String remoteAddress = c.getRemoteAddress();        if (pushed.contains(remoteAddress))          // ALREADY SENT: JUMP IT          continue;      } catch (Exception e) {        // SOCKET EXCEPTION SKIP IT        continue;      }      if (!(c.getProtocol() instanceof ONetworkProtocolBinary) || c.getData().getSerializationImpl() == null)        // INVOLVE ONLY BINARY PROTOCOLS        continue;      final ONetworkProtocolBinary p = (ONetworkProtocolBinary) c.getProtocol();      final OChannelBinary channel = p.getChannel();      final ORecordSerializer ser = ORecordSerializerFactory.instance().getFormat(c.getData().getSerializationImpl());      if (ser == null)        return;      final byte[] content = ser.toStream(iConfig, false);      try {        // TRY ACQUIRING THE LOCK FOR MAXIMUM 3 SECS TO AVOID TO FREEZE CURRENT THREAD        if (channel.tryAcquireWriteLock(TIMEOUT_PUSH)) {          try {            channel.writeByte(OChannelBinaryProtocol.PUSH_DATA);            channel.writeInt(Integer.MIN_VALUE);            channel.writeByte(OChannelBinaryProtocol.REQUEST_PUSH_DISTRIB_CONFIG);            channel.writeBytes(content);            channel.flush();            pushed.add(c.getRemoteAddress());            OLogManager.instance().debug(this, "Sent updated cluster configuration to the remote client %s", c.getRemoteAddress());          } finally {            channel.releaseWriteLock();          }        } else {          OLogManager.instance()              .info(this, "Timeout on sending updated cluster configuration to the remote client %s", c.getRemoteAddress());        }      } catch (Exception e) {        OLogManager.instance().warn(this, "Cannot push cluster configuration to the client %s", e, c.getRemoteAddress());      }    }  }
public boolean swap(int index, OIdentifiable newValue) {    EntriesIterator iter = (EntriesIterator) rawIterator();    int currIndex = 0;    while (iter.hasNext()) {      iter.next();      if (index == currIndex) {        iter.swapValueOnCurrent(newValue);        return true;      }      currIndex++;    }    return false;  }
@Override  public void close() {    for (Map.Entry<ORID, LockedRecordMetadata> lock : locks.entrySet()) {      try {        final LockedRecordMetadata lockedRecordMetadata = lock.getValue();        if (lockedRecordMetadata.strategy.equals(OStorage.LOCKING_STRATEGY.EXCLUSIVE_LOCK)) {          ((OAbstractPaginatedStorage) getDatabase().getStorage().getUnderlying()).releaseWriteLock(lock.getKey());        } else if (lockedRecordMetadata.strategy.equals(OStorage.LOCKING_STRATEGY.SHARED_LOCK)) {          ((OAbstractPaginatedStorage) getDatabase().getStorage().getUnderlying()).releaseReadLock(lock.getKey());        }      } catch (Exception e) {        OLogManager.instance().debug(this, "Error on releasing lock against record " + lock.getKey(), e);      }    }    locks.clear();  }
private void handleUpdateEdge(ODocument record) {    Object currentOut = record.field("out");    Object currentIn = record.field("in");    Object prevOut = record.getOriginalValue("out");    Object prevIn = record.getOriginalValue("in");    // to manage subqueries    if (currentOut instanceof Collection && ((Collection) currentOut).size() == 1) {      currentOut = ((Collection) currentOut).iterator().next();      record.setProperty("out", currentOut);    }    if (currentIn instanceof Collection && ((Collection) currentIn).size() == 1) {      currentIn = ((Collection) currentIn).iterator().next();      record.setProperty("in", currentIn);    }    validateOutInForEdge(record, currentOut, currentIn);    changeVertexEdgePointer(record, (OIdentifiable) prevIn, (OIdentifiable) currentIn, "in");    changeVertexEdgePointer(record, (OIdentifiable) prevOut, (OIdentifiable) currentOut, "out");  }
private void changeVertexEdgePointer(ODocument edge, OIdentifiable prevVertex, OIdentifiable currentVertex, String direction) {    if (prevVertex != null && !prevVertex.equals(currentVertex)) {      String edgeClassName = edge.getClassName();      if (edgeClassName.equalsIgnoreCase("E")) {        edgeClassName = "";      }      String vertexFieldName = direction + "_" + edgeClassName;      ODocument prevOutDoc = ((OIdentifiable) prevVertex).getRecord();      ORidBag prevBag = prevOutDoc.field(vertexFieldName);      if (prevBag != null) {        prevBag.remove(edge);        prevOutDoc.save();      }      ODocument currentVertexDoc = ((OIdentifiable) currentVertex).getRecord();      ORidBag currentBag = currentVertexDoc.field(vertexFieldName);      if (currentBag == null) {        currentBag = new ORidBag();        currentVertexDoc.field(vertexFieldName, currentBag);      }      currentBag.add(edge);    }  }
private boolean isRecordInstanceOf(Object iRecord, String orientClass) {    if (iRecord == null) {      return false;    }    if (!(iRecord instanceof OIdentifiable)) {      return false;    }    ODocument record = ((OIdentifiable) iRecord).getRecord();    if (iRecord == null) {      return false;    }    return (record.getSchemaClass().isSubClassOf(orientClass));  }
@Override  public void serializeInByteBufferObject(Character object, ByteBuffer buffer, Object... hints) {    buffer.putChar(object);  }
public synchronized void generateSchema(final String iPackageName, final ClassLoader iClassLoader) {    OLogManager.instance().debug(this, "Generating schema inside package: %s", iPackageName);    List<Class<?>> classes = null;    try {      classes = OReflectionHelper.getClassesFor(iPackageName, iClassLoader);    } catch (ClassNotFoundException e) {      throw OException.wrapException(new ODatabaseException("Classes cannot be loaded during schema generation"), e);    }    for (Class<?> c : classes) {      generateSchema(c);    }  }
public synchronized void generateSchema(final Class<?> iClass, ODatabaseDocument database) {    if (iClass == null || iClass.isInterface() || iClass.isPrimitive() || iClass.isEnum() || iClass.isAnonymousClass())      return;    OObjectEntitySerializer.registerClass(iClass);    OClass schema = database.getMetadata().getSchema().getClass(iClass);    if (schema == null) {      generateOClass(iClass, database);    }    List<String> fields = OObjectEntitySerializer.getClassFields(iClass);    if (fields != null)      for (String field : fields) {        if (schema.existsProperty(field))          continue;        if (OObjectEntitySerializer.isVersionField(iClass, field) || OObjectEntitySerializer.isIdField(iClass, field))          continue;        Field f = OObjectEntitySerializer.getField(field, iClass);        if (f.getType().equals(Object.class) || f.getType().equals(ODocument.class) || OBlob.class.isAssignableFrom(f.getType())) {          continue;        }        OType t = OObjectEntitySerializer.getTypeByClass(iClass, field, f);        if (t == OType.CUSTOM) {          OEntityManager entityManager = OEntityManager.getEntityManagerByDatabaseURL(database.getURL());          // if the target type is registered as entity, it should be linked instead of custom/serialized          if (entityManager.getEntityClass(f.getType().getSimpleName()) != null) {            t = OType.LINK;          }        }        if (t == null) {          if (f.getType().isEnum())            t = OType.STRING;          else {            t = OType.LINK;          }        }        switch (t) {        case LINK:          Class<?> linkedClazz = OObjectEntitySerializer.getSpecifiedLinkedType(f);          if (linkedClazz == null)            linkedClazz = f.getType();          generateLinkProperty(database, schema, field, t, linkedClazz);          break;        case LINKLIST:        case LINKMAP:        case LINKSET:          linkedClazz = OObjectEntitySerializer.getSpecifiedMultiLinkedType(f);          if (linkedClazz == null)            linkedClazz = OReflectionHelper.getGenericMultivalueType(f);          if (linkedClazz != null)            generateLinkProperty(database, schema, field, t, linkedClazz);          break;        case EMBEDDED:          linkedClazz = f.getType();          if (linkedClazz == null || linkedClazz.equals(Object.class) || linkedClazz.equals(ODocument.class) || OBlob.class              .isAssignableFrom(f.getType())) {            continue;          } else {            generateLinkProperty(database, schema, field, t, linkedClazz);          }          break;        case EMBEDDEDLIST:        case EMBEDDEDSET:        case EMBEDDEDMAP:          linkedClazz = OReflectionHelper.getGenericMultivalueType(f);          if (linkedClazz == null || linkedClazz.equals(Object.class) || linkedClazz.equals(ODocument.class) || OBlob.class              .isAssignableFrom(f.getType())) {            continue;          } else {            if (OReflectionHelper.isJavaType(linkedClazz)) {              schema.createProperty(field, t, OType.getTypeByClass(linkedClazz));            } else if (linkedClazz.isEnum()) {              schema.createProperty(field, t, OType.STRING);            } else {              generateLinkProperty(database, schema, field, t, linkedClazz);            }          }          break;        default:          schema.createProperty(field, t);          break;        }      }  }
public synchronized void synchronizeSchema() {    OObjectDatabaseTx database = ((OObjectDatabaseTx) ODatabaseRecordThreadLocal.instance().get().getDatabaseOwner());    Collection<Class<?>> registeredEntities = database.getEntityManager().getRegisteredEntities();    boolean automaticSchemaGeneration = database.isAutomaticSchemaGeneration();    boolean reloadSchema = false;    for (Class<?> iClass : registeredEntities) {      if (Proxy.class.isAssignableFrom(iClass) || iClass.isEnum() || OReflectionHelper.isJavaType(iClass) || iClass          .isAnonymousClass())        return;      if (!database.getMetadata().getSchema().existsClass(iClass.getSimpleName())) {        database.getMetadata().getSchema().createClass(iClass.getSimpleName());        reloadSchema = true;      }      for (Class<?> currentClass = iClass; currentClass != Object.class; ) {        if (automaticSchemaGeneration && !currentClass.equals(Object.class) && !currentClass.equals(ODocument.class)) {          ((OSchemaProxyObject) database.getMetadata().getSchema()).generateSchema(currentClass, database.getUnderlying());        }        String iClassName = currentClass.getSimpleName();        currentClass = currentClass.getSuperclass();        if (currentClass == null || currentClass.equals(ODocument.class))          // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER          // ODOCUMENT FIELDS          currentClass = Object.class;        if (database != null && !database.isClosed() && !currentClass.equals(Object.class)) {          OClass oSuperClass;          OClass currentOClass = database.getMetadata().getSchema().getClass(iClassName);          if (!database.getMetadata().getSchema().existsClass(currentClass.getSimpleName())) {            oSuperClass = database.getMetadata().getSchema().createClass(currentClass.getSimpleName());            reloadSchema = true;          } else {            oSuperClass = database.getMetadata().getSchema().getClass(currentClass.getSimpleName());            reloadSchema = true;          }          if (!currentOClass.getSuperClasses().contains(oSuperClass)) {            currentOClass.setSuperClasses(Arrays.asList(oSuperClass));            reloadSchema = true;          }        }      }    }    if (database != null && !database.isClosed() && reloadSchema) {      database.getMetadata().getSchema().reload();    }  }
protected void updateMetadata(final String iName, final String iDescription, final METRIC_TYPE iType) {    if (iDescription != null && dictionary.putIfAbsent(iName, iDescription) == null)      types.put(iName, iType);  }
@SuppressWarnings("unchecked")  public REC next() {    checkDirection(true);    if (currentRecord != null)      try {        // RETURN LAST LOADED RECORD        return (REC) currentRecord;      } finally {        currentRecord = null;      }    ORecord record;    // MOVE FORWARD IN THE CURRENT CLUSTER    while (hasNext()) {      if (currentRecord != null)        try {          // RETURN LAST LOADED RECORD          return (REC) currentRecord;        } finally {          currentRecord = null;        }      record = getTransactionEntry();      if (record == null)        record = readCurrentRecord(null, +1);      if (record != null)        // FOUND        if (include(record))          return (REC) record;    }    record = getTransactionEntry();    if (record != null)      return (REC) record;    throw new NoSuchElementException(        "Direction: forward, last position was: " + current + ", range: " + beginRange + "-" + endRange);  }
@SuppressWarnings("unchecked")  @Override  public REC previous() {    checkDirection(false);    if (currentRecord != null)      try {        // RETURN LAST LOADED RECORD        return (REC) currentRecord;      } finally {        currentRecord = null;      }    ORecord record = getRecord();    // MOVE BACKWARD IN THE CURRENT CLUSTER    while (hasPrevious()) {      if (currentRecord != null)        try {          // RETURN LAST LOADED RECORD          return (REC) currentRecord;        } finally {          currentRecord = null;        }      record = getTransactionEntry();      if (record == null)        record = readCurrentRecord(null, -1);      if (record != null)        // FOUND        if (include(record))          return (REC) record;    }    record = getTransactionEntry();    if (record != null)      return (REC) record;    return null;  }
@Override  public ORecordIteratorClusters<REC> begin() {    if (clusterIds.length == 0)      return this;    browsedRecords = 0;    currentClusterIdx = 0;    current.setClusterId(clusterIds[currentClusterIdx]);    updateClusterRange();    resetCurrentPosition();    nextPosition();    final ORecord record = getRecord();    currentRecord = readCurrentRecord(record, 0);    if (currentRecord != null && !include(currentRecord)) {      currentRecord = null;      hasNext();    }    return this;  }
@Override  public ORecordIteratorClusters<REC> last() {    if (clusterIds.length == 0)      return this;    browsedRecords = 0;    currentClusterIdx = clusterIds.length - 1;    updateClusterRange();    current.setClusterId(clusterIds[currentClusterIdx]);    resetCurrentPosition();    prevPosition();    final ORecord record = getRecord();    currentRecord = readCurrentRecord(record, 0);    if (currentRecord != null && !include(currentRecord)) {      currentRecord = null;      hasPrevious();    }    return this;  }
@Override  public ORecordIteratorClusters<REC> setLiveUpdated(boolean iLiveUpdated) {    super.setLiveUpdated(iLiveUpdated);    if (iLiveUpdated) {      firstClusterEntry = 0;      lastClusterEntry = Long.MAX_VALUE;    } else {      updateClusterRange();    }    return this;  }
public Object execute(final Map<Object, Object> iArgs) {    if (clazz == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    return OGraphCommandExecutorSQLFactory.runInConfiguredTxMode(new OGraphCommandExecutorSQLFactory.GraphCallBack<List<Object>>() {      @Override      public List<Object> call(OrientBaseGraph graph) {        final Set<OIdentifiable> fromIds = OSQLEngine.getInstance().parseRIDTarget(graph.getRawGraph(), from, context, iArgs);        final Set<OIdentifiable> toIds = OSQLEngine.getInstance().parseRIDTarget(graph.getRawGraph(), to, context, iArgs);        // CREATE EDGES        final List<Object> edges = new ArrayList<Object>();        for (OIdentifiable from : fromIds) {          final OrientVertex fromVertex = graph.getVertex(from);          if (fromVertex == null)            throw new OCommandExecutionException("Source vertex '" + from + "' not exists");          for (OIdentifiable to : toIds) {            final OrientVertex toVertex;            if (from.equals(to)) {              toVertex = fromVertex;            } else {              toVertex = graph.getVertex(to);            }            if (fields != null)              // EVALUATE FIELDS              for (final OPair<String, Object> f : fields) {                if (f.getValue() instanceof OSQLFunctionRuntime) {                  f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(to, null, context));                }else if(f.getValue() instanceof OSQLFilterItem){                  f.setValue(((OSQLFilterItem) f.getValue()).getValue(to, null, context));                }              }            OrientEdge edge = null;            if (content != null) {              if (fields != null)                // MERGE CONTENT WITH FIELDS                fields.addAll(OPair.convertFromMap(content.toMap()));              else                fields = OPair.convertFromMap(content.toMap());            }            edge = fromVertex.addEdge(null, toVertex, edgeLabel, clusterName, fields);            if (fields != null && !fields.isEmpty()) {              if (edge.isLightweight())                edge.convertToDocument();              OSQLHelper.bindParameters(edge.getRecord(), fields, new OCommandParameters(iArgs), context);            }            edge.save(clusterName);            edges.add(edge);            if (batch > 0 && edges.size() % batch == 0) {              graph.commit();              graph.begin();            }          }        }        if (edges.isEmpty()) {          if (fromIds.isEmpty())            throw new OCommandExecutionException("No edge has been created because no source vertices");          else if (toIds.isEmpty())            throw new OCommandExecutionException("No edge has been created because no target vertices");          throw new OCommandExecutionException("No edge has been created between " + fromIds + " and " + toIds);        }        return edges;      }    });  }
public int nextChar() throws IOException {    if (missedChar != null) {      // RETURNS THE PREVIOUS PARSED CHAR      c = missedChar.charValue();      missedChar = null;    } else {      int read = in.read();      if (read == -1)        return -1;      c = (char) read;      if (c == '\\') {        read = in.read();        if (read == -1)          return -1;        char c2 = (char) read;        if (c2 == 'u') {          // DECODE UNICODE CHAR          final StringBuilder buff = new StringBuilder(8);          for (int i = 0; i < 4; ++i) {            read = in.read();            if (read == -1)              return -1;            buff.append((char) read);          }          cursor += 6;          return (char) Integer.parseInt(buff.toString(), 16);        } else {          // REMEMBER THE CURRENT CHAR TO RETURN NEXT TIME          missedChar = c2;        }      }    }    cursor++;    if (c == NEW_LINE) {      ++lineNumber;      columnNumber = 0;    } else      ++columnNumber;    return (char) c;  }
public Object execute(final Map<Object, Object> iArgs) {    if (recordIds.isEmpty() && subQuery == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    if (subQuery != null) {      final List<OIdentifiable> result = new OCommandSQL(subQuery.toString()).execute();      for (OIdentifiable id : result)        recordIds.add(id.getIdentity());    }    return OFindReferenceHelper.findReferences(recordIds, classList);  }
private static OBinaryRequest<? extends OBinaryResponse> createRequest(int requestType) {    switch (requestType) {    case OChannelBinaryProtocol.REQUEST_DB_OPEN:      return new OOpenRequest();    case OChannelBinaryProtocol.REQUEST_CONNECT:      return new OConnectRequest();    case OChannelBinaryProtocol.REQUEST_DB_REOPEN:      return new OReopenRequest();    case OChannelBinaryProtocol.REQUEST_SHUTDOWN:      return new OShutdownRequest();    case OChannelBinaryProtocol.REQUEST_DB_LIST:      return new OListDatabasesRequest();    case OChannelBinaryProtocol.REQUEST_SERVER_INFO:      return new OServerInfoRequest();    case OChannelBinaryProtocol.REQUEST_DB_RELOAD:      return new OReloadRequest();    case OChannelBinaryProtocol.REQUEST_DB_CREATE:      return new OCreateDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_CLOSE:      return new OCloseRequest();    case OChannelBinaryProtocol.REQUEST_DB_EXIST:      return new OExistsDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_DROP:      return new ODropDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_SIZE:      return new OGetSizeRequest();    case OChannelBinaryProtocol.REQUEST_DB_COUNTRECORDS:      return new OCountRecordsRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER:      return new ODistributedStatusRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_COUNT:      return new OCountRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_DATARANGE:      return new OGetClusterDataRangeRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_ADD:      return new OAddClusterRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_DROP:      return new ODropClusterRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_METADATA:      return new OGetRecordMetadataRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_LOAD:      return new OReadRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_LOAD_IF_VERSION_NOT_LATEST:      return new OReadRecordIfVersionIsNotLatestRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_CREATE:      return new OCreateRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_UPDATE:      return new OUpdateRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_DELETE:      return new ODeleteRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_HIDE:      return new OHideRecordRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_HIGHER:      return new OHigherPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_CEILING:      return new OCeilingPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_LOWER:      return new OLowerPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_FLOOR:      return new OFloorPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_COMMAND:      return new OCommandRequest();    case OChannelBinaryProtocol.REQUEST_QUERY:      return new OQueryRequest();    case OChannelBinaryProtocol.REQUEST_CLOSE_QUERY:      return new OCloseQueryRequest();    case OChannelBinaryProtocol.REQUEST_QUERY_NEXT_PAGE:      return new OQueryNextPageRequest();    case OChannelBinaryProtocol.REQUEST_TX_COMMIT:      return new OCommitRequest();    case OChannelBinaryProtocol.REQUEST_CONFIG_GET:      return new OGetGlobalConfigurationRequest();    case OChannelBinaryProtocol.REQUEST_CONFIG_SET:      return new OSetGlobalConfigurationRequest();    case OChannelBinaryProtocol.REQUEST_CONFIG_LIST:      return new OListGlobalConfigurationsRequest();    case OChannelBinaryProtocol.REQUEST_DB_FREEZE:      return new OFreezeDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_RELEASE:      return new OReleaseDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_CLEAN_OUT:      return new OCleanOutRecordRequest();    case OChannelBinaryProtocol.REQUEST_CREATE_SBTREE_BONSAI:      return new OSBTCreateTreeRequest();    case OChannelBinaryProtocol.REQUEST_SBTREE_BONSAI_GET:      return new OSBTGetRequest();    case OChannelBinaryProtocol.REQUEST_SBTREE_BONSAI_FIRST_KEY:      return new OSBTFirstKeyRequest();    case OChannelBinaryProtocol.REQUEST_SBTREE_BONSAI_GET_ENTRIES_MAJOR:      return new OSBTFetchEntriesMajorRequest<>();    case OChannelBinaryProtocol.REQUEST_RIDBAG_GET_SIZE:      return new OSBTGetRealBagSizeRequest();    case OChannelBinaryProtocol.REQUEST_INCREMENTAL_BACKUP:      return new OIncrementalBackupRequest();    case OChannelBinaryProtocol.REQUEST_DB_IMPORT:      return new OImportRequest();    case OChannelBinaryProtocol.DISTRIBUTED_CONNECT:      return new ODistributedConnectRequest();    default:      throw new ODatabaseException("binary protocol command with code: " + requestType);    }  }
public static OBinaryRequest<? extends OBinaryResponse> createRequest37(int requestType) {    switch (requestType) {    case OChannelBinaryProtocol.SUBSCRIBE_PUSH:      return new OSubscribeRequest();    case OChannelBinaryProtocol.EXPERIMENTAL:      return new OExperimentalRequest();    case OChannelBinaryProtocol.UNSUBSCRIBE_PUSH:      return new OUnsubscribeRequest();    case OChannelBinaryProtocol.REQUEST_TX_FETCH:      return new OFetchTransactionRequest();    case OChannelBinaryProtocol.REQUEST_TX_REBEGIN:      return new ORebeginTransactionRequest();    case OChannelBinaryProtocol.REQUEST_TX_BEGIN:      return new OBeginTransactionRequest();    case OChannelBinaryProtocol.REQUEST_TX_COMMIT:      return new OCommit37Request();    case OChannelBinaryProtocol.REQUEST_TX_ROLLBACK:      return new ORollbackTransactionRequest();    case OChannelBinaryProtocol.REQUEST_BATCH_OPERATIONS:      return new OBatchOperationsRequest();    case OChannelBinaryProtocol.REQUEST_DB_OPEN:      return new OOpen37Request();    case OChannelBinaryProtocol.REQUEST_CONNECT:      return new OConnect37Request();    case OChannelBinaryProtocol.REQUEST_DB_REOPEN:      return new OReopenRequest();    case OChannelBinaryProtocol.REQUEST_SHUTDOWN:      return new OShutdownRequest();    case OChannelBinaryProtocol.REQUEST_DB_LIST:      return new OListDatabasesRequest();    case OChannelBinaryProtocol.REQUEST_SERVER_INFO:      return new OServerInfoRequest();    case OChannelBinaryProtocol.REQUEST_DB_RELOAD:      return new OReloadRequest37();    case OChannelBinaryProtocol.REQUEST_DB_CREATE:      return new OCreateDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_CLOSE:      return new OCloseRequest();    case OChannelBinaryProtocol.REQUEST_DB_EXIST:      return new OExistsDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_DROP:      return new ODropDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_SIZE:      return new OGetSizeRequest();    case OChannelBinaryProtocol.REQUEST_DB_COUNTRECORDS:      return new OCountRecordsRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER:      return new ODistributedStatusRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_COUNT:      return new OCountRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_DATARANGE:      return new OGetClusterDataRangeRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_ADD:      return new OAddClusterRequest();    case OChannelBinaryProtocol.REQUEST_CLUSTER_DROP:      return new ODropClusterRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_METADATA:      return new OGetRecordMetadataRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_LOAD:      return new OReadRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_LOAD_IF_VERSION_NOT_LATEST:      return new OReadRecordIfVersionIsNotLatestRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_CREATE:      return new OCreateRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_UPDATE:      return new OUpdateRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_DELETE:      return new ODeleteRecordRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_HIDE:      return new OHideRecordRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_HIGHER:      return new OHigherPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_CEILING:      return new OCeilingPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_LOWER:      return new OLowerPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_POSITIONS_FLOOR:      return new OFloorPhysicalPositionsRequest();    case OChannelBinaryProtocol.REQUEST_COMMAND:      return new OCommandRequest();    case OChannelBinaryProtocol.REQUEST_QUERY:      return new OQueryRequest();    case OChannelBinaryProtocol.REQUEST_CLOSE_QUERY:      return new OCloseQueryRequest();    case OChannelBinaryProtocol.REQUEST_QUERY_NEXT_PAGE:      return new OQueryNextPageRequest();    case OChannelBinaryProtocol.REQUEST_CONFIG_GET:      return new OGetGlobalConfigurationRequest();    case OChannelBinaryProtocol.REQUEST_CONFIG_SET:      return new OSetGlobalConfigurationRequest();    case OChannelBinaryProtocol.REQUEST_CONFIG_LIST:      return new OListGlobalConfigurationsRequest();    case OChannelBinaryProtocol.REQUEST_DB_FREEZE:      return new OFreezeDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_DB_RELEASE:      return new OReleaseDatabaseRequest();    case OChannelBinaryProtocol.REQUEST_RECORD_CLEAN_OUT:      return new OCleanOutRecordRequest();    case OChannelBinaryProtocol.REQUEST_CREATE_SBTREE_BONSAI:      return new OSBTCreateTreeRequest();    case OChannelBinaryProtocol.REQUEST_SBTREE_BONSAI_GET:      return new OSBTGetRequest();    case OChannelBinaryProtocol.REQUEST_SBTREE_BONSAI_FIRST_KEY:      return new OSBTFirstKeyRequest();    case OChannelBinaryProtocol.REQUEST_SBTREE_BONSAI_GET_ENTRIES_MAJOR:      return new OSBTFetchEntriesMajorRequest<>();    case OChannelBinaryProtocol.REQUEST_RIDBAG_GET_SIZE:      return new OSBTGetRealBagSizeRequest();    case OChannelBinaryProtocol.REQUEST_INCREMENTAL_BACKUP:      return new OIncrementalBackupRequest();    case OChannelBinaryProtocol.REQUEST_DB_IMPORT:      return new OImportRequest();    case OChannelBinaryProtocol.DISTRIBUTED_CONNECT:      return new ODistributedConnectRequest();    default:      throw new ODatabaseException("binary protocol command with code: " + requestType + " for protocol version 37");    }  }
public static Object parseValue(String iValue, final OCommandContext iContext) {    return parseValue(iValue, iContext, false);  }
@Override  public OCommandRequestAbstract onAsyncReplicationError(final OAsyncReplicationError iCallback) {    if (iCallback != null) {      onAsyncReplicationError = new OAsyncReplicationError() {        int retry = 0;        @Override        public ACTION onAsyncReplicationError(Throwable iException, final int iRetry) {          switch (iCallback.onAsyncReplicationError(iException, ++retry)) {          case RETRY:            execute();            break;          case IGNORE:          }          return ACTION.IGNORE;        }      };    } else      onAsyncReplicationError = null;    return this;  }
public void register(final Class<? extends OCompression> compression) {    try {      final OCompression tempInstance = compression.newInstance();      final String name = tempInstance.name();      if (compressions.containsKey(name))        throw new IllegalArgumentException("Compression with name '" + name + "' was already registered");      if (compressionClasses.containsKey(tempInstance.name()))        throw new IllegalArgumentException("Compression with name '" + name + "' was already registered");      compressionClasses.put(name, compression);    } catch (Exception e) {      OLogManager.instance().error(this, "Cannot register storage compression algorithm '%s'", e, compression);    }  }
public int getOpenFilesLimit(boolean verbose, int recommended, int defLimit) {    if (Platform.isLinux()) {      final OCLibrary.Rlimit rlimit = new OCLibrary.Rlimit();      final int result = C_LIBRARY.getrlimit(OCLibrary.RLIMIT_NOFILE, rlimit);      if (result == 0 && rlimit.rlim_cur > 0) {        if (verbose) {          OLogManager.instance().infoNoDb(this, "Detected limit of amount of simultaneously open files is %d, "              + " limit of open files for disk cache will be set to %d", rlimit.rlim_cur, rlimit.rlim_cur / 2 - 512);        }        if (rlimit.rlim_cur < recommended) {          OLogManager.instance()              .warnNoDb(this, "Value of limit of simultaneously open files is too small, recommended value is %d", recommended);        }        return (int) rlimit.rlim_cur / 2 - 512;      } else {        if (verbose) {          OLogManager.instance().infoNoDb(this, "Can not detect value of limit of open files.");        }      }    } else if (Platform.isWindows()) {      if (verbose) {        OLogManager.instance()            .infoNoDb(this, "Windows OS is detected, %d limit of open files will be set for the disk cache.", recommended);      }      return recommended;    }    if (verbose) {      OLogManager.instance().infoNoDb(this, "Default limit of open files (%d) will be used.", defLimit);    }    return defLimit;  }
public MemoryLimitResult getMemoryLimit(final boolean printSteps) {    //Perform several steps here:    //1. Fetch physical size available on machine    //2. Fetch soft limit    //3. Fetch cgroup soft limit    //4. Fetch cgroup hard limit    //5. Return the minimal value from the list of results    long memoryLimit = getPhysicalMemorySize();    boolean insideContainer = false;    if (printSteps) {      OLogManager.instance()          .infoNoDb(this, "%d B/%d MB/%d GB of physical memory were detected on machine", memoryLimit, convertToMB(memoryLimit),              convertToGB(memoryLimit));    }    if (Platform.isLinux()) {      final OCLibrary.Rlimit rlimit = new OCLibrary.Rlimit();      final int result = C_LIBRARY.getrlimit(OCLibrary.RLIMIT_AS, rlimit);      //no errors during the call      if (result == 0) {        if (printSteps)          OLogManager.instance().infoNoDb(this, "Soft memory limit for this process is set to %d B/%d MB/%d GB", rlimit.rlim_cur,              convertToMB(rlimit.rlim_cur), convertToGB(rlimit.rlim_cur));        memoryLimit = updateMemoryLimit(memoryLimit, rlimit.rlim_cur);        if (printSteps)          OLogManager.instance().infoNoDb(this, "Hard memory limit for this process is set to %d B/%d MB/%d GB", rlimit.rlim_max,              convertToMB(rlimit.rlim_max), convertToGB(rlimit.rlim_max));        memoryLimit = updateMemoryLimit(memoryLimit, rlimit.rlim_max);      }      final String memoryCGroupPath = findMemoryGCGroupPath();      if (memoryCGroupPath != null) {        if (printSteps)          OLogManager.instance().infoNoDb(this, "Path to 'memory' cgroup is '%s'", memoryCGroupPath);        final String memoryCGroupRoot = findMemoryGCRoot();        if (printSteps)          OLogManager.instance().infoNoDb(this, "Mounting path for memory cgroup controller is '%s'", memoryCGroupRoot);        File memoryCGroup = new File(memoryCGroupRoot, memoryCGroupPath);        if (!memoryCGroup.exists()) {          if (printSteps)            OLogManager.instance().infoNoDb(this, "Can not find '%s' path for memory cgroup, it is supposed that "                + "process is running in container, will try to read root '%s' memory cgroup data", memoryCGroup, memoryCGroupRoot);          memoryCGroup = new File(memoryCGroupRoot);          insideContainer = true;        }        final long softMemoryLimit = fetchCGroupSoftMemoryLimit(memoryCGroup, printSteps);        memoryLimit = updateMemoryLimit(memoryLimit, softMemoryLimit);        final long hardMemoryLimit = fetchCGroupHardMemoryLimit(memoryCGroup, printSteps);        memoryLimit = updateMemoryLimit(memoryLimit, hardMemoryLimit);      }    }    if (printSteps) {      if (memoryLimit > 0)        OLogManager.instance()            .infoNoDb(this, "Detected memory limit for current process is %d B/%d MB/%d GB", memoryLimit, convertToMB(memoryLimit),                convertToGB(memoryLimit));      else        OLogManager.instance().infoNoDb(this, "Memory limit for current process is not set");    }    if (memoryLimit <= 0)      return null;    return new MemoryLimitResult(memoryLimit, insideContainer);  }
private long getPhysicalMemorySize() {    long osMemory = -1;    try {      final MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();      final Object attribute = mBeanServer          .getAttribute(new ObjectName("java.lang", "type", "OperatingSystem"), "TotalPhysicalMemorySize");      if (attribute != null) {        if (attribute instanceof Long) {          osMemory = (Long) attribute;        } else {          try {            osMemory = Long.parseLong(attribute.toString());          } catch (final NumberFormatException e) {            if (!OLogManager.instance().isDebugEnabled())              OLogManager.instance().warnNoDb(OMemory.class, "Unable to determine the amount of installed RAM.");            else              OLogManager.instance().debugNoDb(OMemory.class, "Unable to determine the amount of installed RAM.", e);          }        }      } else {        if (!OLogManager.instance().isDebugEnabled())          OLogManager.instance().warnNoDb(OMemory.class, "Unable to determine the amount of installed RAM.");      }    } catch (MalformedObjectNameException | AttributeNotFoundException | InstanceNotFoundException | MBeanException | ReflectionException e) {      if (!OLogManager.instance().isDebugEnabled())        OLogManager.instance().warnNoDb(OMemory.class, "Unable to determine the amount of installed RAM.");      else        OLogManager.instance().debugNoDb(OMemory.class, "Unable to determine the amount of installed RAM.", e);    } catch (final RuntimeException e) {      OLogManager.instance().warnNoDb(OMemory.class, "Unable to determine the amount of installed RAM.", e);    }    return osMemory;  }
public boolean allowsIndexedFunctionExecutionOnTarget(OFromClause target, OCommandContext context,      OBinaryCompareOperator operator, Object right) {    if (this.childExpressions.size() != 1) {      return false;    }    return this.childExpressions.get(0).allowsIndexedFunctionExecutionOnTarget(target, context, operator, right);  }
public Object execute(final Map<Object, Object> iArgs) {    if (clazz == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    // CREATE VERTEX DOES NOT HAVE TO BE IN TX    return OGraphCommandExecutorSQLFactory.runWithAnyGraph(new OGraphCommandExecutorSQLFactory.GraphCallBack<Object>() {      @Override      public Object call(final OrientBaseGraph graph) {        final OrientVertex vertex = graph.addTemporaryVertex(clazz.getName());        if (fields != null)          // EVALUATE FIELDS          for (final OPair<String, Object> f : fields) {            if (f.getValue() instanceof OSQLFunctionRuntime)              f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(vertex.getRecord(), null, context));          }        OSQLHelper.bindParameters(vertex.getRecord(), fields, new OCommandParameters(iArgs), context);        if (content != null)          vertex.getRecord().merge(content, true, false);        if (clusterName != null)          vertex.save(clusterName);        else          vertex.save();        return vertex.getRecord();      }    });  }
public static void writeOType(BytesContainer bytes, int pos, OType type) {    bytes.bytes[pos] = (byte) type.getId();  }
public void move(final int iFrom, final int iPosition) {    if (iPosition == 0)      return;    final int to = iFrom + iPosition;    final int size = iPosition > 0 ? buffer.length - to : buffer.length - iFrom;    System.arraycopy(buffer, iFrom, buffer, to, size);  }
public final byte[] toByteArray() {    if (position == buffer.length - 1)      // 100% USED, RETURN THE FULL BUFFER      return buffer;    final int pos = position;    final byte[] destinBuffer = new byte[pos];    final byte[] sourceBuffer = buffer;    if (pos < NATIVE_COPY_THRESHOLD)      for (int i = 0; i < pos; ++i)        destinBuffer[i] = sourceBuffer[i];    else      System.arraycopy(sourceBuffer, 0, destinBuffer, 0, pos);    return destinBuffer;  }
public int set(final byte[] iContent) {    if (iContent == null)      return -1;    final int begin = position;    assureSpaceFor(OBinaryProtocol.SIZE_INT + iContent.length);    OBinaryProtocol.int2bytes(iContent.length, buffer, position);    position += OBinaryProtocol.SIZE_INT;    write(iContent, 0, iContent.length);    return begin;  }
public void fill(final int iLength, final byte iFiller) {    assureSpaceFor(iLength);    Arrays.fill(buffer, position, position + iLength, iFiller);    position += iLength;  }
public OExecutionStepInternal executeUntilReturn() {    if (steps.size() > 0) {      lastStep = steps.get(steps.size() - 1);    }    for (int i = 0; i < steps.size() - 1; i++) {      ScriptLineStep step = steps.get(i);      if (step.containsReturn()) {        OExecutionStepInternal returnStep = step.executeUntilReturn(ctx);        if (returnStep != null) {          lastStep = returnStep;          return lastStep;        }      }      OResultSet lastResult = step.syncPull(ctx, 100);      while (lastResult.hasNext()) {        while (lastResult.hasNext()) {          lastResult.next();        }        lastResult = step.syncPull(ctx, 100);      }    }    this.lastStep = steps.get(steps.size() - 1);    return lastStep;  }
public OExecutionStepInternal executeFull() {    for (int i = 0; i < steps.size(); i++) {      ScriptLineStep step = steps.get(i);      if (step.containsReturn()) {        OExecutionStepInternal returnStep = step.executeUntilReturn(ctx);        if (returnStep != null) {          return returnStep;        }      }      OResultSet lastResult = step.syncPull(ctx, 100);      while (lastResult.hasNext()) {        while (lastResult.hasNext()) {          lastResult.next();        }        lastResult = step.syncPull(ctx, 100);      }    }    return null;  }
public static ODocument toStream(final Object iPojo, final ODocument iRecord, final OEntityManager iEntityManager,      final OClass schemaClass, final OUserObject2RecordHandler iObj2RecHandler, final ODatabaseObject db,      final boolean iSaveOnlyDirty) {    if (iSaveOnlyDirty && !iRecord.isDirty())      return iRecord;    final long timer = Orient.instance().getProfiler().startChrono();    final Integer identityRecord = System.identityHashCode(iRecord);    if (OSerializationThreadLocal.INSTANCE.get().contains(identityRecord))      return iRecord;    OSerializationThreadLocal.INSTANCE.get().add(identityRecord);    OProperty schemaProperty;    final Class<?> pojoClass = iPojo.getClass();    final List<Field> properties = getClassFields(pojoClass);    // CHECK FOR ID BINDING    final Field idField = fieldIds.get(pojoClass);    if (idField != null) {      Object id = getFieldValue(iPojo, idField.getName());      if (id != null) {        // FOUND        if (id instanceof ORecordId) {          ORecordInternal.setIdentity(iRecord, (ORecordId) id);        } else if (id instanceof Number) {          // TREATS AS CLUSTER POSITION          ((ORecordId) iRecord.getIdentity()).setClusterId(schemaClass.getDefaultClusterId());          ((ORecordId) iRecord.getIdentity()).setClusterPosition(((Number) id).longValue());        } else if (id instanceof String)          ((ORecordId) iRecord.getIdentity()).fromString((String) id);        else if (id.getClass().equals(Object.class))          ORecordInternal.setIdentity(iRecord, (ORecordId) id);        else          OLogManager.instance().warn(OObjectSerializerHelper.class,              "@Id field has been declared as %s while the supported are: ORID, Number, String, Object", id.getClass());      }    }    // CHECK FOR VERSION BINDING    final Field vField = fieldVersions.get(pojoClass);    boolean versionConfigured = false;    if (vField != null) {      versionConfigured = true;      Object ver = getFieldValue(iPojo, vField.getName());      final int version = convertVersion(ver);      ORecordInternal.setVersion(iRecord, version);    }    if (db.isMVCC() && !versionConfigured && db.getTransaction() instanceof OTransactionOptimistic)      throw new OTransactionException("Cannot involve an object of class '" + pojoClass          + "' in an Optimistic Transaction commit because it does not define @Version or @OVersion and therefore cannot handle MVCC");    // SET OBJECT CLASS    iRecord.setClassName(schemaClass != null ? schemaClass.getName() : null);    String fieldName;    Object fieldValue;    // CALL BEFORE MARSHALLING    invokeCallback(iPojo, iRecord, OBeforeSerialization.class);    for (Field p : properties) {      fieldName = p.getName();      if (idField != null && fieldName.equals(idField.getName()))        continue;      if (vField != null && fieldName.equals(vField.getName()))        continue;      fieldValue = serializeFieldValue(getFieldType(iPojo, fieldName), getFieldValue(iPojo, fieldName));      schemaProperty = schemaClass != null ? schemaClass.getProperty(fieldName) : null;      if (fieldValue != null) {        if (isEmbeddedObject(iPojo.getClass(), fieldValue.getClass(), fieldName, iEntityManager)) {          // AUTO CREATE SCHEMA PROPERTY          if (schemaClass == null) {            db.getMetadata().getSchema().createClass(iPojo.getClass());            iRecord.setClassNameIfExists(iPojo.getClass().getSimpleName());          }          if (schemaProperty == null) {            OType t = OType.getTypeByClass(fieldValue.getClass());            if (t == null)              t = OType.EMBEDDED;            schemaProperty = iRecord.getSchemaClass().createProperty(fieldName, t);          }        }      }      fieldValue = typeToStream(fieldValue, schemaProperty != null ? schemaProperty.getType() : null, iEntityManager,          iObj2RecHandler, db, iRecord, iSaveOnlyDirty);      iRecord.field(fieldName, fieldValue);    }    iObj2RecHandler.registerUserObject(iPojo, iRecord);    // CALL AFTER MARSHALLING    invokeCallback(iPojo, iRecord, OAfterSerialization.class);    OSerializationThreadLocal.INSTANCE.get().remove(identityRecord);    Orient.instance().getProfiler().stopChrono("Object.toStream", "Serialize object to stream", timer);    return iRecord;  }
public static Type[] getGenericTypes(final Object iObject) {    if (iObject instanceof OTrackedMultiValue) {      final Class<?> cls = ((OTrackedMultiValue<?, ?>) iObject).getGenericClass();      if (cls != null)        return new Type[] { cls };    }    return OReflectionHelper.getGenericTypes(iObject.getClass());  }
@Override  public Object evaluateRecord(final OIdentifiable iRecord, ODocument iCurrentResult, final OSQLFilterCondition iCondition,      final Object iLeft, final Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {    return true;  }
public Object execute(final Map<Object, Object> iArgs) {    ODatabaseDocumentInternal db = getDatabase();    db.begin();    if (className == null && clusterName == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    OModifiableBoolean shutdownGraph = new OModifiableBoolean();    final boolean txAlreadyBegun = getDatabase().getTransaction().isActive();    try {      final Set<OIdentifiable> sourceRIDs = OSQLEngine.getInstance().parseRIDTarget(db, source, context, iArgs);      // CREATE EDGES      final List<ODocument> result = new ArrayList<ODocument>(sourceRIDs.size());      for (OIdentifiable from : sourceRIDs) {        final OVertex fromVertex = toVertex(from);        if (fromVertex == null)          continue;        final ORID oldVertex = fromVertex.getIdentity().copy();        final ORID newVertex = fromVertex.moveTo(className, clusterName);        final ODocument newVertexDoc = newVertex.getRecord();        if (fields != null) {          // EVALUATE FIELDS          for (final OPair<String, Object> f : fields) {            if (f.getValue() instanceof OSQLFunctionRuntime)              f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(newVertex.getRecord(), null, context));          }          OSQLHelper.bindParameters(newVertexDoc, fields, new OCommandParameters(iArgs), context);        }        if (merge != null)          newVertexDoc.merge(merge, true, false);        // SAVE CHANGES        newVertexDoc.save();        // PUT THE MOVE INTO THE RESULT        result            .add(new ODocument().setTrackingChanges(false).field("old", oldVertex, OType.LINK).field("new", newVertex, OType.LINK));        if (batch > 0 && result.size() % batch == 0) {            db.commit();            db.begin();        }      }        db.commit();      return result;    } finally {//      if (!txAlreadyBegun)//        db.commit();    }  }
@Override  public void serializeInByteBufferObject(String object, ByteBuffer buffer, Object... hints) {    int length = object.length();    buffer.putInt(length);    byte[] binaryData = new byte[length * 2];    char[] stringContent = new char[length];    object.getChars(0, length, stringContent, 0);    int counter = 0;    for (char character : stringContent) {      binaryData[counter] = (byte) character;      counter++;      binaryData[counter] = (byte) (character >>> 8);      counter++;    }    buffer.put(binaryData);  }
@Override  public String deserializeFromByteBufferObject(ByteBuffer buffer) {    int len = buffer.getInt();    final char[] chars = new char[len];    final byte[] binaryData = new byte[2 * len];    buffer.get(binaryData);    for (int i = 0; i < len; i++)      chars[i] = (char) ((0xFF & binaryData[i << 1]) | ((0xFF & binaryData[(i << 1) + 1]) << 8));    return new String(chars);  }  /**   * {@inheritDoc}   */  @Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer) {    return buffer.getInt() * 2 + OIntegerSerializer.INT_SIZE;  }  /**   * {@inheritDoc}   */  @Override  public String deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    int len = walChanges.getIntValue(buffer, offset);    final char[] chars = new char[len];    offset += OIntegerSerializer.INT_SIZE;    byte[] binaryData = walChanges.getBinaryValue(buffer, offset, 2 * len);    for (int i = 0; i < len; i++)      chars[i] = (char) ((0xFF & binaryData[i << 1]) | ((0xFF & binaryData[(i << 1) + 1]) << 8));    return new String(chars);  }  /**   * {@inheritDoc}   */  @Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return walChanges.getIntValue(buffer, offset) * 2 + OIntegerSerializer.INT_SIZE;  }}
public static void writeIdentifiable(OChannelBinary channel, OClientConnection connection, final OIdentifiable o)      throws IOException {    if (o == null)      channel.writeShort(OChannelBinaryProtocol.RECORD_NULL);    else if (o instanceof ORecordId) {      channel.writeShort(OChannelBinaryProtocol.RECORD_RID);      channel.writeRID((ORID) o);    } else {      writeRecord(channel, connection, o.getRecord());    }  }
public OStorageConfigurationImpl load(final OContextConfiguration configuration) throws OSerializationException {    lock.acquireWriteLock();    try {      initConfiguration(configuration);      final byte[] record = storage.readRecord(CONFIG_RID, null, false, false, null).getResult().buffer;      if (record == null)        throw new OStorageException("Cannot load database configuration. The database seems corrupted");      fromStream(record, 0, record.length, streamCharset);    } finally {      lock.releaseWriteLock();    }    return this;  }
public byte[] toStream(final int iNetworkVersion, Charset charset) throws OSerializationException {    lock.acquireReadLock();    try {      final StringBuilder buffer = new StringBuilder(8192);      write(buffer, CURRENT_VERSION);      write(buffer, name);      write(buffer, schemaRecordId);      write(buffer, dictionaryRecordId);      write(buffer, indexMgrRecordId);      write(buffer, localeLanguage);      write(buffer, localeCountry);      write(buffer, dateFormat);      write(buffer, dateTimeFormat);      write(buffer, timeZone.getID());      write(buffer, charset);      if (iNetworkVersion > 24)        write(buffer, conflictStrategy);      phySegmentToStream(buffer, fileTemplate);      write(buffer, clusters.size());      for (OStorageClusterConfiguration c : clusters) {        if (c == null) {          write(buffer, -1);          continue;        }        write(buffer, c.getId());        write(buffer, c.getName());        write(buffer, c.getDataSegmentId());        if (c instanceof OStoragePaginatedClusterConfiguration) {          write(buffer, "d");          final OStoragePaginatedClusterConfiguration paginatedClusterConfiguration = (OStoragePaginatedClusterConfiguration) c;          write(buffer, paginatedClusterConfiguration.useWal);          write(buffer, paginatedClusterConfiguration.recordOverflowGrowFactor);          write(buffer, paginatedClusterConfiguration.recordGrowFactor);          write(buffer, paginatedClusterConfiguration.compression);          if (iNetworkVersion >= 31)            write(buffer, paginatedClusterConfiguration.encryption);          if (iNetworkVersion > 24)            write(buffer, paginatedClusterConfiguration.conflictStrategy);          if (iNetworkVersion > 25)            write(buffer, paginatedClusterConfiguration.getStatus().name());          if (iNetworkVersion >= Integer.MAX_VALUE) {            write(buffer, paginatedClusterConfiguration.getBinaryVersion());          }        }      }      if (iNetworkVersion <= 25) {        // dataSegment array        write(buffer, 0);        // tx Segment File        write(buffer, "");        write(buffer, "");        write(buffer, 0);        // tx segment flags        write(buffer, false);        write(buffer, false);      }      synchronized (properties) {        write(buffer, properties.size());        for (OStorageEntryConfiguration e : properties)          entryToStream(buffer, e);      }      write(buffer, binaryFormatVersion);      write(buffer, clusterSelection);      write(buffer, getMinimumClusters());      if (iNetworkVersion > 24) {        write(buffer, recordSerializer);        write(buffer, recordSerializerVersion);        // WRITE CONFIGURATION        write(buffer, configuration.getContextSize());        for (String k : configuration.getContextKeys()) {          final OGlobalConfiguration cfg = OGlobalConfiguration.findByKey(k);          write(buffer, k);          if (cfg != null) {            write(buffer, cfg.isHidden() ? null : configuration.getValueAsString(cfg));          } else {            write(buffer, null);            OLogManager.instance().warn(this, "Storing configuration for property:'" + k + "' not existing in current version");          }        }      }      write(buffer, indexEngines.size());      for (IndexEngineData engineData : indexEngines.values()) {        write(buffer, engineData.getName());        write(buffer, engineData.getAlgorithm());        write(buffer, engineData.getIndexType() == null ? "" : engineData.getIndexType());        write(buffer, engineData.getValueSerializerId());        write(buffer, engineData.getKeySerializedId());        write(buffer, engineData.isAutomatic());        write(buffer, engineData.getDurableInNonTxMode());        write(buffer, engineData.getVersion());        write(buffer, engineData.isNullValuesSupport());        write(buffer, engineData.getKeySize());        write(buffer, engineData.getEncryption());        write(buffer, engineData.getEncryptionOptions());        if (engineData.getKeyTypes() != null) {          write(buffer, engineData.getKeyTypes().length);          for (OType type : engineData.getKeyTypes()) {            write(buffer, type.name());          }        } else {          write(buffer, 0);        }        if (engineData.getEngineProperties() == null) {          write(buffer, 0);        } else {          write(buffer, engineData.getEngineProperties().size());          for (Map.Entry<String, String> property : engineData.getEngineProperties().entrySet()) {            write(buffer, property.getKey());            write(buffer, property.getValue());          }        }        write(buffer, engineData.getApiVersion());        write(buffer, engineData.isMultivalue());      }      write(buffer, createdAtVersion);      write(buffer, pageSize);      write(buffer, freeListBoundary);      write(buffer, maxKeySize);      // PLAIN: ALLOCATE ENOUGH SPACE TO REUSE IT EVERY TIME      buffer.append("|");      return buffer.toString().getBytes(charset);    } finally {      lock.releaseReadLock();    }  }  public void create() throws IOException {    lock.acquireWriteLock();    try {      storage.createRecord(CONFIG_RID, new byte[] { 0, 0, 0, 0 }, 0, OBlob.RECORD_TYPE, null);    } finally {      lock.releaseWriteLock();    }  }
public static boolean contains(final int[] iArray, final int iToFind) {    if (iArray == null || iArray.length == 0)      return false;    for (int e : iArray)      if (e == iToFind)        return true;    return false;  }
public static <T> boolean contains(final T[] iArray, final T iToFind) {    if (iArray == null || iArray.length == 0)      return false;    for (T e : iArray)      if (e != null && e.equals(iToFind))        return true;    return false;  }
@Override  public <RET extends OCommandExecutor> RET parse(OCommandRequest iRequest) {    final OCommandRequestText textRequest = (OCommandRequestText) iRequest;    if (iRequest instanceof OSQLSynchQuery) {      request = (OSQLSynchQuery<ODocument>) iRequest;    } else if (iRequest instanceof OSQLAsynchQuery) {      request = (OSQLAsynchQuery<ODocument>) iRequest;    } else {      // BUILD A QUERY OBJECT FROM THE COMMAND REQUEST      request = new OSQLSynchQuery<ODocument>(textRequest.getText());      if (textRequest.getResultListener() != null) {        request.setResultListener(textRequest.getResultListener());      }    }    String queryText = textRequest.getText();    // please, do not look at this... refactor this ASAP with new executor structure    final InputStream is = new ByteArrayInputStream(queryText.getBytes());    OrientSql osql = null;    try {      ODatabaseDocumentInternal db = getDatabase();      if (db == null) {        osql = new OrientSql(is);      } else {        osql = new OrientSql(is, db.getStorage().getConfiguration().getCharset());      }    } catch (UnsupportedEncodingException e) {      OLogManager.instance().warn(this,          "Invalid charset for database " + getDatabase() + " " + getDatabase().getStorage().getConfiguration().getCharset());      osql = new OrientSql(is);    }    try {      OMatchStatement result = (OMatchStatement) osql.parse();      this.matchExpressions = result.matchExpressions;      this.notMatchExpressions = result.notMatchExpressions;      this.returnItems = result.returnItems;      this.returnAliases = result.returnAliases;      this.limit = result.limit;    } catch (ParseException e) {      OCommandSQLParsingException ex = new OCommandSQLParsingException(e, queryText);      OErrorCode.QUERY_PARSE_ERROR.throwException(ex.getMessage(), ex);    }    buildPatterns();    pattern.validate();    return (RET) this;  }
private void rebindFilters(Map<String, OWhereClause> aliasFilters) {    for (OMatchExpression expression : matchExpressions) {      OWhereClause newFilter = aliasFilters.get(expression.origin.getAlias());      expression.origin.setFilter(newFilter);      for (OMatchPathItem item : expression.items) {        newFilter = aliasFilters.get(item.filter.getAlias());        item.filter.setFilter(newFilter);      }    }  }
private void assignDefaultAliases(List<OMatchExpression> matchExpressions) {    int counter = 0;    for (OMatchExpression expression : matchExpressions) {      if (expression.origin.getAlias() == null) {        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));      }      for (OMatchPathItem item : expression.items) {        if (item.filter == null) {          item.filter = new OMatchFilter(-1);        }        if (item.filter.getAlias() == null) {          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));        }      }    }  }
@Override  public Object execute(Map<Object, Object> iArgs) {    this.context.setInputParameters(iArgs);    return execute(this.request, this.context, this.progressListener);  }
public Object execute(OSQLAsynchQuery<ODocument> request, OCommandContext context, OProgressListener progressListener) {    if (orderBy != null) {      throw new OCommandExecutionException("ORDER BY is not supported in MATCH on the legacy API");    }    if (groupBy != null) {      throw new OCommandExecutionException("GROUP BY is not supported in MATCH on the legacy API");    }    if (unwind != null) {      throw new OCommandExecutionException("UNWIND is not supported in MATCH on the legacy API");    }    if (skip != null) {      throw new OCommandExecutionException("SKIP is not supported in MATCH on the legacy API");    }    Map<Object, Object> iArgs = context.getInputParameters();    try {      Map<String, Long> estimatedRootEntries = estimateRootEntries(aliasClasses, aliasFilters, context);      if (estimatedRootEntries.values().contains(0l)) {        return new OBasicLegacyResultSet();// some aliases do not match on any classes      }      List<EdgeTraversal> sortedEdges = getTopologicalSortedSchedule(estimatedRootEntries, pattern);      MatchExecutionPlan executionPlan = new MatchExecutionPlan();      executionPlan.sortedEdges = sortedEdges;      calculateMatch(pattern, estimatedRootEntries, new MatchContext(), aliasClasses, aliasFilters, context, request,          executionPlan);      return getResult(request);    } finally {      if (request.getResultListener() != null) {        request.getResultListener().end();      }    }  }
private void updateScheduleStartingAt(PatternNode startNode, Set<PatternNode> visitedNodes, Set<PatternEdge> visitedEdges,      Map<String, Set<String>> remainingDependencies, List<EdgeTraversal> resultingSchedule) {    // OrientDB requires the schedule to contain all edges present in the query, which is a stronger condition    // than simply visiting all nodes in the query. Consider the following example query:    //     MATCH {    //         class: A,    //         as: foo    //     }.in() {    //         as: bar    //     }, {    //         class: B,    //         as: bar    //     }.out() {    //         as: foo    //     } RETURN $matches    // The schedule for the above query must have two edges, even though there are only two nodes and they can both    // be visited with the traversal of a single edge.    //    // To satisfy it, we obey the following for each non-optional node:    // - ignore edges to neighboring nodes which have unsatisfied dependencies;    // - for visited neighboring nodes, add their edge if it wasn't already present in the schedule, but do not    //   recurse into the neighboring node;    // - for unvisited neighboring nodes with satisfied dependencies, add their edge and recurse into them.    visitedNodes.add(startNode);    for (Set<String> dependencies : remainingDependencies.values()) {      dependencies.remove(startNode.alias);    }    Map<PatternEdge, Boolean> edges = new LinkedHashMap<PatternEdge, Boolean>();    for (PatternEdge outEdge : startNode.out) {      edges.put(outEdge, true);    }    for (PatternEdge inEdge : startNode.in) {      edges.put(inEdge, false);    }    for (Map.Entry<PatternEdge, Boolean> edgeData : edges.entrySet()) {      PatternEdge edge = edgeData.getKey();      boolean isOutbound = edgeData.getValue();      PatternNode neighboringNode = isOutbound ? edge.in : edge.out;      if (!remainingDependencies.get(neighboringNode.alias).isEmpty()) {        // Unsatisfied dependencies, ignore this neighboring node.        continue;      }      if (visitedNodes.contains(neighboringNode)) {        if (!visitedEdges.contains(edge)) {          // If we are executing in this block, we are in the following situation:          // - the startNode has not been visited yet;          // - it has a neighboringNode that has already been visited;          // - the edge between the startNode and the neighboringNode has not been scheduled yet.          //          // The isOutbound value shows us whether the edge is outbound from the point of view of the startNode.          // However, if there are edges to the startNode, we must visit the startNode from an already-visited          // neighbor, to preserve the validity of the traversal. Therefore, we negate the value of isOutbound          // to ensure that the edge is always scheduled in the direction from the already-visited neighbor          // toward the startNode. Notably, this is also the case when evaluating "optional" nodes -- we always          // visit the optional node from its non-optional and already-visited neighbor.          //          // The only exception to the above is when we have edges with "while" conditions. We are not allowed          // to flip their directionality, so we leave them as-is.          boolean traversalDirection;          if (startNode.optional || edge.item.isBidirectional()) {            traversalDirection = !isOutbound;          } else {            traversalDirection = isOutbound;          }          visitedEdges.add(edge);          resultingSchedule.add(new EdgeTraversal(edge, traversalDirection));        }      } else if (!startNode.optional) {        // If the neighboring node wasn't visited, we don't expand the optional node into it, hence the above check.        // Instead, we'll allow the neighboring node to add the edge we failed to visit, via the above block.        if (visitedEdges.contains(edge)) {          // Should never happen.          throw new AssertionError("The edge was visited, but the neighboring vertex was not: " + edge + " " + neighboringNode);        }        visitedEdges.add(edge);        resultingSchedule.add(new EdgeTraversal(edge, isOutbound));        updateScheduleStartingAt(neighboringNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);      }    }  }
private List<EdgeTraversal> getTopologicalSortedSchedule(Map<String, Long> estimatedRootEntries, Pattern pattern) {    List<EdgeTraversal> resultingSchedule = new ArrayList<EdgeTraversal>();    Map<String, Set<String>> remainingDependencies = getDependencies(pattern);    Set<PatternNode> visitedNodes = new HashSet<PatternNode>();    Set<PatternEdge> visitedEdges = new HashSet<PatternEdge>();    // Sort the possible root vertices in order of estimated size, since we want to start with a small vertex set.    List<OPair<Long, String>> rootWeights = new ArrayList<OPair<Long, String>>();    for (Map.Entry<String, Long> root : estimatedRootEntries.entrySet()) {      rootWeights.add(new OPair<Long, String>(root.getValue(), root.getKey()));    }    Collections.sort(rootWeights);    // Add the starting vertices, in the correct order, to an ordered set.    Set<String> remainingStarts = new LinkedHashSet<String>();    for (OPair<Long, String> item : rootWeights) {      remainingStarts.add(item.getValue());    }    // Add all the remaining aliases after all the suggested start points.    for (String alias : pattern.aliasToNode.keySet()) {      if (!remainingStarts.contains(alias)) {        remainingStarts.add(alias);      }    }    while (resultingSchedule.size() < pattern.numOfEdges) {      // Start a new depth-first pass, adding all nodes with satisfied dependencies.      // 1. Find a starting vertex for the depth-first pass.      PatternNode startingNode = null;      List<String> startsToRemove = new ArrayList<String>();      for (String currentAlias : remainingStarts) {        PatternNode currentNode = pattern.aliasToNode.get(currentAlias);        if (visitedNodes.contains(currentNode)) {          // If a previous traversal already visited this alias, remove it from further consideration.          startsToRemove.add(currentAlias);        } else if (remainingDependencies.get(currentAlias).isEmpty()) {          // If it hasn't been visited, and has all dependencies satisfied, visit it.          startsToRemove.add(currentAlias);          startingNode = currentNode;          break;        }      }      remainingStarts.removeAll(startsToRemove);      if (startingNode == null) {        // We didn't manage to find a valid root, and yet we haven't constructed a complete schedule.        // This means there must be a cycle in our dependency graph, or all dependency-free nodes are optional.        // Therefore, the query is invalid.        throw new OCommandExecutionException("This query contains MATCH conditions that cannot be evaluated, "            + "like an undefined alias or a circular dependency on a $matched condition.");      }      // 2. Having found a starting vertex, traverse its neighbors depth-first,      //    adding any non-visited ones with satisfied dependencies to our schedule.      updateScheduleStartingAt(startingNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);    }    if (resultingSchedule.size() != pattern.numOfEdges) {      throw new AssertionError("Incorrect number of edges: " + resultingSchedule.size() + " vs " + pattern.numOfEdges);    }    return resultingSchedule;  }
private boolean addSingleResult(OSQLAsynchQuery<ODocument> request, OBasicCommandContext ctx, ORecord record) {    if (((OBasicCommandContext) context).addToUniqueResult(record)) {      request.getResultListener().result(record);      long currentCount = ctx.getResultsProcessed().incrementAndGet();      long limitValue = limitFromProtocol;      if (limit != null) {        limitValue = limit.num.getValue().longValue();      }      if (limitValue > -1 && limitValue <= currentCount) {        return false;      }    }    return true;  }
private OSelectStatement buildSelectStatement(String className, OWhereClause oWhereClause) {    OSelectStatement stm = new OSelectStatement(-1);    stm.whereClause = oWhereClause;    stm.target = new OFromClause(-1);    stm.target.item = new OFromItem(-1);    stm.target.item.identifier = new OIdentifier(className);    return stm;  }
@Override  public boolean isEqual(final OBinaryField iField1, final OBinaryField iField2) {    final BytesContainer fieldValue1 = iField1.bytes;    final int offset1 = fieldValue1.offset;    final BytesContainer fieldValue2 = iField2.bytes;    final int offset2 = fieldValue2.offset;    try {      switch (iField1.type) {      case INTEGER: {        final int value1 = OVarIntSerializer.readAsInteger(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case DATE: {          final long value2 = (OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY);          return value1 == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {          return Integer.parseInt(readString(fieldValue2)) == value1;        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.intValue();        }        }        break;      }      case LONG: {        final long value1 = OVarIntSerializer.readAsLong(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case DATE: {          final long value2 = (OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY);          return value1 == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {          return Long.parseLong(readString(fieldValue2)) == value1;        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.longValue();        }        }        break;      }      case SHORT: {        final short value1 = OVarIntSerializer.readAsShort(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case DATE: {          final long value2 = (OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY);          return value1 == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {          return Short.parseShort(readString(fieldValue2)) == value1;        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.shortValue();        }        }        break;      }      case STRING: {        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return Integer.parseInt(readString(fieldValue1)) == value2;        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return Long.parseLong(readString(fieldValue1)) == value2;        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return Long.parseLong(readString(fieldValue1)) == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return Short.parseShort(readString(fieldValue1)) == value2;        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return Byte.parseByte(readString(fieldValue1)) == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return Float.parseFloat(readString(fieldValue1)) == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return Double.parseDouble(readString(fieldValue1)) == value2;        }        case STRING: {          final int len1 = OVarIntSerializer.readAsInteger(fieldValue1);          final int len2 = OVarIntSerializer.readAsInteger(fieldValue2);          if (len1 != len2)            return false;          final OCollate collate = (iField1.collate != null && !ODefaultCollate.NAME.equals(iField1.collate.getName())) ?              iField1.collate :              (iField2.collate != null && !ODefaultCollate.NAME.equals(iField2.collate.getName()) ? iField2.collate : null);          if (collate != null) {            final String str1 = (String) collate.transform(stringFromBytes(fieldValue1.bytes, fieldValue1.offset, len1));            final String str2 = (String) collate.transform(stringFromBytes(fieldValue2.bytes, fieldValue2.offset, len2));            return str1.equals(str2);          } else {            for (int i = 0; i < len1; ++i) {              if (fieldValue1.bytes[fieldValue1.offset + i] != fieldValue2.bytes[fieldValue2.offset + i])                return false;            }          }          return true;        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return new BigDecimal(readString(fieldValue1)).equals(value2);        }        case BOOLEAN: {          final boolean value2 = readByte(fieldValue2) == 1;          return Boolean.parseBoolean(readString(fieldValue1)) == value2;        }        }        break;      }      case DOUBLE: {        final long value1AsLong = readLong(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final double value1 = Double.longBitsToDouble(value1AsLong);          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final double value1 = Double.longBitsToDouble(value1AsLong);          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case SHORT: {          final double value1 = Double.longBitsToDouble(value1AsLong);          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case BYTE: {          final double value1 = Double.longBitsToDouble(value1AsLong);          final byte value2 = readByte(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final double value1 = Double.longBitsToDouble(value1AsLong);          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2AsLong = readLong(fieldValue2);          return value1AsLong == value2AsLong;        }        case STRING: {          final double value1 = Double.longBitsToDouble(value1AsLong);          return Double.parseDouble(readString(fieldValue2)) == value1;        }        case DECIMAL: {          final double value1 = Double.longBitsToDouble(value1AsLong);          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.doubleValue();        }        }        break;      }      case FLOAT: {        final int value1AsInt = readInteger(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final float value1 = Float.intBitsToFloat(value1AsInt);          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final float value1 = Float.intBitsToFloat(value1AsInt);          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case SHORT: {          final float value1 = Float.intBitsToFloat(value1AsInt);          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case BYTE: {          final float value1 = Float.intBitsToFloat(value1AsInt);          final byte value2 = readByte(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2AsInt = readInteger(fieldValue2);          return value1AsInt == value2AsInt;        }        case DOUBLE: {          final float value1 = Float.intBitsToFloat(value1AsInt);          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {          final float value1 = Float.intBitsToFloat(value1AsInt);          return Float.parseFloat(readString(fieldValue2)) == value1;        }        case DECIMAL: {          final float value1 = Float.intBitsToFloat(value1AsInt);          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.floatValue();        }        }        break;      }      case BYTE: {        final byte value1 = readByte(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {          final byte value2 = Byte.parseByte((readString(fieldValue2)));          return value1 == value2;        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.byteValue();        }        }        break;      }      case BOOLEAN: {        final boolean value1 = readByte(fieldValue1) == 1;        switch (iField2.type) {        case BOOLEAN: {          final boolean value2 = readByte(fieldValue2) == 1;          return value1 == value2;        }        case STRING: {          final String str = readString(fieldValue2);          return Boolean.parseBoolean(str) == value1;        }        }        break;      }      case DATE: {        final long value1 = OVarIntSerializer.readAsLong(fieldValue1) * MILLISEC_PER_DAY;        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          long value2 = OVarIntSerializer.readAsLong(fieldValue2);          value2 = convertDayToTimezone(ODateHelper.getDatabaseTimeZone(), TimeZone.getTimeZone("GMT"), value2);          return value1 == value2;        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return value1 == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.longValue();        }        }        break;      }      case DATETIME: {        final long value1 = OVarIntSerializer.readAsLong(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1 == value2;        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1 == value2;        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return value1 == value2;        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1 == value2;        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1 == value2;        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1 == value2;        }        case STRING: {          final String value2AsString = readString(fieldValue2);          if (OIOUtils.isLong(value2AsString)) {            final long value2 = Long.parseLong(value2AsString);            return value1 == value2;          }          final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().getIfDefined();          try {            final SimpleDateFormat dateFormat = db != null ?                db.getStorage().getConfiguration().getDateTimeFormatInstance() :                new SimpleDateFormat(OStorageConfiguration.DEFAULT_DATETIME_FORMAT);            final Date value2AsDate = dateFormat.parse(value2AsString);            final long value2 = value2AsDate.getTime();            return value1 == value2;          } catch (ParseException ignore) {            try {              final SimpleDateFormat dateFormat = db != null ?                  db.getStorage().getConfiguration().getDateFormatInstance() :                  new SimpleDateFormat(OStorageConfiguration.DEFAULT_DATE_FORMAT);              final Date value2AsDate = dateFormat.parse(value2AsString);              final long value2 = value2AsDate.getTime();              return value1 == value2;            } catch (ParseException ignored) {              return new Date(value1).toString().equals(value2AsString);            }          }        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1 == value2.longValue();        }        }        break;      }      case BINARY: {        switch (iField2.type) {        case BINARY: {          final int length1 = OVarIntSerializer.readAsInteger(fieldValue1);          final int length2 = OVarIntSerializer.readAsInteger(fieldValue2);          if (length1 != length2)            return false;          for (int i = 0; i < length1; ++i) {            if (fieldValue1.bytes[fieldValue1.offset + i] != fieldValue2.bytes[fieldValue2.offset + i])              return false;          }          return true;        }        }        break;      }      case LINK: {        switch (iField2.type) {        case LINK: {          final int clusterId1 = OVarIntSerializer.readAsInteger(fieldValue1);          final int clusterId2 = OVarIntSerializer.readAsInteger(fieldValue2);          if (clusterId1 != clusterId2)            return false;          final long clusterPos1 = OVarIntSerializer.readAsLong(fieldValue1);          final long clusterPos2 = OVarIntSerializer.readAsLong(fieldValue2);          if (clusterPos1 == clusterPos2)            return true;          break;        }        case STRING: {          return readOptimizedLink(fieldValue1, false).toString().equals(readString(fieldValue2));        }        }        break;      }      case DECIMAL: {        final BigDecimal value1 = ODecimalSerializer.INSTANCE.deserialize(fieldValue1.bytes, fieldValue1.offset);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1.equals(new BigDecimal(value2));        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1.equals(new BigDecimal(value2));        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1.equals(new BigDecimal(value2));        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1.equals(new BigDecimal(value2));        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1.equals(new BigDecimal(value2));        }        case STRING: {          return value1.toString().equals(readString(fieldValue2));        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1.equals(value2);        }        }        break;      }      }    } finally {      fieldValue1.offset = offset1;      fieldValue2.offset = offset2;    }    return false;  }
@Override  public int compare(final OBinaryField iField1, final OBinaryField iField2) {    final BytesContainer fieldValue1 = iField1.bytes;    final int offset1 = fieldValue1.offset;    final BytesContainer fieldValue2 = iField2.bytes;    final int offset2 = fieldValue2.offset;    try {      switch (iField1.type) {      case INTEGER: {        final int value1 = OVarIntSerializer.readAsInteger(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2 = readString(fieldValue2);          return Integer.toString(value1).compareTo(value2);        }        case DECIMAL: {          final int value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).intValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case LONG: {        final long value1 = OVarIntSerializer.readAsLong(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2 = readString(fieldValue2);          return Long.toString(value1).compareTo(value2);        }        case DECIMAL: {          final long value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).longValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case SHORT: {        final short value1 = OVarIntSerializer.readAsShort(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2 = readString(fieldValue2);          return Short.toString(value1).compareTo(value2);        }        case DECIMAL: {          final short value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).shortValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case STRING: {        final String value1 = readString(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1.compareTo(Integer.toString(value2));        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1.compareTo(Long.toString(value2));        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return value1.compareTo(Long.toString(value2));        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1.compareTo(Short.toString(value2));        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return value1.compareTo(Byte.toString(value2));        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1.compareTo(Float.toString(value2));        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1.compareTo(Double.toString(value2));        }        case STRING: {          final String value2 = readString(fieldValue2);          final OCollate collate = (iField1.collate != null && !ODefaultCollate.NAME.equals(iField1.collate.getName())) ?              iField1.collate :              (iField2.collate != null && !ODefaultCollate.NAME.equals(iField2.collate.getName()) ? iField2.collate : null);          if (collate != null) {            final String str1 = (String) collate.transform(value1);            final String str2 = (String) collate.transform(value2);            return str1.compareTo(str2);          }          return value1.compareTo(value2);        }        case BOOLEAN: {          final boolean value2 = readByte(fieldValue2) == 1;          return value1.compareTo(Boolean.toString(value2));        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return new BigDecimal(value1).compareTo(value2);        }        }        break;      }      case DOUBLE: {        final double value1 = Double.longBitsToDouble(readLong(fieldValue1));        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2 = readString(fieldValue2);          return Double.toString(value1).compareTo(value2);        }        case DECIMAL: {          final double value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).doubleValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case FLOAT: {        final float value1 = Float.intBitsToFloat(readInteger(fieldValue1));        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2 = readString(fieldValue2);          return Float.toString(value1).compareTo(value2);        }        case DECIMAL: {          final String value2 = readString(fieldValue2);          return Float.toString(value1).compareTo(value2);        }        }        break;      }      case BYTE: {        final byte value1 = readByte(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2 = readString(fieldValue2);          return Byte.toString(value1).compareTo(value2);        }        case DECIMAL: {          final byte value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).byteValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case BOOLEAN: {        final boolean value1 = readByte(fieldValue1) == 1;        switch (iField2.type) {        case BOOLEAN: {          final boolean value2 = readByte(fieldValue2) == 1;          return (value1 == value2) ? 0 : value1 ? 1 : -1;        }        case STRING: {          final boolean value2 = Boolean.parseBoolean(readString(fieldValue2));          return (value1 == value2) ? 0 : value1 ? 1 : -1;        }        }        break;      }      case DATETIME: {        final long value1 = OVarIntSerializer.readAsLong(fieldValue1);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2AsString = readString(fieldValue2);          if (OIOUtils.isLong(value2AsString)) {            final long value2 = Long.parseLong(value2AsString);            return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);          }          final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().getIfDefined();          try {            final SimpleDateFormat dateFormat = db != null ?                db.getStorage().getConfiguration().getDateTimeFormatInstance() :                new SimpleDateFormat(OStorageConfiguration.DEFAULT_DATETIME_FORMAT);            final Date value2AsDate = dateFormat.parse(value2AsString);            final long value2 = value2AsDate.getTime();            return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);          } catch (ParseException ignored) {            try {              final SimpleDateFormat dateFormat = db != null ?                  db.getStorage().getConfiguration().getDateFormatInstance() :                  new SimpleDateFormat(OStorageConfiguration.DEFAULT_DATE_FORMAT);              final Date value2AsDate = dateFormat.parse(value2AsString);              final long value2 = value2AsDate.getTime();              return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);            } catch (ParseException ignore) {              return new Date(value1).toString().compareTo(value2AsString);            }          }        }        case DECIMAL: {          final long value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).longValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case DATE: {        final long value1 = OVarIntSerializer.readAsLong(fieldValue1) * MILLISEC_PER_DAY;        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DATE: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2) * MILLISEC_PER_DAY;          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        case STRING: {          final String value2AsString = readString(fieldValue2);          if (OIOUtils.isLong(value2AsString)) {            final long value2 = Long.parseLong(value2AsString);            return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);          }          final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().getIfDefined();          try {            final SimpleDateFormat dateFormat = db != null ?                db.getStorage().getConfiguration().getDateFormatInstance() :                new SimpleDateFormat(OStorageConfiguration.DEFAULT_DATE_FORMAT);            final Date value2AsDate = dateFormat.parse(value2AsString);            long value2 = value2AsDate.getTime();            value2 = convertDayToTimezone(ODateHelper.getDatabaseTimeZone(), TimeZone.getTimeZone("GMT"), value2);            return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);          } catch (ParseException ignore) {            try {              final SimpleDateFormat dateFormat = db != null ?                  db.getStorage().getConfiguration().getDateFormatInstance() :                  new SimpleDateFormat(OStorageConfiguration.DEFAULT_DATETIME_FORMAT);              final Date value2AsDate = dateFormat.parse(value2AsString);              long value2 = value2AsDate.getTime();              value2 = convertDayToTimezone(ODateHelper.getDatabaseTimeZone(), TimeZone.getTimeZone("GMT"), value2);              return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);            } catch (ParseException ignored) {              return new Date(value1).toString().compareTo(value2AsString);            }          }        }        case DECIMAL: {          final long value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset).longValue();          return (value1 < value2) ? -1 : ((value1 == value2) ? 0 : 1);        }        }        break;      }      case BINARY: {        switch (iField2.type) {        case BINARY: {          final int length1 = OVarIntSerializer.readAsInteger(fieldValue1);          final int length2 = OVarIntSerializer.readAsInteger(fieldValue2);          final int max = Math.min(length1, length2);          for (int i = 0; i < max; ++i) {            final byte b1 = fieldValue1.bytes[fieldValue1.offset + i];            final byte b2 = fieldValue2.bytes[fieldValue2.offset + i];            if (b1 > b2)              return 1;            else if (b2 > b1)              return -1;          }          if (length1 > length2)            return 1;          else if (length2 > length1)            return -1;          // EQUALS          return 0;        }        }        break;      }      case LINK: {        switch (iField2.type) {        case LINK: {          final int clusterId1 = OVarIntSerializer.readAsInteger(fieldValue1);          final int clusterId2 = OVarIntSerializer.readAsInteger(fieldValue2);          if (clusterId1 > clusterId2)            return 1;          else if (clusterId1 < clusterId2)            return -1;          else {            final long clusterPos1 = OVarIntSerializer.readAsLong(fieldValue1);            final long clusterPos2 = OVarIntSerializer.readAsLong(fieldValue2);            if (clusterPos1 > clusterPos2)              return 1;            else if (clusterPos1 < clusterPos2)              return -1;            return 0;          }        }        case STRING: {          return readOptimizedLink(fieldValue1, false).compareTo(new ORecordId(readString(fieldValue2)));        }        }        break;      }      case DECIMAL: {        final BigDecimal value1 = ODecimalSerializer.INSTANCE.deserialize(fieldValue1.bytes, fieldValue1.offset);        switch (iField2.type) {        case INTEGER: {          final int value2 = OVarIntSerializer.readAsInteger(fieldValue2);          return value1.compareTo(new BigDecimal(value2));        }        case LONG:        case DATETIME: {          final long value2 = OVarIntSerializer.readAsLong(fieldValue2);          return value1.compareTo(new BigDecimal(value2));        }        case SHORT: {          final short value2 = OVarIntSerializer.readAsShort(fieldValue2);          return value1.compareTo(new BigDecimal(value2));        }        case FLOAT: {          final float value2 = Float.intBitsToFloat(readInteger(fieldValue2));          return value1.compareTo(new BigDecimal(value2));        }        case DOUBLE: {          final double value2 = Double.longBitsToDouble(readLong(fieldValue2));          return value1.compareTo(new BigDecimal(value2));        }        case STRING: {          final String value2 = readString(fieldValue2);          return value1.toString().compareTo(value2);        }        case DECIMAL: {          final BigDecimal value2 = ODecimalSerializer.INSTANCE.deserialize(fieldValue2.bytes, fieldValue2.offset);          return value1.compareTo(value2);        }        case BYTE: {          final byte value2 = readByte(fieldValue2);          return value1.compareTo(new BigDecimal(value2));        }        }        break;      }      }    } finally {      fieldValue1.offset = offset1;      fieldValue2.offset = offset2;    }    // NO COMPARE SUPPORTED, RETURN NON EQUALS    return 1;  }
public void addIndex(final OIndexDefinition indexDefinition) {    indexDefinitions.add(indexDefinition);    if (indexDefinition instanceof OIndexDefinitionMultiValue) {      if (multiValueDefinitionIndex == -1)        multiValueDefinitionIndex = indexDefinitions.size() - 1;      else        throw new OIndexException("Composite key cannot contain more than one collection item");    }    collate.addCollate(indexDefinition.getCollate());  }
public List<String> getFields() {    final List<String> fields = new LinkedList<String>();    for (final OIndexDefinition indexDefinition : indexDefinitions) {      fields.addAll(indexDefinition.getFields());    }    return Collections.unmodifiableList(fields);  }
public Object getDocumentValueToIndex(final ODocument iDocument) {    final List<OCompositeKey> compositeKeys = new ArrayList<OCompositeKey>(10);    final OCompositeKey firstKey = new OCompositeKey();    boolean containsCollection = false;    compositeKeys.add(firstKey);    for (final OIndexDefinition indexDefinition : indexDefinitions) {      final Object result = indexDefinition.getDocumentValueToIndex(iDocument);      if (result == null && isNullValuesIgnored())        return null;      //for empty collections we add null key in index      if (result instanceof Collection && ((Collection) result).isEmpty() && isNullValuesIgnored())        return null;      containsCollection = addKey(firstKey, compositeKeys, containsCollection, result);    }    if (!containsCollection)      return firstKey;    return compositeKeys;  }
public Object createValue(final Object... params) {    if (params.length == 1 && params[0] instanceof Collection)      return params[0];    return createValue(Arrays.asList(params));  }
public OType[] getTypes() {    final List<OType> types = new LinkedList<OType>();    for (final OIndexDefinition indexDefinition : indexDefinitions)      Collections.addAll(types, indexDefinition.getTypes());    return types.toArray(new OType[types.size()]);  }
@Override  public ODocument toStream() {    document.setInternalStatus(ORecordElement.STATUS.UNMARSHALLING);    try {      serializeToStream();    } finally {      document.setInternalStatus(ORecordElement.STATUS.LOADED);    }    return document;  }
public String toCreateIndexDDL(final String indexName, final String indexType, String engine) {    final StringBuilder ddl = new StringBuilder("create index ");    ddl.append(indexName).append(" on ").append(className).append(" ( ");    final Iterator<String> fieldIterator = getFieldsToIndex().iterator();    if (fieldIterator.hasNext()) {      ddl.append(fieldIterator.next());      while (fieldIterator.hasNext()) {        ddl.append(", ").append(fieldIterator.next());      }    }    ddl.append(" ) ").append(indexType).append(' ');    if (engine != null)      ddl.append(OCommandExecutorSQLCreateIndex.KEYWORD_ENGINE + " " + engine).append(' ');    if (multiValueDefinitionIndex == -1) {      boolean first = true;      for (OType oType : getTypes()) {        if (first)          first = false;        else          ddl.append(", ");        ddl.append(oType.name());      }    }    return ddl.toString();  }
public Object execute(final Map<Object, Object> iArgs) {    if (records.isEmpty())      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    int deleted = 0;    final ODatabaseDocumentInternal database = getDatabase();    for (String rec : records) {      try {        final ORecordId rid = new ORecordId(rec);        final OStorageOperationResult<Boolean> result = database.getStorage().deleteRecord(rid, -1, 0, null);        database.getLocalCache().deleteRecord(rid);        if (result.getResult())          deleted++;      } catch (Exception e) {        throw OException.wrapException(new OCommandExecutionException("Error on executing command"), e);      }    }    return deleted;  }
public OProjectionItem splitForAggregation(AggregateProjectionSplit aggregateSplit, OCommandContext ctx) {    if (isAggregate()) {      OProjectionItem result = new OProjectionItem(-1);      result.alias = getProjectionAlias();      result.expression = expression.splitForAggregation(aggregateSplit, ctx);      result.nestedProjection = nestedProjection;      return result;    } else {      return this;    }  }
public Object toObjectDetermineType(OResult source, OCommandContext ctx){    String className = getClassNameForDocument(ctx);    String type = getTypeForDocument(ctx);    if (className != null || (type != null && "d".equalsIgnoreCase(type))) {      return toDocument(source, ctx, className);    }    else{      return toMap(source, ctx);    }  }
public boolean isFieldChain() {    if (operationsChain == null) {      return true;    }    for (OPair<OSQLMethodRuntime, Object[]> pair : operationsChain) {      if (!pair.getKey().getMethod().getName().equals(OSQLMethodField.NAME)) {        return false;      }    }    return true;  }
public OCollate getCollate(Object doc) {    if (collate != null || operationsChain == null || !isFieldChain()) {      return collate;    }    if (!(doc instanceof OIdentifiable)) {      return null;    }    FieldChain chain = getFieldChain();    ODocument lastDoc = ((OIdentifiable) doc).getRecord();    for (int i = 0; i < chain.getItemCount() - 1; i++) {      if (lastDoc == null) {        return null;      }      Object nextDoc = lastDoc.field(chain.getItemName(i));      if (nextDoc == null || !(nextDoc instanceof OIdentifiable)) {        return null;      }      lastDoc = ((OIdentifiable) nextDoc).getRecord();    }    if (lastDoc == null) {      return null;    }    OClass schemaClass = lastDoc.getSchemaClass();    if (schemaClass == null) {      return null;    }    OProperty property = schemaClass.getProperty(chain.getItemName(chain.getItemCount() - 1));    if (property == null) {      return null;    }    return property.getCollate();  }
public String getStringValue() {    if (value == null) {      return null;    }    if (value.contains("`")) {      return value.replaceAll("\\\\`", "`");    }    return value;  }
private void setStringValue(String s) {    if (s == null) {      value = null;    } else if (s.contains("`")) {      value = s.replaceAll("`", "\\\\`");    } else {      value = s;    }  }
private int advanceProbe(int probe) {    probe ^= probe << 13; // xorshift    probe ^= probe >>> 17;    probe ^= probe << 5;    this.probe.get().set(probe);    return probe;  }
@Override  public void commit(final boolean force) {    checkTransaction();    if (txStartCounter < 0)      throw new OStorageException("Invalid value of tx counter");    if (force)      txStartCounter = 0;    else      txStartCounter--;    if (txStartCounter == 0) {      doCommit();    } else if (txStartCounter > 0)      OLogManager.instance().debug(this, "Nested transaction was closed but transaction itself was not committed.");    else      throw new OTransactionException("Transaction was committed more times than it is started.");  }
public Object execute(final Map<Object, Object> iArgs) {    if (clusterName == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocumentInternal database = getDatabase();    // CHECK IF ANY CLASS IS USING IT    final int clusterId = database.getStorage().getClusterIdByName(clusterName);    for (OClass iClass : database.getMetadata().getSchema().getClasses()) {      for (int i : iClass.getClusterIds()) {        if (i == clusterId)          // IN USE          return false;      }    }    // REMOVE CACHE OF COMMAND RESULTS IF ACTIVE    database.getMetadata().getCommandCache().invalidateResultsOfCluster(clusterName);    database.dropCluster(clusterId, true);    return true;  }
public static ODocument buildJsonFromFile(String filePath) throws IOException {    if (filePath == null) {      return null;    }    File jsonFile = new File(filePath);    if (!jsonFile.exists()) {      return null;    }    FileInputStream is = new FileInputStream(jsonFile);    BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName("UTF-8")));    ODocument json = new ODocument();    String jsonText = OFileManager.readAllTextFile(rd);    json.fromJSON(jsonText, "noMap");    return json;  }
public Object execute(final Map<Object, Object> iArgs) {    if (rid == null && query == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    if (!returning.equalsIgnoreCase("COUNT"))      allDeletedRecords = new ArrayList<ORecord>();    txAlreadyBegun = getDatabase().getTransaction().isActive();    if (rid != null) {      // REMOVE PUNCTUAL RID      OGraphCommandExecutorSQLFactory.runInConfiguredTxMode(new OGraphCommandExecutorSQLFactory.GraphCallBack<Object>() {        @Override        public Object call(OrientBaseGraph graph) {          final OrientVertex v = graph.getVertex(rid);          if (v != null) {            v.remove();            removed = 1;          }          return null;        }      });      // CLOSE PENDING TX      end();    } else if (query != null) {      // TARGET IS A CLASS + OPTIONAL CONDITION      OGraphCommandExecutorSQLFactory.runInConfiguredTxMode(new OGraphCommandExecutorSQLFactory.GraphCallBack<OrientGraph>() {        @Override        public OrientGraph call(final OrientBaseGraph iGraph) {          // TARGET IS A CLASS + OPTIONAL CONDITION          currentGraph.set(iGraph);          query.setContext(getContext());          query.execute(iArgs);          return null;        }      });    } else      throw new OCommandExecutionException("Invalid target");    if (returning.equalsIgnoreCase("COUNT"))      // RETURNS ONLY THE COUNT      return removed;    else      // RETURNS ALL THE DELETED RECORDS      return allDeletedRecords;  }
public boolean result(final Object iRecord) {    final OIdentifiable id = (OIdentifiable) iRecord;    if (id.getIdentity().isValid()) {      final ODocument record = id.getRecord();      final OrientBaseGraph g = currentGraph.get();      final OrientVertex v = g.getVertex(record);      if (v != null) {        v.remove();        if (!txAlreadyBegun && batch > 0 && removed % batch == 0) {          if (g instanceof OrientGraph) {            g.commit();            ((OrientGraph) g).begin();          }        }        if (returning.equalsIgnoreCase("BEFORE"))          allDeletedRecords.add(record);        removed++;      }    }    return true;  }
protected String parseReturn() throws OCommandSQLParsingException {    final String returning = parserNextWord(true);    if (!returning.equalsIgnoreCase("COUNT") && !returning.equalsIgnoreCase("BEFORE"))      throwParsingException("Invalid " + KEYWORD_RETURN + " value set to '" + returning          + "' but it should be COUNT (default), BEFORE. Example: " + KEYWORD_RETURN + " BEFORE");    return returning;  }
public boolean checkPassword(final String iPassword, final String iHash) {    if (iHash.startsWith(HASH_ALGORITHM_PREFIX)) {      final String s = iHash.substring(HASH_ALGORITHM_PREFIX.length());      return createSHA256(iPassword).equals(s);    } else if (iHash.startsWith(PBKDF2_ALGORITHM_PREFIX)) {      final String s = iHash.substring(PBKDF2_ALGORITHM_PREFIX.length());      return checkPasswordWithSalt(iPassword, s, PBKDF2_ALGORITHM);    } else if (iHash.startsWith(PBKDF2_SHA256_ALGORITHM_PREFIX)) {      final String s = iHash.substring(PBKDF2_SHA256_ALGORITHM_PREFIX.length());      return checkPasswordWithSalt(iPassword, s, PBKDF2_SHA256_ALGORITHM);    }    // Do not compare raw strings against each other, to avoid timing attacks.    // Instead, hash them both with a cryptographic hash function and    // compare their hashes with a constant-time comparison method.    return MessageDigest.isEqual(digestSHA256(iPassword), digestSHA256(iHash));  }
public String createHash(final String iInput, final String iAlgorithm, final boolean iIncludeAlgorithm) {    if (iInput == null)      throw new IllegalArgumentException("Input string is null");    if (iAlgorithm == null)      throw new IllegalArgumentException("Algorithm is null");    final StringBuilder buffer = new StringBuilder(128);    final String algorithm = validateAlgorithm(iAlgorithm);    if (iIncludeAlgorithm) {      buffer.append('{');      buffer.append(algorithm);      buffer.append('}');    }    final String transformed;    if (HASH_ALGORITHM.equalsIgnoreCase(algorithm)) {      transformed = createSHA256(iInput);    } else if (PBKDF2_ALGORITHM.equalsIgnoreCase(algorithm)) {      transformed = createHashWithSalt(iInput, OGlobalConfiguration.SECURITY_USER_PASSWORD_SALT_ITERATIONS.getValueAsInteger(),          algorithm);    } else if (PBKDF2_SHA256_ALGORITHM.equalsIgnoreCase(algorithm)) {      transformed = createHashWithSalt(iInput, OGlobalConfiguration.SECURITY_USER_PASSWORD_SALT_ITERATIONS.getValueAsInteger(),          algorithm);    } else      throw new IllegalArgumentException("Algorithm '" + algorithm + "' is not supported");    buffer.append(transformed);    return buffer.toString();  }
private static boolean isAlgorithmSupported(final String algorithm) {    // Java 7 specific checks.    if (Runtime.class.getPackage() != null && Runtime.class.getPackage().getImplementationVersion() != null) {      if (Runtime.class.getPackage().getImplementationVersion().startsWith("1.7")) {        // Java 7 does not support the PBKDF2_SHA256_ALGORITHM.        if (algorithm != null && algorithm.equals(PBKDF2_SHA256_ALGORITHM)) {          return false;        }      }    }    return true;  }
public OIndexInternal<?> create(final OIndexDefinition indexDefinition, final String clusterIndexName,      final Set<String> clustersToIndex, boolean rebuild, final OProgressListener progressListener,      final OBinarySerializer valueSerializer) {    acquireExclusiveLock();    try {      configuration = indexConfigurationInstance(new ODocument().setTrackingChanges(false));      this.indexDefinition = indexDefinition;      if (clustersToIndex != null)        this.clustersToIndex = new HashSet<>(clustersToIndex);      else        this.clustersToIndex = new HashSet<>();      // do not remove this, it is needed to remove index garbage if such one exists      try {        if (apiVersion == 0) {          removeValuesContainer();        }      } catch (Exception e) {        OLogManager.instance().error(this, "Error during deletion of index '%s'", e, name);      }      indexId = storage.addIndexEngine(name, algorithm, type, indexDefinition, valueSerializer, isAutomatic(), true, version, 1,          this instanceof OIndexMultiValues, getEngineProperties(), clustersToIndex, metadata);      apiVersion = OAbstractPaginatedStorage.extractEngineAPIVersion(indexId);      assert indexId >= 0;      assert apiVersion >= 0;      onIndexEngineChange(indexId);      if (rebuild)        fillIndex(progressListener, false);      updateConfiguration();    } catch (Exception e) {      OLogManager.instance().error(this, "Exception during index '%s' creation", e, name);      while (true)        try {          if (indexId >= 0)            storage.deleteIndexEngine(indexId);          break;        } catch (OInvalidIndexEngineIdException ignore) {          doReloadIndexEngine();        } catch (Exception ex) {          OLogManager.instance().error(this, "Exception during index '%s' deletion", ex, name);        }      if (e instanceof OIndexException)        throw (OIndexException) e;      throw OException.wrapException(new OIndexException("Cannot create the index '" + name + "'"), e);    } finally {      releaseExclusiveLock();    }    return this;  }
public long rebuild(final OProgressListener iProgressListener) {    long documentIndexed;    final boolean intentInstalled = getDatabase().declareIntent(new OIntentMassiveInsert());    acquireExclusiveLock();    try {      // DO NOT REORDER 2 assignments bellow      // see #getRebuildVersion()      rebuilding = true;      rebuildVersion.incrementAndGet();      try {        if (indexId >= 0) {          storage.deleteIndexEngine(indexId);        }      } catch (Exception e) {        OLogManager.instance().error(this, "Error during index '%s' delete", e, name);      }      removeValuesContainer();      indexId = storage          .addIndexEngine(name, algorithm, type, indexDefinition, determineValueSerializer(), isAutomatic(), true, version, 1,              this instanceof OIndexMultiValues, getEngineProperties(), clustersToIndex, metadata);      apiVersion = OAbstractPaginatedStorage.extractEngineAPIVersion(indexId);      onIndexEngineChange(indexId);    } catch (Exception e) {      try {        if (indexId >= 0)          storage.clearIndex(indexId);      } catch (Exception e2) {        OLogManager.instance().error(this, "Error during index rebuild", e2);        // IGNORE EXCEPTION: IF THE REBUILD WAS LAUNCHED IN CASE OF RID INVALID CLEAR ALWAYS GOES IN ERROR      }      rebuilding = false;      throw OException.wrapException(new OIndexException("Error on rebuilding the index for clusters: " + clustersToIndex), e);    } finally {      releaseExclusiveLock();    }    acquireSharedLock();    try {      documentIndexed = fillIndex(iProgressListener, true);    } catch (final Exception e) {      OLogManager.instance().error(this, "Error during index rebuild", e);      try {        if (indexId >= 0)          storage.clearIndex(indexId);      } catch (Exception e2) {        OLogManager.instance().error(this, "Error during index rebuild", e2);        // IGNORE EXCEPTION: IF THE REBUILD WAS LAUNCHED IN CASE OF RID INVALID CLEAR ALWAYS GOES IN ERROR      }      throw OException.wrapException(new OIndexException("Error on rebuilding the index for clusters: " + clustersToIndex), e);    } finally {      rebuilding = false;      if (intentInstalled)        getDatabase().declareIntent(null);      releaseSharedLock();    }    return documentIndexed;  }
public Query order(final String props, final String dir) {    this.orderBy = props;    this.orderByDir = dir;    return this;  }
@Override  public Iterable<Vertex> vertices() {    if (limit == 0)      return Collections.emptyList();    OTransaction transaction = ((OrientBaseGraph) graph).getRawGraph().getTransaction();    if (transaction.isActive() && transaction.getEntryCount() > 0 || hasCustomPredicate()) {      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL      // SUPPORTED USED THE BASIC IMPL      String[] classes = allSubClassesLabels();      return new OrientGraphQueryIterable<Vertex>(true, classes);    }    final StringBuilder text = new StringBuilder(512);    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES    text.append(QUERY_SELECT_FROM);    if (((OrientBaseGraph) graph).isUseClassForVertexLabel() && labels != null && labels.length > 0) {      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY      if (labels.length == 1)        // USE THE CLASS NAME        text.append(OrientBaseGraph.encodeClassName(labels[0]));      else {        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY        String[] classes = allSubClassesLabels();        return new OrientGraphQueryIterable<Vertex>(true, classes);      }    } else      text.append(OrientVertexType.CLASS_NAME);    final List<Object> queryParams = manageFilters(text);    if (!((OrientBaseGraph) graph).isUseClassForVertexLabel())      manageLabels(queryParams.size() > 0, text);    if (orderBy.length() > 1) {      text.append(ORDERBY);      text.append(orderBy);      text.append(" ").append(orderByDir).append(" ");    }    if (skip > 0 && skip < Integer.MAX_VALUE) {      text.append(SKIP);      text.append(skip);    }    if (limit > 0 && limit < Integer.MAX_VALUE) {      text.append(LIMIT);      text.append(limit);    }    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());    if (fetchPlan != null)      query.setFetchPlan(fetchPlan);    return new OrientElementIterable<Vertex>(((OrientBaseGraph) graph),        ((OrientBaseGraph) graph).getRawGraph().query(query, queryParams.toArray()));  }
@Override  public Iterable<Edge> edges() {    if (limit == 0)      return Collections.emptyList();    if (((OrientBaseGraph) graph).getRawGraph().getTransaction().isActive() || hasCustomPredicate())      // INSIDE TRANSACTION QUERY DOESN'T SEE IN MEMORY CHANGES, UNTIL      // SUPPORTED USED THE BASIC IMPL      return new OrientGraphQueryIterable<Edge>(false, labels);    if (((OrientBaseGraph) graph).isUseLightweightEdges())      return new OrientGraphQueryIterable<Edge>(false, labels);    final StringBuilder text = new StringBuilder(512);    // GO DIRECTLY AGAINST E CLASS AND SUB-CLASSES    text.append(QUERY_SELECT_FROM);    if (((OrientBaseGraph) graph).isUseClassForEdgeLabel() && labels != null && labels.length > 0) {      // FILTER PER CLASS SAVING CHECKING OF LABEL PROPERTY      if (labels.length == 1)        // USE THE CLASS NAME        text.append(OrientBaseGraph.encodeClassName(labels[0]));      else {        // MULTIPLE CLASSES NOT SUPPORTED DIRECTLY: CREATE A SUB-QUERY        return new OrientGraphQueryIterable<Edge>(false, labels);      }    } else      text.append(OrientEdgeType.CLASS_NAME);    List<Object> queryParams = manageFilters(text);    if (!((OrientBaseGraph) graph).isUseClassForEdgeLabel())      manageLabels(queryParams.size() > 0, text);    final OSQLSynchQuery<OIdentifiable> query = new OSQLSynchQuery<OIdentifiable>(text.toString());    if (fetchPlan != null)      query.setFetchPlan(fetchPlan);    if (limit > 0 && limit < Integer.MAX_VALUE)      query.setLimit(limit);    return new OrientElementIterable<Edge>(((OrientBaseGraph) graph),        ((OrientBaseGraph) graph).getRawGraph().query(query, queryParams.toArray()));  }
@Override  public int[] getPartitionKey() {    if (tasks.size() == 1)      // ONE TASK, USE THE INNER TASK'S PARTITION KEY      return tasks.get(0).getPartitionKey();    // MULTIPLE PARTITIONS    final int[] partitions = new int[tasks.size()];    for (int i = 0; i < tasks.size(); ++i) {      final OAbstractRecordReplicatedTask task = tasks.get(i);      partitions[i] = task.getPartitionKey()[0];    }    return partitions;  }
@Override  public long getDistributedTimeout() {    final long to = OGlobalConfiguration.DISTRIBUTED_CRUD_TASK_SYNCH_TIMEOUT.getValueAsLong();    return to + ((to / 2) * tasks.size());  }
public String toCreateIndexDDL(final String indexName, final String indexType, final String engine) {    final StringBuilder ddl = new StringBuilder("create index `");    ddl.append(indexName).append("` ").append(indexType).append(' ');    if (keyTypes != null && keyTypes.length > 0) {      ddl.append(keyTypes[0].toString());      for (int i = 1; i < keyTypes.length; i++) {        ddl.append(", ").append(keyTypes[i].toString());      }    }    return ddl.toString();  }
public byte[] toStream(final int iNetworkVersion, final Charset charset) throws OSerializationException {    lock.acquireReadLock();    try {      final StringBuilder buffer = new StringBuilder(8192);      write(buffer, CURRENT_VERSION);      write(buffer, null);      write(buffer, getSchemaRecordId());      write(buffer, "");      write(buffer, getIndexMgrRecordId());      write(buffer, getLocaleLanguage());      write(buffer, getLocaleCountry());      write(buffer, getDateFormat());      write(buffer, getDateFormat());      final TimeZone timeZone = getTimeZone();      assert timeZone != null;      write(buffer, timeZone);      write(buffer, charset);      if (iNetworkVersion > 24) {        write(buffer, getConflictStrategy());      }      phySegmentToStream(buffer, new OStorageSegmentConfiguration());      final List<OStorageClusterConfiguration> clusters = getClusters();      write(buffer, clusters.size());      for (final OStorageClusterConfiguration c : clusters) {        if (c == null) {          write(buffer, -1);          continue;        }        write(buffer, c.getId());        write(buffer, c.getName());        write(buffer, c.getDataSegmentId());        if (c instanceof OStoragePaginatedClusterConfiguration) {          write(buffer, "d");          final OStoragePaginatedClusterConfiguration paginatedClusterConfiguration = (OStoragePaginatedClusterConfiguration) c;          write(buffer, paginatedClusterConfiguration.useWal);          write(buffer, paginatedClusterConfiguration.recordOverflowGrowFactor);          write(buffer, paginatedClusterConfiguration.recordGrowFactor);          write(buffer, paginatedClusterConfiguration.compression);          if (iNetworkVersion >= 31) {            write(buffer, paginatedClusterConfiguration.encryption);          }          if (iNetworkVersion > 24) {            write(buffer, paginatedClusterConfiguration.conflictStrategy);          }          if (iNetworkVersion > 25) {            write(buffer, paginatedClusterConfiguration.getStatus().name());          }          if (iNetworkVersion >= Integer.MAX_VALUE) {            write(buffer, paginatedClusterConfiguration.getBinaryVersion());          }        }      }      if (iNetworkVersion <= 25) {        // dataSegment array        write(buffer, 0);        // tx Segment File        write(buffer, "");        write(buffer, "");        write(buffer, 0);        // tx segment flags        write(buffer, false);        write(buffer, false);      }      final List<OStorageEntryConfiguration> properties = getProperties();      write(buffer, properties.size());      for (final OStorageEntryConfiguration e : properties) {        entryToStream(buffer, e);      }      write(buffer, getBinaryFormatVersion());      write(buffer, getClusterSelection());      write(buffer, getMinimumClusters());      if (iNetworkVersion > 24) {        write(buffer, getRecordSerializer());        write(buffer, getRecordSerializerVersion());        // WRITE CONFIGURATION        write(buffer, configuration.getContextSize());        for (final String k : configuration.getContextKeys()) {          final OGlobalConfiguration cfg = OGlobalConfiguration.findByKey(k);          write(buffer, k);          if (cfg != null) {            write(buffer, cfg.isHidden() ? null : configuration.getValueAsString(cfg));          } else {            write(buffer, null);            OLogManager.instance().warn(this, "Storing configuration for property:'" + k + "' not existing in current version");          }        }      }      final List<IndexEngineData> engines = loadIndexEngines();      write(buffer, engines.size());      for (final IndexEngineData engineData : engines) {        write(buffer, engineData.getName());        write(buffer, engineData.getAlgorithm());        write(buffer, engineData.getIndexType() == null ? "" : engineData.getIndexType());        write(buffer, engineData.getValueSerializerId());        write(buffer, engineData.getKeySerializedId());        write(buffer, engineData.isAutomatic());        write(buffer, engineData.getDurableInNonTxMode());        write(buffer, engineData.getVersion());        write(buffer, engineData.isNullValuesSupport());        write(buffer, engineData.getKeySize());        write(buffer, engineData.getEncryption());        write(buffer, engineData.getEncryptionOptions());        if (engineData.getKeyTypes() != null) {          write(buffer, engineData.getKeyTypes().length);          for (final OType type : engineData.getKeyTypes()) {            write(buffer, type.name());          }        } else {          write(buffer, 0);        }        if (engineData.getEngineProperties() == null) {          write(buffer, 0);        } else {          write(buffer, engineData.getEngineProperties().size());          for (final Map.Entry<String, String> property : engineData.getEngineProperties().entrySet()) {            write(buffer, property.getKey());            write(buffer, property.getValue());          }        }        write(buffer, engineData.getApiVersion());        write(buffer, engineData.isMultivalue());      }      write(buffer, getCreatedAtVersion());      write(buffer, getPageSize());      write(buffer, getFreeListBoundary());      write(buffer, getMaxKeySize());      // PLAIN: ALLOCATE ENOUGH SPACE TO REUSE IT EVERY TIME      buffer.append("|");      return buffer.toString().getBytes(charset);    } finally {      lock.releaseReadLock();    }  }
public Features getFeatures() {    makeActive();    if (!featuresInitialized) {      FEATURES.supportsDuplicateEdges = true;      FEATURES.supportsSelfLoops = true;      FEATURES.isPersistent = true;      FEATURES.supportsVertexIteration = true;      FEATURES.supportsVertexIndex = true;      FEATURES.ignoresSuppliedIds = true;      FEATURES.supportsTransactions = true;      FEATURES.supportsVertexKeyIndex = true;      FEATURES.supportsKeyIndices = true;      FEATURES.isWrapper = false;      FEATURES.supportsIndices = true;      FEATURES.supportsVertexProperties = true;      FEATURES.supportsEdgeProperties = true;      // For more information on supported types, please see:      // http://code.google.com/p/orient/wiki/Types      FEATURES.supportsSerializableObjectProperty = true;      FEATURES.supportsBooleanProperty = true;      FEATURES.supportsDoubleProperty = true;      FEATURES.supportsFloatProperty = true;      FEATURES.supportsIntegerProperty = true;      FEATURES.supportsPrimitiveArrayProperty = true;      FEATURES.supportsUniformListProperty = true;      FEATURES.supportsMixedListProperty = true;      FEATURES.supportsLongProperty = true;      FEATURES.supportsMapProperty = true;      FEATURES.supportsStringProperty = true;      FEATURES.supportsThreadedTransactions = false;      FEATURES.supportsThreadIsolatedTransactions = false;      // DYNAMIC FEATURES BASED ON CONFIGURATION      FEATURES.supportsEdgeIndex = !isUseLightweightEdges();      FEATURES.supportsEdgeKeyIndex = !isUseLightweightEdges();      FEATURES.supportsEdgeIteration = !isUseLightweightEdges();      FEATURES.supportsEdgeRetrieval = !isUseLightweightEdges();      featuresInitialized = true;    }    return FEATURES;  }
public void removeEdgeInternal(final OrientEdge edge) {    // OUT VERTEX    final OIdentifiable inVertexEdge = edge.vIn != null ? edge.vIn : edge.rawElement;    final String edgeClassName = OrientBaseGraph.encodeClassName(edge.getLabel());    final boolean useVertexFieldsForEdgeLabels = settings.isUseVertexFieldsForEdgeLabels();    final OIdentifiable outVertex = edge.getOutVertex();    ODocument outVertexRecord = null;    boolean outVertexChanged = false;    if (outVertex != null) {      outVertexRecord = outVertex.getRecord();      if (outVertexRecord != null) {        final String outFieldName = OrientVertex.getConnectionFieldName(Direction.OUT, edgeClassName, useVertexFieldsForEdgeLabels);        outVertexChanged = edge.dropEdgeFromVertex(inVertexEdge, outVertexRecord, outFieldName,            outVertexRecord.field(outFieldName));      }    }    // IN VERTEX    final OIdentifiable outVertexEdge = edge.vOut != null ? edge.vOut : edge.rawElement;    final OIdentifiable inVertex = edge.getInVertex();    ODocument inVertexRecord = null;    boolean inVertexChanged = false;    if (inVertex != null) {      inVertexRecord = inVertex.getRecord();      if (inVertexRecord != null) {        final String inFieldName = OrientVertex.getConnectionFieldName(Direction.IN, edgeClassName, useVertexFieldsForEdgeLabels);        inVertexChanged = edge.dropEdgeFromVertex(outVertexEdge, inVertexRecord, inFieldName, inVertexRecord.field(inFieldName));      }    }    if (outVertexChanged)      outVertexRecord.save();    if (inVertexChanged)      inVertexRecord.save();    if (edge.rawElement != null)      // NON-LIGHTWEIGHT EDGE      edge.removeRecord();  }
private Object execute(OCommandContext ctx) {    if (destField == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocumentInternal database = getDatabase();    if (!(database.getDatabaseOwner() instanceof ODatabaseDocument))      throw new OCommandSQLParsingException(          "This command supports only the database type ODatabaseDocumentTx and type '" + database.getClass() + "' was found");    final ODatabaseDocument db = (ODatabaseDocument) database.getDatabaseOwner();    final OClass sourceClass = database.getMetadata().getSchema().getClass(getSourceClass().getStringValue());    if (sourceClass == null)      throw new OCommandExecutionException("Source class '" + getSourceClass().getStringValue() + "' not found");    final OClass destClass = database.getMetadata().getSchema().getClass(getDestClass().getStringValue());    if (destClass == null)      throw new OCommandExecutionException("Destination class '" + getDestClass().getStringValue() + "' not found");    Object value;    String cmd = "select from ";    if (!ODocumentHelper.ATTRIBUTE_RID.equals(destField)) {      cmd = "select from " + getDestClass() + " where " + destField + " = ";    }    List<ODocument> result;    ODocument target;    Object oldValue;    long total = 0;    String linkName = name == null ? sourceField.getStringValue() : name.getStringValue();    boolean multipleRelationship;    OType linkType = OType.valueOf(type.getStringValue().toUpperCase(Locale.ENGLISH));    if (linkType != null)      // DETERMINE BASED ON FORCED TYPE      multipleRelationship = linkType == OType.LINKSET || linkType == OType.LINKLIST;    else      multipleRelationship = false;    long totRecords = db.countClass(sourceClass.getName());    long currRecord = 0;    database.declareIntent(new OIntentMassiveInsert());    try {      // BROWSE ALL THE RECORDS OF THE SOURCE CLASS      for (ODocument doc : db.browseClass(sourceClass.getName())) {        if (breakExec) {          break;        }        value = doc.getProperty(sourceField.getStringValue());        if (value != null) {          if (value instanceof ODocument || value instanceof ORID) {            // ALREADY CONVERTED          } else if (value instanceof Collection<?>) {            // TODO          } else {            // SEARCH THE DESTINATION RECORD            target = null;            if (!ODocumentHelper.ATTRIBUTE_RID.equals(destField) && value instanceof String)              if (((String) value).length() == 0)                value = null;              else                value = "'" + value + "'";            OResultSet rs = database.query(cmd + value);            result = toList(rs);            rs.close();            if (result == null || result.size() == 0)              value = null;            else if (result.size() > 1)              throw new OCommandExecutionException(                  "Cannot create link because multiple records was found in class '" + destClass.getName() + "' with value " + value                      + " in field '" + destField + "'");            else {              target = result.get(0);              value = target;            }            if (target != null && inverse) {              // INVERSE RELATIONSHIP              oldValue = target.getProperty(linkName);              if (oldValue != null) {                if (!multipleRelationship)                  multipleRelationship = true;                Collection<ODocument> coll;                if (oldValue instanceof Collection) {                  // ADD IT IN THE EXISTENT COLLECTION                  coll = (Collection<ODocument>) oldValue;                  target.setDirty();                } else {                  // CREATE A NEW COLLECTION FOR BOTH                  coll = new ArrayList<ODocument>(2);                  target.setProperty(linkName, coll);                  coll.add((ODocument) oldValue);                }                coll.add(doc);              } else {                if (linkType != null)                  if (linkType == OType.LINKSET) {                    value = new ORecordLazySet(target);                    ((Set<OIdentifiable>) value).add(doc);                  } else if (linkType == OType.LINKLIST) {                    value = new ORecordLazyList(target);                    ((ORecordLazyList) value).add(doc);                  } else                    // IGNORE THE TYPE, SET IT AS LINK                    value = doc;                else                  value = doc;                target.setProperty(linkName, value);              }              target.save();            } else {              // SET THE REFERENCE              doc.setProperty(linkName, value);              doc.save();            }            total++;          }        }      }      if (total > 0) {        if (inverse) {          // REMOVE THE OLD PROPERTY IF ANY          OProperty prop = destClass.getProperty(linkName);          if (prop != null)            destClass.dropProperty(linkName);          if (linkType == null)            linkType = multipleRelationship ? OType.LINKSET : OType.LINK;          // CREATE THE PROPERTY          destClass.createProperty(linkName, linkType, sourceClass);        } else {          // REMOVE THE OLD PROPERTY IF ANY          OProperty prop = sourceClass.getProperty(linkName);          if (prop != null)            sourceClass.dropProperty(linkName);          // CREATE THE PROPERTY          sourceClass.createProperty(linkName, OType.LINK, destClass);        }      }    } catch (Exception e) {      throw OException.wrapException(new OCommandExecutionException("Error on creation of links"), e);    } finally {      database.declareIntent(null);    }    return total;  }
private static boolean checkChangesFilledUpTo(final FileChanges changesContainer, final long pageIndex) {    if (changesContainer == null) {      return true;    } else if (changesContainer.isNew || changesContainer.maxNewPageIndex > -2) {      return pageIndex < changesContainer.maxNewPageIndex + 1;    } else      return !changesContainer.truncate;  }
@Override  public OClass truncateCluster(String clusterName) {    final ODatabaseDocumentInternal database = getDatabase();    database.checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_DELETE, name);    acquireSchemaReadLock();    try {      final String cmd = String.format("truncate cluster %s", clusterName);      database.command(cmd).close();    } finally {      releaseSchemaReadLock();    }    return this;  }
protected boolean parseTimeout(final String w) throws OCommandSQLParsingException {    if (!w.equals(KEYWORD_TIMEOUT))      return false;    String word = parserNextWord(true);    try {      timeoutMs = Long.parseLong(word);    } catch (NumberFormatException ignore) {      throwParsingException("Invalid " + KEYWORD_TIMEOUT + " value set to '" + word + "' but it should be a valid long. Example: "          + KEYWORD_TIMEOUT + " 3000");    }    if (timeoutMs < 0)      throwParsingException("Invalid " + KEYWORD_TIMEOUT + ": value set minor than ZERO. Example: " + KEYWORD_TIMEOUT + " 10000");    word = parserNextWord(true);    if (word != null)      if (word.equals(TIMEOUT_STRATEGY.EXCEPTION.toString()))        timeoutStrategy = TIMEOUT_STRATEGY.EXCEPTION;      else if (word.equals(TIMEOUT_STRATEGY.RETURN.toString()))        timeoutStrategy = TIMEOUT_STRATEGY.RETURN;      else        parserGoBack();    return true;  }
protected String parseLock() throws OCommandSQLParsingException {    final String lockStrategy = parserNextWord(true);    if (!lockStrategy.equalsIgnoreCase("DEFAULT") && !lockStrategy.equalsIgnoreCase("NONE")        && !lockStrategy.equalsIgnoreCase("RECORD"))      throwParsingException("Invalid " + KEYWORD_LOCK + " value set to '" + lockStrategy          + "' but it should be NONE (default) or RECORD. Example: " + KEYWORD_LOCK + " RECORD");    return lockStrategy;  }
@Override  public OSpatialQueryContext build(Map<String, Object> query) throws Exception {    Shape shape = parseShape(query);    SpatialStrategy strategy = manager.strategy();    SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects, shape.getBoundingBox());    Query filterQuery = strategy.makeQuery(args);    BooleanQuery q = new BooleanQuery.Builder().add(filterQuery, BooleanClause.Occur.MUST)        .add(new MatchAllDocsQuery(), BooleanClause.Occur.SHOULD).build();    return new OSpatialQueryContext(null, manager.searcher(), q);  }
public Object execute(final Map<Object, Object> iArgs) {    final StringBuilder result = new StringBuilder();    if (optimizeEdges)      result.append(optimizeEdges());    return result.toString();  }
public Object execute(final Map<Object, Object> iArgs) {    if (fromExpr == null && toExpr == null && rids == null && query == null && compiledFilter == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    txAlreadyBegun = getDatabase().getTransaction().isActive();    if (rids != null) {      // REMOVE PUNCTUAL RID      OGraphCommandExecutorSQLFactory.runInConfiguredTxMode(new OGraphCommandExecutorSQLFactory.GraphCallBack<Object>() {        @Override        public Object call(OrientBaseGraph graph) {          for (ORecordId rid : rids) {            final OrientEdge e = graph.getEdge(rid);            if (e != null) {              e.remove();              removed++;            }          }          return null;        }      });      // CLOSE PENDING TX      end();    } else {      // MULTIPLE EDGES      final Set<OrientEdge> edges = new HashSet<OrientEdge>();      if (query == null) {        OGraphCommandExecutorSQLFactory.runInConfiguredTxMode(new OGraphCommandExecutorSQLFactory.GraphCallBack<Object>() {          @Override          public Object call(OrientBaseGraph graph) {            Set<OIdentifiable> fromIds = null;            if (fromExpr != null)              fromIds = OSQLEngine.getInstance().parseRIDTarget(graph.getRawGraph(), fromExpr, context, iArgs);            Set<OIdentifiable> toIds = null;            if (toExpr != null)              toIds = OSQLEngine.getInstance().parseRIDTarget(graph.getRawGraph(), toExpr, context, iArgs);            if(label == null )              label = OrientEdgeType.CLASS_NAME;                        if (fromIds != null && toIds != null) {              int fromCount = 0;              int toCount = 0;              for (OIdentifiable fromId : fromIds) {                final OrientVertex v = graph.getVertex(fromId);                if (v != null)                  fromCount += v.countEdges(Direction.OUT, label);              }              for (OIdentifiable toId : toIds) {                final OrientVertex v = graph.getVertex(toId);                if (v != null)                  toCount += v.countEdges(Direction.IN, label);              }              if (fromCount <= toCount) {                // REMOVE ALL THE EDGES BETWEEN VERTICES                for (OIdentifiable fromId : fromIds) {                  final OrientVertex v = graph.getVertex(fromId);                  if (v != null)                    for (Edge e : v.getEdges(Direction.OUT, label)) {                      final OIdentifiable inV = ((OrientEdge) e).getInVertex();                      if (inV != null && toIds.contains(inV.getIdentity()))                        edges.add((OrientEdge) e);                    }                }              } else {                for (OIdentifiable toId : toIds) {                  final OrientVertex v = graph.getVertex(toId);                  if (v != null)                    for (Edge e : v.getEdges(Direction.IN, label)) {                      final OIdentifiable outV = ((OrientEdge) e).getOutVertex();                      if (outV != null && fromIds.contains(outV.getIdentity()))                        edges.add((OrientEdge) e);                    }                }              }            } else if (fromIds != null) {              // REMOVE ALL THE EDGES THAT START FROM A VERTEXES              for (OIdentifiable fromId : fromIds) {                                final OrientVertex v = graph.getVertex(fromId);                if (v != null) {                  for (Edge e : v.getEdges(Direction.OUT, label)) {                    edges.add((OrientEdge) e);                  }                }              }            } else if (toIds != null) {              // REMOVE ALL THE EDGES THAT ARRIVE TO A VERTEXES              for (OIdentifiable toId : toIds) {                final OrientVertex v = graph.getVertex(toId);                if (v != null) {                  for (Edge e : v.getEdges(Direction.IN, label)) {                    edges.add((OrientEdge) e);                  }                }              }            } else              throw new OCommandExecutionException("Invalid target: " + toIds);            if (compiledFilter != null) {              // ADDITIONAL FILTERING              for (Iterator<OrientEdge> it = edges.iterator(); it.hasNext();) {                final OrientEdge edge = it.next();                if (!(Boolean) compiledFilter.evaluate(edge.getRecord(), null, context))                  it.remove();              }            }            // DELETE THE FOUND EDGES            removed = edges.size();            for (OrientEdge edge : edges)              edge.remove();            return null;          }        });        // CLOSE PENDING TX        end();      } else {        OGraphCommandExecutorSQLFactory.runInConfiguredTxMode(new OGraphCommandExecutorSQLFactory.GraphCallBack<OrientGraph>() {          @Override          public OrientGraph call(final OrientBaseGraph iGraph) {            // TARGET IS A CLASS + OPTIONAL CONDITION            currentGraph.set(iGraph);            query.setContext(getContext());            query.execute(iArgs);            return null;          }        });      }    }    return removed;  }
public boolean result(final Object iRecord) {    final OIdentifiable id = (OIdentifiable) iRecord;    if (compiledFilter != null) {      // ADDITIONAL FILTERING      if (!(Boolean) compiledFilter.evaluate(id.getRecord(), null, context))        return true;    }    if (id.getIdentity().isValid()) {      final OrientBaseGraph g = currentGraph.get();      final OrientEdge e = g.getEdge(id);      if (e != null) {        e.remove();        if (!txAlreadyBegun && batch > 0 && (removed + 1) % batch == 0) {          if (g instanceof OrientGraph) {            g.commit();            ((OrientGraph) g).begin();          }        }        removed++;      }    }    return true;  }
public OIndexSearchResult merge(final OIndexSearchResult searchResult) {    // if (searchResult.lastOperator instanceof OQueryOperatorEquals) {    if (searchResult.lastOperator instanceof OQueryOperatorEquals) {      return mergeFields(this, searchResult);    }    if (lastOperator instanceof OQueryOperatorEquals) {      return mergeFields(searchResult, this);    }    if (isIndexEqualityOperator(searchResult.lastOperator)) {      return mergeFields(this, searchResult);    }    return mergeFields(searchResult, this);  }
public Object execute(final Map<Object, Object> iArgs) {    if (schemaClass == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final long recs = schemaClass.count(deep);    if (recs > 0 && !unsafe) {      if (schemaClass.isSubClassOf("V")) {        throw new OCommandExecutionException(            "'TRUNCATE CLASS' command cannot be used on not empty vertex classes. Apply the 'UNSAFE' keyword to force it (at your own risk)");      } else if (schemaClass.isSubClassOf("E")) {        throw new OCommandExecutionException(            "'TRUNCATE CLASS' command cannot be used on not empty edge classes. Apply the 'UNSAFE' keyword to force it (at your own risk)");      }    }    Collection<OClass> subclasses = schemaClass.getAllSubclasses();    if (deep && !unsafe) {// for multiple inheritance      for (OClass subclass : subclasses) {        long subclassRecs = schemaClass.count();        if (subclassRecs > 0) {          if (subclass.isSubClassOf("V")) {            throw new OCommandExecutionException(                "'TRUNCATE CLASS' command cannot be used on not empty vertex classes (" + subclass.getName()                    + "). Apply the 'UNSAFE' keyword to force it (at your own risk)");          } else if (subclass.isSubClassOf("E")) {            throw new OCommandExecutionException(                "'TRUNCATE CLASS' command cannot be used on not empty edge classes (" + subclass.getName()                    + "). Apply the 'UNSAFE' keyword to force it (at your own risk)");          }        }      }    }    try {      schemaClass.truncate();      invalidateCommandCache(schemaClass);      if (deep) {        for (OClass subclass : subclasses) {          subclass.truncate();          invalidateCommandCache(subclass);        }      }    } catch (IOException e) {      throw OException.wrapException(new OCommandExecutionException("Error on executing command"), e);    }    return recs;  }
List<ORID> getValues(final int entryIndex) {    assert isLeaf;    int entryPosition = getIntValue(entryIndex * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);    int nextItem = getIntValue(entryPosition);    entryPosition += OIntegerSerializer.INT_SIZE;    // skip key    if (encryption == null) {      entryPosition += getObjectSizeInDirectMemory(keySerializer, entryPosition);    } else {      final int encryptedSize = getIntValue(entryPosition);      entryPosition += OIntegerSerializer.INT_SIZE + encryptedSize;    }    int clusterId = getShortValue(entryPosition);    long clusterPosition = getLongValue(entryPosition + OShortSerializer.SHORT_SIZE);    final List<ORID> results = new ArrayList<>(8);    results.add(new ORecordId(clusterId, clusterPosition));    while (nextItem > 0) {      final int nextNextItem = getIntValue(nextItem);      final int nextItemSize = 0xFF & getByteValue(nextItem + OIntegerSerializer.INT_SIZE);      for (int i = 0; i < nextItemSize; i++) {        clusterId = getShortValue(nextItem + OIntegerSerializer.INT_SIZE + OByteSerializer.BYTE_SIZE + i * RID_SIZE);        clusterPosition = getLongValue(            nextItem + OIntegerSerializer.INT_SIZE + OShortSerializer.SHORT_SIZE + OByteSerializer.BYTE_SIZE + i * RID_SIZE);        results.add(new ORecordId(clusterId, clusterPosition));      }      nextItem = nextNextItem;    }    return results;  }
public void createCluster(final String className, final String clusterName) {    final ODatabaseDocumentInternal currentDB = ODatabaseRecordThreadLocal.instance().getIfDefined();    try {      final ODatabaseDocumentInternal sysdb = openSystemDatabase();      try {        if (!sysdb.existsCluster(clusterName)) {          OSchema schema = sysdb.getMetadata().getSchema();          OClass cls = schema.getClass(className);          if (cls != null) {            cls.addCluster(clusterName);          } else {            OLogManager.instance().error(this, "createCluster() Class name %s does not exist", null, className);          }        }      } finally {        sysdb.close();      }    } finally {      if (currentDB != null)        ODatabaseRecordThreadLocal.instance().set(currentDB);      else        ODatabaseRecordThreadLocal.instance().remove();    }  }
public void freeCluster(final int cid) {    final Set<ORID> toRemove = new HashSet<ORID>(underlying.size() / 2);    final Set<ORID> keys = new HashSet<ORID>(underlying.keys());    for (final ORID id : keys)      if (id.getClusterId() == cid)        toRemove.add(id);    for (final ORID ridToRemove : toRemove)      underlying.remove(ridToRemove);  }
public void startup() {    underlying.startup();    Orient.instance().getProfiler()        .registerHookValue(profilerPrefix + "current", "Number of entries in cache", METRIC_TYPE.SIZE, new OProfilerHookValue() {          public Object getValue() {            return getSize();          }        }, profilerMetadataPrefix + "current");  }
public void shutdown() {    underlying.shutdown();    if (Orient.instance().getProfiler() != null) {      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + "enabled");      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + "current");      Orient.instance().getProfiler().unregisterHookValue(profilerPrefix + "max");    }  }
public static OScriptResultSet singleton(Object entity, OScriptTransformer transformer) {    return new OScriptResultSet(Collections.singletonList(entity).iterator(), transformer);  }
public ORole grant(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {    ORule rule = rules.get(resourceGeneric);    if (rule == null) {      rule = new ORule(resourceGeneric, null, null);      rules.put(resourceGeneric, rule);    }    rule.grantAccess(resourceSpecific, iOperation);    rules.put(resourceGeneric, rule);    updateRolesDocumentContent();    return this;  }
public ORole revoke(final ORule.ResourceGeneric resourceGeneric, String resourceSpecific, final int iOperation) {    if (iOperation == PERMISSION_NONE)      return this;    ORule rule = rules.get(resourceGeneric);    if (rule == null) {      rule = new ORule(resourceGeneric, null, null);      rules.put(resourceGeneric, rule);    }    rule.revokeAccess(resourceSpecific, iOperation);    rules.put(resourceGeneric, rule);    updateRolesDocumentContent();    return this;  }
@Override  public void serializeInByteBufferObject(Float object, ByteBuffer buffer, Object... hints) {    buffer.putInt(Float.floatToIntBits(object));  }
@Override  public Float deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return Float.intBitsToFloat(walChanges.getIntValue(buffer, offset));  }
public boolean result(final Object iRecord) {    final ORecordAbstract record = ((OIdentifiable) iRecord).getRecord();    if (record instanceof ODocument && compiledFilter != null        && !Boolean.TRUE.equals(this.compiledFilter.evaluate(record, (ODocument) record, getContext()))) {      return true;    }    try {      if (record.getIdentity().isValid()) {        if (returning.equalsIgnoreCase("BEFORE"))          allDeletedRecords.add(record);        // RESET VERSION TO DISABLE MVCC AVOIDING THE CONCURRENT EXCEPTION IF LOCAL CACHE IS NOT UPDATED//        ORecordInternal.setVersion(record, -1);        if (!unsafe && record instanceof ODocument) {          // CHECK IF ARE VERTICES OR EDGES          final OClass cls = ((ODocument) record).getSchemaClass();          if (cls != null) {            if (cls.isSubClassOf("V"))              // FOUND VERTEX              throw new OCommandExecutionException(                  "'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it");            else if (cls.isSubClassOf("E"))              // FOUND EDGE              throw new OCommandExecutionException(                  "'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it");          }        }        record.delete();        recordCount++;        return true;      }      return false;    } finally {      if (lockStrategy.equalsIgnoreCase("RECORD"))        ((OAbstractPaginatedStorage) getDatabase().getStorage()).releaseWriteLock(record.getIdentity());    }  }
private void convertToModifiableResult(OUpdateExecutionPlan plan, OCommandContext ctx, boolean profilingEnabled) {    plan.chain(new ConvertToUpdatableResultStep(ctx, profilingEnabled));  }
@Override  public void serializeInByteBufferObject(Integer object, ByteBuffer buffer, Object... hints) {    buffer.putInt(object);  }
@Override  public Integer deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return walChanges.getIntValue(buffer, offset);  }
public void bindParameters(final Map<Object, Object> iArgs) {    if (parameterItems == null || iArgs == null || iArgs.size() == 0)      return;    for (int i = 0; i < parameterItems.size(); i++) {      OSQLFilterItemParameter value = parameterItems.get(i);      if ("?".equals(value.getName())) {        value.setValue(iArgs.get(i));      } else {        value.setValue(iArgs.get(value.getName()));      }    }  }
private void convert(final int iIndex) {    if (converted)      return;    Object o = list.get(iIndex);    if (o == null) {      o = serializedList.get(iIndex);      list.set(iIndex, OObjectEntitySerializer.deserializeFieldValue(deserializeClass, o));    }  }
protected Iterable<OResultInternal> traversePatternEdge(OIdentifiable startingPoint, OCommandContext iCommandContext) {    Iterable possibleResults = null;    if (this.item.getFilter() != null) {      String alias = getEndpointAlias();      Object matchedNodes = iCommandContext.getVariable(MatchPrefetchStep.PREFETCHED_MATCH_ALIAS_PREFIX + alias);      if (matchedNodes != null) {        if (matchedNodes instanceof Iterable) {          possibleResults = (Iterable) matchedNodes;        } else {          possibleResults = Collections.singleton(matchedNodes);        }      }    }    Object prevCurrent = iCommandContext.getVariable("$current");    iCommandContext.setVariable("$current", startingPoint);    Object qR;    try {      qR = this.item.getMethod().execute(startingPoint, possibleResults, iCommandContext);    } finally {      iCommandContext.setVariable("$current", prevCurrent);    }    if (qR == null) {      return Collections.EMPTY_LIST;    }    if (qR instanceof OIdentifiable) {      return Collections.singleton(new OResultInternal((OIdentifiable) qR));    }    if (qR instanceof Iterable) {      final Iterator<Object> iter = ((Iterable) qR).iterator();      Iterable<OResultInternal> result = () -> new Iterator<OResultInternal>() {        private OResultInternal nextElement;        @Override        public boolean hasNext() {          if (nextElement == null) {            fetchNext();          }          return nextElement != null;        }        @Override        public OResultInternal next() {          if (nextElement == null) {            fetchNext();          }          if (nextElement == null) {            throw new IllegalStateException();          }          OResultInternal res = nextElement;          nextElement = null;          return res;        }        public void fetchNext() {          while (iter.hasNext()) {            Object o = iter.next();            if (o instanceof OIdentifiable) {              nextElement = new OResultInternal((OIdentifiable) o);              break;            } else if (o instanceof OResultInternal) {              nextElement = (OResultInternal) o;              break;            } else if (o == null) {              continue;            } else {              throw new UnsupportedOperationException();            }          }        }      };      return result;    }    return Collections.EMPTY_LIST;  }
private void convert(final int iIndex) {    if (converted)      return;    Object o = list.get(iIndex);    if (o == null) {      o = serializedList.get(iIndex);      if (o instanceof Number)        o = enumClass.getEnumConstants()[((Number) o).intValue()];      else        o = Enum.valueOf(enumClass, o.toString());      list.set(iIndex, (TYPE) o);    }  }
public static OType getType(final String iValue) {    if (iValue.length() == 0)      return null;    final char firstChar = iValue.charAt(0);    if (firstChar == ORID.PREFIX)      // RID      return OType.LINK;    else if (firstChar == '\'' || firstChar == '"')      return OType.STRING;    else if (firstChar == OStringSerializerHelper.BINARY_BEGINEND)      return OType.BINARY;    else if (firstChar == OStringSerializerHelper.EMBEDDED_BEGIN)      return OType.EMBEDDED;    else if (firstChar == OStringSerializerHelper.LIST_BEGIN)      return OType.EMBEDDEDLIST;    else if (firstChar == OStringSerializerHelper.SET_BEGIN)      return OType.EMBEDDEDSET;    else if (firstChar == OStringSerializerHelper.MAP_BEGIN)      return OType.EMBEDDEDMAP;    else if (firstChar == OStringSerializerHelper.CUSTOM_TYPE)      return OType.CUSTOM;    // BOOLEAN?    if (iValue.equalsIgnoreCase("true") || iValue.equalsIgnoreCase("false"))      return OType.BOOLEAN;    // NUMBER OR STRING?    boolean integer = true;    for (int index = 0; index < iValue.length(); ++index) {      final char c = iValue.charAt(index);      if (c < '0' || c > '9')        if ((index == 0 && (c == '+' || c == '-')))          continue;        else if (c == DECIMAL_SEPARATOR)          integer = false;        else {          if (index > 0)            if (!integer && c == 'E') {              // CHECK FOR SCIENTIFIC NOTATION              if (index < iValue.length()) {                if (iValue.charAt(index + 1) == '-')                  // JUMP THE DASH IF ANY (NOT MANDATORY)                  index++;                continue;              }            } else if (c == 'f')              return index != (iValue.length() - 1) ? OType.STRING : OType.FLOAT;            else if (c == 'c')              return index != (iValue.length() - 1) ? OType.STRING : OType.DECIMAL;            else if (c == 'l')              return index != (iValue.length() - 1) ? OType.STRING : OType.LONG;            else if (c == 'd')              return index != (iValue.length() - 1) ? OType.STRING : OType.DOUBLE;            else if (c == 'b')              return index != (iValue.length() - 1) ? OType.STRING : OType.BYTE;            else if (c == 'a')              return index != (iValue.length() - 1) ? OType.STRING : OType.DATE;            else if (c == 't')              return index != (iValue.length() - 1) ? OType.STRING : OType.DATETIME;            else if (c == 's')              return index != (iValue.length() - 1) ? OType.STRING : OType.SHORT;            else if (c == 'e') { //eg. 1e-06              try{                Double.parseDouble(iValue);                return  OType.DOUBLE;              } catch (Exception ignore) {                return OType.STRING;              }            }          return OType.STRING;        }    }    if (integer) {      // AUTO CONVERT TO LONG IF THE INTEGER IS TOO BIG      final int numberLength = iValue.length();      if (numberLength > MAX_INTEGER_DIGITS || (numberLength == MAX_INTEGER_DIGITS && iValue.compareTo(MAX_INTEGER_AS_STRING) > 0))        return OType.LONG;      return OType.INTEGER;    }    // CHECK IF THE DECIMAL NUMBER IS A FLOAT OR DOUBLE    final double dou = Double.parseDouble(iValue);    if (dou <= Float.MAX_VALUE && dou >= Float.MIN_VALUE && Double.toString(dou).equals(Float.toString((float) dou))        && new Double(new Double(dou).floatValue()).doubleValue() == dou) {      return OType.FLOAT;    } else if (!new Double(dou).toString().equals(iValue)) {      return OType.DECIMAL;    }    return OType.DOUBLE;  }
public static OType getType(final String iValue, final char iCharType) {    if (iCharType == 'f')      return OType.FLOAT;    else if (iCharType == 'c')      return OType.DECIMAL;    else if (iCharType == 'l')      return OType.LONG;    else if (iCharType == 'd')      return OType.DOUBLE;    else if (iCharType == 'b') {      if (iValue.length() >= 1 && iValue.length() <= 3)        return OType.BYTE;      else        return OType.BINARY;    } else if (iCharType == 'a')      return OType.DATE;    else if (iCharType == 't')      return OType.DATETIME;    else if (iCharType == 's')      return OType.SHORT;    else if (iCharType == 'e')      return OType.EMBEDDEDSET;    else if (iCharType == 'g')      return OType.LINKBAG;    else if (iCharType == 'z')      return OType.LINKLIST;    else if (iCharType == 'm')      return OType.LINKMAP;    else if (iCharType == 'x')      return OType.LINK;    else if (iCharType == 'n')      return OType.LINKSET;    else if (iCharType == 'x')      return OType.LINK;    else if (iCharType == 'u')      return OType.CUSTOM;    return OType.STRING;  }
public static Object getTypeValue(final String iValue) {    if (iValue == null || iValue.equalsIgnoreCase("NULL"))      return null;    if (iValue.length() == 0)      return "";    if (iValue.length() > 1)      if (iValue.charAt(0) == '"' && iValue.charAt(iValue.length() - 1) == '"')        // STRING        return OStringSerializerHelper.decode(iValue.substring(1, iValue.length() - 1));      else if (iValue.charAt(0) == OStringSerializerHelper.BINARY_BEGINEND          && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.BINARY_BEGINEND)        // STRING        return OStringSerializerHelper.getBinaryContent(iValue);      else if (iValue.charAt(0) == OStringSerializerHelper.LIST_BEGIN          && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.LIST_END) {        // LIST        final ArrayList<String> coll = new ArrayList<String>();        OStringSerializerHelper.getCollection(iValue, 0, coll, OStringSerializerHelper.LIST_BEGIN,            OStringSerializerHelper.LIST_END, OStringSerializerHelper.COLLECTION_SEPARATOR);        return coll;      } else if (iValue.charAt(0) == OStringSerializerHelper.SET_BEGIN          && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.SET_END) {        // SET        final Set<String> coll = new HashSet<String>();        OStringSerializerHelper.getCollection(iValue, 0, coll, OStringSerializerHelper.SET_BEGIN, OStringSerializerHelper.SET_END,            OStringSerializerHelper.COLLECTION_SEPARATOR);        return coll;      } else if (iValue.charAt(0) == OStringSerializerHelper.MAP_BEGIN          && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.MAP_END) {        // MAP        return OStringSerializerHelper.getMap(iValue);      }    if (iValue.charAt(0) == ORID.PREFIX)      // RID      return new ORecordId(iValue);    boolean integer = true;    char c;    boolean stringStarBySign = false;    for (int index = 0; index < iValue.length(); ++index) {      c = iValue.charAt(index);      if (c < '0' || c > '9') {        if ((index == 0 && (c == '+' || c == '-'))) {          stringStarBySign = true;          continue;        } else if (c == DECIMAL_SEPARATOR)          integer = false;        else {          if (index > 0) {            if (!integer && c == 'E') {              // CHECK FOR SCIENTIFIC NOTATION              if (index < iValue.length())                index++;              if (iValue.charAt(index) == '-')                continue;            }            final String v = iValue.substring(0, index);            if (c == 'f')              return new Float(v);            else if (c == 'c')              return new BigDecimal(v);            else if (c == 'l')              return new Long(v);            else if (c == 'd')              return new Double(v);            else if (c == 'b')              return new Byte(v);            else if (c == 'a' || c == 't')              return new Date(Long.parseLong(v));            else if (c == 's')              return new Short(v);          }          return iValue;        }      } else if (stringStarBySign) {        stringStarBySign = false;      }    }    if (stringStarBySign)      return iValue;    if (integer) {      try {        return new Integer(iValue);      } catch (NumberFormatException ignore) {        return new Long(iValue);      }    } else if ("NaN".equals(iValue) || "Infinity".equals(iValue))      // NaN and Infinity CANNOT BE MANAGED BY BIG-DECIMAL TYPE      return new Double(iValue);    else      return new BigDecimal(iValue);  }
@Override  public void increment(int hash) {    hash = spread(hash);    final int start = (hash & 3) << 2;    // Loop unrolling improves throughput by 5m ops/s    final int index0 = indexOf(hash, 0);    final int index1 = indexOf(hash, 1);    final int index2 = indexOf(hash, 2);    final int index3 = indexOf(hash, 3);    boolean added = incrementAt(index0, start);    added |= incrementAt(index1, start + 1);    added |= incrementAt(index2, start + 2);    added |= incrementAt(index3, start + 3);    if (added && (++size == sampleSize)) {      reset();    }  }
private boolean incrementAt(final int i, final int j) {    final int offset = j << 2;    final long mask = (0xfL << offset);    if ((table[i] & mask) != mask) {      table[i] += (1L << offset);      return true;    }    return false;  }
private void reset() {    int count = 0;    for (int i = 0; i < table.length; i++) {      count += Long.bitCount(table[i] & ONE_MASK);      table[i] = (table[i] >>> 1) & RESET_MASK;    }    size = (size >>> 1) - (count >>> 2);  }
private int indexOf(final int item, final int i) {    long hash = SEED[i] * item;    hash += hash >> 32;    return ((int) hash) & tableMask;  }
private int spread(int x) {    x = ((x >>> 16) ^ x) * 0x45d9f3b;    x = ((x >>> 16) ^ x) * randomSeed;    return (x >>> 16) ^ x;  }
public OIndex<?> createIndex(final String iType) {    acquireSchemaReadLock();    try {      return owner.createIndex(getFullName(), iType, globalRef.getName());    } finally {      releaseSchemaReadLock();    }  }
@Deprecated  public OPropertyImpl dropIndexes() {    getDatabase().checkSecurity(ORule.ResourceGeneric.SCHEMA, ORole.PERMISSION_DELETE);    acquireSchemaReadLock();    try {      final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();      final ArrayList<OIndex<?>> relatedIndexes = new ArrayList<OIndex<?>>();      for (final OIndex<?> index : indexManager.getClassIndexes(owner.getName())) {        final OIndexDefinition definition = index.getDefinition();        if (OCollections.indexOf(definition.getFields(), globalRef.getName(), new OCaseInsentiveComparator()) > -1) {          if (definition instanceof OPropertyIndexDefinition) {            relatedIndexes.add(index);          } else {            throw new IllegalArgumentException(                "This operation applicable only for property indexes. " + index.getName() + " is " + index.getDefinition());          }        }      }      for (final OIndex<?> index : relatedIndexes)        getDatabase().getMetadata().getIndexManager().dropIndex(index.getName());      return this;    } finally {      releaseSchemaReadLock();    }  }
@Deprecated  public OIndex<?> getIndex() {    acquireSchemaReadLock();    try {      Set<OIndex<?>> indexes = owner.getInvolvedIndexes(globalRef.getName());      if (indexes != null && !indexes.isEmpty())        return indexes.iterator().next();      return null;    } finally {      releaseSchemaReadLock();    }  }
public OClass getLinkedClass() {    acquireSchemaReadLock();    try {      if (linkedClass == null && linkedClassName != null)        linkedClass = owner.owner.getClass(linkedClassName);      return linkedClass;    } finally {      releaseSchemaReadLock();    }  }
public Object execute(final Map<Object, Object> iArgs) {    if (clazz == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    // CREATE VERTEX DOES NOT HAVE TO BE IN TX    final OVertex vertex = getDatabase().newVertex(clazz);    if (fields != null)      // EVALUATE FIELDS      for (final OPair<String, Object> f : fields) {        if (f.getValue() instanceof OSQLFunctionRuntime)          f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(vertex.getRecord(), null, context));      }    OSQLHelper.bindParameters(vertex.getRecord(), fields, new OCommandParameters(iArgs), context);    if (content != null)      ((ODocument)vertex.getRecord()).merge(content, true, false);    if (clusterName != null)      vertex.save(clusterName);    else      vertex.save();    return vertex.getRecord();  }
public void addKey(final Object key) {    if (key instanceof OCompositeKey) {      final OCompositeKey compositeKey = (OCompositeKey) key;      for (final Object inKey : compositeKey.keys) {        addKey(inKey);      }    } else {      keys.add(key);    }  }
public OIndex<?> createIndex(ODatabaseDocumentInternal database, final String iName, String type,      final OIndexDefinition indexDefinition, final int[] clusterIdsToIndex, OProgressListener progressListener, ODocument metadata,      String algorithm) {    if (database.getTransaction().isActive())      throw new IllegalStateException("Cannot create a new index inside a transaction");    final Character c = OSchemaShared.checkFieldNameIfValid(iName);    if (c != null)      throw new IllegalArgumentException("Invalid index name '" + iName + "'. Character '" + c + "' is invalid");    if (indexDefinition == null) {      throw new IllegalArgumentException("Index definition cannot be null");    }    final Locale locale = getServerLocale();    type = type.toUpperCase(locale);    if (algorithm == null) {      algorithm = OIndexes.chooseDefaultIndexAlgorithm(type);    }    final String valueContainerAlgorithm = chooseContainerAlgorithm(type);    final OIndexInternal<?> index;    acquireExclusiveLock();    try {      if (indexes.containsKey(iName))        throw new OIndexException("Index with name " + iName + " already exists.");      // manual indexes are always durable      if (clusterIdsToIndex == null || clusterIdsToIndex.length == 0) {        if (metadata == null)          metadata = new ODocument().setTrackingChanges(false);        final Object durable = metadata.field("durableInNonTxMode");        if (!(durable instanceof Boolean))          metadata.field("durableInNonTxMode", true);        if (metadata.field("trackMode") == null)          metadata.field("trackMode", "FULL");      }      index = OIndexes.createIndex(getStorage(), iName, type, algorithm, valueContainerAlgorithm, metadata, -1);      if (progressListener == null)        // ASSIGN DEFAULT PROGRESS LISTENER        progressListener = new OIndexRebuildOutputListener(index);      final Set<String> clustersToIndex = findClustersByIds(clusterIdsToIndex, database);      Object ignoreNullValues = metadata == null ? null : metadata.field("ignoreNullValues");      if (Boolean.TRUE.equals(ignoreNullValues)) {        indexDefinition.setNullValuesIgnored(true);      } else if (Boolean.FALSE.equals(ignoreNullValues)) {        indexDefinition.setNullValuesIgnored(false);      } else {        indexDefinition.setNullValuesIgnored(            database.getConfiguration().getValueAsBoolean(OGlobalConfiguration.INDEX_IGNORE_NULL_VALUES_DEFAULT));      }      // decide which cluster to use ("index" - for automatic and "manindex" for manual)      final String clusterName = indexDefinition.getClassName() != null ? defaultClusterName : manualClusterName;      index.create(iName, indexDefinition, clusterName, clustersToIndex, true, progressListener);      addIndexInternal(index);      if (metadata != null) {        final ODocument config = index.getConfiguration();        config.field("metadata", metadata, OType.EMBEDDED);      }      setDirty();      save();    } finally {      releaseExclusiveLock();    }    notifyInvolvedClasses(database, clusterIdsToIndex);    return preProcessBeforeReturn(database, index);  }
@Override  public ODocument toStream() {    internalAcquireExclusiveLock();    try {      document.setInternalStatus(ORecordElement.STATUS.UNMARSHALLING);      try {        final OTrackedSet<ODocument> indexes = new OTrackedSet<>(document);        for (final OIndex<?> i : this.indexes.values()) {          indexes.add(((OIndexInternal<?>) i).updateConfiguration());        }        document.field(CONFIG_INDEXES, indexes, OType.EMBEDDEDSET);      } finally {        document.setInternalStatus(ORecordElement.STATUS.LOADED);      }      document.setDirty();      return document;    } finally {      internalReleaseExclusiveLock();    }  }
public void setServerRole(final String iServerName, final ROLES role) {    synchronized (configuration) {      ODocument servers = configuration.field(SERVERS);      if (servers == null) {        servers = new ODocument();        configuration.field(SERVERS, servers, OType.EMBEDDED);      }      servers.field(iServerName, role);      incrementVersion();    }  }
public List<String> addNewNodeInServerList(final String iNode) {    synchronized (configuration) {      final List<String> changedPartitions = new ArrayList<String>();      // ADD THE NODE IN CONFIGURATION. LOOK FOR $newNode TAG      for (String clusterName : getClusterNames()) {        final List<String> partitions = getClusterConfiguration(clusterName).field(SERVERS);        if (partitions != null) {          final int newNodePos = partitions.indexOf(OModifiableDistributedConfiguration.NEW_NODE_TAG);          if (newNodePos > -1 && !partitions.contains(iNode)) {            partitions.add(newNodePos, iNode);            changedPartitions.add(clusterName);          }        }      }      if (!changedPartitions.isEmpty()) {        // INCREMENT VERSION        incrementVersion();        if (!getRegisteredServers().contains(iNode)) {          if (getNewNodeStrategy() == NEW_NODE_STRATEGIES.STATIC) {            // REGISTER THE SERVER AS STATIC AND INCREMENT VERSION            setServerRole(iNode, getServerRole("*"));          }        }        return changedPartitions;      }    }    return null;  }
public void setServerOwner(final String iClusterName, final String iServerName) {    if (iClusterName == null)      throw new IllegalArgumentException("cluster name cannot be null");    synchronized (configuration) {      final ODocument clusters = configuration.field(CLUSTERS);      ODocument cluster = clusters.field(iClusterName);      if (cluster == null)        // CREATE IT        cluster = createCluster(iClusterName);      else {        // CHECK IF THE OWNER IS ALREADY CONFIGURED        final String owner = cluster.field(OWNER);        if (owner != null && !iServerName.equalsIgnoreCase(owner))          throw new ODistributedException("Cannot overwrite ownership of cluster '" + iClusterName + "' to the server '"              + iServerName + "', because server '" + owner + "' was already configured as owner");      }      List<String> serverList = getClusterConfiguration(iClusterName).field(SERVERS);      if (serverList == null) {        serverList = initClusterServers(cluster);      }      if (!serverList.isEmpty() && serverList.get(0).equals(iServerName))        // ALREADY OWNER        return;      // REMOVE THE NODE IF ANY      boolean removed = false;      for (Iterator<String> it = serverList.iterator(); it.hasNext();) {        if (it.next().equals(iServerName)) {          it.remove();          removed = true;          break;        }      }      if( !removed )        throw new ODistributedException("Cannot set ownership of cluster '" + iClusterName + "' to the server '"            + iServerName + "', because the server has no that cluster (sharding)");      // ADD THE NODE AS FIRST OF THE LIST = MASTER      serverList.add(0, iServerName);      incrementVersion();    }  }
public List<String> removeServer(final String iNode) {    synchronized (configuration) {      final List<String> changedPartitions = new ArrayList<String>();      for (String clusterName : getClusterNames()) {        final Collection<String> nodes = getClusterConfiguration(clusterName).field(SERVERS);        if (nodes != null) {          for (String node : nodes) {            if (node.equals(iNode)) {              // FOUND: REMOVE IT              nodes.remove(node);              changedPartitions.add(clusterName);              break;            }          }        }      }      if (!changedPartitions.isEmpty()) {        incrementVersion();        return changedPartitions;      }    }    return null;  }
public List<String> setServerOffline(final String iNode, final String newLockManagerServer) {    final List<String> changedPartitions = new ArrayList<String>();    final String[] clusters = getClusterNames();    synchronized (configuration) {      for (String clusterName : clusters) {        final List<String> nodes = getClusterConfiguration(clusterName).field(SERVERS);        if (nodes != null && nodes.size() > 1) {          for (String node : nodes) {            if (node.equals(iNode)) {              // FOUND: PUT THE NODE AT THE END (BEFORE ANY TAG <NEW_NODE>)              nodes.remove(node);              final boolean newNodeRemoved = nodes.remove(NEW_NODE_TAG);              nodes.add(node);              if (newNodeRemoved)                // REINSERT NEW NODE TAG AT THE END                nodes.add(NEW_NODE_TAG);              if (newLockManagerServer != null) {                // ASSURE THE NEW LOCK MANAGER IS THE FIRST IN THE LIST                if (nodes.remove(newLockManagerServer))                  nodes.add(0, newLockManagerServer);              }              changedPartitions.add(clusterName);              break;            }          }        }      }      if (!changedPartitions.isEmpty()) {        incrementVersion();        return changedPartitions;      }    }    return null;  }
public void configure(OStorage iStorage, int iId, String iClusterName, Object... iParameters) {    id = iId;    name = iClusterName;  }
public void configure(OStorage iStorage, OStorageClusterConfiguration iConfig) throws IOException {    id = iConfig.getId();    name = iConfig.getName();  }
protected void removeListener(final ORecordListener listener) {    if (_listeners != null) {      _listeners.remove(listener);      if (_listeners.isEmpty())        _listeners = null;    }  }
public ODistributedDatabaseImpl registerDatabase(final String iDatabaseName, ODistributedConfiguration cfg) {    final ODistributedDatabaseImpl ddb = databases.get(iDatabaseName);    if (ddb != null)      return ddb;    return new ODistributedDatabaseImpl(manager, this, iDatabaseName, cfg, manager.getServerInstance());  }
public void dispatchResponseToThread(final ODistributedResponse response) {    try {      final long msgId = response.getRequestId().getMessageId();      // GET ASYNCHRONOUS MSG MANAGER IF ANY      final ODistributedResponseManager asynchMgr = responsesByRequestIds.get(msgId);      if (asynchMgr == null) {        if (ODistributedServerLog.isDebugEnabled())          ODistributedServerLog.debug(this, manager.getLocalNodeName(), response.getExecutorNodeName(), DIRECTION.IN,              "received response for message %d after the timeout (%dms)", msgId,              OGlobalConfiguration.DISTRIBUTED_ASYNCH_RESPONSES_TIMEOUT.getValueAsLong());      } else if (asynchMgr.collectResponse(response)) {        // ALL RESPONSE RECEIVED, REMOVE THE RESPONSE MANAGER WITHOUT WAITING THE PURGE THREAD REMOVE THEM FOR TIMEOUT        responsesByRequestIds.remove(msgId);      }    } finally {      Orient.instance().getProfiler()          .updateCounter("distributed.node.msgReceived", "Number of replication messages received in current node", +1,              "distributed.node.msgReceived");      Orient.instance().getProfiler().updateCounter("distributed.node." + response.getExecutorNodeName() + ".msgReceived",          "Number of replication messages received in current node from a node", +1, "distributed.node.*.msgReceived");    }  }
public void timeoutRequest(final long msgId) {    final ODistributedResponseManager asynchMgr = responsesByRequestIds.remove(msgId);    if (asynchMgr != null)      asynchMgr.timeout();  }
public void internalCreate(OrientDBConfig config, OSharedContext ctx) {    this.sharedContext = ctx;    this.status = STATUS.OPEN;    // THIS IF SHOULDN'T BE NEEDED, CREATE HAPPEN ONLY IN EMBEDDED    applyAttributes(config);    applyListeners(config);    metadata = new OMetadataDefault(this);    installHooksEmbedded();    createMetadata(ctx);    if (this.getMetadata().getCommandCache().isEnabled())      registerHook(new OCommandCacheHook(this), ORecordHook.HOOK_POSITION.REGULAR);  }
public ODatabaseDocumentInternal copy() {    ODatabaseDocumentEmbedded database = new ODatabaseDocumentEmbedded(getSharedContext().getStorage());    database.init(config, this.sharedContext);    String user;    if (getUser() != null) {      user = getUser().getName();    } else {      user = null;    }    database.internalOpen(user, null, false);    database.callOnOpenListeners();    this.activateOnCurrentThread();    return database;  }
public void executeDeleteRecord(OIdentifiable record, final int iVersion, final boolean iRequired, final OPERATION_MODE iMode,      boolean prohibitTombstones) {    checkOpenness();    checkIfActive();    final ORecordId rid = (ORecordId) record.getIdentity();    if (rid == null)      throw new ODatabaseException(          "Cannot delete record because it has no identity. Probably was created from scratch or contains projections of fields rather than a full record");    if (!rid.isValid())      return;    record = record.getRecord();    if (record == null)      return;    final OMicroTransaction microTx = beginMicroTransaction();    try {      microTx.deleteRecord(record.getRecord(), iMode);    } catch (Exception e) {      endMicroTransaction(false);      throw e;    }    endMicroTransaction(true);    return;  }
public <RET extends ORecord> RET executeReadRecord(final ORecordId rid, ORecord iRecord, final int recordVersion,      final String fetchPlan, final boolean ignoreCache, final boolean iUpdateCache, final boolean loadTombstones,      final OStorage.LOCKING_STRATEGY lockingStrategy, RecordReader recordReader) {    checkOpenness();    checkIfActive();    getMetadata().makeThreadLocalSchemaSnapshot();    ORecordSerializationContext.pushContext();    try {      checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, getClusterNameById(rid.getClusterId()));      // either regular or micro tx must be active or both inactive      assert !(getTransaction().isActive() && (microTransaction != null && microTransaction.isActive()));      // SEARCH IN LOCAL TX      ORecord record = getTransaction().getRecord(rid);      if (record == OBasicTransaction.DELETED_RECORD)        // DELETED IN TX        return null;      if (record == null) {        if (microTransaction != null && microTransaction.isActive()) {          record = microTransaction.getRecord(rid);          if (record == OBasicTransaction.DELETED_RECORD)            return null;        }      }      if (record == null && !ignoreCache)        // SEARCH INTO THE CACHE        record = getLocalCache().findRecord(rid);      if (record != null) {        if (iRecord != null) {          iRecord.fromStream(record.toStream());          ORecordInternal.setVersion(iRecord, record.getVersion());          record = iRecord;        }        OFetchHelper.checkFetchPlanValid(fetchPlan);        if (beforeReadOperations(record))          return null;        if (record.getInternalStatus() == ORecordElement.STATUS.NOT_LOADED)          record.reload();        if (lockingStrategy == OStorage.LOCKING_STRATEGY.KEEP_SHARED_LOCK) {          OLogManager.instance()              .warn(this, "You use deprecated record locking strategy: %s it may lead to deadlocks " + lockingStrategy);          record.lock(false);        } else if (lockingStrategy == OStorage.LOCKING_STRATEGY.KEEP_EXCLUSIVE_LOCK) {          OLogManager.instance()              .warn(this, "You use deprecated record locking strategy: %s it may lead to deadlocks " + lockingStrategy);          record.lock(true);        }        afterReadOperations(record);        if (record instanceof ODocument)          ODocumentInternal.checkClass((ODocument) record, this);        return (RET) record;      }      final ORawBuffer recordBuffer;      if (!rid.isValid())        recordBuffer = null;      else {        OFetchHelper.checkFetchPlanValid(fetchPlan);        int version;        if (iRecord != null)          version = iRecord.getVersion();        else          version = recordVersion;        recordBuffer = recordReader.readRecord(getStorage(), rid, fetchPlan, ignoreCache, version);      }      if (recordBuffer == null)        return null;      if (iRecord == null || ORecordInternal.getRecordType(iRecord) != recordBuffer.recordType)        // NO SAME RECORD TYPE: CAN'T REUSE OLD ONE BUT CREATE A NEW ONE FOR IT        iRecord = Orient.instance().getRecordFactoryManager().newInstance(recordBuffer.recordType, rid.getClusterId(), this);      ORecordInternal.setRecordSerializer(iRecord, getSerializer());      ORecordInternal.fill(iRecord, rid, recordBuffer.version, recordBuffer.buffer, false, this);      if (iRecord instanceof ODocument)        ODocumentInternal.checkClass((ODocument) iRecord, this);      if (ORecordVersionHelper.isTombstone(iRecord.getVersion()))        return (RET) iRecord;      if (beforeReadOperations(iRecord))        return null;      iRecord.fromStream(recordBuffer.buffer);      afterReadOperations(iRecord);      if (iUpdateCache)        getLocalCache().updateRecord(iRecord);      return (RET) iRecord;    } catch (OOfflineClusterException t) {      throw t;    } catch (ORecordNotFoundException t) {      throw t;    } catch (Exception t) {      if (rid.isTemporary())        throw OException.wrapException(new ODatabaseException("Error on retrieving record using temporary RID: " + rid), t);      else        throw OException.wrapException(new ODatabaseException(            "Error on retrieving record " + rid + " (cluster: " + getStorage().getPhysicalClusterNameById(rid.getClusterId())                + ")"), t);    } finally {      ORecordSerializationContext.pullContext();      getMetadata().clearThreadLocalSchemaSnapshot();    }  }
@Override  public void serializeInByteBufferObject(Byte object, ByteBuffer buffer, Object... hints) {    buffer.put(object);  }
public void notifySaved(OBonsaiCollectionPointer newPointer) {    if (newPointer.isValid()) {      if (isEmbedded()) {        replaceWithSBTree(newPointer);      } else {        ((OSBTreeRidBag) delegate).setCollectionPointer(newPointer);        ((OSBTreeRidBag) delegate).clearChanges();      }    }  }
public boolean tryMerge(final ORidBag otherValue, boolean iMergeSingleItemsOfMultiValueFields) {    if (!isEmbedded() && !otherValue.isEmbedded()) {      final OSBTreeRidBag thisTree = (OSBTreeRidBag) delegate;      final OSBTreeRidBag otherTree = (OSBTreeRidBag) otherValue.delegate;      if (thisTree.getCollectionPointer().equals(otherTree.getCollectionPointer())) {        thisTree.mergeChanges(otherTree);        uuid = otherValue.uuid;        return true;      }    } else if (iMergeSingleItemsOfMultiValueFields) {      final Iterator<OIdentifiable> iter = otherValue.rawIterator();      while (iter.hasNext()) {        final OIdentifiable value = iter.next();        if (value != null) {          final Iterator<OIdentifiable> localIter = rawIterator();          boolean found = false;          while (localIter.hasNext()) {            final OIdentifiable v = localIter.next();            if (value.equals(v)) {              found = true;              break;            }          }          if (!found)            add(value);        }      }      return true;    }    return false;  }
private void replaceWithSBTree(OBonsaiCollectionPointer pointer) {    delegate.requestDelete();    final OSBTreeRidBag treeBag = new OSBTreeRidBag();    treeBag.setCollectionPointer(pointer);    treeBag.setOwner(delegate.getOwner());    for (OMultiValueChangeListener<OIdentifiable, OIdentifiable> listener : delegate.getChangeListeners())      treeBag.addChangeListener(listener);    delegate = treeBag;  }
public static Object transformResult(Object result) {    if (java8MethodIsArray == null || !(result instanceof Map)) {      return result;    }    // PATCH BY MAT ABOUT NASHORN RETURNING VALUE FOR ARRAYS.    try {      if ((Boolean) java8MethodIsArray.invoke(result)) {        List<?> partial = new ArrayList(((Map) result).values());        List<Object> finalResult = new ArrayList<Object>();        for (Object o : partial) {          finalResult.add(transformResult(o));        }        return finalResult;      } else {        Map<Object, Object> mapResult = (Map) result;        List<Object> keys = new ArrayList<Object>(mapResult.keySet());        for (Object key : keys) {          mapResult.put(key, transformResult(mapResult.get(key)));        }        return mapResult;      }    } catch (Exception e) {      OLogManager.instance().error(OCommandExecutorUtility.class, "", e);    }    return result;  }
public Object execute(final Map<Object, Object> iArgs) {    if (clusterName == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocument database = getDatabase();    final int clusterId = database.getClusterIdByName(clusterName);    if (clusterId > -1)      throw new OCommandSQLParsingException("Cluster '" + clusterName + "' already exists");    if (blob) {      if (requestedId == -1) {        return database.addBlobCluster(clusterName);      } else {        throw new OCommandExecutionException("Request id not supported by blob cluster creation.");      }    } else {      if (requestedId == -1) {        return database.addCluster(clusterName);      } else {        return database.addCluster(clusterName, requestedId, null);      }    }  }
public void close() {    lock();    try {      if (this.evictionTask != null) {        this.evictionTask.cancel();      }      for (Entry<String, OReentrantResourcePool<String, DB>> pool : pools.entrySet()) {        for (DB db : pool.getValue().getResources()) {          pool.getValue().close();          try {            OLogManager.instance().debug(this, "Closing pooled database '%s'...", db.getName());            ((ODatabasePooled) db).forceClose();            OLogManager.instance().debug(this, "OK", db.getName());          } catch (Exception e) {            OLogManager.instance().debug(this, "Error: %d", e.toString());          }        }      }    } finally {      unlock();    }  }
public void onStorageUnregistered(final OStorage iStorage) {    final String storageURL = iStorage.getURL();    lock();    try {      Set<String> poolToClose = null;      for (Entry<String, OReentrantResourcePool<String, DB>> e : pools.entrySet()) {        final int pos = e.getKey().indexOf("@");        final String dbName = e.getKey().substring(pos + 1);        if (storageURL.equals(dbName)) {          if (poolToClose == null)            poolToClose = new HashSet<String>();          poolToClose.add(e.getKey());        }      }      if (poolToClose != null)        for (String pool : poolToClose)          remove(pool);    } finally {      unlock();    }  }
public static Set<String> getFunctionNames() {    final Set<String> types = new HashSet<String>();    final Iterator<OSQLFunctionFactory> ite = getFunctionFactories();    while (ite.hasNext()) {      types.addAll(ite.next().getFunctionNames());    }    return types;  }
public static Set<String> getCollateNames() {    final Set<String> types = new HashSet<String>();    final Iterator<OCollateFactory> ite = getCollateFactories();    while (ite.hasNext()) {      types.addAll(ite.next().getNames());    }    return types;  }
public static Set<String> getCommandNames() {    final Set<String> types = new HashSet<String>();    final Iterator<OCommandExecutorSQLFactory> ite = getCommandFactories();    while (ite.hasNext()) {      types.addAll(ite.next().getCommandNames());    }    return types;  }
private Tuple<Integer, OType> getFieldSizeAndTypeFromCurrentPosition(BytesContainer bytes) {    int fieldSize = OVarIntSerializer.readAsInteger(bytes);    OType type = readOType(bytes, false);        return new Tuple<>(fieldSize, type);  }
public OHttpResponseWrapper writeStatus(final int iHttpCode, final String iReason) throws IOException {    response.writeStatus(iHttpCode, iReason);    return this;  }
public OHttpResponseWrapper writeHeaders(final String iContentType, final boolean iKeepAlive) throws IOException {    response.writeHeaders(iContentType, iKeepAlive);    return this;  }
public OHttpResponseWrapper writeRecords(final Object iRecords, final String iFetchPlan) throws IOException {    response.writeRecords(iRecords, iFetchPlan);    return this;  }
public OHttpResponseWrapper writeRecord(final ORecord iRecord, final String iFetchPlan) throws IOException {    response.writeRecord(iRecord, iFetchPlan, null);    return this;  }
public OHttpResponseWrapper send(final int iCode, final String iReason, final String iContentType, final Object iContent)      throws IOException {    response.send(iCode, iReason, iContentType, iContent, null);    return this;  }
public OHttpResponseWrapper sendStream(final int iCode, final String iReason, final String iContentType,      final InputStream iContent, final long iSize) throws IOException {    response.sendStream(iCode, iReason, iContentType, iContent, iSize);    return this;  }
@SuppressWarnings("unchecked")  @Override  public REC previous() {    checkDirection(false);    if (currentRecord != null) {      try {        return (REC) currentRecord;      } finally {        currentRecord = null;      }    }    // ITERATE UNTIL THE PREVIOUS GOOD RECORD    while (hasPrevious()) {      try {        return (REC) currentRecord;      } finally {        currentRecord = null;      }    }    return null;  }
@SuppressWarnings("unchecked")  public REC next() {    checkDirection(true);    ORecord record;    // ITERATE UNTIL THE NEXT GOOD RECORD    while (hasNext()) {      // FOUND      if (currentRecord != null) {        try {          return (REC) currentRecord;        } finally {          currentRecord = null;        }      }      record = getTransactionEntry();      if (record != null)        return (REC) record;    }    return null;  }
@Override  public ORecordIteratorCluster<REC> begin() {    browsedRecords = 0;    updateRangesOnLiveUpdate();    resetCurrentPosition();    currentRecord = readCurrentRecord(getRecord(), +1);    return this;  }
@Override  public ORecordIteratorCluster<REC> setLiveUpdated(boolean iLiveUpdated) {    super.setLiveUpdated(iLiveUpdated);    // SET THE RANGE LIMITS    if (iLiveUpdated) {      firstClusterEntry = 0L;      lastClusterEntry = Long.MAX_VALUE;    } else {      final long[] range = database.getStorage().getClusterDataRange(current.getClusterId());      firstClusterEntry = range[0];      lastClusterEntry = range[1];    }    totalAvailableRecords = database.countClusterElements(current.getClusterId());    return this;  }
public ODatabaseObject open(String name, String user, String password) {    return new OObjectDatabaseTx((ODatabaseDocumentInternal) orientDB.open(name, user, password));  }
public void create(String name, ODatabaseType type, OrientDBConfig config) {    orientDB.create(name, type, config);  }
public void setValue(Object target, Object value, OCommandContext ctx) {    if (target == null) {      return;    }    if (target.getClass().isArray()) {      setArrayValue(target, value, ctx);    } else if (target instanceof List) {      setValue((List) target, value, ctx);    } else if (OMultiValue.isMultiValue(value)) {      //TODO    }    //TODO  }
@Override  public void close() {    if (isClosed())      return;    checkOpenness();    if (ownerPool != null && ownerPool.getConnectionsInCurrentThread(getURL(), userName) > 1) {      ownerPool.release(this);      return;    }    try {      commit(true);    } catch (Exception e) {      OLogManager.instance().error(this, "Error on releasing database '%s' in pool", e, getName());    }    try {      callOnCloseListeners();    } catch (Exception e) {      OLogManager.instance().error(this, "Error on releasing database '%s' in pool", e, getName());    }    getLocalCache().clear();    if (ownerPool != null) {      final ODatabaseDocumentPool localCopy = ownerPool;      ownerPool = null;      localCopy.release(this);    }    ODatabaseRecordThreadLocal.instance().remove();  }
@Override  public UUID listenForChanges(ORidBag collection) {    UUID ownerUUID = collection.getTemporaryId();    if (ownerUUID != null) {      final OBonsaiCollectionPointer pointer = collection.getPointer();      Map<UUID, OBonsaiCollectionPointer> changedPointers = collectionPointerChanges.get();      if (pointer != null && pointer.isValid()) {        changedPointers.put(ownerUUID, pointer);      }    }    return null;  }
public synchronized void processRequest(final ODistributedRequest request, final boolean waitForAcceptingRequests) {    if (!running) {      throw new ODistributedException("Server is going down or is removing the database:'" + getDatabaseName() + "' discarding");    }    final ORemoteTask task = request.getTask();    if (waitForAcceptingRequests) {      waitIsReady(task);      if (!running) {        throw new ODistributedException("Server is going down or is removing the database:'" + getDatabaseName() + "' discarding");      }    }    totalReceivedRequests.incrementAndGet();    // final ODistributedMomentum lastMomentum = filterByMomentum.get();    // if (lastMomentum != null && task instanceof OAbstractReplicatedTask) {    // final OLogSequenceNumber taskLastLSN = ((OAbstractReplicatedTask) task).getLastLSN();    //    // final String sourceServer = manager.getNodeNameById(request.getId().getNodeId());    // final OLogSequenceNumber lastLSNFromMomentum = lastMomentum.getLSN(sourceServer);    //    // if (taskLastLSN != null && lastLSNFromMomentum != null && taskLastLSN.compareTo(lastLSNFromMomentum) < 0) {    // // SKIP REQUEST BECAUSE CONTAINS AN OLD LSN    // final String msg = String.format("Skipped request %s on database '%s' because %s < current %s", request, databaseName,    // taskLastLSN, lastLSNFromMomentum);    // ODistributedServerLog.info(this, localNodeName, null, DIRECTION.NONE, msg);    // ODistributedWorker.sendResponseBack(this, manager, request, new ODistributedException(msg));    // return;    // }    // }    final int[] partitionKeys = task.getPartitionKey();    if (ODistributedServerLog.isDebugEnabled())      ODistributedServerLog          .debug(this, localNodeName, task.getNodeSource(), DIRECTION.IN, "Request %s on database '%s' partitionKeys=%s task=%s",              request, databaseName, Arrays.toString(partitionKeys), task);    if (partitionKeys.length > 1 || partitionKeys[0] == -1) {      final Set<Integer> involvedWorkerQueues;      if (partitionKeys.length > 1)        involvedWorkerQueues = getInvolvedQueuesByPartitionKeys(partitionKeys);      else        // LOCK ALL THE QUEUES        involvedWorkerQueues = ALL_QUEUES;      // if (ODistributedServerLog.isDebugEnabled())      ODistributedServerLog          .debug(this, localNodeName, null, DIRECTION.NONE, "Request %s on database '%s' involvedQueues=%s", request, databaseName,              involvedWorkerQueues);      if (involvedWorkerQueues.size() == 1)        // JUST ONE QUEUE INVOLVED: PROCESS IT IMMEDIATELY        processRequest(involvedWorkerQueues.iterator().next(), request);      else {        // INVOLVING MULTIPLE QUEUES        // if (ODistributedServerLog.isDebugEnabled())        ODistributedServerLog.debug(this, localNodeName, null, DIRECTION.NONE,            "Request %s on database '%s' waiting for all the previous requests to be completed", request, databaseName);        CyclicBarrier started = new CyclicBarrier(involvedWorkerQueues.size());        CyclicBarrier finished = new CyclicBarrier(involvedWorkerQueues.size());        // WAIT ALL THE INVOLVED QUEUES ARE FREE AND SYNCHRONIZED        for (int queue : involvedWorkerQueues) {          ODistributedWorker worker = workerThreads.get(queue);          OWaitPartitionsReadyTask waitRequest = new OWaitPartitionsReadyTask(started, task, finished);          final ODistributedRequest syncRequest = new ODistributedRequest(null, request.getId().getNodeId(),              request.getId().getMessageId(), databaseName, waitRequest);          worker.processRequest(syncRequest);        }      }    } else if (partitionKeys.length == 1 && partitionKeys[0] == -2) {      // ANY PARTITION: USE THE FIRST EMPTY IF ANY, OTHERWISE THE FIRST IN THE LIST      boolean found = false;      for (ODistributedWorker q : workerThreads) {        if (q.isWaitingForNextRequest() && q.localQueue.isEmpty()) {          q.processRequest(request);          found = true;          break;        }      }      if (!found)        // ALL THE THREADS ARE BUSY, SELECT THE FIRST EMPTY ONE        for (ODistributedWorker q : workerThreads) {          if (q.localQueue.isEmpty()) {            q.processRequest(request);            found = true;            break;          }        }      if (!found)        // EXEC ON THE FIRST QUEUE        workerThreads.get(0).processRequest(request);    } else if (partitionKeys.length == 1 && partitionKeys[0] == -3) {      // SERVICE - LOCK      ODistributedServerLog.debug(this, localNodeName, request.getTask().getNodeSource(), DIRECTION.IN,          "Request %s on database '%s' dispatched to the lock worker", request, databaseName);      lockThread.processRequest(request);    } else if (partitionKeys.length == 1 && partitionKeys[0] == -4) {      // SERVICE - FAST_NOLOCK      ODistributedServerLog.debug(this, localNodeName, request.getTask().getNodeSource(), DIRECTION.IN,          "Request %s on database '%s' dispatched to the nowait worker", request, databaseName);      nowaitThread.processRequest(request);    } else {      processRequest(partitionKeys[0], request);    }  }
public void startComponentOperation(String componentName, ComponentType type) {    final Component currentComponent = componentsStack.peek();    if (currentComponent != null && componentName.equals(currentComponent.name)) {      currentComponent.operationCount++;      return;    }    componentsStack.push(new Component(componentName, type));  }
public void completeComponentOperation() {    final Component currentComponent = componentsStack.peek();    if (currentComponent == null)      return;    currentComponent.operationCount--;    if (currentComponent.operationCount == 0) {      final String componentName = currentComponent.name;      PerformanceCountersHolder cHolder = countersByComponent          .computeIfAbsent(componentName, k -> currentComponent.type.newCountersHolder());      cHolder.operationsCount++;      componentsStack.pop();      makeSnapshotIfNeeded(-1);    }  }
public long getReadSpeedFromCacheInPages(String componentName) {    if (componentName == null)      return performanceCountersHolder.getReadSpeedFromCacheInPages();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getReadSpeedFromCacheInPages();    return -1;  }
public long getReadSpeedFromFileInPages(String componentName) {    if (componentName == null)      return performanceCountersHolder.getReadSpeedFromFileInPages();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getReadSpeedFromFileInPages();    return -1;  }
public long getAmountOfPagesReadFromCache(String componentName) {    if (componentName == null)      return performanceCountersHolder.getAmountOfPagesReadFromCache();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getAmountOfPagesReadFromCache();    return -1;  }
public long getAmountOfPagesReadFromFile(String componentName) {    if (componentName == null)      return performanceCountersHolder.getAmountOfPagesReadFromFile();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getAmountOfPagesReadFromFile();    return -1;  }
public long getWriteSpeedInCacheInPages(String componentName) {    if (componentName == null)      return performanceCountersHolder.getWriteSpeedInCacheInPages();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getWriteSpeedInCacheInPages();    return -1;  }
public long getAmountOfPagesWrittenInCache(String componentName) {    if (componentName == null)      return performanceCountersHolder.getAmountOfPagesWrittenInCache();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getAmountOfPagesWrittenInCache();    return -1;  }
public int getCacheHits(String componentName) {    if (componentName == null)      return performanceCountersHolder.getCacheHits();    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getCacheHits();    return -1;  }
public long getAmountOfPagesPerOperation(String componentName) {    if (componentName == null) {      return -1;    }    final PerformanceCountersHolder cHolder = countersByComponent.get(componentName);    if (cHolder != null)      return cHolder.getAmountOfPagesPerOperation();    return -1;  }
public void pushComponentCounters(Map<String, PerformanceCountersHolder> counters) {    if (snapshot == null)      return;    for (Map.Entry<String, PerformanceCountersHolder> entry : snapshot.countersByComponent.entrySet()) {      final String componentName = entry.getKey();      PerformanceCountersHolder holder = counters.computeIfAbsent(componentName, k -> entry.getValue().newInstance());      entry.getValue().pushData(holder);    }  }
public WritCacheCountersHolder pushWriteCacheCounters(WritCacheCountersHolder holder) {    if (snapshot == null)      return holder;    if (snapshot.writCacheCountersHolder == null)      return holder;    if (holder == null)      holder = new WritCacheCountersHolder();    snapshot.writCacheCountersHolder.pushData(holder);    return holder;  }
public StorageCountersHolder pushStorageCounters(StorageCountersHolder holder) {    if (snapshot == null)      return holder;    if (snapshot.storageCountersHolder == null)      return holder;    if (holder == null)      holder = new StorageCountersHolder();    snapshot.storageCountersHolder.pushData(holder);    return holder;  }
public WALCountersHolder pushWALCounters(WALCountersHolder holder) {    if (snapshot == null)      return holder;    if (snapshot.walCountersHolder == null)      return holder;    if (holder == null)      holder = new WALCountersHolder();    snapshot.walCountersHolder.pushData(holder);    return holder;  }
public void pushComponentCounters(String name, PerformanceCountersHolder holder) {    if (snapshot == null)      return;    final PerformanceCountersHolder countersHolder = snapshot.countersByComponent.get(name);    if (countersHolder != null) {      countersHolder.pushData(holder);    }  }
public ODocument toDocument() {    final ODocument document = performanceCountersHolder.toDocument();    document.field("commitTime", getCommitTime(), OType.LONG);    final Map<String, ODocument> countersMap = new HashMap<>();    for (Map.Entry<String, PerformanceCountersHolder> entry : countersByComponent.entrySet()) {      countersMap.put(entry.getKey(), entry.getValue().toDocument());    }    document.field("dataByComponent", countersMap, OType.EMBEDDEDMAP);    if (walCountersHolder != null) {      final ODocument wal = walCountersHolder.toDocument();      document.field("walData", wal, OType.EMBEDDED);    }    return document;  }
public void incrementPageAccessOnCacheLevel(boolean cacheHit) {    performanceCountersHolder.cacheAccessCount++;    if (cacheHit)      performanceCountersHolder.cacheHit++;    for (Component component : componentsStack) {      final String componentName = component.name;      PerformanceCountersHolder cHolder = countersByComponent          .computeIfAbsent(componentName, k -> component.type.newCountersHolder());      cHolder.cacheAccessCount++;      if (cacheHit)        cHolder.cacheHit++;    }    makeSnapshotIfNeeded(-1);  }
public void stopWriteCacheFlushTimer(int pagesFlushed) {    // lazy initialization to prevent memory consumption    if (writCacheCountersHolder == null)      writCacheCountersHolder = new WritCacheCountersHolder();    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    writCacheCountersHolder.flushOperationsCount++;    writCacheCountersHolder.amountOfPagesFlushed += pagesFlushed;    writCacheCountersHolder.flushOperationsTime += timeDiff;    makeSnapshotIfNeeded(endTs);  }
public void stopFuzzyCheckpointTimer() {    if (writCacheCountersHolder == null)      writCacheCountersHolder = new WritCacheCountersHolder();    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    writCacheCountersHolder.fuzzyCheckpointCount++;    writCacheCountersHolder.fuzzyCheckpointTime += timeDiff;    makeSnapshotIfNeeded(endTs);  }
public void stopPageReadFromCacheTimer() {    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    performanceCountersHolder.pageReadFromCacheTime += timeDiff;    performanceCountersHolder.pageReadFromCacheCount++;    for (Component component : componentsStack) {      final String componentName = component.name;      PerformanceCountersHolder cHolder = countersByComponent          .computeIfAbsent(componentName, k -> component.type.newCountersHolder());      cHolder.pageReadFromCacheTime += timeDiff;      cHolder.pageReadFromCacheCount++;    }    final Component currentComponent = componentsStack.peek();    if (currentComponent != null) {      PerformanceCountersHolder currentHolder = countersByComponent.get(currentComponent.name);      if (currentHolder.currentOperation != null) {        currentHolder.currentOperation.incrementOperationsCounter(1, 0);      }    }    makeSnapshotIfNeeded(endTs);  }
public void stopFullCheckpointTimer() {    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    if (storageCountersHolder == null)      storageCountersHolder = new StorageCountersHolder();    storageCountersHolder.fullCheckpointOperationsCount++;    storageCountersHolder.fullCheckpointOperationsTime += timeDiff;    makeSnapshotIfNeeded(endTs);  }
public void stopPageWriteInCacheTimer() {    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    performanceCountersHolder.pageWriteToCacheTime += timeDiff;    performanceCountersHolder.pageWriteToCacheCount++;    for (Component component : componentsStack) {      final String componentName = component.name;      PerformanceCountersHolder cHolder = countersByComponent          .computeIfAbsent(componentName, k -> component.type.newCountersHolder());      cHolder.pageWriteToCacheTime += timeDiff;      cHolder.pageWriteToCacheCount++;    }    makeSnapshotIfNeeded(endTs);  }
public void stopCommitTimer() {    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    performanceCountersHolder.commitTime += timeDiff;    performanceCountersHolder.commitCount++;    makeSnapshotIfNeeded(endTs);  }
public void stopWALRecordTimer(boolean isStartRecord, boolean isStopRecord) {    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    if (walCountersHolder == null)      walCountersHolder = new WALCountersHolder();    walCountersHolder.logRecordCount++;    walCountersHolder.logRecordTime += timeDiff;    if (isStartRecord) {      walCountersHolder.startRecordCount++;      walCountersHolder.startRecordTime += timeDiff;    } else if (isStopRecord) {      walCountersHolder.stopRecordCount++;      walCountersHolder.stopRecordTime += timeDiff;    }    makeSnapshotIfNeeded(endTs);  }
public void stopWALFlushTimer() {    final long endTs = nanoTimer.getNano();    final long timeDiff = (endTs - timeStamps.pop());    if (walCountersHolder == null)      walCountersHolder = new WALCountersHolder();    walCountersHolder.flushCount++;    walCountersHolder.flushTime += timeDiff;    makeSnapshotIfNeeded(endTs);  }
private void makeSnapshotIfNeeded(long currentTime) {    if (currentTime < 0) {      currentTime = nanoTimer.getNano();    }    if (lastSnapshotTimestamp == -1)      lastSnapshotTimestamp = 0;    if (lastSnapshotTimestamp < 0 || currentTime - lastSnapshotTimestamp >= intervalBetweenSnapshots) {      snapshot = new PerformanceSnapshot(performanceCountersHolder, countersByComponent, writCacheCountersHolder,          storageCountersHolder, walCountersHolder);      lastSnapshotTimestamp = currentTime;    }    if (cleanUpInterval > 0) {      if (currentTime - lastCleanUpTimeStamp >= cleanUpInterval) {        performanceCountersHolder.clean();        for (PerformanceCountersHolder pch : countersByComponent.values()) {          pch.clean();        }        if (writCacheCountersHolder != null)          writCacheCountersHolder.clean();        if (storageCountersHolder != null)          storageCountersHolder.clean();        if (writCacheCountersHolder != null)          walCountersHolder.clean();        lastCleanUpTimeStamp = currentTime;      }    }  }
@Override  public void shutdown() {    try {      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();      if (onProfiler != null)        if (mBeanServer.isRegistered(onProfiler))          mBeanServer.unregisterMBean(onProfiler);    } catch (Exception e) {      OLogManager.instance().error(this, "OrientDB Server v" + OConstants.getVersion() + " unregisterMBean error", e);    }  }
public static OStatement get(String statement, ODatabaseDocumentInternal db) {    if (db == null) {      return parse(statement);    }    OStatementCache resource = db.getSharedContext().getStatementCache();    return resource.get(statement);  }
public OStatement get(String statement) {    OStatement result;    synchronized (map) {      //LRU      result = map.remove(statement);      if (result != null) {        map.put(statement, result);      }    }    if (result == null) {      result = parse(statement);      synchronized (map) {        map.put(statement, result);      }    }    return result;  }
protected static OStatement parse(String statement) throws OCommandSQLParsingException {    try {      ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().getIfDefined();      InputStream is;      if (db == null) {        is = new ByteArrayInputStream(statement.getBytes());      } else {        try {          is = new ByteArrayInputStream(statement.getBytes(db.getStorage().getConfiguration().getCharset()));        } catch (UnsupportedEncodingException e2) {          OLogManager.instance()              .warn(null, "Unsupported charset for database " + db + " " + db.getStorage().getConfiguration().getCharset());          is = new ByteArrayInputStream(statement.getBytes());        }      }      OrientSql osql = null;      if (db == null) {        osql = new OrientSql(is);      } else {        try {          osql = new OrientSql(is, db.getStorage().getConfiguration().getCharset());        } catch (UnsupportedEncodingException e2) {          OLogManager.instance()              .warn(null, "Unsupported charset for database " + db + " " + db.getStorage().getConfiguration().getCharset());          osql = new OrientSql(is);        }      }      OStatement result = osql.parse();      result.originalStatement = statement;      return result;    } catch (ParseException e) {      throwParsingException(e, statement);    } catch (TokenMgrError e2) {      throwParsingException(e2, statement);    }    return null;  }
protected void start() {    try {      initNetwork();      initReceiveMessages();      initDiscoveryPing();      initCheckLeader();      initCheckDisconnect();    } catch (Exception ex) {      OLogManager.instance().error(this, "Cannot start distributed node discovery: " + ex.getMessage(), ex);    }  }
protected void initReceiveMessages() throws IOException {    messageThread = new Thread(() -> {      while (!Thread.interrupted()) {        receiveMessages();      }    });    messageThread.setName("OrientDB_DistributedDiscoveryThread");    messageThread.setDaemon(true);    messageThread.start();  }
protected void initDiscoveryPing() {    discoveryTimer = new TimerTask() {      @Override      public void run() {        try {          sendPing();          if (running) {            initDiscoveryPing();          }        } catch (Exception e) {          e.printStackTrace();        }      }    };    taskScheduler.scheduleOnce(discoveryTimer, discoveryPingIntervalMillis);  }
protected void initCheckDisconnect() {    disconnectTimer = new TimerTask() {      public void run() {        try {          checkIfKnownServersAreAlive();          if (running) {            initCheckDisconnect();          }        } catch (Exception e) {          e.printStackTrace();        }      }    };    taskScheduler.scheduleOnce(disconnectTimer, discoveryPingIntervalMillis);  }
private void initCheckLeader() {    checkerTimer = new TimerTask() {      @Override      public void run() {        try {          if (running) {            checkLeader();            initCheckLeader();          }        } catch (Exception e) {          e.printStackTrace();        }      }    };    taskScheduler.scheduleOnce(checkerTimer, checkLeaderIntervalMillis);  }
protected byte[] serializeMessage(OBroadcastMessage message) throws Exception {    ByteArrayOutputStream buffer = new ByteArrayOutputStream();    message.write(new DataOutputStream(buffer));    return encrypt(buffer.toByteArray());  }
private byte[] encrypt(byte[] data) throws Exception {    if (config.getGroupPassword() == null) {      return data;    }    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");    byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();    IvParameterSpec ivSpec = new IvParameterSpec(iv);    SecretKeySpec keySpec = new SecretKeySpec(paddedPassword(config.getGroupPassword()), "AES");    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);    ByteArrayOutputStream stream = new ByteArrayOutputStream();    DataOutput output = new DataOutputStream(stream);    output.writeInt(iv.length);    output.write(iv);    byte[] cypher = cipher.doFinal(data);    output.writeInt(cypher.length);    output.write(cypher);    return stream.toByteArray();  }
void removeRecord() {    checkIfAttached();    final OrientBaseGraph graph = getGraph();    graph.setCurrentGraphInThreadLocal();    graph.autoStartTransaction();    if (checkDeletedInTx())      graph.throwRecordNotFoundException(getIdentity(), "The graph element with id " + getIdentity() + " not found");    try {      getRecord().load();    } catch (ORecordNotFoundException e) {      graph.throwRecordNotFoundException(getIdentity(), e.getMessage());    }    getRecord().delete();  }
public <T extends OrientElement> T setProperties(final Object... fields) {    if (checkDeletedInTx())      graph.throwRecordNotFoundException(getIdentity(), "The graph element " + getIdentity() + " has been deleted");    setPropertiesInternal(fields);    save();    return (T) this;  }
@Override public void setProperty(final String key, final Object value) {    if (checkDeletedInTx())      graph.throwRecordNotFoundException(getIdentity(), "The graph element " + getIdentity() + " has been deleted");    validateProperty(this, key, value);    final OrientBaseGraph graph = getGraph();    if (graph != null)      graph.autoStartTransaction();    getRecord().field(key, value);    if (graph != null)      save();  }
@Override public <T> T removeProperty(final String key) {    if (checkDeletedInTx())      throw new IllegalStateException("The vertex " + getIdentity() + " has been deleted");    final OrientBaseGraph graph = getGraph();    if (graph != null)      graph.autoStartTransaction();    final Object oldValue = getRecord().removeField(key);    if (graph != null)      save();    return (T) oldValue;  }
@Override public <T> T getProperty(final String key) {    if (key == null)      return null;    final OrientBaseGraph graph = getGraph();    if (key.equals("_class"))      return (T) ODocumentInternal.getImmutableSchemaClass(getRecord()).getName();    else if (key.equals("_version"))      return (T) new Integer(getRecord().getVersion());    else if (key.equals("_rid"))      return (T) rawElement.getIdentity().toString();    final ODocument record = getRecord();    if (record == null)      // NO RECORD      return null;    final Object fieldValue = record.field(key);    if (graph != null && fieldValue instanceof OIdentifiable && !(((OIdentifiable) fieldValue).getRecord() instanceof OBlob)) {      ODocument fieldRecord = ((OIdentifiable) fieldValue).getRecord();      if (fieldRecord != null) {        final OClass schemaClass = fieldRecord.getSchemaClass();        if (schemaClass != null && (schemaClass.isVertexType() || schemaClass.isEdgeType())) {          // CONVERT IT TO VERTEX/EDGE          return (T) graph.getElement(fieldValue);        }      }      return (T) fieldValue;    } else if (!(fieldValue instanceof Map) && OMultiValue.isMultiValue(fieldValue) && OMultiValue        .getFirstValue(fieldValue) instanceof OIdentifiable) {      final OIdentifiable firstValue = (OIdentifiable) OMultiValue.getFirstValue(fieldValue);      if (firstValue instanceof ODocument) {        final ODocument document = (ODocument) firstValue;        /// clusterId -2 Is considered a projection so does not have a class but is a not embedded record        if (document.getIdentity().getClusterId() != -2 && (document.isEmbedded()            || ODocumentInternal.getImmutableSchemaClass(document) == null))          return (T) fieldValue;      }      if (graph != null)        // CONVERT IT TO ITERABLE<VERTEX/EDGE>        return (T) new OrientElementIterable<OrientElement>(graph, OMultiValue.getMultiValueIterable(fieldValue));    }    return (T) fieldValue;  }
public void save(final String iClusterName) {    final OrientBaseGraph graph = checkIfAttached();    graph.setCurrentGraphInThreadLocal();    if (rawElement instanceof ODocument)      if (iClusterName != null)        rawElement = ((ODocument) rawElement).save(iClusterName);      else        rawElement = ((ODocument) rawElement).save();  }
@Override public OSerializableStream fromStream(final byte[] stream) throws OSerializationException {    final ODocument record = getRecord();    ((ORecordId) record.getIdentity()).fromString(new String(stream));    return this;  }
@Override public ORID getIdentity() {    if (rawElement == null)      return ORecordId.EMPTY_RECORD_ID;    final ORID rid = rawElement.getIdentity();    if (!rid.isValid()) {      final OrientBaseGraph graph = getGraph();      if (graph != null) {        // SAVE THE RECORD TO OBTAIN A VALID RID        graph.setCurrentGraphInThreadLocal();        graph.autoStartTransaction();        save();      }    }    return rid;  }
@Override public ODocument getRecord() {    if (rawElement == null)      return null;    if (rawElement instanceof ODocument)      return (ODocument) rawElement;    final ODocument doc = rawElement.getRecord();    if (doc == null)      return null;    // CHANGE THE RID -> DOCUMENT    rawElement = doc;    return doc;  }
public OrientElement detach() {    // EARLY UNMARSHALL FIELDS    getRecord().setLazyLoad(false);    getRecord().fieldNames();    // COPY GRAPH SETTINGS TO WORK OFFLINE    if (graph != null) {      settings = graph.settings.copy();      graph = null;    }    classicDetachMode = true;    return this;  }
public OrientElement attach(final OrientBaseGraph iNewGraph) {    if (iNewGraph == null)      throw new IllegalArgumentException("Graph is null");    classicDetachMode = true;    graph = iNewGraph;    // LINK THE GRAPHS SETTINGS    settings = graph.settings;    return this;  }
public OrientBaseGraph getGraph() {    if (classicDetachMode)      return graph;    OrientBaseGraph result = OrientBaseGraph.getActiveGraph();    if (result == null && this.graph != null && !graph.isClosed()) {      result = graph;    }    return result;  }
public final void validateProperty(final Element element, final String key, final Object value) throws IllegalArgumentException {    if (settings.isStandardElementConstraints() && null == value)      throw ExceptionFactory.propertyValueCanNotBeNull();    if (null == key)      throw ExceptionFactory.propertyKeyCanNotBeNull();    if (settings.isStandardElementConstraints() && key.equals(StringFactory.ID))      throw ExceptionFactory.propertyKeyIdIsReserved();    if (element instanceof Edge && key.equals(StringFactory.LABEL))      throw ExceptionFactory.propertyKeyLabelIsReservedForEdges();    if (key.isEmpty())      throw ExceptionFactory.propertyKeyCanNotBeEmpty();  }
protected String checkForClassInSchema(final String className) {    if (className == null)      return null;    OrientBaseGraph graph = getGraph();    if (graph == null)      return className;    final OSchema schema = graph.getRawGraph().getMetadata().getSchema();    if (!schema.existsClass(className)) {      // CREATE A NEW CLASS AT THE FLY      try {        graph.executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {                                 @Override public OClass call(final OrientBaseGraph g) {                                   return schema.createClass(className, schema.getClass(getBaseClassName()));                                 }                               }, "Committing the active transaction to create the new type '", className, "' as subclass of '", getBaseClassName(),            "'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction");      } catch (OSchemaException e) {        if (!schema.existsClass(className))          throw e;      }    } else {      // CHECK THE CLASS INHERITANCE      final OClass cls = schema.getClass(className);      if (!cls.isSubClassOf(getBaseClassName()))        throw new IllegalArgumentException("Class '" + className + "' is not an instance of " + getBaseClassName());    }    return className;  }
protected <T extends OrientElement> T setPropertiesInternal(final Object... fields) {    OrientBaseGraph graph = getGraph();    if (fields != null && fields.length > 0 && fields[0] != null) {      if (graph != null)        graph.autoStartTransaction();      if (fields.length == 1) {        Object f = fields[0];        if (f instanceof Map<?, ?>) {          for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) f).entrySet())            setPropertyInternal(this, (ODocument) rawElement.getRecord(), entry.getKey().toString(), entry.getValue());        } else if (f instanceof Collection) {          for (Object o : (Collection) f) {            if (!(o instanceof OPair))              throw new IllegalArgumentException(                  "Invalid fields: expecting a pairs of fields as String,Object, but found the item: " + o);            final OPair entry = (OPair) o;            setPropertyInternal(this, (ODocument) rawElement.getRecord(), entry.getKey().toString(), entry.getValue());          }        } else          throw new IllegalArgumentException(              "Invalid fields: expecting a pairs of fields as String,Object or a single Map<String,Object>, but found: " + f);      } else {        if (fields.length % 2 != 0)          throw new IllegalArgumentException(              "Invalid fields: expecting a pairs of fields as String,Object or a single Map<String,Object>, but found: " + Arrays                  .toString(fields));        // SET THE FIELDS        for (int i = 0; i < fields.length; i += 2)          setPropertyInternal(this, (ODocument) rawElement.getRecord(), fields[i].toString(), fields[i + 1]);      }    }    return (T) this;  }
public <T extends Enum<T>> T getValueAsEnum(final OGlobalConfiguration config, Class<T> enumType) {    final Object value;    if (this.config != null && this.config.containsKey(config.getKey())) {      value = this.config.get(config.getKey());    } else {      value = config.getValue();    }    if (value == null)      return null;    if (enumType.isAssignableFrom(value.getClass())) {      return enumType.cast(value);    } else if (value instanceof String) {      final String presentation = value.toString();      return Enum.valueOf(enumType, presentation);    } else {      throw new ClassCastException("Value " + value + " can not be cast to enumeration " + enumType.getSimpleName());    }  }
public static OIndexCursor wrap(OIndex<?> source, OIndexCursor cursor, long indexRebuildVersion) {    if (cursor instanceof OIndexChangesWrapper)      return cursor;    if (cursor instanceof OSizeable) {      return new OIndexChangesSizeable(source, cursor, indexRebuildVersion);    }    return new OIndexChangesWrapper(source, cursor, indexRebuildVersion);  }
@Override  public Map.Entry<Object, OIdentifiable> nextEntry() {    if (source.isRebuilding())      throwRebuildException();    final Map.Entry<Object, OIdentifiable> entry = delegate.nextEntry();    if (source.getRebuildVersion() != indexRebuildVersion)      throwRebuildException();    return entry;  }
@Override  public Set<OIdentifiable> toValues() {    if (source.isRebuilding())      throwRebuildException();    final Set<OIdentifiable> values = delegate.toValues();    if (source.getRebuildVersion() != indexRebuildVersion)      throwRebuildException();    return values;  }
@Override  public Set<Map.Entry<Object, OIdentifiable>> toEntries() {    if (source.isRebuilding())      throwRebuildException();    final Set<Map.Entry<Object, OIdentifiable>> entries = delegate.toEntries();    if (source.getRebuildVersion() != indexRebuildVersion)      throwRebuildException();    return entries;  }
@Override  public Set<Object> toKeys() {    if (source.isRebuilding())      throwRebuildException();    final Set<Object> keys = delegate.toKeys();    if (source.getRebuildVersion() != indexRebuildVersion)      throwRebuildException();    return keys;  }
@Override  public boolean hasNext() {    if (source.isRebuilding())      throwRebuildException();    final boolean isNext = delegate.hasNext();    if (source.getRebuildVersion() != indexRebuildVersion)      throwRebuildException();    return isNext;  }
@Override  public OIdentifiable next() {    if (source.isRebuilding())      throwRebuildException();    final OIdentifiable next = delegate.next();    if (source.getRebuildVersion() != indexRebuildVersion)      throwRebuildException();    return next;  }
public OGraphMLReader defineVertexAttributeStrategy(final String iAttributeName, final OGraphMLImportStrategy iStrategy) {    vertexPropsStrategy.put(iAttributeName, iStrategy);    return this;  }
public OGraphMLReader defineEdgeAttributeStrategy(final String iAttributeName, final OGraphMLImportStrategy iStrategy) {    edgePropsStrategy.put(iAttributeName, iStrategy);    return this;  }
public void inputGraph(final Graph inputGraph, final InputStream graphMLInputStream) throws IOException {    inputGraph(inputGraph, graphMLInputStream, batchSize, vertexIdKey, edgeIdKey, edgeLabelKey);  }
public void inputGraph(final Graph inputGraph, final String filename) throws IOException {    inputGraph(inputGraph, filename, batchSize, vertexIdKey, edgeIdKey, edgeLabelKey);  }
public OGraphMLReader inputGraph(final Graph inputGraph, final String filename, int bufferSize, String vertexIdKey,      String edgeIdKey, String edgeLabelKey) throws IOException {    FileInputStream fis = new FileInputStream(filename);    try {      return inputGraph(inputGraph, fis, bufferSize, vertexIdKey, edgeIdKey, edgeLabelKey);    } finally {      fis.close();    }  }
public OGraphMLReader inputGraph(final Graph inputGraph, final InputStream graphMLInputStream, int bufferSize, String vertexIdKey,      String edgeIdKey, String edgeLabelKey) throws IOException {    XMLInputFactory inputFactory = XMLInputFactory.newInstance();    try {      XMLStreamReader reader = inputFactory.createXMLStreamReader(graphMLInputStream);      final OrientBaseGraph graph = (OrientBaseGraph) inputGraph;      if (storeVertexIds)        graph.setSaveOriginalIds(storeVertexIds);      Map<String, String> keyIdMap = new HashMap<String, String>();      Map<String, String> keyTypesMaps = new HashMap<String, String>();      // <Mapped ID String, ID Object>      // <Default ID String, Mapped ID String>      Map<String, ORID> vertexMappedIdMap = new HashMap<String, ORID>();      // Buffered Vertex Data      String vertexId = null;      Map<String, Object> vertexProps = null;      boolean inVertex = false;      // Buffered Edge Data      String edgeId = null;      String edgeLabel = null;      String vertexLabel = null;      Vertex[] edgeEndVertices = null; // [0] = outVertex , [1] = inVertex      Map<String, Object> edgeProps = null;      boolean inEdge = false;      int bufferCounter = 0;      long importedVertices = 0;      long importedEdges = 0;      while (reader.hasNext()) {        Integer eventType = reader.next();        if (eventType.equals(XMLEvent.START_ELEMENT)) {          String elementName = reader.getName().getLocalPart();          if (elementName.equals(GraphMLTokens.KEY)) {            String id = reader.getAttributeValue(null, GraphMLTokens.ID);            String attributeName = reader.getAttributeValue(null, GraphMLTokens.ATTR_NAME);            String attributeType = reader.getAttributeValue(null, GraphMLTokens.ATTR_TYPE);            keyIdMap.put(id, attributeName);            keyTypesMaps.put(id, attributeType);          } else if (elementName.equals(GraphMLTokens.NODE)) {            vertexId = reader.getAttributeValue(null, GraphMLTokens.ID);            vertexLabel = reader.getAttributeValue(null, LABELS);            if (vertexLabel != null) {              if (vertexLabel.startsWith(":"))                // REMOVE : AS PREFIX                vertexLabel = vertexLabel.substring(1);              final String[] vertexLabels = vertexLabel.split(":");              // GET ONLY FIRST LABEL AS CLASS              vertexLabel = vertexId + ",class:" + vertexLabels[vertexLabelIndex];            } else              vertexLabel = vertexId;            inVertex = true;            vertexProps = new HashMap<String, Object>();          } else if (elementName.equals(GraphMLTokens.EDGE)) {            edgeId = reader.getAttributeValue(null, GraphMLTokens.ID);            edgeLabel = reader.getAttributeValue(null, GraphMLTokens.LABEL);            edgeLabel = edgeLabel == null ? GraphMLTokens._DEFAULT : edgeLabel;            String[] vertexIds = new String[2];            vertexIds[0] = reader.getAttributeValue(null, GraphMLTokens.SOURCE);            vertexIds[1] = reader.getAttributeValue(null, GraphMLTokens.TARGET);            edgeEndVertices = new Vertex[2];            for (int i = 0; i < 2; i++) { // i=0 => outVertex, i=1 => inVertex              if (vertexIdKey == null) {                edgeEndVertices[i] = null;              } else {                final Object vId = vertexMappedIdMap.get(vertexIds[i]);                edgeEndVertices[i] = vId != null ? graph.getVertex(vId) : null;              }              if (null == edgeEndVertices[i]) {                edgeEndVertices[i] = graph.addVertex(vertexLabel);                if (vertexIdKey != null) {                  mapId(vertexMappedIdMap, vertexIds[i], (ORID) edgeEndVertices[i].getId());                }                bufferCounter++;                importedVertices++;                printStatus(reader, importedVertices, importedEdges);              }            }            inEdge = true;            vertexLabel = null;            edgeProps = new HashMap<String, Object>();          } else if (elementName.equals(GraphMLTokens.DATA)) {            String key = reader.getAttributeValue(null, GraphMLTokens.KEY);            String attributeName = keyIdMap.get(key);            if (attributeName == null)              attributeName = key;            String value = reader.getElementText();            if (inVertex) {              if ((vertexIdKey != null) && (key.equals(vertexIdKey))) {                // Should occur at most once per Vertex                vertexId = value;              } else if (attributeName.equalsIgnoreCase(LABELS)) {                // IGNORE LABELS              } else {                final Object attrValue = typeCastValue(key, value, keyTypesMaps);                final OGraphMLImportStrategy strategy = vertexPropsStrategy.get(attributeName);                if (strategy != null) {                  attributeName = strategy.transformAttribute(attributeName, attrValue);                }                if (attributeName != null)                  vertexProps.put(attributeName, attrValue);              }            } else if (inEdge) {              if ((edgeLabelKey != null) && (key.equals(edgeLabelKey)))                edgeLabel = value;              else if ((edgeIdKey != null) && (key.equals(edgeIdKey)))                edgeId = value;              else {                final Object attrValue = typeCastValue(key, value, keyTypesMaps);                final OGraphMLImportStrategy strategy = edgePropsStrategy.get(attributeName);                if (strategy != null) {                  attributeName = strategy.transformAttribute(attributeName, attrValue);                }                if (attributeName != null)                  edgeProps.put(attributeName, attrValue);              }            }          }        } else if (eventType.equals(XMLEvent.END_ELEMENT)) {          String elementName = reader.getName().getLocalPart();          if (elementName.equals(GraphMLTokens.NODE)) {            ORID currentVertex = null;            if (vertexIdKey != null)              currentVertex = vertexMappedIdMap.get(vertexId);            if (currentVertex == null) {              final OrientVertex v = graph.addVertex(vertexLabel, vertexProps);              if (vertexIdKey != null)                mapId(vertexMappedIdMap, vertexId, v.getIdentity());              bufferCounter++;              importedVertices++;              printStatus(reader, importedVertices, importedEdges);            } else {              // UPDATE IT              final OrientVertex v = graph.getVertex(currentVertex);              v.setProperties(vertexProps);            }            vertexId = null;            vertexLabel = null;            vertexProps = null;            inVertex = false;          } else if (elementName.equals(GraphMLTokens.EDGE)) {            Edge currentEdge = ((OrientVertex) edgeEndVertices[0]).addEdge(null, (OrientVertex) edgeEndVertices[1], edgeLabel, null,                edgeProps);            bufferCounter++;            importedEdges++;            printStatus(reader, importedVertices, importedEdges);            edgeId = null;            edgeLabel = null;            edgeEndVertices = null;            edgeProps = null;            inEdge = false;          }        }        if (bufferCounter > bufferSize) {          graph.commit();          bufferCounter = 0;        }      }      reader.close();      graph.commit();    } catch (Exception xse) {      throw OException.wrapException(new ODatabaseImportException("Error on importing GraphML"), xse);    }    return this;  }
public OGraphMLReader inputGraph(final InputStream graphMLInputStream) throws IOException {    return inputGraph(this.graph, graphMLInputStream, batchSize, this.vertexIdKey, this.edgeIdKey, this.edgeLabelKey);  }
public OGraphMLReader inputGraph(final String filename) throws IOException {    return inputGraph(this.graph, filename, batchSize, this.vertexIdKey, this.edgeIdKey, this.edgeLabelKey);  }
@Override  public void serializeInByteBufferObject(Date object, ByteBuffer buffer, Object... hints) {    final Calendar calendar = Calendar.getInstance();    calendar.setTime(object);    calendar.set(Calendar.HOUR_OF_DAY, 0);    calendar.set(Calendar.MINUTE, 0);    calendar.set(Calendar.SECOND, 0);    calendar.set(Calendar.MILLISECOND, 0);    final ODateTimeSerializer dateTimeSerializer = ODateTimeSerializer.INSTANCE;    dateTimeSerializer.serializeInByteBufferObject(calendar.getTime(), buffer);  }
@Override  public Date deserializeFromByteBufferObject(ByteBuffer buffer) {    final ODateTimeSerializer dateTimeSerializer = ODateTimeSerializer.INSTANCE;    return dateTimeSerializer.deserializeFromByteBufferObject(buffer);  }
@Override  public Date deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final ODateTimeSerializer dateTimeSerializer = ODateTimeSerializer.INSTANCE;    return dateTimeSerializer.deserializeFromByteBufferObject(buffer, walChanges, offset);  }
public List<ORecordOperation> getNewRecordEntriesByClass(final OClass iClass, final boolean iPolymorphic) {    final List<ORecordOperation> result = new ArrayList<ORecordOperation>();    if (iClass == null)      // RETURN ALL THE RECORDS      for (ORecordOperation entry : allEntries.values()) {        if (entry.type == ORecordOperation.CREATED)          result.add(entry);      }    else {      // FILTER RECORDS BY CLASSNAME      for (ORecordOperation entry : allEntries.values()) {        if (entry.type == ORecordOperation.CREATED)          if (entry.getRecord() != null && entry.getRecord() instanceof ODocument) {            if (iPolymorphic) {              if (iClass.isSuperClassOf(((ODocument) entry.getRecord()).getSchemaClass()))                result.add(entry);            } else if (iClass.getName().equals(((ODocument) entry.getRecord()).getClassName()))              result.add(entry);          }      }    }    return result;  }
public List<ORecordOperation> getNewRecordEntriesByClusterIds(final int[] iIds) {    final List<ORecordOperation> result = new ArrayList<ORecordOperation>();    if (iIds == null)      // RETURN ALL THE RECORDS      for (ORecordOperation entry : allEntries.values()) {        if (entry.type == ORecordOperation.CREATED)          result.add(entry);      }    else      // FILTER RECORDS BY ID      for (ORecordOperation entry : allEntries.values()) {        for (int id : iIds) {          if (entry.getRecord() != null && entry.getRecord().getIdentity().getClusterId() == id              && entry.type == ORecordOperation.CREATED) {            result.add(entry);            break;          }        }      }    return result;  }
public void addIndexEntry(final OIndex<?> delegate, final String iIndexName, final OTransactionIndexChanges.OPERATION iOperation,      final Object key, final OIdentifiable iValue, boolean clientTrackOnly) {    OTransactionIndexChanges indexEntry = indexEntries.get(iIndexName);    if (indexEntry == null) {      indexEntry = new OTransactionIndexChanges();      indexEntries.put(iIndexName, indexEntry);    }    if (iOperation == OPERATION.CLEAR)      indexEntry.setCleared();    else {      OTransactionIndexChangesPerKey changes = indexEntry.getChangesPerKey(key);      changes.clientTrackOnly = clientTrackOnly;      changes.add(iValue, iOperation);      if (iValue == null)        return;      List<OTransactionRecordIndexOperation> transactionIndexOperations = recordIndexOperations.get(iValue.getIdentity());      if (transactionIndexOperations == null) {        transactionIndexOperations = new ArrayList<OTransactionRecordIndexOperation>();        recordIndexOperations.put(iValue.getIdentity().copy(), transactionIndexOperations);      }      transactionIndexOperations.add(new OTransactionRecordIndexOperation(iIndexName, key, iOperation));    }  }
private static Set<ORecord> mergeSet(Set<ORecord> target, Set<ORecord> source) {    if (source != null) {      if (target == null) {        return source;      } else {        if (target.size() > source.size()) {          target.addAll(source);          return target;        } else {          source.addAll(target);          return source;        }      }    } else {      return target;    }  }
public String authenticate(final String username, final String password) {    String principal = null;    try {      if (getServerConfig() != null) {        OServerUserConfiguration userCfg = null;        // This will throw an IllegalArgumentException if username is null or empty.        // However, a null or empty username is possible with some security implementations.        if (username != null && !username.isEmpty())          userCfg = getServerConfig().getUser(username);        if (userCfg != null && userCfg.password != null) {          if (OSecurityManager.instance().checkPassword(password, userCfg.password)) {            principal = userCfg.name;          }        }      } else {        OLogManager.instance().error(this, "OServerConfigAuthenticator.authenticate() ServerConfig is null", null);      }    } catch (Exception ex) {      OLogManager.instance().error(this, "OServerConfigAuthenticator.authenticate()", ex);    }    return principal;  }
public void config(final OServer oServer, final OServerConfigurationManager serverCfg, final ODocument jsonConfig) {    super.config(oServer, serverCfg, jsonConfig);  }
public OServerUserConfiguration getUser(final String username) {    OServerUserConfiguration userCfg = null;    if (getServerConfig() != null) {      userCfg = getServerConfig().getUser(username);    }    return userCfg;  }
public boolean isAuthorized(final String username, final String resource) {    if (username == null || resource == null)      return false;    if (getServerConfig() != null) {      // getUser() will throw an IllegalArgumentException if username is null or empty.      // However, a null or empty username is possible with some security implementations.      if (!username.isEmpty()) {        OServerUserConfiguration userCfg = getServerConfig().getUser(username);        if (userCfg != null) {          // Total Access          if (userCfg.resources.equals("*"))            return true;          String[] resourceParts = userCfg.resources.split(",");          for (String r : resourceParts) {            if (r.equalsIgnoreCase(resource))              return true;          }        }      }    } else {      OLogManager.instance().error(this, "OServerConfigAuthenticator.isAuthorized() ServerConfig is null", null);    }    return false;  }
@SuppressWarnings("unchecked") public boolean result(final Object iRecord) {    final ODocument record = ((OIdentifiable) iRecord).getRecord();    if (isUpdateEdge() && !isRecordInstanceOf(iRecord, "E")) {      throw new OCommandExecutionException("Using UPDATE EDGE on a record that is not an instance of E");    }    if (compiledFilter != null) {      // ADDITIONAL FILTERING      if (!(Boolean) compiledFilter.evaluate(record, null, context))        return false;    }    parameters.reset();    returnHandler.beforeUpdate(record);    boolean updated = handleContent(record);    updated |= handleMerge(record);    updated |= handleSetEntries(record);    updated |= handleIncrementEntries(record);    updated |= handleAddEntries(record);    updated |= handlePutEntries(record);    updated |= handleRemoveEntries(record);    if (updated) {      handleUpdateEdge(record);      record.setDirty();      record.save();      returnHandler.afterUpdate(record);      this.updated = true;    }    return true;  }
private void handleUpdateEdge(ODocument record) {    if (!updateEdge) {      return;    }    Object currentOut = record.field("out");    Object currentIn = record.field("in");    Object prevOut = record.getOriginalValue("out");    Object prevIn = record.getOriginalValue("in");    validateOutInForEdge(record, currentOut, currentIn);    changeVertexEdgePointer(record, (OIdentifiable) prevIn, (OIdentifiable) currentIn, "in");    changeVertexEdgePointer(record, (OIdentifiable) prevOut, (OIdentifiable) currentOut, "out");  }
protected void parseReturn() throws OCommandSQLParsingException {    parserNextWord(false, " ");    String mode = parserGetLastWord().trim();    if (mode.equalsIgnoreCase("COUNT")) {      returnHandler = new ORecordCountHandler();    } else if (mode.equalsIgnoreCase("BEFORE") || mode.equalsIgnoreCase("AFTER")) {      parserNextWord(false, " ");      String returning = parserGetLastWord().trim();      Object returnExpression = null;      if (returning.equalsIgnoreCase(KEYWORD_WHERE) || returning.equalsIgnoreCase(KEYWORD_TIMEOUT) || returning          .equalsIgnoreCase(KEYWORD_LIMIT) || returning.equalsIgnoreCase(KEYWORD_UPSERT) || returning.equalsIgnoreCase(KEYWORD_LOCK)          || returning.length() == 0) {        parserGoBack();      } else {        if (returning.startsWith("$") || returning.startsWith("@"))          returnExpression = (returning.length() > 0) ? OSQLHelper.parseValue(this, returning, this.getContext()) : null;        else          throwSyntaxErrorException("record attribute (@attributes) or functions with $current variable expected");      }      if (mode.equalsIgnoreCase("BEFORE"))        returnHandler = new OOriginalRecordsReturnHandler(returnExpression, getContext());      else        returnHandler = new OUpdatedRecordsReturnHandler(returnExpression, getContext());    } else      throwSyntaxErrorException(" COUNT | BEFORE | AFTER keywords expected");  }
public Iterable<OIdentifiable> executeIndexedFunction(OFromClause target, OCommandContext ctx, OBinaryCompareOperator operator,      Object rightValue) {    OSQLFunction function = OSQLEngine.getInstance().getFunction(name.getStringValue());    if (function instanceof OIndexableSQLFunction) {      return ((OIndexableSQLFunction) function)          .searchFromTarget(target, operator, rightValue, ctx, this.getParams().toArray(new OExpression[] {}));    }    return null;  }
public long estimateIndexedFunction(OFromClause target, OCommandContext ctx, OBinaryCompareOperator operator, Object rightValue) {    OSQLFunction function = OSQLEngine.getInstance().getFunction(name.getStringValue());    if (function instanceof OIndexableSQLFunction) {      return ((OIndexableSQLFunction) function)          .estimate(target, operator, rightValue, ctx, this.getParams().toArray(new OExpression[] {}));    }    return -1;  }
public boolean canExecuteIndexedFunctionWithoutIndex(OFromClause target, OCommandContext context, OBinaryCompareOperator operator,      Object right) {    OSQLFunction function = OSQLEngine.getInstance().getFunction(name.getStringValue());    if (function instanceof OIndexableSQLFunction) {      return ((OIndexableSQLFunction) function)          .canExecuteInline(target, operator, right, context, this.getParams().toArray(new OExpression[] {}));    }    return false;  }
@Override  public void serializeInByteBufferObject(OIndexRIDContainer object, ByteBuffer buffer, Object... hints) {    buffer.putLong(object.getFileId());    final boolean embedded = object.isEmbedded();    final boolean durable = object.isDurableNonTxMode();    buffer.put((byte) (embedded ? 1 : 0));    buffer.put((byte) (durable ? 1 : 0));    if (embedded) {      buffer.putInt(object.size());      for (OIdentifiable ids : object) {        LINK_SERIALIZER.serializeInByteBufferObject(ids, buffer);      }    } else {      final OIndexRIDContainerSBTree underlying = (OIndexRIDContainerSBTree) object.getUnderlying();      final OBonsaiBucketPointer rootPointer = underlying.getRootPointer();      buffer.putLong(rootPointer.getPageIndex());      buffer.putInt(rootPointer.getPageOffset());    }  }
@Override  public OIndexRIDContainer deserializeFromByteBufferObject(ByteBuffer buffer) {    final long fileId = buffer.getLong();    final boolean embedded = buffer.get() > 0;    final boolean durable = buffer.get() > 0;    if (embedded) {      final int size = buffer.getInt();      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));      for (int i = 0; i < size; i++) {        underlying.add(LINK_SERIALIZER.deserializeFromByteBufferObject(buffer));      }      return new OIndexRIDContainer(fileId, underlying, durable);    } else {      final long pageIndex = buffer.getLong();      final int pageOffset = buffer.getInt();      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().get();      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer,          (OAbstractPaginatedStorage) db.getStorage().getUnderlying());      return new OIndexRIDContainer(fileId, underlying, durable);    }  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer) {    final int offset = buffer.position();    buffer.position();    if (buffer.get(offset + EMBEDDED_OFFSET) > 0) {      return embeddedObjectSerializedSize(buffer.getInt(offset + EMBEDDED_SIZE_OFFSET));    } else {      return SBTREE_CONTAINER_SIZE;    }  }
@Override  public OIndexRIDContainer deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final long fileId = walChanges.getLongValue(buffer, offset + FILE_ID_OFFSET);    final boolean durable = walChanges.getByteValue(buffer, offset + DURABLE_OFFSET) > 0;    if (walChanges.getByteValue(buffer, offset + EMBEDDED_OFFSET) > 0) {      final int size = walChanges.getIntValue(buffer, offset + EMBEDDED_SIZE_OFFSET);      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));      int p = offset + EMBEDDED_VALUES_OFFSET;      for (int i = 0; i < size; i++) {        underlying.add(LINK_SERIALIZER.deserializeFromByteBufferObject(buffer, walChanges, p));        p += RID_SIZE;      }      return new OIndexRIDContainer(fileId, underlying, durable);    } else {      final long pageIndex = walChanges.getLongValue(buffer, offset + SBTREE_ROOTINDEX_OFFSET);      final int pageOffset = walChanges.getIntValue(buffer, offset + SBTREE_ROOTOFFSET_OFFSET);      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.instance().get();      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer,          (OAbstractPaginatedStorage) db.getStorage().getUnderlying());      return new OIndexRIDContainer(fileId, underlying, durable);    }  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer, OWALChanges walChanges, int offset) {    if (walChanges.getByteValue(buffer, offset + EMBEDDED_OFFSET) > 0) {      return embeddedObjectSerializedSize(walChanges.getIntValue(buffer, offset + EMBEDDED_SIZE_OFFSET));    } else {      return SBTREE_CONTAINER_SIZE;    }  }
public ODatabaseSession open(String database, String user, String password) {    return open(database, user, password, OrientDBConfig.defaultConfig());  }
public ODatabaseSession open(String database, String user, String password, OrientDBConfig config) {    return internal.open(database, user, password, config);  }
public void create(String database, ODatabaseType type) {    create(database, type, OrientDBConfig.defaultConfig());  }
public void create(String database, ODatabaseType type, OrientDBConfig config) {    this.internal.create(database, serverUser, serverPassword, type, config);  }
public boolean createIfNotExists(String database, ODatabaseType type) {    return createIfNotExists(database, type, OrientDBConfig.defaultConfig());  }
public boolean createIfNotExists(String database, ODatabaseType type, OrientDBConfig config) {    if (!this.internal.exists(database, serverUser, serverPassword)) {      this.internal.create(database, serverUser, serverPassword, type, config);      return true;    }    return false;  }
public static <T> Collection<OChainedIndexProxy<T>> createProxies(OClass iSchemaClass, OSQLFilterItemField.FieldChain longChain) {    List<OChainedIndexProxy<T>> proxies = new ArrayList<OChainedIndexProxy<T>>();    for (List<OIndex<?>> indexChain : getIndexesForChain(iSchemaClass, longChain)) {      proxies.add(new OChainedIndexProxy<T>(indexChain));    }    return proxies;  }
protected static OIndex<?> findBestIndex(Iterable<OIndex<?>> indexes) {    OIndex<?> bestIndex = null;    for (OIndex<?> index : indexes) {      if (priorityOfUsage(index) > priorityOfUsage(bestIndex))        bestIndex = index;    }    return bestIndex;  }
@Override  public long getRebuildVersion() {    long rebuildVersion = 0;    for (OIndex<?> index : indexChain) {      rebuildVersion += index.getRebuildVersion();    }    return rebuildVersion;  }
@Override  public T get(Object iKey) {    final Object lastIndexResult = lastIndex.get(iKey);    final Set<OIdentifiable> result = new HashSet<OIdentifiable>();    if (lastIndexResult != null)      result.addAll(applyTailIndexes(lastIndexResult));    return (T) result;  }
private Set<Comparable> prepareKeys(OIndex<?> index, Object keys) {    final OIndexDefinition indexDefinition = index.getDefinition();    if (keys instanceof Collection) {      final Set<Comparable> newKeys = new TreeSet<Comparable>();      for (Object o : ((Collection) keys)) {        newKeys.add((Comparable) indexDefinition.createValue(o));      }      return newKeys;    } else {      return Collections.singleton((Comparable) indexDefinition.createValue(keys));    }  }
private void updateStatistic(OIndex<?> index) {    final OProfiler profiler = Orient.instance().getProfiler();    if (profiler.isRecording()) {      Orient.instance().getProfiler()          .updateCounter(profiler.getDatabaseMetric(index.getDatabaseName(), "query.indexUsed"), "Used index in query", +1);      final int paramCount = index.getDefinition().getParamCount();      if (paramCount > 1) {        final String profiler_prefix = profiler.getDatabaseMetric(index.getDatabaseName(), "query.compositeIndexUsed");        profiler.updateCounter(profiler_prefix, "Used composite index in query", +1);        profiler            .updateCounter(profiler_prefix + "." + paramCount, "Used composite index in query with " + paramCount + " params", +1);      }    }  }
void writePage(ByteBuffer page, long pageIndex) throws IOException {    synchronized (lockObject) {      lastAccessTime = System.nanoTime();      if (pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache.size()) {        if (pageIndex < firstCachedPage + pageCache.size()) {          pageCache.set((int) (pageIndex - firstCachedPage), page);        } else {          pageCache.add(page);        }      } else if (pageCache.isEmpty()) {        pageCache.add(page);        firstCachedPage = pageIndex;      }      lastWrittenPage = page;      lastWrittenPageIndex = pageIndex;      if (pageCache.size() * OWALPage.PAGE_SIZE >= bufferSize + OWALPage.PAGE_SIZE) {        flushAllBufferPagesExceptLastOne();      }    }  }
byte[] readPage(long pageIndex) throws IOException {    synchronized (lockObject) {      lastAccessTime = System.nanoTime();      if (pageIndex == lastWrittenPageIndex) {        return lastWrittenPage.array();      }      if (pageIndex >= firstCachedPage && pageIndex < firstCachedPage + pageCache.size()) {        final ByteBuffer buffer = pageCache.get((int) (pageIndex - firstCachedPage));        return buffer.array();      }      final ByteBuffer buffer = ByteBuffer.allocate(OWALPage.PAGE_SIZE).order(ByteOrder.nativeOrder());      initFile();      segChannel.position(pageIndex * OWALPage.PAGE_SIZE);      readByteBuffer(buffer, segChannel);      return buffer.array();    }  }
void truncate(long pageIndex) throws IOException {    synchronized (lockObject) {      lastAccessTime = System.nanoTime();      flushBuffer();      lastWrittenPageIndex = -1;      lastWrittenPage = null;      segChannel.truncate(pageIndex * OWALPage.PAGE_SIZE);    }  }
ByteBuffer readPageBuffer(long pageIndex) throws IOException {    synchronized (lockObject) {      lastAccessTime = System.nanoTime();      if (pageIndex == lastWrittenPageIndex) {        final ByteBuffer copy = ByteBuffer.allocate(OWALPage.PAGE_SIZE).order(ByteOrder.nativeOrder());        lastWrittenPage.position(0);        copy.put(lastWrittenPage);        return copy;      }      if (pageIndex >= firstCachedPage && pageIndex < firstCachedPage + pageCache.size()) {        final ByteBuffer buffer = pageCache.get((int) (pageIndex - firstCachedPage));        final ByteBuffer copy = ByteBuffer.allocate(OWALPage.PAGE_SIZE).order(ByteOrder.nativeOrder());        buffer.position(0);        copy.put(buffer);        return copy;      }      final ByteBuffer buffer = ByteBuffer.allocate(OWALPage.PAGE_SIZE).order(ByteOrder.nativeOrder());      initFile();      segChannel.position(pageIndex * OWALPage.PAGE_SIZE);      readByteBuffer(buffer, segChannel);      buffer.position(0);      return buffer;    }  }
public void sync() throws IOException {    synchronized (lockObject) {      if (segChannel != null) {        lastAccessTime = System.nanoTime();        flushBuffer();        segChannel.force(false);      }    }  }
public void close(boolean flush) {    closer.shutdown();    try {      if (!closer.awaitTermination(CLOSER_TIMEOUT_MIN, TimeUnit.MINUTES)) {        OLogManager.instance().error(this, "Can not close file " + path.getFileName(), null);      } else {        synchronized (lockObject) {          try {            if (segChannel != null) {              closeFile(flush);            }          } catch (IOException ioe) {            OLogManager.instance().error(this, "Can not close file " + path.getFileName(), ioe);          }        }      }    } catch (InterruptedException ie) {      OLogManager.instance().warn(this, "WAL file " + path.getFileName() + " close was interrupted", ie);    }  }
public void open() throws IOException {    synchronized (lockObject) {      lastAccessTime = System.nanoTime();      initFile();      long pagesCount = segChannel.size() / OWALPage.PAGE_SIZE;      if (segChannel.size() % OWALPage.PAGE_SIZE > 0) {        OLogManager.instance().error(this, "Last WAL page was written partially, auto fix", null);        segChannel.truncate(OWALPage.PAGE_SIZE * pagesCount);      }      firstCachedPage = -1;      pageCache.clear();      lastWrittenPage = null;      lastWrittenPageIndex = -1;    }  }
@Override  public byte[] getRecord(int position) {    buffer.position(position + 2);    final int recordSize = buffer.getInt();    final byte[] record = new byte[recordSize];    buffer.get(record);    return record;  }
public boolean isReplicationActive(final String iClusterName, final String iLocalNode) {    final Collection<String> servers = getClusterConfiguration(iClusterName).field(SERVERS);    if (servers != null && !servers.isEmpty()) {      return true;    }    return false;  }
public NEW_NODE_STRATEGIES getNewNodeStrategy() {    final String value = configuration.field(NEW_NODE_STRATEGY);    if (value != null)      return NEW_NODE_STRATEGIES.valueOf(value.toUpperCase(Locale.ENGLISH));    return NEW_NODE_STRATEGIES.STATIC;  }
public Boolean isExecutionModeSynchronous(final String iClusterName) {    Object value = getClusterConfiguration(iClusterName).field(EXECUTION_MODE);    if (value == null) {      value = configuration.field(EXECUTION_MODE);      if (value == null)        return null;    }    if (value.toString().equalsIgnoreCase("undefined"))      return null;    return value.toString().equalsIgnoreCase(EXECUTION_MODE_SYNCHRONOUS);  }
public Boolean isReadYourWrites(final String iClusterName) {    Object value = getClusterConfiguration(iClusterName).field(READ_YOUR_WRITES);    if (value == null) {      value = configuration.field(READ_YOUR_WRITES);      if (value == null) {        OLogManager.instance()            .warn(this, "%s setting not found for cluster=%s in distributed-config.json", READ_YOUR_WRITES, iClusterName);        return true;      }    }    return (Boolean) value;  }
public Map<String, Collection<String>> getServerClusterMap(Collection<String> iClusterNames, final String iLocalNode,      final boolean optimizeForLocalOnly) {    if (iClusterNames == null || iClusterNames.isEmpty())      iClusterNames = DEFAULT_CLUSTER_NAME;    final Map<String, Collection<String>> servers = new HashMap<String, Collection<String>>(iClusterNames.size());    // TRY TO SEE IF IT CAN BE EXECUTED ON LOCAL NODE ONLY    boolean canUseLocalNode = true;    for (String p : iClusterNames) {      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);      if (serverList != null && !serverList.contains(iLocalNode)) {        canUseLocalNode = false;        break;      }    }    if (optimizeForLocalOnly && canUseLocalNode) {      // USE LOCAL NODE ONLY (MUCH FASTER)      servers.put(iLocalNode, iClusterNames);      return servers;    }// GROUP BY SERVER WITH THE NUMBER OF CLUSTERS    final Map<String, Collection<String>> serverMap = new HashMap<String, Collection<String>>();    for (String p : iClusterNames) {      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);      for (String s : serverList) {        if (NEW_NODE_TAG.equalsIgnoreCase(s))          continue;        Collection<String> clustersInServer = serverMap.get(s);        if (clustersInServer == null) {          clustersInServer = new HashSet<String>();          serverMap.put(s, clustersInServer);        }        clustersInServer.add(p);      }    }    if (serverMap.size() == 1)      // RETURN THE ONLY SERVER INVOLVED      return serverMap;    if (!optimizeForLocalOnly)      return serverMap;// ORDER BY NUMBER OF CLUSTERS    final List<String> orderedServers = new ArrayList<String>(serverMap.keySet());    Collections.sort(orderedServers, new Comparator<String>() {      @Override      public int compare(final String o1, final String o2) {        return ((Integer) serverMap.get(o2).size()).compareTo((Integer) serverMap.get(o1).size());      }    });// BROWSER ORDERED SERVER MAP PUTTING THE MINIMUM SERVER TO COVER ALL THE CLUSTERS    final Set<String> remainingClusters = new HashSet<String>(iClusterNames); // KEEPS THE REMAINING CLUSTER TO ADD IN FINAL// RESULT    final Set<String> includedClusters = new HashSet<String>(iClusterNames.size()); // KEEPS THE COLLECTION OF ALREADY INCLUDED    // CLUSTERS    for (String s : orderedServers) {      final Collection<String> clusters = serverMap.get(s);      if (!servers.isEmpty()) {        // FILTER CLUSTER LIST AVOIDING TO REPEAT CLUSTERS ALREADY INCLUDED ON PREVIOUS NODES        clusters.removeAll(includedClusters);      }      servers.put(s, clusters);      remainingClusters.removeAll(clusters);      includedClusters.addAll(clusters);      if (remainingClusters.isEmpty())        // FOUND ALL CLUSTERS        break;    }    return servers;  }
public List<String> getOwnedClustersByServer(Collection<String> iClusterNames, final String iNode) {    if (iClusterNames == null || iClusterNames.isEmpty())      iClusterNames = DEFAULT_CLUSTER_NAME;    final List<String> notDefinedClusters = new ArrayList<String>(5);    final List<String> candidates = new ArrayList<String>(5);    for (String p : iClusterNames) {      if (p == null)        continue;      final String ownerServer = getClusterOwner(p);      if (ownerServer == null)        notDefinedClusters.add(p);      else if (iNode.equals(ownerServer)) {        // COLLECT AS CANDIDATE        candidates.add(p);      }    }    if (!candidates.isEmpty())      // RETURN THE FIRST ONE      return candidates;    final String owner = getClusterOwner(ALL_WILDCARD);    if (iNode.equals(owner))      // CURRENT SERVER IS MASTER OF DEFAULT: RETURN ALL THE NON CONFIGURED CLUSTERS      return notDefinedClusters;    // NO MASTER FOUND, RETURN EMPTY LIST    return candidates;  }
public Set<String> getServers(Collection<String> iClusterNames) {    if (iClusterNames == null || iClusterNames.isEmpty())      return getAllConfiguredServers();    final Set<String> partitions = new HashSet<String>(iClusterNames.size());    for (String p : iClusterNames) {      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);      if (serverList != null) {        for (String s : serverList)          if (!s.equals(NEW_NODE_TAG))            partitions.add(s);      }    }    return partitions;  }
public boolean isServerContainingAllClusters(final String server, Collection<String> clusters) {    if (clusters == null || clusters.isEmpty())      clusters = DEFAULT_CLUSTER_NAME;    for (String cluster : clusters) {      final List<String> serverList = getClusterConfiguration(cluster).field(SERVERS);      if (serverList != null) {        if (!serverList.contains(server))          return false;      }    }    return true;  }
public boolean isServerContainingCluster(final String server, String cluster) {    if (cluster == null)      cluster = ALL_WILDCARD;    final List<String> serverList = getClusterConfiguration(cluster).field(SERVERS);    if (serverList != null) {      return serverList.contains(server);    }    return true;  }
public List<String> getServers(final String iClusterName, final String iExclude) {    final List<String> serverList = getClusterConfiguration(iClusterName).field(SERVERS);    if (serverList != null) {      // COPY AND REMOVE ANY NEW_NODE_TAG      List<String> filteredServerList = new ArrayList<String>(serverList.size());      for (String s : serverList) {        if (!s.equals(NEW_NODE_TAG) && (iExclude == null || !iExclude.equals(s)))          filteredServerList.add(s);      }      return filteredServerList;    }    return Collections.EMPTY_LIST;  }
public List<String> getMasterServers() {    final List<String> serverList = getClusterConfiguration(null).field(SERVERS);    if (serverList != null) {      // COPY AND REMOVE ANY NEW_NODE_TAG      List<String> masters = new ArrayList<String>(serverList.size());      for (String s : serverList) {        if (!s.equals(NEW_NODE_TAG))          masters.add(s);      }      final ROLES defRole = getDefaultServerRole();      final ODocument servers = configuration.field(SERVERS);      if (servers != null) {        for (Iterator<String> it = masters.iterator(); it.hasNext(); ) {          final String server = it.next();          final String roleAsString = servers.field(server);          final ROLES role = roleAsString != null ? ROLES.valueOf(roleAsString.toUpperCase(Locale.ENGLISH)) : defRole;          if (role != ROLES.MASTER)            it.remove();        }      }      return masters;    }    return Collections.EMPTY_LIST;  }
public Set<String> getAllConfiguredServers() {    final Set<String> servers = new HashSet<String>();    for (String p : getClusterNames()) {      final List<String> serverList = getClusterConfiguration(p).field(SERVERS);      if (serverList != null) {        for (String s : serverList)          if (!s.equals(NEW_NODE_TAG))            servers.add(s);      }    }    return servers;  }
public Set<String> getClustersOnServer(final String iNodeName) {    final Set<String> clusters = new HashSet<String>();    for (String cl : getClusterNames()) {      final List<String> servers = getServers(cl, null);      if (servers.contains(iNodeName))        clusters.add(cl);    }    return clusters;  }
public Set<String> getClustersOwnedByServer(final String iNodeName) {    final Set<String> clusters = new HashSet<String>();    for (String cl : getClusterNames()) {      if (iNodeName.equals(getClusterOwner(cl)))        clusters.add(cl);    }    return clusters;  }
public String getClusterOwner(final String iClusterName) {    String owner;    final ODocument clusters = getConfiguredClusters();    // GET THE CLUSTER CFG    final ODocument cfg = iClusterName != null ? (ODocument) clusters.field(iClusterName) : null;    if (cfg != null) {      owner = cfg.field(OWNER);      if (owner != null)        return owner;      final List<String> serverList = cfg.field(SERVERS);      if (serverList != null && !serverList.isEmpty()) {        // RETURN THE FIRST ONE        owner = serverList.get(0);        if (NEW_NODE_TAG.equals(owner) && serverList.size() > 1)          // DON'T RETURN <NEW_NODE>          owner = serverList.get(1);      }    } else      // RETURN THE OWNER OF *      return getClusterOwner(ALL_WILDCARD);    return owner;  }
public String getConfiguredClusterOwner(final String iClusterName) {    String owner = null;    final ODocument clusters = getConfiguredClusters();    // GET THE CLUSTER CFG    final ODocument cfg = clusters.field(iClusterName);    if (cfg != null)      owner = cfg.field(OWNER);    return owner;  }
public List<String> getConfiguredServers(final String iClusterName) {    final Collection<? extends String> list = (Collection<? extends String>) getClusterConfiguration(iClusterName).field(SERVERS);    return list != null ? new ArrayList<String>(list) : null;  }
public ROLES getServerRole(final String iServerName) {    final ODocument servers = configuration.field(SERVERS);    if (servers == null)      // DEFAULT: MASTER      return ROLES.MASTER;    String role = servers.field(iServerName);    if (role == null) {      // DEFAULT: MASTER      role = servers.field(ALL_WILDCARD);      if (role == null)        // DEFAULT: MASTER        return ROLES.MASTER;    }    return ROLES.valueOf(role.toUpperCase(Locale.ENGLISH));  }
public Set<String> getRegisteredServers() {    final ODocument servers = configuration.field(SERVERS);    final Set<String> result = new HashSet<String>();    if (servers != null)      for (String s : servers.fieldNames())        result.add(s);    return result;  }
public Set<String> getDataCenters() {    final ODocument dcs = configuration.field(DCS);    if (dcs == null)      return Collections.EMPTY_SET;    final Set<String> result = new HashSet<String>();    for (String dc : dcs.fieldNames()) {      result.add(dc);    }    return result;  }
public int getDataCenterWriteQuorum(final String dataCenter) {    final ODocument dc = getDataCenterConfiguration(dataCenter);    Object wq = dc.field(WRITE_QUORUM);    if (wq instanceof String) {      if (wq.toString().equalsIgnoreCase(ODistributedConfiguration.QUORUM_MAJORITY)) {        final List<String> servers = dc.field(SERVERS);        wq = servers.size() / 2 + 1;      } else if (wq.toString().equalsIgnoreCase(ODistributedConfiguration.QUORUM_ALL)) {        final List<String> servers = dc.field(SERVERS);        wq = servers.size();      }    }    return (Integer) wq;  }
public boolean isSharded() {    final ODocument allCluster = getClusterConfiguration(ALL_WILDCARD);    if (allCluster != null) {      final List<String> allServers = allCluster.field(SERVERS);      if (allServers != null && !allServers.isEmpty()) {        for (String cl : getClusterNames()) {          final List<String> servers = getServers(cl, null);          if (servers != null && !servers.isEmpty() && !allServers.containsAll(servers))            return false;        }      }    }    return false;  }
public List<String> getDataCenterServers(final String dataCenter) {    final ODocument dc = getDataCenterConfiguration(dataCenter);    final List<String> servers = dc.field(SERVERS);    if (servers == null || servers.isEmpty())      throw new OConfigurationException(          "Data center '" + dataCenter + "' does not contain any server in distributed database configuration");    return new ArrayList<String>(servers);  }
public String getDataCenterOfServer(final String server) {    final ODocument dcs = configuration.field(DCS);    if (dcs != null) {      for (String dc : dcs.fieldNames()) {        final ODocument dcConfig = dcs.field(dc);        if (dcConfig != null) {          final List<String> dcServers = dcConfig.field("servers");          if (dcServers != null && !dcServers.isEmpty()) {            if (dcServers.contains(server))              // FOUND              return dc;          }        }      }    }// NOT FOUND    return null;  }
public Object getGlobalReadQuorum(final String iClusterName) {    Object value = getClusterConfiguration(iClusterName).field(READ_QUORUM);    if (value == null)      value = configuration.field(READ_QUORUM);    return value;  }
public int getReadQuorum(final String clusterName, final int totalConfiguredServers, final String server) {    return getQuorum("readQuorum", clusterName, totalConfiguredServers, DEFAULT_READ_QUORUM, server);  }
public int getWriteQuorum(final String clusterName, final int totalConfiguredMasterServers, final String server) {    Integer overWrite = overwriteWriteQuorum.get();    if (overWrite != null)      return overWrite.intValue();    else      return getQuorum("writeQuorum", clusterName, totalConfiguredMasterServers, DEFAULT_WRITE_QUORUM, server);  }
protected ODocument getClusterConfiguration(String iClusterName) {    final ODocument clusters = getConfiguredClusters();    if (iClusterName == null)      iClusterName = ALL_WILDCARD;    final ODocument cfg;    if (!clusters.containsField(iClusterName))      // NO CLUSTER IN CFG: GET THE DEFAULT ONE      cfg = clusters.field(ALL_WILDCARD);    else      // GET THE CLUSTER CFG      cfg = clusters.field(iClusterName);    if (cfg == null)      return new ODocument();    return cfg;  }
private ODocument getDataCenterConfiguration(final String dataCenter) {    final ODocument dcs = configuration.field(DCS);    if (dcs != null)      return dcs.field(dataCenter);    throw new OConfigurationException("Cannot find the data center '" + dataCenter + "' in distributed database configuration");  }
private int getQuorum(final String quorumSetting, final String iClusterName, final int totalServers, final Object defaultValue,      final String server) {    Object value = getClusterConfiguration(iClusterName).field(quorumSetting);    if (value == null) {      value = configuration.field(quorumSetting);      if (value == null) {        OLogManager.instance()            .warn(this, "%s setting not found for cluster=%s in distributed-config.json", quorumSetting, iClusterName);        value = defaultValue;      }    }    if (value instanceof String) {      if (value.toString().equalsIgnoreCase(QUORUM_MAJORITY))        value = totalServers / 2 + 1;      else if (value.toString().equalsIgnoreCase(QUORUM_ALL))        value = totalServers;      else if (value.toString().equalsIgnoreCase(QUORUM_LOCAL_DC)) {        final String dc = getDataCenterOfServer(server);        if (dc == null)          throw new OConfigurationException("Data center not specified for server '" + server + "' in distributed configuration");        value = getDataCenterWriteQuorum(dc);      } else        throw new OConfigurationException(            "The value '" + value + "' is not supported for " + quorumSetting + " in distributed configuration");    }    return (Integer) value;  }
public static void clearInitStack() {    final ThreadLocal<Deque<OrientBaseGraph>> is = initializationStack;    if (is != null)      is.get().clear();    final ThreadLocal<OrientBaseGraph> ag = activeGraph;    if (ag != null)      ag.remove();  }
public static void encodeClassNames(final String... iLabels) {    if (iLabels != null)      // ENCODE LABELS      for (int i = 0; i < iLabels.length; ++i)        iLabels[i] = encodeClassName(iLabels[i]);  }
public static void getEdgeClassNames(final OrientBaseGraph graph, final String... iLabels) {    if (iLabels != null && graph != null && graph.isUseClassForEdgeLabel()) {      for (int i = 0; i < iLabels.length; ++i) {        final OrientEdgeType edgeType = graph.getEdgeType(iLabels[i]);        if (edgeType != null)          // OVERWRITE CLASS NAME BECAUSE ATTRIBUTES ARE CASE SENSITIVE          iLabels[i] = edgeType.getName();      }    }  }
public static String encodeClassName(String iClassName) {    if (iClassName == null)      return null;    if (Character.isDigit(iClassName.charAt(0)))      iClassName = "-" + iClassName;    try {      return URLEncoder.encode(iClassName, "UTF-8").replaceAll("\\.", "%2E"); // encode invalid '.'    } catch (UnsupportedEncodingException e) {      OLogManager.instance().error(null, "Error on encoding class name using encoding '%s'", e, "UTF-8");      return iClassName;    }  }
public static String decodeClassName(String iClassName) {    if (iClassName == null)      return null;    if (iClassName.charAt(0) == '-')      iClassName = iClassName.substring(1);    try {      return URLDecoder.decode(iClassName, "UTF-8");    } catch (UnsupportedEncodingException e) {      OLogManager.instance().error(null, "Error on decoding class name using encoding '%s'", e, "UTF-8");      return iClassName;    }  }
public OrientBaseGraph configure(final Settings iSetting) {    makeActive();    if (iSetting != null) {      if (settings == null) {        settings = iSetting;      } else {        settings.copyFrom(iSetting);      }    }    return this;  }
@SuppressWarnings("unchecked")  @Override  public <T extends Element> Index<T> getIndex(final String indexName, final Class<T> indexClass) {    makeActive();    final OIndexManager indexManager = getDatabase().getMetadata().getIndexManager();    final OIndex idx = indexManager.getIndex(indexName);    if (idx == null || !hasIndexClass(idx))      return null;    final Index<? extends Element> index = new OrientIndex(this, idx);    if (indexClass.isAssignableFrom(index.getIndexClass()))      return (Index<T>) index;    else      throw ExceptionFactory.indexDoesNotSupportClass(indexName, indexClass);  }
public void dropIndex(final String indexName) {    makeActive();    executeOutsideTx(new OCallable<Object, OrientBaseGraph>() {      @Override      public Object call(OrientBaseGraph g) {        try {          final OIndexManager indexManager = getRawGraph().getMetadata().getIndexManager();          final OIndex index = indexManager.getIndex(indexName);          ODocument metadata = index.getConfiguration().field("metadata");          String recordMapIndexName = null;          if (metadata != null) {            recordMapIndexName = metadata.field(OrientIndex.CONFIG_RECORD_MAP_NAME);          }          indexManager.dropIndex(indexName);          if (recordMapIndexName != null)            getRawGraph().getMetadata().getIndexManager().dropIndex(recordMapIndexName);          saveIndexConfiguration();          return null;        } catch (Exception e) {          g.rollback();          throw new RuntimeException(e.getMessage(), e);        }      }    }, "drop index '", indexName, "'");  }
@Override  public OrientVertex addVertex(final Object id) {    makeActive();    return addVertex(id, (Object[]) null);  }
public OrientVertex addVertex(Object id, final Object... prop) {    makeActive();    String className = null;    String clusterName = null;    Object[] fields = null;    if (id != null) {      if (id instanceof String) {        // PARSE ARGUMENTS        final String[] args = ((String) id).split(",");        for (String s : args) {          if (s.startsWith(CLASS_PREFIX))            // GET THE CLASS NAME            className = s.substring(CLASS_PREFIX.length());          else if (s.startsWith(CLUSTER_PREFIX))            // GET THE CLASS NAME            clusterName = s.substring(CLUSTER_PREFIX.length());          else            id = s;        }      }      if (isSaveOriginalIds())        // SAVE THE ID TOO        fields = new Object[] { OrientElement.DEF_ORIGINAL_ID_FIELDNAME, id };    }    setCurrentGraphInThreadLocal();    autoStartTransaction();    final OrientVertex vertex = getVertexInstance(className, fields);    vertex.setPropertiesInternal(prop);    // SAVE IT    if (clusterName != null)      vertex.save(clusterName);    else      vertex.save();    return vertex;  }
public OrientVertex addVertex(final String iClassName, final String iClusterName) {    makeActive();    setCurrentGraphInThreadLocal();    autoStartTransaction();    final OrientVertex vertex = getVertexInstance(iClassName);    // SAVE IT    if (iClusterName != null)      vertex.save(iClusterName);    else      vertex.save();    return vertex;  }
public OrientVertex addTemporaryVertex(final String iClassName, final Object... prop) {    makeActive();    setCurrentGraphInThreadLocal();    autoStartTransaction();    final OrientVertex vertex = getVertexInstance(iClassName);    vertex.setPropertiesInternal(prop);    return vertex;  }
@Override  public OrientEdge addEdge(final Object id, Vertex outVertex, Vertex inVertex, final String label) {    makeActive();    String className = null;    String clusterName = null;    if (id != null) {      if (id instanceof String) {        // PARSE ARGUMENTS        final String[] args = ((String) id).split(",");        for (String s : args) {          if (s.startsWith(CLASS_PREFIX))            // GET THE CLASS NAME            className = s.substring(CLASS_PREFIX.length());          else if (s.startsWith(CLUSTER_PREFIX))            // GET THE CLASS NAME            clusterName = s.substring(CLUSTER_PREFIX.length());        }      }    }    // SAVE THE ID TOO?    final Object[] fields = isSaveOriginalIds() && id != null ? new Object[] { OrientElement.DEF_ORIGINAL_ID_FIELDNAME, id } : null;    if (outVertex instanceof PartitionVertex)      // WRAPPED: GET THE BASE VERTEX      outVertex = ((PartitionVertex) outVertex).getBaseVertex();    if (inVertex instanceof PartitionVertex)      // WRAPPED: GET THE BASE VERTEX      inVertex = ((PartitionVertex) inVertex).getBaseVertex();    return ((OrientVertex) outVertex).addEdge(label, (OrientVertex) inVertex, className, clusterName, fields);  }
public OrientVertex getVertex(final Object id) {    makeActive();    if (null == id)      throw ExceptionFactory.vertexIdCanNotBeNull();    if (id instanceof OrientVertex)      return (OrientVertex) id;    else if (id instanceof ODocument)      return getVertexInstance((OIdentifiable) id);    setCurrentGraphInThreadLocal();    ORID rid;    if (id instanceof OIdentifiable)      rid = ((OIdentifiable) id).getIdentity();    else {      try {        rid = new ORecordId(id.toString());      } catch (IllegalArgumentException iae) {        // orientdb throws IllegalArgumentException: Argument 'xxxx' is        // not a RecordId in form of string. Format must be:        // <cluster-id>:<cluster-position>        return null;      }    }    if (!rid.isValid())      return null;    final ORecord rec = rid.getRecord();    if (rec == null || !(rec instanceof ODocument))      return null;    final OClass cls = ((ODocument) rec).getSchemaClass();    if (cls != null && cls.isEdgeType())      throw new IllegalArgumentException("Cannot retrieve a vertex with the RID " + rid + " because it is an edge");    return getVertexInstance(rec);  }
public Iterable<Vertex> getVerticesOfClass(final String iClassName, final boolean iPolymorphic) {    makeActive();    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iClassName);    if (cls == null)      throw new IllegalArgumentException("Cannot find class '" + iClassName + "' in database schema");    if (!cls.isSubClassOf(OrientVertexType.CLASS_NAME))      throw new IllegalArgumentException("Class '" + iClassName + "' is not a vertex class");    return new OrientElementScanIterable<Vertex>(this, iClassName, iPolymorphic);  }
public Iterable<Vertex> getVertices(final String iKey, Object iValue) {    makeActive();    if (iKey.equals("@class"))      return getVerticesOfClass(iValue.toString());    int pos = iKey.indexOf('.');    final String className = pos > -1 ? iKey.substring(0, pos) : OrientVertexType.CLASS_NAME;    final String key = pos > -1 ? iKey.substring(pos + 1) : iKey;    OClass clazz = getDatabase().getMetadata().getImmutableSchemaSnapshot().getClass(className);    if (clazz == null) {      throw new IllegalArgumentException("OClass not found in the schema: " + className);    }    OIndex<?> idx = null;    final Collection<? extends OIndex<?>> indexes = clazz.getIndexes();    for (OIndex<?> index : indexes) {      OIndexDefinition indexDef = index.getDefinition();      if ("lucene".equalsIgnoreCase(index.getAlgorithm())) {        continue;      }      List<String> indexedFields = indexDef.getFields();      if (indexedFields != null && indexedFields.size() > 0 && indexedFields.get(0).equals(key)) {        idx = index;        break;      }    }    if (idx == null) {      idx = getDatabase().getMetadata().getIndexManager().getIndex(iKey);    }    if (idx != null) {      iValue = convertKey(idx, iValue);      Object indexValue = idx.get(iValue);      if (indexValue != null && !(indexValue instanceof Iterable<?>))        indexValue = Arrays.asList(indexValue);      return new OrientElementIterable<Vertex>(this, (Iterable<?>) indexValue);    } else {      // NO INDEX: EXECUTE A QUERY      OrientGraphQuery query = (OrientGraphQuery) query();      query.labels(clazz.getName());      return query.has(key, iValue).vertices();    }  }
@Deprecated  public Vertex getVertexByKey(final String iKey, Object iValue) {    makeActive();    String indexName;    if (iKey.indexOf('.') > -1)      indexName = iKey;    else      indexName = OrientVertexType.CLASS_NAME + "." + iKey;    final OIndex<?> idx = getDatabase().getMetadata().getIndexManager().getIndex(indexName);    if (idx != null) {      iValue = convertKey(idx, iValue);      Object v = idx.get(iValue);      if (v != null)        return getVertex(v);      return null;    } else      throw new IllegalArgumentException("Index '" + indexName + "' not found");  }
public Iterable<Vertex> getVertices(final String label, final String[] iKey, Object[] iValue) {    if (iKey.length != iValue.length) {      throw new IllegalArgumentException("key names and values must be arrays of the same size");    }    makeActive();    final OClass clazz = getDatabase().getMetadata().getImmutableSchemaSnapshot().getClass(label);    if (clazz != null) {      Set<OIndex<?>> indexes = clazz.getInvolvedIndexes(Arrays.asList(iKey));      Iterator<OIndex<?>> iterator = indexes.iterator();      while (iterator.hasNext()) {        final OIndex<?> idx = iterator.next();        if (idx != null) {          if ("lucene".equalsIgnoreCase(idx.getAlgorithm())) {            continue;          }          Object[] sortedParams = new Object[iValue.length];          List<String> indexFields = idx.getDefinition().getFields();          for (int i = 0; i < iKey.length; i++) {            sortedParams[indexFields.indexOf(iKey[i])] = iValue[i];          }          List<Object> keys = Arrays.asList(convertKeys(idx, sortedParams));          Object key;          if (indexFields.size() == 1) {            key = keys.get(0);          } else {            key = new OCompositeKey(keys);          }          Object indexValue = idx.get(key);          if (indexValue != null && !(indexValue instanceof Iterable<?>))            indexValue = Arrays.asList(indexValue);          return new OrientClassVertexIterable(this, (Iterable<?>) indexValue, label);        }      }    }    // NO INDEX: EXECUTE A QUERY    OrientGraphQuery query = (OrientGraphQuery) query();    query.labels(label);    for (int i = 0; i < iKey.length; i++) {      query.has(iKey[i], iValue[i]);    }    return query.vertices();  }
public Iterable<Edge> getEdgesOfClass(final String iClassName, final boolean iPolymorphic) {    makeActive();    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iClassName);    if (cls == null)      throw new IllegalArgumentException("Cannot find class '" + iClassName + "' in database schema");    if (!cls.isSubClassOf(OrientEdgeType.CLASS_NAME))      throw new IllegalArgumentException("Class '" + iClassName + "' is not an edge class");    return new OrientElementScanIterable<Edge>(this, iClassName, iPolymorphic);  }
public Iterable<Edge> getEdges(final String iKey, Object iValue) {    makeActive();    if (iKey.equals("@class"))      return getEdgesOfClass(iValue.toString());    final String indexName;    final String key;    int pos = iKey.indexOf('.');    if (pos > -1) {      indexName = iKey;      key = iKey.substring(iKey.indexOf('.') + 1);    } else {      indexName = OrientEdgeType.CLASS_NAME + "." + iKey;      key = iKey;    }    final OIndex<?> idx = getDatabase().getMetadata().getIndexManager().getIndex(indexName);    if (idx != null) {      iValue = convertKey(idx, iValue);      Object indexValue = idx.get(iValue);      if (indexValue != null && !(indexValue instanceof Iterable<?>))        indexValue = Arrays.asList(indexValue);      return new OrientElementIterable<Edge>(this, (Iterable<?>) indexValue);    }    // NO INDEX: EXECUTE A QUERY    return query().has(key, iValue).edges();  }
public OrientEdge getEdge(final Object id) {    makeActive();    if (null == id)      throw ExceptionFactory.edgeIdCanNotBeNull();    if (id instanceof OrientEdge)      return (OrientEdge) id;    else if (id instanceof ODocument)      return new OrientEdge(this, (OIdentifiable) id);    final OIdentifiable rec;    if (id instanceof OIdentifiable)      rec = (OIdentifiable) id;    else {      final String str = id.toString();      int pos = str.indexOf("->");      if (pos > -1) {        // DUMMY EDGE: CREATE IT IN MEMORY        final String from = str.substring(0, pos);        final String to = str.substring(pos + 2);        return getEdgeInstance(new ORecordId(from), new ORecordId(to), null);      }      try {        rec = new ORecordId(str);      } catch (IllegalArgumentException iae) {        // orientdb throws IllegalArgumentException: Argument 'xxxx' is        // not a RecordId in form of string. Format must be:        // [#]<cluster-id>:<cluster-position>        return null;      }    }    final ODocument doc = rec.getRecord();    if (doc == null)      return null;    final OClass cls = doc.getSchemaClass();    if (cls != null) {      if (cls.isVertexType())        throw new IllegalArgumentException("Cannot retrieve an edge with the RID " + id + " because it is a vertex");      if (!cls.isEdgeType())        throw new IllegalArgumentException("Class '" + doc.getClassName() + "' is not an edge class");    }    return new OrientEdge(this, rec);  }
public OrientBaseGraph reuse(final ODatabaseDocumentInternal iDatabase) {    ODatabaseRecordThreadLocal.instance().set(iDatabase);    this.url = iDatabase.getURL();    database = iDatabase;    makeActive();    return this;  }
public void shutdown(boolean closeDb, boolean commitTx) {    makeActive();    try {      if (!isClosed()) {        if (commitTx) {          final OStorage storage = getDatabase().getStorage().getUnderlying();          if (storage instanceof OAbstractPaginatedStorage) {            if (((OAbstractPaginatedStorage) storage).getWALInstance() != null)              getDatabase().commit();          } else {            getDatabase().commit();          }        } else if (closeDb) {          getDatabase().rollback();        }      }    } catch (ONeedRetryException e) {      throw e;    } catch (RuntimeException e) {      OLogManager.instance().error(this, "Error during context close for db " + url, e);      throw e;    } catch (Exception e) {      OLogManager.instance().error(this, "Error during context close for db " + url, e);      throw OException.wrapException(new ODatabaseException("Error during context close for db " + url), e);    } finally {      try {        if (closeDb) {          getDatabase().close();          if (getDatabase().isPooled()) {            database = null;          }        }        pollGraphFromStack(closeDb);      } catch (Exception e) {        OLogManager.instance().error(this, "Error during context close for db " + url, e);      }    }    url = null;    username = null;    password = null;    if (!closeDb)      getDatabase().activateOnCurrentThread();  }
public OrientVertexType getVertexBaseType() {    makeActive();    return new OrientVertexType(this, getRawGraph().getMetadata().getSchema().getClass(OrientVertexType.CLASS_NAME));  }
public OrientVertexType getVertexType(final String iTypeName) {    makeActive();    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iTypeName);    if (cls == null)      return null;    OrientVertexType.checkType(cls);    return new OrientVertexType(this, cls);  }
public OrientVertexType createVertexType(final String iClassName, final int clusters) {    makeActive();    return createVertexType(iClassName, (String) null, clusters);  }
public OrientVertexType createVertexType(final String iClassName, final String iSuperClassName) {    makeActive();    return createVertexType(iClassName, iSuperClassName == null ? getVertexBaseType() : getVertexType(iSuperClassName));  }
public OrientVertexType createVertexType(final String iClassName, final OClass iSuperClass, final int clusters) {    makeActive();    OrientVertexType.checkType(iSuperClass);    return executeOutsideTx(new OCallable<OrientVertexType, OrientBaseGraph>() {      @Override      public OrientVertexType call(final OrientBaseGraph g) {        return new OrientVertexType(g, getRawGraph().getMetadata().getSchema().createClass(iClassName, clusters, iSuperClass));      }    }, "create vertex type '", iClassName, "' as subclass of '", iSuperClass.getName(), "' (clusters=" + clusters + ")");  }
public void dropVertexType(final String iTypeName) {    makeActive();    if (getDatabase().countClass(iTypeName) > 0)      throw new OCommandExecutionException("cannot drop vertex type '" + iTypeName          + "' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data");    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {      @Override      public OClass call(final OrientBaseGraph g) {        ODatabaseDocument rawGraph = getRawGraph();        rawGraph.getMetadata().getSchema().dropClass(iTypeName);        return null;      }    }, "drop vertex type '", iTypeName, "'");  }
public OrientEdgeType getEdgeType(final String iTypeName) {    makeActive();    final OClass cls = getRawGraph().getMetadata().getSchema().getClass(iTypeName);    if (cls == null)      return null;    OrientEdgeType.checkType(cls);    return new OrientEdgeType(this, cls);  }
public OrientEdgeType createEdgeType(final String iClassName, final int clusters) {    makeActive();    return createEdgeType(iClassName, (String) null, clusters);  }
public OrientEdgeType createEdgeType(final String iClassName, final String iSuperClassName) {    makeActive();    return createEdgeType(iClassName, iSuperClassName == null ? getEdgeBaseType() : getEdgeType(iSuperClassName));  }
public OrientEdgeType createEdgeType(final String iClassName, final OClass iSuperClass, final int clusters) {    makeActive();    OrientEdgeType.checkType(iSuperClass);    return executeOutsideTx(new OCallable<OrientEdgeType, OrientBaseGraph>() {      @Override      public OrientEdgeType call(final OrientBaseGraph g) {        return new OrientEdgeType(g, getRawGraph().getMetadata().getSchema().createClass(iClassName, clusters, iSuperClass));      }    }, "create edge type '", iClassName, "' as subclass of '", iSuperClass.getName(), "' (clusters=" + clusters + ")");  }
public OrientElement getElement(final Object id) {    makeActive();    if (null == id)      throw new IllegalArgumentException("id cannot be null");    if (id instanceof OrientElement)      return (OrientElement) id;    OIdentifiable rec;    if (id instanceof OIdentifiable)      rec = (OIdentifiable) id;    else      try {        rec = new ORecordId(id.toString());      } catch (IllegalArgumentException iae) {        // orientdb throws IllegalArgumentException: Argument 'xxxx' is        // not a RecordId in form of string. Format must be:        // <cluster-id>:<cluster-position>        return null;      }    final ODocument doc = rec.getRecord();    if (doc != null) {      final OImmutableClass schemaClass = ODocumentInternal.getImmutableSchemaClass(doc);      if (schemaClass != null && schemaClass.isEdgeType())        return getEdge(doc);      else        return getVertexInstance(doc);    }    return null;  }
public <T extends Element> void dropKeyIndex(final String key, final Class<T> elementClass) {    makeActive();    if (elementClass == null)      throw ExceptionFactory.classForElementCannotBeNull();    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {      @Override      public OClass call(final OrientBaseGraph g) {        final String className = getClassName(elementClass);        getRawGraph().getMetadata().getIndexManager().dropIndex(className + "." + key);        return null;      }    }, "drop key index '", elementClass.getSimpleName(), ".", key, "'");  }
@SuppressWarnings({ "rawtypes" })  @Override  public <T extends Element> void createKeyIndex(final String key, final Class<T> elementClass,      final Parameter... indexParameters) {    makeActive();    if (elementClass == null)      throw ExceptionFactory.classForElementCannotBeNull();    executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {      @Override      public OClass call(final OrientBaseGraph g) {        String indexType = OClass.INDEX_TYPE.NOTUNIQUE.name();        OType keyType = OType.STRING;        String className = null;        String collate = null;        ODocument metadata = null;        final String ancestorClassName = getClassName(elementClass);        // READ PARAMETERS        for (Parameter<?, ?> p : indexParameters) {          if (p.getKey().equals("type"))            indexType = p.getValue().toString().toUpperCase(Locale.ENGLISH);          else if (p.getKey().equals("keytype"))            keyType = OType.valueOf(p.getValue().toString().toUpperCase(Locale.ENGLISH));          else if (p.getKey().equals("class"))            className = p.getValue().toString();          else if (p.getKey().equals("collate"))            collate = p.getValue().toString();          else if (p.getKey().toString().startsWith("metadata.")) {            if (metadata == null)              metadata = new ODocument();            metadata.field(p.getKey().toString().substring("metadata.".length()), p.getValue());          }        }        if (className == null)          className = ancestorClassName;        final ODatabaseDocument db = getRawGraph();        final OSchema schema = db.getMetadata().getSchema();        final OClass cls = schema.getOrCreateClass(className, schema.getClass(ancestorClassName));        final OProperty property = cls.getProperty(key);        if (property != null)          keyType = property.getType();        OPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition(className, key, keyType);        if (collate != null)          indexDefinition.setCollate(collate);        db.getMetadata().getIndexManager()            .createIndex(className + "." + key, indexType, indexDefinition, cls.getPolymorphicClusterIds(), null, metadata);        return null;      }    }, "create key index on '", elementClass.getSimpleName(), ".", key, "'");  }
@Override  public <T extends Element> Set<String> getIndexedKeys(final Class<T> elementClass) {    makeActive();    return getIndexedKeys(elementClass, false);  }
public <T extends Element> Set<String> getIndexedKeys(final Class<T> elementClass, final boolean includeClassNames) {    makeActive();    if (elementClass == null)      throw ExceptionFactory.classForElementCannotBeNull();    final OSchema schema = getRawGraph().getMetadata().getImmutableSchemaSnapshot();    final String elementOClassName = getClassName(elementClass);    Set<String> result = new HashSet<String>();    final Collection<? extends OIndex<?>> indexes = getRawGraph().getMetadata().getIndexManager().getIndexes();    for (OIndex<?> index : indexes) {      String indexName = index.getName();      int point = indexName.indexOf(".");      if (point > 0) {        String oClassName = indexName.substring(0, point);        OClass oClass = schema.getClass(oClassName);        if (oClass != null) {          if (oClass.isSubClassOf(elementOClassName)) {            if (includeClassNames)              result.add(index.getName());            else              result.add(index.getDefinition().getFields().get(0));          }        }      }    }    return result;  }
protected static void removeEdges(final OrientBaseGraph graph, final ODocument iVertex, final String iFieldName,      final OIdentifiable iVertexToRemove, final boolean iAlsoInverse, final boolean useVertexFieldsForEdgeLabels,      final boolean autoScaleEdgeType, final boolean forceReload) {    if (iVertex == null)      return;    final Object fieldValue = iVertexToRemove != null ? iVertex.field(iFieldName) : iVertex.removeField(iFieldName);    if (fieldValue == null)      return;    if (fieldValue instanceof OIdentifiable) {      // SINGLE RECORD      if (iVertexToRemove != null) {        if (!fieldValue.equals(iVertexToRemove))          // NOT FOUND          return;        iVertex.removeField(iFieldName);        deleteEdgeIfAny(iVertexToRemove, forceReload);      }      if (iAlsoInverse)        removeInverseEdge(graph, iVertex, iFieldName, iVertexToRemove, (OIdentifiable) fieldValue, useVertexFieldsForEdgeLabels,            autoScaleEdgeType, forceReload);    } else if (fieldValue instanceof ORidBag) {      // COLLECTION OF RECORDS: REMOVE THE ENTRY      final ORidBag bag = (ORidBag) fieldValue;      if (iVertexToRemove != null) {        // SEARCH SEQUENTIALLY (SLOWER)        for (Iterator<OIdentifiable> it = bag.rawIterator(); it.hasNext(); ) {          final ODocument curr = getDocument(it.next(), forceReload);          if (curr == null) {            // EDGE REMOVED            it.remove();            iVertex.save();            continue;          }          if (iVertexToRemove.equals(curr)) {            // FOUND AS VERTEX            it.remove();            if (iAlsoInverse)              removeInverseEdge(graph, iVertex, iFieldName, iVertexToRemove, curr, useVertexFieldsForEdgeLabels, autoScaleEdgeType,                  forceReload);            break;          } else if (ODocumentInternal.getImmutableSchemaClass(curr).isEdgeType()) {            final Direction direction = OrientVertex.getConnectionDirection(iFieldName, useVertexFieldsForEdgeLabels);            // EDGE, REMOVE THE EDGE            if (iVertexToRemove.equals(OrientEdge.getConnection(curr, direction.opposite()))) {              it.remove();              if (iAlsoInverse)                removeInverseEdge(graph, iVertex, iFieldName, iVertexToRemove, curr, useVertexFieldsForEdgeLabels,                    autoScaleEdgeType, forceReload);              break;            }          }        }        deleteEdgeIfAny(iVertexToRemove, forceReload);      } else {        // DELETE ALL THE EDGES        for (Iterator<OIdentifiable> it = bag.rawIterator(); it.hasNext(); ) {          OIdentifiable edge = it.next();          if (iAlsoInverse)            removeInverseEdge(graph, iVertex, iFieldName, null, edge, useVertexFieldsForEdgeLabels, autoScaleEdgeType, forceReload);          deleteEdgeIfAny(edge, forceReload);        }      }      if (autoScaleEdgeType && bag.isEmpty())        // FORCE REMOVAL OF ENTIRE FIELD        iVertex.removeField(iFieldName);    } else if (fieldValue instanceof Collection) {      final Collection col = (Collection) fieldValue;      if (iVertexToRemove != null) {        // SEARCH SEQUENTIALLY (SLOWER)        for (Iterator<OIdentifiable> it = col.iterator(); it.hasNext(); ) {          final ODocument curr = getDocument(it.next(), forceReload);          if (curr == null)            // EDGE REMOVED            continue;          if (iVertexToRemove.equals(curr)) {            // FOUND AS VERTEX            it.remove();            if (iAlsoInverse)              removeInverseEdge(graph, iVertex, iFieldName, iVertexToRemove, curr, useVertexFieldsForEdgeLabels, autoScaleEdgeType,                  forceReload);            break;          } else if (ODocumentInternal.getImmutableSchemaClass(curr).isVertexType()) {            final Direction direction = OrientVertex.getConnectionDirection(iFieldName, useVertexFieldsForEdgeLabels);            // EDGE, REMOVE THE EDGE            if (iVertexToRemove.equals(OrientEdge.getConnection(curr, direction.opposite()))) {              it.remove();              if (iAlsoInverse)                removeInverseEdge(graph, iVertex, iFieldName, iVertexToRemove, curr, useVertexFieldsForEdgeLabels,                    autoScaleEdgeType, forceReload);              break;            }          }        }        deleteEdgeIfAny(iVertexToRemove, forceReload);      } else {        // DELETE ALL THE EDGES        for (OIdentifiable edge : (Iterable<OIdentifiable>) col) {          if (iAlsoInverse)            removeInverseEdge(graph, iVertex, iFieldName, null, edge, useVertexFieldsForEdgeLabels, autoScaleEdgeType, forceReload);          deleteEdgeIfAny(edge, forceReload);        }      }      if (autoScaleEdgeType && col.isEmpty())        // FORCE REMOVAL OF ENTIRE FIELD        iVertex.removeField(iFieldName);    }  }
private static void removeInverseEdge(final OrientBaseGraph graph, final ODocument iVertex, final String iFieldName,      final OIdentifiable iVertexToRemove, final OIdentifiable currentRecord, final boolean useVertexFieldsForEdgeLabels,      final boolean autoScaleEdgeType, boolean forceReload) {    final ODocument r = getDocument(currentRecord, forceReload);    if (r == null)      return;    final String inverseFieldName = OrientVertex.getInverseConnectionFieldName(iFieldName, useVertexFieldsForEdgeLabels);    OImmutableClass immutableClass = ODocumentInternal.getImmutableSchemaClass(r);    OClass klass = ODocumentInternal.getImmutableSchemaClass(r);    if (klass == null) {      graph.getDatabase().getMetadata().reload();      klass = graph.getDatabase().getMetadata().getSchema().getClass(inverseFieldName);      if (klass == null) {        OLogManager.instance().warn(null, "Removing edge, schema class not found for " + r);        return;      }    }    if (klass.isVertexType()) {      // DIRECT VERTEX      removeEdges(graph, r, inverseFieldName, iVertex, false, useVertexFieldsForEdgeLabels, autoScaleEdgeType, forceReload);      r.save();    } else if (klass.isEdgeType()) {      // EDGE, REMOVE THE EDGE      final OIdentifiable otherVertex = OrientEdge          .getConnection(r, OrientVertex.getConnectionDirection(inverseFieldName, useVertexFieldsForEdgeLabels));      if (otherVertex != null) {        if (iVertexToRemove == null || otherVertex.equals(iVertexToRemove)) {          final int maxRetries = graph.getMaxRetries();          for (int retry = 0; retry < maxRetries; ++retry) {            try {              final ODocument otherVertexRecord = getDocument(otherVertex, forceReload);              // BIDIRECTIONAL EDGE              removeEdges(graph, otherVertexRecord, inverseFieldName, (OIdentifiable) currentRecord, false,                  useVertexFieldsForEdgeLabels, autoScaleEdgeType, forceReload);              if (otherVertexRecord != null)                otherVertexRecord.save();              break;            } catch (ONeedRetryException e) {              // RETRY            }          }        }      }    }  }
protected static void deleteEdgeIfAny(final OIdentifiable iRecord, boolean forceReload) {    if (iRecord != null) {      final ODocument doc = getDocument(iRecord, forceReload);      if (doc != null) {        final OImmutableClass clazz = ODocumentInternal.getImmutableSchemaClass(doc);        if (clazz != null && clazz.isEdgeType())          // DELETE THE EDGE RECORD TOO          doc.delete();      }    }  }
@Override  public void removeBackgroundExceptionListener(final OBackgroundExceptionListener listener) {    final List<WeakReference<OBackgroundExceptionListener>> itemsToRemove = new ArrayList<>(1);    for (final WeakReference<OBackgroundExceptionListener> ref : backgroundExceptionListeners) {      final OBackgroundExceptionListener l = ref.get();      if (l != null && l.equals(listener)) {        itemsToRemove.add(ref);      }    }    backgroundExceptionListeners.removeAll(itemsToRemove);  }
private void fireBackgroundDataFlushExceptionEvent(final Throwable e) {    for (final WeakReference<OBackgroundExceptionListener> ref : backgroundExceptionListeners) {      final OBackgroundExceptionListener listener = ref.get();      if (listener != null) {        listener.onException(e);      }    }  }
private void freeSpaceCheckAfterNewPageAdd() throws IOException {    final long newPagesAdded = amountOfNewPagesAdded.addAndGet(1);    final long lastSpaceCheck = lastDiskSpaceCheck.get();    if (newPagesAdded - lastSpaceCheck > diskSizeCheckInterval || lastSpaceCheck == 0) {      //usable space may be less than free space      final long freeSpace = Files.getFileStore(storagePath).getUsableSpace();      if (freeSpace < freeSpaceLimit) {        callLowSpaceListeners(new OLowDiskSpaceInformation(freeSpace, freeSpaceLimit));      }      lastDiskSpaceCheck.lazySet(newPagesAdded);    }  }
private void readNameIdMapV2() throws IOException, InterruptedException {    nameIdMap.clear();    long localFileCounter = -1;    nameIdMapHolder.position(0);    NameFileIdEntry nameFileIdEntry;    final Map<Integer, String> idFileNameMap = new HashMap<>(1_000);    while ((nameFileIdEntry = readNextNameIdEntryV2()) != null) {      final long absFileId = Math.abs(nameFileIdEntry.fileId);      if (localFileCounter < absFileId) {        localFileCounter = absFileId;      }      nameIdMap.put(nameFileIdEntry.name, nameFileIdEntry.fileId);      if (nameFileIdEntry.fileId >= 0) {        idNameMap.put(nameFileIdEntry.fileId, nameFileIdEntry.name);      }      idFileNameMap.put(nameFileIdEntry.fileId, nameFileIdEntry.fileSystemName);    }    if (localFileCounter > 0 && nextInternalId < localFileCounter) {      nextInternalId = (int) localFileCounter;    }    for (final Map.Entry<String, Integer> nameIdEntry : nameIdMap.entrySet()) {      final int fileId = nameIdEntry.getValue();      if (fileId >= 0) {        final long externalId = composeFileId(id, nameIdEntry.getValue());        if (files.get(externalId) == null) {          final Path path = storagePath.resolve(idFileNameMap.get((nameIdEntry.getValue())));          final OFileClassic fileClassic = new OFileClassic(path);          if (fileClassic.exists()) {            fileClassic.open();            files.add(externalId, fileClassic);          } else {            nameIdMap.put(nameIdEntry.getKey(), -fileId);            idNameMap.remove(fileId);          }        }      }    }  }
public boolean matches(String propertyName) {    if (star) {      return true;    }    if (expression != null) {      String fieldString = expression.getDefaultAlias().getStringValue();      if (fieldString.equals(propertyName)) {        return true;      }      if (rightWildcard && propertyName.startsWith(fieldString)) {        return true;      }    }    return false;  }
public Object execute(final Map<Object, Object> iArgs) {    if (clusterName == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocumentInternal database = getDatabase();    final int clusterId = database.getClusterIdByName(clusterName);    if (clusterId < 0) {      throw new ODatabaseException("Cluster with name " + clusterName + " does not exist");    }    final OSchema schema = database.getMetadata().getSchema();    final OClass clazz = schema.getClassByClusterId(clusterId);    if (clazz == null) {      final OStorage storage = database.getStorage();      final OCluster cluster = storage.getClusterById(clusterId);      if (cluster == null) {        throw new ODatabaseException("Cluster with name " + clusterName + " does not exist");      }      try {        database.checkForClusterPermissions(cluster.getName());        cluster.truncate();      } catch (IOException ioe) {        throw OException.wrapException(new ODatabaseException("Error during truncation of cluster with name " + clusterName), ioe);      }    } else {      clazz.truncateCluster(clusterName);    }    return true;  }
public void startThreadMonitoring() {    switchLock.acquireWriteLock();    try {      if (enabled)        throw new IllegalStateException("Monitoring is already started on system level and can not be started on thread level");      enabledForCurrentThread.set(true);      statistics.put(Thread.currentThread(), new OSessionStoragePerformanceStatistic(intervalBetweenSnapshots, Long.MAX_VALUE));    } finally {      switchLock.releaseWriteLock();    }  }
public void startMonitoring() {    switchLock.acquireWriteLock();    try {      if (!statistics.isEmpty() && !enabled)        throw new IllegalStateException("Monitoring is already started on thread level and can not be started on system level");      deadThreadsStatistic = null;      postMeasurementStatistic = null;      enabled = true;    } finally {      switchLock.releaseWriteLock();    }  }
public void stopMonitoring() {    switchLock.acquireWriteLock();    try {      enabled = false;      final PerformanceCountersHolder countersHolder = ComponentType.GENERAL.newCountersHolder();      final Map<String, PerformanceCountersHolder> componentCountersHolder = new HashMap<>();      WritCacheCountersHolder writCacheCountersHolder = deadThreadsStatistic.writCacheCountersHolder;      StorageCountersHolder storageCountersHolder = deadThreadsStatistic.storageCountersHolder;      WALCountersHolder walCountersHolder = deadThreadsStatistic.walCountersHolder;      deadThreadsStatistic.countersHolder.pushData(countersHolder);      componentCountersHolder.putAll(deadThreadsStatistic.countersByComponents);      deadThreadsStatistic = null;      for (OSessionStoragePerformanceStatistic statistic : statistics.values()) {        statistic.pushSystemCounters(countersHolder);        statistic.pushComponentCounters(componentCountersHolder);        writCacheCountersHolder = statistic.pushWriteCacheCounters(writCacheCountersHolder);        storageCountersHolder = statistic.pushStorageCounters(storageCountersHolder);        walCountersHolder = statistic.pushWALCounters(walCountersHolder);      }      statistics.clear();      postMeasurementStatistic = new ImmutableStatistic(countersHolder, componentCountersHolder, writCacheCountersHolder,          storageCountersHolder, walCountersHolder);    } finally {      switchLock.releaseWriteLock();    }  }
public void registerMBean(String storageName, int storageId) {    if (mbeanIsRegistered.compareAndSet(false, true)) {      try {        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));        if (!server.isRegistered(mbeanName)) {          server.registerMBean(new OPerformanceStatisticManagerMBean(this), mbeanName);        } else {          mbeanIsRegistered.set(false);          OLogManager.instance().warn(this,              "MBean with name %s has already registered. Probably your system was not shutdown correctly"                  + " or you have several running applications which use OrientDB engine inside", mbeanName.getCanonicalName());        }      } catch (MalformedObjectNameException | InstanceAlreadyExistsException | NotCompliantMBeanException | MBeanRegistrationException e) {        throw OException.wrapException(new OStorageException("Error during registration of profiler MBean"), e);      }    }  }
public void unregisterMBean(String storageName, int storageId) {    if (storageName == null) {      OLogManager.instance().warnNoDb(this, "Can not unregister MBean for performance statistics, storage name is null");    }    if (mbeanIsRegistered.compareAndSet(true, false)) {      try {        final MBeanServer server = ManagementFactory.getPlatformMBeanServer();        final ObjectName mbeanName = new ObjectName(getMBeanName(storageName, storageId));        server.unregisterMBean(mbeanName);      } catch (MalformedObjectNameException | InstanceNotFoundException | MBeanRegistrationException e) {        throw OException.wrapException(new OStorageException("Error during unregistration of profiler MBean"), e);      }    }  }
public long getAmountOfPagesPerOperation(String componentName) {    switchLock.acquireReadLock();    try {      if (enabled) {        final PerformanceCountersHolder componentCountersHolder = ComponentType.GENERAL.newCountersHolder();        fetchComponentCounters(componentName, componentCountersHolder);        return componentCountersHolder.getAmountOfPagesPerOperation();      } else {        final ImmutableStatistic post = postMeasurementStatistic;        if (post == null)          return -1;        final PerformanceCountersHolder holder = post.countersByComponents.get(componentName);        if (holder == null)          return -1;        return holder.getAmountOfPagesPerOperation();      }    } finally {      switchLock.releaseReadLock();    }  }
public int getCacheHits(String componentName) {    switchLock.acquireReadLock();    try {      if (enabled) {        final PerformanceCountersHolder countersHolder = ComponentType.GENERAL.newCountersHolder();        fetchComponentCounters(componentName, countersHolder);        return countersHolder.getCacheHits();      } else {        final ImmutableStatistic post = postMeasurementStatistic;        if (post == null)          return -1;        final PerformanceCountersHolder holder = post.countersByComponents.get(componentName);        if (holder != null)          return holder.getCacheHits();        return -1;      }    } finally {      switchLock.releaseReadLock();    }  }
private WritCacheCountersHolder fetchWriteCacheCounters() {    //go through all threads and accumulate statistic only for live threads    //all dead threads will be removed and statistics from them will be    //later accumulated in #deadThreadsStatistic field, then result statistic from this field    //will be aggregated to countersHolder    //To decrease inter thread communication delay we fetch snapshots first    //and only after that we aggregate data from immutable snapshots    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());    final Collection<Thread> threadsToRemove = new ArrayList<>();    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {      final Thread thread = entry.getKey();      final OSessionStoragePerformanceStatistic statistic = entry.getValue();      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));    }    WritCacheCountersHolder holder = null;    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {      final Thread thread = pair.getFirst();      if (thread.isAlive()) {        final PerformanceSnapshot snapshot = pair.getSecond();        if (snapshot.writCacheCountersHolder != null) {          if (holder == null)            holder = new WritCacheCountersHolder();          snapshot.writCacheCountersHolder.pushData(holder);        }      } else {        threadsToRemove.add(thread);      }    }    if (!threadsToRemove.isEmpty()) {      updateDeadThreadsStatistic(threadsToRemove);    }    final ImmutableStatistic ds = deadThreadsStatistic;    if (ds != null) {      final WritCacheCountersHolder wch = ds.writCacheCountersHolder;      if (wch != null) {        if (holder == null)          holder = new WritCacheCountersHolder();        wch.pushData(holder);      }    }    return holder;  }
private void fetchSystemCounters(PerformanceCountersHolder countersHolder) {    //go through all threads and accumulate statistic only for live threads    //all dead threads will be removed and statistics from them will be    //later accumulated in #deadThreadsStatistic field, then result statistic from this field    //will be aggregated to countersHolder    //To decrease inter thread communication delay we fetch snapshots first    //and only after that we aggregate data from immutable snapshots    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());    final Collection<Thread> threadsToRemove = new ArrayList<>();    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {      final Thread thread = entry.getKey();      final OSessionStoragePerformanceStatistic statistic = entry.getValue();      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));    }    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {      final Thread thread = pair.getFirst();      if (thread.isAlive()) {        final PerformanceSnapshot snapshot = pair.getSecond();        snapshot.performanceCountersHolder.pushData(countersHolder);      } else {        threadsToRemove.add(thread);      }    }    if (!threadsToRemove.isEmpty()) {      updateDeadThreadsStatistic(threadsToRemove);    }    final ImmutableStatistic ds = deadThreadsStatistic;    if (ds != null) {      final PerformanceCountersHolder dch = ds.countersHolder;      dch.pushData(countersHolder);    }  }
private void fetchComponentCounters(String componentName, PerformanceCountersHolder componentCountersHolder) {    //go through all threads and accumulate statistic only for live threads    //all dead threads will be removed and statistics from them will be    //later accumulated in #deadThreadsStatistic field, then result statistic from this field    //will be aggregated to componentCountersHolder    //To decrease inter thread communication delay we fetch snapshots first    //and only after that we aggregate data from immutable snapshots    final Collection<ORawPair<Thread, PerformanceSnapshot>> snapshots = new ArrayList<>(statistics.size());    final List<Thread> threadsToRemove = new ArrayList<>();    for (Map.Entry<Thread, OSessionStoragePerformanceStatistic> entry : statistics.entrySet()) {      final Thread thread = entry.getKey();      final OSessionStoragePerformanceStatistic statistic = entry.getValue();      snapshots.add(new ORawPair<>(thread, statistic.getSnapshot()));    }    for (ORawPair<Thread, PerformanceSnapshot> pair : snapshots) {      final Thread thread = pair.getFirst();      if (thread.isAlive()) {        final PerformanceSnapshot snapshot = pair.getSecond();        final PerformanceCountersHolder holder = snapshot.countersByComponent.get(componentName);        if (holder != null)          holder.pushData(componentCountersHolder);      } else {        threadsToRemove.add(thread);      }    }    if (!threadsToRemove.isEmpty()) {      updateDeadThreadsStatistic(threadsToRemove);    }    final ImmutableStatistic ds = deadThreadsStatistic;    if (ds != null) {      final PerformanceCountersHolder dch = ds.countersByComponents.get(componentName);      if (dch != null) {        dch.pushData(componentCountersHolder);      }    }  }
private void updateDeadThreadsStatistic(Collection<Thread> threadsToRemove) {    deadThreadsUpdateLock.lock();    try {      //we accumulate all statistic in intermediate fields and only then put      //results in #deadThreadsStatistic field to preserve thread safety features      final ImmutableStatistic oldDS = deadThreadsStatistic;      final PerformanceCountersHolder countersHolder = ComponentType.GENERAL.newCountersHolder();      final Map<String, PerformanceCountersHolder> countersByComponents = new HashMap<>();      WritCacheCountersHolder writeCacheCountersHolder = null;      StorageCountersHolder storageCountersHolder = null;      WALCountersHolder walCountersHolder = null;      //fetch data from old statistic first      if (oldDS != null) {        oldDS.countersHolder.pushData(countersHolder);        for (Map.Entry<String, PerformanceCountersHolder> oldEntry : oldDS.countersByComponents.entrySet()) {          final PerformanceCountersHolder holder = oldEntry.getValue().newInstance();          oldEntry.getValue().pushData(holder);          countersByComponents.put(oldEntry.getKey(), holder);        }        if (oldDS.writCacheCountersHolder != null) {          writeCacheCountersHolder = new WritCacheCountersHolder();          oldDS.writCacheCountersHolder.pushData(writeCacheCountersHolder);        }        if (oldDS.storageCountersHolder != null) {          storageCountersHolder = new StorageCountersHolder();          oldDS.storageCountersHolder.pushData(storageCountersHolder);        }        if (oldDS.walCountersHolder != null) {          walCountersHolder = new WALCountersHolder();          oldDS.walCountersHolder.pushData(walCountersHolder);        }      }      //remove all threads from active statistic and put all in #deadThreadsStatistic field      for (Thread deadThread : threadsToRemove) {        final OSessionStoragePerformanceStatistic sessionStoragePerformanceStatistic = statistics.remove(deadThread);        if (sessionStoragePerformanceStatistic != null) {          sessionStoragePerformanceStatistic.pushSystemCounters(countersHolder);          sessionStoragePerformanceStatistic.pushComponentCounters(countersByComponents);          writeCacheCountersHolder = sessionStoragePerformanceStatistic.pushWriteCacheCounters(writeCacheCountersHolder);          storageCountersHolder = sessionStoragePerformanceStatistic.pushStorageCounters(storageCountersHolder);          walCountersHolder = sessionStoragePerformanceStatistic.pushWALCounters(walCountersHolder);        }      }      deadThreadsStatistic = new ImmutableStatistic(countersHolder, countersByComponents, writeCacheCountersHolder,          storageCountersHolder, walCountersHolder);    } finally {      deadThreadsUpdateLock.unlock();    }  }
public ORID getValue(final int entryIndex) {    assert isLeaf;    int entryPosition = getIntValue(entryIndex * OIntegerSerializer.INT_SIZE + POSITIONS_ARRAY_OFFSET);    // skip key    if (encryption == null) {      entryPosition += getObjectSizeInDirectMemory(keySerializer, entryPosition);    } else {      final int encryptedSize = getIntValue(entryPosition);      entryPosition += OIntegerSerializer.INT_SIZE + encryptedSize;    }    final int clusterId = getShortValue(entryPosition);    final long clusterPosition = getLongValue(entryPosition + OShortSerializer.SHORT_SIZE);    return new ORecordId(clusterId, clusterPosition);  }
public byte[] compress(String jsonStr) {    if (jsonStr == null || jsonStr.length() == 0) {      return null;    }    GZIPOutputStream gout = null;    ByteArrayOutputStream baos = null;    try {      byte[] incoming = jsonStr.getBytes("UTF-8");      baos = new ByteArrayOutputStream();      gout = new GZIPOutputStream(baos, 16384); // 16KB      gout.write(incoming);      gout.finish();      return baos.toByteArray();    } catch (Exception ex) {      OLogManager.instance().error(this, "Error on compressing HTTP response", ex);    } finally {      try {        if (gout != null) {          gout.close();        }        if (baos != null) {          baos.close();        }      } catch (Exception ex) {      }    }    return null;  }
public String getProperty(final String iName, final String iDefaultValue) {    if (properties == null)      return null;    for (OServerEntryConfiguration p : properties) {      if (p.name.equals(iName))        return p.value;    }    return null;  }
public <RET extends Object> RET newInstance(final String iClassName, final Object iEnclosingClass, Object... iArgs) {    underlying.checkIfActive();    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_CREATE, iClassName);    try {      Class<?> entityClass = entityManager.getEntityClass(iClassName);      if (entityClass != null) {        RET enhanced = (RET) OObjectEntityEnhancer.getInstance()            .getProxiedInstance(entityManager.getEntityClass(iClassName), iEnclosingClass, underlying.newInstance(iClassName), null,                iArgs);        return (RET) enhanced;      } else {        throw new OSerializationException("Type " + iClassName            + " cannot be serialized because is not part of registered entities. To fix this error register this class");      }    } catch (Exception e) {      final String message = "Error on creating object of class " + iClassName;      OLogManager.instance().error(this, message, e);      throw OException.wrapException(new ODatabaseException(message), e);    }  }
public <RET> RET detach(final Object iPojo, boolean returnNonProxiedInstance) {    return (RET) OObjectEntitySerializer.detach(iPojo, this, returnNonProxiedInstance);  }
public <RET> RET detachAll(final Object iPojo, boolean returnNonProxiedInstance) {    return detachAll(iPojo, returnNonProxiedInstance, new HashMap<Object, Object>(), new HashMap<Object, Object>());  }
public <RET> RET save(final Object iContent, OPERATION_MODE iMode, boolean iForceCreate,      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {    return (RET) save(iContent, null, iMode, false, iRecordCreatedCallback, iRecordUpdatedCallback);  }
public <RET> RET save(final Object iPojo, final String iClusterName) {    return (RET) save(iPojo, iClusterName, OPERATION_MODE.SYNCHRONOUS, false, null, null);  }
public <RET> RET save(final Object iPojo, final String iClusterName, OPERATION_MODE iMode, boolean iForceCreate,      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {    checkOpenness();    if (iPojo == null)      return (RET) iPojo;    else if (OMultiValue.isMultiValue(iPojo)) {      // MULTI VALUE OBJECT: STORE SINGLE POJOS      for (Object pojo : OMultiValue.getMultiValueIterable(iPojo)) {        save(pojo, iClusterName);      }      return (RET) iPojo;    } else {      OSerializationThreadLocal.INSTANCE.get().clear();      // GET THE ASSOCIATED DOCUMENT      final Object proxiedObject = OObjectEntitySerializer.serializeObject(iPojo, this);      final ODocument record = getRecordByUserObject(proxiedObject, true);      try {        record.setInternalStatus(ORecordElement.STATUS.MARSHALLING);        if (!saveOnlyDirty || record.isDirty()) {          // REGISTER BEFORE TO SERIALIZE TO AVOID PROBLEMS WITH CIRCULAR DEPENDENCY          // registerUserObject(iPojo, record);          deleteOrphans((((OObjectProxyMethodHandler) ((ProxyObject) proxiedObject).getHandler())));          ODocument savedRecord = underlying              .save(record, iClusterName, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);          ((OObjectProxyMethodHandler) ((ProxyObject) proxiedObject).getHandler()).setDoc(savedRecord);          ((OObjectProxyMethodHandler) ((ProxyObject) proxiedObject).getHandler()).updateLoadedFieldMap(proxiedObject, false);          // RE-REGISTER FOR NEW RECORDS SINCE THE ID HAS CHANGED          registerUserObject(proxiedObject, record);        }      } finally {        record.setInternalStatus(ORecordElement.STATUS.LOADED);      }      return (RET) proxiedObject;    }  }
public int getVersion(final Object iPojo) {    checkOpenness();    final ODocument record = getRecordByUserObject(iPojo, false);    if (record != null)      return record.getVersion();    return OObjectSerializerHelper.getObjectVersion(iPojo);  }
private void registerFieldMappingStrategy() {    if (!this.getConfiguration().getContextKeys().contains(OGlobalConfiguration.DOCUMENT_BINARY_MAPPING.getKey())) {      this.getConfiguration()          .setValue(OGlobalConfiguration.DOCUMENT_BINARY_MAPPING, OGlobalConfiguration.DOCUMENT_BINARY_MAPPING.getValueAsInteger());    }  }
public <RET extends OCommandRequest> RET command(final OCommandRequest iCommand) {    return (RET) new OCommandSQLPojoWrapper(this, underlying.command(iCommand));  }
protected void convertParameters(final Object... iArgs) {    if (iArgs == null)      return;    // FILTER PARAMETERS    for (int i = 0; i < iArgs.length; ++i)      iArgs[i] = convertParameter(iArgs[i]);  }
public void setDirty(final Object iPojo) {    if (iPojo == null)      return;    final ODocument record = getRecordByUserObject(iPojo, false);    if (record == null)      throw new OObjectNotManagedException("The object " + iPojo + " is not managed by current database");    record.setDirty();  }
public void unsetDirty(final Object iPojo) {    if (iPojo == null)      return;    final ODocument record = getRecordByUserObject(iPojo, false);    if (record == null)      return;    ORecordInternal.unsetDirty(record);  }
protected Object convertParameter(final Object iParameter) {    if (iParameter != null)      // FILTER PARAMETERS      if (iParameter instanceof Map<?, ?>) {        Map<String, Object> map = (Map<String, Object>) iParameter;        for (Map.Entry<String, Object> e : map.entrySet()) {          map.put(e.getKey(), convertParameter(e.getValue()));        }        return map;      } else if (iParameter instanceof Collection<?>) {        List<Object> result = new ArrayList<Object>();        for (Object object : (Collection<Object>) iParameter) {          result.add(convertParameter(object));        }        return result;      } else if (iParameter.getClass().isEnum()) {        return ((Enum<?>) iParameter).name();      } else if (!OType.isSimpleType(iParameter)) {        final ORID rid = getIdentity(iParameter);        if (rid != null && rid.isValid())          // REPLACE OBJECT INSTANCE WITH ITS RECORD ID          return rid;      }    return iParameter;  }
private static Set<String> getIndexTypes() {    final Set<String> types = new HashSet<>();    final Iterator<OIndexFactory> ite = getAllFactories();    while (ite.hasNext()) {      types.addAll(ite.next().getTypes());    }    return types;  }
public static Set<String> getIndexEngines() {    final Set<String> engines = new HashSet<>();    final Iterator<OIndexFactory> ite = getAllFactories();    while (ite.hasNext()) {      engines.addAll(ite.next().getAlgorithms());    }    return engines;  }
public static OIndexInternal<?> createIndex(OStorage storage, String name, String indexType, String algorithm,      String valueContainerAlgorithm, ODocument metadata, int version) throws OConfigurationException, OIndexException {    if (indexType.equalsIgnoreCase(OClass.INDEX_TYPE.UNIQUE_HASH_INDEX.name()) || indexType        .equalsIgnoreCase(OClass.INDEX_TYPE.NOTUNIQUE_HASH_INDEX.name()) || indexType        .equalsIgnoreCase(OClass.INDEX_TYPE.DICTIONARY_HASH_INDEX.name())) {      if (!algorithm.equalsIgnoreCase("autosharding")) {        algorithm = OHashIndexFactory.HASH_INDEX_ALGORITHM;      }    }    return findFactoryByAlgorithmAndType(algorithm, indexType)        .createIndex(name, storage, indexType, algorithm, valueContainerAlgorithm, metadata, version);  }
public boolean collectResponse(final ODistributedResponse response) {    final String executorNode = response.getExecutorNodeName();    final String senderNode = response.getSenderNodeName();    response.setDistributedResponseManager(this);    synchronousResponsesLock.lock();    try {      if (!executorNode.equals(dManager.getLocalNodeName()) && !responses.containsKey(executorNode)) {        ODistributedServerLog.warn(this, senderNode, executorNode, DIRECTION.IN,            "Received response for request (%s) from unexpected node. Expected are: %s", request, getExpectedNodes());        Orient.instance().getProfiler()            .updateCounter("distributed.node.unexpectedNodeResponse", "Number of responses from unexpected nodes", +1);        return false;      }      dManager.getMessageService().updateLatency(executorNode, sentOn);      responses.put(executorNode, response);      receivedResponses++;      if (waitForLocalNode && executorNode.equals(senderNode))        receivedCurrentNode = true;      if (ODistributedServerLog.isDebugEnabled())        ODistributedServerLog.debug(this, senderNode, executorNode, DIRECTION.IN,            "Received response '%s' for request (%s) (receivedCurrentNode=%s receivedResponses=%d totalExpectedResponses=%d quorum=%d)",            response, request, receivedCurrentNode, receivedResponses, totalExpectedResponses, quorum);      if (groupResponsesByResult) {        // PUT THE RESPONSE IN THE RIGHT RESPONSE GROUP        // TODO: AVOID TO KEEP ALL THE RESULT FOR THE SAME RESP GROUP, BUT RATHER THE FIRST ONE + COUNTER        final Object responsePayload = response.getPayload();        boolean foundBucket = false;        for (int i = 0; i < responseGroups.size(); ++i) {          final List<ODistributedResponse> responseGroup = responseGroups.get(i);          if (responseGroup.isEmpty())            // ABSENT            foundBucket = true;          else {            final Object rgPayload = responseGroup.get(0).getPayload();            if (rgPayload == null && responsePayload == null)              // BOTH NULL              foundBucket = true;            else if (rgPayload != null) {              if (rgPayload instanceof ODocument && responsePayload instanceof ODocument && !((ODocument) rgPayload).getIdentity()                  .isValid() && ((ODocument) rgPayload).hasSameContentOf((ODocument) responsePayload))                // SAME RESULT                foundBucket = true;              else if (rgPayload.equals(responsePayload))                // SAME RESULT                foundBucket = true;              else if (rgPayload instanceof Collection && responsePayload instanceof Collection) {                if (OMultiValue.equals((Collection) rgPayload, (Collection) responsePayload))                  // COLLECTIONS WITH THE SAME VALUES                  foundBucket = true;              }            }          }          if (foundBucket) {            responseGroup.add(response);            break;          }        }        if (!foundBucket) {          // CREATE A NEW BUCKET          final ArrayList<ODistributedResponse> newBucket = new ArrayList<ODistributedResponse>();          responseGroups.add(newBucket);          newBucket.add(response);        }      }      // FOR EVERY RESPONSE COLLECTED, COMPUTE THE FINAL QUORUM RESPONSE IF POSSIBLE      computeQuorumResponse(false);      return checkForCompletion();    } finally {      synchronousResponsesLock.unlock();    }  }
public boolean setLocalResult(final String localNodeName, final Object localResult) {    localResponse = new ODistributedResponse(this, request.getId(), localNodeName, localNodeName, localResult);    receivedCurrentNode = true;    return collectResponse(localResponse);  }
public boolean waitForSynchronousResponses() throws InterruptedException {    final long beginTime = System.currentTimeMillis();    try {      boolean reachedTimeout = false;      long currentTimeout = synchTimeout;      while (currentTimeout > 0) {        if (currentTimeout > 10000)          // CUT THE TIMEOUT IN BLOCKS OF 10S EACH TO ALLOW CHECKING FOR ANY SERVER IF UNREACHABLE          currentTimeout = 10000;        if (ODistributedServerLog.isDebugEnabled())          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,              "Waiting max %dms for collecting all synchronous responses... (timeout=%d reqId=%s thread=%d)", currentTimeout,              synchTimeout, request.getId(), Thread.currentThread().getId());        // WAIT FOR THE RESPONSES        if (synchronousResponsesArrived.await(currentTimeout, TimeUnit.MILLISECONDS)) {          if (canceled.get())            throw new ODistributedOperationException("Request has been canceled");          // COMPLETED          if (ODistributedServerLog.isDebugEnabled())            ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,                "All synchronous responses collected in %dms (reqId=%s thread=%d)", (System.currentTimeMillis() - beginTime),                request.getId(), Thread.currentThread().getId());          return true;        }        if (ODistributedServerLog.isDebugEnabled())          ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,              "All synchronous responses not collected in %dms, waiting again... (reqId=%s thread=%d)",              (System.currentTimeMillis() - beginTime), request.getId(), Thread.currentThread().getId());        if (Thread.currentThread().isInterrupted()) {          // INTERRUPTED          ODistributedServerLog              .warn(this, dManager.getLocalNodeName(), null, DIRECTION.NONE, "Thread has been interrupted wait for request (%s)",                  request);          Thread.currentThread().interrupt();          break;        }        synchronousResponsesLock.lock();        try {          final long now = System.currentTimeMillis();          final long elapsed = now - beginTime;          if (elapsed > synchTimeout)            reachedTimeout = true;          currentTimeout = synchTimeout - elapsed;          // CHECK IF ANY NODE ARE UNREACHABLE IN THE MEANWHILE          int synchronizingNodes = 0;          int missingActiveNodes = 0;          Map<String, ODistributedServerManager.DB_STATUS> missingResponseNodeStatuses = new HashMap<String, ODistributedServerManager.DB_STATUS>(              responses.size());          int missingResponses = 0;          for (Iterator<Map.Entry<String, Object>> iter = responses.entrySet().iterator(); iter.hasNext(); ) {            final Map.Entry<String, Object> curr = iter.next();            if (curr.getValue() == NO_RESPONSE) {              missingResponses++;              // ANALYZE THE NODE WITHOUT A RESPONSE              final ODistributedServerManager.DB_STATUS dbStatus = dManager.getDatabaseStatus(curr.getKey(), getDatabaseName());              missingResponseNodeStatuses.put(curr.getKey(), dbStatus);              switch (dbStatus) {              case BACKUP:              case SYNCHRONIZING:                synchronizingNodes++;                missingActiveNodes++;                break;              case ONLINE:                missingActiveNodes++;                break;              }            }          }          if (missingResponses == 0) {            // ALL RESPONSE COLLECTED, BUT NO QUORUM REACHED            ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,                "All responses collected %s, but no quorum reached (reqId=%s)", responses, request.getId());            break;          }          request.getTask().checkIsValid(dManager);          if (missingActiveNodes == 0) {            // NO MORE ACTIVE NODES TO WAIT            ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,                "No more active nodes to wait for request (%s): anticipate timeout (saved %d ms). Missing servers: %s", request,                currentTimeout, missingResponseNodeStatuses);            break;          }          final long lastClusterChange = dManager.getLastClusterChangeOn();          if (lastClusterChange > 0 && now - lastClusterChange < (synchTimeout + ADDITIONAL_TIMEOUT_CLUSTER_SHAPE)) {            // CHANGED CLUSTER SHAPE DURING WAIT: ENLARGE TIMEOUT            currentTimeout = synchTimeout;            ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,                "Cluster shape changed during request (%s): enlarge timeout +%dms, wait again for %dms", request, synchTimeout,                currentTimeout);            continue;          } else if (synchronizingNodes > 0) {            // SOME NODE IS SYNCHRONIZING: WAIT FOR THEM            // currentTimeout = synchTimeout;            // ODistributedServerLog.debug(this, dManager.getLocalNodeName(), null, DIRECTION.NONE,            // "%d nodes are in synchronization mode during request (%s): enlarge timeout +%dms, wait again for %dms",            // synchronizingNodes, request, synchTimeout, currentTimeout);          }        } finally {          synchronousResponsesLock.unlock();        }      }      if (canceled.get())        throw new ODistributedOperationException("Request has been canceled");      return isMinimumQuorumReached(reachedTimeout);    } finally {      Orient.instance().getProfiler()          .stopChrono("distributed.synchResponses", "Time to collect all the synchronous responses from distributed nodes",              beginTime);    }  }
public List<String> getMissingNodes() {    synchronousResponsesLock.lock();    try {      final List<String> missingNodes = new ArrayList<String>();      for (Map.Entry<String, Object> entry : responses.entrySet())        if (entry.getValue() == NO_RESPONSE)          missingNodes.add(entry.getKey());      return missingNodes;    } finally {      synchronousResponsesLock.unlock();    }  }
protected List<ODistributedResponse> getConflictResponses() {    final List<ODistributedResponse> servers = new ArrayList<ODistributedResponse>();    int bestGroupSoFar = getBestResponsesGroup();    for (int i = 0; i < responseGroups.size(); ++i) {      if (i != bestGroupSoFar) {        for (ODistributedResponse r : responseGroups.get(i))          servers.add(r);      }    }    return servers;  }
protected int getBestResponsesGroup() {    int maxCoherentResponses = 0;    int bestGroupSoFar = 0;    for (int i = 0; i < responseGroups.size(); ++i) {      final int currentGroupSize = responseGroups.get(i).size();      if (currentGroupSize > maxCoherentResponses) {        maxCoherentResponses = currentGroupSize;        bestGroupSoFar = i;      }    }    return bestGroupSoFar;  }
private boolean computeQuorumResponse(boolean reachedTimeout) {    if (quorumResponse != null)      // ALREADY COMPUTED      return true;    if (groupResponsesByResult) {      for (List<ODistributedResponse> group : responseGroups) {        if (group.size() >= quorum) {          int responsesForQuorum = 0;          for (ODistributedResponse r : group) {            if (nodesConcurInQuorum.contains(r.getExecutorNodeName())) {              final Object payload = r.getPayload();              if (payload instanceof Throwable) {                if (payload instanceof ODistributedRecordLockedException)                  // JUST ONE ODistributedRecordLockedException IS ENOUGH TO FAIL THE OPERATION BECAUSE RESOURCES CANNOT BE LOCKED                  break;                if (payload instanceof OConcurrentCreateException)                  // JUST ONE OConcurrentCreateException IS ENOUGH TO FAIL THE OPERATION BECAUSE RID ARE DIFFERENT                  break;              } else if (++responsesForQuorum >= quorum) {                // QUORUM REACHED                setQuorumResponse(r);                return true;              }            }          }        }      }    } else {      if (receivedResponses >= quorum) {        int responsesForQuorum = 0;        for (Map.Entry<String, Object> response : responses.entrySet()) {          if (response.getValue() != NO_RESPONSE && nodesConcurInQuorum.contains(response.getKey())              && ++responsesForQuorum >= quorum) {            // QUORUM REACHED            ODistributedResponse resp = (ODistributedResponse) response.getValue();            if (resp != null && !(resp.getPayload() instanceof Throwable))              setQuorumResponse(resp);            return true;          }        }      }    }    return false;  }
protected List<ODistributedResponse> getReceivedResponses() {    final List<ODistributedResponse> parsed = new ArrayList<ODistributedResponse>();    for (Object r : responses.values())      if (r != NO_RESPONSE)        parsed.add((ODistributedResponse) r);    return parsed;  }
public static OExecutionPlan get(String statement, OCommandContext ctx, ODatabaseDocumentInternal db) {    if (db == null) {      throw new IllegalArgumentException("DB cannot be null");    }    if (statement == null) {      return null;    }    OExecutionPlanCache resource = db.getSharedContext().getExecutionPlanCache();    OExecutionPlan result = resource.getInternal(statement, ctx, db);    return result;  }
public OExecutionPlan getInternal(String statement, OCommandContext ctx, ODatabaseDocumentInternal db) {    OInternalExecutionPlan result;    if (statement == null) {      return null;    }    synchronized (map) {      //LRU      result = map.remove(statement);      if (result != null) {        map.put(statement, result);        result = result.copy(ctx);      }    }    return result;  }
List<String> getMatchPatternInvolvedAliases() {    if (mathExpression != null)      return mathExpression.getMatchPatternInvolvedAliases();    if (arrayConcatExpression != null)      return arrayConcatExpression.getMatchPatternInvolvedAliases();    return null;  }
public boolean allowsIndexedFunctionExecutionOnTarget(OFromClause target, OCommandContext context) {    return left.allowsIndexedFunctionExecutionOnTarget(target, context, operator, right.execute((OResult) null, context));  }
public String getLibrary(final ODatabase<?> db, final String iLanguage) {    if (db == null)      // NO DB = NO LIBRARY      return null;    final StringBuilder code = new StringBuilder();    final Set<String> functions = db.getMetadata().getFunctionLibrary().getFunctionNames();    for (String fName : functions) {      final OFunction f = db.getMetadata().getFunctionLibrary().getFunction(fName);      if (f.getLanguage() == null)        throw new OConfigurationException("Database function '" + fName + "' has no language");      if (f.getLanguage().equalsIgnoreCase(iLanguage)) {        final String def = getFunctionDefinition(f);        if (def != null) {          code.append(def);          code.append("\n");        }      }    }    return code.length() == 0 ? null : code.toString();  }
public OPartitionedObjectPool.PoolEntry<ScriptEngine> acquireDatabaseEngine(final String databaseName, final String language) {    ODatabaseScriptManager dbManager = dbManagers.get(databaseName);    if (dbManager == null) {      // CREATE A NEW DATABASE SCRIPT MANAGER      dbManager = new ODatabaseScriptManager(this, databaseName);      final ODatabaseScriptManager prev = dbManagers.putIfAbsent(databaseName, dbManager);      if (prev != null) {        dbManager.close();        // GET PREVIOUS ONE        dbManager = prev;      }    }    return dbManager.acquireEngine(language);  }
public void releaseDatabaseEngine(final String iLanguage, final String iDatabaseName,      final OPartitionedObjectPool.PoolEntry<ScriptEngine> poolEntry) {    final ODatabaseScriptManager dbManager = dbManagers.get(iDatabaseName);    // We check if there is still a valid pool because it could be removed by the function reload    if (dbManager != null) {      dbManager.releaseEngine(iLanguage, poolEntry);    }  }
public void unbind(ScriptEngine scriptEngine, final Bindings binding, final OCommandContext iContext,      final Map<Object, Object> iArgs) {    for (OScriptInjection i : injections)      i.unbind(scriptEngine, binding);    binding.put("db", null);    binding.put("orient", null);    binding.put("util", null);    binding.put("ctx", null);    if (iContext != null) {      for (Entry<String, Object> a : iContext.getVariables().entrySet())        binding.put(a.getKey(), null);    }    if (iArgs != null) {      for (Entry<Object, Object> a : iArgs.entrySet())        binding.put(a.getKey().toString(), null);    }    binding.put("params", null);  }  public void registerInjection(final OScriptInjection iInj) {    if (!injections.contains(iInj))      injections.add(iInj);  }  public void unregisterInjection(final OScriptInjection iInj) {    injections.remove(iInj);  }  public List<OScriptInjection> getInjections() {    return injections;  }  public OScriptManager registerEngine(final String iLanguage, final ScriptEngineFactory iEngine) {    engines.put(iLanguage, iEngine);    return this;  }  public OScriptManager registerFormatter(final String iLanguage, final OScriptFormatter iFormatterImpl) {    formatters.put(iLanguage.toLowerCase(Locale.ENGLISH), iFormatterImpl);    return this;  }  public OScriptManager registerResultHandler(final String iLanguage, final OScriptResultHandler resultHandler) {    handlers.put(iLanguage.toLowerCase(Locale.ENGLISH), resultHandler);    return this;  }  public Object handleResult(String language, Object result, ScriptEngine engine, Bindings binding, ODatabaseDocument database) {    OScriptResultHandler handler = handlers.get(language);    if (handler != null) {      return handler.handle(result, engine, binding, database);    } else {      return result;    }  }  /**   * Ask to the Script engine all the formatters   *   * @return Map containing all the formatters   */  public Map<String, OScriptFormatter> getFormatters() {    return formatters;  }  /**   * Closes the pool for a database. This is called at Orient shutdown and in case a function has been updated.   *   * @param iDatabaseName   */  public void close(final String iDatabaseName) {    final ODatabaseScriptManager dbPool = dbManagers.remove(iDatabaseName);    if (dbPool != null)      dbPool.close();  }}
long getNextPosition(final OAtomicOperation atomicOperation) throws IOException {    final long filledUpTo = getFilledUpTo(atomicOperation, fileId);    final long pageIndex = filledUpTo - 1;    final OCacheEntry cacheEntry = loadPageForRead(atomicOperation, fileId, pageIndex, false, 1);    try {      final OClusterPositionMapBucket bucket = new OClusterPositionMapBucket(cacheEntry, false);      final int bucketSize = bucket.getSize();      return pageIndex * OClusterPositionMapBucket.MAX_ENTRIES + bucketSize;    } finally {      releasePageFromRead(atomicOperation, cacheEntry);    }  }
private int updateSize() {    int size = 0;    if (collectionPointer != null) {      final OSBTreeBonsai<OIdentifiable, Integer> tree = loadTree();      if (tree == null) {        throw new IllegalStateException("RidBag is not properly initialized, can not load tree implementation");      }      try {        size = tree.getRealBagSize(changes);      } finally {        releaseTree();      }    } else {      for (Change change : changes.values()) {        size += change.applyTo(0);      }    }    for (OModifiableInteger diff : newEntries.values()) {      size += diff.getValue();    }    this.size = size;    return size;  }
private boolean removeFromNewEntries(final OIdentifiable identifiable) {    OModifiableInteger counter = newEntries.get(identifiable);    if (counter == null) {      return false;    } else {      if (counter.getValue() == 1) {        newEntries.remove(identifiable);      } else {        counter.decrement();      }      return true;    }  }
private void processAndBlock() {    OCollection fromKey = indexKeyFrom((OAndBlock) condition, additionalRangeCondition);    OCollection toKey = indexKeyTo((OAndBlock) condition, additionalRangeCondition);    boolean fromKeyIncluded = indexKeyFromIncluded((OAndBlock) condition, additionalRangeCondition);    boolean toKeyIncluded = indexKeyToIncluded((OAndBlock) condition, additionalRangeCondition);    init(fromKey, fromKeyIncluded, toKey, toKeyIncluded);  }
private Object unboxOResult(Object value) {    if (value instanceof List) {      return ((List) value).stream().map(x -> unboxOResult(x)).collect(Collectors.toList());    }    if (value instanceof OResult) {      if (((OResult) value).isElement()) {        return ((OResult) value).getIdentity().orElse(null);      }      Set<String> props = ((OResult) value).getPropertyNames();      if (props.size() == 1) {        return ((OResult) value).getProperty(props.iterator().next());      }    }    return value;  }
public V getValue(int index) {    int entryPosition = getIntValue(POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer.INT_SIZE);    // skip hash code    entryPosition += OLongSerializer.LONG_SIZE;    if (encryption == null) {      // skip key      entryPosition += getObjectSizeInDirectMemory(keySerializer, entryPosition);    } else {      final int encryptedLength = getIntValue(entryPosition);      entryPosition += encryptedLength + OIntegerSerializer.INT_SIZE;    }    return deserializeFromDirectMemory(valueSerializer, entryPosition);  }
boolean canBeUsedByOrderByAfterFilter(OIndex<?> index, List<String> equalsFilterFields,      List<OPair<String, String>> orderedFields) {    if (orderedFields.isEmpty())      return false;    if (!index.supportsOrderedIterations())      return false;    final OIndexDefinition definition = index.getDefinition();    final List<String> indexFields = definition.getFields();    int endIndex = Math.min(indexFields.size(), equalsFilterFields.size());    final String firstOrder = orderedFields.get(0).getValue();    //check that all the "equals" clauses are a prefix for the index    for (int i = 0; i < endIndex; i++) {      final String equalsFieldName = equalsFilterFields.get(i);      final String indexFieldName = indexFields.get(i);      if (!equalsFieldName.equals(indexFieldName))        return false;    }    endIndex = Math.min(indexFields.size(), orderedFields.size() + equalsFilterFields.size());    if (endIndex == equalsFilterFields.size()) {      //the index is used only for filtering      return false;    }    //check that after that prefix there all the Order By fields in the right order    for (int i = equalsFilterFields.size(); i < endIndex; i++) {      int fieldOrderInOrderByClause = i - equalsFilterFields.size();      final OPair<String, String> pair = orderedFields.get(fieldOrderInOrderByClause);      if (!firstOrder.equals(pair.getValue()))        return false;      final String orderFieldName = pair.getKey();      final String indexFieldName = indexFields.get(i);      if (!orderFieldName.equals(indexFieldName))        return false;    }    return true;  }
public static int indexOfOutsideStrings(final String iText, final char iToFind, int iFrom, int iTo) {    if (iTo == -1)      iTo = iText.length() - 1;    if (iFrom == -1)      iFrom = iText.length() - 1;    char c;    char stringChar = ' ';    boolean escape = false;    final StringBuilder buffer = new StringBuilder(1024);    int i = iFrom;    while (true) {      c = iText.charAt(i);      if (!escape && c == '\\' && ((i + 1) < iText.length())) {        if (iText.charAt(i + 1) == 'u') {          i = readUnicode(iText, i + 2, buffer);        } else          escape = true;      } else {        if (c == '\'' || c == '"') {          // BEGIN/END STRING          if (stringChar == ' ') {            // BEGIN            stringChar = c;          } else {            // END            if (!escape && c == stringChar)              stringChar = ' ';          }        }        if (c == iToFind && stringChar == ' ')          return i;        if (escape)          escape = false;      }      if (iFrom < iTo) {        // MOVE FORWARD        if (++i > iTo)          break;      } else {        // MOVE BACKWARD        if (--i < iFrom)          break;      }    }    return -1;  }
public static int jumpWhiteSpaces(final CharSequence iText, final int iCurrentPosition, final int iMaxPosition) {    return jump(iText, iCurrentPosition, iMaxPosition, COMMON_JUMP);  }
public static int jump(final CharSequence iText, int iCurrentPosition, final int iMaxPosition, final String iJumpChars) {    if (iCurrentPosition < 0)      return -1;    final int size = iMaxPosition > -1 ? Math.min(iMaxPosition, iText.length()) : iText.length();    final int jumpCharSize = iJumpChars.length();    boolean found = true;    char c;    for (; iCurrentPosition < size; ++iCurrentPosition) {      found = false;      c = iText.charAt(iCurrentPosition);      for (int jumpIndex = 0; jumpIndex < jumpCharSize; ++jumpIndex) {        if (iJumpChars.charAt(jumpIndex) == c) {          found = true;          break;        }      }      if (!found)        break;    }    return iCurrentPosition >= size ? -1 : iCurrentPosition;  }
public static boolean startsWithIgnoreCase(final String iText, final String iToFind) {    if (iText.length() < iToFind.length())      return false;    return iText.substring(0, iToFind.length()).equalsIgnoreCase(iToFind);  }
public OQueryAbstract setFetchPlan(final String fetchPlan) {    OFetchHelper.checkFetchPlanValid(fetchPlan);    if (fetchPlan != null && fetchPlan.length() == 0)      this.fetchPlan = null;    else      this.fetchPlan = fetchPlan;    return this;  }
@Override  public void enqueueRepairRecord(final ORecordId rid) {    if (!active)      return;    if (rid == null || !rid.isPersistent())      return;    if (rid.getClusterPosition() < -1)      // SKIP TRANSACTIONAL RIDS      return;    recordProcessed.incrementAndGet();    // ADD RECORD TO REPAIR    records.put(rid, Boolean.TRUE);  }
@Override  public void cancelRepairRecord(final ORecordId rid) {    if (!active)      return;    if (rid.getClusterPosition() < -1)      // SKIP TRANSACTIONAL RIDS      return;    // REMOVE THE RECORD TO REPAIR    if (records.remove(rid) != null)      // REMOVED      recordCanceled.incrementAndGet();  }
@Override  public void enqueueRepairCluster(final int clusterId) {    if (!active)      return;    if (clusterId < -1)      // SKIP TRANSACTIONAL RIDS      return;    recordProcessed.incrementAndGet();    // ADD CLUSTER TO REPAIR    clusters.put(clusterId, Boolean.TRUE);  }
public Object execute(final Map<Object, Object> iArgs) {    final ODatabaseDocumentInternal database = getDatabase();    database.checkSecurity(ORule.ResourceGeneric.SERVER, "status", ORole.PERMISSION_READ);    if (!(database instanceof ODatabaseDocumentDistributed)) {      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    }    final OHazelcastPlugin dManager = (OHazelcastPlugin) ((ODatabaseDocumentDistributed) database).getDistributedManager();    if (dManager == null || !dManager.isEnabled())      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    final String databaseName = database.getName();    final ODistributedConfiguration cfg = dManager.getDatabaseConfiguration(databaseName);    if (parsedStatement.outputText) {      final StringBuilder output = new StringBuilder();      if (parsedStatement.servers)        output.append(ODistributedOutput.formatServerStatus(dManager, dManager.getClusterConfiguration()));      if (parsedStatement.db)        output.append(ODistributedOutput.formatClusterTable(dManager, databaseName, cfg, dManager.getTotalNodes(databaseName)));      if (parsedStatement.latency)        output.append(ODistributedOutput.formatLatency(dManager, dManager.getClusterConfiguration()));      if (parsedStatement.messages)        output.append(ODistributedOutput.formatMessages(dManager, dManager.getClusterConfiguration()));      return output.toString();    }    final ODocument output = new ODocument();    if (parsedStatement.servers)      output.field("servers", dManager.getClusterConfiguration(), OType.EMBEDDED);    if (parsedStatement.db)      output.field("database", cfg.getDocument(), OType.EMBEDDED);    return output;  }
private Map<String, Set<String>> getDependencies(Pattern pattern) {    Map<String, Set<String>> result = new HashMap<String, Set<String>>();    for (PatternNode node : pattern.aliasToNode.values()) {      Set<String> currentDependencies = new HashSet<String>();      OWhereClause filter = aliasFilters.get(node.alias);      if (filter != null && filter.getBaseExpression() != null) {        List<String> involvedAliases = filter.getBaseExpression().getMatchPatternInvolvedAliases();        if (involvedAliases != null) {          currentDependencies.addAll(involvedAliases);        }      }      result.put(node.alias, currentDependencies);    }    return result;  }
private List<EdgeTraversal> sortEdges(Map<String, Long> estimatedRootEntries, Pattern pattern, OCommandContext ctx) {    OQueryStats stats = null;    if (ctx != null && ctx.getDatabase() != null) {      stats = OQueryStats.get((ODatabaseDocumentInternal) ctx.getDatabase());    }    //TODO use the stats    List<EdgeTraversal> result = new ArrayList<EdgeTraversal>();    List<OPair<Long, String>> rootWeights = new ArrayList<OPair<Long, String>>();    for (Map.Entry<String, Long> root : estimatedRootEntries.entrySet()) {      rootWeights.add(new OPair<Long, String>(root.getValue(), root.getKey()));    }    Collections.sort(rootWeights);    Set<PatternEdge> traversedEdges = new HashSet<PatternEdge>();    Set<PatternNode> traversedNodes = new HashSet<PatternNode>();    List<PatternNode> nextNodes = new ArrayList<PatternNode>();    while (result.size() < pattern.getNumOfEdges()) {      for (OPair<Long, String> rootPair : rootWeights) {        PatternNode root = pattern.get(rootPair.getValue());        if (root.isOptionalNode()) {          continue;        }        if (!traversedNodes.contains(root)) {          nextNodes.add(root);          break;        }      }      if (nextNodes.isEmpty()) {        break;      }      while (!nextNodes.isEmpty()) {        PatternNode node = nextNodes.remove(0);        traversedNodes.add(node);        for (PatternEdge edge : node.out) {          if (!traversedEdges.contains(edge)) {            result.add(new EdgeTraversal(edge, true));            traversedEdges.add(edge);            if (!traversedNodes.contains(edge.in) && !nextNodes.contains(edge.in)) {              nextNodes.add(edge.in);            }          }        }        for (PatternEdge edge : node.in) {          if (!traversedEdges.contains(edge) && edge.item.isBidirectional()) {            result.add(new EdgeTraversal(edge, false));            traversedEdges.add(edge);            if (!traversedNodes.contains(edge.out) && !nextNodes.contains(edge.out)) {              nextNodes.add(edge.out);            }          }        }      }    }    return result;  }
private void assignDefaultAliases(List<OMatchExpression> matchExpressions) {    int counter = 0;    for (OMatchExpression expression : matchExpressions) {      if (expression.getOrigin().getAlias() == null) {        expression.getOrigin().setAlias(DEFAULT_ALIAS_PREFIX + (counter++));      }      for (OMatchPathItem item : expression.getItems()) {        if (item.getFilter() == null) {          item.setFilter(new OMatchFilter(-1));        }        if (item.getFilter().getAlias() == null) {          item.getFilter().setAlias(DEFAULT_ALIAS_PREFIX + (counter++));        }      }    }  }
public synchronized Object createPojo(final String iClassName) throws OConfigurationException {    if (iClassName == null)      throw new IllegalArgumentException("Cannot create the object: class name is empty");    final Class<?> entityClass = classHandler.getEntityClass(iClassName);    try {      if (entityClass != null)        return createInstance(entityClass);    } catch (Exception e) {      throw OException.wrapException(new OConfigurationException("Error while creating new pojo of class '" + iClassName + "'"), e);    }    try {      // TRY TO INSTANTIATE THE CLASS DIRECTLY BY ITS NAME      return createInstance(Class.forName(iClassName));    } catch (Exception e) {      throw OException.wrapException(new OConfigurationException("The class '" + iClassName          + "' was not found between the entity classes. Ensure registerEntityClasses(package) has been called first"), e);    }  }
public synchronized void deregisterEntityClasses(final String iPackageName, final ClassLoader iClassLoader) {    OLogManager.instance().debug(this, "Discovering entity classes inside package: %s", iPackageName);    List<Class<?>> classes = null;    try {      classes = OReflectionHelper.getClassesFor(iPackageName, iClassLoader);    } catch (ClassNotFoundException e) {      throw OException.wrapException(new ODatabaseException("Class cannot be found in package " + iPackageName), e);    }    for (Class<?> c : classes) {      deregisterEntityClass(c);    }    if (OLogManager.instance().isDebugEnabled()) {      for (Entry<String, Class<?>> entry : classHandler.getClassesEntrySet()) {        OLogManager.instance().debug(this, "Unloaded entity class '%s' from: %s", entry.getKey(), entry.getValue());      }    }  }
public synchronized void registerEntityClasses(final Collection<String> iClassNames, final ClassLoader iClassLoader) {    OLogManager.instance().debug(this, "Discovering entity classes for class names: %s", iClassNames);    try {      registerEntityClasses(OReflectionHelper.getClassesFor(iClassNames, iClassLoader));    } catch (ClassNotFoundException e) {      throw OException.wrapException(new ODatabaseException("Entity class cannot be found"), e);    }  }
public synchronized void registerEntityClasses(Class<?> aClass, boolean recursive) {    if (recursive) {      classHandler.registerEntityClass(aClass);      Field[] declaredFields = aClass.getDeclaredFields();      for (Field declaredField : declaredFields) {        Class<?> declaredFieldType = declaredField.getType();        if (!classHandler.containsEntityClass(declaredFieldType)) {          registerEntityClasses(declaredFieldType, recursive);        }      }    } else {      classHandler.registerEntityClass(aClass);    }  }
public synchronized void setClassHandler(final OEntityManagerClassHandler iClassHandler) {    Iterator<Entry<String, Class<?>>> iterator = classHandler.getClassesEntrySet().iterator();    while (iterator.hasNext()){      Entry<String, Class<?>> entry = iterator.next();      boolean forceSchemaReload = !iterator.hasNext();      iClassHandler.registerEntityClass(entry.getValue(), forceSchemaReload);    }    this.classHandler = iClassHandler;  }
public DB acquire(final String iName, final String iUserName, final String iUserPassword) {    setup();    return dbPool.acquire(iName, iUserName, iUserPassword);  }
public int getAvailableConnections(final String name, final String userName) {    setup();    return dbPool.getAvailableConnections(name, userName);  }
public DB acquire(final String iName, final String iUserName, final String iUserPassword,      final Map<String, Object> iOptionalParams) {    setup();    return dbPool.acquire(iName, iUserName, iUserPassword, iOptionalParams);  }
public Object execute(final Map<Object, Object> iArgs) {    final ODatabaseDocumentInternal database = getDatabase();    database.checkSecurity(ORule.ResourceGeneric.CLUSTER, "sync", ORole.PERMISSION_UPDATE);    if (!(database instanceof ODatabaseDocumentDistributed)) {      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    }    final OHazelcastPlugin dManager = (OHazelcastPlugin) ((ODatabaseDocumentDistributed) database).getDistributedManager();    if (dManager == null || !dManager.isEnabled())      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    final String databaseName = database.getName();    try {      if (this.parsedStatement.modeFull) {        return replaceCluster(dManager, database, dManager.getServerInstance(), databaseName, this.parsedStatement.clusterName.getStringValue());      }      // else {      // int merged = 0;      // return String.format("Merged %d records", merged);      // }    } catch (Exception e) {      throw OException.wrapException(new OCommandExecutionException("Cannot execute synchronization of cluster"), e);    }    return "Mode not supported";  }
public void dumpToLog() {    final StringBuilder text = new StringBuilder();    text.append("Dump of ").append(this).append('\n');    text.append("Magic:\t\t\t").append(String.format("%016X", getLongValue(MAGIC_NUMBER_OFFSET))).append('\n');    text.append("CRC32:\t\t\t").append(String.format("%08X", getIntValue(CRC32_OFFSET))).append('\n');    text.append("WAL Segment:\t").append(String.format("%016X", getLongValue(WAL_SEGMENT_OFFSET))).append('\n');    text.append("WAL Position:\t").append(String.format("%016X", getLongValue(WAL_POSITION_OFFSET))).append('\n');    text.append("Next Page:\t\t").append(String.format("%016X", getLongValue(NEXT_PAGE_OFFSET))).append('\n');    text.append("Prev Page:\t\t").append(String.format("%016X", getLongValue(PREV_PAGE_OFFSET))).append('\n');    text.append("Free List:\t\t").append(String.format("%08X", getIntValue(FREELIST_HEADER_OFFSET))).append('\n');    text.append("Free Pointer:\t").append(String.format("%08X", getIntValue(FREE_POSITION_OFFSET))).append('\n');    text.append("Free Space:\t\t").append(String.format("%08X", getIntValue(FREE_SPACE_COUNTER_OFFSET))).append('\n');    text.append("Entry Count:\t").append(String.format("%08X", getIntValue(ENTRIES_COUNT_OFFSET))).append('\n');    final int indexCount = getIntValue(PAGE_INDEXES_LENGTH_OFFSET);    text.append("Index Count:\t").append(String.format("%08X", indexCount)).append("\n\n");    int foundEntries = 0;    for (int i = 0; i < indexCount; ++i) {      final int offset = getIntValue(PAGE_INDEXES_OFFSET + i * INDEX_ITEM_SIZE);      text.append("\tOffset:\t\t").append(String.format("%08X", offset)).append(" (").append(i).append(")\n");      text.append("\tVersion:\t")          .append(String.format("%08X", getIntValue(PAGE_INDEXES_OFFSET + i * INDEX_ITEM_SIZE + OIntegerSerializer.INT_SIZE)))          .append('\n');      if ((offset & MARKED_AS_DELETED_FLAG) != 0) {        continue;      }      final int cleanOffset = offset & POSITION_MASK;      text.append("\t\tEntry Size:\t");      if (cleanOffset + OIntegerSerializer.INT_SIZE <= MAX_PAGE_SIZE_BYTES) {        text.append(String.format("%08X", getIntValue(cleanOffset))).append(" (").append(foundEntries).append(")\n");      } else {        text.append("?\n");      }      if (cleanOffset + OIntegerSerializer.INT_SIZE * 2 <= MAX_PAGE_SIZE_BYTES) {        text.append("\t\tIndex:\t\t").append(String.format("%08X", getIntValue(cleanOffset + OIntegerSerializer.INT_SIZE)))            .append('\n');      } else {        text.append("?\n");      }      if (cleanOffset + OIntegerSerializer.INT_SIZE * 3 <= MAX_PAGE_SIZE_BYTES) {        text.append("\t\tData Size:\t").append(String.format("%08X", getIntValue(cleanOffset + OIntegerSerializer.INT_SIZE * 2)))            .append('\n');      } else {        text.append("?\n");      }      ++foundEntries;    }    OLogManager.instance().error(this, "%s", null, text);  }
public static synchronized <T extends Object> Iterator<T> lookupProviderWithOrientClassLoader(Class<T> clazz) {    return lookupProviderWithOrientClassLoader(clazz, OClassLoaderHelper.class.getClassLoader());  }
public static long getCappedRuntimeMaxMemory(long unlimitedCap) {    final long jvmMaxMemory = Runtime.getRuntime().maxMemory();    return jvmMaxMemory == Long.MAX_VALUE ? unlimitedCap : jvmMaxMemory;  }
public static void checkCacheMemoryConfiguration() {    final long maxHeapSize = Runtime.getRuntime().maxMemory();    final long maxCacheSize = getMaxCacheMemorySize();    final ONative.MemoryLimitResult physicalMemory = ONative.instance().getMemoryLimit(false);    if (maxHeapSize != Long.MAX_VALUE && physicalMemory != null && maxHeapSize + maxCacheSize > physicalMemory.memoryLimit)      OLogManager.instance().warnNoDb(OMemory.class,          "The sum of the configured JVM maximum heap size (" + maxHeapSize + " bytes) " + "and the OrientDB maximum cache size ("              + maxCacheSize + " bytes) is larger than the available physical memory size " + "(" + physicalMemory              + " bytes). That may cause out of memory errors, please tune the configuration up. Use the "              + "-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to "              + "lower memory requirements of the cache.");  }
public static void fixCommonConfigurationProblems() {    long diskCacheSize = OGlobalConfiguration.DISK_CACHE_SIZE.getValueAsLong();    final int max32BitCacheSize = 512;    if (getJavaBitWidth() == 32 && diskCacheSize > max32BitCacheSize) {      OLogManager.instance()          .infoNoDb(OGlobalConfiguration.class, "32 bit JVM is detected. Lowering disk cache size from %,dMB to %,dMB.",              diskCacheSize, max32BitCacheSize);      OGlobalConfiguration.DISK_CACHE_SIZE.setValue(max32BitCacheSize);    }  }
public Vertex vertexFromJson(final InputStream json) throws IOException {    final JsonParser jp = jsonFactory.createParser(json);    final JsonNode node = jp.readValueAsTree();    return this.vertexFromJson(node);  }
public Vertex vertexFromJson(final JsonNode json) throws IOException {    final Map<String, Object> props = readProperties(json, true, this.hasEmbeddedTypes);    final Object vertexId = getTypedValueFromJsonNode(json.get(GraphSONTokens._ID));    final Vertex v = factory.createVertex(vertexId);    for (Map.Entry<String, Object> entry : props.entrySet()) {      // if (this.vertexPropertyKeys == null || vertexPropertyKeys.contains(entry.getKey())) {      if (includeKey(entry.getKey(), vertexPropertyKeys, this.vertexPropertiesRule)) {        v.setProperty(entry.getKey(), entry.getValue());      }    }    return v;  }
public Edge edgeFromJson(final JSONObject json, final Vertex out, final Vertex in) throws IOException {    return this.edgeFromJson(json.toString(), out, in);  }
public Edge edgeFromJson(final String json, final Vertex out, final Vertex in) throws IOException {    final JsonParser jp = jsonFactory.createParser(json);    final JsonNode node = jp.readValueAsTree();    return this.edgeFromJson(node, out, in);  }
public Edge edgeFromJson(final JsonNode json, final Vertex out, final Vertex in) throws IOException {    final Map<String, Object> props = OGraphSONUtility.readProperties(json, true, this.hasEmbeddedTypes);    final Object edgeId = getTypedValueFromJsonNode(json.get(GraphSONTokens._ID));    final JsonNode nodeLabel = json.get(GraphSONTokens._LABEL);    // assigned an empty string edge label in cases where one does not exist. this gets around the requirement    // that blueprints graphs have a non-null label while ensuring that GraphSON can stay flexible in parsing    // partial bits from the JSON. Not sure if there is any gotchas developing out of this.    final String label = nodeLabel == null ? EMPTY_STRING : nodeLabel.textValue();    final Edge e = factory.createEdge(edgeId, out, in, label);    for (Map.Entry<String, Object> entry : props.entrySet()) {      // if (this.edgePropertyKeys == null || this.edgePropertyKeys.contains(entry.getKey())) {      if (includeKey(entry.getKey(), edgePropertyKeys, this.edgePropertiesRule)) {        e.setProperty(entry.getKey(), entry.getValue());      }    }    return e;  }
public JSONObject jsonFromElement(final Element element) throws JSONException {    final ObjectNode objectNode = this.objectNodeFromElement(element);    try {      return new JSONObject(new JSONTokener(mapper.writeValueAsString(objectNode)));    } catch (IOException ioe) {      // repackage this as a JSONException...seems sensible as the caller will only know about      // the jettison object not being created      throw new JSONException(ioe);    }  }
public ObjectNode objectNodeFromElement(final Element element) {    final boolean isEdge = element instanceof Edge;    final boolean showTypes = mode == GraphSONMode.EXTENDED;    final List<String> propertyKeys = isEdge ? this.edgePropertyKeys : this.vertexPropertyKeys;    final ElementPropertiesRule elementPropertyConfig = isEdge ? this.edgePropertiesRule : this.vertexPropertiesRule;    final ObjectNode jsonElement = createJSONMap(createPropertyMap(element, propertyKeys, elementPropertyConfig, normalized),        propertyKeys, showTypes);    if ((isEdge && this.includeReservedEdgeId) || (!isEdge && this.includeReservedVertexId)) {      putObject(jsonElement, GraphSONTokens._ID, element.getId());    }    // it's important to keep the order of these straight. check Edge first and then Vertex because there    // are graph implementations that have Edge extend from Vertex    if (element instanceof Edge) {      final Edge edge = (Edge) element;      if (this.includeReservedEdgeId) {        putObject(jsonElement, GraphSONTokens._ID, element.getId());      }      if (this.includeReservedEdgeType) {        jsonElement.put(GraphSONTokens._TYPE, GraphSONTokens.EDGE);      }      if (this.includeReservedEdgeOutV) {        putObject(jsonElement, GraphSONTokens._OUT_V, edge.getVertex(Direction.OUT).getId());      }      if (this.includeReservedEdgeInV) {        putObject(jsonElement, GraphSONTokens._IN_V, edge.getVertex(Direction.IN).getId());      }      if (this.includeReservedEdgeLabel) {        jsonElement.put(GraphSONTokens._LABEL, edge.getLabel());      }    } else if (element instanceof Vertex) {      if (this.includeReservedVertexId) {        putObject(jsonElement, GraphSONTokens._ID, element.getId());      }      if (this.includeReservedVertexType) {        jsonElement.put(GraphSONTokens._TYPE, GraphSONTokens.VERTEX);      }    }    return jsonElement;  }
public static Vertex vertexFromJson(final JSONObject json, final ElementFactory factory, final GraphSONMode mode,      final Set<String> propertyKeys) throws IOException {    final OGraphSONUtility graphson = new OGraphSONUtility(mode, factory, propertyKeys, null);    return graphson.vertexFromJson(json);  }
public static Edge edgeFromJson(final JSONObject json, final Vertex out, final Vertex in, final ElementFactory factory,      final GraphSONMode mode, final Set<String> propertyKeys) throws IOException {    final OGraphSONUtility graphson = new OGraphSONUtility(mode, factory, null, propertyKeys);    return graphson.edgeFromJson(json, out, in);  }
public static JSONObject jsonFromElement(final Element element, final Set<String> propertyKeys, final GraphSONMode mode)      throws JSONException {    final OGraphSONUtility graphson = element instanceof Edge ? new OGraphSONUtility(mode, null, null, propertyKeys)        : new OGraphSONUtility(mode, null, propertyKeys, null);    return graphson.jsonFromElement(element);  }
public static ObjectNode objectNodeFromElement(final Element element, final Set<String> propertyKeys, final GraphSONMode mode) {    final OGraphSONUtility graphson = element instanceof Edge ? new OGraphSONUtility(mode, null, null, propertyKeys)        : new OGraphSONUtility(mode, null, propertyKeys, null);    return graphson.objectNodeFromElement(element);  }
public void executeImport(ODocument cfg, OServer server) {    OETLJob job = new OETLJob(cfg, server, new OETLListener() {      @Override      public void onEnd(OETLJob etlJob) {        currentJob = null;      }    });    job.validate();    currentJob = job;    pool.execute(job);  }
public ODocument status() {    ODocument status = new ODocument();    Collection<ODocument> jobs = new ArrayList<ODocument>();    if (currentJob != null) {      jobs.add(currentJob.status());    }    status.field("jobs", jobs);    return status;  }
@Override  public void serializeInByteBufferObject(OIdentifiable object, ByteBuffer buffer, Object... hints) {    final ORID r = object.getIdentity();    buffer.putShort((short) r.getClusterId());    // Wrong implementation but needed for binary compatibility    byte[] stream = new byte[OLongSerializer.LONG_SIZE];    OLongSerializer.INSTANCE.serialize(r.getClusterPosition(), stream, 0);    buffer.put(stream);  }
@Override  public OIdentifiable deserializeFromByteBufferObject(ByteBuffer buffer) {    final int clusterId = buffer.getShort();    final byte[] stream = new byte[OLongSerializer.LONG_SIZE];    buffer.get(stream);    // Wrong implementation but needed for binary compatibility    final long clusterPosition = OLongSerializer.INSTANCE.deserialize(stream, 0);    return new ORecordId(clusterId, clusterPosition);  }
@Override  public OIdentifiable deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final int clusterId = walChanges.getShortValue(buffer, offset);    // Wrong implementation but needed for binary compatibility    final long clusterPosition = OLongSerializer.INSTANCE        .deserialize(walChanges.getBinaryValue(buffer, offset + OShortSerializer.SHORT_SIZE, OLongSerializer.LONG_SIZE), 0);    // final long clusterPosition = OLongSerializer.INSTANCE    // .deserializeFromDirectMemory(pointer, offset + OShortSerializer.SHORT_SIZE);    return new ORecordId(clusterId, clusterPosition);  }
@SuppressWarnings("unchecked")  public <T> Comparator<T> getComparator(Class<T> clazz) {    boolean useUnsafe = OGlobalConfiguration.MEMORY_USE_UNSAFE.getValueAsBoolean();    if (clazz.equals(byte[].class)) {      if (useUnsafe && unsafeWasDetected)        return (Comparator<T>) OUnsafeByteArrayComparator.INSTANCE;      return (Comparator<T>) OByteArrayComparator.INSTANCE;    }    return null;  }
public Map<String, Set<String>> getActiveClusterMap() {    if (distributedManager.isOffline() || !distributedManager.isNodeOnline(distributedManager.getLocalNodeName(), getName())        || OScenarioThreadLocal.INSTANCE.isRunModeDistributed()) {      return super.getActiveClusterMap();    }    Map<String, Set<String>> result = new HashMap<>();    ODistributedConfiguration cfg = getDistributedConfiguration();    for (String server : distributedManager.getActiveServers()) {      if (getClustersOnServer(cfg, server).contains("*")) {        //TODO check this!!!        result.put(server, getStorage().getClusterNames());      } else {        result.put(server, getClustersOnServer(cfg, server));      }    }    return result;  }
public Map<String, Set<String>> getActiveDataCenterMap() {    Map<String, Set<String>> result = new HashMap<>();    ODistributedConfiguration cfg = getDistributedConfiguration();    Set<String> servers = cfg.getRegisteredServers();    for (String server : servers) {      String dc = cfg.getDataCenterOfServer(server);      Set<String> dcConfig = result.get(dc);      if (dcConfig == null) {        dcConfig = new HashSet<>();        result.put(dc, dcConfig);      }      dcConfig.add(server);    }    return result;  }
public boolean commit2pc(ODistributedRequestId transactionId, boolean local) {    getStorageDistributed().resetLastValidBackup();    ODistributedDatabase localDistributedDatabase = getStorageDistributed().getLocalDistributedDatabase();    ONewDistributedTxContextImpl txContext = (ONewDistributedTxContextImpl) localDistributedDatabase.getTxContext(transactionId);    if (txContext != null) {      if (SUCCESS.equals(txContext.getStatus())) {        try {          txContext.commit(this);          localDistributedDatabase.popTxContext(transactionId);          OLiveQueryHook.notifyForTxChanges(this);          OLiveQueryHookV2.notifyForTxChanges(this);        } finally {          OLiveQueryHook.removePendingDatabaseOps(this);          OLiveQueryHookV2.removePendingDatabaseOps(this);        }        return true;      } else if (TIMEDOUT.equals(txContext.getStatus())) {        int nretry = getConfiguration().getValueAsInteger(DISTRIBUTED_CONCURRENT_TX_MAX_AUTORETRY);        int delay = getConfiguration().getValueAsInteger(DISTRIBUTED_CONCURRENT_TX_AUTORETRY_DELAY);        for (int i = 0; i < nretry; i++) {          try {            if (i > 0) {              try {                Thread.sleep(new Random().nextInt(delay));              } catch (InterruptedException e) {                OException.wrapException(new OInterruptedException(e.getMessage()), e);              }            }            internalBegin2pc(txContext, local);            txContext.setStatus(SUCCESS);            break;          } catch (ODistributedRecordLockedException | ODistributedKeyLockedException ex) {            // Just retry          } catch (Exception ex) {            OLogManager.instance()                .warn(ODatabaseDocumentDistributed.this, "Error beginning timed out transaction: %s ", ex, transactionId);            break;          }        }        if (!SUCCESS.equals(txContext.getStatus())) {          txContext.destroy();          localDistributedDatabase.popTxContext(transactionId);          Orient.instance().submit(() -> {            OLogManager.instance()                .warn(ODatabaseDocumentDistributed.this, "Reached limit of retry for commit tx:%s forcing database re-install",                    transactionId);            distributedManager.installDatabase(false, ODatabaseDocumentDistributed.this.getName(), true, true);          });          return true;        }        try {          txContext.commit(this);          localDistributedDatabase.popTxContext(transactionId);          OLiveQueryHook.notifyForTxChanges(this);          OLiveQueryHookV2.notifyForTxChanges(this);          return true;        } finally {          OLiveQueryHook.removePendingDatabaseOps(this);          OLiveQueryHookV2.removePendingDatabaseOps(this);        }      } else {        txContext.destroy();        localDistributedDatabase.popTxContext(transactionId);        Orient.instance().submit(() -> {          OLogManager.instance()              .warn(ODatabaseDocumentDistributed.this, "Reached limit of retry for commit tx:%s forcing database re-install",                  transactionId);          distributedManager.installDatabase(false, ODatabaseDocumentDistributed.this.getName(), true, true);        });        return true;      }    }    return false;  }
public String toCreateIndexDDL(final String indexName, final String indexType, String engine) {    return "create index `" + indexName + "` " + indexType + ' ' + "runtime " + serializer.getId();  }
protected static String separateAlgorithm(final String cipherTransform) {    String[] array = cipherTransform.split("/");    if (array.length > 1)      return array[0];    return null;  }
public static OSymmetricKey fromConfig(final OSymmetricKeyConfig keyConfig) {    if (keyConfig.usesKeyString()) {      return fromString(keyConfig.getKeyAlgorithm(), keyConfig.getKeyString());    } else if (keyConfig.usesKeyFile()) {      return fromFile(keyConfig.getKeyAlgorithm(), keyConfig.getKeyFile());    } else if (keyConfig.usesKeystore()) {      return fromKeystore(keyConfig.getKeystoreFile(), keyConfig.getKeystorePassword(), keyConfig.getKeystoreKeyAlias(),          keyConfig.getKeystoreKeyPassword());    } else {      throw new OSecurityException("OSymmetricKey(OSymmetricKeyConfig) Invalid configuration");    }  }
public static OSymmetricKey fromFile(final String algorithm, final String path) {    String base64Key = null;    try {      java.io.FileInputStream fis = null;      try {        fis = new java.io.FileInputStream(OSystemVariableResolver.resolveSystemVariables(path));        return fromStream(algorithm, fis);      } finally {        if (fis != null)          fis.close();      }    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.fromFile() Exception: " + ex.getMessage()), ex);    }  }
public static OSymmetricKey fromStream(final String algorithm, final InputStream is) {    String base64Key = null;    try {      base64Key = OIOUtils.readStreamAsString(is);    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.fromStream() Exception: " + ex.getMessage()), ex);    }    return new OSymmetricKey(algorithm, base64Key);  }
public static OSymmetricKey fromKeystore(final String path, final String password, final String keyAlias,      final String keyPassword) {    OSymmetricKey sk = null;    try {      KeyStore ks = KeyStore.getInstance("JCEKS"); // JCEKS is required to hold SecretKey entries.      java.io.FileInputStream fis = null;      try {        fis = new java.io.FileInputStream(OSystemVariableResolver.resolveSystemVariables(path));        return fromKeystore(fis, password, keyAlias, keyPassword);      } finally {        if (fis != null)          fis.close();      }    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.fromKeystore() Exception: " + ex.getMessage()), ex);    }  }
public static OSymmetricKey fromKeystore(final InputStream is, final String password, final String keyAlias,      final String keyPassword) {    OSymmetricKey sk = null;    try {      KeyStore ks = KeyStore.getInstance("JCEKS"); // JCEKS is required to hold SecretKey entries.      char[] ksPasswdChars = null;      if (password != null)        ksPasswdChars = password.toCharArray();      ks.load(is, ksPasswdChars); // ksPasswdChars may be null.      char[] ksKeyPasswdChars = null;      if (keyPassword != null)        ksKeyPasswdChars = keyPassword.toCharArray();      KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(ksKeyPasswdChars); // ksKeyPasswdChars may be null.      KeyStore.SecretKeyEntry skEntry = (KeyStore.SecretKeyEntry) ks.getEntry(keyAlias, protParam);      if (skEntry == null)        throw new OSecurityException("SecretKeyEntry is null for key alias: " + keyAlias);      SecretKey secretKey = skEntry.getSecretKey();      sk = new OSymmetricKey(secretKey);    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.fromKeystore() Exception: " + ex.getMessage()), ex);    }    return sk;  }
public String encrypt(final String value) {    try {      return encrypt(value.getBytes("UTF8"));    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.encrypt() Exception: " + ex.getMessage()), ex);    }  }
public String encrypt(final String transform, final byte[] bytes) {    String encodedJSON = null;    if (secretKey == null)      throw new OSecurityException("OSymmetricKey.encrypt() SecretKey is null");    if (transform == null)      throw new OSecurityException("OSymmetricKey.encrypt() Cannot determine cipher transformation");    try {      // Throws NoSuchAlgorithmException and NoSuchPaddingException.      Cipher cipher = Cipher.getInstance(transform);      // If the cipher transformation requires an initialization vector then init() will create a random one.      // (Use cipher.getIV() to retrieve the IV, if it exists.)      cipher.init(Cipher.ENCRYPT_MODE, secretKey);      // If the cipher does not use an IV, this will be null.      byte[] initVector = cipher.getIV();//      byte[] initVector = encCipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();      byte[] encrypted = cipher.doFinal(bytes);      encodedJSON = encodeJSON(encrypted, initVector);    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.encrypt() Exception: " + ex.getMessage()), ex);    }    return encodedJSON;  }
public String decryptAsString(final String encodedJSON) {    try {      byte[] decrypted = decrypt(encodedJSON);      return new String(decrypted, "UTF8");    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.decryptAsString() Exception: " + ex.getMessage()), ex);    }  }
public byte[] decrypt(final String encodedJSON) {    byte[] result = null;    if (encodedJSON == null)      throw new OSecurityException("OSymmetricKey.decrypt(String) encodedJSON is null");    try {      byte[] decoded = convertFromBase64(encodedJSON);      if (decoded == null)        throw new OSecurityException("OSymmetricKey.decrypt(String) encodedJSON could not be decoded");      String json = new String(decoded, "UTF8");      // Convert the JSON content to an ODocument to make parsing it easier.      final ODocument doc = new ODocument().fromJSON(json, "noMap");      // Set a default in case the JSON document does not contain an "algorithm" property.      String algorithm = secretKeyAlgorithm;      if (doc.containsField("algorithm"))        algorithm = doc.field("algorithm");      // Set a default in case the JSON document does not contain a "transform" property.      String transform = defaultCipherTransformation;      if (doc.containsField("transform"))        transform = doc.field("transform");      String payloadBase64 = doc.field("payload");      String ivBase64 = doc.field("iv");      byte[] payload = null;      byte[] iv = null;      if (payloadBase64 != null)        payload = convertFromBase64(payloadBase64);      if (ivBase64 != null)        iv = convertFromBase64(ivBase64);      // Throws NoSuchAlgorithmException and NoSuchPaddingException.      Cipher cipher = Cipher.getInstance(transform);      if (iv != null)        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));      else        cipher.init(Cipher.DECRYPT_MODE, secretKey);      result = cipher.doFinal(payload);    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.decrypt(String) Exception: " + ex.getMessage()), ex);    }    return result;  }
public void saveToStream(final OutputStream os) {    if (os == null)      throw new OSecurityException("OSymmetricKey.saveToStream() OutputStream is null");    try {      final OutputStreamWriter osw = new OutputStreamWriter(os);      try {        final BufferedWriter writer = new BufferedWriter(osw);        try {          writer.write(getBase64Key());        } finally {          writer.close();        }      } finally {        os.close();      }    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.saveToStream() Exception: " + ex.getMessage()), ex);    }  }
public void saveToKeystore(final OutputStream os, final String ksPasswd, final String keyAlias, final String keyPasswd) {    if (os == null)      throw new OSecurityException("OSymmetricKey.saveToKeystore() OutputStream is null");    if (ksPasswd == null)      throw new OSecurityException("OSymmetricKey.saveToKeystore() Keystore Password is required");    if (keyAlias == null)      throw new OSecurityException("OSymmetricKey.saveToKeystore() Key Alias is required");    if (keyPasswd == null)      throw new OSecurityException("OSymmetricKey.saveToKeystore() Key Password is required");    try {      KeyStore ks = KeyStore.getInstance("JCEKS");      char[] ksPasswdCA = ksPasswd.toCharArray();      char[] keyPasswdCA = keyPasswd.toCharArray();      // Create a new KeyStore by passing null.      ks.load(null, ksPasswdCA);      KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(keyPasswdCA);      KeyStore.SecretKeyEntry skEntry = new KeyStore.SecretKeyEntry(secretKey);      ks.setEntry(keyAlias, skEntry, protParam);      // Save the KeyStore      ks.store(os, ksPasswdCA);    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKey.saveToKeystore() Exception: " + ex.getMessage()), ex);    }  }
@Override  public void serializeInByteBufferObject(UUID object, ByteBuffer buffer, Object... hints) {    buffer.putLong(object.getMostSignificantBits());    buffer.putLong(object.getLeastSignificantBits());  }
@Override  public UUID deserializeFromByteBufferObject(ByteBuffer buffer) {    final long mostSignificantBits = buffer.getLong();    final long leastSignificantBits = buffer.getLong();    return new UUID(mostSignificantBits, leastSignificantBits);  }
@Override  public UUID deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final long mostSignificantBits = walChanges.getLongValue(buffer, offset);    final long leastSignificantBits = walChanges.getLongValue(buffer, offset + OLongSerializer.LONG_SIZE);    return new UUID(mostSignificantBits, leastSignificantBits);  }
public OCommandContext setChild(final OCommandContext iContext) {    if (iContext == null) {      if (child != null) {        // REMOVE IT        child.setParent(null);        child = null;      }    } else if (child != iContext) {      // ADD IT      child = iContext;      iContext.setParent(this);    }    return this;  }
public synchronized boolean addToUniqueResult(Object o) {    Object toAdd = o;    if (o instanceof ODocument && ((ODocument) o).getIdentity().isNew()) {      toAdd = new ODocumentEqualityWrapper((ODocument) o);    }    return this.uniqueResult.add(toAdd);  }
@Override  public void serializeInByteBufferObject(BigDecimal object, ByteBuffer buffer, Object... hints) {    buffer.putInt(object.scale());    OBinaryTypeSerializer.INSTANCE.serializeInByteBufferObject(object.unscaledValue().toByteArray(), buffer);  }
@Override  public BigDecimal deserializeFromByteBufferObject(ByteBuffer buffer) {    final int scale = buffer.getInt();    final byte[] unscaledValue = OBinaryTypeSerializer.INSTANCE.deserializeFromByteBufferObject(buffer);    return new BigDecimal(new BigInteger(unscaledValue), scale);  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer) {    buffer.position(buffer.position() + OIntegerSerializer.INT_SIZE);    return OIntegerSerializer.INT_SIZE + OBinaryTypeSerializer.INSTANCE.getObjectSizeInByteBuffer(buffer);  }
@Override  public BigDecimal deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final int scale = walChanges.getIntValue(buffer, offset);    offset += OIntegerSerializer.INT_SIZE;    final byte[] unscaledValue = OBinaryTypeSerializer.INSTANCE.deserializeFromByteBufferObject(buffer, walChanges, offset);    return new BigDecimal(new BigInteger(unscaledValue), scale);  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return OIntegerSerializer.INT_SIZE + OBinaryTypeSerializer.INSTANCE        .getObjectSizeInByteBuffer(buffer, walChanges, offset + OIntegerSerializer.INT_SIZE);  }
private Object getValueAsObjectOrMap(ODocument iRecord, String iFieldValue, OType iType, OType iLinkedType,      Map<String, Character> iFieldTypes, boolean iNoMap, String iOptions) {    final String[] fields = OStringParser.getWords(iFieldValue.substring(1, iFieldValue.length() - 1), ":,", true);    if (fields == null || fields.length == 0)      if (iNoMap) {        ODocument res = new ODocument();        ODocumentInternal.addOwner(res, iRecord);        return res;      } else        return new HashMap<String, Object>();    if (iNoMap || hasTypeField(fields)) {      return getValueAsRecord(iRecord, iFieldValue, iType, iOptions, fields);    } else {      return getValueAsMap(iRecord, iFieldValue, iLinkedType, iFieldTypes, false, iOptions, fields);    }  }
protected String authenticate(final String username, final String password, final String iDatabaseName) throws IOException {    ODatabaseDocument db = null;    String userRid = null;    try {      db = (ODatabaseDocument) server.openDatabase(iDatabaseName, username, password);      userRid = (db.getUser() == null ? "<server user>" : db.getUser().getDocument().getIdentity().toString());    } catch (OSecurityAccessException e) {      // WRONG USER/PASSWD    } catch (OLockException e) {      OLogManager.instance().error(this, "Cannot access to the database '" + iDatabaseName + "'", e);    } finally {      if (db != null) {        db.close();      }    }    return userRid;  }
@SuppressWarnings("unchecked")  public static Object getMapEntry(final Map<String, ?> iMap, final Object iKey) {    if (iMap == null || iKey == null)      return null;    if (iKey instanceof String) {      String iName = (String) iKey;      int pos = iName.indexOf('.');      if (pos > -1)        iName = iName.substring(0, pos);      final Object value = iMap.get(iName);      if (value == null)        return null;      if (pos > -1) {        final String restFieldName = iName.substring(pos + 1);        if (value instanceof ODocument)          return getFieldValue(value, restFieldName);        else if (value instanceof Map<?, ?>)          return getMapEntry((Map<String, ?>) value, restFieldName);      }      return value;    } else      return iMap.get(iKey);  }
@SuppressWarnings("unchecked")  public static boolean hasSameContentOf(final ODocument iCurrent, final ODatabaseDocumentInternal iMyDb, final ODocument iOther,      final ODatabaseDocumentInternal iOtherDb, RIDMapper ridMapper) {    return hasSameContentOf(iCurrent, iMyDb, iOther, iOtherDb, ridMapper, true);  }
@SuppressWarnings("unchecked")  public static boolean hasSameContentOf(final ODocument iCurrent, final ODatabaseDocumentInternal iMyDb, final ODocument iOther,      final ODatabaseDocumentInternal iOtherDb, RIDMapper ridMapper, final boolean iCheckAlsoIdentity) {    if (iOther == null)      return false;    if (iCheckAlsoIdentity && iCurrent.getIdentity().isValid() && !iCurrent.getIdentity().equals(iOther.getIdentity()))      return false;    if (iMyDb != null)      makeDbCall(iMyDb, new ODbRelatedCall<Object>() {        public Object call(ODatabaseDocumentInternal database) {          if (iCurrent.getInternalStatus() == STATUS.NOT_LOADED)            iCurrent.reload();          return null;        }      });    if (iOtherDb != null)      makeDbCall(iOtherDb, new ODbRelatedCall<Object>() {        public Object call(ODatabaseDocumentInternal database) {          if (iOther.getInternalStatus() == STATUS.NOT_LOADED)            iOther.reload();          return null;        }      });    if (iMyDb != null)      makeDbCall(iMyDb, new ODbRelatedCall<Object>() {        public Object call(ODatabaseDocumentInternal database) {          iCurrent.checkForFields();          return null;        }      });    else      iCurrent.checkForFields();    if (iOtherDb != null)      makeDbCall(iOtherDb, new ODbRelatedCall<Object>() {        public Object call(ODatabaseDocumentInternal database) {          iOther.checkForFields();          return null;        }      });    else      iOther.checkForFields();    if (iCurrent.fields() != iOther.fields())      return false;    // CHECK FIELD-BY-FIELD    Object myFieldValue;    Object otherFieldValue;    for (Entry<String, Object> f : iCurrent) {      myFieldValue = f.getValue();      otherFieldValue = iOther._fields.get(f.getKey()).value;      if (myFieldValue == otherFieldValue)        continue;      // CHECK FOR NULLS      if (myFieldValue == null) {        if (otherFieldValue != null)          return false;      } else if (otherFieldValue == null)        return false;      if (myFieldValue != null)        if (myFieldValue instanceof Set && otherFieldValue instanceof Set) {          if (!compareSets(iMyDb, (Set<?>) myFieldValue, iOtherDb, (Set<?>) otherFieldValue, ridMapper))            return false;        } else if (myFieldValue instanceof Collection && otherFieldValue instanceof Collection) {          if (!compareCollections(iMyDb, (Collection<?>) myFieldValue, iOtherDb, (Collection<?>) otherFieldValue, ridMapper))            return false;        } else if (myFieldValue instanceof ORidBag && otherFieldValue instanceof ORidBag) {          if (!compareBags(iMyDb, (ORidBag) myFieldValue, iOtherDb, (ORidBag) otherFieldValue, ridMapper))            return false;        } else if (myFieldValue instanceof Map && otherFieldValue instanceof Map) {          if (!compareMaps(iMyDb, (Map<Object, Object>) myFieldValue, iOtherDb, (Map<Object, Object>) otherFieldValue, ridMapper))            return false;        } else if (myFieldValue instanceof ODocument && otherFieldValue instanceof ODocument) {          if (!hasSameContentOf((ODocument) myFieldValue, iMyDb, (ODocument) otherFieldValue, iOtherDb, ridMapper))            return false;        } else {          if (!compareScalarValues(myFieldValue, iMyDb, otherFieldValue, iOtherDb, ridMapper))            return false;        }    }    return true;  }
public String getRemoteAddress() {    Socket socket = null;    if (getProtocol() != null) {      socket = getProtocol().getChannel().socket;    } else {      for (ONetworkProtocol protocol : this.protocols) {        socket = protocol.getChannel().socket;        if (socket != null)          break;      }    }    if (socket != null) {      final InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();      return remoteAddress.getAddress().getHostAddress() + ":" + remoteAddress.getPort();    }    return null;  }
protected ORecord getRecord() {    final ORecord record;    if (reusedRecord != null) {      // REUSE THE SAME RECORD AFTER HAVING RESETTED IT      record = reusedRecord;      record.reset();    } else      record = null;    return record;  }
protected ORecord readCurrentRecord(ORecord iRecord, final int iMovement) {    if (limit > -1 && browsedRecords >= limit)      // LIMIT REACHED      return null;    do {      final boolean moveResult;      switch (iMovement) {      case 1:        moveResult = nextPosition();        break;      case -1:        moveResult = prevPosition();        break;      case 0:        moveResult = checkCurrentPosition();        break;      default:        throw new IllegalStateException("Invalid movement value : " + iMovement);      }      if (!moveResult)        return null;      try {        if (iRecord != null) {          ORecordInternal.setIdentity(iRecord, new ORecordId(current.getClusterId(), current.getClusterPosition()));          iRecord = database.load(iRecord, fetchPlan, false);        } else          iRecord = database.load(current, fetchPlan, false);      } catch (ODatabaseException e) {        if (Thread.interrupted() || database.isClosed())          // THREAD INTERRUPTED: RETURN          throw e;        if (e.getCause() instanceof OSecurityException)          throw e;        brokenRIDs.add(current.copy());        OLogManager.instance().error(this, "Error on fetching record during browsing. The record has been skipped", e);      }      if (iRecord != null) {        browsedRecords++;        return iRecord;      }    } while (iMovement != 0);    return null;  }
public void importDelta(final OServer serverInstance, final String databaseName, final FileInputStream in, final String iNode)      throws IOException {    final String nodeName = serverInstance.getDistributedManager().getLocalNodeName();    final ODatabaseDocumentInternal db = serverInstance.openDatabase(databaseName);    try {      OScenarioThreadLocal.executeAsDistributed(new Callable<Object>() {        @Override        public Object call() throws Exception {          db.activateOnCurrentThread();          long totalRecords = 0;          long totalCreated = 0;          long totalUpdated = 0;          long totalDeleted = 0;          long totalHoles = 0;          long totalSkipped = 0;          ODistributedServerLog              .info(this, nodeName, iNode, DIRECTION.IN, "Started import of delta for database '" + db.getName() + "'");          long lastLap = System.currentTimeMillis();          // final GZIPInputStream gzipInput = new GZIPInputStream(in);          try {            final DataInputStream input = new DataInputStream(in);            try {              final long records = input.readLong();              for (long i = 0; i < records; ++i) {                final int clusterId = input.readInt();                final long clusterPos = input.readLong();                final boolean deleted = input.readBoolean();                final ORecordId rid = new ORecordId(clusterId, clusterPos);                totalRecords++;                final OPaginatedCluster cluster = (OPaginatedCluster) db.getStorage().getUnderlying()                    .getClusterById(rid.getClusterId());                final OPaginatedCluster.RECORD_STATUS recordStatus = cluster.getRecordStatus(rid.getClusterPosition());                ORecord newRecord = null;                if (deleted) {                  ODistributedServerLog.debug(this, nodeName, iNode, DIRECTION.IN, "DELTA <- deleting %s", rid);                  switch (recordStatus) {                  case REMOVED:                    // SKIP IT                    totalSkipped++;                    continue;                  case ALLOCATED:                  case PRESENT:                    // DELETE IT                    db.delete(rid);                    break;                  case NOT_EXISTENT:                    totalSkipped++;                    break;                  }                  totalDeleted++;                } else {                  final int recordVersion = input.readInt();                  final int recordType = input.readByte();                  final int recordSize = input.readInt();                  final byte[] recordContent = new byte[recordSize];                  input.read(recordContent);                  switch (recordStatus) {                  case REMOVED:                    // SKIP IT                    totalSkipped++;                    continue;                  case ALLOCATED:                  case PRESENT:                    // UPDATE IT                    newRecord = Orient.instance().getRecordFactoryManager()                        .newInstance((byte) recordType, rid.getClusterId(), null);                    ORecordInternal.fill(newRecord, rid, ORecordVersionHelper.setRollbackMode(recordVersion), recordContent, true);                    final ORecord loadedRecord = rid.getRecord();                    if (loadedRecord instanceof ODocument) {                      // APPLY CHANGES FIELD BY FIELD TO MARK DIRTY FIELDS FOR INDEXES/HOOKS                      ODocument loadedDocument = (ODocument) loadedRecord;                      loadedDocument.merge((ODocument) newRecord, false, false);                      ORecordInternal.setVersion(loadedRecord, ORecordVersionHelper.setRollbackMode(recordVersion));                      loadedDocument.setDirty();                      newRecord = loadedDocument;                    }                    // SAVE THE UPDATE RECORD                    newRecord.save();                    ODistributedServerLog                        .debug(this, nodeName, iNode, DIRECTION.IN, "DELTA <- updating rid=%s type=%d size=%d v=%d content=%s", rid,                            recordType, recordSize, recordVersion, newRecord);                    totalUpdated++;                    break;                  case NOT_EXISTENT:                    // CREATE AND DELETE RECORD IF NEEDED                    do {                      newRecord = Orient.instance().getRecordFactoryManager()                          .newInstance((byte) recordType, rid.getClusterId(), null);                      ORecordInternal.fill(newRecord, new ORecordId(rid.getClusterId(), -1), recordVersion, recordContent, true);                      try {                        newRecord.save();                      } catch (ORecordNotFoundException e) {                        ODistributedServerLog.info(this, nodeName, iNode, DIRECTION.IN,                            "DELTA <- error on saving record (not found) rid=%s type=%d size=%d v=%d content=%s", rid, recordType,                            recordSize, recordVersion, newRecord);                      } catch (ORecordDuplicatedException e) {                        ODistributedServerLog.info(this, nodeName, iNode, DIRECTION.IN,                            "DELTA <- error on saving record (duplicated %s) rid=%s type=%d size=%d v=%d content=%s", e.getRid(),                            rid, recordType, recordSize, recordVersion, newRecord);                        // throw OException.wrapException(                        // new ODistributedDatabaseDeltaSyncException("Error on delta sync: found duplicated record " + rid), e);                        final ORecord duplicatedRecord = db.load(e.getRid(), null, true);                        if (duplicatedRecord == null) {                          // RECORD REMOVED: THE INDEX IS DIRTY, FIX THE DIRTY INDEX                          final ODocument doc = (ODocument) newRecord;                          final OIndex<?> index = db.getMetadata().getIndexManager().getIndex(e.getIndexName());                          final List<String> fields = index.getDefinition().getFields();                          final List<Object> values = new ArrayList<Object>(fields.size());                          for (String f : fields) {                            values.add(doc.field(f));                          }                          final Object keyValue = index.getDefinition().createValue(values);                          index.remove(keyValue, e.getRid());                          // RESAVE THE RECORD                          newRecord.save();                        } else                          break;                      }                      if (newRecord.getIdentity().getClusterPosition() < clusterPos) {                        // DELETE THE RECORD TO CREATE A HOLE                        ODistributedServerLog                            .debug(this, nodeName, iNode, DIRECTION.IN, "DELTA <- creating hole rid=%s", newRecord.getIdentity());                        newRecord.delete();                        totalHoles++;                      }                    } while (newRecord.getIdentity().getClusterPosition() < clusterPos);                    ODistributedServerLog                        .debug(this, nodeName, iNode, DIRECTION.IN, "DELTA <- creating rid=%s type=%d size=%d v=%d content=%s", rid,                            recordType, recordSize, recordVersion, newRecord);                    totalCreated++;                    break;                  }                  if (newRecord.getIdentity().isPersistent() && !newRecord.getIdentity().equals(rid))                    throw new ODistributedDatabaseDeltaSyncException(                        "Error on synchronization of records, rids are different: saved " + newRecord.getIdentity()                            + ", but it should be " + rid);                }                final long now = System.currentTimeMillis();                if (now - lastLap > 2000) {                  // DUMP STATS EVERY SECOND                  ODistributedServerLog.info(this, nodeName, iNode, DIRECTION.IN,                      "- %,d total entries: %,d created, %,d updated, %,d deleted, %,d holes, %,d skipped...", totalRecords,                      totalCreated, totalUpdated, totalDeleted, totalHoles, totalSkipped);                  lastLap = now;                }              }              db.getMetadata().reload();            } finally {              input.close();            }          } catch (Exception e) {            ODistributedServerLog                .error(this, nodeName, iNode, DIRECTION.IN, "Error on installing database delta '%s' on local server", e,                    db.getName());            throw OException.wrapException(                new ODistributedException("Error on installing database delta '" + db.getName() + "' on local server"), e);          } finally {            // gzipInput.close();          }          ODistributedServerLog.info(this, nodeName, iNode, DIRECTION.IN,              "Installed database delta for '%s'. %d total entries: %d created, %d updated, %d deleted, %d holes, %,d skipped",              db.getName(), totalRecords, totalCreated, totalUpdated, totalDeleted, totalHoles, totalSkipped);          return null;        }      });      db.activateOnCurrentThread();    } catch (Exception e) {      // FORCE FULL DATABASE SYNC      ODistributedServerLog.error(this, nodeName, iNode, DIRECTION.IN,          "Error while applying changes of database delta sync on '%s': forcing full database sync...", e, db.getName());      throw OException.wrapException(new ODistributedDatabaseDeltaSyncException(          "Error while applying changes of database delta sync on '" + db.getName() + "': forcing full database sync..."), e);    }  }
public double gcdist(double lata, double longa, double latb, double longb) {        double midlat, psi, dist;        midlat = 0.5 * (lata + latb);        psi = 0.0174532925                * Math.sqrt(Math.pow(lata - latb, 2)                + Math.pow((longa - longb)                * Math.cos(0.0174532925 * midlat), 2));        dist = 6372.640112 * psi;        return dist;    }
protected double getSimpleHeuristicCost(double x, double g, double dFactor) {        double dx = Math.abs(x - g);        return dFactor * (dx);    }
protected double getManhatanHeuristicCost(double x, double y, double gx, double gy, double dFactor) {        double dx = Math.abs(x - gx);        double dy = Math.abs(y - gy);        return dFactor * (dx + dy);    }
protected double getDiagonalHeuristicCost(double x, double y, double gx, double gy, double dFactor) {        double dx = Math.abs(x - gx);        double dy = Math.abs(y - gy);        double h_diagonal = Math.min(dx, dy);        double h_straight = dx + dy;        return (dFactor * 2) * h_diagonal + dFactor * (h_straight - 2 * h_diagonal);    }
protected double getEuclideanHeuristicCost(double x, double y, double gx, double gy, double dFactor) {        double dx = Math.abs(x - gx);        double dy = Math.abs(y - gy);        return (dFactor * Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)));    }
protected double getTieBreakingHeuristicCost(double x, double y, double sx, double sy, double gx, double gy, double heuristic) {        double dx1 = x - gx;        double dy1 = y - gy;        double dx2 = sx - gx;        double dy2 = sy - gy;        double cross = Math.abs(dx1 * dy2 - dx2 * dy1);        heuristic += (cross * 0.0001);        return heuristic;    }
public OrientGraph getTx() {    final OrientGraph g;    if (pool == null) {      g = (OrientGraph) getTxGraphImplFactory().getGraph(getDatabase(), user, password, settings);    } else {      // USE THE POOL      g = (OrientGraph) getTxGraphImplFactory().getGraph(pool, settings);    }    initGraph(g);    return g;  }
public OrientGraphNoTx getNoTx() {    final OrientGraphNoTx g;    if (pool == null) {      g = (OrientGraphNoTx) getNoTxGraphImplFactory().getGraph(getDatabase(), user, password, settings);    } else {      // USE THE POOL      g = (OrientGraphNoTx) getNoTxGraphImplFactory().getGraph(pool, settings);    }    initGraph(g);    return g;  }
public ODatabaseDocumentTx getDatabase(final boolean iCreate, final boolean iOpen) {    if (pool != null)      return pool.acquire();    final ODatabaseDocument db = new ODatabaseDocumentTx(url);    if (properties != null) {       properties.entrySet().forEach(e -> db.setProperty(e.getKey(), e.getValue()));    }    if (!db.getURL().startsWith("remote:") && !db.exists()) {      if (iCreate)        db.create();      else if (iOpen)        throw new ODatabaseException("Database '" + url + "' not found");    } else if (iOpen)      db.open(user, password);    return (ODatabaseDocumentTx) db;  }
public boolean exists() {    final ODatabaseDocument db = getDatabase(false, false);    try {      return db.exists();    } finally {      db.close();    }  }
public OrientGraphFactory setupPool(final int iMin, final int iMax) {    if (pool != null) {      pool.close();    }    pool = new OPartitionedDatabasePool(url, user, password, 8, iMax).setAutoCreate(true);    properties.entrySet().forEach(p -> pool.setProperty(p.getKey(), p.getValue()));    return this;  }
public Object getProperty(final String iName) {    return properties.get(iName.toLowerCase(Locale.ENGLISH));  }
@SuppressWarnings("deprecation")  @Override  public void stopTransaction(final Conclusion conclusion) {    makeActive();    if (getDatabase().isClosed() || getDatabase().getTransaction() instanceof OTransactionNoTx        || getDatabase().getTransaction().getStatus() != TXSTATUS.BEGUN)      return;    if (Conclusion.SUCCESS == conclusion)      commit();    else      rollback();  }
final public OStatement parse() throws ParseException { /*@bgen(jjtree) parse */ Oparse jjtn000 = new Oparse(JJTPARSE); boolean jjtc000 = true; jjtree.openNodeScope(jjtn000); jjtn000.jjtSetFirstToken(getToken(1));OStatement result;    try {      result = Statement();      jj_consume_token(0);    jjtree.closeNodeScope(jjtn000, true);    jjtc000 = false;    jjtn000.jjtSetLastToken(getToken(0));    {if (true) return result;}    } catch (Throwable jjte000) {    if (jjtc000) {      jjtree.clearNodeScope(jjtn000);      jjtc000 = false;    } else {      jjtree.popNode();    }    if (jjte000 instanceof RuntimeException) {      {if (true) throw (RuntimeException)jjte000;}    }    if (jjte000 instanceof ParseException) {      {if (true) throw (ParseException)jjte000;}    }    {if (true) throw (Error)jjte000;}    } finally {    if (jjtc000) {      jjtree.closeNodeScope(jjtn000, true);      jjtn000.jjtSetLastToken(getToken(0));    }    }    throw new Error("Missing return statement in function");  }
final public Token getNextToken() {    if (token.next != null) token = token.next;    else token = token.next = token_source.getNextToken();    jj_ntk = -1;    jj_gen++;    return token;  }
final public Token getToken(int index) {    Token t = token;    for (int i = 0; i < index; i++) {      if (t.next != null) t = t.next;      else t = t.next = token_source.getNextToken();    }    return t;  }
public ParseException generateParseException() {    jj_expentries.clear();    boolean[] la1tokens = new boolean[279];    if (jj_kind >= 0) {      la1tokens[jj_kind] = true;      jj_kind = -1;    }    for (int i = 0; i < 424; i++) {      if (jj_la1[i] == jj_gen) {        for (int j = 0; j < 32; j++) {          if ((jj_la1_0[i] & (1<<j)) != 0) {            la1tokens[j] = true;          }          if ((jj_la1_1[i] & (1<<j)) != 0) {            la1tokens[32+j] = true;          }          if ((jj_la1_2[i] & (1<<j)) != 0) {            la1tokens[64+j] = true;          }          if ((jj_la1_3[i] & (1<<j)) != 0) {            la1tokens[96+j] = true;          }          if ((jj_la1_4[i] & (1<<j)) != 0) {            la1tokens[128+j] = true;          }          if ((jj_la1_5[i] & (1<<j)) != 0) {            la1tokens[160+j] = true;          }          if ((jj_la1_6[i] & (1<<j)) != 0) {            la1tokens[192+j] = true;          }          if ((jj_la1_7[i] & (1<<j)) != 0) {            la1tokens[224+j] = true;          }          if ((jj_la1_8[i] & (1<<j)) != 0) {            la1tokens[256+j] = true;          }        }      }    }    for (int i = 0; i < 279; i++) {      if (la1tokens[i]) {        jj_expentry = new int[1];        jj_expentry[0] = i;        jj_expentries.add(jj_expentry);      }    }    jj_endpos = 0;    jj_rescan_token();    jj_add_error_token(0, 0);    int[][] exptokseq = new int[jj_expentries.size()][];    for (int i = 0; i < jj_expentries.size(); i++) {      exptokseq[i] = jj_expentries.get(i);    }    return new ParseException(token, exptokseq, tokenImage);  }
public static String getConnectionFieldName(final Direction iDirection, final String iClassName,      final boolean useVertexFieldsForEdgeLabels) {    if (iDirection == null || iDirection == Direction.BOTH)      throw new IllegalArgumentException("Direction not valid");    if (useVertexFieldsForEdgeLabels) {      // PREFIX "out_" or "in_" TO THE FIELD NAME      final String prefix = iDirection == Direction.OUT ? CONNECTION_OUT_PREFIX : CONNECTION_IN_PREFIX;      if (iClassName == null || iClassName.isEmpty() || iClassName.equals(OrientEdgeType.CLASS_NAME))        return prefix;      return prefix + iClassName;    } else      // "out" or "in"      return iDirection == Direction.OUT ? OrientBaseGraph.CONNECTION_OUT : OrientBaseGraph.CONNECTION_IN;  }
public static String getInverseConnectionFieldName(final String iFieldName, final boolean useVertexFieldsForEdgeLabels) {    if (useVertexFieldsForEdgeLabels) {      if (iFieldName.startsWith(CONNECTION_OUT_PREFIX)) {        if (iFieldName.length() == CONNECTION_OUT_PREFIX.length())          // "OUT" CASE          return CONNECTION_IN_PREFIX;        return CONNECTION_IN_PREFIX + iFieldName.substring(CONNECTION_OUT_PREFIX.length());      } else if (iFieldName.startsWith(CONNECTION_IN_PREFIX)) {        if (iFieldName.length() == CONNECTION_IN_PREFIX.length())          // "IN" CASE          return CONNECTION_OUT_PREFIX;        return CONNECTION_OUT_PREFIX + iFieldName.substring(CONNECTION_IN_PREFIX.length());      } else        throw new IllegalArgumentException("Cannot find reverse connection name for field " + iFieldName);    }    if (iFieldName.equals(OrientBaseGraph.CONNECTION_OUT))      return OrientBaseGraph.CONNECTION_IN;    else if (iFieldName.equals(OrientBaseGraph.CONNECTION_IN))      return OrientBaseGraph.CONNECTION_OUT;    throw new IllegalArgumentException("Cannot find reverse connection name for field " + iFieldName);  }
public static void replaceLinks(final ODocument iVertex, final String iFieldName, final OIdentifiable iVertexToRemove,      final OIdentifiable iNewVertex) {    if (iVertex == null)      return;    final Object fieldValue = iVertexToRemove != null ? iVertex.field(iFieldName) : iVertex.removeField(iFieldName);    if (fieldValue == null)      return;    if (fieldValue instanceof OIdentifiable) {      // SINGLE RECORD      if (iVertexToRemove != null) {        if (!fieldValue.equals(iVertexToRemove)) {          return;        }        iVertex.field(iFieldName, iNewVertex);      }    } else if (fieldValue instanceof ORidBag) {      // COLLECTION OF RECORDS: REMOVE THE ENTRY      final ORidBag bag = (ORidBag) fieldValue;      boolean found = false;      final Iterator<OIdentifiable> it = bag.rawIterator();      while (it.hasNext()) {        if (it.next().equals(iVertexToRemove)) {          // REMOVE THE OLD ENTRY          found = true;          it.remove();        }      }      if (found)        // ADD THE NEW ONE        bag.add(iNewVertex);    } else if (fieldValue instanceof Collection) {      final Collection col = (Collection) fieldValue;      if (col.remove(iVertexToRemove))        col.add(iNewVertex);    }    iVertex.save();  }
protected static OrientEdge getEdge(final OrientBaseGraph graph, final ODocument doc, String fieldName,      final OPair<Direction, String> connection, final Object fieldValue, final OIdentifiable iTargetVertex,      final String[] iLabels) {    final OrientEdge toAdd;    final ODocument fieldRecord = ((OIdentifiable) fieldValue).getRecord();    if (fieldRecord == null)      return null;    OClass klass = ODocumentInternal.getImmutableSchemaClass(fieldRecord);    if (klass == null && ODatabaseRecordThreadLocal.instance().getIfDefined() != null) {      ODatabaseRecordThreadLocal.instance().getIfDefined().getMetadata().reload();      klass = fieldRecord.getSchemaClass();    }    if (klass.isVertexType()) {      if (iTargetVertex != null && !iTargetVertex.equals(fieldValue))        return null;      // DIRECT VERTEX, CREATE A DUMMY EDGE BETWEEN VERTICES      if (connection.getKey() == Direction.OUT)        toAdd = graph.getEdgeInstance(doc, fieldRecord, connection.getValue());      else        toAdd = graph.getEdgeInstance(fieldRecord, doc, connection.getValue());    } else if (klass.isEdgeType()) {      // EDGE      if (iTargetVertex != null) {        Object targetVertex = OrientEdge.getConnection(fieldRecord, connection.getKey().opposite());        if (!iTargetVertex.equals(targetVertex))          return null;      }      toAdd = graph.getEdge(fieldRecord);    } else      throw new IllegalStateException("Invalid content found in " + fieldName + " field: " + fieldRecord);    return toAdd;  }
public Object execute(final OCommandPredicate iPredicate) {    final Object result = iPredicate.evaluate(rawElement.getRecord(), null, null);    if (result instanceof OAutoConvertToRecord)      ((OAutoConvertToRecord) result).setAutoConvertToRecord(true);    return result;  }
@Override  public Set<String> getPropertyKeys() {    final OrientBaseGraph graph = setCurrentGraphInThreadLocal();    final ODocument doc = getRecord();    final Set<String> result = new HashSet<String>();    for (String field : doc.fieldNames())      if (graph != null && settings.isUseVertexFieldsForEdgeLabels()) {        if (!field.startsWith(CONNECTION_OUT_PREFIX) && !field.startsWith(CONNECTION_IN_PREFIX))          result.add(field);      } else if (!field.equals(OrientBaseGraph.CONNECTION_OUT) && !field.equals(OrientBaseGraph.CONNECTION_IN))        result.add(field);    return result;  }
@Override  public Iterable<Vertex> getVertices(final Direction iDirection, final String... iLabels) {    setCurrentGraphInThreadLocal();    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);    OrientBaseGraph.encodeClassNames(iLabels);    final ODocument doc = getRecord();    final OMultiCollectionIterator<Vertex> iterable = new OMultiCollectionIterator<Vertex>();    for (OTriple<String, Direction, String> connectionField : getConnectionFields(iDirection, iLabels)) {      String fieldName = connectionField.getKey();      OPair<Direction, String> connection = connectionField.getValue();      final Object fieldValue = doc.rawField(fieldName);      if (fieldValue != null)        if (fieldValue instanceof OIdentifiable) {          addSingleVertex(doc, iterable, fieldName, connection, fieldValue, iLabels);        } else if (fieldValue instanceof Collection<?>) {          Collection<?> coll = (Collection<?>) fieldValue;          if (coll.size() == 1) {            // SINGLE ITEM: AVOID CALLING ITERATOR            if (coll instanceof ORecordLazyMultiValue)              addSingleVertex(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(), iLabels);            else if (coll instanceof List<?>)              addSingleVertex(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), iLabels);            else              addSingleVertex(doc, iterable, fieldName, connection, coll.iterator().next(), iLabels);          } else {            // CREATE LAZY Iterable AGAINST COLLECTION FIELD            if (coll instanceof ORecordLazyMultiValue)              iterable.add(new OrientVertexIterator(this, coll, ((ORecordLazyMultiValue) coll).rawIterator(), connection, iLabels,                  coll.size()));            else              iterable.add(new OrientVertexIterator(this, coll, coll.iterator(), connection, iLabels, -1));          }        } else if (fieldValue instanceof ORidBag) {          iterable.add(new OrientVertexIterator(this, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection, iLabels, -1));        }    }    return iterable;  }
@Override  public void remove() {    checkClass();    final OrientBaseGraph graph = checkIfAttached();    graph.setCurrentGraphInThreadLocal();    graph.autoStartTransaction();    final ODocument doc = getRecord();    if (doc == null)      throw ExceptionFactory.vertexWithIdDoesNotExist(this.getId());    Map<String, List<ODocument>> treeRidbagEdgesToRemove = new HashMap<String, List<ODocument>>();    if (!graph.getRawGraph().getTransaction().isActive()) {      for (String fieldName : doc.fieldNames()) {        final OPair<Direction, String> connection = getConnection(Direction.BOTH, fieldName);        if (connection == null)          // SKIP THIS FIELD          continue;        Object fv = doc.field(fieldName);        if (fv instanceof ORidBag && !((ORidBag) fv).isEmbedded()) {          List<ODocument> docs = new ArrayList<ODocument>();          for (OIdentifiable id : (ORidBag) fv)            docs.add(OrientBaseGraph.getDocument(id, true));          treeRidbagEdgesToRemove.put(fieldName, docs);        }      }    }    // REMOVE THE VERTEX RECORD FIRST TO CATCH CME BEFORE EDGES ARE REMOVED    super.removeRecord();    // REMOVE THE VERTEX FROM MANUAL INDEXES    final Iterator<Index<? extends Element>> it = graph.getIndices().iterator();    if (it.hasNext()) {      final Set<Edge> allEdges = new HashSet<Edge>();      for (Edge e : getEdges(Direction.BOTH))        allEdges.add(e);      while (it.hasNext()) {        final Index<? extends Element> index = it.next();        if (Vertex.class.isAssignableFrom(index.getIndexClass())) {          OrientIndex<OrientVertex> idx = (OrientIndex<OrientVertex>) index;          idx.removeElement(this);        }        if (Edge.class.isAssignableFrom(index.getIndexClass())) {          OrientIndex<OrientEdge> idx = (OrientIndex<OrientEdge>) index;          for (Edge e : allEdges)            idx.removeElement((OrientEdge) e);        }      }    }    for (Map.Entry<String, List<ODocument>> entry : treeRidbagEdgesToRemove.entrySet()) {      doc.removeField(entry.getKey());      Iterator<ODocument> iter = entry.getValue().iterator();      while (iter.hasNext()) {        ODocument docEdge = iter.next();        OrientBaseGraph.deleteEdgeIfAny(docEdge, false);      }    }    graph.removeEdgesInternal(this, doc, null, true, settings.isUseVertexFieldsForEdgeLabels(), settings.isAutoScaleEdgeType());  }
public ORID moveTo(final String iClassName, final String iClusterName) {    final OrientBaseGraph graph = getGraph();    if (checkDeletedInTx())      graph.throwRecordNotFoundException(getIdentity(), "The vertex " + getIdentity() + " has been deleted");    final ORID oldIdentity = getIdentity().copy();    final ORecord oldRecord = oldIdentity.getRecord();    if (oldRecord == null)      graph.throwRecordNotFoundException(getIdentity(), "The vertex " + getIdentity() + " has been deleted");    final ODocument doc = ((ODocument) rawElement.getRecord()).copy();    final Iterable<Edge> outEdges = getEdges(Direction.OUT);    final Iterable<Edge> inEdges = getEdges(Direction.IN);    // DELETE THE OLD RECORD FIRST TO AVOID ISSUES WITH UNIQUE CONSTRAINTS    copyRidBags(oldRecord, doc);    removeEdgeLinks(oldRecord);    oldRecord.delete();    if (iClassName != null)      // OVERWRITE CLASS      doc.setClassName(iClassName);    // SAVE THE NEW VERTEX    doc.setDirty();    // RESET IDENTITY    ORecordInternal.setIdentity(doc, new ORecordId());    if (iClusterName != null)      doc.save(iClusterName);    else      doc.save();    final ORID newIdentity = doc.getIdentity();    // CONVERT OUT EDGES    for (Edge e : outEdges) {      final OrientEdge oe = (OrientEdge) e;      if (oe.isLightweight()) {        // REPLACE ALL REFS IN inVertex        final OrientVertex inV = oe.getVertex(Direction.IN);        final String inFieldName = OrientVertex            .getConnectionFieldName(Direction.IN, oe.getLabel(), graph.isUseVertexFieldsForEdgeLabels());        replaceLinks(inV.getRecord(), inFieldName, oldIdentity, newIdentity);      } else {        // REPLACE WITH NEW VERTEX        oe.vOut = newIdentity;        oe.getRecord().field(OrientBaseGraph.CONNECTION_OUT, newIdentity);        oe.save();      }    }    for (Edge e : inEdges) {      final OrientEdge oe = (OrientEdge) e;      if (oe.isLightweight()) {        // REPLACE ALL REFS IN outVertex        final OrientVertex outV = oe.getVertex(Direction.OUT);        final String outFieldName = OrientVertex            .getConnectionFieldName(Direction.OUT, oe.getLabel(), graph.isUseVertexFieldsForEdgeLabels());        replaceLinks(outV.getRecord(), outFieldName, oldIdentity, newIdentity);      } else {        // REPLACE WITH NEW VERTEX        oe.vIn = newIdentity;        oe.getRecord().field(OrientBaseGraph.CONNECTION_IN, newIdentity);        oe.save();      }    }    // FINAL SAVE    doc.save();    return newIdentity;  }
@Override  public Edge addEdge(final String label, Vertex inVertex) {    if (inVertex instanceof PartitionVertex)      // WRAPPED: GET THE BASE VERTEX      inVertex = ((PartitionVertex) inVertex).getBaseVertex();    return addEdge(label, (OrientVertex) inVertex, null, null, (Object[]) null);  }
public OrientEdge addEdge(final String label, final OrientVertex inVertex, final String iClassName) {    return addEdge(label, inVertex, iClassName, null, (Object[]) null);  }
public OrientEdge addEdge(String label, final OrientVertex inVertex, final String iClassName, final String iClusterName,      final Object... fields) {    if (inVertex == null)      throw new IllegalArgumentException("destination vertex is null");    final OrientBaseGraph graph = getGraph();    if (graph != null)      return graph.addEdgeInternal(this, label, inVertex, iClassName, iClusterName, fields);    // IN MEMORY CHANGES ONLY: USE NOTX CLASS    return OrientGraphNoTx.addEdgeInternal(null, this, label, inVertex, iClassName, iClusterName, fields);  }
public long countEdges(final Direction iDirection, final String... iLabels) {    checkIfAttached();    long counter = 0;    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);    OrientBaseGraph.encodeClassNames(iLabels);    if (settings.isUseVertexFieldsForEdgeLabels() || iLabels == null || iLabels.length == 0) {      // VERY FAST      final ODocument doc = getRecord();      for (String fieldName : doc.fieldNames()) {        final OPair<Direction, String> connection = getConnection(iDirection, fieldName, iLabels);        if (connection == null)          // SKIP THIS FIELD          continue;        final Object fieldValue = doc.field(fieldName);        if (fieldValue != null)          if (fieldValue instanceof Collection<?>)            counter += ((Collection<?>) fieldValue).size();          else if (fieldValue instanceof Map<?, ?>)            counter += ((Map<?, ?>) fieldValue).size();          else if (fieldValue instanceof ORidBag) {            counter += ((ORidBag) fieldValue).size();          } else {            counter++;          }      }    } else {      // SLOWER: BROWSE & FILTER      for (Edge e : getEdges(iDirection, iLabels))        if (e != null)          counter++;    }    return counter;  }
@Override  public Iterable<Edge> getEdges(final Direction iDirection, final String... iLabels) {    return getEdges(null, iDirection, iLabels);  }
public Iterable<Edge> getEdges(final OrientVertex iDestination, final Direction iDirection, final String... iLabels) {    setCurrentGraphInThreadLocal();    final ODocument doc = getRecord();    OrientBaseGraph.getEdgeClassNames(getGraph(), iLabels);    OrientBaseGraph.encodeClassNames(iLabels);    final OMultiCollectionIterator<Edge> iterable = new OMultiCollectionIterator<Edge>().setEmbedded(true);    for (OTriple<String, Direction, String> connectionField : getConnectionFields(iDirection, iLabels)) {      String fieldName = connectionField.getKey();      OPair<Direction, String> connection = connectionField.getValue();      final Object fieldValue = doc.rawField(fieldName);      if (fieldValue != null) {        final OIdentifiable destinationVId = iDestination != null ? (OIdentifiable) iDestination.getId() : null;        if (fieldValue instanceof OIdentifiable) {          addSingleEdge(doc, iterable, fieldName, connection, fieldValue, destinationVId, iLabels);        } else if (fieldValue instanceof Collection<?>) {          Collection<?> coll = (Collection<?>) fieldValue;          if (coll.size() == 1) {            // SINGLE ITEM: AVOID CALLING ITERATOR            if (coll instanceof ORecordLazyMultiValue)              addSingleEdge(doc, iterable, fieldName, connection, ((ORecordLazyMultiValue) coll).rawIterator().next(),                  destinationVId, iLabels);            else if (coll instanceof List<?>)              addSingleEdge(doc, iterable, fieldName, connection, ((List<?>) coll).get(0), destinationVId, iLabels);            else              addSingleEdge(doc, iterable, fieldName, connection, coll.iterator().next(), destinationVId, iLabels);          } else {            // CREATE LAZY Iterable AGAINST COLLECTION FIELD            if (coll instanceof ORecordLazyMultiValue) {              iterable.add(                  new OrientEdgeIterator(this, iDestination, coll, ((ORecordLazyMultiValue) coll).rawIterator(), connection,                      iLabels, coll.size()));            } else              iterable.add(new OrientEdgeIterator(this, iDestination, coll, coll.iterator(), connection, iLabels, -1));          }        } else if (fieldValue instanceof ORidBag) {          iterable.add(              new OrientEdgeIterator(this, iDestination, fieldValue, ((ORidBag) fieldValue).rawIterator(), connection, iLabels,                  ((ORidBag) fieldValue).size()));        }      }    }    return iterable;  }
@Override  public String getLabel() {    setCurrentGraphInThreadLocal();    if (settings.isUseClassForVertexLabel()) {      final String clsName = getRecord().getClassName();      if (!OrientVertexType.CLASS_NAME.equals(clsName))        // RETURN THE CLASS NAME        return clsName;    }    return getRecord().field(OrientElement.LABEL_FIELD_NAME);  }
@Override  public OrientVertexType getType() {    final OrientBaseGraph graph = getGraph();    return new OrientVertexType(graph, getRecord().getSchemaClass());  }
public String getConnectionClass(final Direction iDirection, final String iFieldName) {    if (iDirection == Direction.OUT) {      if (iFieldName.length() > CONNECTION_OUT_PREFIX.length())        return iFieldName.substring(CONNECTION_OUT_PREFIX.length());    } else if (iDirection == Direction.IN) {      if (iFieldName.length() > CONNECTION_IN_PREFIX.length())        return iFieldName.substring(CONNECTION_IN_PREFIX.length());    }    return OrientEdgeType.CLASS_NAME;  }
protected OPair<Direction, String> getConnection(final Direction iDirection, final String iFieldName, String... iClassNames) {    if (iClassNames != null && iClassNames.length == 1 && iClassNames[0].equalsIgnoreCase("E"))      // DEFAULT CLASS, TREAT IT AS NO CLASS/LABEL      iClassNames = null;    final OrientBaseGraph graph = getGraph();    if (iDirection == Direction.OUT || iDirection == Direction.BOTH) {      if (settings.isUseVertexFieldsForEdgeLabels()) {        // FIELDS THAT STARTS WITH "out_"        if (iFieldName.startsWith(CONNECTION_OUT_PREFIX)) {          String connClass = getConnectionClass(Direction.OUT, iFieldName);          if (iClassNames == null || iClassNames.length == 0)            return new OPair<Direction, String>(Direction.OUT, connClass);          // CHECK AGAINST ALL THE CLASS NAMES          OrientEdgeType edgeType = graph.getEdgeType(connClass);          if (edgeType != null) {            for (String clsName : iClassNames) {              if (edgeType.isSubClassOf(clsName))                return new OPair<Direction, String>(Direction.OUT, connClass);            }          }        }      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_OUT))        // CHECK FOR "out"        return new OPair<Direction, String>(Direction.OUT, null);    }    if (iDirection == Direction.IN || iDirection == Direction.BOTH) {      if (settings.isUseVertexFieldsForEdgeLabels()) {        // FIELDS THAT STARTS WITH "in_"        if (iFieldName.startsWith(CONNECTION_IN_PREFIX)) {          String connClass = getConnectionClass(Direction.IN, iFieldName);          if (iClassNames == null || iClassNames.length == 0)            return new OPair<Direction, String>(Direction.IN, connClass);          // CHECK AGAINST ALL THE CLASS NAMES          OrientEdgeType edgeType = graph.getEdgeType(connClass);          if (edgeType != null) {            for (String clsName : iClassNames) {              if (edgeType.isSubClassOf(clsName))                return new OPair<Direction, String>(Direction.IN, connClass);            }          }        }      } else if (iFieldName.equals(OrientBaseGraph.CONNECTION_IN))        // CHECK FOR "in"        return new OPair<Direction, String>(Direction.IN, null);    }    // NOT FOUND    return null;  }
private List<OTriple<String, Direction, String>> getConnectionFields(final Direction iDirection, String... iClassNames) {    final ODocument doc = getRecord();    List<OTriple<String, Direction, String>> result = new ArrayList<>();    if (settings.isUseVertexFieldsForEdgeLabels()) {      if (iClassNames == null || iClassNames.length == 0 || (iClassNames.length == 1 && iClassNames[0].equalsIgnoreCase("E"))) {        for (String fieldName : doc.fieldNames()) {          final OPair<Direction, String> connection = getConnection(iDirection, fieldName, iClassNames);          if (connection != null)            result.add(new OTriple<String, Direction, String>(fieldName, connection.getKey(), connection.getValue()));        }      } else {        OSchema schema = getGraph().getRawGraph().getMetadata().getSchema();        Set<String> allClassNames = new HashSet<String>();        for (String className : iClassNames) {          allClassNames.add(className);          OClass clazz = schema.getClass(className);          if (clazz != null) {            Collection<OClass> subClasses = clazz.getAllSubclasses();            for (OClass subClass : subClasses) {              allClassNames.add(subClass.getName());            }          }        }        for (String className : allClassNames) {          switch (iDirection) {          case OUT:            result.add(new OTriple<String, Direction, String>(CONNECTION_OUT_PREFIX + className, Direction.OUT, className));            break;          case IN:            result.add(new OTriple<String, Direction, String>(CONNECTION_IN_PREFIX + className, Direction.IN, className));            break;          case BOTH:            result.add(new OTriple<String, Direction, String>(CONNECTION_OUT_PREFIX + className, Direction.OUT, className));            result.add(new OTriple<String, Direction, String>(CONNECTION_IN_PREFIX + className, Direction.IN, className));            break;          }        }      }    } else {      if (iDirection == Direction.OUT)        result.add(new OTriple<String, Direction, String>(OrientBaseGraph.CONNECTION_OUT, Direction.OUT, null));      else if (iDirection == Direction.IN)        result.add(new OTriple<String, Direction, String>(OrientBaseGraph.CONNECTION_IN, Direction.IN, null));      else {        result.add(new OTriple<String, Direction, String>(OrientBaseGraph.CONNECTION_OUT, Direction.OUT, null));        result.add(new OTriple<String, Direction, String>(OrientBaseGraph.CONNECTION_IN, Direction.IN, null));      }    }    // EARLY FETCH ALL THE FIELDS THAT MATTERS    String[] fieldNames = new String[result.size()];    int i = 0;    for (OTriple<String, Direction, String> connectionField : result)      fieldNames[i++] = connectionField.getKey();    doc.deserializeFields(fieldNames);    return result;  }
private void processBrokenRids(Set<ORID> brokenRids) throws IOException, ParseException {    if (exporterVersion >= 12) {      listener.onMessage("Reading of set of RIDs of records which were detected as broken during database export\n");      jsonReader.readNext(OJSONReader.BEGIN_COLLECTION);      while (true) {        jsonReader.readNext(OJSONReader.NEXT_IN_ARRAY);        final ORecordId recordId = new ORecordId(jsonReader.getValue());        brokenRids.add(recordId);        if (jsonReader.lastChar() == ']')          break;      }    }    if (migrateLinks) {      if (exporterVersion >= 12)        listener.onMessage(            brokenRids.size() + " were detected as broken during database export, links on those records will be removed from"                + " result database");      migrateLinksInImportedDocuments(brokenRids);    }  }
public Object execute(final Map<Object, Object> iArgs) {    if (clazz == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    ODatabaseDocumentInternal db = getDatabase();    final List<Object> edges = new ArrayList<Object>();    Set<OIdentifiable> fromIds = null;    Set<OIdentifiable> toIds = null;    db.begin();    try {      fromIds = OSQLEngine.getInstance().parseRIDTarget(db, from, context, iArgs);      toIds = OSQLEngine.getInstance().parseRIDTarget(db, to, context, iArgs);      // CREATE EDGES      for (OIdentifiable from : fromIds) {        final OVertex fromVertex = toVertex(from);        if (fromVertex == null)          throw new OCommandExecutionException("Source vertex '" + from + "' does not exist");        for (OIdentifiable to : toIds) {          final OVertex toVertex;          if (from.equals(to)) {            toVertex = fromVertex;          } else {            toVertex = toVertex(to);          }          if (toVertex == null) {            throw new OCommandExecutionException("Source vertex '" + to + "' does not exist");          }          if (fields != null)            // EVALUATE FIELDS            for (final OPair<String, Object> f : fields) {              if (f.getValue() instanceof OSQLFunctionRuntime) {                f.setValue(((OSQLFunctionRuntime) f.getValue()).getValue(to, null, context));              } else if (f.getValue() instanceof OSQLFilterItem) {                f.setValue(((OSQLFilterItem) f.getValue()).getValue(to, null, context));              }            }          OEdge edge = null;          if (content != null) {            if (fields != null)              // MERGE CONTENT WITH FIELDS              fields.addAll(OPair.convertFromMap(content.toMap()));            else              fields = OPair.convertFromMap(content.toMap());          }          edge = fromVertex.addEdge(toVertex, edgeLabel);          if (fields != null && !fields.isEmpty()) {            OSQLHelper.bindParameters(edge.getRecord(), fields, new OCommandParameters(iArgs), context);          }          edge.save(clusterName);          fromVertex.save();          toVertex.save();          edges.add(edge);          if (batch > 0 && edges.size() % batch == 0) {            db.commit();            db.begin();          }        }      }    } finally {      db.commit();    }    if (edges.isEmpty()) {      if (fromIds.isEmpty())        throw new OCommandExecutionException("No edge has been created because no source vertices");      else if (toIds.isEmpty())        throw new OCommandExecutionException("No edge has been created because no target vertices");      throw new OCommandExecutionException("No edge has been created between " + fromIds + " and " + toIds);    }    return edges;  }
protected Map<Method, Object> getConsoleMethods() {    if (methods != null)      return methods;    // search for declared command collections    final Iterator<OConsoleCommandCollection> ite = ServiceLoader.load(OConsoleCommandCollection.class).iterator();    final Collection<Object> candidates = new ArrayList<Object>();    candidates.add(this);    while (ite.hasNext()) {      try {        // make a copy and set it's context        final OConsoleCommandCollection cc = ite.next().getClass().newInstance();        cc.setContext(this);        candidates.add(cc);      } catch (InstantiationException ex) {        Logger.getLogger(OConsoleApplication.class.getName()).log(Level.WARNING, ex.getMessage());      } catch (IllegalAccessException ex) {        Logger.getLogger(OConsoleApplication.class.getName()).log(Level.WARNING, ex.getMessage());      }    }    methods = new TreeMap<Method, Object>(new Comparator<Method>() {      public int compare(Method o1, Method o2) {        final ConsoleCommand ann1 = o1.getAnnotation(ConsoleCommand.class);        final ConsoleCommand ann2 = o2.getAnnotation(ConsoleCommand.class);        if (ann1 != null && ann2 != null) {          if (ann1.priority() != ann2.priority())            // PRIORITY WINS            return ann1.priority() - ann2.priority();        }        int res = o1.getName().compareTo(o2.getName());        if (res == 0)          res = o1.toString().compareTo(o2.toString());        return res;      }    });    for (final Object candidate : candidates) {      final Method[] classMethods = candidate.getClass().getMethods();      for (Method m : classMethods) {        if (Modifier.isAbstract(m.getModifiers()) || Modifier.isStatic(m.getModifiers()) || !Modifier.isPublic(m.getModifiers())) {          continue;        }        if (m.getReturnType() != Void.TYPE) {          continue;        }        methods.put(m, candidate);      }    }    return methods;  }
@Override  public Object executeOnLocalNode(final ODistributedRequestId reqId, final ORemoteTask task,      final ODatabaseDocumentInternal database) {    if (database != null && !(database.getStorage() instanceof ODistributedStorage))      throw new ODistributedException(          "Distributed storage was not installed for database '" + database.getName() + "'. Implementation found: " + database              .getStorage().getClass().getName());    final ODistributedAbstractPlugin manager = this;    return OScenarioThreadLocal.executeAsDistributed(new Callable<Object>() {      @Override      public Object call() throws Exception {        try {          final Object result = task.execute(reqId, serverInstance, manager, database);          if (result instanceof Throwable && !(result instanceof OException))            // EXCEPTION            ODistributedServerLog.debug(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,                "Error on executing request %d (%s) on local node: ", (Throwable) result, reqId, task);          else {            // OK            final String sourceNodeName = task.getNodeSource();            if (database != null) {              final ODistributedDatabaseImpl ddb = getMessageService().getDatabase(database.getName());              if (ddb != null && !(result instanceof Throwable) && task instanceof OAbstractReplicatedTask && !task                  .isIdempotent()) {                // UPDATE LSN WITH LAST OPERATION                ddb.setLSN(sourceNodeName, ((OAbstractReplicatedTask) task).getLastLSN(), true);                // UPDATE LSN WITH LAST LOCAL OPERATION                ddb.setLSN(getLocalNodeName(), ((OAbstractPaginatedStorage) database.getStorage().getUnderlying()).getLSN(), true);              }            }          }          return result;        } catch (InterruptedException e) {          // IGNORE IT          ODistributedServerLog.debug(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,              "Interrupted execution on executing distributed request %s on local node: %s", e, reqId, task);          return e;        } catch (Exception e) {          if (!(e instanceof OException))            ODistributedServerLog.error(this, nodeName, getNodeNameById(reqId.getNodeId()), DIRECTION.IN,                "Error on executing distributed request %s on local node: %s", e, reqId, task);          return e;        }      }    });  }
@Override  public int getAvailableNodes(final Collection<String> iNodes, final String databaseName) {    for (Iterator<String> it = iNodes.iterator(); it.hasNext(); ) {      final String node = it.next();      if (!isNodeAvailable(node, databaseName))        it.remove();    }    return iNodes.size();  }
@Override  public int getNodesWithStatus(final Collection<String> iNodes, final String databaseName, final DB_STATUS... statuses) {    for (Iterator<String> it = iNodes.iterator(); it.hasNext(); ) {      final String node = it.next();      if (!isNodeStatusEqualsTo(node, databaseName, statuses))        it.remove();    }    return iNodes.size();  }
protected void installDatabaseFromNetwork(final String dbPath, final String databaseName,      final ODistributedDatabaseImpl distrDatabase, final String iNode, final ODistributedDatabaseChunk firstChunk,      final boolean delta, final File uniqueClustersBackupDirectory, final OModifiableDistributedConfiguration cfg) {    final String fileName = Orient.getTempPath() + "install_" + databaseName + "_server" + getLocalNodeId() + ".zip";    final String localNodeName = nodeName;    ODistributedServerLog        .info(this, localNodeName, iNode, DIRECTION.IN, "Copying remote database '%s' to: %s", databaseName, fileName);    final File file = new File(fileName);    if (file.exists())      file.delete();    try {      file.getParentFile().mkdirs();      file.createNewFile();    } catch (IOException e) {      throw OException.wrapException(new ODistributedException("Error on creating temp database file to install locally"), e);    }    // DELETE ANY PREVIOUS .COMPLETED FILE    final File completedFile = new File(file.getAbsolutePath() + ".completed");    if (completedFile.exists())      completedFile.delete();    final AtomicReference<ODistributedMomentum> momentum = new AtomicReference<ODistributedMomentum>();    OSyncReceiver receiver = new OSyncReceiver(this, databaseName, firstChunk, momentum, fileName, iNode, dbPath, file);    try {      Thread t = new Thread(receiver);      t.setUncaughtExceptionHandler(new OUncaughtExceptionHandler());      t.start();    } catch (Exception e) {      ODistributedServerLog          .error(this, nodeName, null, DIRECTION.NONE, "Error on transferring database '%s' to '%s'", e, databaseName, fileName);      throw OException.wrapException(new ODistributedException("Error on transferring database"), e);    }    final ODatabaseDocumentInternal db = installDatabaseOnLocalNode(databaseName, dbPath, iNode, fileName, delta,        uniqueClustersBackupDirectory, cfg, firstChunk.incremental, firstChunk.walSegment, firstChunk.walPosition, receiver);    if (db == null)      return;    // OVERWRITE THE MOMENTUM FROM THE ORIGINAL SERVER AND ADD LAST LOCAL LSN    try {      distrDatabase.getSyncConfiguration().load();      distrDatabase.getSyncConfiguration()          .setLastLSN(localNodeName, ((OLocalPaginatedStorage) db.getStorage().getUnderlying()).getLSN(), false);    } catch (IOException e) {      ODistributedServerLog.error(this, nodeName, null, DIRECTION.NONE, "Error on loading %s file for database '%s'", e,          DISTRIBUTED_SYNC_JSON_FILENAME, databaseName);    }    try {      distrDatabase.setOnline();    } finally {      db.activateOnCurrentThread();      db.close();    }    try {      rebalanceClusterOwnership(nodeName, db, cfg, false);    } catch (Exception e) {      // HANDLE IT AS WARNING      ODistributedServerLog          .warn(this, nodeName, null, DIRECTION.NONE, "Error on re-balancing the cluster for database '%s'", e, databaseName);      // NOT CRITICAL, CONTINUE    }  }
@Override  public List<String> backup(OutputStream out, Map<String, Object> options, Callable<Object> callable,      final OCommandOutputListener iListener, int compressionLevel, int bufferSize) throws IOException {    return underlying.backup(out, options, callable, iListener, compressionLevel, bufferSize);  }
protected ORole createRole(final ODocument roleDoc) {    ORole role = null;     // If databaseName is set, then only allow roles with the same databaseName.    if (databaseName != null && !databaseName.isEmpty()) {    	if (roleDoc != null && roleDoc.containsField(OSystemRole.DB_FILTER) && roleDoc.fieldType(OSystemRole.DB_FILTER) == OType.EMBEDDEDLIST) {    		    	  List<String> dbNames = roleDoc.field(OSystemRole.DB_FILTER, OType.EMBEDDEDLIST);  	 	    	 	  for (String dbName : dbNames) {  	       if (dbName != null && !dbName.isEmpty() && (dbName.equalsIgnoreCase(databaseName) || dbName.equals("*"))) {    	      role = new OSystemRole(roleDoc);    	      break;    	    }    	  }      }    }    // If databaseName is not set, only return roles without a OSystemRole.DB_FILTER property or if set to "*".    else {      if (roleDoc != null) {        if (!roleDoc.containsField(OSystemRole.DB_FILTER)) {    	    role = new OSystemRole(roleDoc);    	  } else { // It does use the dbFilter property.          if(roleDoc.fieldType(OSystemRole.DB_FILTER) == OType.EMBEDDEDLIST) {      	   List<String> dbNames = roleDoc.field(OSystemRole.DB_FILTER, OType.EMBEDDEDLIST);  	 	    	 	      for (String dbName : dbNames) {  	           if (dbName != null && !dbName.isEmpty() && dbName.equals("*")) {    	          role = new OSystemRole(roleDoc);    	          break;    	        }    	      }    	    }        }      }    }    return role;  }
public Object execute(final Map<Object, Object> iArgs) {    final ODatabaseDocument database = getDatabase();    if (attribute == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final OClassImpl cls = (OClassImpl) database.getMetadata().getSchema().getClass(className);    if (cls == null)      throw new OCommandExecutionException("Cannot alter class '" + className + "' because not found");    if (!unsafe && attribute == ATTRIBUTES.NAME && cls.isSubClassOf("E"))      throw new OCommandExecutionException("Cannot alter class '" + className          + "' because is an Edge class and could break vertices. Use UNSAFE if you want to force it");    // REMOVE CACHE OF COMMAND RESULTS    for (int clId : cls.getPolymorphicClusterIds())      getDatabase().getMetadata().getCommandCache().invalidateResultsOfCluster(getDatabase().getClusterNameById(clId));    if (value != null && attribute == ATTRIBUTES.SUPERCLASS) {      checkClassExists(database, className, decodeClassName(value));    }    if (value != null && attribute == ATTRIBUTES.SUPERCLASSES) {      List<String> classes = Arrays.asList(value.split(",\\s*"));      for (String cName : classes) {        checkClassExists(database, className, decodeClassName(cName));      }    }    if (!unsafe && value != null && attribute == ATTRIBUTES.NAME) {      if (!cls.getIndexes().isEmpty()) {        throw new OCommandExecutionException("Cannot rename class '" + className            + "' because it has indexes defined on it. Drop indexes before or use UNSAFE (at your won risk)");      }    }    cls.set(attribute, value);    return Boolean.TRUE;  }
protected Object executeSQL() {    ODatabaseDocument db = ODatabaseRecordThreadLocal.instance().getIfDefined();    try {      return executeSQLScript(parserText, db);    } catch (IOException e) {      throw OException.wrapException(new OCommandExecutionException("Error on executing command: " + parserText), e);    }  }
protected void waitForNextRetry() {    try {      Thread.sleep(new Random().nextInt(MAX_DELAY - 1) + 1);    } catch (InterruptedException e) {      OLogManager.instance().error(this, "Wait was interrupted", e);    }  }
public String getArgument(final int iPosition) {     return args != null && args.length > iPosition ? args[iPosition] : null;   }
public int hasParameters(final String... iNames) {     int found = 0;     if (iNames != null && request.parameters != null)       for (String name : iNames)         found += request.parameters.containsKey(name) ? 1 : 0;     return found;   }
@Deprecated  public synchronized OServerAdmin connect(final String iUserName, final String iUserPassword) throws IOException {    final String username;    final String password;    OCredentialInterceptor ci = OSecurityManager.instance().newCredentialInterceptor();    if (ci != null) {      ci.intercept(storage.getURL(), iUserName, iUserPassword);      username = ci.getUsername();      password = ci.getPassword();    } else {      username = iUserName;      password = iUserPassword;    }    OConnect37Request request = new OConnect37Request(username, password);    networkAdminOperation((network, session) -> {      OStorageRemoteNodeSession nodeSession = session.getOrCreateServerSession(network.getServerURL());      try {        network.beginRequest(request.getCommand(), session);        request.write(network, session);      } finally {        network.endRequest();      }      OConnectResponse response = request.createResponse();      try {        network.beginResponse(nodeSession.getSessionId(), true);        response.read(network, session);      } finally {        storage.endResponse(network);      }      return null;    }, "Cannot connect to the remote server/database '" + storage.getURL() + "'");    return this;  }
@Deprecated  public synchronized Map<String, String> listDatabases() throws IOException {    OListDatabasesRequest request = new OListDatabasesRequest();    OListDatabasesResponse response = networkAdminOperation(request, "Cannot retrieve the configuration list");    return response.getDatabases();  }
@Deprecated  public synchronized ODocument getServerInfo() throws IOException {    OServerInfoRequest request = new OServerInfoRequest();    OServerInfoResponse response = networkAdminOperation(request, "Cannot retrieve server information");    ODocument res = new ODocument();    res.fromJSON(response.getResult());    return res;  }
@Deprecated  public synchronized OServerAdmin createDatabase(final String iDatabaseType, String iStorageMode) throws IOException {    return createDatabase(storage.getName(), iDatabaseType, iStorageMode);  }
public synchronized OServerAdmin createDatabase(final String iDatabaseName, final String iDatabaseType, final String iStorageMode,      final String backupPath) throws IOException {    if (iDatabaseName == null || iDatabaseName.length() <= 0) {      final String message = "Cannot create unnamed remote storage. Check your syntax";      OLogManager.instance().error(this, message, null);      throw new OStorageException(message);    } else {      String storageMode;      if (iStorageMode == null)        storageMode = "plocal";      else        storageMode = iStorageMode;      OCreateDatabaseRequest request = new OCreateDatabaseRequest(iDatabaseName, iDatabaseName, storageMode, backupPath);      OCreateDatabaseResponse response = networkAdminOperation(request, "Cannot create the remote storage: " + storage.getName());    }    return this;  }
public synchronized boolean existsDatabase(final String iDatabaseName, final String storageType) throws IOException {    OExistsDatabaseRequest request = new OExistsDatabaseRequest(iDatabaseName, storageType);    OExistsDatabaseResponse response = networkAdminOperation(request,        "Error on checking existence of the remote storage: " + storage.getName());    return response.isExists();  }
public synchronized OServerAdmin dropDatabase(final String iDatabaseName, final String storageType) throws IOException {    ODropDatabaseRequest request = new ODropDatabaseRequest(iDatabaseName, storageType);    ODropDatabaseResponse response = networkAdminOperation(request, "Cannot delete the remote storage: " + storage.getName());    OURLConnection connection = OURLHelper.parse(getURL());    OrientDBRemote remote = (OrientDBRemote) ODatabaseDocumentTxInternal.getOrCreateRemoteFactory(connection.getPath());    remote.forceDatabaseClose(iDatabaseName);    ODatabaseRecordThreadLocal.instance().remove();    return this;  }
public synchronized OServerAdmin freezeDatabase(final String storageType) throws IOException {    OFreezeDatabaseRequest request = new OFreezeDatabaseRequest(storage.getName(), storageType);    OFreezeDatabaseResponse response = networkAdminOperation(request, "Cannot freeze the remote storage: " + storage.getName());    return this;  }
public synchronized OServerAdmin releaseDatabase(final String storageType) throws IOException {    OReleaseDatabaseRequest request = new OReleaseDatabaseRequest(storage.getName(), storageType);    OReleaseDatabaseResponse response = networkAdminOperation(request, "Cannot release the remote storage: " + storage.getName());    return this;  }
public ODocument clusterStatus() {    ODistributedStatusRequest request = new ODistributedStatusRequest();    ODistributedStatusResponse response = storage.networkOperation(request, "Error on executing Cluster status ");    OLogManager.instance().debug(this, "Cluster status %s", response.getClusterConfig().toJSON("prettyPrint"));    return response.getClusterConfig();  }
@SuppressWarnings("rawtypes")  public Object execute(final Map<Object, Object> iArgs) {    if (indexName == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocument database = getDatabase();    final OIndex<?> idx;    List<OCollate> collatesList = null;    if (collates != null) {      collatesList = new ArrayList<OCollate>();      for (String collate : collates) {        if (collate != null) {          final OCollate col = OSQLEngine.getCollate(collate);          collatesList.add(col);        } else          collatesList.add(null);      }    }    if (fields == null || fields.length == 0) {      OIndexFactory factory = OIndexes.getFactory(indexType.toString(), null);      if (keyTypes != null)        idx = database.getMetadata().getIndexManager()            .createIndex(indexName, indexType.toString(), new OSimpleKeyIndexDefinition(keyTypes, collatesList), null, null,                metadataDoc, engine);      else if (serializerKeyId != 0) {        idx = database.getMetadata().getIndexManager()            .createIndex(indexName, indexType.toString(), new ORuntimeKeyIndexDefinition(serializerKeyId), null, null, metadataDoc,                engine);      } else {        throw new ODatabaseException("Impossible to create an index without specify the key type or the associated property");      }    } else {      if ((keyTypes == null || keyTypes.length == 0) && collates == null) {        idx = oClass.createIndex(indexName, indexType.toString(), null, metadataDoc, engine, fields);      } else {        final List<OType> fieldTypeList;        if (keyTypes == null) {          for (final String fieldName : fields) {            if (!fieldName.equals("@rid") && !oClass.existsProperty(fieldName))              throw new OIndexException(                  "Index with name : '" + indexName + "' cannot be created on class : '" + oClass.getName() + "' because field: '"                      + fieldName + "' is absent in class definition.");          }          fieldTypeList = ((OClassImpl) oClass).extractFieldTypes(fields);        } else          fieldTypeList = Arrays.asList(keyTypes);        final OIndexDefinition idxDef = OIndexDefinitionFactory            .createIndexDefinition(oClass, Arrays.asList(fields), fieldTypeList, collatesList, indexType.toString(), null);        idx = database.getMetadata().getIndexManager()            .createIndex(indexName, indexType.name(), idxDef, oClass.getPolymorphicClusterIds(), null, metadataDoc, engine);      }    }    if (idx != null)      return idx.getSize();    return null;  }
public static OrientGraph getGraph(final boolean autoStartTx, OModifiableBoolean shouldBeShutDown) {    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();    final OrientBaseGraph result = OrientBaseGraph.getActiveGraph();    if (result != null && (result instanceof OrientGraph)) {      final ODatabaseDocumentInternal graphDb = result.getRawGraph();      // CHECK IF THE DATABASE + USER IN TL IS THE SAME IN ORDER TO USE IT      if (canReuseActiveGraph(graphDb, database)) {        if (!graphDb.isClosed()) {          ODatabaseRecordThreadLocal.instance().set(graphDb);          if (autoStartTx && autoTxStartRequired(graphDb))            ((OrientGraph) result).begin();          shouldBeShutDown.setValue(false);          return (OrientGraph) result;        }      }    }    // Set it again on ThreadLocal because the getRawGraph() may have set a closed db in the thread-local    ODatabaseRecordThreadLocal.instance().set(database);    shouldBeShutDown.setValue(true);    final OrientGraph g = (OrientGraph) OrientGraphFactory.getTxGraphImplFactory().getGraph(database, false);    if (autoStartTx && autoTxStartRequired(database))      g.begin();    return g;  }
protected void parseRetry() throws OCommandSQLParsingException {    retry = Integer.parseInt(parserNextWord(true));    String temp = parseOptionalWord(true);    if (temp.equals("WAIT")) {      wait = Integer.parseInt(parserNextWord(true));    } else      parserGoBack();  }
long reset(boolean executeViaDistributed) throws ODatabaseException {    long retVal;    if (executeViaDistributed) {      try {        retVal = sendSequenceActionOverCluster(OSequenceAction.RESET, null);      } catch (InterruptedException | ExecutionException exc) {        OLogManager.instance().error(this, exc.getMessage(), exc, (Object[]) null);        throw new ODatabaseException(exc.getMessage());      }    } else {      retVal = resetWork();    }    return retVal;  }
public ORecord saveRecord(final ORecord iRecord, final String iClusterName, final OPERATION_MODE iMode, boolean iForceCreate,      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {    try {      return database.saveAll(iRecord, iClusterName, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);    } catch (Exception e) {      // REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS      final ORecordId rid = (ORecordId) iRecord.getIdentity();      if (rid.isValid())        database.getLocalCache().freeRecord(rid);      if (e instanceof ONeedRetryException)        throw (ONeedRetryException) e;      throw OException.wrapException(          new ODatabaseException("Error during saving of record" + (iRecord != null ? " with rid " + iRecord.getIdentity() : "")),          e);    }  }
public void deleteRecord(final ORecord iRecord, final OPERATION_MODE iMode) {    if (!iRecord.getIdentity().isPersistent())      return;    try {      database.executeDeleteRecord(iRecord, iRecord.getVersion(), true, iMode, false);    } catch (Exception e) {      // REMOVE IT FROM THE CACHE TO AVOID DIRTY RECORDS      final ORecordId rid = (ORecordId) iRecord.getIdentity();      if (rid.isValid())        database.getLocalCache().freeRecord(rid);      if (e instanceof RuntimeException)        throw (RuntimeException) e;      throw OException.wrapException(          new ODatabaseException("Error during deletion of record" + (iRecord != null ? " with rid " + iRecord.getIdentity() : "")),          e);    }  }
public void config(final OServer oServer, final OServerConfigurationManager serverCfg, final ODocument jsonConfig) {    server = oServer;    serverConfig = serverCfg;    if (jsonConfig.containsField("name")) {      name = jsonConfig.field("name");    }    if (jsonConfig.containsField("debug")) {      debug = jsonConfig.field("debug");    }    if (jsonConfig.containsField("enabled")) {      enabled = jsonConfig.field("enabled");    }    if (jsonConfig.containsField("caseSensitive")) {      caseSensitive = jsonConfig.field("caseSensitive");    }  }
public String getAuthenticationHeader(String databaseName) {    String header;    // Default to Basic.    if (databaseName != null)      header = "WWW-Authenticate: Basic realm=\"OrientDB db-" + databaseName + "\"";    else      header = "WWW-Authenticate: Basic realm=\"OrientDB Server\"";    return header;  }
public void config(final OServer oServer, final OServerConfigurationManager serverCfg, final ODocument jsonConfig) {    super.config(oServer, serverCfg, jsonConfig);    try {    } catch (Exception ex) {      OLogManager.instance().error(this, "config()", ex);    }  }
public String authenticate(final String username, final String password) {    String principal = null;    try {      if (getServer() != null) {        // dbName parameter is null because we don't need to filter any roles for this.        OUser user = getServer().getSecurity().getSystemUser(username, null);        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {          if (user.checkPassword(password))            principal = username;        }      }    } catch (Exception ex) {      OLogManager.instance().error(this, "authenticate()", ex);    }    return principal;  }
public boolean isAuthorized(final String username, final String resource) {    if (username == null || resource == null)      return false;    try {      if (getServer() != null) {        OUser user = getServer().getSecurity().getSystemUser(username, null);        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {          ORole role = null;          ORule.ResourceGeneric rg = ORule.mapLegacyResourceToGenericResource(resource);          if (rg != null) {            String specificResource = ORule.mapLegacyResourceToSpecificResource(resource);            if (specificResource == null || specificResource.equals("*")) {              specificResource = null;            }            role = user.checkIfAllowed(rg, specificResource, ORole.PERMISSION_EXECUTE);          }          return role != null;        }      }    } catch (Exception ex) {      OLogManager.instance().error(this, "isAuthorized()", ex);    }    return false;  }
public OServerUserConfiguration getUser(final String username) {    OServerUserConfiguration userCfg = null;    try {      if (getServer() != null) {        OUser user = getServer().getSecurity().getSystemUser(username, null);        if (user != null && user.getAccountStatus() == OSecurityUser.STATUSES.ACTIVE) {          userCfg = new OServerUserConfiguration(user.getName(), "", "");        }      }    } catch (Exception ex) {      OLogManager.instance().error(this, "getUser()", ex);    }    return userCfg;  }
@Override  public void run() {    if (server != null)      if (!server.shutdown()) {        // ALREADY IN SHUTDOWN, WAIT FOR 5 SEC MORE        try {          Thread.sleep(5000);        } catch (InterruptedException e) {        }      }  }
public void ReInit(java.io.Reader dstream,                 int startline, int startcolumn, int buffersize)  {    inputStream = dstream;    line = startline;    column = startcolumn - 1;    if (buffer == null || buffersize != buffer.length)    {      available = bufsize = buffersize;      buffer = new char[buffersize];      bufline = new int[buffersize];      bufcolumn = new int[buffersize];      nextCharBuf = new char[4096];    }    prevCharIsLF = prevCharIsCR = false;    tokenBegin = inBuf = maxNextCharInd = 0;    nextCharInd = bufpos = -1;  }
public void ReInit(java.io.Reader dstream,                                        int startline, int startcolumn)  {    ReInit(dstream, startline, startcolumn, 4096);  }
public void ReInit(java.io.InputStream dstream, String encoding, int startline,  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException  {    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);  }
public void ReInit(java.io.InputStream dstream, int startline,  int startcolumn, int buffersize)  {    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);  }
public void ReInit(java.io.InputStream dstream, String encoding, int startline,                     int startcolumn) throws java.io.UnsupportedEncodingException  {    ReInit(dstream, encoding, startline, startcolumn, 4096);  }
public void ReInit(java.io.InputStream dstream, int startline,                     int startcolumn)  {    ReInit(dstream, startline, startcolumn, 4096);  }
public void adjustBeginLineColumn(int newLine, int newCol)  {    int start = tokenBegin;    int len;    if (bufpos >= tokenBegin)    {      len = bufpos - tokenBegin + inBuf + 1;    }    else    {      len = bufsize - tokenBegin + bufpos + 1 + inBuf;    }    int i = 0, j = 0, k = 0;    int nextColDiff = 0, columnDiff = 0;    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])    {      bufline[j] = newLine;      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];      bufcolumn[j] = newCol + columnDiff;      columnDiff = nextColDiff;      i++;    }    if (i < len)    {      bufline[j] = newLine++;      bufcolumn[j] = newCol + columnDiff;      while (i++ < len)      {        if (bufline[j = start % bufsize] != bufline[++start % bufsize])          bufline[j] = newLine++;        else          bufline[j] = newLine;      }    }    line = bufline[j];    column = bufcolumn[j];  }
@Override  public void serializeInByteBufferObject(OCompositeKey object, ByteBuffer buffer, Object... hints) {    final OType[] types = getKeyTypes(hints);    final List<Object> keys = object.getKeys();    final int keysSize = keys.size();    final int oldStartOffset = buffer.position();    buffer.position(oldStartOffset + OIntegerSerializer.INT_SIZE);    buffer.putInt(keysSize);    final OBinarySerializerFactory factory = OBinarySerializerFactory.getInstance();    for (int i = 0; i < keys.size(); i++) {      final Object key = keys.get(i);      OBinarySerializer<Object> binarySerializer;      if (key != null) {        final OType type;        if (types.length > i)          type = types[i];        else          type = OType.getTypeByClass(key.getClass());        binarySerializer = factory.getObjectSerializer(type);      } else        binarySerializer = ONullSerializer.INSTANCE;      buffer.put(binarySerializer.getId());      binarySerializer.serializeInByteBufferObject(key, buffer);    }    final int finalPosition = buffer.position();    final int serializedSize = buffer.position() - oldStartOffset;    buffer.position(oldStartOffset);    buffer.putInt(serializedSize);    buffer.position(finalPosition);  }
@Override  public OCompositeKey deserializeFromByteBufferObject(ByteBuffer buffer) {    final OCompositeKey compositeKey = new OCompositeKey();    buffer.position(buffer.position() + OIntegerSerializer.INT_SIZE);    final int keysSize = buffer.getInt();    final OBinarySerializerFactory factory = OBinarySerializerFactory.getInstance();    for (int i = 0; i < keysSize; i++) {      final byte serializerId = buffer.get();      @SuppressWarnings("unchecked")      OBinarySerializer<Object> binarySerializer = (OBinarySerializer<Object>) factory.getObjectSerializer(serializerId);      final Object key = binarySerializer.deserializeFromByteBufferObject(buffer);      compositeKey.addKey(key);    }    return compositeKey;  }
@Override  public OCompositeKey deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final OCompositeKey compositeKey = new OCompositeKey();    offset += OIntegerSerializer.INT_SIZE;    final int keysSize = walChanges.getIntValue(buffer, offset);    offset += OIntegerSerializer.INT_SIZE;    final OBinarySerializerFactory factory = OBinarySerializerFactory.getInstance();    for (int i = 0; i < keysSize; i++) {      final byte serializerId = walChanges.getByteValue(buffer, offset);      offset += OBinarySerializerFactory.TYPE_IDENTIFIER_SIZE;      @SuppressWarnings("unchecked")      OBinarySerializer<Object> binarySerializer = (OBinarySerializer<Object>) factory.getObjectSerializer(serializerId);      final Object key = binarySerializer.deserializeFromByteBufferObject(buffer, walChanges, offset);      compositeKey.addKey(key);      offset += binarySerializer.getObjectSize(key);    }    return compositeKey;  }
protected void setBucketPointer(int pageOffset, OBonsaiBucketPointer value) throws IOException {    setLongValue(pageOffset, value.getPageIndex());    setIntValue(pageOffset + OLongSerializer.LONG_SIZE, value.getPageOffset());  }
protected OBonsaiBucketPointer getBucketPointer(int offset) {    final long pageIndex = getLongValue(offset);    final int pageOffset = getIntValue(offset + OLongSerializer.LONG_SIZE);    return new OBonsaiBucketPointer(pageIndex, pageOffset);  }
@Override  public OClass truncateCluster(String clusterName) {    getDatabase().checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_DELETE, name);    acquireSchemaReadLock();    try {      final ODatabaseDocumentInternal database = getDatabase();      truncateClusterInternal(clusterName, database);    } finally {      releaseSchemaReadLock();    }    return this;  }
public OAtomicOperation startAtomicOperation(String lockName, boolean trackNonTxOperations) throws IOException {    OAtomicOperation operation = currentOperation.get();    if (operation != null) {      operation.incrementCounter();      if (lockName != null) {        acquireExclusiveLockTillOperationComplete(operation, lockName);      }      return operation;    }    atomicOperationsCount.increment();    while (freezeRequests.get() > 0) {      assert freezeRequests.get() >= 0;      atomicOperationsCount.decrement();      throwFreezeExceptionIfNeeded();      final Thread thread = Thread.currentThread();      addThreadInWaitingList(thread);      if (freezeRequests.get() > 0) {        LockSupport.park(this);      }      atomicOperationsCount.increment();    }    assert freezeRequests.get() >= 0;    final boolean useWal = useWal();    final OOperationUnitId unitId = OOperationUnitId.generateId();    final OLogSequenceNumber lsn = useWal ? writeAheadLog.logAtomicOperationStartRecord(true, unitId) : null;    operation = new OAtomicOperation(lsn, unitId, readCache, writeCache, storage.getId());    currentOperation.set(operation);    if (trackAtomicOperations) {      final Thread thread = Thread.currentThread();      activeAtomicOperations.put(unitId, new OPair<>(thread.getName(), thread.getStackTrace()));    }    if (useWal && trackNonTxOperations && storage.getStorageTransaction() == null) {      writeAheadLog.log(new ONonTxOperationPerformedWALRecord());    }    if (lockName != null) {      acquireExclusiveLockTillOperationComplete(operation, lockName);    }    try {      storage.checkReadOnlyConditions();    } catch (RuntimeException | Error e) {      final Iterator<String> lockedObjectIterator = operation.lockedObjects().iterator();      while (lockedObjectIterator.hasNext()) {        final String lockedObject = lockedObjectIterator.next();        lockedObjectIterator.remove();        lockManager.releaseLock(this, lockedObject, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);      }      throw e;    }    return operation;  }
public OLogSequenceNumber endAtomicOperation(boolean rollback) throws IOException {    final OAtomicOperation operation = currentOperation.get();    if (operation == null) {      OLogManager.instance().error(this, "There is no atomic operation active", null);      throw new ODatabaseException("There is no atomic operation active");    }    int counter = operation.getCounter();    operation.decrementCounter();    assert counter > 0;    final OLogSequenceNumber lsn;    try {      if (rollback) {        operation.rollback();      }      if (counter == 1) {        try {          final boolean useWal = useWal();          if (!operation.isRollback()) {            lsn = operation.commitChanges(useWal ? writeAheadLog : null);          } else {            lsn = null;          }          if (trackAtomicOperations) {            activeAtomicOperations.remove(operation.getOperationUnitId());          }        } finally {          final Iterator<String> lockedObjectIterator = operation.lockedObjects().iterator();          while (lockedObjectIterator.hasNext()) {            final String lockedObject = lockedObjectIterator.next();            lockedObjectIterator.remove();            lockManager.releaseLock(this, lockedObject, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);          }          currentOperation.set(null);        }      } else {        lsn = null;      }    } catch (Error e) {      final OAbstractPaginatedStorage st = storage;      if (st != null) {        st.handleJVMError(e);      }      counter = 1;      throw e;    } finally {      if (counter == 1) {        atomicOperationsCount.decrement();      }    }    return lsn;  }
public void acquireExclusiveLockTillOperationComplete(OAtomicOperation operation, String lockName) {    if (operation.containsInLockedObjects(lockName)) {      return;    }    lockManager.acquireLock(lockName, OOneEntryPerKeyLockManager.LOCK.EXCLUSIVE);    operation.addLockedObject(lockName);  }
public void acquireExclusiveLockTillOperationComplete(ODurableComponent durableComponent) {    final OAtomicOperation operation = currentOperation.get();    assert operation != null;    acquireExclusiveLockTillOperationComplete(operation, durableComponent.getLockName());  }
public void changeMaximumAmountOfMemory(final long readCacheMaxMemory) throws IllegalStateException {    MemoryData memoryData;    MemoryData newMemoryData;    final int newMemorySize = normalizeMemory(readCacheMaxMemory, pageSize);    do {      memoryData = memoryDataContainer.get();      if (memoryData.maxSize == newMemorySize) {        return;      }      if ((100 * memoryData.pinnedPages / newMemorySize) > percentOfPinnedPages) {        throw new IllegalStateException("Cannot decrease amount of memory used by disk cache "            + "because limit of pinned pages will be more than allowed limit " + percentOfPinnedPages);      }      newMemoryData = new MemoryData(newMemorySize, memoryData.pinnedPages);    } while (!memoryDataContainer.compareAndSet(memoryData, newMemoryData));//    if (newMemorySize < memoryData.maxSize)//      removeColdestPagesIfNeeded();    OLogManager.instance()        .info(this, "Disk cache size was changed from " + memoryData.maxSize + " pages to " + newMemorySize + " pages");  }
@Override  public final void closeStorage(final OWriteCache writeCache) throws IOException {    if (writeCache == null) {      return;    }    cacheLock.acquireWriteLock();    try {      final long[] filesToClear = writeCache.close();      clearFiles(writeCache, filesToClear);    } finally {      cacheLock.releaseWriteLock();    }  }
@Override  public final void storeCacheState(final OWriteCache writeCache) {    if (!OGlobalConfiguration.STORAGE_KEEP_DISK_CACHE_STATE.getValueAsBoolean()) {      return;    }    if (writeCache == null) {      return;    }    cacheLock.acquireWriteLock();    try {      final Path rootDirectory = writeCache.getRootDirectory();      final Path stateFile = rootDirectory.resolve(CACHE_STATE_FILE);      if (Files.exists(stateFile)) {        Files.delete(stateFile);      }      final Set<Long> filesToStore = new HashSet<>(writeCache.files().values());      try (final FileChannel channel = FileChannel.open(stateFile, StandardOpenOption.WRITE, StandardOpenOption.CREATE)) {        final OutputStream channelStream = Channels.newOutputStream(channel);        final BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(channelStream, 64 * 1024);        try (final DataOutputStream dataOutputStream = new DataOutputStream(bufferedOutputStream)) {          dataOutputStream.writeLong(memoryDataContainer.get().maxSize);          storeQueueState(writeCache, filesToStore, dataOutputStream, am);          dataOutputStream.writeInt(-1);          storeQueueState(writeCache, filesToStore, dataOutputStream, a1in);          dataOutputStream.writeInt(-1);          storeQueueState(writeCache, filesToStore, dataOutputStream, a1out);          dataOutputStream.writeInt(-1);        }      }    } catch (final Exception e) {      OLogManager.instance()          .error(this, "Cannot store state of cache for storage placed under %s", e, writeCache.getRootDirectory());    } finally {      cacheLock.releaseWriteLock();    }  }
private static void storeQueueState(final OWriteCache writeCache, final Set<Long> filesToStore,      final DataOutputStream dataOutputStream, final LRUList queue) throws IOException {    final Iterator<OCacheEntry> queueIterator = queue.reverseIterator();    while (queueIterator.hasNext()) {      final OCacheEntry cacheEntry = queueIterator.next();      final long fileId = cacheEntry.getFileId();      if (filesToStore.contains(fileId)) {        final int internalId = writeCache.internalFileId(fileId);        dataOutputStream.writeInt(internalId);        dataOutputStream.writeLong(cacheEntry.getPageIndex());      }    }  }
private void listen(final String iHostName, final String iHostPortRange, final String iProtocolName,      Class<? extends ONetworkProtocol> protocolClass) {    for (int port : getPorts(iHostPortRange)) {      inboundAddr = new InetSocketAddress(iHostName, port);      try {        serverSocket = socketFactory.createServerSocket(port, 0, InetAddress.getByName(iHostName));        if (serverSocket.isBound()) {          OLogManager.instance().info(this,              "Listening $ANSI{green " + iProtocolName + "} connections on $ANSI{green " + inboundAddr.getAddress().getHostAddress()                  + ":" + inboundAddr.getPort() + "} (protocol v." + protocolVersion + ", socket=" + socketFactory.getName() + ")");          return;        }      } catch (BindException be) {        OLogManager.instance().warn(this, "Port %s:%d busy, trying the next available...", iHostName, port);      } catch (SocketException se) {        OLogManager.instance().error(this, "Unable to create socket", se);        throw new RuntimeException(se);      } catch (IOException ioe) {        OLogManager.instance().error(this, "Unable to read data from an open socket", ioe);        System.err.println("Unable to read data from an open socket.");        throw new RuntimeException(ioe);      }    }    OLogManager.instance()        .error(this, "Unable to listen for connections using the configured ports '%s' on host '%s'", null, iHostPortRange,            iHostName);    throw new OSystemException("Unable to listen for connections using the configured ports '%s' on host '%s'");  }
private void readParameters(final OContextConfiguration iServerConfig, final OServerParameterConfiguration[] iParameters) {    configuration = new OContextConfiguration(iServerConfig);    // SET PARAMETERS    if (iParameters != null && iParameters.length > 0) {      // CONVERT PARAMETERS IN MAP TO INTIALIZE THE CONTEXT-CONFIGURATION      for (OServerParameterConfiguration param : iParameters)        configuration.setValue(param.name, param.value);    }    socketBufferSize = configuration.getValueAsInteger(OGlobalConfiguration.NETWORK_SOCKET_BUFFER_SIZE);  }
public void applyStorageFilter() {    final StorageFilter filter = new StorageFilter();    if (storageFilterHolder.compareAndSet(null, filter)) {      for (Logger logger : loggersCache.values()) {        logger.setFilter(filter);      }    }  }
public void shutdown() {    if (shutdownFlag.compareAndSet(false, true)) {      try {        if (LogManager.getLogManager() instanceof ShutdownLogManager)          ((ShutdownLogManager) LogManager.getLogManager()).shutdown();      } catch (NoClassDefFoundError ignore) {        // Om nom nom. Some custom class loaders, like Tomcat's one, cannot load classes while in shutdown hooks, since their        // runtime is already shutdown. Ignoring the exception, if ShutdownLogManager is not loaded at this point there are no instances        // of it anyway and we have nothing to shutdown.      }    }  }
public void add(K key, V item) throws InterruptedException {    if (!item.isOpen())      throw new IllegalArgumentException("All passed in items should be in open state");    checkOpenFilesLimit();    final OClosableEntry<K, V> closableEntry = new OClosableEntry<K, V>(item);    final OClosableEntry<K, V> oldEntry = data.putIfAbsent(key, closableEntry);    if (oldEntry != null) {      throw new IllegalStateException("Item with key " + key + " already exists");    }    logAdd(closableEntry);  }
public V remove(K key) {    final OClosableEntry<K, V> removed = data.remove(key);    if (removed != null) {      long preStatus = removed.makeRetired();      if (OClosableEntry.isOpen(preStatus)) {        countClosedFiles();      }      logRemoved(removed);      return removed.get();    }    return null;  }
public OClosableEntry<K, V> acquire(K key) throws InterruptedException {    checkOpenFilesLimit();    final OClosableEntry<K, V> entry = data.get(key);    if (entry == null)      return null;    boolean logOpen = false;    entry.acquireStateLock();    try {      if (entry.isRetired() || entry.isDead()) {        return null;      } else if (entry.isClosed()) {        entry.makeAcquiredFromClosed(entry.get());        logOpen = true;      } else if (entry.isOpen()) {        entry.makeAcquiredFromOpen();      } else {        entry.incrementAcquired();      }    } finally {      entry.releaseStateLock();    }    if (logOpen) {      logOpen(entry);    } else {      logAcquire(entry);    }    assert entry.get().isOpen();    return entry;  }
private void checkOpenFilesLimit() throws InterruptedException {    CountDownLatch ol = openLatch.get();    if (ol != null)      ol.await();    while (openFiles.get() > openLimit) {      final CountDownLatch latch = new CountDownLatch(1);      //make other threads to wait till we evict entries and close evicted open files      if (openLatch.compareAndSet(null, latch)) {        while (openFiles.get() > openLimit) {          emptyBuffers();        }        latch.countDown();        openLatch.set(null);      } else {        ol = openLatch.get();        if (ol != null)          ol.await();      }    }  }
public V get(K key) {    final OClosableEntry<K, V> entry = data.get(key);    if (entry != null)      return entry.get();    return null;  }
public void clear() {    lruLock.lock();    try {      data.clear();      openFiles.set(0);      for (int n = 0; n < NUMBER_OF_READ_BUFFERS; n++) {        final AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[n];        for (int i = 0; i < READ_BUFFER_SIZE; i++) {          buffer[i].set(null);        }        readBufferReadCount[n] = 0;        readBufferWriteCount[n].set(0);        readBufferDrainAtWriteCount[n].set(0);      }      stateBuffer.clear();      while (lruList.poll() != null)        ;    } finally {      lruLock.unlock();    }  }
public boolean close(K key) {    emptyBuffers();    final OClosableEntry<K, V> entry = data.get(key);    if (entry == null)      return true;    if (entry.makeClosed()) {      countClosedFiles();      return true;    }    return false;  }
private void emptyWriteBuffer() {    Runnable task = stateBuffer.poll();    while (task != null) {      task.run();      task = stateBuffer.poll();    }  }
private void emptyReadBuffers() {    for (int n = 0; n < NUMBER_OF_READ_BUFFERS; n++) {      AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[n];      long writeCount = readBufferDrainAtWriteCount[n].get();      long counter = readBufferReadCount[n];      while (true) {        final int bufferIndex = (int) (counter & READ_BUFFER_INDEX_MASK);        final AtomicReference<OClosableEntry<K, V>> eref = buffer[bufferIndex];        final OClosableEntry<K, V> entry = eref.get();        if (entry == null)          break;        applyRead(entry);        counter++;        eref.lazySet(null);      }      readBufferReadCount[n] = counter;      readBufferDrainAtWriteCount[n].lazySet(writeCount);    }  }
private void afterWrite(Runnable task) {    stateBuffer.add(task);    drainStatus.lazySet(DrainStatus.REQUIRED);    tryToDrainBuffers();  }
private void afterRead(OClosableEntry<K, V> entry) {    final int bufferIndex = readBufferIndex();    final long writeCount = putEntryInReadBuffer(entry, bufferIndex);    drainReadBuffersIfNeeded(bufferIndex, writeCount);  }
private long putEntryInReadBuffer(OClosableEntry<K, V> entry, int bufferIndex) {    //next index to write for this buffer    AtomicLong writeCounter = readBufferWriteCount[bufferIndex];    final long counter = writeCounter.get();    //we do not use CAS operations to limit contention between threads    //it is normal that because of duplications of indexes some of items will be lost    writeCounter.lazySet(counter + 1);    final AtomicReference<OClosableEntry<K, V>>[] buffer = readBuffers[bufferIndex];    AtomicReference<OClosableEntry<K, V>> bufferEntry = buffer[(int) (counter & READ_BUFFER_INDEX_MASK)];    bufferEntry.lazySet(entry);    return counter + 1;  }
private static int closestPowerOfTwo(int value) {    int n = value - 1;    n |= n >>> 1;    n |= n >>> 2;    n |= n >>> 4;    n |= n >>> 8;    n |= n >>> 16;    return (n < 0) ? 1 : (n >= (1 << 30)) ? 1 << 30 : n + 1;  }
@Override  public void serializeInByteBufferObject(Long object, ByteBuffer buffer, Object... hints) {    buffer.putLong(object);  }
@Override  public Long deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return walChanges.getLongValue(buffer, offset);  }
public boolean onEvent(OLiveQueryPushRequest pushRequest) {    ODatabaseDocumentInternal old = ODatabaseRecordThreadLocal.instance().getIfDefined();    try {      database.activateOnCurrentThread();      if (pushRequest.getStatus() == OLiveQueryPushRequest.ERROR) {        onError(pushRequest.getErrorCode().newException(pushRequest.getErrorMessage(), null));        return true;      } else {        for (OLiveQueryResult result : pushRequest.getEvents()) {          switch (result.getEventType()) {          case OLiveQueryResult.CREATE_EVENT:            listener.onCreate(database, result.getCurrentValue());            break;          case OLiveQueryResult.UPDATE_EVENT:            listener.onUpdate(database, result.getOldValue(), result.getCurrentValue());            break;          case OLiveQueryResult.DELETE_EVENT:            listener.onDelete(database, result.getCurrentValue());            break;          }        }        if (pushRequest.getStatus() == OLiveQueryPushRequest.END) {          onEnd();          return true;        }      }      return false;    } finally {      ODatabaseRecordThreadLocal.instance().set(old);    }  }
public OCommandRequestText fromStream(final byte[] iStream, ORecordSerializer serializer) throws IOException {    if (iStream == null || iStream.length == 0)      // NULL VALUE      return null;    final int classNameSize = OBinaryProtocol.bytes2int(iStream);    if (classNameSize <= 0) {      final String message = "Class signature not found in ANY element: " + Arrays.toString(iStream);      OLogManager.instance().error(this, message, null);      throw new OSerializationException(message);    }    final String className = new String(iStream,4,classNameSize,"UTF-8");    try {      final OCommandRequestText stream;      // CHECK FOR ALIASES      if (className.equalsIgnoreCase("q"))        // QUERY        stream = new OSQLSynchQuery<Object>();      else if (className.equalsIgnoreCase("c"))        // SQL COMMAND        stream = new OCommandSQL();      else if (className.equalsIgnoreCase("s"))        // SCRIPT COMMAND        stream = new OCommandScript();      else        // CREATE THE OBJECT BY INVOKING THE EMPTY CONSTRUCTOR        stream = (OCommandRequestText) Class.forName(className).newInstance();      return stream.fromStream(OArrays.copyOfRange(iStream, 4 + classNameSize, iStream.length), serializer);    } catch (Exception e) {      final String message = "Error on unmarshalling content. Class: " + className;      OLogManager.instance().error(this, message, e);      throw OException.wrapException(new OSerializationException(message), e);    }  }
public byte[] toStream(final OCommandRequestText iObject) throws IOException {    if (iObject == null)      return null;    // SERIALIZE THE CLASS NAME    final byte[] className;    if (iObject instanceof OLiveQuery<?>)      className = iObject.getClass().getName().getBytes("UTF-8");    else if (iObject instanceof OSQLSynchQuery<?>)      className = QUERY_COMMAND_CLASS_ASBYTES;    else if (iObject instanceof OCommandSQL)      className = SQL_COMMAND_CLASS_ASBYTES;    else if (iObject instanceof OCommandScript)      className = SCRIPT_COMMAND_CLASS_ASBYTES;    else {      if (iObject == null)        className = null;      else        className = iObject.getClass().getName().getBytes("UTF-8");    }    // SERIALIZE THE OBJECT CONTENT    byte[] objectContent = iObject.toStream();    byte[] result = new byte[4 + className.length + objectContent.length];    // COPY THE CLASS NAME SIZE + CLASS NAME + OBJECT CONTENT    System.arraycopy(OBinaryProtocol.int2bytes(className.length), 0, result, 0, 4);    System.arraycopy(className, 0, result, 4, className.length);    System.arraycopy(objectContent, 0, result, 4 + className.length, objectContent.length);    return result;  }
public Object fromStream(final String iStream) {    if (iStream == null || iStream.length() == 0)      // NULL VALUE      return null;    final ODocument instance = new ODocument();    try {      ORecordSerializerSchemaAware2CSV.INSTANCE.fromStream(iStream.getBytes("UTF-8"), instance, null);    } catch (UnsupportedEncodingException e) {      throw OException.wrapException(new OSerializationException("Error decoding string"), e);    }    final String className = instance.field(ODocumentSerializable.CLASS_NAME);    if (className == null)      return instance;    Class<?> clazz = null;    try {      clazz = Class.forName(className);    } catch (ClassNotFoundException e) {      OLogManager.instance().debug(this, "Class name provided in embedded document " + className + " does not exist.", e);    }    if (clazz == null)      return instance;    if (ODocumentSerializable.class.isAssignableFrom(clazz)) {      try {        final ODocumentSerializable documentSerializable = (ODocumentSerializable) clazz.newInstance();        final ODocument docClone = new ODocument();        instance.copyTo(docClone);        docClone.removeField(ODocumentSerializable.CLASS_NAME);        documentSerializable.fromDocument(docClone);        return documentSerializable;      } catch (InstantiationException e) {        throw OException.wrapException(new OSerializationException("Cannot serialize the object"), e);      } catch (IllegalAccessException e) {        throw OException.wrapException(new OSerializationException("Cannot serialize the object"), e);      }    }    return instance;  }
public StringBuilder toStream(final StringBuilder iOutput, Object iValue) {    if (iValue != null) {      if (iValue instanceof ODocumentSerializable)        iValue = ((ODocumentSerializable) iValue).toDocument();      if (!(iValue instanceof OSerializableStream))        throw new OSerializationException(            "Cannot serialize the object since it's not implements the OSerializableStream interface");      OSerializableStream stream = (OSerializableStream) iValue;      iOutput.append(iValue.getClass().getName());      iOutput.append(SEPARATOR);      try {        iOutput.append(new String(stream.toStream(), "UTF-8"));      } catch (UnsupportedEncodingException e) {        throw OException.wrapException(new OSerializationException("Error serializing embedded object"), e);      }    }    return iOutput;  }
private void convert(final Object iKey) {    if (converted)      return;    if (super.containsKey(iKey))      return;    Object o = underlying.get(String.valueOf(iKey));    if (o instanceof Number)      super.put(iKey, enumClass.getEnumConstants()[((Number) o).intValue()]);    else      super.put(iKey, Enum.valueOf(enumClass, o.toString()));  }
protected void convertAll() {    if (converted)      return;    for (java.util.Map.Entry<Object, Object> e : underlying.entrySet()) {      if (e.getValue() instanceof Number)        super.put(e.getKey(), enumClass.getEnumConstants()[((Number) e.getValue()).intValue()]);      else        super.put(e.getKey(), Enum.valueOf(enumClass, e.getValue().toString()));    }    converted = true;  }
@SuppressWarnings("unchecked")  public <T> OBinarySerializer<T> getObjectSerializer(final OType type) {    return (OBinarySerializer<T>) serializerTypeMap.get(type);  }
public void processRequest(final ODistributedRequest request, final boolean waitForAcceptingRequests) {    if (!running) {      throw new ODistributedException("Server is going down or is removing the database:'" + getDatabaseName() + "' discarding");    }    final ORemoteTask task = request.getTask();    if (waitForAcceptingRequests) {      waitIsReady(task);      if (!running) {        throw new ODistributedException("Server is going down or is removing the database:'" + getDatabaseName() + "' discarding");      }    }    totalReceivedRequests.incrementAndGet();    // final ODistributedMomentum lastMomentum = filterByMomentum.get();    // if (lastMomentum != null && task instanceof OAbstractReplicatedTask) {    // final OLogSequenceNumber taskLastLSN = ((OAbstractReplicatedTask) task).getLastLSN();    //    // final String sourceServer = manager.getNodeNameById(request.getId().getNodeId());    // final OLogSequenceNumber lastLSNFromMomentum = lastMomentum.getLSN(sourceServer);    //    // if (taskLastLSN != null && lastLSNFromMomentum != null && taskLastLSN.compareTo(lastLSNFromMomentum) < 0) {    // // SKIP REQUEST BECAUSE CONTAINS AN OLD LSN    // final String msg = String.format("Skipped request %s on database '%s' because %s < current %s", request, databaseName,    // taskLastLSN, lastLSNFromMomentum);    // ODistributedServerLog.info(this, localNodeName, null, DIRECTION.NONE, msg);    // ODistributedWorker.sendResponseBack(this, manager, request, new ODistributedException(msg));    // return;    // }    // }    final int[] partitionKeys = task.getPartitionKey();    if (ODistributedServerLog.isDebugEnabled())      ODistributedServerLog          .debug(this, localNodeName, task.getNodeSource(), DIRECTION.IN, "Request %s on database '%s' partitionKeys=%s task=%s",              request, databaseName, Arrays.toString(partitionKeys), task);    if (partitionKeys.length > 1 || partitionKeys[0] == -1) {      final Set<Integer> involvedWorkerQueues;      if (partitionKeys.length > 1)        involvedWorkerQueues = getInvolvedQueuesByPartitionKeys(partitionKeys);      else        // LOCK ALL THE QUEUES        involvedWorkerQueues = ALL_QUEUES;      // if (ODistributedServerLog.isDebugEnabled())      ODistributedServerLog          .debug(this, localNodeName, null, DIRECTION.NONE, "Request %s on database '%s' involvedQueues=%s", request, databaseName,              involvedWorkerQueues);      if (involvedWorkerQueues.size() == 1)        // JUST ONE QUEUE INVOLVED: PROCESS IT IMMEDIATELY        processRequest(involvedWorkerQueues.iterator().next(), request);      else {        // INVOLVING MULTIPLE QUEUES        // if (ODistributedServerLog.isDebugEnabled())        ODistributedServerLog.debug(this, localNodeName, null, DIRECTION.NONE,            "Request %s on database '%s' waiting for all the previous requests to be completed", request, databaseName);        // WAIT ALL THE INVOLVED QUEUES ARE FREE AND SYNCHRONIZED        final CountDownLatch syncLatch = new CountDownLatch(involvedWorkerQueues.size());        final ODistributedRequest syncRequest = new ODistributedRequest(null, request.getId().getNodeId(), -1, databaseName,            new OSynchronizedTaskWrapper(syncLatch));        for (int queue : involvedWorkerQueues) {          ODistributedWorker worker = workerThreads.get(queue);          worker.processRequest(syncRequest);        }        // Make infinite timeout everytime        long taskTimeout = 0;        try {          if (taskTimeout <= 0)            syncLatch.await();          else {            // WAIT FOR COMPLETION. THE TIMEOUT IS MANAGED IN SMALLER CYCLES TO PROPERLY RECOGNIZE WHEN THE DB IS REMOVED            final long start = System.currentTimeMillis();            final long cycleTimeout = Math.min(taskTimeout, 2000);            boolean locked = false;            do {              if (syncLatch.await(cycleTimeout, TimeUnit.MILLISECONDS)) {                // DONE                locked = true;                break;              }              if (this.workerThreads.size() == 0)                // DATABASE WAS SHUTDOWN                break;            } while (System.currentTimeMillis() - start < taskTimeout);            if (!locked) {              final String msg = String.format(                  "Cannot execute distributed request (%s) because all worker threads (%d) are busy (pending=%d timeout=%d)",                  request, workerThreads.size(), syncLatch.getCount(), taskTimeout);              ODistributedWorker.sendResponseBack(this, manager, request, new ODistributedOperationException(msg));              return;            }          }        } catch (InterruptedException e) {          // IGNORE          Thread.currentThread().interrupt();          final String msg = String              .format("Cannot execute distributed request (%s) because all worker threads (%d) are busy", request,                  workerThreads.size());          ODistributedWorker.sendResponseBack(this, manager, request, new ODistributedOperationException(msg));          return;        }        // PUT THE TASK TO EXECUTE ONLY IN THE FIRST QUEUE AND PUT WAIT-FOR TASKS IN THE OTHERS. WHEN THE REAL TASK IS EXECUTED,        // ALL THE OTHER TASKS WILL RETURN, SO THE QUEUES WILL BE BUSY DURING THE EXECUTION OF THE TASK. THIS AVOID CONCURRENT        // EXECUTION FOR THE SAME PARTITION        final CountDownLatch queueLatch = new CountDownLatch(1);        int i = 0;        for (int queue : involvedWorkerQueues) {          final ODistributedRequest req;          if (i++ == 0) {            // USE THE FIRST QUEUE TO PROCESS THE REQUEST            final String senderNodeName = manager.getNodeNameById(request.getId().getNodeId());            request.setTask(new OSynchronizedTaskWrapper(queueLatch, senderNodeName, task));            req = request;          } else            req = new ODistributedRequest(manager, request.getId().getNodeId(), -1, databaseName, new OWaitForTask(queueLatch));          workerThreads.get(queue).processRequest(req);        }      }    } else if (partitionKeys.length == 1 && partitionKeys[0] == -2) {      // ANY PARTITION: USE THE FIRST EMPTY IF ANY, OTHERWISE THE FIRST IN THE LIST      boolean found = false;      for (ODistributedWorker q : workerThreads) {        if (q.isWaitingForNextRequest() && q.localQueue.isEmpty()) {          q.processRequest(request);          found = true;          break;        }      }      if (!found)        // ALL THE THREADS ARE BUSY, SELECT THE FIRST EMPTY ONE        for (ODistributedWorker q : workerThreads) {          if (q.localQueue.isEmpty()) {            q.processRequest(request);            found = true;            break;          }        }      if (!found)        // EXEC ON THE FIRST QUEUE        workerThreads.get(0).processRequest(request);    } else if (partitionKeys.length == 1 && partitionKeys[0] == -3) {      // SERVICE - LOCK      ODistributedServerLog.debug(this, localNodeName, request.getTask().getNodeSource(), DIRECTION.IN,          "Request %s on database '%s' dispatched to the lock worker", request, databaseName);      lockThread.processRequest(request);    } else if (partitionKeys.length == 1 && partitionKeys[0] == -4) {      // SERVICE - FAST_NOLOCK      ODistributedServerLog.debug(this, localNodeName, request.getTask().getNodeSource(), DIRECTION.IN,          "Request %s on database '%s' dispatched to the nowait worker", request, databaseName);      nowaitThread.processRequest(request);    } else {      processRequest(partitionKeys[0], request);    }  }
public void addShutdownHandler(OShutdownHandler shutdownHandler) {    engineLock.writeLock().lock();    try {      shutdownHandlers.add(shutdownHandler);    } finally {      engineLock.writeLock().unlock();    }  }
private void initShutdownQueue() {    addShutdownHandler(new OShutdownWorkersHandler());    addShutdownHandler(new OShutdownOrientDBInstancesHandler());    addShutdownHandler(new OShutdownPendingThreadsHandler());    addShutdownHandler(new OShutdownProfilerHandler());    addShutdownHandler(new OShutdownCallListenersHandler());  }
private void registerEngines() {    ClassLoader classLoader = Orient.class.getClassLoader();    Iterator<OEngine> engines = OClassLoaderHelper.lookupProviderWithOrientClassLoader(OEngine.class, classLoader);    OEngine engine = null;    while (engines.hasNext()) {      try {        engine = engines.next();        registerEngine(engine);      } catch (IllegalArgumentException e) {        if (engine != null)          OLogManager.instance().debug(this, "Failed to replace engine " + engine.getName(), e);      }    }  }
public OEngine getEngine(final String engineName) {    engineLock.readLock().lock();    try {      return engines.get(engineName);    } finally {      engineLock.readLock().unlock();    }  }
public OEngine getEngineIfRunning(final String engineName) {    engineLock.readLock().lock();    try {      final OEngine engine = engines.get(engineName);      return engine == null || !engine.isRunning() ? null : engine;    } finally {      engineLock.readLock().unlock();    }  }
public OEngine getRunningEngine(final String engineName) {    engineLock.readLock().lock();    try {      OEngine engine = engines.get(engineName);      if (engine == null)        throw new IllegalStateException("Engine '" + engineName + "' is not found.");      if (!engine.isRunning() && !startEngine(engine))        throw new IllegalStateException("Engine '" + engineName + "' is failed to start.");      return engine;    } finally {      engineLock.readLock().unlock();    }  }
@Override public OResultSet executeSimple(OCommandContext ctx) {    OResultInternal result = new OResultInternal();    result.setProperty("operation", "optimize database");    OStorage storage = ((ODatabaseInternal) ctx.getDatabase()).getStorage();    if (on) {      // activate the profiler      ((OAbstractPaginatedStorage) storage).startGatheringPerformanceStatisticForCurrentThread();      result.setProperty("value", "on");    } else {      // stop the profiler and return the stats      final OSessionStoragePerformanceStatistic performanceStatistic = ((OAbstractPaginatedStorage) storage)          .completeGatheringPerformanceStatisticForCurrentThread();      result.setProperty("value", "off");      if (performanceStatistic != null) {        result.setProperty("result", performanceStatistic.toDocument());      } else {        result.setProperty("result", "error");        result.setProperty("errorMessage", "profiling of storage was not started");      }    }    OInternalResultSet rs = new OInternalResultSet();    rs.add(result);    return rs;  }
@Override public Object execute(OSQLAsynchQuery<ODocument> request, OCommandContext context, OProgressListener progressListener) {    try {      ODatabaseDocumentInternal db = getDatabase();      final OStorage storage = db.getStorage();      if (on) {        // activate the profiler        ((OAbstractPaginatedStorage) storage).startGatheringPerformanceStatisticForCurrentThread();        ODocument result = new ODocument();        result.field("result", "OK");        request.getResultListener().result(result);      } else {        // stop the profiler and return the stats        final OSessionStoragePerformanceStatistic performanceStatistic = ((OAbstractPaginatedStorage) storage)            .completeGatheringPerformanceStatisticForCurrentThread();        if (performanceStatistic != null)          request.getResultListener().result(performanceStatistic.toDocument());        else {          ODocument result = new ODocument();          result.field("result", "Error: profiling of storage was not started.");          request.getResultListener().result(result);        }      }      return getResult(request);    } finally {      if (request.getResultListener() != null) {        request.getResultListener().end();      }    }  }
protected void removeState(AtomicInteger state) {    readersStateList.remove(state);    readersStateArrayRef.set(null);    // Paranoia: just in case someone forgot to call sharedUnlock()    // and there is a Writer waiting on that state    state.set(SRWL_STATE_NOT_READING);  }
private ReadersEntry addState() {    final AtomicInteger state = new AtomicInteger(SRWL_STATE_NOT_READING);    final ReadersEntry newEntry = new ReadersEntry(state);    entry.set(newEntry);    readersStateList.add(state);    readersStateArrayRef.set(null);    return newEntry;  }
public void sharedLock() {    ReadersEntry localEntry = entry.get();    // Initialize a new Reader-state for this thread if needed    if (localEntry == null) {      localEntry = addState();    }    final AtomicInteger currentReadersState = localEntry.state;    // The "optimistic" code path takes only two synchronized calls:    // a set() on a cache line that should be held in exclusive mode    // by the current thread, and a get() on a cache line that is shared.    while (true) {      currentReadersState.set(SRWL_STATE_READING);      if (!stampedLock.isWriteLocked()) {        // Acquired lock in read-only mode        return;      } else {        // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer        currentReadersState.set(SRWL_STATE_NOT_READING);        // Some (other) thread is holding the write-lock, we must wait        while (stampedLock.isWriteLocked()) {          Thread.yield();        }      }    }  }
public void sharedUnlock() {    final ReadersEntry localEntry = entry.get();    if (localEntry == null) {      // ERROR: Tried to unlock a non read-locked lock      throw new IllegalMonitorStateException();    } else {      localEntry.state.set(SRWL_STATE_NOT_READING);      return;    }  }
public void exclusiveLock() {    // Try to acquire the lock in write-mode    stampedLock.writeLock();    // We can only do this after writerOwner has been set to the current thread    AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();    if (localReadersStateArray == null) {      // Set to dummyArray before scanning the readersStateList to impose      // a linearizability condition      readersStateArrayRef.set(dummyArray);      // Copy readersStateList to an array      localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);      readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);    }    // Scan the array of Reader states    for (AtomicInteger readerState : localReadersStateArray) {      while (readerState != null && readerState.get() == SRWL_STATE_READING) {        Thread.yield();      }    }  }
public boolean sharedTryLock() {    ReadersEntry localEntry = entry.get();    // Initialize a new Reader-state for this thread if needed    if (localEntry == null) {      localEntry = addState();    }    final AtomicInteger currentReadersState = localEntry.state;    currentReadersState.set(SRWL_STATE_READING);    if (!stampedLock.isWriteLocked()) {      // Acquired lock in read-only mode      return true;    } else {      // Go back to SRWL_STATE_NOT_READING and quit      currentReadersState.set(SRWL_STATE_NOT_READING);      return false;    }  }
public boolean sharedTryLockNanos(long nanosTimeout) {    final long lastTime = System.nanoTime();    ReadersEntry localEntry = entry.get();    // Initialize a new Reader-state for this thread if needed    if (localEntry == null) {      localEntry = addState();    }    final AtomicInteger currentReadersState = localEntry.state;    while (true) {      currentReadersState.set(SRWL_STATE_READING);      if (!stampedLock.isWriteLocked()) {        // Acquired lock in read-only mode        return true;      } else {        // Go back to SRWL_STATE_NOT_READING to avoid blocking a Writer        // and then check if this is a downgrade.        currentReadersState.set(SRWL_STATE_NOT_READING);        if (nanosTimeout <= 0)          return false;        if (System.nanoTime() - lastTime < nanosTimeout) {          Thread.yield();        } else {          return false;        }      }    }  }
public boolean exclusiveTryLock() {    // Try to acquire the lock in write-mode    if (stampedLock.tryWriteLock() == 0) {      return false;    }    // We can only do this after writerOwner has been set to the current thread    AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();    if (localReadersStateArray == null) {      // Set to dummyArray before scanning the readersStateList to impose      // a linearizability condition      readersStateArrayRef.set(dummyArray);      // Copy readersStateList to an array      localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);      readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);    }    // Scan the array of Reader states    for (AtomicInteger readerState : localReadersStateArray) {      if (readerState != null && readerState.get() == SRWL_STATE_READING) {        // There is at least one ongoing Reader so give up        stampedLock.asWriteLock().unlock();        return false;      }    }    return true;  }
public boolean exclusiveTryLockNanos(long nanosTimeout) throws InterruptedException {    final long lastTime = System.nanoTime();    // Try to acquire the lock in write-mode    if (stampedLock.tryWriteLock(nanosTimeout, TimeUnit.NANOSECONDS) == 0) {      return false;    }    // We can only do this after writerOwner has been set to the current thread    AtomicInteger[] localReadersStateArray = readersStateArrayRef.get();    if (localReadersStateArray == null) {      // Set to dummyArray before scanning the readersStateList to impose      // a linearizability condition      readersStateArrayRef.set(dummyArray);      // Copy readersStateList to an array      localReadersStateArray = readersStateList.toArray(new AtomicInteger[readersStateList.size()]);      readersStateArrayRef.compareAndSet(dummyArray, localReadersStateArray);    }    // Scan the array of Reader states    for (AtomicInteger readerState : localReadersStateArray) {      while (readerState != null && readerState.get() == SRWL_STATE_READING) {        if (System.nanoTime() - lastTime < nanosTimeout) {          Thread.yield();        } else {          // Time has expired and there is at least one ongoing Reader so give up          stampedLock.asWriteLock().unlock();          return false;        }      }    }    return true;  }
public OUser authenticate(final OToken authToken) {    final String dbName = getDatabase().getName();    if (authToken.getIsValid() != true) {      throw new OSecurityAccessException(dbName, "Token not valid");    }    OUser user = authToken.getUser(getDatabase());    if (user == null && authToken.getUserName() != null) {      // Token handler may not support returning an OUser so let's get username (subject) and query:      user = getUser(authToken.getUserName());    }    if (user == null) {      throw new OSecurityAccessException(dbName, "Authentication failed, could not load user from token");    }    if (user.getAccountStatus() != STATUSES.ACTIVE)      throw new OSecurityAccessException(dbName, "User '" + user.getName() + "' is not active");    return user;  }
public OUser createMetadata() {    final ODatabaseDocument database = getDatabase();    OClass identityClass = database.getMetadata().getSchema().getClass(OIdentity.CLASS_NAME); // SINCE 1.2.0    if (identityClass == null)      identityClass = database.getMetadata().getSchema().createAbstractClass(OIdentity.CLASS_NAME);    OClass roleClass = createOrUpdateORoleClass(database, identityClass);    createOrUpdateOUserClass(database, identityClass, roleClass);    // CREATE ROLES AND USERS    ORole adminRole = getRole(ORole.ADMIN);    if (adminRole == null) {      adminRole = createRole(ORole.ADMIN, ORole.ALLOW_MODES.ALLOW_ALL_BUT);      adminRole.addRule(ORule.ResourceGeneric.BYPASS_RESTRICTED, null, ORole.PERMISSION_ALL).save();    }    OUser adminUser = getUser(OUser.ADMIN);    if (adminUser == null) {      // This will return the global value if a local storage context configuration value does not exist.      boolean createDefUsers = getDatabase().getStorage().getConfiguration().getContextConfiguration()          .getValueAsBoolean(OGlobalConfiguration.CREATE_DEFAULT_USERS);      if (createDefUsers) {        adminUser = createUser(OUser.ADMIN, OUser.ADMIN, adminRole);      }    }    // SINCE 1.2.0    createOrUpdateORestrictedClass(database);    return adminUser;  }
public List<OIdentifiable> execute() {    final List<OIdentifiable> result = new ArrayList<OIdentifiable>();    while (hasNext())      result.add(next());    return result;  }
public static void dumpHeap(String fileName, boolean live) {    try {      MBeanServer server = ManagementFactory.getPlatformMBeanServer();      server.invoke(new ObjectName(HOTSPOT_BEAN_NAME),          "dumpHeap",          new Object[]{fileName, live},          new String[]{String.class.getName(), Boolean.TYPE.getName()}      );    } catch (RuntimeException re) {      throw re;    } catch (Exception exp) {      throw new RuntimeException(exp);    }  }
public boolean tryAcquireReadLock(long timeout) {    final OModifiableInteger lHolds = lockHolds.get();    final int holds = lHolds.intValue();    if (holds > 0) {      // we have already acquire read lock      lHolds.increment();      return true;    } else if (holds < 0) {      // write lock is acquired before, do nothing      return true;    }    distributedCounter.increment();    WNode wNode = tail.get();    final long start = System.nanoTime();    while (wNode.locked) {      distributedCounter.decrement();      while (wNode.locked && wNode == tail.get()) {        wNode.waitingReaders.put(Thread.currentThread(), Boolean.TRUE);        if (wNode.locked && wNode == tail.get()) {          final long parkTimeout = timeout - (System.nanoTime() - start);          if (parkTimeout > 0) {            LockSupport.parkNanos(this, parkTimeout);          } else {            return false;          }        }        wNode = tail.get();        if (System.nanoTime() - start > timeout) {          return false;        }      }      distributedCounter.increment();      wNode = tail.get();      if (System.nanoTime() - start > timeout) {        distributedCounter.decrement();        return false;      }    }    lHolds.increment();    assert lHolds.intValue() == 1;    return true;  }
public static boolean isLabeled(final String iEdgeLabel, final String[] iLabels) {    if (iLabels != null && iLabels.length > 0) {      // FILTER LABEL      if (iEdgeLabel != null)        for (String l : iLabels)          if (l.equals(iEdgeLabel))            // FOUND            return true;      // NOT FOUND      return false;    }    // NO LABELS    return true;  }
public static String getRecordLabel(final OIdentifiable iEdge) {    if (iEdge == null)      return null;    final ODocument edge = iEdge.getRecord();    if (edge == null)      return null;    return edge.field(OrientElement.LABEL_FIELD_NAME);  }
private static void removeLightweightConnection(final ODocument iVertex, final String iFieldName,      final OIdentifiable iVertexToRemove) {    if (iVertex == null || iVertexToRemove == null)      return;    final Object fieldValue = iVertex.field(iFieldName);    if (fieldValue instanceof OIdentifiable) {      if (fieldValue.equals(iVertexToRemove)) {        iVertex.removeField(iFieldName);      }    } else if (fieldValue instanceof ORidBag) {      ((ORidBag) fieldValue).remove(iVertexToRemove);    }  }
@Override  public OrientVertex getVertex(final Direction direction) {    final OrientBaseGraph graph = setCurrentGraphInThreadLocal();    if (direction.equals(Direction.OUT))      return graph.getVertex(getOutVertex());    else if (direction.equals(Direction.IN))      return graph.getVertex(getInVertex());    else      throw ExceptionFactory.bothIsNotSupported();  }
public OIdentifiable getOutVertex() {    if (vOut != null)      // LIGHTWEIGHT EDGE      return vOut;    setCurrentGraphInThreadLocal();    final ODocument doc = getRecord();    if (doc == null)      return null;    if (settings != null && settings.isKeepInMemoryReferences())      // AVOID LAZY RESOLVING+SETTING OF RECORD      return doc.rawField(OrientBaseGraph.CONNECTION_OUT);    else      return doc.field(OrientBaseGraph.CONNECTION_OUT);  }
public OIdentifiable getInVertex() {    if (vIn != null)      // LIGHTWEIGHT EDGE      return vIn;    setCurrentGraphInThreadLocal();    final ODocument doc = getRecord();    if (doc == null)      return null;    if (settings != null && settings.isKeepInMemoryReferences())      // AVOID LAZY RESOLVING+SETTING OF RECORD      return doc.rawField(OrientBaseGraph.CONNECTION_IN);    else      return doc.field(OrientBaseGraph.CONNECTION_IN);  }
@Override  public String getLabel() {    if (label != null)      // LIGHTWEIGHT EDGE      return label;    else if (rawElement != null) {      if (settings != null && settings.isUseClassForEdgeLabel()) {        final String clsName = getRecord().getClassName();        if (!OrientEdgeType.CLASS_NAME.equals(clsName))          // RETURN THE CLASS NAME          return OrientBaseGraph.decodeClassName(clsName);      }      setCurrentGraphInThreadLocal();      final ODocument doc = rawElement.getRecord();      if (doc == null)        return null;      final String label = doc.field(OrientElement.LABEL_FIELD_NAME);      if (label != null)        return OrientBaseGraph.decodeClassName(label);    }    return null;  }
@Override  public Object getId() {    if (rawElement == null)      // CREATE A TEMPORARY ID      return vOut.getIdentity() + "->" + vIn.getIdentity();    setCurrentGraphInThreadLocal();    return super.getId();  }
@Override  public <T> T getProperty(final String key) {    setCurrentGraphInThreadLocal();    if (rawElement == null)      // LIGHTWEIGHT EDGE      return null;    return super.getProperty(key);  }
@Override  public Set<String> getPropertyKeys() {    if (rawElement == null)      // LIGHTWEIGHT EDGE      return Collections.emptySet();    setCurrentGraphInThreadLocal();    final Set<String> result = new HashSet<String>();    for (String field : getRecord().fieldNames())      if (!field.equals(OrientBaseGraph.CONNECTION_OUT) && !field.equals(OrientBaseGraph.CONNECTION_IN) && (          settings.isUseClassForEdgeLabel() || !field.equals(OrientElement.LABEL_FIELD_NAME)))        result.add(field);    return result;  }
@Override  public void setProperty(final String key, final Object value) {    setCurrentGraphInThreadLocal();    if (rawElement == null)      // LIGHTWEIGHT EDGE      convertToDocument();    super.setProperty(key, value);  }
@Override  public <T> T removeProperty(String key) {    setCurrentGraphInThreadLocal();    if (rawElement != null)      // NON LIGHTWEIGHT EDGE      return super.removeProperty(key);    return null;  }
@Override  public void remove() {    final OrientBaseGraph graph = getGraph();    if (!isLightweight())      checkClass();    graph.setCurrentGraphInThreadLocal();    graph.autoStartTransaction();    for (final Index<? extends Element> index : graph.getIndices()) {      if (Edge.class.isAssignableFrom(index.getIndexClass())) {        OrientIndex<OrientEdge> idx = (OrientIndex<OrientEdge>) index;        idx.removeElement(this);      }    }    if (graph != null)      graph.removeEdgeInternal(this);    else      // IN MEMORY CHANGES ONLY: USE NOTX CLASS      OrientGraphNoTx.removeEdgeInternal(null, this);  }
@Override  public ODocument getRecord() {    if (rawElement == null) {      // CREATE AT THE FLY      final ODocument tmp = new ODocument(getClassName(label)).setTrackingChanges(false);      tmp.field(OrientBaseGraph.CONNECTION_IN, vIn.getIdentity());      tmp.field(OrientBaseGraph.CONNECTION_OUT, vOut.getIdentity());      if (label != null && settings != null && !settings.isUseClassForEdgeLabel())        tmp.field(OrientEdge.LABEL_FIELD_NAME, label);      return tmp;    }    return super.getRecord();  }
public void convertToDocument() {    final OrientBaseGraph graph = checkIfAttached();    if (rawElement != null)      // ALREADY CONVERTED      return;    graph.setCurrentGraphInThreadLocal();    graph.autoStartTransaction();    final ODocument vOutRecord = vOut.getRecord();    final ODocument vInRecord = vIn.getRecord();    final ODocument doc = createDocument(label);    doc.field(OrientBaseGraph.CONNECTION_OUT, settings.isKeepInMemoryReferences() ? vOutRecord.getIdentity() : vOutRecord);    doc.field(OrientBaseGraph.CONNECTION_IN, settings.isKeepInMemoryReferences() ? vInRecord.getIdentity() : vInRecord);    rawElement = doc;    final boolean useVertexFieldsForEdgeLabels = settings.isUseVertexFieldsForEdgeLabels();    final String outFieldName = OrientVertex.getConnectionFieldName(Direction.OUT, label, useVertexFieldsForEdgeLabels);    removeLightweightConnection(vOutRecord, outFieldName, vInRecord);    // OUT-VERTEX ---> IN-VERTEX/EDGE    OrientVertex.createLink(graph, vOutRecord, doc, outFieldName);    vOutRecord.save();    final String inFieldName = OrientVertex.getConnectionFieldName(Direction.IN, label, useVertexFieldsForEdgeLabels);    removeLightweightConnection(vInRecord, inFieldName, vOutRecord);    // IN-VERTEX ---> OUT-VERTEX/EDGE    OrientVertex.createLink(graph, vInRecord, doc, inFieldName);    vInRecord.save();    vOut = null;    vIn = null;    label = null;  }
public String getClassName(final String iLabel) {    if (iLabel != null && (settings == null || settings.isUseClassForEdgeLabel()))      // USE THE LABEL AS DOCUMENT CLASS      return checkForClassInSchema(iLabel);    return OrientEdgeType.CLASS_NAME;  }
public Object execute(final Map<Object, Object> iArgs) {    if (attribute == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocumentInternal database = getDatabase();    database.checkSecurity(ORule.ResourceGeneric.DATABASE, ORole.PERMISSION_UPDATE);    database.setInternal(attribute, value);    return null;  }
@Override  public void serializeInByteBufferObject(Date object, ByteBuffer buffer, Object... hints) {    final Calendar calendar = Calendar.getInstance();    calendar.setTime(object);    buffer.putLong(calendar.getTimeInMillis());  }
@Override  public Date deserializeFromByteBufferObject(ByteBuffer buffer) {    final Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(buffer.getLong());    return calendar.getTime();  }
@Override  public Date deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final Calendar calendar = Calendar.getInstance();    calendar.setTimeInMillis(walChanges.getLongValue(buffer, offset));    return calendar.getTime();  }
public Object execute(final Map<Object, Object> iArgs) {    final ODatabaseDocumentInternal database = getDatabase();    database.checkSecurity(ORule.ResourceGeneric.SERVER, "remove", ORole.PERMISSION_EXECUTE);    if (!(database instanceof ODatabaseDocumentDistributed)) {      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    }    final OHazelcastPlugin dManager = (OHazelcastPlugin) ((ODatabaseDocumentDistributed) database).getDistributedManager();    if (dManager == null || !dManager.isEnabled())      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    final String databaseName = database.getName();    // The last parameter (true) indicates to set the node's database status to OFFLINE.    // If this is changed to false, the node will be set to NOT_AVAILABLE, and then the auto-repairer will    // re-synchronize the database on the node, and then set it to ONLINE.    return dManager.removeNodeFromConfiguration(parsedStatement.serverName.getStringValue(), databaseName, false, true);  }
@Override  public void clear() throws IOException {    boolean rollback = false;    final OAtomicOperation atomicOperation = startAtomicOperation(true);    try {      final Lock lock = FILE_LOCK_MANAGER.acquireExclusiveLock(fileId);      try {        final Queue<OBonsaiBucketPointer> subTreesToDelete = new LinkedList<>();        final OCacheEntry cacheEntry = loadPageForWrite(atomicOperation, fileId, rootBucketPointer.getPageIndex(), false, true);        try {          OSBTreeBonsaiBucket<K, V> rootBucket = new OSBTreeBonsaiBucket<>(cacheEntry, rootBucketPointer.getPageOffset(),              keySerializer, valueSerializer, this);          addChildrenToQueue(subTreesToDelete, rootBucket);          rootBucket.shrink(0);          rootBucket = new OSBTreeBonsaiBucket<>(cacheEntry, rootBucketPointer.getPageOffset(), true, keySerializer,              valueSerializer, this);          rootBucket.setTreeSize(0);        } finally {          releasePageFromWrite(atomicOperation, cacheEntry);        }        recycleSubTrees(subTreesToDelete, atomicOperation);      } finally {        lock.unlock();      }    } catch (final Exception e) {      rollback = true;      throw e;    } finally {      endAtomicOperation(rollback);    }  }
@Override  public void delete() throws IOException {    boolean rollback = false;    final OAtomicOperation atomicOperation = startAtomicOperation(false);    try {      final Lock lock = FILE_LOCK_MANAGER.acquireExclusiveLock(fileId);      try {        final Queue<OBonsaiBucketPointer> subTreesToDelete = new LinkedList<>();        subTreesToDelete.add(rootBucketPointer);        recycleSubTrees(subTreesToDelete, atomicOperation);      } finally {        lock.unlock();      }    } catch (final Exception e) {      rollback = true;      throw e;    } finally {      endAtomicOperation(rollback);    }  }
public void begin() {    walActive =  OGlobalConfiguration.USE_WAL.getValueAsBoolean();    if (walActive)      OGlobalConfiguration.USE_WAL.setValue(false);    if (averageEdgeNumberPerNode > 0) {      OGlobalConfiguration.RID_BAG_EMBEDDED_DEFAULT_SIZE.setValue(averageEdgeNumberPerNode);      OGlobalConfiguration.RID_BAG_EMBEDDED_TO_SBTREEBONSAI_THRESHOLD.setValue(bonsaiThreshold);    }    db = new ODatabaseDocumentTx(dbUrl);    if (db.exists()) {      db.open(userName, password);    } else {      db.create();    }    createBaseSchema();    out = estimatedEntries > 0 ? new HashMap<Long, List<Long>>(estimatedEntries) : new HashMap<Long, List<Long>>();    in = estimatedEntries > 0 ? new HashMap<Long, List<Long>>(estimatedEntries) : new HashMap<Long, List<Long>>();    OClass vClass = db.getMetadata().getSchema().getClass(this.vertexClass);    int[] existingClusters = vClass.getClusterIds();    for (int c = existingClusters.length; c <= parallel; c++) {      vClass.addCluster(vClass.getName() + "_" + c);    }    clusterIds = vClass.getClusterIds();    lastClusterPositions = new long[clusterIds.length];    for (int i = 0; i < clusterIds.length; i++) {      int clusterId = clusterIds[i];      try {        lastClusterPositions[i] = db.getStorage().getClusterById(clusterId).getLastPosition();      } catch (Exception e) {        throw new RuntimeException(e);      }    }  }
public void end() {    final OClass vClass = db.getMetadata().getSchema().getClass(vertexClass);    try {      runningThreads = new AtomicInteger(parallel);      for (int i = 0; i < parallel - 1; i++) {        Thread t = new BatchImporterJob(i, vClass);        t.start();      }      Thread t = new BatchImporterJob(parallel - 1, vClass);      t.run();      if (runningThreads.get() > 0) {        synchronized (runningThreads) {          while (runningThreads.get() > 0) {            try {              runningThreads.wait();            } catch (InterruptedException e) {            }          }        }      }    } finally {      db.activateOnCurrentThread();      db.declareIntent(null);      db.close();      if (walActive)        OGlobalConfiguration.USE_WAL.setValue(true);    }  }
public void createVertex(final Long v) {    last = last < v ? v : last;    final List<Long> outList = out.get(v);    if (outList == null) {      out.put(v, new ArrayList<Long>(averageEdgeNumberPerNode <= 0 ? 4 : averageEdgeNumberPerNode));    }  }
public void createEdge(final Long from, final Long to) {    if (from < 0) {      throw new IllegalArgumentException(" Invalid vertex id: " + from);    }    if (to < 0) {      throw new IllegalArgumentException(" Invalid vertex id: " + to);    }    last = last < from ? from : last;    last = last < to ? to : last;    putInList(from, out, to);    putInList(to, in, from);  }
public Object execute(final Map<Object, Object> iArgs) {    if (rid == null && query == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    if (!returning.equalsIgnoreCase("COUNT"))      allDeletedRecords = new ArrayList<ORecord>();    txAlreadyBegun = getDatabase().getTransaction().isActive();    ODatabaseDocumentInternal db = getDatabase();    if (rid != null) {      // REMOVE PUNCTUAL RID      db.begin();      final OVertex v = toVertex(rid);      if (v != null) {        v.delete();        removed = 1;      }      db.commit();    } else if (query != null) {      // TARGET IS A CLASS + OPTIONAL CONDITION      db.begin();      // TARGET IS A CLASS + OPTIONAL CONDITION      query.setContext(getContext());      query.execute(iArgs);      db.commit();    } else      throw new OCommandExecutionException("Invalid target");    if (returning.equalsIgnoreCase("COUNT"))      // RETURNS ONLY THE COUNT      return removed;    else      // RETURNS ALL THE DELETED RECORDS      return allDeletedRecords;  }
public boolean result(final Object iRecord) {    final OIdentifiable id = (OIdentifiable) iRecord;    if (id.getIdentity().isValid()) {      final ODocument record = id.getRecord();      ODatabaseDocumentInternal db = getDatabase();      final OVertex v = toVertex(record);      if (v != null) {        v.delete();        if (!txAlreadyBegun && batch > 0 && removed % batch == 0) {          db.commit();          db.begin();        }        if (returning.equalsIgnoreCase("BEFORE"))          allDeletedRecords.add(record);        removed++;      }    }    return true;  }
public OCommandExecutorSQLTraverse parse(final OCommandRequest iRequest) {    final OCommandRequestText textRequest = (OCommandRequestText) iRequest;    String queryText = textRequest.getText();    String originalQuery = queryText;    try {      // System.out.println("NEW PARSER FROM: " + queryText);      queryText = preParse(queryText, iRequest);      // System.out.println("NEW PARSER TO: " + queryText);      textRequest.setText(queryText);      super.parse(iRequest);      final int pos = parseFields();      if (pos == -1)        throw new OCommandSQLParsingException("Traverse must have the field list. Use " + getSyntax());      parserSetCurrentPosition(pos);      int endPosition = parserText.length();      parsedTarget = OSQLEngine.getInstance().parseTarget(parserText.substring(pos, endPosition), getContext());      if (parsedTarget.parserIsEnded())        parserSetCurrentPosition(endPosition);      else        parserMoveCurrentPosition(parsedTarget.parserGetCurrentPosition());      if (!parserIsEnded()) {        parserNextWord(true);        if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE))          // // TODO Remove the additional management of WHERE for TRAVERSE after a while          warnDeprecatedWhere();        if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE) || parserGetLastWord().equalsIgnoreCase(KEYWORD_WHILE)) {          compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition(), endPosition),              getContext(), KEYWORD_WHILE);          traverse.predicate(compiledFilter);          optimize();          parserSetCurrentPosition(compiledFilter.parserIsEnded() ? endPosition              : compiledFilter.parserGetCurrentPosition() + parserGetCurrentPosition());        } else          parserGoBack();      }      parserSkipWhiteSpaces();      while (!parserIsEnded()) {        if (parserOptionalKeyword(KEYWORD_LIMIT, KEYWORD_SKIP, KEYWORD_OFFSET, KEYWORD_TIMEOUT, KEYWORD_MAXDEPTH,            KEYWORD_STRATEGY)) {          final String w = parserGetLastWord();          if (w.equals(KEYWORD_LIMIT))            parseLimit(w);          else if (w.equals(KEYWORD_SKIP) || w.equals(KEYWORD_OFFSET))            parseSkip(w);          else if (w.equals(KEYWORD_TIMEOUT))            parseTimeout(w);          else if (w.equals(KEYWORD_MAXDEPTH))            parseMaxDepth(w);          else if (w.equals(KEYWORD_STRATEGY))            parseStrategy(w);        }      }      if (limit == 0 || limit < -1)        throw new IllegalArgumentException("Limit must be > 0 or = -1 (no limit)");      else        traverse.limit(limit);      traverse.getContext().setParent(iRequest.getContext());    } finally {      textRequest.setText(originalQuery);    }    return this;  }
protected boolean parseStrategy(final String w) throws OCommandSQLParsingException {    if (!w.equals(KEYWORD_STRATEGY))      return false;    final String strategyWord = parserNextWord(true);    try {      traverse.setStrategy(OTraverse.STRATEGY.valueOf(strategyWord.toUpperCase(Locale.ENGLISH)));    } catch (IllegalArgumentException ignore) {      throwParsingException("Invalid " + KEYWORD_STRATEGY + ". Use one between " + Arrays.toString(OTraverse.STRATEGY.values()));    }    return true;  }
@Override  public void serializeInByteBufferObject(byte[] object, ByteBuffer buffer, Object... hints) {    final int len = object.length;    buffer.putInt(len);    buffer.put(object);  }
@Override  public byte[] deserializeFromByteBufferObject(ByteBuffer buffer) {    final int len = buffer.getInt();    final byte[] result = new byte[len];    buffer.get(result);    return result;  }
@Override  public byte[] deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    final int len = walChanges.getIntValue(buffer, offset);    offset += OIntegerSerializer.INT_SIZE;    return walChanges.getBinaryValue(buffer, offset, len);  }
@Override  public int getObjectSizeInByteBuffer(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return walChanges.getIntValue(buffer, offset) + OIntegerSerializer.INT_SIZE;  }
private List<RecordInfo> getPositionsFromEmbeddedCollection(final BytesContainer bytes, int serializerVersion) {    List<RecordInfo> retList = new ArrayList<>();    int numberOfElements = OVarIntSerializer.readAsInteger(bytes);    //read collection type    readByte(bytes);    for (int i = 0; i < numberOfElements; i++) {      //read element      //read data type            OType dataType = readOType(bytes, false);      int fieldStart = bytes.offset;            RecordInfo fieldInfo = new RecordInfo();      fieldInfo.fieldStartOffset = fieldStart;      fieldInfo.fieldType = dataType;      //TODO find better way to skip data bytes;      deserializeValue(bytes, dataType, null, true, -1, serializerVersion, true);      fieldInfo.fieldLength = bytes.offset - fieldStart;      retList.add(fieldInfo);    }    return retList;  }
public Object execute(final Map<Object, Object> iArgs) {    if (newRecords == null && content == null && subQuery == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final OCommandParameters commandParameters = new OCommandParameters(iArgs);    if (indexName != null) {      if (newRecords == null)        throw new OCommandExecutionException("No key/value found");      final OIndex<?> index = getDatabase().getMetadata().getIndexManager().getIndex(indexName);      if (index == null)        throw new OCommandExecutionException("Target index '" + indexName + "' not found");      // BIND VALUES      Map<String, Object> result = new HashMap<String, Object>();      for (Map<String, Object> candidate : newRecords) {        Object indexKey = getIndexKeyValue(commandParameters, candidate);        OIdentifiable indexValue = getIndexValue(commandParameters, candidate);        if (index instanceof OIndexMultiValues) {          final Collection<ORID> rids = ((OIndexMultiValues) index).get(indexKey);          if (!rids.contains(indexValue.getIdentity())) {            index.put(indexKey, indexValue);          }        } else {          index.put(indexKey, indexValue);        }        result.put(KEYWORD_KEY, indexKey);        result.put(KEYWORD_RID, indexValue);      }      // RETURN LAST ENTRY      return prepareReturnItem(new ODocument(result));    } else {      // CREATE NEW DOCUMENTS      final List<ODocument> docs = new ArrayList<ODocument>();      if (newRecords != null) {        for (Map<String, Object> candidate : newRecords) {          final ODocument doc = className != null ? new ODocument(className) : new ODocument();          OSQLHelper.bindParameters(doc, candidate, commandParameters, context);          saveRecord(doc);          docs.add(doc);        }        if (docs.size() == 1)          return prepareReturnItem(docs.get(0));        else          return prepareReturnResult(docs);      } else if (content != null) {        final ODocument doc = className != null ? new ODocument(className) : new ODocument();        doc.merge(content, true, false);        saveRecord(doc);        return prepareReturnItem(doc);      } else if (subQuery != null) {        subQuery.execute();        if (queryResult != null)          return prepareReturnResult(queryResult);        return saved.longValue();      }    }    return null;  }
protected boolean fixLink(final Object fieldValue) {    if (fieldValue instanceof OIdentifiable) {      final ORID id = ((OIdentifiable) fieldValue).getIdentity();      if (id.getClusterId() == 0 && id.getClusterPosition() == 0)        return true;      if (id.isValid())        if (id.isPersistent()) {          final ORecord connected = ((OIdentifiable) fieldValue).getRecord();          if (connected == null)            return true;        } else          return true;    }    return false;  }
public static PersistenceUnitTransactionType initTransactionType(String elementContent) {		if (elementContent == null || elementContent.isEmpty()) {			return null;		}		try {			return PersistenceUnitTransactionType.valueOf(elementContent.toUpperCase(Locale.ENGLISH));		} catch (IllegalArgumentException ex) {			throw new PersistenceException("Unknown TransactionType: " + elementContent, ex);		}	}
public Object execute(final Map<Object, Object> iArgs) {    if (name == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocument database = getDatabase();    if (name.equals("*")) {      long totalIndexed = 0;      for (OIndex<?> idx : database.getMetadata().getIndexManager().getIndexes()) {        if (idx.isAutomatic())          totalIndexed += idx.rebuild();      }      return totalIndexed;    } else {      final OIndex<?> idx = database.getMetadata().getIndexManager().getIndex(name);      if (idx == null)        throw new OCommandExecutionException("Index '" + name + "' not found");      if (!idx.isAutomatic())        throw new OCommandExecutionException("Cannot rebuild index '" + name            + "' because it's manual and there aren't indications of what to index");      return idx.rebuild();    }  }
public void intercept(final String url, final String username, final String password) throws OSecurityException {    if (username == null || username.isEmpty())      throw new OSecurityException("OSymmetricKeyCI username is not valid!");    if (password == null || password.isEmpty())      throw new OSecurityException("OSymmetricKeyCI password is not valid!");    this.username = username;    // These are all used as defaults if the JSON document is missing any fields.    // Defaults to "AES".    String algorithm = OGlobalConfiguration.CLIENT_CI_KEYALGORITHM.getValueAsString();    // Defaults to "AES/CBC/PKCS5Padding".    String transform = OGlobalConfiguration.CLIENT_CI_CIPHERTRANSFORM.getValueAsString();    String keystoreFile = OGlobalConfiguration.CLIENT_CI_KEYSTORE_FILE.getValueAsString();    String keystorePassword = OGlobalConfiguration.CLIENT_CI_KEYSTORE_PASSWORD.getValueAsString();    ODocument jsonDoc = null;    try {      jsonDoc = new ODocument().fromJSON(password, "noMap");    } catch (Exception ex) {      throw OException.wrapException(new OSecurityException("OSymmetricKeyCI.intercept() Exception: " + ex.getMessage()), ex);    }    // Override algorithm and transform, if they exist in the JSON document.    if (jsonDoc.containsField("algorithm"))      algorithm = jsonDoc.field("algorithm");    if (jsonDoc.containsField("transform"))      transform = jsonDoc.field("transform");    // Just in case the default configuration gets changed, check it.    if (transform == null || transform.isEmpty())      throw new OSecurityException("OSymmetricKeyCI.intercept() cipher transformation is required");    // If the algorithm is not set, either as a default in the global configuration or in the JSON document,    // then determine the algorithm from the cipher transformation.    if (algorithm == null)      algorithm = OSymmetricKey.separateAlgorithm(transform);    OSymmetricKey key = null;    // "key" has priority over "keyFile" and "keyStore".    if (jsonDoc.containsField("key")) {      final String base64Key = jsonDoc.field("key");      key = OSymmetricKey.fromString(algorithm, base64Key);      key.setDefaultCipherTransform(transform);    } else // "keyFile" has priority over "keyStore".      if (jsonDoc.containsField("keyFile")) {        key = OSymmetricKey.fromFile(algorithm, (String) jsonDoc.field("keyFile"));        key.setDefaultCipherTransform(transform);      } else if (jsonDoc.containsField("keyStore")) {        ODocument ksDoc = jsonDoc.field("keyStore");        if (ksDoc.containsField("file"))          keystoreFile = ksDoc.field("file");        if (keystoreFile == null || keystoreFile.isEmpty())          throw new OSecurityException("OSymmetricKeyCI.intercept() keystore file is required");        // Specific to Keystore, but override if present in the JSON document.        if (ksDoc.containsField("password"))          keystorePassword = ksDoc.field("password");        String keyAlias = ksDoc.field("keyAlias");        if (keyAlias == null || keyAlias.isEmpty())          throw new OSecurityException("OSymmetricKeyCI.intercept() keystore key alias is required");        // keyPassword may be null.        String keyPassword = ksDoc.field("keyPassword");        // keystorePassword may be null.        key = OSymmetricKey.fromKeystore(keystoreFile, keystorePassword, keyAlias, keyPassword);        key.setDefaultCipherTransform(transform);      } else {        throw new OSecurityException("OSymmetricKeyCI.intercept() No suitable symmetric key property exists");      }    // This should never happen, but...    if (key == null)      throw new OSecurityException("OSymmetricKeyCI.intercept() OSymmetricKey is null");    encodedJSON = key.encrypt(transform, username);  }
public static ORecordAbstract fill(final ORecord record, final ORID iRid, final int iVersion, final byte[] iBuffer,      final boolean iDirty) {    final ORecordAbstract rec = (ORecordAbstract) record;    rec.fill(iRid, iVersion, iBuffer, iDirty);    return rec;  }
public static ORecordAbstract setIdentity(final ORecord record, final int iClusterId, final long iClusterPosition) {    final ORecordAbstract rec = (ORecordAbstract) record;    rec.setIdentity(iClusterId, iClusterPosition);    return rec;  }
public static ORecordAbstract setIdentity(final ORecord record, final ORecordId iIdentity) {    final ORecordAbstract rec = (ORecordAbstract) record;    rec.setIdentity(iIdentity);    return rec;  }
public static void setVersion(final ORecord record, final int iVersion) {    final ORecordAbstract rec = (ORecordAbstract) record;    rec.setVersion(iVersion);  }
public static byte getRecordType(final ORecord record) {    if (record instanceof ORecordAbstract) {      return ((ORecordAbstract) record).getRecordType();    }    final ORecordAbstract rec = (ORecordAbstract) record.getRecord();    return rec.getRecordType();  }
public void initDatabaseInstance() {    if (database == null) {      for (int retry = 0; retry < 100; ++retry) {        try {          database = distributed.getDatabaseInstance();          // OK          break;        } catch (OStorageException e) {          // WAIT FOR A WHILE, THEN RETRY          if (!dbNotAvailable(retry))            return;        } catch (OConfigurationException e) {          // WAIT FOR A WHILE, THEN RETRY          if (!dbNotAvailable(retry))            return;        }      }      if (database == null) {        ODistributedServerLog.info(this, manager.getLocalNodeName(), null, DIRECTION.NONE,            "Database '%s' not present, shutting down database manager", databaseName);        distributed.shutdown();        throw new ODistributedException("Cannot open database '" + databaseName + "'");      }    } else if (database.isClosed()) {      // DATABASE CLOSED, REOPEN IT      database.activateOnCurrentThread();      database.close();      database = distributed.getDatabaseInstance();    }  }
protected void onMessage(final ODistributedRequest iRequest) {    String senderNodeName = null;    for (int retry = 0; retry < 10; retry++) {      senderNodeName = manager.getNodeNameById(iRequest.getId().getNodeId());      if (senderNodeName != null)        break;      try {        Thread.sleep(200);      } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw OException.wrapException(new ODistributedException("Execution has been interrupted"), e);      }    }    if (senderNodeName == null) {      ODistributedServerLog.warn(this, localNodeName, senderNodeName, DIRECTION.IN,          "Sender server id %d is not registered in the cluster configuration, discard the request: (%s) (worker=%d)",          iRequest.getId().getNodeId(), iRequest, id);      sendResponseBack(iRequest, new ODistributedException("Sender server id " + iRequest.getId().getNodeId()          + " is not registered in the cluster configuration, discard the request"));      return;    }    final ORemoteTask task = iRequest.getTask();    if (ODistributedServerLog.isDebugEnabled())      ODistributedServerLog          .debug(this, localNodeName, senderNodeName, DIRECTION.IN, "Received request: (%s) (worker=%d)", iRequest, id);    // EXECUTE IT LOCALLY    Object responsePayload = null;    OSecurityUser origin = null;    try {      waitNodeIsOnline();      distributed.waitIsReady(task);      // EXECUTE THE TASK      for (int retry = 1; running; ++retry) {        if (task.isUsingDatabase()) {          initDatabaseInstance();          if (database == null)            throw new ODistributedOperationException(                "Error on executing remote request because the database '" + databaseName + "' is not available");          // keep original user in database, check the username passed in request and set new user in DB, after document saved,          // reset to original user          if (database != null) {            database.activateOnCurrentThread();            origin = database.getUser();            try {              if (iRequest.getUserRID() != null && iRequest.getUserRID().isValid() && (lastUser == null || !(lastUser.getIdentity())                  .equals(iRequest.getUserRID()))) {                lastUser = database.getMetadata().getSecurity().getUser(iRequest.getUserRID());                database.setUser(lastUser);// set to new user              } else                origin = null;            } catch (Exception ex) {              OLogManager.instance().error(this, "Failed on user switching database. ", ex);            }          }        }        responsePayload = manager.executeOnLocalNode(iRequest.getId(), iRequest.getTask(), database);        if (responsePayload instanceof OModificationOperationProhibitedException) {          // RETRY          try {            ODistributedServerLog.info(this, localNodeName, senderNodeName, DIRECTION.IN,                "Database is frozen, waiting and retrying. Request %s (retry=%d, worker=%d)", iRequest, retry, id);            Thread.sleep(1000);          } catch (InterruptedException e) {          }        } else {          // OPERATION EXECUTED (OK OR ERROR), NO RETRY NEEDED          if (retry > 1)            ODistributedServerLog                .info(this, localNodeName, senderNodeName, DIRECTION.IN, "Request %s succeed after retry=%d", iRequest, retry);          break;        }      }    } catch (RuntimeException e) {      if (task.hasResponse())        sendResponseBack(iRequest, e);      throw e;    } finally {      if (database != null && !database.isClosed()) {        database.activateOnCurrentThread();        if (!database.isClosed()) {          database.rollback();          database.getLocalCache().clear();          if (origin != null)            database.setUser(origin);        }      }    }    if (task.hasResponse()) {      if (!sendResponseBack(iRequest, responsePayload)) {        handleError(iRequest, responsePayload);      }    }  }
public String printExceptionMessage(Exception e, String message, String level) {    if (e.getMessage() != null)      message += "\n" + e.getClass().getName() + " - " + e.getMessage();    else      message += "\n" + e.getClass().getName();    switch (level) {    case "debug":      this.messageHandler.debug(this, message);      break;    case "info":      this.messageHandler.info(this, message);      break;    case "warn":      this.messageHandler.warn(this, message);      break;    case "error":      this.messageHandler.error(this, message);      break;    }    return message;  }
public String printExceptionStackTrace(Exception e, String level) {    // copying the exception stack trace in the string    Writer writer = new StringWriter();    e.printStackTrace(new PrintWriter(writer));    String s = writer.toString();    switch (level) {    case "debug":      this.messageHandler.debug(this, "\n" + s + "\n");      break;    case "info":      this.messageHandler.info(this, "\n" + s + "\n");      break;    case "warn":      this.messageHandler.warn(this, "\n" + s + "\n");      break;    case "error":      this.messageHandler.error(this, "\n" + s + "\n");      break;    }    return s;  }
public OIndexCursor executeIndexQuery(OCommandContext iContext, OIndex<?> index, final List<Object> keyParams,      boolean ascSortOrder) {    return null;  }
private void convertLink2Record(final Object iKey) {    if (status == MULTIVALUE_CONTENT_TYPE.ALL_RECORDS)      return;    final Object value;    if (iKey instanceof ORID)      value = iKey;    else      value = super.get(iKey);    if (value != null && value instanceof ORID) {      final ORID rid = (ORID) value;      marshalling = true;      try {        try {          // OVERWRITE IT          ORecord record = rid.getRecord();          if(record != null){              ORecordInternal.unTrack(sourceRecord, rid);              ORecordInternal.track(sourceRecord, record);          }          super.put(iKey, record);        } catch (ORecordNotFoundException ignore) {          // IGNORE THIS        }      } finally {        marshalling = false;      }    }  }
@Override  public void serializeInByteBufferObject(Boolean object, ByteBuffer buffer, Object... hints) {    buffer.put(object.booleanValue() ? (byte) 1 : (byte) 0);  }
@Override  public Boolean deserializeFromByteBufferObject(ByteBuffer buffer, OWALChanges walChanges, int offset) {    return walChanges.getByteValue(buffer, offset) > 0;  }
public void registerCommand(final OServerCommand iServerCommandInstance) {    for (String name : iServerCommandInstance.getNames())      if (OStringSerializerHelper.contains(name, '{')) {        restCommands.put(name, iServerCommandInstance);      } else if (OStringSerializerHelper.contains(name, '*'))        wildcardCommands.put(name, iServerCommandInstance);      else        exactCommands.put(name, iServerCommandInstance);    iServerCommandInstance.configure(server);  }
public void config(final OServer oServer, final OServerConfigurationManager serverCfg, final ODocument jsonConfig) {    super.config(oServer, serverCfg, jsonConfig);    try {      if (jsonConfig.containsField("users")) {        List<ODocument> usersList = jsonConfig.field("users");        for (ODocument userDoc : usersList) {        	          OServerUserConfiguration userCfg = createServerUser(userDoc);                   if (userCfg != null) {            String checkName = userCfg.name;                if (!isCaseSensitive()) checkName = checkName.toLowerCase(Locale.ENGLISH);          	          	usersMap.put(checkName, userCfg);          }        }      }    } catch (Exception ex) {      OLogManager.instance().error(this, "config()", ex);    }  }
protected OServerUserConfiguration createServerUser(final ODocument userDoc) {    OServerUserConfiguration userCfg = null;        if (userDoc.containsField("username") && userDoc.containsField("resources")) {      final String user = userDoc.field("username");      final String resources = userDoc.field("resources");      String password = userDoc.field("password");              if (password == null) password = "";          userCfg = new OServerUserConfiguration(user, password, resources);    }       return userCfg;  }
public String authenticate(final String username, final String password) {    String principal = null;    try {      OServerUserConfiguration user = getUser(username);      if (isPasswordValid(user)) {        if (OSecurityManager.instance().checkPassword(password, user.password)) {          principal = user.name;        }      }    } catch (Exception ex) {      OLogManager.instance().error(this, "ODefaultPasswordAuthenticator.authenticate()", ex);    }    return principal;  }
public boolean isAuthorized(final String username, final String resource) {    if (username == null || resource == null)      return false;    OServerUserConfiguration userCfg = getUser(username);    if (userCfg != null) {      // Total Access      if (userCfg.resources.equals("*"))        return true;      String[] resourceParts = userCfg.resources.split(",");      for (String r : resourceParts) {        if (r.equalsIgnoreCase(resource))          return true;      }    }    return false;  }
public OServerUserConfiguration getUser(final String username) {    OServerUserConfiguration userCfg = null;    synchronized (usersMap) {      if (username != null) {        String checkName = username;        if (!isCaseSensitive())          checkName = username.toLowerCase(Locale.ENGLISH);        if (usersMap.containsKey(checkName)) {          userCfg = usersMap.get(checkName);        }      }    }    return userCfg;  }
public List<OIndexSearchResult> analyzeCondition(OSQLFilterCondition condition, final OClass schemaClass,      OCommandContext context) {    final List<OIndexSearchResult> indexSearchResults = new ArrayList<OIndexSearchResult>();    OIndexSearchResult lastCondition = analyzeFilterBranch(schemaClass, condition, indexSearchResults, context);    if (indexSearchResults.isEmpty() && lastCondition != null) {      indexSearchResults.add(lastCondition);    }    Collections.sort(indexSearchResults, new Comparator<OIndexSearchResult>() {      public int compare(final OIndexSearchResult searchResultOne, final OIndexSearchResult searchResultTwo) {        return searchResultTwo.getFieldCount() - searchResultOne.getFieldCount();      }    });    return indexSearchResults;  }
private OIndexSearchResult createIndexedProperty(final OSQLFilterCondition iCondition, final Object iItem, OCommandContext ctx) {    if (iItem == null || !(iItem instanceof OSQLFilterItemField)) {      return null;    }    if (iCondition.getLeft() instanceof OSQLFilterItemField && iCondition.getRight() instanceof OSQLFilterItemField) {      return null;    }    final OSQLFilterItemField item = (OSQLFilterItemField) iItem;    if (item.hasChainOperators() && !item.isFieldChain()) {      return null;    }    boolean inverted = iCondition.getRight() == iItem;    final Object origValue = inverted ? iCondition.getLeft() : iCondition.getRight();    OQueryOperator operator = iCondition.getOperator();    if (inverted) {      if (operator instanceof OQueryOperatorIn) {        operator = new OQueryOperatorContains();      } else if (operator instanceof OQueryOperatorContains) {        operator = new OQueryOperatorIn();      } else if (operator instanceof OQueryOperatorMajor) {        operator = new OQueryOperatorMinor();      } else if (operator instanceof OQueryOperatorMinor) {        operator = new OQueryOperatorMajor();      } else if (operator instanceof OQueryOperatorMajorEquals) {        operator = new OQueryOperatorMinorEquals();      } else if (operator instanceof OQueryOperatorMinorEquals) {        operator = new OQueryOperatorMajorEquals();      }    }    if (iCondition.getOperator() instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn) {      return new OIndexSearchResult(operator, item.getFieldChain(), origValue);    }    final Object value = OSQLHelper.getValue(origValue, null, ctx);    return new OIndexSearchResult(operator, item.getFieldChain(), value);  }
public void detach(final Object self, final boolean nonProxiedInstance)      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {    final Class<?> selfClass = self.getClass();    for (String fieldName : doc.fieldNames()) {      Object value = getValue(self, fieldName, false, null, true);      if (value instanceof OObjectLazyMultivalueElement) {        ((OObjectLazyMultivalueElement<?>) value).detach(nonProxiedInstance);        if (nonProxiedInstance)          value = ((OObjectLazyMultivalueElement<?>) value).getNonOrientInstance();      }      OObjectEntitySerializer.setFieldValue(OObjectEntitySerializer.getField(fieldName, selfClass), self, value);    }    OObjectEntitySerializer.setIdField(selfClass, self, doc.getIdentity());    OObjectEntitySerializer.setVersionField(selfClass, self, doc.getVersion());  }
public void detachAll(final Object self, final boolean nonProxiedInstance, final Map<Object, Object> alreadyDetached,      final Map<Object, Object> lazyObjects) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {    final Class<?> selfClass = self.getClass();    for (String fieldName : doc.fieldNames()) {      final Field field = OObjectEntitySerializer.getField(fieldName, selfClass);      if (field != null) {        Object value = getValue(self, fieldName, false, null, true);        if (value instanceof OObjectLazyMultivalueElement) {          ((OObjectLazyMultivalueElement<?>) value).detachAll(nonProxiedInstance, alreadyDetached, lazyObjects);          if (nonProxiedInstance)            value = ((OObjectLazyMultivalueElement<?>) value).getNonOrientInstance();        } else if (value instanceof Proxy) {          OObjectProxyMethodHandler handler = (OObjectProxyMethodHandler) ((ProxyObject) value).getHandler();          if (nonProxiedInstance) {            value = OObjectEntitySerializer.getNonProxiedInstance(value);          }          if (OObjectEntitySerializer.isFetchLazyField(self.getClass(), fieldName)) {            // just make a placeholder with only the id, so it can be fetched later (but not by orient            // internally)            // do not use the already detached map for this, that might mix up lazy and non-lazy objects            Object lazyValue = lazyObjects.get(handler.doc.getIdentity());            if (lazyValue != null) {              value = lazyValue;            } else {              OObjectEntitySerializer.setIdField(field.getType(), value, handler.doc.getIdentity());              lazyObjects.put(handler.doc.getIdentity(), value);            }          } else {            Object detachedValue = alreadyDetached.get(handler.doc.getIdentity());            if (detachedValue != null) {              value = detachedValue;            } else {              ORID identity = handler.doc.getIdentity();              if (identity.isValid())                alreadyDetached.put(identity, value);              handler.detachAll(value, nonProxiedInstance, alreadyDetached, lazyObjects);            }          }        } else if (value instanceof OTrackedMap && nonProxiedInstance) {          Map newValue = new LinkedHashMap<>();          newValue.putAll((Map) value);          value = newValue;        } else if (value instanceof OTrackedList && nonProxiedInstance) {          List newValue = new ArrayList();          newValue.addAll((Collection) value);          value = newValue;        } else if (value instanceof OTrackedSet && nonProxiedInstance) {          Set newValue = new LinkedHashSet();          newValue.addAll((Collection) value);          value = newValue;        }        OObjectEntitySerializer.setFieldValue(field, self, value);      }    }    OObjectEntitySerializer.setIdField(selfClass, self, doc.getIdentity());    OObjectEntitySerializer.setVersionField(selfClass, self, doc.getVersion());  }
public void attach(final Object self)      throws IllegalArgumentException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {    for (Class<?> currentClass = self.getClass(); currentClass != Object.class; ) {      if (Proxy.class.isAssignableFrom(currentClass)) {        currentClass = currentClass.getSuperclass();        continue;      }      for (Field f : currentClass.getDeclaredFields()) {        final String fieldName = f.getName();        final Class<?> declaringClass = f.getDeclaringClass();        if (OObjectEntitySerializer.isTransientField(declaringClass, fieldName) || OObjectEntitySerializer            .isVersionField(declaringClass, fieldName) || OObjectEntitySerializer.isIdField(declaringClass, fieldName))          continue;        Object value = OObjectEntitySerializer.getFieldValue(f, self);        value = setValue(self, fieldName, value);        OObjectEntitySerializer.setFieldValue(f, self, value);      }      currentClass = currentClass.getSuperclass();      if (currentClass == null || currentClass.equals(ODocument.class))        // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER        // ODOCUMENT FIELDS        currentClass = Object.class;    }  }
private String[] calculateProperties(OCommandContext ctx) {    if (propertyList == null) {      return null;    }    return propertyList.stream().map(x -> x.getCompleteKey()).collect(Collectors.toList()).toArray(new String[] {});  }
private OClass getIndexClass(OCommandContext ctx) {    if (className == null) {      return null;    }    OClass result = ctx.getDatabase().getMetadata().getSchema().getClass(className.getStringValue());    if (result == null) {      throw new OCommandExecutionException("Cannot find class " + className);    }    return result;  }
private ODocument calculateMetadata(OCommandContext ctx) {    if (metadata == null) {      return null;    }    return metadata.toDocument(null, ctx);  }
protected long nextWithNewCurrentValue(long currentValue, boolean executeViaDistributed)      throws OSequenceLimitReachedException, ODatabaseException {    if (!executeViaDistributed) {      //we don't want synchronization on whole method, because called with executeViaDistributed == true      //will later call nextWithNewCurrentValue with parameter executeViaDistributed == false      //and that will cause deadlock      synchronized (this) {        cacheStart = currentValue;        return nextWork();      }    } else {      try{        return sendSequenceActionSetAndNext(currentValue);      }      catch (InterruptedException | ExecutionException exc){        OLogManager.instance().error(this, exc.getMessage(), exc, (Object[]) null);        throw new ODatabaseException(exc.getMessage());      }    }  }
public Iterable<OTransactionIndexEntry> interpret(Interpretation interpretation) {    synchronized (this) {      switch (interpretation) {      case Unique:        return interpretAsUnique();      case Dictionary:        return interpretAsDictionary();      case NonUnique:        return interpretAsNonUnique();      default:        throw new IllegalStateException("Unexpected interpretation '" + interpretation + "'");      }    }  }
public Object execute(final Map<Object, Object> iArgs) {    if (fromExpr == null && toExpr == null && rids == null && query == null && compiledFilter == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    ODatabaseDocumentInternal db = getDatabase();    txAlreadyBegun = db.getTransaction().isActive();    if (rids != null) {      // REMOVE PUNCTUAL RID      db.begin();      for (ORecordId rid : rids) {        final OEdge e = toEdge(rid);        if (e != null) {          e.delete();          removed++;        }      }      db.commit();      return removed;    } else {      // MULTIPLE EDGES      final Set<OEdge> edges = new HashSet<OEdge>();      if (query == null) {        db.begin();        Set<OIdentifiable> fromIds = null;        if (fromExpr != null)          fromIds = OSQLEngine.getInstance().parseRIDTarget(db, fromExpr, context, iArgs);        Set<OIdentifiable> toIds = null;        if (toExpr != null)          toIds = OSQLEngine.getInstance().parseRIDTarget(db, toExpr, context, iArgs);        if (label == null)          label = "E";        if (fromIds != null && toIds != null) {          int fromCount = 0;          int toCount = 0;          for (OIdentifiable fromId : fromIds) {            final OVertex v = toVertex(fromId);            if (v != null)              fromCount += count(v.getEdges(ODirection.OUT, label));          }          for (OIdentifiable toId : toIds) {            final OVertex v = toVertex(toId);            if (v != null)              toCount += count(v.getEdges(ODirection.IN, label));          }          if (fromCount <= toCount) {            // REMOVE ALL THE EDGES BETWEEN VERTICES            for (OIdentifiable fromId : fromIds) {              final OVertex v = toVertex(fromId);              if (v != null)                for (OEdge e : v.getEdges(ODirection.OUT, label)) {                  final OIdentifiable inV = ((OEdge) e).getTo();                  if (inV != null && toIds.contains(inV.getIdentity()))                    edges.add(e);                }            }          } else {            for (OIdentifiable toId : toIds) {              final OVertex v = toVertex(toId);              if (v != null)                for (OEdge e : v.getEdges(ODirection.IN, label)) {                  final OIdentifiable outV = ((OEdge) e).getFrom();                  if (outV != null && fromIds.contains(outV.getIdentity()))                    edges.add(e);                }            }          }        } else if (fromIds != null) {          // REMOVE ALL THE EDGES THAT START FROM A VERTEXES          for (OIdentifiable fromId : fromIds) {            final OVertex v = toVertex(fromId);            if (v != null) {              for (OEdge e : v.getEdges(ODirection.OUT, label)) {                edges.add(e);              }            }          }        } else if (toIds != null) {          // REMOVE ALL THE EDGES THAT ARRIVE TO A VERTEXES          for (OIdentifiable toId : toIds) {            final OVertex v = toVertex(toId);            if (v != null) {              for (OEdge e : v.getEdges(ODirection.IN, label)) {                edges.add(e);              }            }          }        } else          throw new OCommandExecutionException("Invalid target: " + toIds);        if (compiledFilter != null) {          // ADDITIONAL FILTERING          for (Iterator<OEdge> it = edges.iterator(); it.hasNext(); ) {            final OEdge edge = it.next();            if (!(Boolean) compiledFilter.evaluate(edge.getRecord(), null, context))              it.remove();          }        }        // DELETE THE FOUND EDGES        removed = edges.size();        for (OEdge edge : edges)          edge.delete();        db.commit();        return removed;      } else {        db.begin();        // TARGET IS A CLASS + OPTIONAL CONDITION        query.setContext(getContext());        query.execute(iArgs);        db.commit();        return removed;      }    }  }
public boolean result(final Object iRecord) {    final OIdentifiable id = (OIdentifiable) iRecord;    if (compiledFilter != null) {      // ADDITIONAL FILTERING      if (!(Boolean) compiledFilter.evaluate(id.getRecord(), null, context))        return true;    }    if (id.getIdentity().isValid()) {      final OEdge e = toEdge(id);      if (e != null) {        e.delete();        if (!txAlreadyBegun && batch > 0 && (removed + 1) % batch == 0) {          getDatabase().commit();          getDatabase().begin();        }        removed++;      }    }    return true;  }
public void truncate() throws IOException {    ODatabaseDocumentInternal db = getDatabase();    db.checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_UPDATE);    if (isSubClassOf(OSecurityShared.RESTRICTED_CLASSNAME)) {      throw new OSecurityException(          "Class '" + getName() + "' cannot be truncated because has record level security enabled (extends '"              + OSecurityShared.RESTRICTED_CLASSNAME + "')");    }    final OStorage storage = db.getStorage();    acquireSchemaReadLock();    try {      for (int id : clusterIds) {        OCluster cl = storage.getClusterById(id);        db.checkForClusterPermissions(cl.getName());        cl.truncate();      }      for (OIndex<?> index : getClassIndexes())        index.clear();      Set<OIndex<?>> superclassIndexes = new HashSet<OIndex<?>>();      superclassIndexes.addAll(getIndexes());      superclassIndexes.removeAll(getClassIndexes());      for (OIndex index : superclassIndexes) {        index.rebuild();      }    } finally {      releaseSchemaReadLock();    }  }
public boolean isSubClassOf(final String iClassName) {    acquireSchemaReadLock();    try {      if (iClassName == null)        return false;      if (iClassName.equalsIgnoreCase(getName()) || iClassName.equalsIgnoreCase(getShortName()))        return true;      for (OClassImpl superClass : superClasses) {        if (superClass.isSubClassOf(iClassName))          return true;      }      return false;    } finally {      releaseSchemaReadLock();    }  }
public boolean isSubClassOf(final OClass clazz) {    acquireSchemaReadLock();    try {      if (clazz == null)        return false;      if (equals(clazz))        return true;      for (OClassImpl superClass : superClasses) {        if (superClass.isSubClassOf(clazz))          return true;      }      return false;    } finally {      releaseSchemaReadLock();    }  }
protected OClass addBaseClass(final OClassImpl iBaseClass) {    checkRecursion(iBaseClass);    if (subclasses == null)      subclasses = new ArrayList<OClass>();    if (subclasses.contains(iBaseClass))      return this;    subclasses.add(iBaseClass);    addPolymorphicClusterIdsWithInheritance(iBaseClass);    return this;  }
protected void addPolymorphicClusterIds(final OClassImpl iBaseClass) {    Set<Integer> clusters = new TreeSet<Integer>();    for (int clusterId : polymorphicClusterIds) {      clusters.add(clusterId);    }    for (int clusterId : iBaseClass.polymorphicClusterIds) {      if (clusters.add(clusterId)) {        try {          addClusterIdToIndexes(clusterId);        } catch (RuntimeException e) {          OLogManager.instance().warn(this, "Error adding clusterId '%d' to index of class '%s'", e, clusterId, getName());          clusters.remove(clusterId);        }      }    }    polymorphicClusterIds = new int[clusters.size()];    int i = 0;    for (Integer cluster : clusters) {      polymorphicClusterIds[i] = cluster;      i++;    }  }
@Override  public Object evaluateRecord(OIdentifiable iRecord, ODocument iCurrentResult, OSQLFilterCondition iCondition, Object iLeft,      Object iRight, OCommandContext iContext, final ODocumentSerializer serializer) {    OSQLFunction function = OSQLEngine.getInstance().getFunction(keyword);    return function.execute(this, iRecord, iCurrentResult, new Object[] { iLeft, iCondition.getRight() }, iContext);  }
private static OIdentifiable linkToStream(final StringBuilder buffer, final ODocument iParentRecord, Object iLinked) {    if (iLinked == null)      // NULL REFERENCE      return null;    OIdentifiable resultRid = null;    ORID rid;    if (iLinked instanceof ORID) {      // JUST THE REFERENCE      rid = (ORID) iLinked;      assert rid.getIdentity().isValid() || (ODatabaseRecordThreadLocal.instance().get().getStorage() instanceof OStorageProxy) :          "Impossible to serialize invalid link " + rid.getIdentity();      resultRid = rid;    } else {      if (iLinked instanceof String)        iLinked = new ORecordId((String) iLinked);      if (!(iLinked instanceof OIdentifiable))        throw new IllegalArgumentException(            "Invalid object received. Expected a OIdentifiable but received type=" + iLinked.getClass().getName() + " and value="                + iLinked);      // RECORD      ORecord iLinkedRecord = ((OIdentifiable) iLinked).getRecord();      rid = iLinkedRecord.getIdentity();      assert rid.getIdentity().isValid() || (ODatabaseRecordThreadLocal.instance().get().getStorage() instanceof OStorageProxy) :          "Impossible to serialize invalid link " + rid.getIdentity();      final ODatabaseDocument database = ODatabaseRecordThreadLocal.instance().get();      if (iParentRecord != null) {        if (!database.isRetainRecords())          // REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY          resultRid = iLinkedRecord.getIdentity();      }    }    if (rid.isValid())      rid.toString(buffer);    return resultRid;  }
public static SortField buildSortField(Map<String, Object> conf) {    final String field = Optional.ofNullable((String) conf.get("field")).orElse(null);    final String type = Optional.ofNullable(((String) conf.get("type")).toUpperCase()).orElse(SortField.Type.STRING.name());    final Boolean reverse = Optional.ofNullable((Boolean) conf.get("reverse")).orElse(false);    SortField sortField = new SortField(field, SortField.Type.valueOf(type), reverse);    return sortField;  }
public int fromInputStream(final InputStream in) throws IOException {    final OMemoryStream out = new OMemoryStream();    try {      final byte[] buffer = new byte[OMemoryStream.DEF_SIZE];      int readBytesCount;      while (true) {        readBytesCount = in.read(buffer, 0, buffer.length);        if (readBytesCount == -1) {          break;        }        out.write(buffer, 0, readBytesCount);      }      out.flush();      _source = out.toByteArray();    } finally {      out.close();    }    _size = _source.length;    return _size;  }
public int fromInputStream(final InputStream in, final int maxSize) throws IOException {    final byte[] buffer = new byte[maxSize];    int totalBytesCount = 0;    int readBytesCount;    while (totalBytesCount < maxSize) {      readBytesCount = in.read(buffer, totalBytesCount, buffer.length - totalBytesCount);      if (readBytesCount == -1) {        break;      }      totalBytesCount += readBytesCount;    }    if (totalBytesCount == 0) {      _source = EMPTY_SOURCE;      _size = 0;    } else if (totalBytesCount == maxSize) {      _source = buffer;      _size = maxSize;    } else {      _source = Arrays.copyOf(buffer, totalBytesCount);      _size = totalBytesCount;    }    return _size;  }
public final OPointer acquireDirect(boolean clear) {    OPointer pointer;    pointer = pointersPool.poll();    if (pointer != null) {      pointersPoolSize.decrementAndGet();    } else {      pointer = allocator.allocate(pageSize, -1);    }    if (clear) {      pointer.clear();    }    final ByteBuffer buffer = pointer.getNativeByteBuffer();    buffer.position(0);    if (TRACK) {      pointerMapping.put(pointer, generatePointer());    }    return pointer;  }
public final void release(OPointer pointer) {    if (TRACK) {      pointerMapping.remove(pointer);    }    long poolSize = pointersPoolSize.incrementAndGet();    if (poolSize > this.poolSize) {      pointersPoolSize.decrementAndGet();      allocator.deallocate(pointer);    } else {      pointersPool.add(pointer);    }  }
public void checkMemoryLeaks() {    boolean detected = false;    if (TRACK) {      for (Map.Entry<OPointer, PointerTracker> entry : pointerMapping.entrySet()) {        OLogManager.instance()            .errorNoDb(this, "DIRECT-TRACK: unreleased direct memory pointer `%X` detected.", entry.getValue().allocation,                System.identityHashCode(entry.getKey()));        detected = true;      }    }    assert !detected;  }
public void clear() {    for (OPointer pointer : pointersPool) {      allocator.deallocate(pointer);    }    pointersPool.clear();    pointersPoolSize.set(0);    for (OPointer pointer : pointerMapping.keySet()) {      allocator.deallocate(pointer);    }    pointerMapping.clear();  }
public static int bytes2int(final byte[] b, final int offset) {    return (b[offset]) << 24 | (0xff & b[offset + 1]) << 16 | (0xff & b[offset + 2]) << 8 | ((0xff & b[offset + 3]));  }
public static PersistenceUnitInfo findPersistenceUnit(String unitName, Collection<? extends PersistenceUnitInfo> units) {    if (units == null || unitName == null) {      return null;    }    for (PersistenceUnitInfo unit : units) {      if (unitName.equals(unit.getPersistenceUnitName())) {        return unit;      }    }    return null;  }
public static Collection<? extends PersistenceUnitInfo> parse(URL persistenceXml) {    InputStream is = null;    try {      // Buffer the InputStream so we can mark it, though we'll be in      // trouble if we have to read more than 8192 characters before finding      // the schema!      is = new BufferedInputStream(persistenceXml.openStream());      JPAVersion jpaVersion = getSchemaVersion(is);      Schema schema = getSchema(jpaVersion);      if (schema == null) {        throw new PersistenceException("Schema is unknown");      }      // Get back to the beginning of the stream      is = new BufferedInputStream(persistenceXml.openStream());      parserFactory.setNamespaceAware(true);      int endIndex = persistenceXml.getPath().length() - PERSISTENCE_XML_BASE_NAME.length();      URL persistenceXmlRoot = new URL("file://" + persistenceXml.getFile().substring(0, endIndex));      return getPersistenceUnits(is, persistenceXmlRoot, jpaVersion);    } catch (Exception e) {      throw new PersistenceException("Something goes wrong while parsing persistence.xml", e);    } finally {      if (is != null)        try {          is.close();        } catch (IOException e) {          // No logging necessary, just consume        }    }  }
@Override  public void startElement(String uri, String localName, String name, Attributes attributes) throws SAXException {    PersistenceXml element = PersistenceXml.parse((localName == null || localName.isEmpty()) ? name : localName);    schemaVersion = PersistenceXmlUtil.parseSchemaVersion(uri, element, attributes);    // found, stop parsing    if (schemaVersion != null) {      throw new StopSAXParser();    }    // This should never occurs, however check if contain known tag other than TAG_PERSISTENCE    if (TAG_PERSISTENCE != element && EnumSet.allOf(PersistenceXml.class).contains(element)) {      throw new PersistenceException("Cannot find schema version attribute in <persistence> tag");    }  }
public static void writeUnsignedVarLong(long value, final BytesContainer bos) {    int pos;    while ((value & 0xFFFFFFFFFFFFFF80L) != 0L) {      // out.writeByte(((int) value & 0x7F) | 0x80);      pos = bos.alloc((short) 1);      bos.bytes[pos] = (byte) (value & 0x7F | 0x80);      value >>>= 7;    }    // out.writeByte((int) value & 0x7F);    pos = bos.alloc((short) 1);    bos.bytes[pos] = (byte) (value & 0x7F);  }
public static long readSignedVarLong(final BytesContainer bytes) {    final long raw = readUnsignedVarLong(bytes);    // This undoes the trick in writeSignedVarLong()    final long temp = (((raw << 63) >> 63) ^ raw) >> 1;    // This extra step lets us deal with the largest signed values by    // treating    // negative results from read unsigned methods as like unsigned values    // Must re-flip the top bit if the original read value had it set.    return temp ^ (raw & (1L << 63));  }
public static long readUnsignedVarLong(final BytesContainer bytes) {    long value = 0L;    int i = 0;    long b;    while (((b = bytes.bytes[bytes.offset++]) & 0x80L) != 0) {      value |= (b & 0x7F) << i;      i += 7;      if (i > 63)        throw new IllegalArgumentException("Variable length quantity is too long (must be <= 63)");    }    return value | (b << i);  }
@Override  public void onOpen(final ODatabaseInternal iDatabase) {    if (!isRelatedToLocalServer(iDatabase))      return;    if (isOffline() && status != NODE_STATUS.STARTING)      return;    final ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal.instance().getIfDefined();    try {      final String dbName = iDatabase.getName();      final ODistributedConfiguration cfg = getDatabaseConfiguration(dbName);      if (cfg == null)        return;    } catch (HazelcastException e) {      throw OException.wrapException(new OOfflineNodeException("Hazelcast instance is not available"), e);    } catch (HazelcastInstanceNotActiveException e) {      throw OException.wrapException(new OOfflineNodeException("Hazelcast instance is not available"), e);    } finally {      // RESTORE ORIGINAL DATABASE INSTANCE IN TL      ODatabaseRecordThreadLocal.instance().set(currDb);    }  }
protected void installDatabaseFromNetwork(final String dbPath, final String databaseName,      final ODistributedDatabaseImpl distrDatabase, final String iNode, final ODistributedDatabaseChunk firstChunk,      final boolean delta, final File uniqueClustersBackupDirectory, final OModifiableDistributedConfiguration cfg) {    final String localNodeName = nodeName;    final AtomicReference<ODistributedMomentum> momentum = new AtomicReference<ODistributedMomentum>();    OSyncReceiver receiver = new OSyncReceiver(this, databaseName, firstChunk, momentum, iNode, dbPath);    try {      Thread t = new Thread(receiver);      t.setUncaughtExceptionHandler(new OUncaughtExceptionHandler());      t.start();    } catch (Exception e) {      ODistributedServerLog.error(this, nodeName, null, DIRECTION.NONE, "Error on transferring database '%s' ", e, databaseName);      throw OException.wrapException(new ODistributedException("Error on transferring database"), e);    }    final ODatabaseDocumentInternal db = installDatabaseOnLocalNode(databaseName, dbPath, iNode, delta,        uniqueClustersBackupDirectory, cfg, firstChunk.incremental, receiver);    if (db == null)      return;    // OVERWRITE THE MOMENTUM FROM THE ORIGINAL SERVER AND ADD LAST LOCAL LSN    try {      distrDatabase.getSyncConfiguration().load();      distrDatabase.getSyncConfiguration()          .setLastLSN(localNodeName, ((OLocalPaginatedStorage) db.getStorage().getUnderlying()).getLSN(), false);    } catch (IOException e) {      ODistributedServerLog.error(this, nodeName, null, DIRECTION.NONE, "Error on loading %s file for database '%s'", e,          DISTRIBUTED_SYNC_JSON_FILENAME, databaseName);    }    try {      distrDatabase.setOnline();    } finally {      db.activateOnCurrentThread();      db.close();    }    // ASK FOR INDIVIDUAL CLUSTERS IN CASE OF SHARDING AND NO LOCAL COPY    final Set<String> localManagedClusters = cfg.getClustersOnServer(localNodeName);    final Set<String> sourceNodeClusters = cfg.getClustersOnServer(iNode);    localManagedClusters.removeAll(sourceNodeClusters);    final HashSet<String> toSynchClusters = new HashSet<String>();    for (String cl : localManagedClusters) {      // FILTER CLUSTER CHECKING IF ANY NODE IS ACTIVE      final List<String> servers = cfg.getServers(cl, localNodeName);      getAvailableNodes(servers, databaseName);      if (!servers.isEmpty())        toSynchClusters.add(cl);    }    // SYNC ALL THE CLUSTERS    for (String cl : toSynchClusters) {      // FILTER CLUSTER CHECKING IF ANY NODE IS ACTIVE      OCommandExecutorSQLHASyncCluster.replaceCluster(this, serverInstance, databaseName, cl);    }    try {      rebalanceClusterOwnership(nodeName, db, cfg, false);    } catch (Exception e) {      // HANDLE IT AS WARNING      ODistributedServerLog          .warn(this, nodeName, null, DIRECTION.NONE, "Error on re-balancing the cluster for database '%s'", e, databaseName);      // NOT CRITICAL, CONTINUE    }  }
public boolean installClustersOfClass(final ODatabaseInternal iDatabase, final OClass iClass,      OModifiableDistributedConfiguration cfg) {    final String databaseName = iDatabase.getName();    if (iClass.isAbstract())      return false;    // INIT THE DATABASE IF NEEDED    getMessageService().registerDatabase(databaseName, cfg);    return executeInDistributedDatabaseLock(databaseName, 20000, cfg,        new OCallable<Boolean, OModifiableDistributedConfiguration>() {          @Override          public Boolean call(final OModifiableDistributedConfiguration lastCfg) {            final Set<String> availableNodes = getAvailableNodeNames(iDatabase.getName());            final List<String> cluster2Create = clusterAssignmentStrategy                .assignClusterOwnershipOfClass(iDatabase, lastCfg, iClass, availableNodes, true);            final Map<OClass, List<String>> cluster2CreateMap = new HashMap<OClass, List<String>>(1);            cluster2CreateMap.put(iClass, cluster2Create);            createClusters(iDatabase, cluster2CreateMap, lastCfg);            return true;          }        });  }
public <T> T executeInDistributedDatabaseLock(final String databaseName, final long timeoutLocking,      OModifiableDistributedConfiguration lastCfg, final OCallable<T, OModifiableDistributedConfiguration> iCallback) {    boolean updated;    T result;    lockManagerRequester.acquireExclusiveLock(databaseName, nodeName, timeoutLocking);    try {      if (lastCfg == null)        // ACQUIRE CFG INSIDE THE LOCK        lastCfg = getDatabaseConfiguration(databaseName).modify();      if (ODistributedServerLog.isDebugEnabled())        ODistributedServerLog            .debug(this, nodeName, null, DIRECTION.NONE, "Current distributed configuration for database '%s': %s", databaseName,                lastCfg.getDocument().toJSON());      try {        result = iCallback.call(lastCfg);      } finally {        if (ODistributedServerLog.isDebugEnabled())          ODistributedServerLog              .debug(this, nodeName, null, DIRECTION.NONE, "New distributed configuration for database '%s': %s", databaseName,                  lastCfg.getDocument().toJSON());        // CONFIGURATION CHANGED, UPDATE IT ON THE CLUSTER AND DISK        updated = updateCachedDatabaseConfiguration(databaseName, lastCfg, true);      }    } catch (RuntimeException e) {      throw e;    } catch (Exception e) {      throw new RuntimeException(e);    } finally {      lockManagerRequester.releaseExclusiveLock(databaseName, nodeName);    }    if (updated) {      // SEND NEW CFG TO ALL THE CONNECTED CLIENTS      notifyClients(databaseName);      serverInstance.getClientConnectionManager().pushDistribCfg2Clients(getClusterConfiguration());    }    return result;  }
protected void dumpServersStatus() {    final ODocument cfg = getClusterConfiguration();    final String compactStatus = ODistributedOutput.getCompactServerStatus(this, cfg);    if (!lastServerDump.equals(compactStatus)) {      lastServerDump = compactStatus;      ODistributedServerLog          .info(this, getLocalNodeName(), null, DIRECTION.NONE, "Distributed servers status (*=current @=lockmgr[%s]):\n%s",              getLockManagerServer(), ODistributedOutput.formatServerStatus(this, cfg));    }  }
public static <T> int indexOf(final List<T> list, final T object, final Comparator<T> comparator) {    int i = 0;    for (final T item : list) {      if (comparator.compare(item, object) == 0)        return i;      i++;    }    return -1;  }
public static int indexOf(final Object[] array, final Comparable object) {    for (int i = 0; i < array.length; ++i) {      if (object.compareTo(array[i]) == 0)        // FOUND        return i;    }    return -1;  }
public static int indexOf(final int[] array, final int object) {    for (int i = 0; i < array.length; ++i) {      if (array[i] == object)        // FOUND        return i;    }    return -1;  }
public OCommandExecutorSQLSelect parse(final OCommandRequest iRequest) {    final OCommandRequestText textRequest = (OCommandRequestText) iRequest;    String queryText = textRequest.getText();    String originalQuery = queryText;    try {      // System.out.println("NEW PARSER FROM: " + queryText);      queryText = preParse(queryText, iRequest);      // System.out.println("NEW PARSER TO: " + queryText);      textRequest.setText(queryText);      super.parse(iRequest);      initContext();      final int pos = parseProjections();      if (pos == -1) {        return this;      }      final int endPosition = parserText.length();      parserNextWord(true);      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_FROM)) {        // FROM        parsedTarget = OSQLEngine.getInstance()            .parseTarget(parserText.substring(parserGetCurrentPosition(), endPosition), getContext());        parserSetCurrentPosition(            parsedTarget.parserIsEnded() ? endPosition : parsedTarget.parserGetCurrentPosition() + parserGetCurrentPosition());      } else {        parserGoBack();      }      if (!parserIsEnded()) {        parserSkipWhiteSpaces();        while (!parserIsEnded()) {          final String w = parserNextWord(true);          if (!w.isEmpty()) {            if (w.equals(KEYWORD_WHERE)) {              compiledFilter = OSQLEngine.getInstance()                  .parseCondition(parserText.substring(parserGetCurrentPosition(), endPosition), getContext(), KEYWORD_WHERE);              optimize();              parserSetCurrentPosition(compiledFilter.parserIsEnded() ?                  endPosition :                  compiledFilter.parserGetCurrentPosition() + parserGetCurrentPosition());            } else if (w.equals(KEYWORD_LET)) {              parseLet();            } else if (w.equals(KEYWORD_GROUP)) {              parseGroupBy();            } else if (w.equals(KEYWORD_ORDER)) {              parseOrderBy();            } else if (w.equals(KEYWORD_UNWIND)) {              parseUnwind();            } else if (w.equals(KEYWORD_LIMIT)) {              parseLimit(w);            } else if (w.equals(KEYWORD_SKIP) || w.equals(KEYWORD_OFFSET)) {              parseSkip(w);            } else if (w.equals(KEYWORD_FETCHPLAN)) {              parseFetchplan(w);            } else if (w.equals(KEYWORD_NOCACHE)) {              parseNoCache(w);            } else if (w.equals(KEYWORD_TIMEOUT)) {              parseTimeout(w);            } else if (w.equals(KEYWORD_LOCK)) {              final String lock = parseLock();              if (lock.equalsIgnoreCase("DEFAULT")) {                lockingStrategy = LOCKING_STRATEGY.DEFAULT;              } else if (lock.equals("NONE")) {                lockingStrategy = LOCKING_STRATEGY.NONE;              } else if (lock.equals("RECORD")) {                lockingStrategy = LOCKING_STRATEGY.EXCLUSIVE_LOCK;              } else if (lock.equals("SHARED")) {                lockingStrategy = LOCKING_STRATEGY.SHARED_LOCK;              }            } else if (w.equals(KEYWORD_PARALLEL)) {              parallel = parseParallel(w);            } else {              if (preParsedStatement == null) {                throwParsingException("Invalid keyword '" + w + "'");              }//if the pre-parsed statement is OK, then you can go on with the rest, the SQL is valid and this is probably a space in a backtick            }          }        }      }      if (limit == 0 || limit < -1) {        throw new IllegalArgumentException("Limit must be > 0 or = -1 (no limit)");      }      validateQuery();    } finally {      textRequest.setText(originalQuery);    }    return this;  }
@Override  public Set<String> getInvolvedClusters() {    final Set<String> clusters = new HashSet<String>();    if (parsedTarget != null) {      final ODatabaseDocument db = getDatabase();      if (parsedTarget.getTargetQuery() != null && parsedTarget          .getTargetRecords() instanceof OCommandExecutorSQLResultsetDelegate) {        // SUB-QUERY: EXECUTE IT LOCALLY        // SUB QUERY, PROPAGATE THE CALL        final Set<String> clIds = ((OCommandExecutorSQLResultsetDelegate) parsedTarget.getTargetRecords()).getInvolvedClusters();        for (String c : clIds) {          // FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS          if (checkClusterAccess(db, c)) {            clusters.add(c);          }        }      } else if (parsedTarget.getTargetRecords() != null) {        // SINGLE RECORDS: BROWSE ALL (COULD BE EXPENSIVE).        for (OIdentifiable identifiable : parsedTarget.getTargetRecords()) {          final String c = db.getClusterNameById(identifiable.getIdentity().getClusterId()).toLowerCase(Locale.ENGLISH);          // FILTER THE CLUSTER WHERE THE USER HAS THE RIGHT ACCESS          if (checkClusterAccess(db, c)) {            clusters.add(c);          }        }      }      if (parsedTarget.getTargetClasses() != null) {        return getInvolvedClustersOfClasses(parsedTarget.getTargetClasses().values());      }      if (parsedTarget.getTargetClusters() != null) {        return getInvolvedClustersOfClusters(parsedTarget.getTargetClusters().keySet());      }      if (parsedTarget.getTargetIndex() != null) {        // EXTRACT THE CLASS NAME -> CLUSTERS FROM THE INDEX DEFINITION        return getInvolvedClustersOfIndex(parsedTarget.getTargetIndex());      }    }    return clusters;  }
@Override  protected boolean handleResult(final OIdentifiable iRecord, final OCommandContext iContext) {    lastRecord = iRecord;    if ((orderedFields.isEmpty() || fullySortedByIndex || isRidOnlySort()) && skip > 0 && this.unwindFields == null        && this.expandTarget == null) {      lastRecord = null;      skip--;      return true;    }    if (!addResult(lastRecord, iContext)) {      return false;    }    return continueSearching();  }
public int getTemporaryRIDCounter(final OCommandContext iContext) {    final OTemporaryRidGenerator parentQuery = (OTemporaryRidGenerator) iContext.getVariable("parentQuery");    return parentQuery != null && parentQuery != this ?        parentQuery.getTemporaryRIDCounter(iContext) :        serialTempRID.getAndIncrement();  }
private void applyPartialOrderBy() {    if (expandTarget != null || (unwindFields != null && unwindFields.size() > 0) || orderedFields.isEmpty() || fullySortedByIndex        || isRidOnlySort()) {      return;    }    if (limit > 0) {      int sortBufferSize = limit + 1;      if (skip > 0) {        sortBufferSize += skip;      }      if (tempResult instanceof List && ((List) tempResult).size() >= sortBufferSize + PARTIAL_SORT_BUFFER_THRESHOLD) {        applyOrderBy(false);        tempResult = new ArrayList(((List) tempResult).subList(0, sortBufferSize));      }    }  }
protected void reportTip(final String iMessage) {    Orient.instance().getProfiler().reportTip(iMessage);    List<String> tips = (List<String>) context.getVariable("tips");    if (tips == null) {      tips = new ArrayList<String>(3);      context.setVariable("tips", tips);    }    tips.add(iMessage);  }
protected boolean parseFetchplan(final String w) throws OCommandSQLParsingException {    if (!w.equals(KEYWORD_FETCHPLAN)) {      return false;    }    parserSkipWhiteSpaces();    int start = parserGetCurrentPosition();    parserNextWord(true);    int end = parserGetCurrentPosition();    parserSkipWhiteSpaces();    int position = parserGetCurrentPosition();    while (!parserIsEnded()) {      final String word = OIOUtils.getStringContent(parserNextWord(true));      if (!OPatternConst.PATTERN_FETCH_PLAN.matcher(word).matches()) {        break;      }      end = parserGetCurrentPosition();      parserSkipWhiteSpaces();      position = parserGetCurrentPosition();    }    parserSetCurrentPosition(position);    if (end < 0) {      fetchPlan = OIOUtils.getStringContent(parserText.substring(start));    } else {      fetchPlan = OIOUtils.getStringContent(parserText.substring(start, end));    }    request.setFetchPlan(fetchPlan);    return true;  }
protected boolean parseNoCache(final String w) throws OCommandSQLParsingException {    if (!w.equals(KEYWORD_NOCACHE))      return false;    noCache = true;    return true;  }
private boolean optimizeSort(OClass iSchemaClass) {    OIndexCursor cursor = getOptimizedSortCursor(iSchemaClass);    if (cursor != null) {      fetchValuesFromIndexCursor(cursor);      return true;    }    return false;  }
private void applyExpand() {    if (expandTarget == null) {      return;    }    final long startExpand = System.currentTimeMillis();    try {      if (tempResult == null) {        tempResult = new ArrayList<OIdentifiable>();        if (expandTarget instanceof OSQLFilterItemVariable) {          Object r = ((OSQLFilterItemVariable) expandTarget).getValue(null, null, context);          if (r != null) {            if (r instanceof OIdentifiable) {              ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) r);            } else if (r instanceof Iterator || OMultiValue.isMultiValue(r)) {              for (Object o : OMultiValue.getMultiValueIterable(r)) {                ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) o);              }            }          }        } else if (expandTarget instanceof OSQLFunctionRuntime && !hasFieldItemParams((OSQLFunctionRuntime) expandTarget)) {          if (((OSQLFunctionRuntime) expandTarget).aggregateResults()) {            throw new OCommandExecutionException("Unsupported operation: aggregate function in expand(" + expandTarget + ")");          } else {            Object r = ((OSQLFunctionRuntime) expandTarget).execute(null, null, null, context);            if (r instanceof OIdentifiable) {              ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) r);            } else if (r instanceof Iterator || OMultiValue.isMultiValue(r)) {              for (Object o : OMultiValue.getMultiValueIterable(r)) {                ((Collection<OIdentifiable>) tempResult).add((OIdentifiable) o);              }            }          }        }      } else {        if (tempResult == null) {          tempResult = new ArrayList<OIdentifiable>();        }        final OMultiCollectionIterator<OIdentifiable> finalResult = new OMultiCollectionIterator<OIdentifiable>();        if (orderedFields == null || orderedFields.size() == 0) {          // expand is applied before sorting, so limiting the result set here would give wrong results          int iteratorLimit = 0;          if (limit < 0) {            iteratorLimit = -1;          } else {            iteratorLimit += limit;          }          finalResult.setLimit(iteratorLimit);          finalResult.setSkip(skip);        }        for (OIdentifiable id : tempResult) {          Object fieldValue;          if (expandTarget instanceof OSQLFilterItem) {            fieldValue = ((OSQLFilterItem) expandTarget).getValue(id.getRecord(), null, context);          } else if (expandTarget instanceof OSQLFunctionRuntime) {            fieldValue = ((OSQLFunctionRuntime) expandTarget).getResult();          } else {            fieldValue = expandTarget.toString();          }          if (fieldValue != null) {            if (fieldValue instanceof Iterable && !(fieldValue instanceof OIdentifiable)) {              fieldValue = ((Iterable) fieldValue).iterator();            }            if (fieldValue instanceof ODocument) {              ArrayList<ODocument> partial = new ArrayList<ODocument>();              partial.add((ODocument) fieldValue);              finalResult.add(partial);            } else if (fieldValue instanceof Collection<?> || fieldValue.getClass().isArray() || fieldValue instanceof Iterator<?>                || fieldValue instanceof OIdentifiable || fieldValue instanceof ORidBag) {              finalResult.add(fieldValue);            } else if (fieldValue instanceof Map<?, ?>) {              finalResult.add(((Map<?, OIdentifiable>) fieldValue).values());            }          }        }        tempResult = finalResult;      }    } finally {      context.setVariable("expandElapsed", (System.currentTimeMillis() - startExpand));    }  }
public ODocument status() {    synchronized (listener) {      ODocument status = new ODocument();      status.field("cfg", cfg);      status.field("status", this.status);      String lastBatchLog = "";      if (this.messageHandler != null) {        lastBatchLog = extractBatchLog();      }      status.field("log", lastBatchLog);      if (this.status == Status.FINISHED) {        listener.notifyAll();      }      return status;    }  }
@SuppressWarnings("unchecked")  public <RET> RET execute(final Object... iArgs) {    setParameters(iArgs);    OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationOk = onAsyncReplicationOk;    OExecutionThreadLocal.INSTANCE.get().onAsyncReplicationError = onAsyncReplicationError;    return (RET) ODatabaseRecordThreadLocal.instance().get().getStorage().command(this);  }
public static Object createLink(final ODocument iFromVertex, final OIdentifiable iTo, final String iFieldName) {    final Object out;    OType outType = iFromVertex.fieldType(iFieldName);    Object found = iFromVertex.field(iFieldName);    final OClass linkClass = ODocumentInternal.getImmutableSchemaClass(iFromVertex);    if (linkClass == null)      throw new IllegalArgumentException("Class not found in source vertex: " + iFromVertex);    final OProperty prop = linkClass.getProperty(iFieldName);    final OType propType = prop != null && prop.getType() != OType.ANY ? prop.getType() : null;    if (found == null) {      if (propType == OType.LINKLIST || (prop != null && "true".equalsIgnoreCase(prop.getCustom("ordered")))) {//TODO constant        final Collection coll = new ORecordLazyList(iFromVertex);        coll.add(iTo);        out = coll;        outType = OType.LINKLIST;      } else if (propType == null || propType == OType.LINKBAG) {        final ORidBag bag = new ORidBag();        bag.add(iTo);        out = bag;        outType = OType.LINKBAG;      } else if (propType == OType.LINK) {        out = iTo;        outType = OType.LINK;      } else        throw new ODatabaseException("Type of field provided in schema '" + prop.getType() + "' cannot be used for link creation.");    } else if (found instanceof OIdentifiable) {      if (prop != null && propType == OType.LINK)        throw new ODatabaseException(            "Type of field provided in schema '" + prop.getType() + "' cannot be used for creation to hold several links.");      if (prop != null && "true".equalsIgnoreCase(prop.getCustom("ordered"))) {//TODO constant        final Collection coll = new ORecordLazyList(iFromVertex);        coll.add(found);        coll.add(iTo);        out = coll;        outType = OType.LINKLIST;      } else {        final ORidBag bag = new ORidBag();        bag.add((OIdentifiable) found);        bag.add(iTo);        out = bag;        outType = OType.LINKBAG;      }    } else if (found instanceof ORidBag) {      // ADD THE LINK TO THE COLLECTION      out = null;      ((ORidBag) found).add(iTo.getRecord());    } else if (found instanceof Collection<?>) {      // USE THE FOUND COLLECTION      out = null;      ((Collection<Object>) found).add(iTo);    } else      throw new ODatabaseException("Relationship content is invalid on field " + iFieldName + ". Found: " + found);    if (out != null)      // OVERWRITE IT      iFromVertex.field(iFieldName, out, outType);    return out;  }
public final void handleJVMError(final Error e) {    if (jvmError.compareAndSet(null, e)) {      OLogManager.instance().errorNoDb(this, "JVM error was thrown", e);    }  }
public OBackgroundDelta recordsChangedAfterLSN(final OLogSequenceNumber lsn, final OCommandOutputListener outputListener) {    final OLogSequenceNumber endLsn;    // container of rids of changed records    final SortedSet<ORID> sortedRids = new TreeSet<>();    try {      if (!configuration.getContextConfiguration().getValueAsBoolean(OGlobalConfiguration.STORAGE_TRACK_CHANGED_RECORDS_IN_WAL)) {        throw new IllegalStateException(            "Cannot find records which were changed starting from provided LSN because tracking of rids of changed records in WAL is switched off, "                + "to switch it on please set property " + OGlobalConfiguration.STORAGE_TRACK_CHANGED_RECORDS_IN_WAL.getKey()                + " to the true value, please note that only records"                + " which are stored after this property was set will be retrieved");      }      stateLock.acquireReadLock();      try {        if (writeAheadLog == null) {          return null;        }        // we iterate till the last record is contained in wal at the moment when we call this method        endLsn = writeAheadLog.end();        if (endLsn == null || lsn.compareTo(endLsn) > 0) {          OLogManager.instance()              .warn(this, "Cannot find requested LSN=%s for database sync operation. Last available LSN is %s", lsn, endLsn);          return null;        }        if (lsn.equals(endLsn)) {          // nothing has changed          return new OBackgroundDelta(endLsn);        }        List<OWriteableWALRecord> records = writeAheadLog.next(lsn, 1);        if (records.isEmpty()) {          OLogManager.instance()              .info(this, "Cannot find requested LSN=%s for database sync operation (last available LSN is %s)", lsn, endLsn);          return null;        }        final OLogSequenceNumber freezeLsn = records.get(0).getLsn();        writeAheadLog.addCutTillLimit(freezeLsn);        try {          records = writeAheadLog.next(lsn, 1_000);          if (records.isEmpty()) {            OLogManager.instance()                .info(this, "Cannot find requested LSN=%s for database sync operation (last available LSN is %s)", lsn, endLsn);            return null;          }          // all information about changed records is contained in atomic operation metadata          long read = 0;          readLoop:          while (!records.isEmpty()) {            for (final OWALRecord record : records) {              final OLogSequenceNumber recordLSN = record.getLsn();              if (endLsn.compareTo(recordLSN) >= 0) {                if (record instanceof OFileCreatedWALRecord) {                  throw new ODatabaseException(                      "Cannot execute delta-sync because a new file has been added. Filename: '" + ((OFileCreatedWALRecord) record)                          .getFileName() + "' (id=" + ((OFileCreatedWALRecord) record).getFileId() + ")");                }                if (record instanceof OFileDeletedWALRecord) {                  throw new ODatabaseException(                      "Cannot execute delta-sync because a file has been deleted. File id: " + ((OFileDeletedWALRecord) record)                          .getFileId());                }                if (record instanceof OAtomicUnitEndRecord) {                  final OAtomicUnitEndRecord atomicUnitEndRecord = (OAtomicUnitEndRecord) record;                  if (atomicUnitEndRecord.getAtomicOperationMetadata().containsKey(ORecordOperationMetadata.RID_METADATA_KEY)) {                    final ORecordOperationMetadata recordOperationMetadata = (ORecordOperationMetadata) atomicUnitEndRecord                        .getAtomicOperationMetadata().get(ORecordOperationMetadata.RID_METADATA_KEY);                    final Set<ORID> rids = recordOperationMetadata.getValue();                    sortedRids.addAll(rids);                  }                }                read++;                if (outputListener != null) {                  outputListener.onMessage("read " + read + " records from WAL and collected " + sortedRids.size() + " records");                }              } else {                break readLoop;              }            }            records = writeAheadLog.next(records.get(records.size() - 1).getLsn(), 1_000);          }        } finally {          writeAheadLog.removeCutTillLimit(freezeLsn);        }      } catch (final IOException e) {        throw OException.wrapException(new OStorageException("Error of reading of records changed after LSN " + lsn), e);      } finally {        stateLock.releaseReadLock();      }      OBackgroundDelta b = new OBackgroundDelta(this, outputListener, sortedRids, lsn, endLsn);      return b;    } catch (final RuntimeException e) {      throw logAndPrepareForRethrow(e);    } catch (final Error e) {      throw logAndPrepareForRethrow(e);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
public Set<ORecordId> recordsChangedRecently(final int maxEntries) {    final SortedSet<ORecordId> result = new TreeSet<>();    try {      if (!OGlobalConfiguration.STORAGE_TRACK_CHANGED_RECORDS_IN_WAL.getValueAsBoolean()) {        throw new IllegalStateException(            "Cannot find records which were changed starting from provided LSN because tracking of rids of changed records in WAL is switched off, "                + "to switch it on please set property " + OGlobalConfiguration.STORAGE_TRACK_CHANGED_RECORDS_IN_WAL.getKey()                + " to the true value, please note that only records"                + " which are stored after this property was set will be retrieved");      }      stateLock.acquireReadLock();      try {        if (writeAheadLog == null) {          OLogManager.instance().warn(this, "No WAL found for database '%s'", name);          return null;        }        OLogSequenceNumber startLsn = writeAheadLog.begin();        if (startLsn == null) {          OLogManager.instance().warn(this, "The WAL is empty for database '%s'", name);          return result;        }        final OLogSequenceNumber freezeLSN = startLsn;        writeAheadLog.addCutTillLimit(freezeLSN);        try {          //reread because log may be already truncated          startLsn = writeAheadLog.begin();          if (startLsn == null) {            OLogManager.instance().warn(this, "The WAL is empty for database '%s'", name);            return result;          }          final OLogSequenceNumber endLsn = writeAheadLog.end();          if (endLsn == null) {            OLogManager.instance().warn(this, "The WAL is empty for database '%s'", name);            return result;          }          List<OWriteableWALRecord> walRecords = writeAheadLog.read(startLsn, 1_000);          if (walRecords.isEmpty()) {            OLogManager.instance()                .info(this, "Cannot find requested LSN=%s for database sync operation (record in WAL is absent)", startLsn);            return null;          }          // KEEP LAST MAX-ENTRIES TRANSACTIONS' LSN          final List<OAtomicUnitEndRecord> lastTx = new ArrayList<>(1024);          readLoop:          while (!walRecords.isEmpty()) {            for (final OWriteableWALRecord walRecord : walRecords) {              final OLogSequenceNumber recordLSN = walRecord.getLsn();              if (endLsn.compareTo(recordLSN) >= 0) {                if (walRecord instanceof OAtomicUnitEndRecord) {                  if (lastTx.size() >= maxEntries) {                    lastTx.remove(0);                  }                  lastTx.add((OAtomicUnitEndRecord) walRecord);                }              } else {                break readLoop;              }            }            walRecords = writeAheadLog.next(walRecords.get(walRecords.size() - 1).getLsn(), 1_000);          }          // COLLECT ALL THE MODIFIED RECORDS          for (final OAtomicUnitEndRecord atomicUnitEndRecord : lastTx) {            if (atomicUnitEndRecord.getAtomicOperationMetadata().containsKey(ORecordOperationMetadata.RID_METADATA_KEY)) {              final ORecordOperationMetadata recordOperationMetadata = (ORecordOperationMetadata) atomicUnitEndRecord                  .getAtomicOperationMetadata().get(ORecordOperationMetadata.RID_METADATA_KEY);              final Set<ORID> rids = recordOperationMetadata.getValue();              for (final ORID rid : rids) {                result.add((ORecordId) rid);              }            }          }          OLogManager.instance().info(this, "Found %d records changed in last %d operations", result.size(), lastTx.size());          return result;        } finally {          writeAheadLog.removeCutTillLimit(freezeLSN);        }      } catch (final IOException e) {        throw OException.wrapException(new OStorageException("Error on reading last changed records"), e);      } finally {        stateLock.releaseReadLock();      }    } catch (final RuntimeException e) {      throw logAndPrepareForRethrow(e);    } catch (final Error e) {      throw logAndPrepareForRethrow(e);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
public void startGatheringPerformanceStatisticForCurrentThread() {    try {      performanceStatisticManager.startThreadMonitoring();    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
public OSessionStoragePerformanceStatistic completeGatheringPerformanceStatisticForCurrentThread() {    try {      return performanceStatisticManager.stopThreadMonitoring();    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
public void preallocateRids(final OTransactionInternal clientTx) {    try {      checkOpenness();      checkLowDiskSpaceRequestsAndReadOnlyConditions();      final Iterable<ORecordOperation> entries = clientTx.getRecordOperations();      final TreeMap<Integer, OCluster> clustersToLock = new TreeMap<>();      final Set<ORecordOperation> newRecords = new TreeSet<>(COMMIT_RECORD_OPERATION_COMPARATOR);      for (final ORecordOperation txEntry : entries) {        if (txEntry.type == ORecordOperation.CREATED) {          newRecords.add(txEntry);          final int clusterId = txEntry.getRID().getClusterId();          clustersToLock.put(clusterId, getClusterById(clusterId));        }      }      stateLock.acquireReadLock();      try {        checkOpenness();        makeStorageDirty();        boolean rollback = false;        atomicOperationsManager.startAtomicOperation((String) null, true);        try {          lockClusters(clustersToLock);          for (final ORecordOperation txEntry : newRecords) {            final ORecord rec = txEntry.getRecord();            if (!rec.getIdentity().isPersistent()) {              if (rec.isDirty()) {                //This allocate a position for a new record                final ORecordId rid = (ORecordId) rec.getIdentity().copy();                final ORecordId oldRID = rid.copy();                final OCluster cluster = getClusterById(rid.getClusterId());                final OPhysicalPosition ppos = cluster.allocatePosition(ORecordInternal.getRecordType(rec));                rid.setClusterPosition(ppos.clusterPosition);                clientTx.updateIdentityAfterCommit(oldRID, rid);              }            } else {              //This allocate position starting from a valid rid, used in distributed for allocate the same position on other nodes              final ORecordId rid = (ORecordId) rec.getIdentity();              final OPaginatedCluster cluster = (OPaginatedCluster) getClusterById(rid.getClusterId());              OPaginatedCluster.RECORD_STATUS recordStatus = cluster.getRecordStatus(rid.getClusterPosition());              if (recordStatus == OPaginatedCluster.RECORD_STATUS.NOT_EXISTENT) {                OPhysicalPosition ppos = cluster.allocatePosition(ORecordInternal.getRecordType(rec));                while (ppos.clusterPosition < rid.getClusterPosition()) {                  ppos = cluster.allocatePosition(ORecordInternal.getRecordType(rec));                }                if (ppos.clusterPosition != rid.getClusterPosition()) {                  throw new OConcurrentCreateException(rid, new ORecordId(rid.getClusterId(), ppos.clusterPosition));                }              } else if (recordStatus == OPaginatedCluster.RECORD_STATUS.PRESENT                  || recordStatus == OPaginatedCluster.RECORD_STATUS.REMOVED) {                final OPhysicalPosition ppos = cluster.allocatePosition(ORecordInternal.getRecordType(rec));                throw new OConcurrentCreateException(rid, new ORecordId(rid.getClusterId(), ppos.clusterPosition));              }            }          }        } catch (final Exception e) {          rollback = true;          throw e;        } finally {          atomicOperationsManager.endAtomicOperation(rollback);        }      } catch (final IOException | RuntimeException ioe) {        throw OException.wrapException(new OStorageException("Could not preallocate RIDs"), ioe);      } finally {        stateLock.releaseReadLock();      }    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
private List<ORecordOperation> commit(final OTransactionInternal transaction, final boolean allocated) {    // XXX: At this moment, there are two implementations of the commit method. One for regular client transactions and one for    // implicit micro-transactions. The implementations are quite identical, but operate on slightly different data. If you change    // this method don't forget to change its counterpart:    //    //  OAbstractPaginatedStorage.commit(com.orientechnologies.orient.core.storage.impl.local.OMicroTransaction)    try {      checkOpenness();      checkLowDiskSpaceRequestsAndReadOnlyConditions();      txBegun.incrementAndGet();      final ODatabaseDocumentInternal database = transaction.getDatabase();      final OIndexManager indexManager = database.getMetadata().getIndexManager();      final TreeMap<String, OTransactionIndexChanges> indexOperations = getSortedIndexOperations(transaction);      database.getMetadata().makeThreadLocalSchemaSnapshot();      final Collection<ORecordOperation> recordOperations = transaction.getRecordOperations();      final TreeMap<Integer, OCluster> clustersToLock = new TreeMap<>();      final Map<ORecordOperation, Integer> clusterOverrides = new IdentityHashMap<>(8);      final Set<ORecordOperation> newRecords = new TreeSet<>(COMMIT_RECORD_OPERATION_COMPARATOR);      for (final ORecordOperation recordOperation : recordOperations) {        if (recordOperation.type == ORecordOperation.CREATED || recordOperation.type == ORecordOperation.UPDATED) {          final ORecord record = recordOperation.getRecord();          if (record instanceof ODocument) {            ((ODocument) record).validate();          }        }        if (recordOperation.type == ORecordOperation.UPDATED || recordOperation.type == ORecordOperation.DELETED) {          final int clusterId = recordOperation.getRecord().getIdentity().getClusterId();          clustersToLock.put(clusterId, getClusterById(clusterId));        } else if (recordOperation.type == ORecordOperation.CREATED) {          newRecords.add(recordOperation);          final ORecord record = recordOperation.getRecord();          final ORID rid = record.getIdentity();          int clusterId = rid.getClusterId();          if (record.isDirty() && clusterId == ORID.CLUSTER_ID_INVALID && record instanceof ODocument) {            // TRY TO FIX CLUSTER ID TO THE DEFAULT CLUSTER ID DEFINED IN SCHEMA CLASS            final OImmutableClass class_ = ODocumentInternal.getImmutableSchemaClass(((ODocument) record));            if (class_ != null) {              clusterId = class_.getClusterForNewInstance((ODocument) record);              clusterOverrides.put(recordOperation, clusterId);            }          }          clustersToLock.put(clusterId, getClusterById(clusterId));        }      }      final List<ORecordOperation> result = new ArrayList<>(8);      stateLock.acquireReadLock();      try {        if (modificationLock) {          final List<ORID> recordLocks = new ArrayList<>();          for (final ORecordOperation recordOperation : recordOperations) {            if (recordOperation.type == ORecordOperation.UPDATED || recordOperation.type == ORecordOperation.DELETED) {              recordLocks.add(recordOperation.getRID());            }          }          final Set<ORID> locked = transaction.getLockedRecords();          if (locked != null) {            recordLocks.removeAll(locked);          }          Collections.sort(recordLocks);          for (final ORID rid : recordLocks) {            acquireWriteLock(rid);          }        }        try {          checkOpenness();          makeStorageDirty();          boolean rollback = false;          startStorageTx(transaction);          try {            final OAtomicOperation atomicOperation = OAtomicOperationsManager.getCurrentOperation();            lockClusters(clustersToLock);            checkReadOnlyConditions();            final Map<ORecordOperation, OPhysicalPosition> positions = new IdentityHashMap<>(8);            for (final ORecordOperation recordOperation : newRecords) {              final ORecord rec = recordOperation.getRecord();              if (allocated) {                if (rec.getIdentity().isPersistent()) {                  positions.put(recordOperation, new OPhysicalPosition(rec.getIdentity().getClusterPosition()));                } else {                  throw new OStorageException("Impossible to commit a transaction with not valid rid in pre-allocated commit");                }              } else if (rec.isDirty() && !rec.getIdentity().isPersistent()) {                final ORecordId rid = (ORecordId) rec.getIdentity().copy();                final ORecordId oldRID = rid.copy();                final Integer clusterOverride = clusterOverrides.get(recordOperation);                final int clusterId = clusterOverride == null ? rid.getClusterId() : clusterOverride;                final OCluster cluster = getClusterById(clusterId);                assert atomicOperation.getCounter() == 1;                OPhysicalPosition physicalPosition = cluster.allocatePosition(ORecordInternal.getRecordType(rec));                assert atomicOperation.getCounter() == 1;                rid.setClusterId(cluster.getId());                if (rid.getClusterPosition() > -1) {                  // CREATE EMPTY RECORDS UNTIL THE POSITION IS REACHED. THIS IS THE CASE WHEN A SERVER IS OUT OF SYNC                  // BECAUSE A TRANSACTION HAS BEEN ROLLED BACK BEFORE TO SEND THE REMOTE CREATES. SO THE OWNER NODE DELETED                  // RECORD HAVING A HIGHER CLUSTER POSITION                  while (rid.getClusterPosition() > physicalPosition.clusterPosition) {                    assert atomicOperation.getCounter() == 1;                    physicalPosition = cluster.allocatePosition(ORecordInternal.getRecordType(rec));                    assert atomicOperation.getCounter() == 1;                  }                  if (rid.getClusterPosition() != physicalPosition.clusterPosition) {                    throw new OConcurrentCreateException(rid, new ORecordId(rid.getClusterId(), physicalPosition.clusterPosition));                  }                }                positions.put(recordOperation, physicalPosition);                rid.setClusterPosition(physicalPosition.clusterPosition);                transaction.updateIdentityAfterCommit(oldRID, rid);              }            }            lockRidBags(clustersToLock, indexOperations, indexManager);            checkReadOnlyConditions();            for (final ORecordOperation recordOperation : recordOperations) {              assert atomicOperation.getCounter() == 1;              commitEntry(recordOperation, positions.get(recordOperation), database.getSerializer());              assert atomicOperation.getCounter() == 1;              result.add(recordOperation);            }            lockIndexes(indexOperations);            checkReadOnlyConditions();            commitIndexes(indexOperations, atomicOperation);          } catch (final IOException | RuntimeException e) {            rollback = true;            if (e instanceof RuntimeException) {              throw ((RuntimeException) e);            } else {              throw OException.wrapException(new OStorageException("Error during transaction commit"), e);            }          } finally {            if (rollback) {              rollback(transaction);            } else {              endStorageTx(transaction, recordOperations);            }            this.transaction.set(null);          }        } finally {          atomicOperationsManager.ensureThatComponentsUnlocked();          database.getMetadata().clearThreadLocalSchemaSnapshot();        }      } finally {        try {          if (modificationLock) {            final List<ORID> recordLocks = new ArrayList<>();            for (final ORecordOperation recordOperation : recordOperations) {              if (recordOperation.type == ORecordOperation.UPDATED || recordOperation.type == ORecordOperation.DELETED) {                recordLocks.add(recordOperation.getRID());              }            }            final Set<ORID> locked = transaction.getLockedRecords();            if (locked != null) {              recordLocks.removeAll(locked);            }            for (final ORID rid : recordLocks) {              releaseWriteLock(rid);            }          }        } finally {          stateLock.releaseReadLock();        }      }      if (OLogManager.instance().isDebugEnabled()) {        OLogManager.instance()            .debug(this, "%d Committed transaction %d on database '%s' (result=%s)", Thread.currentThread().getId(),                transaction.getId(), database.getName(), result);      }      return result;    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      handleJVMError(ee);      OAtomicOperationsManager.alarmClearOfAtomicOperation();      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
@SuppressWarnings("UnusedReturnValue")  public boolean validatedPutIndexValue(int indexId, final Object key, final ORID value,      final OBaseIndexEngine.Validator<Object, ORID> validator) throws OInvalidIndexEngineIdException {    indexId = extractInternalId(indexId);    try {      if (transaction.get() != null) {        return doValidatedPutIndexValue(indexId, key, value, validator);      }      checkOpenness();      stateLock.acquireReadLock();      try {        checkOpenness();        checkLowDiskSpaceRequestsAndReadOnlyConditions();        return doValidatedPutIndexValue(indexId, key, value, validator);      } finally {        stateLock.releaseReadLock();      }    } catch (final OInvalidIndexEngineIdException ie) {      throw logAndPrepareForRethrow(ie);    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
public void rollback(final OMicroTransaction microTransaction) {    try {      checkOpenness();      stateLock.acquireReadLock();      try {        try {          checkOpenness();          if (transaction.get() == null) {            return;          }          if (transaction.get().getMicroTransaction().getId() != microTransaction.getId()) {            throw new OStorageException(                "Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be "                    + "rolled back.");          }          makeStorageDirty();          rollbackStorageTx();          microTransaction.updateRecordCacheAfterRollback();          txRollback.incrementAndGet();        } catch (final IOException e) {          throw OException.wrapException(new OStorageException("Error during micro-transaction rollback"), e);        } finally {          transaction.set(null);        }      } finally {        stateLock.releaseReadLock();      }    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
public final void renameCluster(final String oldName, final String newName) {    try {      clusterMap.put(newName.toLowerCase(configuration.getLocaleInstance()),          clusterMap.remove(oldName.toLowerCase(configuration.getLocaleInstance())));    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
@Override  public final Object command(final OCommandRequestText iCommand) {    try {      while (true) {        try {          final OCommandExecutor executor = OCommandManager.instance().getExecutor(iCommand);          // COPY THE CONTEXT FROM THE REQUEST          executor.setContext(iCommand.getContext());          executor.setProgressListener(iCommand.getProgressListener());          executor.parse(iCommand);          return executeCommand(iCommand, executor);        } catch (final ORetryQueryException ignore) {          if (iCommand instanceof OQueryAbstract) {            final OQueryAbstract query = (OQueryAbstract) iCommand;            query.reset();          }        }      }    } catch (final RuntimeException ee) {      throw logAndPrepareForRethrow(ee);    } catch (final Error ee) {      throw logAndPrepareForRethrow(ee, false);    } catch (final Throwable t) {      throw logAndPrepareForRethrow(t);    }  }
private int registerCluster(final OCluster cluster) {    final int id;    if (cluster != null) {      // CHECK FOR DUPLICATION OF NAMES      if (clusterMap.containsKey(cluster.getName().toLowerCase(configuration.getLocaleInstance()))) {        throw new OConfigurationException(            "Cannot add cluster '" + cluster.getName() + "' because it is already registered in database '" + name + "'");      }      // CREATE AND ADD THE NEW REF SEGMENT      clusterMap.put(cluster.getName().toLowerCase(configuration.getLocaleInstance()), cluster);      id = cluster.getId();    } else {      id = clusters.size();    }    setCluster(id, cluster);    return id;  }
private void checkLowDiskSpaceRequestsAndReadOnlyConditions() {    if (transaction.get() != null) {      return;    }    if (lowDiskSpace != null) {      if (checkpointInProgress.compareAndSet(false, true)) {        try {          if (writeCache.checkLowDiskSpace()) {            OLogManager.instance().error(this, "Not enough disk space, force sync will be called", null);            synch();            if (writeCache.checkLowDiskSpace()) {              throw new OLowDiskSpaceException("Error occurred while executing a write operation to database '" + name                  + "' due to limited free space on the disk (" + (lowDiskSpace.freeSpace / (1024 * 1024))                  + " MB). The database is now working in read-only mode."                  + " Please close the database (or stop OrientDB), make room on your hard drive and then reopen the database. "                  + "The minimal required space is " + (lowDiskSpace.requiredSpace / (1024 * 1024)) + " MB. "                  + "Required space is now set to " + configuration.getContextConfiguration()                  .getValueAsInteger(OGlobalConfiguration.DISK_CACHE_FREE_SPACE_LIMIT)                  + "MB (you can change it by setting parameter " + OGlobalConfiguration.DISK_CACHE_FREE_SPACE_LIMIT.getKey()                  + ") .");            } else {              lowDiskSpace = null;            }          } else {            lowDiskSpace = null;          }        } catch (final IOException e) {          throw OException.wrapException(new OStorageException("Error during low disk space handling"), e);        } finally {          checkpointInProgress.set(false);        }      }    }    checkReadOnlyConditions();  }
public Object setProperty(final String iName, final Object iValue) {    if (iValue != null) {      return properties.put(iName.toLowerCase(Locale.ENGLISH), iValue);    } else {      return properties.remove(iName.toLowerCase(Locale.ENGLISH));    }  }
public Object execute(final Map<Object, Object> iArgs) {    if (className == null)      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    final ODatabaseDocument database = getDatabase();    boolean alreadyExists = database.getMetadata().getSchema().existsClass(className);    if (!alreadyExists || !ifNotExists) {      if (clusters != null)        database.getMetadata().getSchema().createClass(className, clusters, superClasses.toArray(new OClass[0]));      else        database.getMetadata().getSchema().createClass(className, clusterIds, superClasses.toArray(new OClass[0]));    }    return database.getMetadata().getSchema().getClasses().size();  }
@Override  public long count() {    if (hasContainers.isEmpty()) {      // NO CONDITIONS: USE THE FAST COUNT      long counter = ((OrientVertex) vertex).countEdges(direction, labels);      if (limit != Integer.MAX_VALUE && counter > limit)        return limit;      return counter;    }    // ITERATE EDGES TO MATCH CONDITIONS    return super.count();  }
public Object execute(final Map<Object, Object> iArgs) {    final ODatabaseDocumentInternal database = getDatabase();    database.checkSecurity(ORule.ResourceGeneric.DATABASE, "sync", ORole.PERMISSION_UPDATE);    final OStorage stg = database.getStorage();    if (!(stg instanceof ODistributedStorage))      throw new ODistributedException("SYNC DATABASE command cannot be executed against a non distributed server");    final ODistributedStorage dStg = (ODistributedStorage) stg;    final OHazelcastPlugin dManager = (OHazelcastPlugin) dStg.getDistributedManager();    if (dManager == null || !dManager.isEnabled())      throw new OCommandExecutionException("OrientDB is not started in distributed mode");    final String databaseName = database.getName();    return dManager.installDatabase(true, databaseName, parsedStatement.isForce(), !parsedStatement.isFull());  }
public OCommandExecutorSQLAbstract createCommand(final String name) throws OCommandExecutionException {    final Class<? extends OCommandExecutorSQLAbstract> clazz = COMMANDS.get(name);    if (clazz == null) {      throw new OCommandExecutionException("Unknowned command name :" + name);    }    try {      return clazz.newInstance();    } catch (Exception e) {      throw OException.wrapException(new OCommandExecutionException("Error in creation of command " + name          + "(). Probably there is not an empty constructor or the constructor generates errors"), e);    }  }
public <RET extends ORecord> RET load(final ORID iRecordId, final String iFetchPlan, final boolean iIgnoreCache) {    return (RET) executeReadRecord((ORecordId) iRecordId, null, -1, iFetchPlan, iIgnoreCache, !iIgnoreCache, false,        OStorage.LOCKING_STRATEGY.DEFAULT, new SimpleRecordReader(prefetchRecords));  }
public ODatabase<ORecord> delete(final ORID iRecord, final int iVersion) {    ORecord record = load(iRecord);    ORecordInternal.setVersion(record, iVersion);    delete(record);    return this;  }
@Override  @Deprecated  public <REC extends ORecord> ORecordIteratorCluster<REC> browseCluster(final String iClusterName, final Class<REC> iRecordClass,      final long startClusterPosition, final long endClusterPosition, final boolean loadTombstones) {    checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, iClusterName);    checkIfActive();    final int clusterId = getClusterIdByName(iClusterName);    return new ORecordIteratorCluster<REC>(this, clusterId, startClusterPosition, endClusterPosition,        OStorage.LOCKING_STRATEGY.DEFAULT);  }
public OCommandRequest command(final OCommandRequest iCommand) {    checkSecurity(ORule.ResourceGeneric.COMMAND, ORole.PERMISSION_READ);    checkIfActive();    final OCommandRequestInternal command = (OCommandRequestInternal) iCommand;    try {      command.reset();      return command;    } catch (Exception e) {      throw OException.wrapException(new ODatabaseException("Error on command execution"), e);    }  }
public <RET extends List<?>> RET query(final OQuery<?> iCommand, final Object... iArgs) {    checkIfActive();    iCommand.reset();    return (RET) iCommand.execute(iArgs);  }
@Override  public long countClusterElements(int[] iClusterIds, boolean countTombstones) {    checkIfActive();    String name;    for (int iClusterId : iClusterIds) {      name = getClusterNameById(iClusterId);      checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, name);    }    return getStorage().count(iClusterIds, countTombstones);  }
@Override  public long countClusterElements(final String iClusterName) {    checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, iClusterName);    checkIfActive();    final int clusterId = getClusterIdByName(iClusterName);    if (clusterId < 0)      throw new IllegalArgumentException("Cluster '" + iClusterName + "' was not found");    return getStorage().count(clusterId);  }
public <DB extends ODatabaseDocument> DB checkSecurity(final ORule.ResourceGeneric resourceGeneric, final String resourceSpecific,      final int iOperation) {    if (user != null) {      try {        user.allow(resourceGeneric, resourceSpecific, iOperation);      } catch (OSecurityAccessException e) {        if (OLogManager.instance().isDebugEnabled())          OLogManager.instance()              .debug(this, "User '%s' tried to access the reserved resource '%s.%s', operation '%s'", getUser(), resourceGeneric,                  resourceSpecific, iOperation);        throw e;      }    }    return (DB) this;  }
public <DB extends ODatabaseDocument> DB checkSecurity(final ORule.ResourceGeneric iResourceGeneric, final int iOperation,      final Object... iResourcesSpecific) {    if (user != null) {      try {        if (iResourcesSpecific.length != 0) {          for (Object target : iResourcesSpecific) {            if (target != null) {              user.allow(iResourceGeneric, target.toString(), iOperation);            } else              user.allow(iResourceGeneric, null, iOperation);          }        } else          user.allow(iResourceGeneric, null, iOperation);      } catch (OSecurityAccessException e) {        if (OLogManager.instance().isDebugEnabled())          OLogManager.instance()              .debug(this, "[checkSecurity] User '%s' tried to access the reserved resource '%s', target(s) '%s', operation '%s'",                  getUser(), iResourceGeneric, Arrays.toString(iResourcesSpecific), iOperation);        throw e;      }    }    return (DB) this;  }
public <DB extends ODatabaseDocument> DB checkSecurity(final ORule.ResourceGeneric iResourceGeneric, final int iOperation,      final Object iResourceSpecific) {    checkOpenness();    if (user != null) {      try {        if (iResourceSpecific != null)          user.allow(iResourceGeneric, iResourceSpecific.toString(), iOperation);        else          user.allow(iResourceGeneric, null, iOperation);      } catch (OSecurityAccessException e) {        if (OLogManager.instance().isDebugEnabled())          OLogManager.instance()              .debug(this, "[checkSecurity] User '%s' tried to access the reserved resource '%s', target '%s', operation '%s'",                  getUser(), iResourceGeneric, iResourceSpecific, iOperation);        throw e;      }    }    return (DB) this;  }
public <DB extends ODatabase> DB setStatus(final STATUS status) {    checkIfActive();    setStatusInternal(status);    return (DB) this;  }
public void setUser(final OSecurityUser user) {    checkIfActive();    if (user instanceof OUser) {      OMetadata metadata = getMetadata();      if (metadata != null) {        final OSecurity security = metadata.getSecurity();        this.user = new OImmutableUser(security.getVersion(), (OUser) user);      } else        this.user = new OImmutableUser(-1, (OUser) user);    } else      this.user = (OImmutableUser) user;  }
public <DB extends ODatabase<?>> DB registerHook(final ORecordHook iHookImpl, final ORecordHook.HOOK_POSITION iPosition) {    checkOpenness();    checkIfActive();    final Map<ORecordHook, ORecordHook.HOOK_POSITION> tmp = new LinkedHashMap<ORecordHook, ORecordHook.HOOK_POSITION>(hooks);    tmp.put(iHookImpl, iPosition);    hooks.clear();    for (ORecordHook.HOOK_POSITION p : ORecordHook.HOOK_POSITION.values()) {      for (Map.Entry<ORecordHook, ORecordHook.HOOK_POSITION> e : tmp.entrySet()) {        if (e.getValue() == p)          hooks.put(e.getKey(), e.getValue());      }    }    compileHooks();    return (DB) this;  }
public <DB extends ODatabase<?>> DB registerHook(final ORecordHook iHookImpl) {    return (DB) registerHook(iHookImpl, ORecordHook.HOOK_POSITION.REGULAR);  }
public <DB extends ODatabase<?>> DB unregisterHook(final ORecordHook iHookImpl) {    checkIfActive();    if (iHookImpl != null) {      iHookImpl.onUnregister();      hooks.remove(iHookImpl);      compileHooks();    }    return (DB) this;  }
public ORecordHook.RESULT callbackHooks(final ORecordHook.TYPE type, final OIdentifiable id) {    if (id == null || hooks.isEmpty() || id.getIdentity().getClusterId() == 0)      return ORecordHook.RESULT.RECORD_NOT_CHANGED;    final ORecordHook.SCOPE scope = ORecordHook.SCOPE.typeToScope(type);    final int scopeOrdinal = scope.ordinal();    final ORID identity = id.getIdentity().copy();    if (!pushInHook(identity))      return ORecordHook.RESULT.RECORD_NOT_CHANGED;    try {      final ORecord rec = id.getRecord();      if (rec == null)        return ORecordHook.RESULT.RECORD_NOT_CHANGED;      final OScenarioThreadLocal.RUN_MODE runMode = OScenarioThreadLocal.INSTANCE.getRunMode();      boolean recordChanged = false;      for (ORecordHook hook : hooksByScope[scopeOrdinal]) {        switch (runMode) {        case DEFAULT: // NON_DISTRIBUTED OR PROXIED DB          if (getStorage().isDistributed()              && hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.TARGET_NODE)            // SKIP            continue;          break; // TARGET NODE        case RUNNING_DISTRIBUTED:          if (hook.getDistributedExecutionMode() == ORecordHook.DISTRIBUTED_EXECUTION_MODE.SOURCE_NODE)            continue;        }        final ORecordHook.RESULT res = hook.onTrigger(type, rec);        if (res == ORecordHook.RESULT.RECORD_CHANGED)          recordChanged = true;        else if (res == ORecordHook.RESULT.SKIP_IO)          // SKIP IO OPERATION          return res;        else if (res == ORecordHook.RESULT.SKIP)          // SKIP NEXT HOOKS AND RETURN IT          return res;        else if (res == ORecordHook.RESULT.RECORD_REPLACED)          return res;      }      return recordChanged ? ORecordHook.RESULT.RECORD_CHANGED : ORecordHook.RESULT.RECORD_NOT_CHANGED;    } finally {      popInHook(identity);    }  }
public <DB extends ODatabaseDocument> DB setValidationEnabled(final boolean iEnabled) {    set(ATTRIBUTES.VALIDATION, iEnabled);    return (DB) this;  }
public ODatabaseDocument delete(final ORID iRecord) {    checkOpenness();    checkIfActive();    final ORecord rec = load(iRecord);    if (rec != null)      delete(rec);    return this;  }
public <RET extends ORecord> RET load(final ORecord iRecord, final String iFetchPlan, final boolean iIgnoreCache) {    return (RET) executeReadRecord((ORecordId) iRecord.getIdentity(), iRecord, -1, iFetchPlan, iIgnoreCache, !iIgnoreCache, false,        OStorage.LOCKING_STRATEGY.NONE, new SimpleRecordReader(prefetchRecords));  }
public boolean executeHideRecord(OIdentifiable record, final OPERATION_MODE iMode) {    checkOpenness();    checkIfActive();    final ORecordId rid = (ORecordId) record.getIdentity();    if (rid == null)      throw new ODatabaseException(          "Cannot hide record because it has no identity. Probably was created from scratch or contains projections of fields rather than a full record");    if (!rid.isValid())      return false;    checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_DELETE, getClusterNameById(rid.getClusterId()));    getMetadata().makeThreadLocalSchemaSnapshot();    if (record instanceof ODocument)      ODocumentInternal.checkClass((ODocument) record, this);    ORecordSerializationContext.pushContext();    try {      final OStorageOperationResult<Boolean> operationResult;      operationResult = getStorage().hideRecord(rid, iMode.ordinal(), null);      // REMOVE THE RECORD FROM 1 AND 2 LEVEL CACHES      if (!operationResult.isMoved())        getLocalCache().deleteRecord(rid);      return operationResult.getResult();    } finally {      ORecordSerializationContext.pullContext();      getMetadata().clearThreadLocalSchemaSnapshot();    }  }
@Override  public void freeze(final boolean throwException) {    checkOpenness();    if (!(getStorage() instanceof OFreezableStorageComponent)) {      OLogManager.instance().error(this,          "Only local paginated storage supports freeze. If you are using remote client please use OServerAdmin instead", null);      return;    }    final long startTime = Orient.instance().getProfiler().startChrono();    final OFreezableStorageComponent storage = getFreezableStorage();    if (storage != null) {      storage.freeze(throwException);    }    Orient.instance().getProfiler()        .stopChrono("db." + getName() + ".freeze", "Time to freeze the database", startTime, "db.*.freeze");  }
public ORecordIteratorClass<ODocument> browseClass(final String iClassName, final boolean iPolymorphic) {    if (getMetadata().getImmutableSchemaSnapshot().getClass(iClassName) == null)      throw new IllegalArgumentException("Class '" + iClassName + "' not found in current database");    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_READ, iClassName);    return new ORecordIteratorClass<ODocument>(this, iClassName, iPolymorphic, false);  }
@Override  public ORecordIteratorCluster<ODocument> browseCluster(final String iClusterName) {    checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, iClusterName);    return new ORecordIteratorCluster<ODocument>(this, getClusterIdByName(iClusterName));  }
@Override  @Deprecated  public ORecordIteratorCluster<ODocument> browseCluster(String iClusterName, long startClusterPosition, long endClusterPosition,      boolean loadTombstones) {    checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, iClusterName);    return new ORecordIteratorCluster<ODocument>(this, getClusterIdByName(iClusterName), startClusterPosition, endClusterPosition,        OStorage.LOCKING_STRATEGY.DEFAULT);  }
@Override  public <RET extends ORecord> RET save(final ORecord iRecord) {    return (RET) save(iRecord, null, OPERATION_MODE.SYNCHRONOUS, false, null, null);  }
@Override  public <RET extends ORecord> RET save(final ORecord iRecord, final OPERATION_MODE iMode, boolean iForceCreate,      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {    return save(iRecord, null, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);  }
@Override  public <RET extends ORecord> RET save(ORecord iRecord, String iClusterName, final OPERATION_MODE iMode, boolean iForceCreate,      final ORecordCallback<? extends Number> iRecordCreatedCallback, ORecordCallback<Integer> iRecordUpdatedCallback) {    checkOpenness();    if (iRecord instanceof OVertex) {      iRecord = iRecord.getRecord();    }    if (iRecord instanceof OEdge) {      if (((OEdge) iRecord).isLightweight()) {        iRecord = ((OEdge) iRecord).getFrom();      } else {        iRecord = iRecord.getRecord();      }    }    ODirtyManager dirtyManager = ORecordInternal.getDirtyManager(iRecord);    if (iRecord instanceof OElement && dirtyManager != null && dirtyManager.getReferences() != null && !dirtyManager.getReferences()        .isEmpty()) {      if ((((OElement) iRecord).isVertex() || ((OElement) iRecord).isEdge()) && !getTransaction().isActive() && inHook.isEmpty()) {        return saveGraph(iRecord, iClusterName, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);      }    }    return saveInternal(iRecord, iClusterName, iMode, iForceCreate, iRecordCreatedCallback, iRecordUpdatedCallback);  }
public long countView(final String viewName) {    final OView cls = getMetadata().getImmutableSchemaSnapshot().getView(viewName);    if (cls == null)      throw new IllegalArgumentException("View '" + cls + "' not found in database");    return countClass(cls, false);  }
public long countClass(final String iClassName, final boolean iPolymorphic) {    final OClass cls = getMetadata().getImmutableSchemaSnapshot().getClass(iClassName);    if (cls == null)      throw new IllegalArgumentException("Class '" + cls + "' not found in database");    return countClass(cls, iPolymorphic);  }
@Override  public ODatabaseDocumentAbstract activateOnCurrentThread() {    final ODatabaseRecordThreadLocal tl = ODatabaseRecordThreadLocal.instance();    if (tl != null)      tl.set(this);    return this;  }
public void register(final OEncryption iEncryption) {    try {      final String name = iEncryption.name();      if (instances.containsKey(name))        throw new IllegalArgumentException("Encryption with name '" + name + "' was already registered");      if (classes.containsKey(name))        throw new IllegalArgumentException("Encryption with name '" + name + "' was already registered");      instances.put(name, iEncryption);    } catch (Exception e) {      OLogManager.instance().error(this, "Cannot register storage encryption algorithm '%s'", e, iEncryption);    }  }
public byte[] getBytes(long pos, int length) throws SQLException {    if (pos < 1)      throw new SQLException("The position of the first byte in the BLOB value to be " + "extracted cannot be less than 1");    if (length < 0)      throw new SQLException(          "The number of the consecutive bytes in the BLOB value to " + "be extracted cannot be a negative number");    int relativeIndex = this.getRelativeIndex(pos);    ByteBuffer buffer = ByteBuffer.allocate(length);    int j;    for (j = 0; j < length; j++) {      if (relativeIndex == currentChunk.length) {        // go to the next chunk, if any...        currentChunkIndex++;        if (currentChunkIndex < binaryDataChunks.size()) {          // the next chunk exists so we update the relative index and          // the current chunk reference          relativeIndex = 0;          currentChunk = binaryDataChunks.get(currentChunkIndex);        } else          // exit from the loop: there are no more bytes to be read          break;      }      buffer.put(currentChunk[relativeIndex]);      relativeIndex++;    }    return buffer.array();  }
private int getRelativeIndex(long pos) {    int currentSize = 0;    currentChunkIndex = 0;    // loop until we find the chuks holding the given position    while (pos >= (currentSize += binaryDataChunks.get(currentChunkIndex).length))      currentChunkIndex++;    currentChunk = binaryDataChunks.get(currentChunkIndex);    currentSize -= currentChunk.length;    // the position referred to the target binary chunk    int relativePosition = (int) (pos - currentSize);    // the index of the first byte to be returned    return relativePosition - 1;  }
protected String parserOptionalWord(final boolean iUpperCase) {    parserPreviousPos = parserCurrentPos;    parserNextWord(iUpperCase);    if (parserLastWord.length() == 0)      return null;    return parserLastWord.toString();  }
protected String parserRequiredWord(final boolean iUpperCase, final String iCustomMessage, String iSeparators) {    if (iSeparators == null)      iSeparators = " ()=><,\r\n";    parserNextWord(iUpperCase, iSeparators);    if (parserLastWord.length() == 0)      throwSyntaxErrorException(iCustomMessage);    if (parserLastWord.charAt(0) == '`' && parserLastWord.charAt(parserLastWord.length() - 1) == '`') {      return parserLastWord.substring(1, parserLastWord.length() - 1);    }    return parserLastWord.toString();  }
protected int parserNextChars(final boolean iUpperCase, final boolean iMandatory, final String... iCandidateWords) {    parserPreviousPos = parserCurrentPos;    parserSkipWhiteSpaces();    parserEscapeSequenceCount = 0;    parserLastWord.setLength(0);    final String[] processedWords = Arrays.copyOf(iCandidateWords, iCandidateWords.length);    // PARSE THE CHARS    final String text2Use = iUpperCase ? parserTextUpperCase : parserText;    final int max = text2Use.length();    parserCurrentPos = parserCurrentPos + parserTextUpperCase.length() - parserText.length();    // PARSE TILL 1 CHAR AFTER THE END TO SIMULATE A SEPARATOR AS EOF    for (int i = 0; parserCurrentPos <= max; ++i) {      final char ch = parserCurrentPos < max ? text2Use.charAt(parserCurrentPos) : '\n';      final boolean separator = ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t' || ch == '(';      if (!separator)        parserLastWord.append(ch);      // CLEAR CANDIDATES      int candidatesWordsCount = 0;      int candidatesWordsPos = -1;      for (int c = 0; c < processedWords.length; ++c) {        final String w = processedWords[c];        if (w != null) {          final int wordSize = w.length();          if ((separator && wordSize > i) || (!separator && (i > wordSize - 1 || w.charAt(i) != ch)))            // DISCARD IT            processedWords[c] = null;          else {            candidatesWordsCount++;            if (candidatesWordsCount == 1)              // REMEMBER THE POSITION              candidatesWordsPos = c;          }        }      }      if (candidatesWordsCount == 1) {        // ONE RESULT, CHECKING IF FOUND        final String w = processedWords[candidatesWordsPos];        if (w.length() == i + (separator ? 0 : 1) && !Character.isLetter(ch))          // FOUND!          return candidatesWordsPos;      }      if (candidatesWordsCount == 0 || separator)        break;      parserCurrentPos++;    }    if (iMandatory)      throwSyntaxErrorException("Found unexpected keyword '" + parserLastWord + "' while it was expected '"          + Arrays.toString(iCandidateWords) + "'");    return -1;  }
protected boolean parserOptionalKeyword(final String... iWords) {    parserNextWord(true, " \r\n,");    if (parserLastWord.length() == 0)      return false;    // FOUND: CHECK IF IT'S IN RANGE    boolean found = iWords.length == 0;    for (String w : iWords) {      if (parserLastWord.toString().equals(w)) {        found = true;        break;      }    }    if (!found)      throwSyntaxErrorException("Found unexpected keyword '" + parserLastWord + "' while it was expected '"          + Arrays.toString(iWords) + "'");    return true;  }
private boolean parserCheckSeparator(final char c, final String iSeparatorChars) {    for (int sepIndex = 0; sepIndex < iSeparatorChars.length(); ++sepIndex) {      if (iSeparatorChars.charAt(sepIndex) == c) {        parserLastSeparator = c;        return true;      }    }    return false;  }
public LinkedList<OrientVertex> getPath() {    final LinkedList<OrientVertex> path = new LinkedList<OrientVertex>();    OrientVertex step = paramDestinationVertex;    // Check if a path exists    if (predecessors.get(step.getIdentity()) == null)      return null;    path.add(step);    while (predecessors.get(step.getIdentity()) != null) {      step = predecessors.get(step.getIdentity());      path.add(step);    }    // Put it into the correct order    Collections.reverse(path);    return path;  }
public Object execute(final Map<Object, Object> iArgs) {    if (className == null) {      throw new OCommandExecutionException("Cannot execute the command because it has not been parsed yet");    }    final ODatabaseDocument database = getDatabase();    if (ifExists && !database.getMetadata().getSchema().existsClass(className)) {      return true;    }    final OClass cls = database.getMetadata().getSchema().getClass(className);    if (cls == null) {      return null;    }    final long records = cls.count(true);    if (records > 0 && !unsafe) {      // NOT EMPTY, CHECK IF CLASS IS OF VERTEX OR EDGES      if (cls.isSubClassOf("V")) {        // FOUND VERTEX CLASS        throw new OCommandExecutionException("'DROP CLASS' command cannot drop class '" + className            + "' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it");      } else if (cls.isSubClassOf("E")) {        // FOUND EDGE CLASS        throw new OCommandExecutionException("'DROP CLASS' command cannot drop class '" + className            + "' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it");      }    }    database.getMetadata().getSchema().dropClass(className);    if (records > 0 && unsafe) {      // NOT EMPTY, CHECK IF CLASS IS OF VERTEX OR EDGES      if (cls.isSubClassOf("V")) {        // FOUND VERTICES        if (unsafe)          OLogManager.instance().warn(this,              "Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges", className,              records);      } else if (cls.isSubClassOf("E")) {        // FOUND EDGES        OLogManager.instance().warn(this,            "Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices", className, records);      }    }    return true;  }
private void clearConfigurationFiles() throws IOException {    final Path file = storagePath.resolve(NAME);    Files.deleteIfExists(file);    final Path backupFile = storagePath.resolve(BACKUP_NAME);    Files.deleteIfExists(backupFile);  }
private void convert(final int iIndex) {    if (converted || !convertToRecord)      return;    Object o = super.get(iIndex);    if (o == null) {      final ODatabaseDocument database = getDatabase().getUnderlying();      o = recordList.get(iIndex);      ODocument doc;      if (o instanceof ORID) {        doc = database.load((ORID) o, fetchPlan);      } else {        doc = (ODocument) o;      }      if (o == null) {        OLogManager.instance().warn(            this,            "Record " + ((OObjectProxyMethodHandler) sourceRecord.getHandler()).getDoc().getIdentity()                + " references a deleted instance");        return;      }      super.set(          iIndex,          (TYPE) OObjectEntityEnhancer.getInstance().getProxiedInstance(doc.getClassName(), getDatabase().getEntityManager(), doc,              sourceRecord));    }  }
public int getAsByteArrayOffset() {    if (position >= length)      return -1;    final int begin = position;    final int size = OBinaryProtocol.bytes2int(buffer, position);    position += OBinaryProtocol.SIZE_INT + size;    return begin;  }
protected String extract(String tokenType) {		OAuth2AccessToken accessToken = getToken();		return String.format("%s %s", tokenType, accessToken.getValue());	}
public OAuth2AccessToken getToken() {		OAuth2AccessToken accessToken = oAuth2ClientContext.getAccessToken();		if (accessToken == null || accessToken.isExpired()) {			try {				accessToken = acquireAccessToken();			}			catch (UserRedirectRequiredException e) {				oAuth2ClientContext.setAccessToken(null);				String stateKey = e.getStateKey();				if (stateKey != null) {					Object stateToPreserve = e.getStateToPreserve();					if (stateToPreserve == null) {						stateToPreserve = "NONE";					}					oAuth2ClientContext.setPreservedState(stateKey, stateToPreserve);				}				throw e;			}		}		return accessToken;	}
protected OAuth2AccessToken acquireAccessToken()			throws UserRedirectRequiredException {		AccessTokenRequest tokenRequest = oAuth2ClientContext.getAccessTokenRequest();		if (tokenRequest == null) {			throw new AccessTokenRequiredException(					"Cannot find valid context on request for resource '"							+ resource.getId() + "'.",					resource);		}		String stateKey = tokenRequest.getStateKey();		if (stateKey != null) {			tokenRequest.setPreservedState(					oAuth2ClientContext.removePreservedState(stateKey));		}		OAuth2AccessToken existingToken = oAuth2ClientContext.getAccessToken();		if (existingToken != null) {			oAuth2ClientContext.setAccessToken(existingToken);		}		OAuth2AccessToken obtainableAccessToken;		obtainableAccessToken = accessTokenProvider.obtainAccessToken(resource,				tokenRequest);		if (obtainableAccessToken == null || obtainableAccessToken.getValue() == null) {			throw new IllegalStateException(					" Access token provider returned a null token, which is illegal according to the contract.");		}		oAuth2ClientContext.setAccessToken(obtainableAccessToken);		return obtainableAccessToken;	}
public boolean copyToken() {		if (context.getAccessToken() == null) {			Authentication authentication = SecurityContextHolder.getContext()					.getAuthentication();			if (authentication != null) {				Object details = authentication.getDetails();				if (details instanceof OAuth2AuthenticationDetails) {					OAuth2AuthenticationDetails holder = (OAuth2AuthenticationDetails) details;					String token = holder.getTokenValue();					DefaultOAuth2AccessToken accessToken = new DefaultOAuth2AccessToken(							token);					String tokenType = holder.getTokenType();					if (tokenType != null) {						accessToken.setTokenType(tokenType);					}					context.setAccessToken(accessToken);					return true;				}			}		}		return false;	}
public void put(String name, Class<?> clazz) {		BeanDefinition definition = new RootBeanDefinition(clazz);		beanFactory.registerBeanDefinition(name, definition);	}
protected void parseNode(NodeModel node, Element element) {		TaskModel task = (TaskModel)node;		task.setForm(element.getAttribute(ATTR_FORM));		task.setAssignee(element.getAttribute(ATTR_ASSIGNEE));		task.setExpireTime(element.getAttribute(ATTR_EXPIRETIME));		task.setAutoExecute(element.getAttribute(ATTR_AUTOEXECUTE));		task.setCallback(element.getAttribute(ATTR_CALLBACK));		task.setReminderTime(element.getAttribute(ATTR_REMINDERTIME));		task.setReminderRepeat(element.getAttribute(ATTR_REMINDERREPEAT));		task.setPerformType(element.getAttribute(ATTR_PERFORMTYPE));		task.setTaskType(element.getAttribute(ATTR_TASKTYPE));		task.setAssignmentHandler(element.getAttribute(ATTR_ASSIGNEE_HANDLER));        NodeList fieldList = element.getElementsByTagName(ATTR_FIELD);        List<FieldModel> fields = new ArrayList<FieldModel>();        for(int i = 0; i < fieldList.getLength(); i++) {            Element item = (Element)fieldList.item(i);            FieldModel fieldModel = new FieldModel();            fieldModel.setName(item.getAttribute(ATTR_NAME));            fieldModel.setDisplayName(item.getAttribute(ATTR_DISPLAYNAME));            fieldModel.setType(item.getAttribute(ATTR_TYPE));            NodeList attrList = item.getElementsByTagName(ATTR_ATTR);            for(int j = 0; j < attrList.getLength(); j++) {                Node attr = attrList.item(j);                fieldModel.addAttr(((Element) attr).getAttribute(ATTR_NAME),                        ((Element) attr).getAttribute(ATTR_VALUE));            }            fields.add(fieldModel);        }        task.setFields(fields);	}
public static String parseTime(Object date) {		if(date == null) return null;		if(date instanceof Date) {			return new DateTime((Date)date).toString(DATE_FORMAT_DEFAULT);		} else if(date instanceof String) {			return String.valueOf(date);		}		return "";	}
public static Date processTime(Map<String, Object> args, String parameter) {		if(StringHelper.isEmpty(parameter)) return null;		Object data = args.get(parameter);		if(data == null) data = parameter;				Date result = null;		if(data instanceof Date) {			return (Date)data;		} else if(data instanceof Long) {			return new Date((Long)data);		} else if(data instanceof String) {			//TODO 1.4-dev ignore		}		return result;	}
protected Connection getConnection() throws SQLException {        Config config = JfinalHelper.getConfig();		Connection conn = config.getThreadLocalConnection();		if(conn == null) {			conn = config.getConnection();            conn.setAutoCommit(true);		}		return conn;	}
public Task complete(String taskId, String operator) {		return complete(taskId, operator, null);	}
public Task complete(String taskId, String operator, Map<String, Object> args) {		Task task = access().getTask(taskId);		AssertHelper.notNull(task, "指定的任务[id=" + taskId + "]不存在");		task.setVariable(JsonHelper.toJson(args));		if(!isAllowed(task, operator)) {			throw new SnakerException("当前参与者[" + operator + "]不允许执行任务[taskId=" + taskId + "]");		}		HistoryTask history = new HistoryTask(task);		history.setFinishTime(DateHelper.getTime());		history.setTaskState(STATE_FINISH);		history.setOperator(operator);		if(history.getActorIds() == null) {			List<TaskActor> actors = access().getTaskActorsByTaskId(task.getId());			String[] actorIds = new String[actors.size()];			for(int i = 0; i < actors.size(); i++) {				actorIds[i] = actors.get(i).getActorId();			}			history.setActorIds(actorIds);		}		access().saveHistory(history);		access().deleteTask(task);        Completion completion = getCompletion();        if(completion != null) {            completion.complete(history);        }		return task;	}
public HistoryTask history(Execution execution, CustomModel model) {		HistoryTask historyTask = new HistoryTask();		historyTask.setId(StringHelper.getPrimaryKey());		historyTask.setOrderId(execution.getOrder().getId());		String currentTime = DateHelper.getTime();		historyTask.setCreateTime(currentTime);		historyTask.setFinishTime(currentTime);		historyTask.setDisplayName(model.getDisplayName());		historyTask.setTaskName(model.getName());		historyTask.setTaskState(STATE_FINISH);		historyTask.setTaskType(TaskType.Record.ordinal());		historyTask.setParentTaskId(execution.getTask() == null ?				START : execution.getTask().getId());		historyTask.setVariable(JsonHelper.toJson(execution.getArgs()));		access().saveHistory(historyTask);		return historyTask;	}
public Task take(String taskId, String operator) {		Task task = access().getTask(taskId);		AssertHelper.notNull(task, "指定的任务[id=" + taskId + "]不存在");		if(!isAllowed(task, operator)) {			throw new SnakerException("当前参与者[" + operator + "]不允许提取任务[taskId=" + taskId + "]");		}		task.setOperator(operator);		task.setFinishTime(DateHelper.getTime());		access().updateTask(task);		return task;	}
public Task resume(String taskId, String operator) {        HistoryTask histTask = access().getHistTask(taskId);        AssertHelper.notNull(histTask, "指定的历史任务[id=" + taskId + "]不存在");        boolean isAllowed = true;        if(StringHelper.isNotEmpty(histTask.getOperator())) {            isAllowed = histTask.getOperator().equals(operator);        }        if(isAllowed) {            Task task = histTask.undoTask();            task.setId(StringHelper.getPrimaryKey());            task.setCreateTime(DateHelper.getTime());            access().saveTask(task);            assignTask(task.getId(), task.getOperator());            return task;        } else {            throw new SnakerException("当前参与者[" + operator + "]不允许唤醒历史任务[taskId=" + taskId + "]");        }    }
public void addTaskActor(String taskId, Integer performType, String... actors) {		Task task = access().getTask(taskId);		AssertHelper.notNull(task, "指定的任务[id=" + taskId + "]不存在");		if(!task.isMajor()) return;		if(performType == null) performType = task.getPerformType();		if(performType == null) performType = 0;		switch(performType) {		case 0:			assignTask(task.getId(), actors);			Map<String, Object> data = task.getVariableMap();			String oldActor = (String)data.get(Task.KEY_ACTOR);			data.put(Task.KEY_ACTOR, oldActor + "," + StringHelper.getStringByArray(actors));			task.setVariable(JsonHelper.toJson(data));			access().updateTask(task);			break;		case 1:			try {				for(String actor : actors) {					Task newTask = (Task)task.clone();					newTask.setId(StringHelper.getPrimaryKey());					newTask.setCreateTime(DateHelper.getTime());					newTask.setOperator(actor);					Map<String, Object> taskData = task.getVariableMap();					taskData.put(Task.KEY_ACTOR, actor);					task.setVariable(JsonHelper.toJson(taskData));					access().saveTask(newTask);					assignTask(newTask.getId(), actor);				}			} catch(CloneNotSupportedException ex) {				throw new SnakerException("任务对象不支持复制", ex.getCause());			}			break;		default :			break;		}	}
public void removeTaskActor(String taskId, String... actors) {		Task task = access().getTask(taskId);		AssertHelper.notNull(task, "指定的任务[id=" + taskId + "]不存在");		if(actors == null || actors.length == 0) return;		if(task.isMajor()) {			access().removeTaskActor(task.getId(), actors);			Map<String, Object> taskData = task.getVariableMap();			String actorStr = (String)taskData.get(Task.KEY_ACTOR);			if(StringHelper.isNotEmpty(actorStr)) {				String[] actorArray = actorStr.split(",");				StringBuilder newActor = new StringBuilder(actorStr.length());				boolean isMatch;				for(String actor : actorArray) {					isMatch = false;					if(StringHelper.isEmpty(actor)) continue;					for(String removeActor : actors) {						if(actor.equals(removeActor)) {							isMatch = true;							break;						}					}					if(isMatch) continue;					newActor.append(actor).append(",");				}				newActor.deleteCharAt(newActor.length() - 1);				taskData.put(Task.KEY_ACTOR, newActor.toString());				task.setVariable(JsonHelper.toJson(taskData));				access().updateTask(task);			}		}	}
public Task withdrawTask(String taskId, String operator) {		HistoryTask hist = access().getHistTask(taskId);		AssertHelper.notNull(hist, "指定的历史任务[id=" + taskId + "]不存在");		List<Task> tasks;		if(hist.isPerformAny()) {			tasks = access().getNextActiveTasks(hist.getId());		} else {			tasks = access().getNextActiveTasks(hist.getOrderId(), 					hist.getTaskName(), hist.getParentTaskId());		}		if(tasks == null || tasks.isEmpty()) {			throw new SnakerException("后续活动任务已完成或不存在，无法撤回.");		}		for(Task task : tasks) {			access().deleteTask(task);		}				Task task = hist.undoTask();		task.setId(StringHelper.getPrimaryKey());		task.setCreateTime(DateHelper.getTime());		access().saveTask(task);		assignTask(task.getId(), task.getOperator());		return task;	}
public Task rejectTask(ProcessModel model, Task currentTask) {		String parentTaskId = currentTask.getParentTaskId();		if(StringHelper.isEmpty(parentTaskId) || parentTaskId.equals(START)) {			throw new SnakerException("上一步任务ID为空，无法驳回至上一步处理");		}		NodeModel current = model.getNode(currentTask.getTaskName());		HistoryTask history = access().getHistTask(parentTaskId);		NodeModel parent = model.getNode(history.getTaskName());		if(!NodeModel.canRejected(current, parent)) {			throw new SnakerException("无法驳回至上一步处理，请确认上一步骤并非fork、join、suprocess以及会签任务");		}		Task task = history.undoTask();		task.setId(StringHelper.getPrimaryKey());		task.setCreateTime(DateHelper.getTime());		task.setOperator(history.getOperator());		access().saveTask(task);		assignTask(task.getId(), task.getOperator());		return task;	}
private void assignTask(String taskId, String... actorIds) {		if(actorIds == null || actorIds.length == 0) return;		for(String actorId : actorIds) {			//修复当actorId为null的bug			if(StringHelper.isEmpty(actorId)) continue;			TaskActor taskActor = new TaskActor();			taskActor.setTaskId(taskId);			taskActor.setActorId(actorId);			access().saveTaskActor(taskActor);		}	}
public List<Task> createNewTask(String taskId, int taskType, String... actors) {		Task task = access().getTask(taskId);		AssertHelper.notNull(task, "指定的任务[id=" + taskId + "]不存在");		List<Task> tasks = new ArrayList<Task>();		try {			Task newTask = (Task)task.clone();			newTask.setTaskType(taskType);			newTask.setCreateTime(DateHelper.getTime());			newTask.setParentTaskId(taskId);			tasks.add(saveTask(newTask, actors));		} catch (CloneNotSupportedException e) {			throw new SnakerException("任务对象不支持复制", e.getCause());		}		return tasks;	}
public TaskModel getTaskModel(String taskId) {        Task task = access().getTask(taskId);        AssertHelper.notNull(task);        Order order = access().getOrder(task.getOrderId());        AssertHelper.notNull(order);        Process process = ServiceContext.getEngine().process().getProcessById(order.getProcessId());        ProcessModel model = process.getModel();        NodeModel nodeModel = model.getNode(task.getTaskName());        AssertHelper.notNull(nodeModel, "任务id无法找到节点模型.");        if(nodeModel instanceof TaskModel) {            return (TaskModel)nodeModel;        } else {            throw new IllegalArgumentException("任务id找到的节点模型不匹配");        }    }
public List<Task> createTask(TaskModel taskModel, Execution execution) {		List<Task> tasks = new ArrayList<Task>();				Map<String, Object> args = execution.getArgs();		if(args == null) args = new HashMap<String, Object>();		Date expireDate = DateHelper.processTime(args, taskModel.getExpireTime());		Date remindDate = DateHelper.processTime(args, taskModel.getReminderTime());		String form = (String)args.get(taskModel.getForm());		String actionUrl = StringHelper.isEmpty(form) ? taskModel.getForm() : form;				String[] actors = getTaskActors(taskModel, execution);		args.put(Task.KEY_ACTOR, StringHelper.getStringByArray(actors));		Task task = createTaskBase(taskModel, execution);		task.setActionUrl(actionUrl);		task.setExpireDate(expireDate);		task.setExpireTime(DateHelper.parseTime(expireDate));        task.setVariable(JsonHelper.toJson(args));				if(taskModel.isPerformAny()) {			//任务执行方式为参与者中任何一个执行即可驱动流程继续流转，该方法只产生一个task			task = saveTask(task, actors);			task.setRemindDate(remindDate);			tasks.add(task);		} else if(taskModel.isPerformAll()){			//任务执行方式为参与者中每个都要执行完才可驱动流程继续流转，该方法根据参与者个数产生对应的task数量			for(String actor : actors) {                Task singleTask;                try {                    singleTask = (Task) task.clone();                } catch (CloneNotSupportedException e) {                    singleTask = task;                }                singleTask = saveTask(singleTask, actor);                singleTask.setRemindDate(remindDate);                tasks.add(singleTask);			}		}		return tasks;	}
private Task createTaskBase(TaskModel model, Execution execution) {		Task task = new Task();		task.setOrderId(execution.getOrder().getId());		task.setTaskName(model.getName());		task.setDisplayName(model.getDisplayName());		task.setCreateTime(DateHelper.getTime());		if(model.isMajor()) {			task.setTaskType(TaskType.Major.ordinal());		} else {			task.setTaskType(TaskType.Aidant.ordinal());		}		task.setParentTaskId(execution.getTask() == null ? 				START : execution.getTask().getId());		task.setModel(model);		return task;	}
private Task saveTask(Task task, String... actors) {		task.setId(StringHelper.getPrimaryKey());		task.setPerformType(PerformType.ANY.ordinal());		access().saveTask(task);		assignTask(task.getId(), actors);		task.setActorIds(actors);		return task;	}
private String[] getTaskActors(TaskModel model, Execution execution) {		Object assigneeObject = null;        AssignmentHandler handler = model.getAssignmentHandlerObject();		if(StringHelper.isNotEmpty(model.getAssignee())) {			assigneeObject = execution.getArgs().get(model.getAssignee());		} else if(handler != null) {            if(handler instanceof Assignment) {                assigneeObject = ((Assignment)handler).assign(model, execution);            } else {                assigneeObject = handler.assign(execution);            }		}		return getTaskActors(assigneeObject == null ? model.getAssignee() : assigneeObject);	}
private String[] getTaskActors(Object actors) {		if(actors == null) return null;		String[] results;		if(actors instanceof String) {			//如果值为字符串类型，则使用逗号,分隔			return ((String)actors).split(",");        } else if(actors instanceof List){            //jackson会把stirng[]转成arraylist，此处增加arraylist的逻辑判断,by 红豆冰沙2014.11.21			List<?> list = (List)actors;			results = new String[list.size()];			for(int i = 0; i < list.size(); i++) {				results[i] = (String)list.get(i);			}            return results;		} else if(actors instanceof Long) {			//如果为Long类型，则返回1个元素的String[]			results = new String[1];			results[0] = String.valueOf((Long)actors);			return results;		} else if(actors instanceof Integer) {			//如果为Integer类型，则返回1个元素的String[]			results = new String[1];			results[0] = String.valueOf((Integer)actors);			return results;		} else if(actors instanceof String[]) {			//如果为String[]类型，则直接返回			return (String[])actors;		} else {			//其它类型，抛出不支持的类型异常			throw new SnakerException("任务参与者对象[" + actors + "]类型不支持."					+ "合法参数示例:Long,Integer,new String[]{},'10000,20000',List<String>");		}	}
public boolean isAllowed(Task task, String operator) {		if(StringHelper.isNotEmpty(operator)) {			if(SnakerEngine.ADMIN.equalsIgnoreCase(operator)					|| SnakerEngine.AUTO.equalsIgnoreCase(operator)) {				return true;			}			if(StringHelper.isNotEmpty(task.getOperator())) {				return operator.equals(task.getOperator());			}		}		List<TaskActor> actors = access().getTaskActorsByTaskId(task.getId());		if(actors == null || actors.isEmpty()) return true;		return !StringHelper.isEmpty(operator)				&& getStrategy().isAllowed(operator, actors);	}
public static InputStream openStream(String resource) {		ClassLoader classLoader = Thread.currentThread()				.getContextClassLoader();		InputStream stream = classLoader.getResourceAsStream(resource);		if (stream == null) {			stream = StreamHelper.class.getClassLoader().getResourceAsStream(resource);		}		return stream;	}
public static long copy(InputStream inputStream, OutputStream outputStream) throws IOException {		return copy( inputStream, outputStream, DEFAULT_CHUNK_SIZE );	}
public static long copy(InputStream inputStream, OutputStream outputStream, int bufferSize) throws IOException {		byte[] buffer = new byte[bufferSize];		long count = 0;		int n;		while ( -1 != ( n = inputStream.read( buffer ) ) ) {			outputStream.write( buffer, 0, n );			count += n;		}		return count;	}
public static void initialize() {		InputStream in;		try {			in = Resources.getResourceAsStream("mybatis.cfg.xml");			sqlSessionFactory = new SqlSessionFactoryBuilder().build(in, ConfigHelper.getProperties());		} catch (IOException e) {			e.printStackTrace();		}	}
public static void initialize(DataSource ds) {		TransactionFactory transactionFactory = new MybatisTransactionFactory();		Environment environment = new Environment("snaker", transactionFactory, ds);		Configuration configuration = new Configuration(environment);        configuration.getTypeAliasRegistry().registerAliases(SCAN_PACKAGE, Object.class);        if (log.isInfoEnabled()) {        	Map<String, Class<?>> typeAliases = configuration.getTypeAliasRegistry().getTypeAliases();        	for(Entry<String, Class<?>> entry : typeAliases.entrySet()) {            	log.info("Scanned class:[name=" + entry.getKey() + ",class=" + entry.getValue().getName() + "]");        	}        }		try {			for(String resource : resources) {				InputStream in = Resources.getResourceAsStream(resource);				XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(in, configuration, resource, configuration.getSqlFragments());				xmlMapperBuilder.parse();			}		} catch (Exception e) {			e.printStackTrace();		} finally {			ErrorContext.instance().reset();		}		sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);	}
public String getPageSql(String sql, Page<?> page) {		StringBuffer pageSql = new StringBuffer(sql.length() + 100);		pageSql.append(getPageBefore(sql, page));		pageSql.append(sql);		pageSql.append(getPageAfter(sql, page));		return pageSql.toString();	}
public boolean isAllowed(String operator, List<TaskActor> actors) {		List<String> assignees = ensureGroup(operator);		if(assignees == null) assignees = new ArrayList<String>();		assignees.add(operator);		boolean isAllowed = false;		for (TaskActor actor : actors) {			for (String assignee : assignees) {				if (actor.getActorId().equals(assignee)) {					isAllowed = true;					break;				}			}		}		return isAllowed;	}
public void parse(Element element) {		model = newModel();		model.setName(element.getAttribute(ATTR_NAME));		model.setDisplayName(element.getAttribute(ATTR_DISPLAYNAME));		model.setLayout(element.getAttribute(ATTR_LAYOUT));		model.setPreInterceptors(element.getAttribute(ATTR_PREINTERCEPTORS));		model.setPostInterceptors(element.getAttribute(ATTR_POSTINTERCEPTORS));				List<Element> transitions = XmlHelper.elements(element, NODE_TRANSITION);		for(Element te : transitions) {			TransitionModel transition = new TransitionModel();			transition.setName(te.getAttribute(ATTR_NAME));			transition.setDisplayName(te.getAttribute(ATTR_DISPLAYNAME));			transition.setTo(te.getAttribute(ATTR_TO));			transition.setExpr(te.getAttribute(ATTR_EXPR));			transition.setG(te.getAttribute(ATTR_G));			transition.setOffset(te.getAttribute(ATTR_OFFSET));			transition.setSource(model);			model.getOutputs().add(transition);		}				parseNode(model, element);	}
private static void initialize() {		String driver = ConfigHelper.getProperty("jdbc.driver");		String url = ConfigHelper.getProperty("jdbc.url");		String username = ConfigHelper.getProperty("jdbc.username");		String password = ConfigHelper.getProperty("jdbc.password");		int maxActive = ConfigHelper.getNumerProperty("jdbc.max.active");		int maxIdle = ConfigHelper.getNumerProperty("jdbc.max.idle");		AssertHelper.notNull(driver);		AssertHelper.notNull(url);		AssertHelper.notNull(username);		AssertHelper.notNull(password);		//初始化DBCP数据源		BasicDataSource ds = new BasicDataSource();		ds.setDriverClassName(driver);		ds.setUrl(url);		ds.setUsername(username);		ds.setPassword(password);        if(maxActive != 0) {		    ds.setMaxActive(maxActive);        }        if(maxIdle != 0) {		    ds.setMaxIdle(maxIdle);        }		dataSource = ds;	}
public static DataSource getDataSource() {		if(dataSource == null) {			synchronized (JdbcHelper.class) {				if(dataSource == null) {					initialize();				}			}		}		AssertHelper.notNull(dataSource);		return dataSource;	}
public static Connection getConnection(DataSource ds) throws SQLException {    	//通过ThreadLocale中获取Connection，如果为空，则通过dataSource返回新的连接对象    	Connection conn = (Connection)TransactionObjectHolder.get();    	if(conn != null) return conn;		if(ds != null) return ds.getConnection();		return getDataSource().getConnection();    }
public static <T> T requiredSingleResult(Collection<T> results) {		int size = (results != null ? results.size() : 0);		if (size == 0) {			return null;		}		return results.iterator().next();	}
public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {		String name = resultSetMetaData.getColumnLabel(columnIndex);		if (name == null || name.length() < 1) {			name = resultSetMetaData.getColumnName(columnIndex);		}		return name;	}
public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {		if (requiredType == null) {			return getResultSetValue(rs, index);		}		Object value = null;		boolean wasNullCheck = false;		if (String.class.equals(requiredType)) {			value = rs.getString(index);		}		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {			value = rs.getBoolean(index);			wasNullCheck = true;		}		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {			value = rs.getByte(index);			wasNullCheck = true;		}		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {			value = rs.getShort(index);			wasNullCheck = true;		}		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {			value = rs.getInt(index);			wasNullCheck = true;		}		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {			value = rs.getLong(index);			wasNullCheck = true;		}		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {			value = rs.getFloat(index);			wasNullCheck = true;		}		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||				Number.class.equals(requiredType)) {			value = rs.getDouble(index);			wasNullCheck = true;		}		else if (byte[].class.equals(requiredType)) {			value = rs.getBytes(index);		}		else if (java.sql.Date.class.equals(requiredType)) {			value = rs.getDate(index);		}		else if (java.sql.Time.class.equals(requiredType)) {			value = rs.getTime(index);		}		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {			value = rs.getTimestamp(index);		}		else if (BigDecimal.class.equals(requiredType)) {			value = rs.getBigDecimal(index);		}		else if (Blob.class.equals(requiredType)) {			value = rs.getBlob(index);		}		else if (Clob.class.equals(requiredType)) {			value = rs.getClob(index);		}		else {			value = getResultSetValue(rs, index);		}		if (wasNullCheck && value != null && rs.wasNull()) {			value = null;		}		return value;	}
public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {		Object obj = rs.getObject(index);		String className = null;		if (obj != null) {			className = obj.getClass().getName();		}		if (obj instanceof Blob) {			obj = rs.getBytes(index);		}		else if (obj instanceof Clob) {			obj = rs.getString(index);		}		else if (className != null &&				("oracle.sql.TIMESTAMP".equals(className) ||				"oracle.sql.TIMESTAMPTZ".equals(className))) {			obj = rs.getTimestamp(index);		}		else if (className != null && className.startsWith("oracle.sql.DATE")) {			String metaDataClassName = rs.getMetaData().getColumnClassName(index);			if ("java.sql.Timestamp".equals(metaDataClassName) ||					"oracle.sql.TIMESTAMP".equals(metaDataClassName)) {				obj = rs.getTimestamp(index);			}			else {				obj = rs.getDate(index);			}		}		else if (obj != null && obj instanceof java.sql.Date) {			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {				obj = rs.getTimestamp(index);			}		}		return obj;	}
public static String getDatabaseType(Connection conn) throws Exception {        DatabaseMetaData databaseMetaData = conn.getMetaData();        String databaseProductName = databaseMetaData.getDatabaseProductName();        return databaseTypeMappings.getProperty(databaseProductName);    }
public static Dialect getDialect(Connection conn) throws Exception {        DatabaseMetaData databaseMetaData = conn.getMetaData();        String databaseProductName = databaseMetaData.getDatabaseProductName();        String dbType = databaseTypeMappings.getProperty(databaseProductName);		if(StringHelper.isEmpty(dbType)) return null;        if(dbType.equalsIgnoreCase("mysql")) return new MySqlDialect();        else if(dbType.equalsIgnoreCase("oracle")) return new OracleDialect();        else if(dbType.equalsIgnoreCase("postgres")) return new PostgresqlDialect();        else if(dbType.equalsIgnoreCase("mssql")) return new SQLServerDialect();		else if(dbType.equalsIgnoreCase("db2")) return new Db2Dialect();		else if(dbType.equalsIgnoreCase("h2")) return new H2Dialect();        else return null;    }
public static boolean isExec(Connection conn) {        Statement stmt = null;        try {            String sql = ConfigHelper.getProperty("schema.test");            if(StringHelper.isEmpty(sql)) {                sql = "select * from wf_process";            }            stmt = conn.createStatement();            stmt.execute(sql);            return true;        } catch(Exception e) {            return false;        } finally {            try {                JdbcHelper.close(stmt);            } catch (SQLException e) {                //ignore            }        }    }
private Object[] getArgs(Map<String, Object> execArgs, String args) {		Object[] objects = null;		if(StringHelper.isNotEmpty(args)) {			String[] argArray = args.split(",");			objects = new Object[argArray.length];			for(int i = 0; i < argArray.length; i++) {				objects[i] = execArgs.get(argArray[i]);			}		}		return objects;	}
public SnakerEngine configure(Configuration config) {		this.configuration = config;		processService = ServiceContext.find(IProcessService.class);		queryService = ServiceContext.find(IQueryService.class);		orderService = ServiceContext.find(IOrderService.class);		taskService = ServiceContext.find(ITaskService.class);		managerService = ServiceContext.find(IManagerService.class);				/*		 * 无spring环境，DBAccess的实现类通过服务上下文获取		 */		if(!this.configuration.isCMB()) {			DBAccess access = ServiceContext.find(DBAccess.class);			AssertHelper.notNull(access);			TransactionInterceptor interceptor = ServiceContext.find(TransactionInterceptor.class);			//如果初始化配置时提供了访问对象，就对DBAccess进行初始化			Object accessObject = this.configuration.getAccessDBObject();			if(accessObject != null) {				if(interceptor != null) {					interceptor.initialize(accessObject);				}				access.initialize(accessObject);			}			setDBAccess(access);            access.runScript();		}		CacheManager cacheManager = ServiceContext.find(CacheManager.class);		if(cacheManager == null) {			//默认使用内存缓存管理器			cacheManager = new MemoryCacheManager();		}		List<CacheManagerAware> cacheServices = ServiceContext.findList(CacheManagerAware.class);		for(CacheManagerAware cacheService : cacheServices) {			cacheService.setCacheManager(cacheManager);		}		return this;	}
protected void setDBAccess(DBAccess access) {		List<AccessService> services = ServiceContext.findList(AccessService.class);		for(AccessService service : services) {			service.setAccess(access);		}	}
public Order startInstanceById(String id, String operator) {		return startInstanceById(id, operator, null);	}
public Order startInstanceById(String id, String operator, Map<String, Object> args) {		if(args == null) args = new HashMap<String, Object>();		Process process = process().getProcessById(id);		process().check(process, id);		return startProcess(process, operator, args);	}
public Order startInstanceByName(String name, Integer version) {		return startInstanceByName(name, version, null, null);	}
public Order startInstanceByName(String name, Integer version,			String operator, Map<String, Object> args) {		if(args == null) args = new HashMap<String, Object>();		Process process = process().getProcessByVersion(name, version);		process().check(process, name);		return startProcess(process, operator, args);	}
public Order startInstanceByExecution(Execution execution) {		Process process = execution.getProcess();		StartModel start = process.getModel().getStart();		AssertHelper.notNull(start, "流程定义[id=" + process.getId() + "]没有开始节点");				Execution current = execute(process, execution.getOperator(), execution.getArgs(), 				execution.getParentOrder().getId(), execution.getParentNodeName());		start.execute(current);		return current.getOrder();	}
private Execution execute(Process process, String operator, Map<String, Object> args, 			String parentId, String parentNodeName) {		Order order = order().createOrder(process, operator, args, parentId, parentNodeName);		if(log.isDebugEnabled()) {			log.debug("创建流程实例对象:" + order);		}		Execution current = new Execution(this, process, order, args);		current.setOperator(operator);		return current;	}
public List<Task> executeTask(String taskId, String operator) {		return executeTask(taskId, operator, null);	}
public List<Task> executeTask(String taskId, String operator, Map<String, Object> args) {		//完成任务，并且构造执行对象		Execution execution = execute(taskId, operator, args);		if(execution == null) return Collections.emptyList();		ProcessModel model = execution.getProcess().getModel();		if(model != null) {			NodeModel nodeModel = model.getNode(execution.getTask().getTaskName());			//将执行对象交给该任务对应的节点模型执行			nodeModel.execute(execution);		}		return execution.getTasks();	}
public List<Task> executeAndJumpTask(String taskId, String operator, Map<String, Object> args, String nodeName) {		Execution execution = execute(taskId, operator, args);		if(execution == null) return Collections.emptyList();		ProcessModel model = execution.getProcess().getModel();		AssertHelper.notNull(model, "当前任务未找到流程定义模型");		if(StringHelper.isEmpty(nodeName)) {			Task newTask = task().rejectTask(model, execution.getTask());			execution.addTask(newTask);		} else {			NodeModel nodeModel = model.getNode(nodeName);			AssertHelper.notNull(nodeModel, "根据节点名称[" + nodeName + "]无法找到节点模型");			//动态创建转移对象，由转移对象执行execution实例			TransitionModel tm = new TransitionModel();			tm.setTarget(nodeModel);			tm.setEnabled(true);			tm.execute(execution);		}		return execution.getTasks();	}
public List<Task> createFreeTask(String orderId, String operator, Map<String, Object> args, TaskModel model) {		Order order = query().getOrder(orderId);		AssertHelper.notNull(order, "指定的流程实例[id=" + orderId + "]已完成或不存在");		order.setLastUpdator(operator);		order.setLastUpdateTime(DateHelper.getTime());		Process process = process().getProcessById(order.getProcessId());		Execution execution = new Execution(this, process, order, args);		execution.setOperator(operator);		return task().createTask(model, execution);	}
private Execution execute(String taskId, String operator, Map<String, Object> args) {		if(args == null) args = new HashMap<String, Object>();		Task task = task().complete(taskId, operator, args);		if(log.isDebugEnabled()) {			log.debug("任务[taskId=" + taskId + "]已完成");		}		Order order = query().getOrder(task.getOrderId());		AssertHelper.notNull(order, "指定的流程实例[id=" + task.getOrderId() + "]已完成或不存在");		order.setLastUpdator(operator);		order.setLastUpdateTime(DateHelper.getTime());		order().updateOrder(order);		//协办任务完成不产生执行对象		if(!task.isMajor()) {			return null;		}		Map<String, Object> orderMaps = order.getVariableMap();		if(orderMaps != null) {			for(Map.Entry<String, Object> entry : orderMaps.entrySet()) {				if(args.containsKey(entry.getKey())) {					continue;				}				args.put(entry.getKey(), entry.getValue());			}		}		Process process = process().getProcessById(order.getProcessId());		Execution execution = new Execution(this, process, order, args);		execution.setOperator(operator);		execution.setTask(task);		return execution;	}
public void handle(Execution execution) {		SnakerEngine engine = execution.getEngine();		Order order = execution.getOrder();		List<Task> tasks = engine.query().getActiveTasks(new QueryFilter().setOrderId(order.getId()));		for(Task task : tasks) {			if(task.isMajor()) throw new SnakerException("存在未完成的主办任务,请确认.");			engine.task().complete(task.getId(), SnakerEngine.AUTO);		}		/**		 * 结束当前流程实例		 */		engine.order().complete(order.getId());				/**		 * 如果存在父流程，则重新构造Execution执行对象，交给父流程的SubProcessModel模型execute		 */		if(StringHelper.isNotEmpty(order.getParentId())) {			Order parentOrder = engine.query().getOrder(order.getParentId());			if(parentOrder == null) return;			Process process = engine.process().getProcessById(parentOrder.getProcessId());			ProcessModel pm = process.getModel();			if(pm == null) return;			SubProcessModel spm = (SubProcessModel)pm.getNode(order.getParentNodeName());            Execution newExecution = new Execution(engine, process, parentOrder, execution.getArgs());            newExecution.setChildOrderId(order.getId());            newExecution.setTask(execution.getTask());			spm.execute(newExecution);			/**			 * SubProcessModel执行结果的tasks合并到当前执行对象execution的tasks列表中			 */			execution.addTasks(newExecution.getTasks());		}	}
public void runScript(Reader reader) throws IOException, SQLException {        AssertHelper.notNull(connection);        try {            boolean originalAutoCommit = connection.getAutoCommit();            try {                if (originalAutoCommit != this.autoCommit) {                    connection.setAutoCommit(this.autoCommit);                }                runScript(connection, reader);            } finally {                connection.setAutoCommit(originalAutoCommit);            }        } catch (IOException e) {            throw e;        } catch (SQLException e) {            throw e;        } catch (Exception e) {            throw new RuntimeException("Error running script.  Cause: " + e, e);        }    }
private void runScript(Connection conn, Reader reader)            throws IOException, SQLException {        StringBuffer command = null;        try {            LineNumberReader lineReader = new LineNumberReader(reader);            String line = null;            while ((line = lineReader.readLine()) != null) {                if (command == null) {                    command = new StringBuffer();                }                String trimmedLine = line.trim();                if (trimmedLine.startsWith("--")) {                    log.info(trimmedLine);                } else if (trimmedLine.length() < 1 || trimmedLine.startsWith("//")) {                    //Do nothing                } else if (trimmedLine.length() < 1 || trimmedLine.startsWith("--")) {                    //Do nothing                } else if (trimmedLine.equals(getDelimiter()) || trimmedLine.endsWith(getDelimiter())) {                    command.append(line.substring(0, line.lastIndexOf(getDelimiter())));                    command.append(" ");                    Statement statement = conn.createStatement();                    log.info(command.toString());                    try {                        statement.execute(command.toString());                    } catch (SQLException e) {                        e.fillInStackTrace();                        log.error("Error executing: " + command);                    }                    if (autoCommit && !conn.getAutoCommit()) {                        conn.commit();                    }                    command = null;                    try {                        statement.close();                    } catch (Exception e) {                        //ignore                    }                    Thread.yield();                } else {                    command.append(line);                    command.append(" ");                }            }            if (!autoCommit) {                conn.commit();            }        } catch (SQLException e) {            e.fillInStackTrace();            throw e;        } catch (IOException e) {            e.fillInStackTrace();            throw e;        }    }
public String getPageSql(String sql, Page<?> page) {		StringBuffer pageSql = new StringBuffer(sql.length() + 100);		pageSql.append("select * from ( select row_.*, rownum rownum_ from ( ");		pageSql.append(sql);		long start = (page.getPageNo() - 1) * page.getPageSize() + 1;		pageSql.append(" ) row_ where rownum < ");		pageSql.append(start + page.getPageSize());		pageSql.append(" ) where rownum_ >= ");		pageSql.append(start);		return pageSql.toString();	}
public void setOrder(String order) {        String lowcaseOrder = StringUtils.lowerCase(order);        //检查order字符串的合法值        String[] orders = StringUtils.split(lowcaseOrder, ',');        for (String orderStr : orders) {            if (!StringUtils.equals(DESC, orderStr) && !StringUtils.equals(ASC, orderStr)) {                throw new IllegalArgumentException("排序类型[" + orderStr + "]不是合法值");            }        }        this.order = lowcaseOrder;    }
public static List<Element> elements(Element element, String tagName) {		if (element == null || !element.hasChildNodes()) {			return Collections.emptyList();		}		List<Element> elements = new ArrayList<Element>();		for (Node child = element.getFirstChild(); child != null; child = child.getNextSibling()) {			if (child.getNodeType() == Node.ELEMENT_NODE) {				Element childElement = (Element) child;				String childTagName = childElement.getNodeName();				if (tagName.equals(childTagName))					elements.add(childElement);			}		}		return elements;	}
public static String getStringByArray(String... strArray) {		if(strArray == null) return "";		StringBuilder buffer = new StringBuilder(strArray.length * 10);		for(String str : strArray) {			buffer.append(str).append(",");		}		buffer.deleteCharAt(buffer.length() - 1);		return buffer.toString();	}
public static String textXML(String xml) {		if(xml == null) return "";		String content = xml;		content = content.replaceAll("<", "&lt;");		content = content.replaceAll(">", "&gt;");		content = content.replaceAll("\"", "&quot;");		content = content.replaceAll("\n", "</br>");		return content;	}
public static String buildPageOrder(String order, String orderby) {		if(isEmpty(orderby) || isEmpty(order)) return "";		String[] orderByArray = StringUtils.split(orderby, ',');		String[] orderArray = StringUtils.split(order, ',');		if(orderArray.length != orderByArray.length) throw new SnakerException("分页多重排序参数中,排序字段与排序方向的个数不相等");		StringBuilder orderStr = new StringBuilder(30);		orderStr.append(" order by ");		for (int i = 0; i < orderByArray.length; i++) {			orderStr.append(orderByArray[i]).append(" ").append(orderArray[i]).append(" ,");		}		orderStr.deleteCharAt(orderStr.length() - 1);		return orderStr.toString();	}
public static void notEmpty(String str, String message) {		if (str == null || str.length() == 0) {			throw new IllegalArgumentException(message);		}	}
public void intercept(Execution execution) {		if(log.isInfoEnabled()) {			for(Task task : execution.getTasks()) {				StringBuffer buffer = new StringBuffer(100);				buffer.append("创建任务[标识=").append(task.getId());				buffer.append(",名称=").append(task.getDisplayName());				buffer.append(",创建时间=").append(task.getCreateTime());				buffer.append(",参与者={");				if(task.getActorIds() != null) {					for(String actor : task.getActorIds()) {						buffer.append(actor).append(";");					}				}				buffer.append("}]");				log.info(buffer.toString());			}		}	}
public Task undoTask() {    	Task task = new Task();    	task.setOrderId(this.getOrderId());;    	task.setTaskName(this.getTaskName());    	task.setDisplayName(this.getDisplayName());    	task.setTaskType(this.getTaskType());    	task.setExpireTime(this.getExpireTime());    	task.setActionUrl(this.getActionUrl());    	task.setParentTaskId(this.getParentTaskId());    	task.setVariable(this.getVariable());    	task.setPerformType(this.getPerformType());    	task.setOperator(this.getOperator());    	return task;    }
private void findForkTaskNames(NodeModel node, StringBuilder buffer) {		if(node instanceof ForkModel) return;		List<TransitionModel> inputs = node.getInputs();		for(TransitionModel tm : inputs) {			if(tm.getSource() instanceof WorkModel) {				buffer.append(tm.getSource().getName()).append(",");			}			findForkTaskNames(tm.getSource(), buffer);		}	}
protected String[] findActiveNodes() {		StringBuilder buffer = new StringBuilder(20);		findForkTaskNames(model, buffer);		String[] taskNames = buffer.toString().split(",");		return taskNames;	}
public Order undo() {        Order order = new Order();        order.setId(this.id);        order.setProcessId(this.processId);        order.setParentId(this.parentId);        order.setCreator(this.creator);        order.setCreateTime(this.createTime);        order.setLastUpdator(this.creator);        order.setLastUpdateTime(this.endTime);        order.setExpireTime(this.expireTime);        order.setOrderNo(this.orderNo);        order.setPriority(this.priority);        order.setVariable(this.variable);        order.setVersion(0);        return order;    }
public static SnakerEngine getEngine() {		AssertHelper.notNull(context, "未注册服务上下文");		if(engine == null) {			engine = context.find(SnakerEngine.class);		}		return engine;	}
public static void put(String name, Object object) {		AssertHelper.notNull(context, "未注册服务上下文");		if(log.isInfoEnabled()) {			log.info("put new instance[name=" + name + "][object=" + object + "]");		}		context.put(name, object);	}
public static void put(String name, Class<?> clazz) {		AssertHelper.notNull(context, "未注册服务上下文");		if(log.isInfoEnabled()) {			log.info("put new instance[name=" + name + "][clazz=" + clazz.getName() + "]");		}		context.put(name, clazz);	}
public static <T> T find(Class<T> clazz) {		AssertHelper.notNull(context, "未注册服务上下文");		return context.find(clazz);	}
public static <T> List<T> findList(Class<T> clazz) {		AssertHelper.notNull(context, "未注册服务上下文");		return context.findList(clazz);	}
public static <T> T findByName(String name, Class<T> clazz) {		AssertHelper.notNull(context, "未注册服务上下文");		return context.findByName(name, clazz);	}
public void handle(Execution execution) {		List<Task> tasks = execution.getEngine().task().createTask(model, execution);		execution.addTasks(tasks);		/**		 * 从服务上下文中查找任务拦截器列表，依次对task集合进行拦截处理		 */		List<SnakerInterceptor> interceptors = ServiceContext.getContext().findList(SnakerInterceptor.class);		try {			for(SnakerInterceptor interceptor : interceptors) {				interceptor.intercept(execution);			}		} catch(Exception e) {			log.error("拦截器执行失败=" + e.getMessage());			throw new SnakerException(e);		}	}
public void exec(Process process, String orderId,			String taskId, NodeModel nodeModel, Map<String, Object> data) 			throws JobExecutionException {		log.info("ExecutorJob execute taskId:{}", taskId);		if(nodeModel == null || !(nodeModel instanceof TaskModel)) {			log.debug("节点模型为空，或不是任务模型，则不满足执行条件");			return;		}		TaskModel tm = (TaskModel)nodeModel;		List<Task> tasks = null;		if(StringHelper.isNotEmpty(tm.getAutoExecute()) 				&& tm.getAutoExecute().equalsIgnoreCase("Y")) {			tasks = engine.executeTask(taskId, SnakerEngine.AUTO, data);			schedule().delete(IScheduler.TYPE_REMINDER + taskId);		}		callback(tm.getCallbackObject(), taskId, tasks);	}
private void callback(JobCallback jobCallback, String taskId, List<Task> tasks) {		if(jobCallback == null) return;		jobCallback.callback(taskId, tasks);	}
private static void initialize() {		String driver = ConfigHelper.getProperty("jdbc.driver");		String url = ConfigHelper.getProperty("jdbc.url");		String username = ConfigHelper.getProperty("jdbc.username");		String password = ConfigHelper.getProperty("jdbc.password");		String dialect = ConfigHelper.getProperty("hibernate.dialect");		AssertHelper.notNull(driver);		AssertHelper.notNull(url);		AssertHelper.notNull(username);		AssertHelper.notNull(password);		AssertHelper.notNull(dialect);		String formatSql = ConfigHelper.getProperty("hibernate.format_sql");		String showSql = ConfigHelper.getProperty("hibernate.show_sql");		Configuration configuration = new Configuration();				if(StringHelper.isNotEmpty(driver)) {			configuration.setProperty("hibernate.connection.driver_class", driver);		}		if(StringHelper.isNotEmpty(url)) {			configuration.setProperty("hibernate.connection.url", url);		}		if(StringHelper.isNotEmpty(username)) {			configuration.setProperty("hibernate.connection.username", username);		}		if(StringHelper.isNotEmpty(password)) {			configuration.setProperty("hibernate.connection.password", password);		}		if(StringHelper.isNotEmpty(dialect)) {			configuration.setProperty("hibernate.dialect", dialect);		}		if(StringHelper.isNotEmpty(formatSql)) {			configuration.setProperty("hibernate.format_sql", formatSql);		}		if(StringHelper.isNotEmpty(showSql)) {			configuration.setProperty("hibernate.show_sql", showSql);		}		sessionFactory = configuration.configure().buildSessionFactory();	}
public static long castLong(Object count) {		if(count == null) return -1L;		if(count instanceof Long) {			return (Long)count;		} else if(count instanceof BigDecimal) {			return ((BigDecimal)count).longValue();		} else if(count instanceof Integer) {			return ((Integer)count).longValue();		} else if(count instanceof BigInteger) {			return ((BigInteger)count).longValue();		} else if(count instanceof Byte) {			return ((Byte)count).longValue();        } else if(count instanceof Short) {            return ((Short)count).longValue();		} else {			return -1L;		}	}
public static Class<?> loadClass(String className) throws ClassNotFoundException {        try {            return Thread.currentThread().getContextClassLoader().loadClass(className);        } catch (ClassNotFoundException e) {            try {                return Class.forName(className);            } catch (ClassNotFoundException ex) {                try {                    return ClassLoader.class.getClassLoader().loadClass(className);                } catch (ClassNotFoundException exc) {                    throw exc;                }            }        }    }
public static Object newInstance(String clazzStr) {        try {        	log.debug("loading class:" + clazzStr);            Class<?> clazz = loadClass(clazzStr);            return instantiate(clazz);        } catch (ClassNotFoundException e) {            log.error("Class not found.", e);        } catch (Exception ex) {        	log.error("类型实例化失败[class=" + clazzStr + "]\n" + ex.getMessage());        }        return null;    }
public static <T> T instantiate(Class<T> clazz) {		if (clazz.isInterface()) {			log.error("所传递的class类型参数为接口，无法实例化");			return null;		}		try {			return clazz.newInstance();		} catch (Exception ex) {			log.error("检查传递的class类型参数是否为抽象类?", ex.getCause());		}		return null;	}
public List<WorkModel> getWorkModels() {		List<WorkModel> models = new ArrayList<WorkModel>();		for(NodeModel node : nodes) {			if(node instanceof WorkModel) {				models.add((WorkModel)node);			}		}		return models;	}
public List<TaskModel> getTaskModels() {        if(taskModels.isEmpty()) {            synchronized (lock) {                if(taskModels.isEmpty())                    buildModels(taskModels, getStart().getNextModels(TaskModel.class), TaskModel.class);            }        }        return taskModels;    }
public <T> List<T> getModels(Class<T> clazz) {        List<T> models = new ArrayList<T>();        buildModels(models, getStart().getNextModels(clazz), clazz);        return models;    }
public StartModel getStart() {		for(NodeModel node : nodes) {			if(node instanceof StartModel) {				return (StartModel)node;			}		}		return null;	}
public NodeModel getNode(String nodeName) {		for(NodeModel node : nodes) {			if(node.getName().equals(nodeName)) {				return node;			}		}		return null;	}
public <T> boolean containsNodeNames(Class<T> T, String... nodeNames) {		for(NodeModel node : nodes) {			if(!T.isInstance(node)) {				continue;			}			for(String nodeName : nodeNames) {				if(node.getName().equals(nodeName)) {					return true;				}			}		}		return false;	}
public <T> T find(Class<T> clazz) {		for (Entry<String, Object> entry : contextMap.entrySet()) {			if (clazz.isInstance(entry.getValue())) {				return clazz.cast(entry.getValue());			}		}		return null;	}
public <T> List<T> findList(Class<T> clazz) {		List<T> list = new ArrayList<T>();		for (Entry<String, Object> entry : contextMap.entrySet()) {			if (clazz.isInstance(entry.getValue())) {				list.add(clazz.cast(entry.getValue()));			}		}		return list;	}
public <T> T findByName(String name, Class<T> clazz) {		for (Entry<String, Object> entry : contextMap.entrySet()) {			if (entry.getKey().equals(name) && clazz.isInstance(entry.getValue())) {				return clazz.cast(entry.getValue());			}		}		return null;	}
public void put(String name, Class<?> clazz) {		contextMap.put(name, ClassHelper.instantiate(clazz));	}
public SnakerEngine buildSnakerEngine() throws SnakerException {		if(log.isInfoEnabled()) {			log.info("SnakerEngine start......");		}		parser();		/**		 * 由服务上下文返回流程引擎		 */		SnakerEngine configEngine = ServiceContext.getEngine();		if(configEngine == null) {			throw new SnakerException("配置无法发现SnakerEngine的实现类");		}		if(log.isInfoEnabled()) {			log.info("SnakerEngine be found:" + configEngine.getClass());		}		return configEngine.configure(this);	}
protected void parser() {		if(log.isDebugEnabled()) {			log.debug("Service parsing start......");		}		//默认使用snaker.xml配置自定义的bean		String config = ConfigHelper.getProperty("config");		if (StringHelper.isEmpty(config)) {			config = USER_CONFIG_FILE;		}		parser(config);		parser(BASE_CONFIG_FILE);		if (!isCMB()) {		    parser(EXT_CONFIG_FILE);			for(Entry<String, Class<?>> entry : txClass.entrySet()) {				if(interceptor != null) {                    Object instance = interceptor.getProxy(entry.getValue());                    ServiceContext.put(entry.getKey(), instance);				} else {                    ServiceContext.put(entry.getKey(), entry.getValue());				}			}		}				if(log.isDebugEnabled()) {			log.debug("Service parsing finish......");		}	}
private void parser(String resource) {		//解析所有配置节点，并实例化class指定的类		DocumentBuilder documentBuilder = XmlHelper.createDocumentBuilder();		try {			if (documentBuilder != null) {				InputStream input = StreamHelper.openStream(resource);				if(input == null) return;				Document doc = documentBuilder.parse(input);				Element configElement = doc.getDocumentElement();				NodeList nodeList = configElement.getChildNodes();				int nodeSize = nodeList.getLength();				for(int i = 0; i < nodeSize; i++) {					Node node = nodeList.item(i);					if (node.getNodeType() == Node.ELEMENT_NODE) {						Element element = (Element)node;						String name = element.getAttribute("name");						String className = element.getAttribute("class");						String proxy = element.getAttribute("proxy");						if(StringHelper.isEmpty(name)) {							name = className;						}						if(ServiceContext.exist(name)) {							log.warn("Duplicate name is:" + name);							continue;						}						Class<?> clazz = ClassHelper.loadClass(className);						if(TransactionInterceptor.class.isAssignableFrom(clazz)) {							interceptor = (TransactionInterceptor)ClassHelper.instantiate(clazz);							ServiceContext.put(name, interceptor);							continue;						}						if(proxy != null && proxy.equalsIgnoreCase("transaction")) {							txClass.put(name, clazz);						} else {							ServiceContext.put(name, clazz);						}					}				}			}		} catch (Exception e) {			e.printStackTrace();			throw new SnakerException("资源解析失败，请检查配置文件[" + resource + "]", e.getCause());		}	}
public static Object getFieldValue(Object obj, String fieldName) {		Object result = null;		Field field = getField(obj, fieldName);		if (field != null) {			field.setAccessible(true);			try {				result = field.get(obj);			} catch (IllegalArgumentException e) {				e.printStackTrace();			} catch (IllegalAccessException e) {				e.printStackTrace();			}		}		return result;	}
public static void setFieldValue(Object obj, String fieldName,			Object fieldValue) {		Field field = getField(obj, fieldName);		if (field != null) {			try {				field.setAccessible(true);				field.set(obj, fieldValue);			} catch (IllegalArgumentException e) {				e.printStackTrace();			} catch (IllegalAccessException e) {				e.printStackTrace();			}		}	}
public static Object invoke(Method method, Object target, Object[] args) {		if (method == null) {			throw new SnakerException("方法不能为空");		}		try {			if (!method.isAccessible()) {				method.setAccessible(true);			}			return method.invoke(target, args);		} catch (InvocationTargetException e) {			Throwable targetException = e.getTargetException();			throw new SnakerException("不能调用 '" + method.getName() + "' with "					+ Arrays.toString(args) + " on " + target + ": "					+ targetException.getMessage(), targetException);		} catch (Exception e) {			throw new SnakerException("不能调用 '" + method.getName() + "' with "					+ Arrays.toString(args) + " on " + target + ": "					+ e.getMessage(), e);		}	}
public static Method findMethod(Class<?> clazz, String methodName) {		Method[] candidates = clazz.getDeclaredMethods();		for (int i = 0; i < candidates.length; i++) {			Method candidate = candidates[i];			if (candidate.getName().equals(methodName)) {				return candidate;			}		}		if (clazz.getSuperclass() != null) {			return findMethod(clazz.getSuperclass(), methodName);		}		return null;	}
public void schedule(JobEntity entity) {		AssertHelper.notNull(entity);	    JobDataMap data = new JobDataMap(entity.getArgs());	    data.put(KEY, entity.getId());	    data.put(MODEL, entity.getModelName());	    Class<? extends Job> jobClazz = null;	    String jobId = "";	    switch(entity.getJobType()) {	    case 0:	    	jobClazz = ExecutorJob.class;	    	jobId = TYPE_EXECUTOR + entity.getTask().getId();	    	break;	    case 1:	    	jobClazz = ReminderJob.class;	    	jobId = TYPE_REMINDER + entity.getTask().getId();	    	break;	    }	    if(jobClazz == null) {	    	log.error("Quartz不支持的JOB类型:{}", entity.getJobType());	    	return;	    }	    	    JobDetail job = JobBuilder	    		.newJob(jobClazz)	    		.usingJobData(data)	    		.withIdentity(jobId, GROUP)	    		.build();	    Trigger trigger = null;	    TriggerBuilder<Trigger> builder = TriggerBuilder	    		.newTrigger()	    		.withIdentity(StringHelper.getPrimaryKey(), GROUP)	    		.startAt(entity.getStartTime());	    if(jobClazz == ReminderJob.class && entity.getPeriod() > 0) {	    	int count = ConfigHelper.getNumerProperty(CONFIG_REPEAT);	    	if(count <= 0) count = 1;	    	builder.withSchedule(SimpleScheduleBuilder.    				repeatMinutelyForTotalCount(count, entity.getPeriod()));	    	if(isUseCalendar) {	    		builder.modifiedByCalendar(CALENDAR_NAME);	    	}	    }	    trigger = builder.build();	    try {	    	log.info("jobId:{} class:{} starting......", jobId, jobClazz);			getScheduler().scheduleJob(job, trigger);		} catch (SchedulerException e) {			log.error(e.getMessage());		}	}
public boolean start() {		if (isStarted)			return true;		if (dataSourceProvider != null)			dataSource = dataSourceProvider.getDataSource();		if (dataSource == null)			throw new RuntimeException("SnakerPlugin start error: SnakerPlugin need DataSource");        Configuration config = new Configuration().initAccessDBObject(dataSource);        if(properties != null) config.initProperties(properties);		engine = config.buildSnakerEngine();		isStarted = true;		return true;	}
public void setModel(ProcessModel processModel) {		this.model = processModel;    	this.name = processModel.getName();    	this.displayName = processModel.getDisplayName();    	this.instanceUrl = processModel.getInstanceUrl();	}
public void intercept(Execution execution) {		if(!isScheduled) return;		for(Task task : execution.getTasks()) {			String id = execution.getProcess().getId() 					+ "-" + execution.getOrder().getId() 					+ "-" + task.getId();			Date expireDate = task.getExpireDate();			if(expireDate != null) {				schedule(id, task, expireDate, JobType.EXECUTER.ordinal(), execution.getArgs());			}			Date remindDate = task.getRemindDate();			if(remindDate != null) {				schedule(id, task, remindDate, JobType.REMINDER.ordinal(), execution.getArgs());			}		}	}
public void handle(Execution execution) {		//根据子流程模型名称获取子流程定义对象		SnakerEngine engine = execution.getEngine();		Process process = engine.process().getProcessByVersion(model.getProcessName(), model.getVersion());				Execution child = execution.createSubExecution(execution, process, model.getName());		Order order = null;		if(isFutureRunning) {			//创建单个线程执行器来执行启动子流程的任务			ExecutorService es = Executors.newSingleThreadExecutor();			//提交执行任务，并返回future			Future<Order> future = es.submit(new ExecuteTask(execution, process, model.getName()));			try {				es.shutdown();				order = future.get();			} catch (InterruptedException e) {				throw new SnakerException("创建子流程线程被强制终止执行", e.getCause());			} catch (ExecutionException e) {				throw new SnakerException("创建子流程线程执行异常.", e.getCause());			}		} else {			order  = engine.startInstanceByExecution(child);		}		AssertHelper.notNull(order, "子流程创建失败");		execution.addTasks(engine.query().getActiveTasks(new QueryFilter().setOrderId(order.getId())));	}
protected void parseNode(NodeModel node, Element element) {		DecisionModel decision = (DecisionModel)node;		decision.setExpr(element.getAttribute(ATTR_EXPR));		decision.setHandleClass(element.getAttribute(ATTR_HANDLECLASS));	}
protected IScheduler schedule() {	    if(scheduler == null) {	    	scheduler = ServiceContext.getContext().find(IScheduler.class);	    }	    return scheduler;	}
protected T handleRow(ResultSet rs) throws SQLException {		/**		 * 根据bean的class类型实例化为对象		 */		T mappedObject = ClassHelper.instantiate(mappedClass);		ResultSetMetaData rsmd = rs.getMetaData();		int columnCount = rsmd.getColumnCount();		/**		 * 对ResultSet结果集字段进行循环		 */		for (int index = 1; index <= columnCount; index++) {			/**			 * 根据字段索引index获取字段名称			 */			String column = JdbcHelper.lookupColumnName(rsmd, index);			/**			 * 根据映射字段集合返回字段名称对应的属性描述符对象			 */			PropertyDescriptor pd = this.mappedFields.get(column.replaceAll(" ", "").toLowerCase());			if (pd != null) {				try {					/**					 * 根据字段index、属性类型返回字段值					 */					Object value = JdbcHelper.getResultSetValue(rs, index, pd.getPropertyType());					try {						/**						 * 使用apache-beanutils设置对象的属性						 */						BeanUtils.setProperty(mappedObject, pd.getName(), value);					} catch (Exception e) {						e.printStackTrace();					}				} catch (Exception ex) {					ex.printStackTrace();				}			}		}		return mappedObject;	}
protected void initialize(Class<T> mappedClass) {		this.mappedClass = mappedClass;		this.mappedFields = new HashMap<String, PropertyDescriptor>();		PropertyDescriptor[] pds = null;		try {			/**			 * 返回bean的属性描述对象数组			 */			pds = propertyDescriptors(mappedClass);		} catch (SQLException e) {			throw new SnakerException(e.getMessage(), e.getCause());		}		for (PropertyDescriptor pd : pds) {			if (pd.getWriteMethod() != null) {				this.mappedFields.put(pd.getName().toLowerCase(), pd);				String underscoredName = underscoreName(pd.getName());				if (!pd.getName().toLowerCase().equals(underscoredName)) {					this.mappedFields.put(underscoredName, pd);				}			}		}	}
private static String underscoreName(String name) {		StringBuilder result = new StringBuilder();		if (name != null && name.length() > 0) {			result.append(name.substring(0, 1).toLowerCase());			for (int i = 1; i < name.length(); i++) {				String s = name.substring(i, i + 1);				if (s.equals(s.toUpperCase())) {					result.append("_");					result.append(s.toLowerCase());				} else {					result.append(s);				}			}		}		return result.toString();	}
private PropertyDescriptor[] propertyDescriptors(Class<?> c)			throws SQLException {		BeanInfo beanInfo = null;		try {			beanInfo = Introspector.getBeanInfo(c);		} catch (IntrospectionException e) {			throw new SQLException("Bean introspection failed: "					+ e.getMessage());		}		return beanInfo.getPropertyDescriptors();	}
public void updateType(String id, String type) {        Process entity = getProcessById(id);        entity.setType(type);		access().updateProcessType(id, type);        cache(entity);	}
public Process getProcessById(String id) {		AssertHelper.notEmpty(id);		Process entity = null;		String processName;		Cache<String, String> nameCache = ensureAvailableNameCache();		Cache<String, Process> entityCache = ensureAvailableEntityCache();		if(nameCache != null && entityCache != null) {			processName = nameCache.get(id);			if(StringHelper.isNotEmpty(processName)) {				entity = entityCache.get(processName);			}		}		if(entity != null) {			if(log.isDebugEnabled()) {				log.debug("obtain process[id={}] from cache.", id);			}			return entity;		}		entity = access().getProcess(id);		if(entity != null) {			if(log.isDebugEnabled()) {				log.debug("obtain process[id={}] from database.", id);			}			cache(entity);		}		return entity;	}
public Process getProcessByVersion(String name, Integer version) {		AssertHelper.notEmpty(name);		if(version == null) {			version = access().getLatestProcessVersion(name);		}		if(version == null) {			version = 0;		}		Process entity = null;		String processName = name + DEFAULT_SEPARATOR + version;		Cache<String, Process> entityCache = ensureAvailableEntityCache();		if(entityCache != null) {			entity = entityCache.get(processName);		}		if(entity != null) {			if(log.isDebugEnabled()) {				log.debug("obtain process[name={}] from cache.", processName);			}			return entity;		}		List<Process> processs = access().getProcesss(null, new QueryFilter().setName(name).setVersion(version));		if(processs != null && !processs.isEmpty()) {			if(log.isDebugEnabled()) {				log.debug("obtain process[name={}] from database.", processName);			}			entity = processs.get(0);			cache(entity);		}		return entity;	}
public String deploy(InputStream input, String creator) {		AssertHelper.notNull(input);		try {			byte[] bytes = StreamHelper.readBytes(input);			ProcessModel model = ModelParser.parse(bytes);			Integer version = access().getLatestProcessVersion(model.getName());			Process entity = new Process();			entity.setId(StringHelper.getPrimaryKey());			if(version == null || version < 0) {				entity.setVersion(0);			} else {				entity.setVersion(version + 1);			}			entity.setState(STATE_ACTIVE);			entity.setModel(model);			entity.setBytes(bytes);			entity.setCreateTime(DateHelper.getTime());			entity.setCreator(creator);			saveProcess(entity);			cache(entity);			return entity.getId();		} catch(Exception e) {			e.printStackTrace();			log.error(e.getMessage());			throw new SnakerException(e.getMessage(), e.getCause());		}	}
public void redeploy(String id, InputStream input) {		AssertHelper.notNull(input);		Process entity = access().getProcess(id);		AssertHelper.notNull(entity);		try {			byte[] bytes = StreamHelper.readBytes(input);			ProcessModel model = ModelParser.parse(bytes);			String oldProcessName = entity.getName();			entity.setModel(model);			entity.setBytes(bytes);			access().updateProcess(entity);			if(!oldProcessName.equalsIgnoreCase(entity.getName())) {				Cache<String, Process> entityCache = ensureAvailableEntityCache();				if(entityCache != null) {					entityCache.remove(oldProcessName + DEFAULT_SEPARATOR + entity.getVersion());				}			}			cache(entity);		} catch(Exception e) {			e.printStackTrace();			log.error(e.getMessage());			throw new SnakerException(e.getMessage(), e.getCause());		}	}
public void undeploy(String id) {		Process entity = access().getProcess(id);		entity.setState(STATE_FINISH);		access().updateProcess(entity);		cache(entity);	}
public void cascadeRemove(String id) {		Process entity = access().getProcess(id);		List<HistoryOrder> historyOrders = access().getHistoryOrders(null, new QueryFilter().setProcessId(id));		for(HistoryOrder historyOrder : historyOrders) {			ServiceContext.getEngine().order().cascadeRemove(historyOrder.getId());		}		access().deleteProcess(entity);		clear(entity);	}
public List<Process> getProcesss(QueryFilter filter) {		if(filter == null) filter = new QueryFilter();		return access().getProcesss(null, filter);	}
public List<Process> getProcesss(Page<Process> page, QueryFilter filter) {		AssertHelper.notNull(filter);		return access().getProcesss(page, filter);	}
private void cache(Process entity) {		Cache<String, String> nameCache = ensureAvailableNameCache();		Cache<String, Process> entityCache = ensureAvailableEntityCache();		if(entity.getModel() == null && entity.getDBContent() != null) {			entity.setModel(ModelParser.parse(entity.getDBContent()));		}		String processName = entity.getName() + DEFAULT_SEPARATOR + entity.getVersion();		if(nameCache != null && entityCache != null) {			if(log.isDebugEnabled()) {				log.debug("cache process id is[{}],name is[{}]", entity.getId(), processName);			}			entityCache.put(processName, entity);			nameCache.put(entity.getId(), processName);		} else {			if(log.isDebugEnabled()) {				log.debug("no cache implementation class");			}		}	}
private void clear(Process entity) {		Cache<String, String> nameCache = ensureAvailableNameCache();		Cache<String, Process> entityCache = ensureAvailableEntityCache();		String processName = entity.getName() + DEFAULT_SEPARATOR + entity.getVersion();		if(nameCache != null && entityCache != null) {			nameCache.remove(entity.getId());			entityCache.remove(processName);		}	}
public static ProcessModel parse(byte[] bytes) {		DocumentBuilder documentBuilder = XmlHelper.createDocumentBuilder();		if(documentBuilder != null) {			Document doc = null;			try {				doc = documentBuilder.parse(new ByteArrayInputStream(bytes));				Element processE = doc.getDocumentElement();				ProcessModel process = new ProcessModel();				process.setName(processE.getAttribute(NodeParser.ATTR_NAME));				process.setDisplayName(processE.getAttribute(NodeParser.ATTR_DISPLAYNAME));				process.setExpireTime(processE.getAttribute(NodeParser.ATTR_EXPIRETIME));				process.setInstanceUrl(processE.getAttribute(NodeParser.ATTR_INSTANCEURL));				process.setInstanceNoClass(processE.getAttribute(NodeParser.ATTR_INSTANCENOCLASS));				NodeList nodeList = processE.getChildNodes();				int nodeSize = nodeList.getLength();				for(int i = 0; i < nodeSize; i++) {					Node node = nodeList.item(i);					if (node.getNodeType() == Node.ELEMENT_NODE) {						NodeModel model = parseModel(node);						process.getNodes().add(model);					}				}								//循环节点模型，构造变迁输入、输出的source、target				for(NodeModel node : process.getNodes()) {					for(TransitionModel transition : node.getOutputs()) {						String to = transition.getTo();						for(NodeModel node2 : process.getNodes()) {							if(to.equalsIgnoreCase(node2.getName())) {								node2.getInputs().add(transition);								transition.setTarget(node2);							}						}					}				}				return process;			} catch (SAXException e) {				e.printStackTrace();				throw new SnakerException(e);			} catch (IOException e) {				throw new SnakerException(e);			}		} else {			throw new SnakerException("documentBuilder is null");		}	}
private static NodeModel parseModel(Node node) {		String nodeName = node.getNodeName();		Element element = (Element)node;		NodeParser nodeParser = null;		try {			nodeParser = ServiceContext.getContext().findByName(nodeName, NodeParser.class);			nodeParser.parse(element);			return nodeParser.getModel();		} catch (RuntimeException e) {			throw new SnakerException(e);		}	}
protected void parseNode(NodeModel node, Element element) {		SubProcessModel model = (SubProcessModel)node;		model.setProcessName(element.getAttribute(ATTR_PROCESSNAME));		String version = element.getAttribute(ATTR_VERSION);		int ver = 0;        if(NumberUtils.isNumber(version)) {        	ver = Integer.parseInt(version);        }		model.setVersion(ver);		String form = element.getAttribute(ATTR_FORM);		if(StringHelper.isNotEmpty(form)) {			model.setForm(form);		} else {			model.setForm(ConfigHelper.getProperty("subprocessurl"));		}	}
public List<TaskModel> getNextTaskModels() {        List<TaskModel> models = new ArrayList<TaskModel>();        for(TransitionModel tm : this.getOutputs()) {            addNextModels(models, tm, TaskModel.class);        }        return models;    }
public Execution createSubExecution(Execution execution, Process process, String parentNodeName) {		return new Execution(execution, process, parentNodeName);	}
public void execute(Execution execution) {		intercept(preInterceptorList, execution);		exec(execution);		intercept(postInterceptorList, execution);	}
protected void runOutTransition(Execution execution) {		for (TransitionModel tm : getOutputs()) {			tm.setEnabled(true);			tm.execute(execution);		}	}
private void intercept(List<SnakerInterceptor> interceptorList, Execution execution) {		try {			for(SnakerInterceptor interceptor : interceptorList) {				interceptor.intercept(execution);			}		} catch(Exception e) {			log.error("拦截器执行失败=" + e.getMessage());            throw new SnakerException(e);		}	}
public static boolean canRejected(NodeModel current, NodeModel parent) {		if(parent instanceof TaskModel && !((TaskModel)parent).isPerformAny()) {			return false;		}        boolean result = false;		for(TransitionModel tm : current.getInputs()) {			NodeModel source = tm.getSource();			if(source == parent) {				return true;			}			if(source instanceof ForkModel					|| source instanceof JoinModel					|| source instanceof SubProcessModel					|| source instanceof StartModel) {				continue;			}			result = result || canRejected(source, parent);		}		return result;	}
public void saveProcess(Process process) {		super.saveProcess(process);		if(process.getBytes() != null) {			Connection conn = null;			PreparedStatement pstmt = null;			try {				conn = getConnection();				pstmt = conn.prepareStatement(PROCESS_UPDATE_BLOB);				pstmt.setBytes(1, process.getBytes());				pstmt.setString(2, process.getId());				pstmt.execute();			} catch (Exception e) {				throw new SnakerException(e.getMessage(), e.getCause());			} finally {				try {					JdbcHelper.close(pstmt);				} catch (SQLException e) {					throw new SnakerException(e.getMessage(), e.getCause());				}			}		}	}
public Object query(int column, String sql, Object... params) {    	Object result;        try {        	if(log.isDebugEnabled()) {        		log.debug("查询单列数据=\n" + sql);        	}            result = runner.query(getConnection(), sql, new ScalarHandler(column), params);        } catch (SQLException e) {            log.error(e.getMessage(), e);            throw new RuntimeException(e.getMessage(), e);        }        return result;    }
protected Connection getConnection() throws SQLException {        if (sessionFactory instanceof SessionFactoryImpl) {            SessionFactoryImpl sessionFactoryImpl = (SessionFactoryImpl) sessionFactory;            ConnectionProvider provider = sessionFactoryImpl.getServiceRegistry().getService(ConnectionProvider.class);            if(provider != null) return provider.getConnection();        }        return null;    }
@SuppressWarnings("unchecked")	public <T> T getProxy(Class<T> clazz) {		return (T)Enhancer.create(clazz, this);	}
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {		Object result = null;		TransactionStatus status = null;		if(isMatch(method.getName())) {			if(log.isDebugEnabled()) {				log.debug("intercept method is[name="  + method.getName() + "]");			}			try {				status = getTransaction();				AssertHelper.notNull(status);				//调用具体无事务支持的业务逻辑				result = proxy.invokeSuper(obj, args);				//如果整个执行过程无异常抛出，则提交TransactionStatus持有的transaction对象				if(status.isNewTransaction()) {					commit(status);				}			} catch (Exception e) {				rollback(status);				throw new SnakerException(e);			}		} else {			if(log.isDebugEnabled()) {				log.debug("****don't intercept method is[name="  + method.getName() + "]");			}			result = proxy.invokeSuper(obj, args);		}		return result;	}
private boolean isMatch(String methodName) {		for(String pattern : txMethods) {			if(StringHelper.simpleMatch(pattern, methodName)) {				return true;			}		}		return false;	}
public Order createOrder(Process process, String operator, Map<String, Object> args) {		return createOrder(process, operator, args, null, null);	}
public Order createOrder(Process process, String operator, Map<String, Object> args, 			String parentId, String parentNodeName) {		Order order = new Order();		order.setId(StringHelper.getPrimaryKey());		order.setParentId(parentId);		order.setParentNodeName(parentNodeName);		order.setCreateTime(DateHelper.getTime());		order.setLastUpdateTime(order.getCreateTime());		order.setCreator(operator);		order.setLastUpdator(order.getCreator());		order.setProcessId(process.getId());		ProcessModel model = process.getModel();		if(model != null && args != null) {			if(StringHelper.isNotEmpty(model.getExpireTime())) {				String expireTime = DateHelper.parseTime(args.get(model.getExpireTime()));				order.setExpireTime(expireTime);			}            String orderNo = (String)args.get(SnakerEngine.ID);            if(StringHelper.isNotEmpty(orderNo)) {                order.setOrderNo(orderNo);            } else {                order.setOrderNo(model.getGenerator().generate(model));            }		}		order.setVariable(JsonHelper.toJson(args));		saveOrder(order);		return order;	}
public void addVariable(String orderId, Map<String, Object> args) {        Order order = access().getOrder(orderId);        Map<String, Object> data = order.getVariableMap();        data.putAll(args);        order.setVariable(JsonHelper.toJson(data));        access().updateOrderVariable(order);    }
public void createCCOrder(String orderId, String creator, String... actorIds) {		for(String actorId : actorIds) {			CCOrder ccorder = new CCOrder();			ccorder.setOrderId(orderId);			ccorder.setActorId(actorId);            ccorder.setCreator(creator);			ccorder.setStatus(STATE_ACTIVE);            ccorder.setCreateTime(DateHelper.getTime());			access().saveCCOrder(ccorder);		}	}
public void saveOrder(Order order) {		HistoryOrder history = new HistoryOrder(order);		history.setOrderState(STATE_ACTIVE);		access().saveOrder(order);		access().saveHistory(history);	}
public void updateCCStatus(String orderId, String... actorIds) {        List<CCOrder> ccorders = access().getCCOrder(orderId, actorIds);        AssertHelper.notNull(ccorders);        for(CCOrder ccorder : ccorders) {            ccorder.setStatus(STATE_FINISH);            ccorder.setFinishTime(DateHelper.getTime());            access().updateCCOrder(ccorder);        }	}
public void deleteCCOrder(String orderId, String actorId) {        List<CCOrder> ccorders = access().getCCOrder(orderId, actorId);		AssertHelper.notNull(ccorders);        for(CCOrder ccorder : ccorders) {		    access().deleteCCOrder(ccorder);        }	}
public void complete(String orderId) {		Order order = access().getOrder(orderId);		HistoryOrder history = access().getHistOrder(orderId);		history.setOrderState(STATE_FINISH);		history.setEndTime(DateHelper.getTime());				access().updateHistory(history);		access().deleteOrder(order);        Completion completion = getCompletion();        if(completion != null) {            completion.complete(history);        }	}
public void terminate(String orderId, String operator) {		SnakerEngine engine = ServiceContext.getEngine();		List<Task> tasks = engine				.query()				.getActiveTasks(new QueryFilter().setOrderId(orderId));		for(Task task : tasks) {			engine.task().complete(task.getId(), operator);		}		Order order = access().getOrder(orderId);		HistoryOrder history = new HistoryOrder(order);		history.setOrderState(STATE_TERMINATION);		history.setEndTime(DateHelper.getTime());				access().updateHistory(history);		access().deleteOrder(order);        Completion completion = getCompletion();        if(completion != null) {            completion.complete(history);        }	}
public Order resume(String orderId) {        HistoryOrder historyOrder = access().getHistOrder(orderId);        Order order = historyOrder.undo();        access().saveOrder(order);        historyOrder.setOrderState(STATE_ACTIVE);        access().updateHistory(historyOrder);        SnakerEngine engine = ServiceContext.getEngine();        List<HistoryTask> histTasks = access().getHistoryTasks(null,                new QueryFilter().setOrderId(orderId));        if(histTasks != null && !histTasks.isEmpty()) {            HistoryTask histTask = histTasks.get(0);            engine.task().resume(histTask.getId(), histTask.getOperator());        }        return order;    }
public void cascadeRemove(String id) {		HistoryOrder historyOrder = access().getHistOrder(id);		AssertHelper.notNull(historyOrder);		List<Task> activeTasks = access().getActiveTasks(null, new QueryFilter().setOrderId(id));		List<HistoryTask> historyTasks = access().getHistoryTasks(null, new QueryFilter().setOrderId(id));		for(Task task : activeTasks) {			access().deleteTask(task);		}		for(HistoryTask historyTask : historyTasks) {			access().deleteHistoryTask(historyTask);		}		List<CCOrder> ccOrders = access().getCCOrder(id);		for(CCOrder ccOrder : ccOrders) {			access().deleteCCOrder(ccOrder);		}		Order order = access().getOrder(id);		access().deleteHistoryOrder(historyOrder);		if(order != null) {			access().deleteOrder(order);		}	}
private Map<String, Object> buildMap(String sql, Object[] args, int[] type) {		Map<String, Object> map = new HashMap<String, Object>();		map.put(KEY_SQL, sql);		map.put(KEY_ARGS, args);		map.put(KEY_TYPE, type);		return map;	}
private Map<String, Object> buildMap(Object entity, String su) {		Map<String, Object> map = new HashMap<String, Object>();		map.put(KEY_ENTITY, entity);		map.put(KEY_SU, su);		return map;	}
protected Dialect getDialect() {        if(dialect != null) return dialect;		dialect = ServiceContext.getContext().find(Dialect.class);		if(dialect == null) {			try {				dialect = JdbcHelper.getDialect(getConnection());			} catch (Exception e) {				log.error("Unable to find the available dialect.Please configure dialect to snaker.xml");			}		}		return dialect;	}
public void saveProcess(Process process) {		if(isORM()) {			saveOrUpdate(buildMap(process, SAVE));		} else {			Object[] args = new Object[]{process.getId(), process.getName(), process.getDisplayName(), process.getType(), 					process.getInstanceUrl(), process.getState(), process.getVersion(), process.getCreateTime(), process.getCreator()};			int[] type = new int[]{Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.INTEGER, 					Types.VARCHAR, Types.INTEGER, Types.INTEGER, Types.VARCHAR, Types.VARCHAR};			saveOrUpdate(buildMap(PROCESS_INSERT, args, type));		}	}
public void updateProcess(Process process) {		if(isORM()) {			saveOrUpdate(buildMap(process, UPDATE));		} else {			Object[] args = new Object[]{process.getName(), process.getDisplayName(), process.getState(), 					process.getInstanceUrl(), process.getCreateTime(), process.getCreator(), process.getId()};			int[] type = new int[]{Types.VARCHAR, Types.VARCHAR, Types.INTEGER, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR};			saveOrUpdate(buildMap(PROCESS_UPDATE, args, type));		}	}
public void runScript() {        String autoStr = ConfigHelper.getProperty("schema.auto");        if(autoStr == null || !autoStr.equalsIgnoreCase("true")) {            return;        }        Connection conn = null;        try {            conn = getConnection();            if(JdbcHelper.isExec(conn)) {                log.info("script has completed execution.skip this step");                return;            }            String databaseType = JdbcHelper.getDatabaseType(conn);            String schema = "db/core/schema-" + databaseType + ".sql";            ScriptRunner runner = new ScriptRunner(conn, true);            runner.runScript(schema);        } catch (Exception e) {            throw new SnakerException(e);        } finally {            try {                JdbcHelper.close(conn);            } catch (SQLException e) {                //ignore            }        }    }
public static <T> T fromJson(String jsonString, Class<T> clazz) {		if (StringHelper.isEmpty(jsonString)) {			return null;		}		try {			return mapper.readValue(jsonString, clazz);		} catch (Exception e) {			log.warn("parse json string error:" + jsonString, e);			return null;		}	}
public static String getProperty(String key) {        if (key == null) {            return null;        }        return getProperties().getProperty(key);    }
public static int getNumerProperty(String key) {        String value = getProperties().getProperty(key);        if(NumberUtils.isNumber(value)) {        	return Integer.parseInt(value);        } else {        	return 0;        }    }
public static void loadProperties(String filename) {    	InputStream in = null;        ClassLoader threadContextClassLoader = Thread.currentThread().getContextClassLoader();        properties = new Properties();        if (threadContextClassLoader != null) {        	in = threadContextClassLoader.getResourceAsStream(filename);        }        if (in == null) {        	in = ConfigHelper.class.getResourceAsStream(filename);            if (in == null) {                log.warn("No properties file found in the classpath by filename " + filename);            }        } else {            try {                properties.load(in);                log.info("Properties read " + properties);            } catch (Exception e) {                log.error("Error reading from " + filename, e);            } finally {                try {                    in.close();                } catch (IOException e) {                    log.warn("IOException while closing InputStream: " + e.getMessage());                }            }        }    }
protected boolean noMoreCharacters() throws IOException {		if (avail == 0) {			avail = is.read(buffer);			if (avail <= 0) {				avail = 0;				return true;			}			pos = 0;		}		return false;	}
public int readLine(final byte[] array, final EnumSet<LineTerminator> terminators) throws IOException {		return readLine(array, 0, array.length, terminators);	}
public int readLine(final byte[] array, final int off, final int len) throws IOException {		return readLine(array, off, len, ALL_TERMINATORS);	}
public int readLine(final byte[] array, final int off, final int len, final EnumSet<LineTerminator> terminators) throws IOException {		ByteArrays.ensureOffsetLength(array ,off, len);		if (len == 0) return 0; // 0-length reads always return 0		if (noMoreCharacters()) return -1;		int i, k = 0, remaining = len, read = 0; // The number of bytes still to be read		for(;;) {			for(i = 0; i < avail && i < remaining && (k = buffer[pos + i]) != '\n' && k != '\r' ; i++);			System.arraycopy(buffer, pos, array, off + read, i);			pos += i;			avail -= i;			read += i;			remaining -= i;			if (remaining == 0) {				readBytes += read;				return read; // We did not stop because of a terminator			}			if (avail > 0) { // We met a terminator				if (k == '\n') { // LF first					pos++;					avail--;					if (terminators.contains(LineTerminator.LF)) {						readBytes += read + 1;						return read;					}					else {						array[off + read++] = '\n';						remaining--;					}				}				else if (k == '\r') { // CR first					pos++;					avail--;					if (terminators.contains(LineTerminator.CR_LF)) {						if (avail > 0) {							if (buffer[pos] == '\n') { // CR/LF with LF already in the buffer.								pos ++;								avail--;								readBytes += read + 2;								return read;							}						}						else { // We must search for the LF.							if (noMoreCharacters()) {								// Not found a matching LF because of end of file, will return CR in buffer if not a terminator								if (! terminators.contains(LineTerminator.CR)) {									array[off + read++] = '\r';									remaining--;									readBytes += read;								}								else readBytes += read + 1;								return read;							}							if (buffer[0] == '\n') {								// Found matching LF, won't return terminators in the buffer								pos++;								avail--;								readBytes += read + 2;								return read;							}						}					}					if (terminators.contains(LineTerminator.CR)) {						readBytes += read + 1;						return read;					}					array[off + read++] = '\r';					remaining--;				}			}			else if (noMoreCharacters()) {				readBytes += read;				return read;			}		}	}
@Override	public long length() throws IOException {		if (measurableStream != null) return measurableStream.length();		if (fileChannel != null) return fileChannel.size();		throw new UnsupportedOperationException();	}
private long skipByReading(final long n) throws IOException {		long toSkip = n;		int len;		while(toSkip > 0) {			len = is.read(buffer, 0, (int)Math.min(buffer.length, toSkip));			if (len > 0) toSkip -= len;			else break;		}		return n - toSkip;	}
@Override	public long skip(final long n) throws IOException {		if (n <= avail) {			final int m = (int)n;			pos += m;			avail -= m;			readBytes += n;			return n;		}		long toSkip = n - avail, result = 0;		avail = 0;		while (toSkip != 0 && (result = is == System.in ? skipByReading(toSkip) : is.skip(toSkip)) < toSkip) {			if (result == 0) {				if (is.read() == -1) break;				toSkip--;			}			else toSkip -= result;		}		final long t = n - (toSkip - result);		readBytes += t;		return t;	}
public static void ensureFromTo(final int arrayLength, final int from, final int to) {		if (from < 0) throw new ArrayIndexOutOfBoundsException("Start index (" + from + ") is negative");		if (from > to) throw new IllegalArgumentException("Start index (" + from + ") is greater than end index (" + to + ")");		if (to > arrayLength) throw new ArrayIndexOutOfBoundsException("End index (" + to + ") is greater than array length (" + arrayLength + ")");	}
public static void ensureOffsetLength(final int arrayLength, final int offset, final int length) {		if (offset < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");		if (length < 0) throw new IllegalArgumentException("Length (" + length + ") is negative");		if (offset + length > arrayLength) throw new ArrayIndexOutOfBoundsException("Last index (" + (offset + length) + ") is greater than array length (" + arrayLength + ")");	}
private static void inPlaceMerge(final int from, int mid, final int to, final IntComparator comp, final Swapper swapper) {		if (from >= mid || mid >= to) return;		if (to - from == 2) {			if (comp.compare(mid, from) < 0) swapper.swap(from, mid);			return;		}		int firstCut;		int secondCut;		if (mid - from > to - mid) {			firstCut = from + (mid - from) / 2;			secondCut = lowerBound(mid, to, firstCut, comp);		}		else {			secondCut = mid + (to - mid) / 2;			firstCut = upperBound(from, mid, secondCut, comp);		}		int first2 = firstCut;		int middle2 = mid;		int last2 = secondCut;		if (middle2 != first2 && middle2 != last2) {			int first1 = first2;			int last1 = middle2;			while (first1 < --last1)				swapper.swap(first1++, last1);			first1 = middle2;			last1 = last2;			while (first1 < --last1)				swapper.swap(first1++, last1);			first1 = first2;			last1 = last2;			while (first1 < --last1)				swapper.swap(first1++, last1);		}		mid = firstCut + (secondCut - mid);		inPlaceMerge(from, firstCut, mid, comp, swapper);		inPlaceMerge(mid, secondCut, to, comp, swapper);	}
private static int lowerBound(int from, final int to, final int pos, final IntComparator comp) {		// if (comp==null) throw new NullPointerException();		int len = to - from;		while (len > 0) {			int half = len / 2;			int middle = from + half;			if (comp.compare(middle, pos) < 0) {				from = middle + 1;				len -= half + 1;			}			else {				len = half;			}		}		return from;	}
private static int upperBound(int from, final int mid, final int pos, final IntComparator comp) {		// if (comp==null) throw new NullPointerException();		int len = mid - from;		while (len > 0) {			int half = len / 2;			int middle = from + half;			if (comp.compare(pos, middle) < 0) {				len = half;			}			else {				from = middle + 1;				len -= half + 1;			}		}		return from;	}
public static void mergeSort(final int from, final int to, final IntComparator c, final Swapper swapper) {		/*		 * We retain the same method signature as quickSort. Given only a comparator and swapper we		 * do not know how to copy and move elements from/to temporary arrays. Hence, in contrast to		 * the JDK mergesorts this is an "in-place" mergesort, i.e. does not allocate any temporary		 * arrays. A non-inplace mergesort would perhaps be faster in most cases, but would require		 * non-intuitive delegate objects...		 */		final int length = to - from;		// Insertion sort on smallest arrays		if (length < MERGESORT_NO_REC) {			for (int i = from; i < to; i++) {				for (int j = i; j > from && (c.compare(j - 1, j) > 0); j--) {					swapper.swap(j, j - 1);				}			}			return;		}		// Recursively sort halves		int mid = (from + to) >>> 1;		mergeSort(from, mid, c, swapper);		mergeSort(mid, to, c, swapper);		// If list is already sorted, nothing left to do. This is an		// optimization that results in faster sorts for nearly ordered lists.		if (c.compare(mid - 1, mid) <= 0) return;		// Merge sorted halves		inPlaceMerge(from, mid, to, c, swapper);	}
protected static void swap(final Swapper swapper, int a, int b, final int n) {		for (int i = 0; i < n; i++, a++, b++) swapper.swap(a, b);	}
public static void parallelQuickSort(final int from, final int to, final IntComparator comp, final Swapper swapper) {		final ForkJoinPool pool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());		pool.invoke(new ForkJoinGenericQuickSort(from, to, comp, swapper));		pool.shutdown();	}
public static void quickSort(final int from, final int to, final IntComparator comp, final Swapper swapper) {		final int len = to - from;		// Insertion sort on smallest arrays		if (len < QUICKSORT_NO_REC) {			for (int i = from; i < to; i++)				for (int j = i; j > from && (comp.compare(j - 1, j) > 0); j--) {					swapper.swap(j, j - 1);				}			return;		}		// Choose a partition element, v		int m = from + len / 2; // Small arrays, middle element		int l = from;		int n = to - 1;		if (len > QUICKSORT_MEDIAN_OF_9) { // Big arrays, pseudomedian of 9			int s = len / 8;			l = med3(l, l + s, l + 2 * s, comp);			m = med3(m - s, m, m + s, comp);			n = med3(n - 2 * s, n - s, n, comp);		}		m = med3(l, m, n, comp); // Mid-size, med of 3		// int v = x[m];		int a = from;		int b = a;		int c = to - 1;		// Establish Invariant: v* (<v)* (>v)* v*		int d = c;		while (true) {			int comparison;			while (b <= c && ((comparison = comp.compare(b, m)) <= 0)) {				if (comparison == 0) {					// Fix reference to pivot if necessary					if (a == m) m = b;					else if (b == m) m = a;					swapper.swap(a++, b);				}				b++;			}			while (c >= b && ((comparison = comp.compare(c, m)) >= 0)) {				if (comparison == 0) {					// Fix reference to pivot if necessary					if (c == m) m = d;					else if (d == m) m = c;					swapper.swap(c, d--);				}				c--;			}			if (b > c) break;			// Fix reference to pivot if necessary			if (b == m) m = d;			else if (c == m) m = c;			swapper.swap(b++, c--);		}		// Swap partition elements back to middle		int s;		s = Math.min(a - from, b - a);		swap(swapper, from, b - s, s);		s = Math.min(d - c, to - d - 1);		swap(swapper, b, to - s, s);		// Recursively sort non-partition-elements		if ((s = b - a) > 1) quickSort(from, from + s, comp, swapper);		if ((s = d - c) > 1) quickSort(to - s, to, comp, swapper);	}
public static int murmurHash3(int x) {		x ^= x >>> 16;		x *= 0x85ebca6b;		x ^= x >>> 13;		x *= 0xc2b2ae35;		x ^= x >>> 16;		return x;	}
public static long murmurHash3(long x) {		x ^= x >>> 33;		x *= 0xff51afd7ed558ccdL;		x ^= x >>> 33;		x *= 0xc4ceb9fe1a85ec53L;		x ^= x >>> 33;		return x;	}
public void clear() throws IOException {		if (! fileChannel.isOpen()) throw new IOException("This " + getClass().getSimpleName() + " is closed");		writePosition = position = inspectable = 0;		mark = -1;	}
@Override	public int write(final ByteBuffer byteBuffer) throws IOException {		ensureOpen();		final int remaining = byteBuffer.remaining();		if (inspectable < buffer.length) {			// Still some space in the inspectable buffer.			final int toBuffer = Math.min(buffer.length - inspectable, remaining);			byteBuffer.get(buffer, inspectable, toBuffer);			inspectable += toBuffer;		}		if (byteBuffer.hasRemaining()) {			fileChannel.position(writePosition);			writePosition += fileChannel.write(byteBuffer);		}		return remaining;	}
public void truncate(final long size) throws FileNotFoundException, IOException {		fileChannel.truncate(Math.max(size, writePosition));	}
@Override	public int read(final byte b[], final int offset, final int length) {		if (this.length == this.position) return length == 0 ? 0 : -1;		final int n = Math.min(length, this.length - this.position);		System.arraycopy(array, this.offset + this.position, b, offset, n);		this.position += n;		return n;	}
@Override	public void position(final long newPosition) throws IOException {		flush();		if (repositionableStream != null) repositionableStream.position(newPosition);		else if (fileChannel != null) fileChannel.position(newPosition);		else throw new UnsupportedOperationException("position() can only be called if the underlying byte stream implements the RepositionableStream interface or if the getChannel() method of the underlying byte stream exists and returns a FileChannel");	}
@Override    public final void transitionsPlanned(long beforeVersion, long desiredVersion, boolean isSnapshotPlan, List<HollowConsumer.Blob.BlobType> transitionSequence) {        updatePlanDetails.beforeVersion = beforeVersion;        updatePlanDetails.desiredVersion = desiredVersion;        updatePlanDetails.transitionSequence = transitionSequence;        if (isSnapshotPlan) {            overallRefreshType = BlobType.SNAPSHOT;        } else {            overallRefreshType = desiredVersion > beforeVersion ? BlobType.DELTA : BlobType.REVERSE_DELTA;        }        refreshMetricsBuilder.setOverallRefreshType(overallRefreshType);    }
private final void noFailRefreshEndMetricsReporting(ConsumerRefreshMetrics refreshMetrics) {        try {            refreshEndMetricsReporting(refreshMetrics);        } catch (Exception e) {            // Metric reporting is not considered critical to consumer refresh. Log exceptions and continue.            log.log(Level.SEVERE, "Encountered an exception in reporting consumer refresh metrics, ignoring exception and continuing with consumer refresh", e);        }    }
public void awaitSuccessfulCompletionOfCurrentTasks() throws InterruptedException, ExecutionException {        for(Future<?> f : futures) {            f.get();        }        futures.clear();    }
public static <T extends HollowRecord> Builder<T> from(HollowConsumer consumer, Class<T> rootType) {        Objects.requireNonNull(consumer);        Objects.requireNonNull(rootType);        return new Builder<>(consumer, rootType);    }
public Stream<S> findMatches(Q query) {        Object[] queryArray = matchFields.stream().map(mf -> mf.extract(query)).toArray();        HollowHashIndexResult matches = hhi.findMatches(queryArray);        if (matches == null) {            return Stream.empty();        }        return matches.stream().mapToObj(i -> selectField.extract(api, i));    }
public void compact() {        Set<String> compactionTargets = findCompactionTargets();                Map<String, BitSet> relocatedOrdinals = new HashMap<String, BitSet>();        PartialOrdinalRemapper remapper = new PartialOrdinalRemapper();                for(String compactionTarget : compactionTargets) {            HollowTypeReadState typeState = readEngine.getTypeState(compactionTarget);            HollowTypeWriteState writeState = writeEngine.getTypeState(compactionTarget);            BitSet populatedOrdinals = typeState.getListener(PopulatedOrdinalListener.class).getPopulatedOrdinals();            BitSet typeRelocatedOrdinals = new BitSet(populatedOrdinals.length());            int populatedCardinality = populatedOrdinals.cardinality();                        writeState.addAllObjectsFromPreviousCycle();                        int numRelocations = 0;            int ordinalToRelocate = populatedOrdinals.nextSetBit(populatedCardinality);            while(ordinalToRelocate != -1) {                numRelocations++;                ordinalToRelocate = populatedOrdinals.nextSetBit(ordinalToRelocate+1);            }                        HollowRecordCopier copier = HollowRecordCopier.createCopier(typeState);            IntMap remappedOrdinals = new IntMap(numRelocations);                        ordinalToRelocate = populatedOrdinals.length();            int relocatePosition = -1;                        try {                                for(int i=0;i<numRelocations;i++) {                    while(!populatedOrdinals.get(--ordinalToRelocate));                    relocatePosition = populatedOrdinals.nextClearBit(relocatePosition + 1);                    typeRelocatedOrdinals.set(ordinalToRelocate);                    writeState.removeOrdinalFromThisCycle(ordinalToRelocate);                    HollowWriteRecord rec = copier.copy(ordinalToRelocate);                    writeState.mapOrdinal(rec, relocatePosition, false, true);                    remappedOrdinals.put(ordinalToRelocate, relocatePosition);                }                            } finally {                writeState.recalculateFreeOrdinals();            }                        remapper.addOrdinalRemapping(compactionTarget, remappedOrdinals);            relocatedOrdinals.put(compactionTarget, typeRelocatedOrdinals);        }                /// find the referencing dependents        TransitiveSetTraverser.addReferencingOutsideClosure(readEngine, relocatedOrdinals);                /// copy all forward except remapped and transitive dependents of remapped        for(HollowSchema schema : HollowSchemaSorter.dependencyOrderedSchemaList(writeEngine.getSchemas())) {            if(!compactionTargets.contains(schema.getName())) {                HollowTypeWriteState writeState = writeEngine.getTypeState(schema.getName());                                writeState.addAllObjectsFromPreviousCycle();                                BitSet typeRelocatedOrdinals = relocatedOrdinals.get(schema.getName());                if(typeRelocatedOrdinals != null) {                    HollowTypeReadState readState = readEngine.getTypeState(schema.getName());                    IntMap remappedOrdinals = new IntMap(typeRelocatedOrdinals.cardinality());                                        boolean preserveHashPositions = shouldPreserveHashPositions(schema);                    HollowRecordCopier copier = HollowRecordCopier.createCopier(readState, remapper, preserveHashPositions);                                        int remapOrdinal = typeRelocatedOrdinals.nextSetBit(0);                    while(remapOrdinal != -1) {                        HollowWriteRecord rec = copier.copy(remapOrdinal);                        int newOrdinal = writeState.add(rec);                        remappedOrdinals.put(remapOrdinal, newOrdinal);                        writeState.removeOrdinalFromThisCycle(remapOrdinal);                                                remapOrdinal = typeRelocatedOrdinals.nextSetBit(remapOrdinal + 1);                    }                                        remapper.addOrdinalRemapping(schema.getName(), remappedOrdinals);                }            }        }    }
private Set<String> findCompactionTargets() {        List<HollowSchema> schemas = HollowSchemaSorter.dependencyOrderedSchemaList(readEngine.getSchemas());        Set<String> typesToCompact = new HashSet<String>();        for(HollowSchema schema : schemas) {            if(isCompactionCandidate(schema.getName())) {                if(!candidateIsDependentOnAnyTargetedType(schema.getName(), typesToCompact))                    typesToCompact.add(schema.getName());            }        }                return typesToCompact;    }
public int getMatchingOrdinal(Object key) {        PrimaryKeyIndexHashTable hashTable = hashTableVolatile;        if(fieldPathIndexes.length != 1 || hashTable.bitsPerElement == 0)            return -1;        int hashCode = keyHashCode(key, 0);        int ordinal = -1;        do {            hashTable = this.hashTableVolatile;            int bucket = hashCode & hashTable.hashMask;            ordinal = readOrdinal(hashTable, bucket);            while(ordinal != -1) {                if(keyDeriver.keyMatches(key, ordinal, 0))                    break;                bucket++;                bucket &= hashTable.hashMask;                ordinal = readOrdinal(hashTable, bucket);            }        } while(hashTableVolatile != hashTable);        return ordinal;    }
public int getMatchingOrdinal(Object... keys) {        PrimaryKeyIndexHashTable hashTable = hashTableVolatile;        if(fieldPathIndexes.length != keys.length || hashTable.bitsPerElement == 0)            return -1;        int hashCode = 0;        for(int i=0;i<keys.length;i++)            hashCode ^= keyHashCode(keys[i], i);        int ordinal = -1;        do {            hashTable = this.hashTableVolatile;            int bucket = hashCode & hashTable.hashMask;            ordinal = readOrdinal(hashTable, bucket);            while(ordinal != -1) {                if(keyDeriver.keyMatches(ordinal, keys))                    break;                bucket++;                bucket &= hashTable.hashMask;                ordinal = readOrdinal(hashTable, bucket);            }        } while(hashTableVolatile != hashTable);        return ordinal;    }
public void set(long index, long value) {        int segmentIndex = (int)(index >> log2OfSegmentSize);        int longInSegment = (int)(index & bitmask);        unsafe.putOrderedLong(segments[segmentIndex], (long)Unsafe.ARRAY_LONG_BASE_OFFSET + (8 * longInSegment), value);        /// duplicate the longs here so that we can read faster.        if(longInSegment == 0 && segmentIndex != 0)            unsafe.putOrderedLong(segments[segmentIndex - 1], (long)Unsafe.ARRAY_LONG_BASE_OFFSET + (8 * (1 << log2OfSegmentSize)), value);    }
@Override    public void cleanSnapshots() {        File[] files = getFilesByType(HollowProducer.Blob.Type.SNAPSHOT.prefix);        if(files == null || files.length <= numOfSnapshotsToKeep) {            return;        }        sortByLastModified(files);        for(int i= numOfSnapshotsToKeep; i < files.length; i++){            File file = files[i];            boolean deleted = file.delete();            if(!deleted) {                log.warning("Could not delete snapshot " + file.getPath());            }        }    }
public static int fieldHashCode(HollowObjectTypeDataAccess typeAccess, int ordinal, int fieldPosition) {        HollowObjectSchema schema = typeAccess.getSchema();        switch(schema.getFieldType(fieldPosition)) {            case BOOLEAN:                Boolean bool = typeAccess.readBoolean(ordinal, fieldPosition);                return booleanHashCode(bool);            case BYTES:            case STRING:                return typeAccess.findVarLengthFieldHashCode(ordinal, fieldPosition);            case DOUBLE:                double d = typeAccess.readDouble(ordinal, fieldPosition);                return doubleHashCode(d);            case FLOAT:                float f = typeAccess.readFloat(ordinal, fieldPosition);                return floatHashCode(f);            case INT:                return intHashCode(typeAccess.readInt(ordinal, fieldPosition));            case LONG:                long l = typeAccess.readLong(ordinal, fieldPosition);                return longHashCode(l);            case REFERENCE:                return typeAccess.readOrdinal(ordinal, fieldPosition);        }        throw new IllegalStateException("I don't know how to hash a " + schema.getFieldType(fieldPosition));    }
public static boolean fieldsAreEqual(HollowObjectTypeDataAccess typeAccess1, int ordinal1, int fieldPosition1, HollowObjectTypeDataAccess typeAccess2, int ordinal2, int fieldPosition2) {        HollowObjectSchema schema1 = typeAccess1.getSchema();        switch(schema1.getFieldType(fieldPosition1)) {            case BOOLEAN:                Boolean bool1 = typeAccess1.readBoolean(ordinal1, fieldPosition1);                Boolean bool2 = typeAccess2.readBoolean(ordinal2, fieldPosition2);                return bool1 == bool2;            case BYTES:                byte[] data1 = typeAccess1.readBytes(ordinal1, fieldPosition1);                byte[] data2 = typeAccess2.readBytes(ordinal2, fieldPosition2);                return Arrays.equals(data1, data2);            case DOUBLE:                double d1 = typeAccess1.readDouble(ordinal1, fieldPosition1);                double d2 = typeAccess2.readDouble(ordinal2, fieldPosition2);                return Double.compare(d1, d2) == 0;            case FLOAT:                float f1 = typeAccess1.readFloat(ordinal1, fieldPosition1);                float f2 = typeAccess2.readFloat(ordinal2, fieldPosition2);                return Float.compare(f1, f2) == 0;            case INT:                int i1 = typeAccess1.readInt(ordinal1, fieldPosition1);                int i2 = typeAccess2.readInt(ordinal2, fieldPosition2);                return i1 == i2;            case LONG:                long l1 = typeAccess1.readLong(ordinal1, fieldPosition1);                long l2 = typeAccess2.readLong(ordinal2, fieldPosition2);                return l1 == l2;            case STRING:                String s1 = typeAccess1.readString(ordinal1, fieldPosition1);                return typeAccess2.isStringFieldEqual(ordinal2, fieldPosition2, s1);            case REFERENCE:                if(typeAccess1 == typeAccess2 && fieldPosition1 == fieldPosition2)                    return typeAccess1.readOrdinal(ordinal1, fieldPosition1) == typeAccess2.readOrdinal(ordinal2, fieldPosition2);            default:        }        throw new IllegalStateException("I don't know how to test equality for a " + schema1.getFieldType(fieldPosition1));    }
public static void addTransitiveMatches(HollowReadStateEngine stateEngine, Map<String, BitSet> matches) {        List<HollowSchema> schemaList = HollowSchemaSorter.dependencyOrderedSchemaList(stateEngine);        Collections.reverse(schemaList);        for(HollowSchema schema : schemaList) {            BitSet currentMatches = matches.get(schema.getName());            if(currentMatches != null) {                addTransitiveMatches(stateEngine, schema.getName(), matches);            }        }    }
public static void removeReferencedOutsideClosure(HollowReadStateEngine stateEngine, Map<String, BitSet> matches) {        List<HollowSchema> orderedSchemas = HollowSchemaSorter.dependencyOrderedSchemaList(stateEngine);        Collections.reverse(orderedSchemas);        for(HollowSchema referencedSchema : orderedSchemas) {            if(matches.containsKey(referencedSchema.getName())) {                for(HollowSchema referencerSchema : orderedSchemas) {                    if(referencerSchema == referencedSchema)                        break;                    if(matches.containsKey(referencedSchema.getName()) && matches.get(referencedSchema.getName()).cardinality() > 0)                        traverseReferencesOutsideClosure(stateEngine, referencerSchema.getName(), referencedSchema.getName(), matches, REMOVE_REFERENCED_OUTSIDE_CLOSURE);                }            }        }    }
public static void addReferencingOutsideClosure(HollowReadStateEngine stateEngine, Map<String, BitSet> matches) {        List<HollowSchema> orderedSchemas = HollowSchemaSorter.dependencyOrderedSchemaList(stateEngine);        for(HollowSchema referencerSchema : orderedSchemas) {            for(HollowSchema referencedSchema : orderedSchemas) {                if(referencedSchema == referencerSchema)                    break;                if(matches.containsKey(referencedSchema.getName()) && matches.get(referencedSchema.getName()).cardinality() > 0)                    traverseReferencesOutsideClosure(stateEngine, referencerSchema.getName(), referencedSchema.getName(), matches, ADD_REFERENCING_OUTSIDE_CLOSURE);            }        }    }
public synchronized boolean updateTo(long requestedVersion) throws Throwable {        if (requestedVersion == getCurrentVersionId()) {            if (requestedVersion == HollowConstants.VERSION_NONE && hollowDataHolderVolatile == null) {                LOG.warning("No versions to update to, initializing to empty state");                // attempting to refresh, but no available versions - initialize to empty state                hollowDataHolderVolatile = newHollowDataHolder();                forceDoubleSnapshotNextUpdate(); // intentionally ignore doubleSnapshotConfig            }            return true;        }        // Take a snapshot of the listeners to ensure additions or removals may occur concurrently        // but will not take effect until a subsequent refresh        final HollowConsumer.RefreshListener[] localListeners =                refreshListeners.toArray(new HollowConsumer.RefreshListener[0]);        long beforeVersion = getCurrentVersionId();        for (HollowConsumer.RefreshListener listener : localListeners)            listener.refreshStarted(beforeVersion, requestedVersion);        try {            HollowUpdatePlan updatePlan = shouldCreateSnapshotPlan()                ? planner.planInitializingUpdate(requestedVersion)                : planner.planUpdate(hollowDataHolderVolatile.getCurrentVersion(), requestedVersion,                        doubleSnapshotConfig.allowDoubleSnapshot());            for (HollowConsumer.RefreshListener listener : localListeners)                if (listener instanceof HollowConsumer.TransitionAwareRefreshListener)                    ((HollowConsumer.TransitionAwareRefreshListener)listener).transitionsPlanned(beforeVersion, requestedVersion, updatePlan.isSnapshotPlan(), updatePlan.getTransitionSequence());            if (updatePlan.destinationVersion() == HollowConstants.VERSION_NONE                    && requestedVersion != HollowConstants.VERSION_LATEST)                throw new IllegalArgumentException(String.format("Could not create an update plan for version %s, because that version or any previous versions could not be retrieved.", requestedVersion));            if (updatePlan.equals(HollowUpdatePlan.DO_NOTHING)                    && requestedVersion == HollowConstants.VERSION_LATEST)                throw new IllegalArgumentException("Could not create an update plan, because no existing versions could be retrieved.");            if (updatePlan.destinationVersion(requestedVersion) == getCurrentVersionId())                return true;            if (updatePlan.isSnapshotPlan()) {                if (hollowDataHolderVolatile == null || doubleSnapshotConfig.allowDoubleSnapshot()) {                    hollowDataHolderVolatile = newHollowDataHolder();                    hollowDataHolderVolatile.update(updatePlan, localListeners);                    forceDoubleSnapshot = false;                }            } else {                hollowDataHolderVolatile.update(updatePlan, localListeners);            }            for(HollowConsumer.RefreshListener refreshListener : localListeners)                refreshListener.refreshSuccessful(beforeVersion, getCurrentVersionId(), requestedVersion);            metrics.updateTypeStateMetrics(getStateEngine(), requestedVersion);            if(metricsCollector != null)                metricsCollector.collect(metrics);            initialLoad.complete(getCurrentVersionId()); // only set the first time            return getCurrentVersionId() == requestedVersion;        } catch(Throwable th) {            forceDoubleSnapshotNextUpdate();            metrics.updateRefreshFailed();            if(metricsCollector != null)                metricsCollector.collect(metrics);            for(HollowConsumer.RefreshListener refreshListener : localListeners)                refreshListener.refreshFailed(beforeVersion, getCurrentVersionId(), requestedVersion, th);            // intentionally omitting a call to initialLoad.completeExceptionally(th), for producers            // that write often a consumer has a chance to try another snapshot that might succeed            throw th;        }    }
@Override    public void onCycleSkip(CycleSkipReason reason) {        cycleMetricsBuilder.setConsecutiveFailures(consecutiveFailures);        lastCycleSuccessTimeNanoOptional.ifPresent(cycleMetricsBuilder::setLastCycleSuccessTimeNano);        // isCycleSuccess and cycleDurationMillis are not set for skipped cycles        cycleMetricsBuilder.setConsecutiveFailures(consecutiveFailures);        cycleMetricsReporting(cycleMetricsBuilder.build());    }
@Override    public void onAnnouncementComplete(com.netflix.hollow.api.producer.Status status, HollowProducer.ReadState readState, long version, Duration elapsed) {        boolean isAnnouncementSuccess = false;        long dataSizeBytes = 0l;        if (status.getType() == com.netflix.hollow.api.producer.Status.StatusType.SUCCESS) {            isAnnouncementSuccess = true;            lastAnnouncementSuccessTimeNanoOptional = OptionalLong.of(System.nanoTime());        }        HollowReadStateEngine stateEngine = readState.getStateEngine();        dataSizeBytes = stateEngine.calcApproxDataSize();        announcementMetricsBuilder                .setDataSizeBytes(dataSizeBytes)                .setIsAnnouncementSuccess(isAnnouncementSuccess)                .setAnnouncementDurationMillis(elapsed.toMillis());        lastAnnouncementSuccessTimeNanoOptional.ifPresent(announcementMetricsBuilder::setLastAnnouncementSuccessTimeNano);        announcementMetricsReporting(announcementMetricsBuilder.build());    }
@Override    public void onCycleComplete(com.netflix.hollow.api.producer.Status status, HollowProducer.ReadState readState, long version, Duration elapsed) {        boolean isCycleSuccess;        long cycleEndTimeNano = System.nanoTime();        if (status.getType() == com.netflix.hollow.api.producer.Status.StatusType.SUCCESS) {            isCycleSuccess = true;            consecutiveFailures = 0l;            lastCycleSuccessTimeNanoOptional = OptionalLong.of(cycleEndTimeNano);        } else {            isCycleSuccess = false;            consecutiveFailures ++;        }        cycleMetricsBuilder                .setConsecutiveFailures(consecutiveFailures)                .setCycleDurationMillis(elapsed.toMillis())                .setIsCycleSuccess(isCycleSuccess);        lastCycleSuccessTimeNanoOptional.ifPresent(cycleMetricsBuilder::setLastCycleSuccessTimeNano);        cycleMetricsReporting(cycleMetricsBuilder.build());    }
private Map<String, String> readHeaderTags(DataInputStream dis) throws IOException {        int numHeaderTags = dis.readShort();        Map<String, String> headerTags = new HashMap<String, String>();        for (int i = 0; i < numHeaderTags; i++) {            headerTags.put(dis.readUTF(), dis.readUTF());        }        return headerTags;    }
public int add(Object o) {        HollowTypeMapper typeMapper = getTypeMapper(o.getClass(), null, null);        return typeMapper.write(o);    }
@Deprecated    public void writeFlat(Object o, FlatRecordWriter flatRecordWriter) {    	HollowTypeMapper typeMapper = getTypeMapper(o.getClass(), null, null);    	typeMapper.writeFlat(o, flatRecordWriter);    }
public RecordPrimaryKey extractPrimaryKey(Object o) {        HollowObjectTypeMapper typeMapper = (HollowObjectTypeMapper) getTypeMapper(o.getClass(), null, null);        return new RecordPrimaryKey(typeMapper.getTypeName(), typeMapper.extractPrimaryKey(o));    }
public void initializeTypeState(Class<?> clazz) {        Objects.requireNonNull(clazz);        getTypeMapper(clazz, null, null);    }
public void clearAll() {        ThreadSafeBitSetSegments segments = this.segments.get();        for(int i=0;i<segments.numSegments();i++) {            AtomicLongArray segment = segments.getSegment(i);            for(int j=0;j<segment.length();j++) {                segment.set(j, 0L);            }        }    }
public ThreadSafeBitSet andNot(ThreadSafeBitSet other) {        if(other.log2SegmentSize != log2SegmentSize)            throw new IllegalArgumentException("Segment sizes must be the same");        ThreadSafeBitSetSegments thisSegments = this.segments.get();        ThreadSafeBitSetSegments otherSegments = other.segments.get();        ThreadSafeBitSetSegments newSegments = new ThreadSafeBitSetSegments(thisSegments.numSegments(), numLongsPerSegment);        for(int i=0;i<thisSegments.numSegments();i++) {            AtomicLongArray thisArray = thisSegments.getSegment(i);            AtomicLongArray otherArray = (i < otherSegments.numSegments()) ? otherSegments.getSegment(i) : null;            AtomicLongArray newArray = newSegments.getSegment(i);            for(int j=0;j<thisArray.length();j++) {                long thisLong = thisArray.get(j);                long otherLong = (otherArray == null) ? 0 : otherArray.get(j);                newArray.set(j, thisLong & ~otherLong);            }        }        ThreadSafeBitSet andNot = new ThreadSafeBitSet(log2SegmentSize);        andNot.segments.set(newSegments);        return andNot;    }
public static ThreadSafeBitSet orAll(ThreadSafeBitSet... bitSets) {        if(bitSets.length == 0)            return new ThreadSafeBitSet();        int log2SegmentSize = bitSets[0].log2SegmentSize;        int numLongsPerSegment = bitSets[0].numLongsPerSegment;        ThreadSafeBitSetSegments segments[] = new ThreadSafeBitSetSegments[bitSets.length];        int maxNumSegments = 0;        for(int i=0;i<bitSets.length;i++) {            if(bitSets[i].log2SegmentSize != log2SegmentSize)                throw new IllegalArgumentException("Segment sizes must be the same");            segments[i] = bitSets[i].segments.get();            if(segments[i].numSegments() > maxNumSegments)                maxNumSegments = segments[i].numSegments();        }        ThreadSafeBitSetSegments newSegments = new ThreadSafeBitSetSegments(maxNumSegments, numLongsPerSegment);        AtomicLongArray segment[] = new AtomicLongArray[segments.length];        for(int i=0;i<maxNumSegments;i++) {            for(int j=0;j<segments.length;j++) {                segment[j] = i < segments[j].numSegments() ? segments[j].getSegment(i) : null;            }            AtomicLongArray newSegment = newSegments.getSegment(i);            for(int j=0;j<numLongsPerSegment;j++) {                long value = 0;                for(int k=0;k<segments.length;k++) {                    if(segment[k] != null)                        value |= segment[k].get(j);                }                newSegment.set(j, value);            }        }        ThreadSafeBitSet or = new ThreadSafeBitSet(log2SegmentSize);        or.segments.set(newSegments);        return or;    }
private AtomicLongArray getSegment(int segmentIndex) {        ThreadSafeBitSetSegments visibleSegments = segments.get();        while(visibleSegments.numSegments() <= segmentIndex) {            /// Thread safety:  newVisibleSegments contains all of the segments from the currently visible segments, plus extra.            /// all of the segments in the currently visible segments are canonical and will not change.            ThreadSafeBitSetSegments newVisibleSegments = new ThreadSafeBitSetSegments(visibleSegments, segmentIndex + 1, numLongsPerSegment);            /// because we are using a compareAndSet, if this thread "wins the race" and successfully sets this variable, then the segments            /// which are newly defined in newVisibleSegments become canonical.            if(segments.compareAndSet(visibleSegments, newVisibleSegments)) {                visibleSegments = newVisibleSegments;            } else {                /// If we "lose the race" and are growing the ThreadSafeBitSet segments larger,                /// then we will gather the new canonical sets from the update which we missed on the next iteration of this loop.                /// Newly defined segments in newVisibleSegments will be discarded, they do not get to become canonical.                visibleSegments = segments.get();            }        }        return visibleSegments.getSegment(segmentIndex);    }
public void updateCycleMetrics(HollowProducerListener.ProducerStatus producerStatus) {        Status.StatusType st = producerStatus.getStatus() == HollowProducerListener.Status.SUCCESS                ? Status.StatusType.SUCCESS                : Status.StatusType.FAIL;        updateCycleMetrics(new Status(st, producerStatus.getCause()), producerStatus.getReadState(), producerStatus.getVersion());    }
public void updateCycleMetrics(Status status, HollowProducer.ReadState readState, long version) {        cyclesCompleted++;        if(status.getType() == Status.StatusType.FAIL) {            cycleFailed++;            return;        }        cyclesSucceeded++;        if(readState != null) {            HollowReadStateEngine hollowReadStateEngine = readState.getStateEngine();            super.update(hollowReadStateEngine, version);        } else {            super.update(version);        }    }
public static void main(String[] args) throws IOException, ClassNotFoundException {        if (args.length == 0) {            System.out.println("Usage:\n"                    + "java " + HollowPOJOGenerator.class.getName() + " --arg1=value1 --arg2=value2\n"                    + "see " + GeneratorArguments.class.getName() + " for available arguments.");            return;        }        HollowWriteStateEngine engine = new HollowWriteStateEngine();        String packageName = null;        String pojoClassNameSuffix = null;        String pathToGeneratedFiles = null;        HollowObjectMapper mapper = new HollowObjectMapper(engine);        ArgumentParser<GeneratorArguments> argumentParser = new ArgumentParser(GeneratorArguments.class, args);        for (ArgumentParser<GeneratorArguments>.ParsedArgument arg : argumentParser.getParsedArguments()) {            switch (arg.getKey()) {                case addToDataModel:                    mapper.initializeTypeState(HollowPOJOGenerator.class.getClassLoader().loadClass(arg.getValue()));                    break;                case addSchemaFileToDataModel:                    HollowWriteStateCreator.readSchemaFileIntoWriteState(arg.getValue(), engine);                    break;                case pathToGeneratedFiles:                    pathToGeneratedFiles = arg.getValue();                    break;                case packageName:                    packageName = arg.getValue();                    break;                case pojoClassNameSuffix:                    pojoClassNameSuffix = arg.getValue();                    break;                default:                    throw new IllegalArgumentException("Unhandled argument " + arg.getKey());            }        }        new HollowPOJOGenerator(packageName, pojoClassNameSuffix, engine).generateFiles(pathToGeneratedFiles);    }
public static void readOrdinals(DataInputStream dis, HollowTypeStateListener[] listeners) throws IOException {        int numLongs = dis.readInt();        int currentOrdinal = 0;        for(int i=0;i<numLongs;i++) {            long l = dis.readLong();            notifyPopulatedOrdinals(l, currentOrdinal, listeners);            currentOrdinal += 64;        }    }
public boolean get(int i) {        SparseBitSet current;        boolean result;        do {            current = sparseBitSetVolatile;            result = current.get(i);        } while (current != sparseBitSetVolatile);        return result;    }
public long size() {        SparseBitSet current;        long size;        do {            current = sparseBitSetVolatile;            size = current.estimateBitsUsed();        } while (current != sparseBitSetVolatile);        return size;    }
public void readSnapshot(InputStream is, HollowFilterConfig filter) throws IOException {        HollowBlobHeader header = readHeader(is, false);        notifyBeginUpdate();        long startTime = System.currentTimeMillis();        DataInputStream dis = new DataInputStream(is);        int numStates = VarInt.readVInt(dis);        Collection<String> typeNames = new TreeSet<String>();        for(int i=0;i<numStates;i++) {            String typeName = readTypeStateSnapshot(dis, header, filter);            typeNames.add(typeName);        }        stateEngine.wireTypeStatesToSchemas();        long endTime = System.currentTimeMillis();        log.info("SNAPSHOT COMPLETED IN " + (endTime - startTime) + "ms");        log.info("TYPES: " + typeNames);        notifyEndUpdate();        stateEngine.afterInitialization();    }
public void applyDelta(InputStream is) throws IOException {        HollowBlobHeader header = readHeader(is, true);        notifyBeginUpdate();        long startTime = System.currentTimeMillis();        DataInputStream dis = new DataInputStream(is);        int numStates = VarInt.readVInt(dis);        Collection<String> typeNames = new TreeSet<String>();        for(int i=0;i<numStates;i++) {            String typeName = readTypeStateDelta(dis, header);            typeNames.add(typeName);            stateEngine.getMemoryRecycler().swap();        }        long endTime = System.currentTimeMillis();        log.info("DELTA COMPLETED IN " + (endTime - startTime) + "ms");        log.info("TYPES: " + typeNames);        notifyEndUpdate();    }
private static String getFieldValue(HollowDiffViewRow row, boolean useFrom) {        Field field = useFrom ? row.getFieldPair().getFrom() : row.getFieldPair().getTo();        if (row.getFieldPair().isLeafNode()) {          return field.getValue() == null ? "null"              : field.getValue().toString().replace("|", "&#x2502");        } else {            String suffix = field.getValue() == null ? " [null]" : "";            return "(" + field.getTypeName() + ")" + suffix;        }    }
public void set(long index, byte value) {        int segmentIndex = (int)(index >> log2OfSegmentSize);        ensureCapacity(segmentIndex);        segments[segmentIndex][(int)(index & bitmask)] = value;    }
public void copy(ByteData src, long srcPos, long destPos, long length) {        for(long i=0;i<length;i++) {            set(destPos++, src.get(srcPos++));        }    }
public int copy(long srcPos, byte[] data, int destPos, int length) {        int segmentSize = 1 << log2OfSegmentSize;        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));        int dataPosition = destPos;        while(length > 0) {            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);            System.arraycopy(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);            dataPosition += bytesToCopyFromSegment;            srcPos += bytesToCopyFromSegment;            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);            length -= bytesToCopyFromSegment;        }        return dataPosition - destPos;    }
public boolean rangeEquals(long rangeStart, SegmentedByteArray compareTo, long cmpStart, int length) {    	for(int i=0;i<length;i++)    		if(get(rangeStart + i) != compareTo.get(cmpStart + i))    			return false;    	return true;    }
public void orderedCopy(SegmentedByteArray src, long srcPos, long destPos, long length) {        int segmentLength = 1 << log2OfSegmentSize;        int currentSegment = (int)(destPos >>> log2OfSegmentSize);        int segmentStartPos = (int)(destPos & bitmask);        int remainingBytesInSegment = segmentLength - segmentStartPos;        while(length > 0) {            int bytesToCopyFromSegment = (int)Math.min(remainingBytesInSegment, length);            ensureCapacity(currentSegment);            int copiedBytes = src.orderedCopy(srcPos, segments[currentSegment], segmentStartPos, bytesToCopyFromSegment);            srcPos += copiedBytes;            length -= copiedBytes;            segmentStartPos = 0;            remainingBytesInSegment = segmentLength;            currentSegment++;        }    }
public int orderedCopy(long srcPos, byte[] data, int destPos, int length) {        int segmentSize = 1 << log2OfSegmentSize;        int remainingBytesInSegment = (int)(segmentSize - (srcPos & bitmask));        int dataPosition = destPos;        while(length > 0) {            byte[] segment = segments[(int)(srcPos >>> log2OfSegmentSize)];            int bytesToCopyFromSegment = Math.min(remainingBytesInSegment, length);            orderedCopy(segment, (int)(srcPos & bitmask), data, dataPosition, bytesToCopyFromSegment);            dataPosition += bytesToCopyFromSegment;            srcPos += bytesToCopyFromSegment;            remainingBytesInSegment = segmentSize - (int)(srcPos & bitmask);            length -= bytesToCopyFromSegment;        }        return dataPosition - destPos;    }
public void readFrom(InputStream is, long length) throws IOException {        int segmentSize = 1 << log2OfSegmentSize;        int segment = 0;        byte scratch[] = new byte[segmentSize];        while(length > 0) {            ensureCapacity(segment);            long bytesToCopy = Math.min(segmentSize, length);            long bytesCopied = 0;            while(bytesCopied < bytesToCopy) {                bytesCopied += is.read(scratch, (int)bytesCopied, (int)(bytesToCopy - bytesCopied));            }            orderedCopy(scratch, 0, segments[segment++], 0, (int)bytesCopied);            length -= bytesCopied;        }    }
public void writeTo(OutputStream os, long startPosition, long len) throws IOException {        int segmentSize = 1 << log2OfSegmentSize;        int remainingBytesInSegment = segmentSize - (int)(startPosition & bitmask);        long remainingBytesInCopy = len;        while(remainingBytesInCopy > 0) {            long bytesToCopyFromSegment = Math.min(remainingBytesInSegment, remainingBytesInCopy);            os.write(segments[(int)(startPosition >>> log2OfSegmentSize)], (int)(startPosition & bitmask), (int)bytesToCopyFromSegment);            startPosition += bytesToCopyFromSegment;            remainingBytesInSegment = segmentSize - (int)(startPosition & bitmask);            remainingBytesInCopy -= bytesToCopyFromSegment;        }    }
private void ensureCapacity(int segmentIndex) {        while(segmentIndex >= segments.length) {            segments = Arrays.copyOf(segments, segments.length * 3 / 2);        }        if(segments[segmentIndex] == null) {            segments[segmentIndex] = memoryRecycler.getByteArray();        }    }
public int getPosition(String fieldName) {        Integer index = nameFieldIndexLookup.get(fieldName);        if (index == null) {            return -1;        }        return index;    }
private long calculateDedupedSizesAndTotalNumberOfSelectBuckets(MultiLinkedElementArray elementArray, GrowingSegmentedLongArray matchIndexHashAndSizeArray) {        long totalBuckets = 0;        long maxSize = 0;        int[] selectArray = new int[8];        for(int i=0;i<elementArray.numLists();i++) {            int listSize = elementArray.listSize(i);            int setSize = 0;            int predictedBuckets = HashCodes.hashTableSize(listSize);            int hashMask = predictedBuckets - 1;            if(predictedBuckets > selectArray.length)                selectArray = new int[predictedBuckets];            for(int j=0;j<predictedBuckets;j++)                selectArray[j] = -1;            HollowOrdinalIterator iter = elementArray.iterator(i);            int selectOrdinal = iter.next();            while(selectOrdinal != HollowOrdinalIterator.NO_MORE_ORDINALS) {                int hash = HashCodes.hashInt(selectOrdinal);                int bucket = hash & hashMask;                while(true) {                    if(selectArray[bucket] == selectOrdinal)                        break;                    if(selectArray[bucket] == -1) {                        selectArray[bucket] = selectOrdinal;                        setSize++;                        break;                    }                    bucket = (bucket+1) & hashMask;                }                selectOrdinal = iter.next();            }            long matchIndexHashAndSize = matchIndexHashAndSizeArray.get(i);            matchIndexHashAndSize |= (long)setSize << 32;            matchIndexHashAndSizeArray.set(i, matchIndexHashAndSize);            totalBuckets += HashCodes.hashTableSize(setSize);            if(setSize > maxSize)                maxSize = setSize;        }        return totalBuckets | (long)bitsRequiredToRepresentValue(maxSize) << 56;    }
public static void main(String[] args) throws IOException, ClassNotFoundException {        if (args.length == 0) {            System.out.println("Usage:\n"                    + "java " + HollowAPIGenerator.class.getName() + " --arg1=value1 --arg2=value2\n"                    + "see " + GeneratorArguments.class.getName() + " for available arguments.");            return;        }        HollowWriteStateEngine engine = new HollowWriteStateEngine();        HollowAPIGenerator.Builder builder = new HollowAPIGenerator.Builder();        HollowObjectMapper mapper = new HollowObjectMapper(engine);        ArgumentParser<GeneratorArguments> argumentParser = new ArgumentParser(GeneratorArguments.class, args);        for (ArgumentParser<GeneratorArguments>.ParsedArgument arg : argumentParser.getParsedArguments()) {            switch (arg.getKey()) {                case addToDataModel:                    mapper.initializeTypeState(HollowAPIGenerator.class.getClassLoader().loadClass(arg.getValue()));                    break;                case addSchemaFileToDataModel:                    HollowWriteStateCreator.readSchemaFileIntoWriteState(arg.getValue(), engine);                    break;                case apiClassName:                    builder.withAPIClassname(arg.getValue());                    break;                case classPostfix:                    builder.withClassPostfix(arg.getValue());                    break;                case getterPrefix:                    builder.withGetterPrefix(arg.getValue());                    break;                case packageName:                    builder.withPackageName(arg.getValue());                    break;                case pathToGeneratedFiles:                    builder.withDestination(arg.getValue());                    break;                case parameterizeAllClassNames:                    builder.withParameterizeAllClassNames(Boolean.valueOf(arg.getValue()));                    break;                default:                    throw new IllegalArgumentException("Unhandled argument " + arg.getKey());            }        }        builder.withDataModel(engine).build().generateSourceFiles();    }
protected static boolean hasCollectionsInDataSet(HollowDataset dataset) {        for(HollowSchema schema : dataset.getSchemas()) {            if ((schema instanceof HollowListSchema) ||                    (schema instanceof HollowSetSchema) ||                    (schema instanceof HollowMapSchema)) {                return true;            }        }        return false;    }
public void generateFiles(File directory) throws IOException {        if (packageName != null && !packageName.trim().isEmpty()) {            String packageDir = packageName.replace(".", File.separator);            if (!directory.getAbsolutePath().endsWith(packageDir)) {                directory = new File(directory, packageDir);            }        }        directory.mkdirs();        HollowAPIClassJavaGenerator apiClassGenerator = new HollowAPIClassJavaGenerator(packageName, apiClassname,                dataset, parameterizeClassNames, config);        HollowAPIFactoryJavaGenerator apiFactoryGenerator = new HollowAPIFactoryJavaGenerator(packageName,                apiClassname, dataset, config);        HollowHashIndexGenerator hashIndexGenerator = new HollowHashIndexGenerator(packageName, apiClassname, dataset, config);        generateFile(directory, apiClassGenerator);        generateFile(directory, apiFactoryGenerator);        generateFile(directory, hashIndexGenerator);        generateFilesForHollowSchemas(directory);    }
protected void generateFilesForHollowSchemas(File directory) throws IOException {        for(HollowSchema schema : dataset.getSchemas()) {            String type = schema.getName();            if (config.isUseHollowPrimitiveTypes() && HollowCodeGenerationUtils.isPrimitiveType(type)) continue; // skip if using hollow primitive type            generateFile(directory, getStaticAPIGenerator(schema));            generateFile(directory, getHollowObjectGenerator(schema));            generateFile(directory, getHollowFactoryGenerator(schema));            if(schema.getSchemaType() == SchemaType.OBJECT) {                HollowObjectSchema objSchema = (HollowObjectSchema)schema;                generateFile(directory, new HollowObjectDelegateInterfaceGenerator(packageName, objSchema,                        ergonomicShortcuts, dataset, config));                generateFile(directory, new HollowObjectDelegateCachedImplGenerator(packageName, objSchema,                        ergonomicShortcuts, dataset, config));                generateFile(directory, new HollowObjectDelegateLookupImplGenerator(packageName, objSchema,                        ergonomicShortcuts, dataset, config));                generateFile(directory, new HollowDataAccessorGenerator(packageName, apiClassname, objSchema,                        dataset, config));                if (!config.isReservePrimaryKeyIndexForTypeWithPrimaryKey()) {                    generateFile(directory, new LegacyHollowPrimaryKeyIndexGenerator(packageName, apiClassname,                            objSchema, dataset, config));                } else if ((objSchema).getPrimaryKey() != null) {                    generateFile(directory, new HollowPrimaryKeyIndexGenerator(dataset, packageName, apiClassname,                            objSchema, config));                    generateFile(directory, new HollowUniqueKeyIndexGenerator(packageName, apiClassname, objSchema,                            dataset, config));                }            }        }    }
public boolean keyMatches(int ordinal, Object... keys) {        if(keys.length != fieldPathIndexes.length)            return false;                for(int i=0;i<keys.length;i++) {            if(!keyMatches(keys[i], ordinal, i))                return false;        }                return true;    }
public Object[] getRecordKey(int ordinal) {        Object[] results = new Object[fieldPathIndexes.length];        for (int i = 0; i < fieldPathIndexes.length; i++) {            results[i] = readValue(ordinal, i);        }        return results;    }
public void initializeDataModel(Class<?>... classes) {        Objects.requireNonNull(classes);        if (classes.length == 0) {            throw new IllegalArgumentException("classes is empty");        }        long start = currentTimeMillis();        for (Class<?> c : classes) {            objectMapper.initializeTypeState(c);        }        listeners.listeners().fireProducerInit(currentTimeMillis() - start);        isInitialized = true;    }
public void initializeDataModel(HollowSchema... schemas) {        Objects.requireNonNull(schemas);        if (schemas.length == 0) {            throw new IllegalArgumentException("classes is empty");        }        long start = currentTimeMillis();        HollowWriteStateCreator.populateStateEngineWithTypeWriteStates(getWriteEngine(), Arrays.asList(schemas));        listeners.listeners().fireProducerInit(currentTimeMillis() - start);        isInitialized = true;    }
public HollowProducer.ReadState restore(long versionDesired, HollowConsumer.BlobRetriever blobRetriever) {        return restore(versionDesired, blobRetriever,                (restoreFrom, restoreTo) -> restoreTo.restoreFrom(restoreFrom));    }
public boolean enablePrimaryProducer(boolean doEnable) {        if (doEnable) {            singleProducerEnforcer.enable();        } else {            singleProducerEnforcer.disable();        }        return (singleProducerEnforcer.isPrimary() == doEnable);    }
void publish(ListenerSupport.Listeners listeners, long toVersion, Artifacts artifacts) throws IOException {        Status.StageBuilder psb = listeners.firePublishStart(toVersion);        try {            artifacts.snapshot = stageBlob(listeners,                    blobStager.openSnapshot(toVersion));            if (readStates.hasCurrent()) {                artifacts.delta = stageBlob(listeners,                        blobStager.openDelta(readStates.current().getVersion(), toVersion));                artifacts.reverseDelta = stageBlob(listeners,                        blobStager.openReverseDelta(toVersion, readStates.current().getVersion()));                publishBlob(listeners, artifacts.delta);                publishBlob(listeners, artifacts.reverseDelta);                if (--numStatesUntilNextSnapshot < 0) {                    if (snapshotPublishExecutor == null) {                        publishBlob(listeners, artifacts.snapshot);                        artifacts.markSnapshotPublishComplete();                    } else {                        // Submit the publish blob task to the executor                        publishSnapshotBlobAsync(listeners, artifacts);                    }                    numStatesUntilNextSnapshot = numStatesBetweenSnapshots;                } else {                    artifacts.markSnapshotPublishComplete();                }            } else {                publishBlob(listeners, artifacts.snapshot);                artifacts.markSnapshotPublishComplete();                numStatesUntilNextSnapshot = numStatesBetweenSnapshots;            }            psb.success();        } catch (Throwable throwable) {            psb.fail(throwable);            throw throwable;        } finally {            listeners.firePublishComplete(psb);        }    }
private ReadStateHelper checkIntegrity(            ListenerSupport.Listeners listeners, ReadStateHelper readStates, Artifacts artifacts) throws Exception {        Status.StageWithStateBuilder status = listeners.fireIntegrityCheckStart(readStates.pending());        try {            ReadStateHelper result = readStates;            HollowReadStateEngine pending = readStates.pending().getStateEngine();            readSnapshot(artifacts.snapshot, pending);            if (readStates.hasCurrent()) {                HollowReadStateEngine current = readStates.current().getStateEngine();                log.info("CHECKSUMS");                HollowChecksum currentChecksum = HollowChecksum.forStateEngineWithCommonSchemas(current, pending);                log.info("  CUR        " + currentChecksum);                HollowChecksum pendingChecksum = HollowChecksum.forStateEngineWithCommonSchemas(pending, current);                log.info("         PND " + pendingChecksum);                if (artifacts.hasDelta()) {                    if (!artifacts.hasReverseDelta()) {                        throw new IllegalStateException("Both a delta and reverse delta are required");                    }                    // FIXME: timt: future cycles will fail unless both deltas validate                    applyDelta(artifacts.delta, current);                    HollowChecksum forwardChecksum = HollowChecksum.forStateEngineWithCommonSchemas(current, pending);                    //out.format("  CUR => PND %s\n", forwardChecksum);                    if (!forwardChecksum.equals(pendingChecksum)) {                        throw new HollowProducer.ChecksumValidationException(HollowProducer.Blob.Type.DELTA);                    }                    applyDelta(artifacts.reverseDelta, pending);                    HollowChecksum reverseChecksum = HollowChecksum.forStateEngineWithCommonSchemas(pending, current);                    //out.format("  CUR <= PND %s\n", reverseChecksum);                    if (!reverseChecksum.equals(currentChecksum)) {                        throw new HollowProducer.ChecksumValidationException(HollowProducer.Blob.Type.REVERSE_DELTA);                    }                    result = readStates.swap();                }            }            status.success();            return result;        } catch (Throwable th) {            status.fail(th);            throw th;        } finally {            listeners.fireIntegrityCheckComplete(status);        }    }
public void addTypeListener(String typeName, HollowTypeStateListener listener) {        List<HollowTypeStateListener> list = listeners.get(typeName);        if(list == null) {            list = new ArrayList<HollowTypeStateListener>();            listeners.put(typeName, list);        }        list.add(listener);        HollowTypeReadState typeState = typeStates.get(typeName);        if(typeState != null)            typeState.addListener(listener);    }
public static FieldPath<ObjectFieldSegment> createFieldPathForPrimaryKey(            HollowDataset dataset, String type, String path) {        boolean autoExpand = !path.endsWith("!");        path = autoExpand ? path : path.substring(0, path.length() - 1);        FieldPath<FieldSegment> fp = createFieldPath(dataset, type, path, autoExpand, false, false);        // Erasure trick to avoid copying when it is known the list only contains        // instances of ObjectFieldSegment        assert fp.segments.stream().allMatch(o -> o instanceof ObjectFieldSegment);        @SuppressWarnings( {"unchecked", "raw"})        FieldPath<ObjectFieldSegment> result = (FieldPath<ObjectFieldSegment>) (FieldPath) fp;        return result;    }
public static FieldPath<FieldSegment> createFieldPathForHashIndex(HollowDataset dataset, String type, String path) {        return createFieldPath(dataset, type, path, false, false, true);    }
public static FieldPath<FieldSegment> createFieldPathForPrefixIndex(            HollowDataset dataset, String type, String path, boolean autoExpand) {        // If autoExpand is false then requireFullPath must be true        boolean requireFullPath = !autoExpand;        return createFieldPath(dataset, type, path, autoExpand, requireFullPath, true);    }
static FieldPath<FieldSegment> createFieldPath(            HollowDataset dataset, String type, String path,            boolean autoExpand, boolean requireFullPath, boolean traverseSequences) {        Objects.requireNonNull(dataset);        Objects.requireNonNull(type);        Objects.requireNonNull(path);        String[] segments = path.isEmpty() ? new String[0] : path.split("\\.");        List<FieldSegment> fieldSegments = new ArrayList<>();        String segmentType = type;        for (int i = 0; i < segments.length; i++) {            HollowSchema schema = dataset.getSchema(segmentType);            // @@@ Can this only occur for anything other than the root `type`?            if (schema == null) {                throw new FieldPathException(FieldPathException.ErrorKind.NOT_BINDABLE, dataset, type, segments,                        fieldSegments, null, i);            }            String segment = segments[i];            HollowSchema.SchemaType schemaType = schema.getSchemaType();            if (schemaType == HollowSchema.SchemaType.OBJECT) {                HollowObjectSchema objectSchema = (HollowObjectSchema) schema;                int index = objectSchema.getPosition(segment);                if (index == -1) {                    throw new FieldPathException(FieldPathException.ErrorKind.NOT_FOUND, dataset, type, segments,                            fieldSegments, schema, i);                }                segmentType = objectSchema.getReferencedType(index);                fieldSegments.add(new ObjectFieldSegment(objectSchema, segment, segmentType, index));            } else if (traverseSequences && (schemaType == HollowSchema.SchemaType.SET                    || schemaType == HollowSchema.SchemaType.LIST)) {                HollowCollectionSchema collectionSchema = (HollowCollectionSchema) schema;                if (!segment.equals("element")) {                    throw new FieldPathException(FieldPathException.ErrorKind.NOT_FOUND, dataset, type, segments,                            fieldSegments, schema, i);                }                segmentType = collectionSchema.getElementType();                fieldSegments.add(new FieldSegment(collectionSchema, segment, segmentType));            } else if (traverseSequences && schemaType == HollowSchema.SchemaType.MAP) {                HollowMapSchema mapSchema = (HollowMapSchema) schema;                if (segment.equals("key")) {                    segmentType = mapSchema.getKeyType();                } else if (segment.equals("value")) {                    segmentType = mapSchema.getValueType();                } else {                    throw new FieldPathException(FieldPathException.ErrorKind.NOT_FOUND, dataset, type, segments,                            fieldSegments, schema, i);                }                fieldSegments.add(new FieldSegment(mapSchema, segment, segmentType));            } else if (!traverseSequences) {                throw new FieldPathException(FieldPathException.ErrorKind.NOT_TRAVERSABLE, dataset, type, segments,                        fieldSegments, schema, i);            }            if (i < segments.length - 1 && segmentType == null) {                throw new FieldPathException(FieldPathException.ErrorKind.NOT_TRAVERSABLE, dataset, type, segments,                        fieldSegments, schema, i);            }        }        if (autoExpand) {            while (segmentType != null) {                HollowSchema schema = dataset.getSchema(segmentType);                if (schema.getSchemaType() == HollowSchema.SchemaType.OBJECT) {                    HollowObjectSchema objectSchema = (HollowObjectSchema) schema;                    if (objectSchema.numFields() == 1) {                        segmentType = objectSchema.getReferencedType(0);                        fieldSegments.add(                                new ObjectFieldSegment(objectSchema, objectSchema.getFieldName(0), segmentType,                                        0));                    } else if (objectSchema.getPrimaryKey() != null && objectSchema.getPrimaryKey().numFields() == 1) {                        PrimaryKey key = objectSchema.getPrimaryKey();                        FieldPath<ObjectFieldSegment> expandedFieldSegments;                        try {                            expandedFieldSegments =                                    createFieldPathForPrimaryKey(dataset, key.getType(), key.getFieldPaths()[0]);                        } catch (FieldPathException cause) {                            FieldPathException e = new FieldPathException(FieldPathException.ErrorKind.NOT_EXPANDABLE,                                    dataset, type, segments,                                    fieldSegments, objectSchema);                            e.initCause(cause);                            throw e;                        }                        fieldSegments.addAll(expandedFieldSegments.segments);                        break;                    } else {                        throw new FieldPathException(FieldPathException.ErrorKind.NOT_EXPANDABLE, dataset, type,                                segments,                                fieldSegments, objectSchema);                    }                } else {                    throw new FieldPathException(FieldPathException.ErrorKind.NOT_EXPANDABLE, dataset, type, segments,                            fieldSegments, schema);                }            }        } else if (requireFullPath && segmentType != null) {            throw new FieldPathException(FieldPathException.ErrorKind.NOT_FULL, dataset, type, segments,                    fieldSegments);        }        return new FieldPath<>(type, fieldSegments, !autoExpand);    }
public void put(Object obj, int ordinal) {        int hashCode = System.identityHashCode(obj);        int segment = segment(hashCode);        segments[segment].put(obj, hashCode, ordinal);    }
private HollowUpdatePlan snapshotPlan(long desiredVersion) {        HollowUpdatePlan plan = new HollowUpdatePlan();        long nearestPreviousSnapshotVersion = includeNearestSnapshot(plan, desiredVersion);        // The includeNearestSnapshot function returns a snapshot version that is less than or equal to the desired version        if(nearestPreviousSnapshotVersion > desiredVersion)            return HollowUpdatePlan.DO_NOTHING;        // If the nearest snapshot version is {@code HollowConstants.VERSION_LATEST} then no past snapshots were found, so        // skip the delta planning and the update plan does nothing        if(nearestPreviousSnapshotVersion == HollowConstants.VERSION_LATEST)            return HollowUpdatePlan.DO_NOTHING;        plan.appendPlan(deltaPlan(nearestPreviousSnapshotVersion, desiredVersion, Integer.MAX_VALUE));        return plan;    }
private long includeNextDelta(HollowUpdatePlan plan, long currentVersion, long desiredVersion) {        HollowConsumer.Blob transition = transitionCreator.retrieveDeltaBlob(currentVersion);        if(transition != null) {            if(transition.getToVersion() <= desiredVersion) {                plan.add(transition);            }            return transition.getToVersion();        }        return HollowConstants.VERSION_LATEST;    }
private void initialize() {        String lastRefType = this.fieldPath.getLastRefTypeInPath();        // get all cardinality to estimate size of array bits needed.        totalWords = readStateEngine.getTypeState(lastRefType).getPopulatedOrdinals().cardinality();        averageWordLen = 0;        double avg = 0;        HollowObjectTypeReadState objectTypeReadState = (HollowObjectTypeReadState) readStateEngine.getTypeState(lastRefType);        BitSet keyBitSet = objectTypeReadState.getPopulatedOrdinals();        int ordinal = keyBitSet.nextSetBit(0);        while (ordinal != -1) {            avg += ((double) objectTypeReadState.readString(ordinal, 0).length()) / ((double) objectTypeReadState.maxOrdinal());            ordinal = keyBitSet.nextSetBit(ordinal + 1);        }        averageWordLen = (int) Math.ceil(avg);        HollowObjectTypeReadState valueState = (HollowObjectTypeReadState) readStateEngine.getTypeDataAccess(type);        maxOrdinalOfType = valueState.maxOrdinal();        // initialize the prefix index.        build();    }
protected String[] getKeys(int ordinal) {        Object[] values = fieldPath.findValues(ordinal);        String[] stringValues = new String[values.length];        for (int i = 0; i < values.length; i++) {            stringValues[i] = ((String) values[i]).toLowerCase();        }        return stringValues;    }
@SuppressWarnings("WeakerAccess")    public HollowOrdinalIterator findKeysWithPrefix(String prefix) {        TST current;        HollowOrdinalIterator it;        do {            current = prefixIndexVolatile;            it = current.findKeysWithPrefix(prefix);        } while (current != this.prefixIndexVolatile);        return it;    }
public boolean contains(String key) {        if (key == null) throw new IllegalArgumentException("key cannot be null");        TST current;        boolean result;        do {            current = prefixIndexVolatile;            result = current.contains(key);        } while (current != this.prefixIndexVolatile);        return result;    }
float getChangePercent(int latestCardinality, int previousCardinality) {        int diff = Math.abs(latestCardinality - previousCardinality);        return (100.0f * diff) / previousCardinality;    }
public void addTypeRecursive(String type, Collection<HollowSchema> schemas) {        addTypeRecursive(type, mapSchemas(schemas));    }
public void addTypeRecursive(String type, Map<String, HollowSchema> schemas) {        addType(type);        HollowSchema schema = schemas.get(type);        switch(schema.getSchemaType()) {        case OBJECT:            HollowObjectSchema objSchema = (HollowObjectSchema)schema;            for(int i=0;i<objSchema.numFields();i++) {                if(objSchema.getFieldType(i) == FieldType.REFERENCE)                    addTypeRecursive(objSchema.getReferencedType(i), schemas);            }            break;        case MAP:            addTypeRecursive(((HollowMapSchema)schema).getKeyType(), schemas);            addTypeRecursive(((HollowMapSchema)schema).getValueType(), schemas);            break;        case LIST:        case SET:            addTypeRecursive(((HollowCollectionSchema)schema).getElementType(), schemas);            break;        }    }
public void addField(String type, String objectField) {        ObjectFilterConfig typeConfig = specifiedFieldConfigs.get(type);        if(typeConfig == null) {            typeConfig = new ObjectFilterConfig();            specifiedFieldConfigs.put(type, typeConfig);        }        typeConfig.addField(objectField);    }
public void addFieldRecursive(String type, String objectField, Collection<HollowSchema> schemas) {        addFieldRecursive(type, objectField, mapSchemas(schemas));    }
public void addFieldRecursive(String type, String objectField, Map<String, HollowSchema> schemas) {        addField(type, objectField);        HollowObjectSchema schema = (HollowObjectSchema)schemas.get(type);        if(schema.getFieldType(objectField) == FieldType.REFERENCE) {            addTypeRecursive(schema.getReferencedType(objectField), schemas);        }    }
public static HollowFilterConfig fromString(String conf) {        String lines[] = conf.split("\n");        HollowFilterConfig config = new HollowFilterConfig("EXCLUDE".equals(lines[0]));        for(int i=1;i<lines.length;i++) {            int delimiterIdx = lines[i].indexOf('.');            if(delimiterIdx == -1) {                config.addType(lines[i]);            } else {                String type = lines[i].substring(0, delimiterIdx);                String field = lines[i].substring(delimiterIdx+1);                config.addField(type, field);            }        }        return config;    }
public void addListener(HollowTypeStateListener listener) {        HollowTypeStateListener[] newListeners = Arrays.copyOf(stateListeners, stateListeners.length + 1);        newListeners[newListeners.length - 1] = listener;        stateListeners = newListeners;    }
public void removeListener(HollowTypeStateListener listener) {        if (stateListeners.length == 0)            return;        stateListeners = Stream.of(stateListeners)                .filter(l -> l != listener)                .toArray(HollowTypeStateListener[]::new);    }
public static List<HollowSchema> dependencyOrderedSchemaList(Collection<HollowSchema> schemas) {        DependencyIndex idx = new DependencyIndex();        Map<String, HollowSchema> schemaMap = new HashMap<String, HollowSchema>();        for(HollowSchema schema : schemas) {            schemaMap.put(schema.getName(), schema);            idx.indexSchema(schema, schemas);        }        List<HollowSchema> orderedSchemas = new ArrayList<HollowSchema>();        while(idx.hasMoreTypes())            orderedSchemas.add(schemaMap.get(idx.getNextType()));        return orderedSchemas;    }
public void initWithNextMajorVersionDefaults_V3() {        usePackageGrouping = true;        useBooleanFieldErgonomics = true;        reservePrimaryKeyIndexForTypeWithPrimaryKey = true;        useHollowPrimitiveTypes = true;        restrictApiToFieldType = true;        useVerboseToString = true;    }
public void set(long index, long value) {        int segmentIndex = (int)(index >> log2OfSegmentSize);                if(segmentIndex >= segments.length) {            int nextPowerOfTwo = 1 << (32 - Integer.numberOfLeadingZeros(segmentIndex));            segments = Arrays.copyOf(segments, nextPowerOfTwo);        }                if(segments[segmentIndex] == null) {            segments[segmentIndex] = memoryRecycler.getLongArray();        }                int longInSegment = (int)(index & bitmask);        segments[segmentIndex][longInSegment] = value;    }
public long get(long index) {        int segmentIndex = (int)(index >> log2OfSegmentSize);        if(segmentIndex >= segments.length || segments[segmentIndex] == null)            return 0;                int longInSegment = (int)(index & bitmask);        return segments[segmentIndex][longInSegment];    }
public Map<String, BitSet> findMatchingRecords(String fieldName, String fieldValue) {        Map<String, BitSet> matches = new HashMap<String, BitSet>();                for(HollowTypeReadState typeState : readEngine.getTypeStates()) {            augmentMatchingRecords(typeState, fieldName, fieldValue, matches);        }        return matches;    }
public Map<String, BitSet> findMatchingRecords(String typeName, String fieldName, String fieldValue) {        Map<String, BitSet> matches = new HashMap<String, BitSet>();        HollowTypeReadState typeState = readEngine.getTypeState(typeName);        if(typeState != null)            augmentMatchingRecords(typeState, fieldName, fieldValue, matches);                return matches;    }
public void setElementMatchPaths(String... paths) {        resetResults();        this.elementPaths = paths;        this.elementKeyPaths = null;        this.elementNonKeyPaths = null;    }
public void setElementKeyPaths(String... paths) {        resetResults();        elementKeyPaths = new BitSet(elementPaths.length);        for(int i=0;i<paths.length;i++) {            int elementPathIdx = getElementPathIdx(paths[i]);            if(elementPathIdx == -1)                throw new IllegalArgumentException("Key path must have been specified as an element match path.  Offending path: " + paths[i]);            elementKeyPaths.set(elementPathIdx);        }        elementNonKeyPaths = new BitSet(elementPaths.length);        elementNonKeyPaths.set(0, elementPaths.length);        elementNonKeyPaths.andNot(elementKeyPaths);    }
public void calculate() {        resetResults();        SimultaneousExecutor executor = new SimultaneousExecutor(getClass(), "calculate");        final int numThreads = executor.getCorePoolSize();        for(int i=0;i<numThreads;i++) {            final int threadNumber = i;            executor.execute(new Runnable() {                public void run() {                    HollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser(from, type, elementPaths);                    HollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser(to, type, elementPaths);                    int hashedResults[] = new int[16];                    for(int i=threadNumber;i<matcher.getMatchedOrdinals().size();i += numThreads) {                        long ordinalPair = matcher.getMatchedOrdinals().get(i);                        int fromOrdinal = (int)(ordinalPair >>> 32);                        int toOrdinal = (int)ordinalPair;                        fromTraverser.traverse(fromOrdinal);                        toTraverser.traverse(toOrdinal);                        if(fromTraverser.getNumMatches() * 2 > hashedResults.length)                            hashedResults = new int[hashTableSize(fromTraverser.getNumMatches())];                        populateHashTable(fromTraverser, hashedResults);                        countMatches(fromTraverser, toTraverser, hashedResults);                    }                    for(int i=threadNumber;i<matcher.getExtraInFrom().size();i+=numThreads) {                        fromTraverser.traverse(matcher.getExtraInFrom().get(i));                        totalUnmatchedFromElements.addAndGet(fromTraverser.getNumMatches());                    }                    for(int i=threadNumber;i<matcher.getExtraInTo().size();i+=numThreads) {                        toTraverser.traverse(matcher.getExtraInTo().get(i));                        totalUnmatchedToElements.addAndGet(toTraverser.getNumMatches());                    }                }            });        }        try {            executor.awaitSuccessfulCompletion();        } catch (Exception ex) {            throw new RuntimeException(ex);        }    }
public void addDiff(int fromOrdinal, int toOrdinal, int score) {        if(isSameDiffAsLastAdd(fromOrdinal, toOrdinal)) {            int scoreIdx = diffPairScores.size() - 1;            diffPairScores.set(scoreIdx, diffPairScores.get(scoreIdx) + score);        } else {            diffFromOrdinals.add(fromOrdinal);            diffToOrdinals.add(toOrdinal);            diffPairScores.add(score);        }        totalDiffScore += score;    }
public void addResults(HollowFieldDiff otherFieldDiff) {        for(int i=0;i<otherFieldDiff.getNumDiffs();i++) {            addDiff(otherFieldDiff.getFromOrdinal(i), otherFieldDiff.getToOrdinal(i), otherFieldDiff.getPairScore(i));        }    }
@Override    public int compareTo(HollowFieldDiff o) {        if(o.getTotalDiffScore() > totalDiffScore)            return 1;        else if(o.getTotalDiffScore() < totalDiffScore)            return -1;        return 0;    }
public void triggerRefresh() {        refreshLock.writeLock().lock();        try {            updater.updateTo(announcementWatcher == null ? Long.MAX_VALUE : announcementWatcher.getLatestVersion());        } catch (Error | RuntimeException e) {            throw e;        } catch (Throwable t) {            throw new RuntimeException(t);        } finally {            refreshLock.writeLock().unlock();        }    }
public void triggerAsyncRefreshWithDelay(int delayMillis) {        final long targetBeginTime = System.currentTimeMillis() + delayMillis;        refreshExecutor.execute(() -> {            try {                long delay = targetBeginTime - System.currentTimeMillis();                if (delay > 0)                    Thread.sleep(delay);            } catch (InterruptedException e) {                // Interrupting, such as shutting down the executor pool,                // cancels the trigger                LOG.log(Level.INFO, "Async refresh interrupted before trigger, refresh cancelled", e);                return;            }            try {                triggerRefresh();            } catch (Error | RuntimeException e) {                // Ensure exceptions are propagated to the executor                LOG.log(Level.SEVERE, "Async refresh failed", e);                throw e;            }        });    }
public void triggerRefreshTo(long version) {        if (announcementWatcher != null)            throw new UnsupportedOperationException("Cannot trigger refresh to specified version when a HollowConsumer.AnnouncementWatcher is present");        try {            updater.updateTo(version);        } catch (Error | RuntimeException e) {            throw e;        } catch (Throwable t) {            throw new RuntimeException(t);        }    }
public <T extends HollowAPI> T getAPI(Class<T> apiClass) {        return apiClass.cast(updater.getAPI());    }
public static void roundTripSnapshot(HollowWriteStateEngine writeEngine, HollowReadStateEngine readEngine) throws IOException {        roundTripSnapshot(writeEngine, readEngine, null);    }
public static void roundTripSnapshot(HollowWriteStateEngine writeEngine, HollowReadStateEngine readEngine, HollowFilterConfig filter) throws IOException {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        HollowBlobWriter writer = new HollowBlobWriter(writeEngine);        writer.writeSnapshot(baos);        writeEngine.prepareForNextCycle();        HollowBlobReader reader = new HollowBlobReader(readEngine);        InputStream is = new ByteArrayInputStream(baos.toByteArray());        if(filter == null)            reader.readSnapshot(is);        else            reader.readSnapshot(is, filter);    }
public static void roundTripDelta(HollowWriteStateEngine writeEngine, HollowReadStateEngine readEngine) throws IOException {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        HollowBlobWriter writer = new HollowBlobWriter(writeEngine);        writer.writeDelta(baos);        HollowBlobReader reader = new HollowBlobReader(readEngine);        reader.applyDelta(new ByteArrayInputStream(baos.toByteArray()));        writeEngine.prepareForNextCycle();    }
public HollowHistoricalStateDataAccess createBasedOnNewDelta(long version, HollowReadStateEngine stateEngine) {        IntMapOrdinalRemapper typeRemovedOrdinalMapping = new IntMapOrdinalRemapper();        List<HollowTypeReadState> historicalTypeStates = new ArrayList<HollowTypeReadState>(stateEngine.getTypeStates().size());        for(HollowTypeReadState typeState : stateEngine.getTypeStates()) {            createDeltaHistoricalTypeState(typeRemovedOrdinalMapping, historicalTypeStates, typeState);        }        HollowHistoricalStateDataAccess dataAccess = new HollowHistoricalStateDataAccess(totalHistory, version, stateEngine, historicalTypeStates, typeRemovedOrdinalMapping, Collections.<String, HollowHistoricalSchemaChange>emptyMap());        dataAccess.setNextState(stateEngine);        return dataAccess;    }
public HollowHistoricalStateDataAccess createConsistentOrdinalHistoricalStateFromDoubleSnapshot(long version, HollowReadStateEngine previous) {        return new HollowHistoricalStateDataAccess(totalHistory, version, previous, IdentityOrdinalRemapper.INSTANCE, Collections.<String, HollowHistoricalSchemaChange>emptyMap());    }
public HollowHistoricalStateDataAccess createHistoricalStateFromDoubleSnapshot(long version, HollowReadStateEngine previous, HollowReadStateEngine current, DiffEqualityMappingOrdinalRemapper ordinalRemapper) {        HollowWriteStateEngine writeEngine = HollowWriteStateCreator.createWithSchemas(schemasWithoutKeys(previous.getSchemas()));        IntMapOrdinalRemapper typeRemovedOrdinalLookupMaps = new IntMapOrdinalRemapper();        for(HollowSchema previousSchema : HollowSchemaSorter.dependencyOrderedSchemaList(previous)) {            HollowTypeReadState previousTypeState = previous.getTypeState(previousSchema.getName());            String typeName = previousTypeState.getSchema().getName();            IntMap ordinalLookupMap;            if(current.getTypeState(typeName) == null) {                ordinalLookupMap = copyAllRecords(previousTypeState, ordinalRemapper, writeEngine);            } else {                HollowTypeReadState currentTypeState = current.getTypeState(typeName);                BitSet currentlyPopulatedOrdinals = currentTypeState.getListener(PopulatedOrdinalListener.class).getPopulatedOrdinals();                ordinalLookupMap = copyUnmatchedRecords(previousTypeState, ordinalRemapper, currentlyPopulatedOrdinals, writeEngine);            }            typeRemovedOrdinalLookupMaps.addOrdinalRemapping(typeName, ordinalLookupMap);        }        Map<String, HollowHistoricalSchemaChange> schemaChanges = calculateSchemaChanges(previous, current, ordinalRemapper.getDiffEqualityMapping());        return new HollowHistoricalStateDataAccess(totalHistory, version, roundTripStateEngine(writeEngine), typeRemovedOrdinalLookupMaps, schemaChanges);    }
public void restoreFromLastState() {        producer.initializeDataModel(dataModel);        long latestAnnouncedVersion = announcementWatcher.getLatestVersion();        if (latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher.NO_ANNOUNCEMENT_AVAILABLE || latestAnnouncedVersion < 0) {            return;        }        restore(latestAnnouncedVersion, blobRetriever);    }
public long runCycle() {        long recordsRemoved = countRecordsToRemove();        long recordsAddedOrModified = this.mutations.values().size() - recordsRemoved;        try {            long version = producer.runCycle(populator);            if(version == lastSucessfulCycle) {                return version;            }            listeners.fireIncrementalCycleComplete(version, recordsAddedOrModified, recordsRemoved, new HashMap<String, Object>(cycleMetadata));            //Only clean changes when the version is new.            clearChanges();            lastSucessfulCycle = version;            return version;        } catch (Exception e) {            listeners.fireIncrementalCycleFail(e, recordsAddedOrModified, recordsRemoved, new HashMap<String, Object>(cycleMetadata));            return FAILED_VERSION;        } finally {            clearCycleMetadata();        }    }
private void executeInParallel(Collection<Object> objList, String description, final Callback callback) {        SimultaneousExecutor executor = new SimultaneousExecutor(threadsPerCpu, getClass(), description);        for(final Object obj : objList) {            executor.execute(() -> callback.call(obj));        }        try {            executor.awaitSuccessfulCompletion();        } catch(Exception e) {            throw new RuntimeException(e);        }    }
public void excludeKey(HollowPrimaryKeyIndex idx, Object... key) {        int excludeOrdinal = idx.getMatchingOrdinal(key);                if(excludeOrdinal >= 0) {            BitSet excludedOrdinals = this.excludedOrdinals.get(idx.getTypeState());                        if(excludedOrdinals == null) {                excludedOrdinals = new BitSet(idx.getTypeState().maxOrdinal()+1);                this.excludedOrdinals.put(idx.getTypeState(), excludedOrdinals);            }                        excludedOrdinals.set(excludeOrdinal);        }    }
public void excludeReferencedObjects() {        Set<HollowReadStateEngine> stateEngines = new HashSet<HollowReadStateEngine>();        for(Map.Entry<HollowTypeReadState, BitSet> entry : excludedOrdinals.entrySet())            stateEngines.add(entry.getKey().getStateEngine());                for(HollowReadStateEngine stateEngine : stateEngines) {            Map<String, BitSet> typeBitSetsForStateEngine = new HashMap<String, BitSet>();                        for(Map.Entry<HollowTypeReadState, BitSet> entry : excludedOrdinals.entrySet()) {                if(entry.getKey().getStateEngine() == stateEngine) {                    String type = entry.getKey().getSchema().getName();                    typeBitSetsForStateEngine.put(type, BitSet.valueOf(entry.getValue().toLongArray()));                }            }                        TransitiveSetTraverser.addTransitiveMatches(stateEngine, typeBitSetsForStateEngine);            for(Map.Entry<String, BitSet> entry : typeBitSetsForStateEngine.entrySet())                excludedOrdinals.put(stateEngine.getTypeState(entry.getKey()), entry.getValue());        }    }
public void writeHeader(HollowBlobHeader header, DataOutputStream dos) throws IOException {        /// save 4 bytes to indicate FastBlob version header.  This will be changed to indicate backwards incompatibility.        dos.writeInt(HollowBlobHeader.HOLLOW_BLOB_VERSION_HEADER);        /// Write randomized tag data -- every state gets a random 64-bit tag.        /// When attempting to apply a delta, the originating state's random 64-bit tag is compared against the current 64-bit tag.        /// This prevents deltas from being applied to incorrect states.        dos.writeLong(header.getOriginRandomizedTag());        dos.writeLong(header.getDestinationRandomizedTag());        /// write the schemas contained in this blob to the stream in the pre v2.2.0 backwards compatibility envelope        ByteArrayOutputStream schemasStream = new ByteArrayOutputStream();        VarInt.writeVInt(schemasStream, header.getSchemas().size());        for(HollowSchema schema : header.getSchemas())            schema.writeTo(schemasStream);        byte[] schemasData = schemasStream.toByteArray();                VarInt.writeVInt(dos, schemasData.length + 1); // plus one byte for new backwards compatibility envelope.        dos.write(schemasData);                ///backwards compatibility -- new data can be added here by first indicating number of bytes used, will be skipped by existing readers.        VarInt.writeVInt(dos, 0);        /// write the header tags -- intended to include input source data versions        dos.writeShort(header.getHeaderTags().size());        for (Map.Entry<String, String> headerTag : header.getHeaderTags().entrySet()) {            dos.writeUTF(headerTag.getKey());            dos.writeUTF(headerTag.getValue());        }    }
public int bitsRequiredForField(String fieldName) {        int fieldIndex = schema.getPosition(fieldName);        return fieldIndex == -1 ? 0 : currentDataVolatile.bitsPerField[fieldIndex];    }
void calculateTypeMetrics(HollowReadStateEngine hollowReadStateEngine) {        Collection<HollowTypeReadState> typeStates = hollowReadStateEngine.getTypeStates();        if (typeStates == null)            return;        totalHeapFootprint = 0L;        totalPopulatedOrdinals = 0;        for (HollowTypeReadState typeState : typeStates) {            long heapCost = typeState.getApproximateHeapFootprintInBytes();            totalHeapFootprint += heapCost;            int populatedOrdinals = typeState.getPopulatedOrdinals().cardinality();            totalPopulatedOrdinals += populatedOrdinals;            String type = typeState.getSchema().getName();            typeHeapFootprint.put(type, heapCost);            typePopulatedOrdinals.put(type, populatedOrdinals);        }    }
public void setPrimaryKeys(PrimaryKey... newKeys) {        Objects.requireNonNull(newKeys);        if (newKeys.length == 0) {            return;        }        if (inputs.length == 1) {            return;        }        /// deduplicate new keys with existing keys        //process existing ones first        Map<String, PrimaryKey> keysByType = new HashMap<>();        for (PrimaryKey primaryKey : primaryKeys) {            keysByType.put(primaryKey.getType(), primaryKey);        }        // allow override        for (PrimaryKey primaryKey : newKeys) {            keysByType.put(primaryKey.getType(), primaryKey);        }        this.primaryKeys = sortPrimaryKeys(new ArrayList<>(keysByType.values()));    }
public void combine() {        SimultaneousExecutor executor = new SimultaneousExecutor(getClass(), "combine");        final int numThreads = executor.getCorePoolSize();        createOrdinalRemappers();        createHashOrderIndependentOrdinalMaps();        final Set<String> processedTypes = new HashSet<>();        final Set<PrimaryKey> processedPrimaryKeys = new HashSet<>();        final Set<PrimaryKey> selectedPrimaryKeys = new HashSet<>();        while(processedTypes.size() < output.getOrderedTypeStates().size()){            /// find the next primary keys            for(PrimaryKey key : primaryKeys) {                if (!processedPrimaryKeys.contains(key) && !ignoredTypes.contains(key.getType())) {                    if(!isAnySelectedPrimaryKeyADependencyOf(key.getType(), selectedPrimaryKeys)) {                        selectedPrimaryKeys.add(key);                    }                }            }            final Set<String> typesToProcessThisIteration = new HashSet<>();            final Map<String, HollowPrimaryKeyIndex[]> primaryKeyIndexes = new HashMap<>();            final HollowCombinerExcludePrimaryKeysCopyDirector primaryKeyCopyDirector = new HollowCombinerExcludePrimaryKeysCopyDirector(copyDirector);            for(HollowSchema schema : output.getSchemas()) {                if(!processedTypes.contains(schema.getName()) && !ignoredTypes.contains(schema.getName())) {                    if(selectedPrimaryKeys.isEmpty() || isAnySelectedPrimaryKeyDependentOn(schema.getName(), selectedPrimaryKeys)) {                        for(PrimaryKey pk : selectedPrimaryKeys) {                            if(pk.getType().equals(schema.getName())) {                                HollowPrimaryKeyIndex[] indexes = new HollowPrimaryKeyIndex[inputs.length];                                for(int i=0;i<indexes.length;i++) {                                    if(inputs[i].getTypeState(pk.getType()) != null)                                        indexes[i] = new HollowPrimaryKeyIndex(inputs[i], pk);                                }                                for(int i=0;i<indexes.length;i++) {                                    HollowTypeReadState typeState = inputs[i].getTypeState(pk.getType());                                    if(typeState != null) {                                        BitSet populatedOrdinals = typeState.getListener(PopulatedOrdinalListener.class).getPopulatedOrdinals();                                            int ordinal = populatedOrdinals.nextSetBit(0);                                        while(ordinal != -1) {                                            if(primaryKeyCopyDirector.shouldCopy(typeState, ordinal)) {                                                Object[] recordKey = indexes[i].getRecordKey(ordinal);                                                    for(int j=i+1;j<indexes.length;j++) {                                                    primaryKeyCopyDirector.excludeKey(indexes[j], recordKey);                                                }                                            }                                                ordinal = populatedOrdinals.nextSetBit(ordinal + 1);                                        }                                    }                                }                                primaryKeyIndexes.put(pk.getType(), indexes);                            }                        }                        typesToProcessThisIteration.add(schema.getName());                    }                }            }            if(typesToProcessThisIteration.isEmpty())                break;            for(int i=0;i<numThreads;i++) {                final int threadNumber = i;                executor.execute(() -> {                    for(int i1 =0; i1 <inputs.length; i1++) {                        HollowCombinerCopyDirector copyDirector = selectedPrimaryKeys.isEmpty()                                ? HollowCombiner.this.copyDirector                                : primaryKeyCopyDirector;                        HollowReadStateEngine inputEngine = inputs[i1];                        OrdinalRemapper ordinalRemapper = selectedPrimaryKeys.isEmpty()                                ? ordinalRemappers[i1]                                : new HollowCombinerPrimaryKeyOrdinalRemapper(ordinalRemappers, primaryKeyIndexes, i1);                        Map<String, HollowCombinerCopier> copierMap = new HashMap<>();                        List<HollowCombinerCopier> copierList = new ArrayList<>();                        for(String typeName : typesToProcessThisIteration) {                            HollowTypeReadState readState = inputEngine.getTypeState(typeName);                            HollowTypeWriteState writeState = output.getTypeState(typeName);                            if (readState != null && writeState != null) {                                HollowCombinerCopier copier = new HollowCombinerCopier(readState, writeState, ordinalRemapper);                                copierList.add(copier);                                copierMap.put(typeName, copier);                            }                        }                        for(String typeName : processedTypes) {                            HollowTypeReadState readState = inputEngine.getTypeState(typeName);                            HollowTypeWriteState writeState = output.getTypeState(typeName);                            if (readState != null && writeState != null) {                                HollowCombinerCopier copier = new HollowCombinerCopier(readState, writeState, ordinalRemappers[i1]);                                copierMap.put(typeName, copier);                            }                        }                        copiersPerType.set(copierMap);                        int currentOrdinal = threadNumber;                        while(!copierList.isEmpty()) {                            copyOrdinalForAllStates(currentOrdinal, copierList, ordinalRemapper, copyDirector);                            currentOrdinal += numThreads;                        }                    }                });            }            try {                executor.awaitSuccessfulCompletionOfCurrentTasks();            } catch(Throwable th) {                throw new RuntimeException(th);            }            processedTypes.addAll(typesToProcessThisIteration);            processedPrimaryKeys.addAll(selectedPrimaryKeys);            selectedPrimaryKeys.clear();        }        executor.shutdown();    }
public void writeDataTo(ByteDataBuffer buf) {        for (int i = 0; i < fieldData.length; i++) {            writeField(buf, i);        }    }
private ByteDataBuffer getFieldBuffer(int fieldPosition) {        isNonNull[fieldPosition] = true;        fieldData[fieldPosition].reset();        return fieldData[fieldPosition];    }
private static void writeFixedLengthInt(ByteDataBuffer fieldBuffer, int intBits) {        fieldBuffer.write((byte) (intBits >>> 24));        fieldBuffer.write((byte) (intBits >>> 16));        fieldBuffer.write((byte) (intBits >>> 8));        fieldBuffer.write((byte) (intBits));    }
private static void writeFixedLengthLong(ByteDataBuffer fieldBuffer, long intBits) {        fieldBuffer.write((byte) (intBits >>> 56));        fieldBuffer.write((byte) (intBits >>> 48));        fieldBuffer.write((byte) (intBits >>> 40));        fieldBuffer.write((byte) (intBits >>> 32));        fieldBuffer.write((byte) (intBits >>> 24));        fieldBuffer.write((byte) (intBits >>> 16));        fieldBuffer.write((byte) (intBits >>> 8));        fieldBuffer.write((byte) (intBits));    }
public IntStream stream() {        Spliterator.OfInt si = new Spliterator.OfInt() {            final long endBucket = selectTableStartPointer + selectTableBuckets;            long currentBucket = selectTableStartPointer;            @Override            public OfInt trySplit() {                // @@@ Supporting splitting and therefore enable parallelism                return null;            }            @Override            public boolean tryAdvance(IntConsumer action) {                while (currentBucket < endBucket) {                    int selectOrdinal = (int) hashIndexState.getSelectHashArray().getElementValue(                            (currentBucket++) * hashIndexState.getBitsPerSelectHashEntry(),                            hashIndexState.getBitsPerSelectHashEntry()) - 1;                    if (selectOrdinal != -1) {                        action.accept(selectOrdinal);                        return true;                    }                }                return false;            }            @Override            public long estimateSize() {                // @@@                return 0;            }            @Override            public int characteristics() {                // @@@ ordinals are distinct?                return 0;            }        };        return StreamSupport.intStream(si, false);    }
public void returnOrdinalToPool(int ordinal) {        if(size == freeOrdinals.length) {            freeOrdinals = Arrays.copyOf(freeOrdinals, freeOrdinals.length * 3 / 2);        }        freeOrdinals[size] = ordinal;        size++;    }
public void sort() {        Arrays.sort(freeOrdinals, 0, size);        /// reverse the ordering        int midpoint = size / 2;        for(int i=0;i<midpoint;i++) {            int temp = freeOrdinals[i];            freeOrdinals[i] = freeOrdinals[size-i-1];            freeOrdinals[size-i-1] = temp;        }    }
public static int hash(Object key[], FieldType fieldType[]) {        int hash = 0;        for (int i = 0; i < key.length; i++) {            hash *= 31;            hash ^= hash(key[i], fieldType[i]);        }        return hash;    }
public static int hash(Object key, FieldType fieldType) {        switch(fieldType) {        case INT:            return HashCodes.hashInt(((Integer)key).intValue());        case LONG:            long longVal = ((Long)key).longValue();            return HashCodes.hashInt((int)(longVal ^ (longVal >>> 32)));        case REFERENCE:            return HashCodes.hashInt(((Integer)key).intValue());        case BYTES:            return HashCodes.hashInt(HashCodes.hashCode((byte[])key));        case STRING:            return HashCodes.hashInt(key.hashCode());        case BOOLEAN:            return HashCodes.hashInt(((Boolean)key).booleanValue() ? 1231 : 1237);        case DOUBLE:            long longBits = Double.doubleToRawLongBits(((Double)key).doubleValue());            return HashCodes.hashInt((int)(longBits ^ (longBits >>> 32)));        case FLOAT:            return HashCodes.hashInt(Float.floatToRawIntBits(((Float)key).floatValue()));        default:            throw new IllegalArgumentException("Unknown field type: " + fieldType);        }    }
public void addElement(long nodeIndex, long element) {        if (element > elementMask) {            throw new IllegalArgumentException("Element " + element + " does not fit in "                    + bitsPerElement + " bits");        }        if (nodeIndex >= numNodes) {            throw new IllegalArgumentException("Provided nodeIndex  " + nodeIndex                    + " greater then numNodes " + numNodes);        }        if (element == NO_ELEMENT) {            // we use 0 to indicate an "empty" element, so we have to store ordinal zero here            nodesWithOrdinalZero.setElementValue(nodeIndex, 1, 1);            return;        }        long bucketStart = nodeIndex * maxElementsPerNode * bitsPerElement;        long currentIndex;        int offset = 0;        do {            currentIndex = bucketStart + offset * bitsPerElement;            offset++;        } while (storage.getElementValue(currentIndex, bitsPerElement, elementMask) != NO_ELEMENT                && offset < maxElementsPerNode);        if (storage.getElementValue(currentIndex, bitsPerElement, elementMask) != NO_ELEMENT) {            // we're full at this index - resize, then figure out the new current index            resizeStorage();            currentIndex = nodeIndex * maxElementsPerNode * bitsPerElement + offset * bitsPerElement;        }        /* we're adding to the first empty spot from the beginning of the bucket - this is         * preferable to adding at the end because we want our getElements method to be fast, and         * it's okay for addElement to be comparatively slow */        storage.setElementValue(currentIndex, bitsPerElement, element);    }
public List<Long> getElements(long nodeIndex) {        long bucketStart = nodeIndex * maxElementsPerNode * bitsPerElement;        List<Long> ret = new ArrayList<>();        if (nodesWithOrdinalZero.getElementValue(nodeIndex, 1, 1) != NO_ELEMENT) {            // 0 indicates an "empty" element, so we fetch ordinal zeros from nodesWithOrdinalZero            ret.add(NO_ELEMENT);        }        for (int offset = 0; offset < maxElementsPerNode; offset++) {            long element = storage.getElementValue(bucketStart + offset * bitsPerElement,                    bitsPerElement, elementMask);            if (element == NO_ELEMENT) {                break; // we have exhausted the elements at this index            }            ret.add(element);        }        return ret;    }
private void resizeStorage() {        int currentElementsPerNode = maxElementsPerNode;        int newElementsPerNode = (int) (currentElementsPerNode * RESIZE_MULTIPLE);        if (newElementsPerNode <= currentElementsPerNode) {            throw new IllegalStateException("cannot resize fixed length array from "                    + currentElementsPerNode + " to " + newElementsPerNode);        }        FixedLengthElementArray newStorage = new FixedLengthElementArray(memoryRecycler,                numNodes * bitsPerElement * newElementsPerNode);        LongStream.range(0, numNodes).forEach(nodeIndex -> {            long currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement;            long newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement;            for (int offset = 0; offset < currentElementsPerNode; offset++) {                long element = storage.getElementValue(currentBucketStart + offset * bitsPerElement,                        bitsPerElement, elementMask);                if (element == NO_ELEMENT) {                    break; // we have exhausted the elements at this index                }                newStorage.setElementValue(                        newBucketStart + offset * bitsPerElement, bitsPerElement, element);            }        });        storage.destroy(memoryRecycler);        storage = newStorage;        maxElementsPerNode = newElementsPerNode;    }
protected void processFile(Reader r, int maxSample) throws Exception {        JsonArrayChunker chunker = new JsonArrayChunker(r, executor);        chunker.initialize();        int counter = 0;        Reader jsonObj = chunker.nextChunk();        while(jsonObj != null && counter < maxSample) {            final Reader currentObject = jsonObj;            executor.execute(new Runnable() {                public void run() {                    try {                        JsonFactory factory = new JsonFactory();                        JsonParser parser = factory.createParser(currentObject);                        processRecord(parser);                    } catch(Exception e){                        throw new RuntimeException(e);                    }                }            });            while(executor.getQueue().size() > maxWorkQueue) {                Thread.sleep(5);            }            counter++;            jsonObj.close();            jsonObj = chunker.nextChunk();        }        executor.awaitSuccessfulCompletion();    }
public int getOrAssignOrdinal(ByteDataBuffer serializedRepresentation, int preferredOrdinal) {        int hash = HashCodes.hashCode(serializedRepresentation);        int ordinal = get(serializedRepresentation, hash);        return ordinal != -1 ? ordinal : assignOrdinal(serializedRepresentation, hash, preferredOrdinal);    }
private synchronized int assignOrdinal(ByteDataBuffer serializedRepresentation, int hash, int preferredOrdinal) {        if (preferredOrdinal < -1 || preferredOrdinal > ORDINAL_MASK) {            throw new IllegalArgumentException(String.format(                    "The given preferred ordinal %s is out of bounds and not within the closed interval [-1, %s]",                    preferredOrdinal, ORDINAL_MASK));        }        if (size > sizeBeforeGrow) {            growKeyArray();        }        /// check to make sure that after acquiring the lock, the element still does not exist.        /// this operation is akin to double-checked locking which is 'fixed' with the JSR 133 memory model in JVM >= 1.5.        /// Note that this also requires pointersAndOrdinals be volatile so resizes are also visible        AtomicLongArray pao = pointersAndOrdinals;        int modBitmask = pao.length() - 1;        int bucket = hash & modBitmask;        long key = pao.get(bucket);        while (key != EMPTY_BUCKET_VALUE) {            if (compare(serializedRepresentation, key)) {                return (int) (key >>> BITS_PER_POINTER);            }            bucket = (bucket + 1) & modBitmask;            key = pao.get(bucket);        }        /// the ordinal for this object still does not exist in the list, even after the lock has been acquired.        /// it is up to this thread to add it at the current bucket position.        int ordinal = findFreeOrdinal(preferredOrdinal);        if (ordinal > ORDINAL_MASK) {            throw new IllegalStateException(String.format(                    "Ordinal cannot be assigned. The to be assigned ordinal, %s, is greater than the maximum supported ordinal value of %s",                    ordinal, ORDINAL_MASK));        }        long pointer = byteData.length();        VarInt.writeVInt(byteData, (int) serializedRepresentation.length());        /// Copying might cause a resize to the segmented array held by byteData        /// A reading thread may observe a null value for a segment during the creation        /// of a new segments array (see SegmentedByteArray.ensureCapacity).        serializedRepresentation.copyTo(byteData);        if (byteData.length() > MAX_BYTE_DATA_LENGTH) {            throw new IllegalStateException(String.format(                    "The number of bytes for the serialized representations, %s, is too large and is greater than the maximum of %s bytes",                    byteData.length(), MAX_BYTE_DATA_LENGTH));        }        key = ((long) ordinal << BITS_PER_POINTER) | pointer;        size++;        /// this set on the AtomicLongArray has volatile semantics (i.e. behaves like a monitor release).        /// Any other thread reading this element in the AtomicLongArray will have visibility to all memory writes this thread has made up to this point.        /// This means the entire byte sequence is guaranteed to be visible to any thread which reads the pointer to that data.        pao.set(bucket, key);        return ordinal;    }
private int findFreeOrdinal(int preferredOrdinal) {        if (preferredOrdinal != -1 && unusedPreviousOrdinals.get(preferredOrdinal)) {            unusedPreviousOrdinals.clear(preferredOrdinal);            return preferredOrdinal;        }        return freeOrdinalTracker.getFreeOrdinal();    }
public void prepareForWrite() {        int maxOrdinal = 0;        AtomicLongArray pao = pointersAndOrdinals;        for (int i = 0; i < pao.length(); i++) {            long key = pao.get(i);            if (key != EMPTY_BUCKET_VALUE) {                int ordinal = (int) (key >>> BITS_PER_POINTER);                if (ordinal > maxOrdinal) {                    maxOrdinal = ordinal;                }            }        }        long[] pbo = new long[maxOrdinal + 1];        Arrays.fill(pbo, -1);        for (int i = 0; i < pao.length(); i++) {            long key = pao.get(i);            if (key != EMPTY_BUCKET_VALUE) {                int ordinal = (int) (key >>> BITS_PER_POINTER);                pbo[ordinal] = key & POINTER_MASK;            }        }        pointersByOrdinal = pbo;    }
public void compact(ThreadSafeBitSet usedOrdinals) {        long[] populatedReverseKeys = new long[size];        int counter = 0;        AtomicLongArray pao = pointersAndOrdinals;        for (int i = 0; i < pao.length(); i++) {            long key = pao.get(i);            if (key != EMPTY_BUCKET_VALUE) {                populatedReverseKeys[counter++] = key << BITS_PER_ORDINAL | key >>> BITS_PER_POINTER;            }        }        Arrays.sort(populatedReverseKeys);        SegmentedByteArray arr = byteData.getUnderlyingArray();        long currentCopyPointer = 0;        for (int i = 0; i < populatedReverseKeys.length; i++) {            int ordinal = (int) (populatedReverseKeys[i] & ORDINAL_MASK);            if (usedOrdinals.get(ordinal)) {                long pointer = populatedReverseKeys[i] >>> BITS_PER_ORDINAL;                int length = VarInt.readVInt(arr, pointer);                length += VarInt.sizeOfVInt(length);                if (currentCopyPointer != pointer) {                    arr.copy(arr, pointer, currentCopyPointer, length);                }                populatedReverseKeys[i] = populatedReverseKeys[i] << BITS_PER_POINTER | currentCopyPointer;                currentCopyPointer += length;            } else {                freeOrdinalTracker.returnOrdinalToPool(ordinal);                populatedReverseKeys[i] = EMPTY_BUCKET_VALUE;            }        }        byteData.setPosition(currentCopyPointer);        freeOrdinalTracker.sort();        // Reset the array then fill with compacted values        // Volatile store not required, could use plain store        // See VarHandles for JDK >= 9        for (int i = 0; i < pao.length(); i++) {            pao.lazySet(i, EMPTY_BUCKET_VALUE);        }        populateNewHashArray(pao, populatedReverseKeys);        size = usedOrdinals.cardinality();        pointersByOrdinal = null;        unusedPreviousOrdinals = null;    }
private boolean compare(ByteDataBuffer serializedRepresentation, long key) {        long position = key & POINTER_MASK;        int sizeOfData = VarInt.readVInt(byteData.getUnderlyingArray(), position);        if (sizeOfData != serializedRepresentation.length()) {            return false;        }        position += VarInt.sizeOfVInt(sizeOfData);        for (int i = 0; i < sizeOfData; i++) {            if (serializedRepresentation.get(i) != byteData.get(position++)) {                return false;            }        }        return true;    }
public void resize(int size) {        size = bucketSize(size);        if (pointersAndOrdinals.length() < size) {            growKeyArray(size);        }    }
private void growKeyArray() {        int newSize = pointersAndOrdinals.length() << 1;        if (newSize < 0) {            throw new IllegalStateException("New size computed to grow the underlying array for the map is negative. " +                    "This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. "                    +                    "Current array size :" + pointersAndOrdinals.length() + " and size to grow :" + newSize);        }        growKeyArray(newSize);    }
private int rehashPreviouslyAddedData(long key) {        long position = key & POINTER_MASK;        int sizeOfData = VarInt.readVInt(byteData.getUnderlyingArray(), position);        position += VarInt.sizeOfVInt(sizeOfData);        return HashCodes.hashCode(byteData.getUnderlyingArray(), position, sizeOfData);    }
private AtomicLongArray emptyKeyArray(int size) {        AtomicLongArray arr = new AtomicLongArray(size);        // Volatile store not required, could use plain store        // See VarHandles for JDK >= 9        for (int i = 0; i < arr.length(); i++) {            arr.lazySet(i, EMPTY_BUCKET_VALUE);        }        return arr;    }
public boolean isMatchEqual(int matchIdx, HollowIndexerValueTraverser otherTraverser, int otherMatchIdx) {        for(int i=0;i<getNumFieldPaths();i++) {            if(!HollowReadFieldUtils.fieldsAreEqual((HollowObjectTypeDataAccess)fieldTypeDataAccess[i], fieldMatchLists[i].get(matchIdx), fieldSchemaPosition[i],                    (HollowObjectTypeDataAccess)otherTraverser.fieldTypeDataAccess[i], otherTraverser.fieldMatchLists[i].get(otherMatchIdx), otherTraverser.fieldSchemaPosition[i]))                return false;        }        return true;    }
public int bitsRequiredForField(String fieldName) {        int maxBitsRequiredForField = shards[0].bitsRequiredForField(fieldName);                for(int i=1;i<shards.length;i++) {            int shardRequiredBits = shards[i].bitsRequiredForField(fieldName);            if(shardRequiredBits > maxBitsRequiredForField)                maxBitsRequiredForField = shardRequiredBits;        }                return maxBitsRequiredForField;    }
public T findMatch(Q key) {        Object[] keyArray = matchFields.stream().map(mf -> mf.extract(key)).toArray();        int ordinal = hpki.getMatchingOrdinal(keyArray);        if (ordinal == -1) {            return null;        }        return uniqueTypeExtractor.extract(api, ordinal);    }
