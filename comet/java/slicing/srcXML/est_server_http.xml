<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C" filename="est_server_http.c"><comment type="block">/** @file */</comment>
<comment type="block">/*------------------------------------------------------------------
 * est/est_server_http.c - EST HTTP server
 *
 *			   This code is adapted from the Mongoose
 *			   HTTP server, which is licensed under the
 *			   MIT license.  The Mongoose copyright
 *			   is retained below. The original function
 *			   names have been retained to facilitate
 *			   code maintenance.
 *
 *
 * May, 2013
 *
 * Copyright (c) 2013-2014, 2016 by cisco Systems, Inc.
 * All rights reserved.
 ***------------------------------------------------------------------
 */</comment>
<comment type="line">// Copyright (c) 2004-2012 Sergey Lyubka</comment>
<comment type="line">//</comment>
<comment type="line">// Permission is hereby granted, free of charge, to any person obtaining a copy</comment>
<comment type="line">// of this software and associated documentation files (the "Software"), to deal</comment>
<comment type="line">// in the Software without restriction, including without limitation the rights</comment>
<comment type="line">// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</comment>
<comment type="line">// copies of the Software, and to permit persons to whom the Software is</comment>
<comment type="line">// furnished to do so, subject to the following conditions:</comment>
<comment type="line">//</comment>
<comment type="line">// The above copyright notice and this permission notice shall be included in</comment>
<comment type="line">// all copies or substantial portions of the Software.</comment>
<comment type="line">//</comment>
<comment type="line">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</comment>
<comment type="line">// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</comment>
<comment type="line">// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</comment>
<comment type="line">// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</comment>
<comment type="line">// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</comment>
<comment type="line">// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</comment>
<comment type="line">// THE SOFTWARE.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_str_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_mem_lib.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;WS2tcpip.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/x509v3.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_SECURE_NO_WARNINGS</name></cpp:macro></cpp:define> <comment type="line">// Disable deprecation warning in VS2005</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro> <cpp:value>600</cpp:value></cpp:define>     <comment type="line">// For flockfile() on Linux</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_LARGEFILE_SOURCE</name></cpp:macro></cpp:define>     <comment type="line">// Enable 64-bit file offsets</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_FORMAT_MACROS</name></cpp:macro></cpp:define>  <comment type="line">// &lt;inttypes.h&gt; wants this for C++</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_LIMIT_MACROS</name></cpp:macro></cpp:define>   <comment type="line">// C++ wants that for INT64_MAX</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name> <name>(</name><name>disable</name> <name>:</name> <name>4127</name><name>)</name></cpp:pragma>    <comment type="line">// conditional expression is constant: introduced by FD_SET(..)</comment>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name> <name>(</name><name>disable</name> <name>:</name> <name>4204</name><name>)</name></cpp:pragma>    <comment type="line">// non-constant aggregate initializer: issued due to missing C99 support</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Disable WIN32_LEAN_AND_MEAN.</comment>
<comment type="line">// This makes windows.h always include winsock2.h</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32_LEAN_AND_MEAN</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WIN32_LEAN_AND_MEAN</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32_WCE</name></cpp:ifndef> <comment type="line">// Some ANSI #includes are not available on Windows CE</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !_WIN32_WCE</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_locl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_ossl_util.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_server_http.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_server.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MONGOOSE_VERSION</name></cpp:macro> <cpp:value>"3.5"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PASSWORDS_FILE_NAME</name></cpp:macro> <cpp:value>".htpasswd"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MG_BUF_LEN</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REQUEST_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_SIZE</name><parameter_list>(<parameter><type><name>array</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(array) / sizeof(array[0]))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<decl_stmt><decl><specifier>static</specifier> <type><name>CRITICAL_SECTION</name></type> <name>global_log_file_lock</name></decl>;</decl_stmt>
<function><specifier>static</specifier> <type><name>pthread_t</name></type> <name>pthread_self</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>

<comment type="line">// Darwin prior to 7.0 and Win32 do not have socklen_t</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_SOCKLEN_T</name></cpp:ifdef>
<typedef>typedef <type><name>int</name></type> <name>socklen_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// NO_SOCKLEN_T</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DARWIN_UNLIMITED_SELECT</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSG_NOSIGNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSG_NOSIGNAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SOMAXCONN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOMAXCONN</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_MAX</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="line">// Describes a string (chunk of memory).</comment>
<struct>struct <name>vec</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>file</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>is_directory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>modification_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>membuf</name></decl>;</decl_stmt> <comment type="line">// Non-NULL if file data is in memory</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_FILE_INITIALIZER</name></cpp:macro> <cpp:value>{ 0, 0, 0, NULL, NULL }</cpp:value></cpp:define>


<function><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mg_get_conn_ssl</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><ternary><condition><expr><name>conn</name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SRC_ADDR</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<function><specifier>static</specifier> <type><name>void</name></type> <name>sockaddr_to_string</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>usa</name></name> <modifier>*</modifier></type><name>usa</name></decl></parameter>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name><name>usa</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>usa</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then>
              <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>usa</name><operator>-&gt;</operator><name>sin</name><operator>.</operator><name>sin_addr</name></name></expr> </then><else>:
              <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>usa</name><operator>-&gt;</operator><name>sin6</name><operator>.</operator><name>sin6_addr</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>socklen_t</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <comment type="line">// Only Windoze Vista (and newer) have inet_ntop()</comment>
    <expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAX_SRC_ADDR</name></expr></argument>, <argument><expr><call><name>inet_ntoa</name><argument_list>(<argument><expr><name><name>usa</name><operator>-&gt;</operator><name>sin</name><operator>.</operator><name>sin_addr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name><name>usa</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>usa</name><operator>-&gt;</operator><name>sin</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line">//static void cry(struct mg_connection *conn,</comment>
<comment type="line">//                PRINTF_FORMAT_STRING(const char *fmt), ...) PRINTF_ARGS(2, 3);</comment>

<comment type="line">// Print error message to the opened error log stream.</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>cry</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MG_BUF_LEN</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>src_addr</name><index>[<expr><name>MAX_SRC_ADDR</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type> <name>timestamp</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Do not lock when getting the callback value, here and below.</comment>
    <comment type="line">// I suppose this is fine, since function cannot disappear in the</comment>
    <comment type="line">// same way string option can.</comment>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>ev_data</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sockaddr_to_string</name><argument_list>(<argument><expr><name>src_addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>src_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>rsa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"[%010lu] [error] [client %s] "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>timestamp</name></expr></argument>, <argument><expr><name>src_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>request_method</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"%s %s: "</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>request_method</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>ev_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Return fake connection structure. Used for logging, if connection</comment>
<comment type="line">// is not applicable at the moment of logging.</comment>
<function><specifier>static</specifier> <type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>fc</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><specifier>static</specifier> <type><name><name>struct</name> <name>mg_connection</name></name></type> <name>fake_connection</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>fake_connection</name><operator>.</operator><name>ctx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <return>return <expr><operator>&amp;</operator><name>fake_connection</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mg_version</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><name>MONGOOSE_VERSION</name></expr>;</return>
}</block></function>

<function><type><name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>mg_get_request_info</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name></name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__SYMBIAN32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>mg_strlcpy</name> <parameter_list>(<parameter><decl><type><specifier>register</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{
    <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>src</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{
        <expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type> <name>mg_strndup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>mg_strlcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><specifier>static</specifier> <type><name>int</name></type> <name>lowercase</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>mg_strncasecmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <do>do <block>{
            <expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>lowercase</name><argument_list>(<argument><expr><name>s1</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>lowercase</name><argument_list>(<argument><expr><name>s2</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block> while <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s1</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>--</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
    }</block></then></if>

    <return>return <expr><name>diff</name></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>mg_strcasecmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>

    <do>do <block>{
        <expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>lowercase</name><argument_list>(<argument><expr><name>s1</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>lowercase</name><argument_list>(<argument><expr><name>s2</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s1</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>;</do>

    <return>return <expr><name>diff</name></expr>;</return>
}</block></function>

<comment type="line">// Like snprintf(), but never returns negative value, or a value</comment>
<comment type="line">// that is larger than a supplied buffer.</comment>
<comment type="line">// Thanks to Adam Zeldis to pointing snprintf()-caused vulnerability</comment>
<comment type="line">// in his audit report.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>mg_vsnprintf</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>buflen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>cry</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"vsnprintf error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></then> <elseif>else <if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>buflen</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>cry</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"truncating vsnprintf buffer: [%.*s]"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">200</literal></expr> ?</condition><then> <expr><literal type="number">200</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>buflen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    }</block></then></if></elseif></if>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="line">//static int mg_snprintf(struct mg_connection *conn, char *buf, size_t buflen,</comment>
<comment type="line">//                       PRINTF_FORMAT_STRING(const char *fmt), ...)</comment>
<comment type="line">//PRINTF_ARGS(4, 5);</comment>

<function><specifier>static</specifier> <type><name>int</name></type> <name>mg_snprintf</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mg_vsnprintf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>size_t</name></type> <name>est_strcspn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>str1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>str2</name></decl></parameter>)</parameter_list><block>{

    <decl_stmt><decl><type><name>rsize_t</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errno_t</name></type> <name>safec_rc</name></decl>;</decl_stmt> 

    <if>if <condition>(<expr><operator>(</operator><name>str1</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">0</literal></expr>;</return> 
    }</block></then></if>

    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>strcspn_s</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>RSIZE_MAX_STR</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>RSIZE_MAX_STR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"strcspn_s error 0x%xO\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>count</name></expr>;</return> 


}</block></function>

<function><specifier>static</specifier> <type><name>size_t</name></type> <name>est_strspn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>str1</name></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name>  <modifier>*</modifier></type> <name>str2</name></decl></parameter>)</parameter_list> <block>{

    <decl_stmt><decl><type><name>rsize_t</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errno_t</name></type> <name>safec_rc</name></decl>;</decl_stmt> 

    <if>if <condition>(<expr><operator>(</operator><name>str1</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>str1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">0</literal></expr>;</return> 
    }</block></then></if>

    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>strspn_s</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>RSIZE_MAX_STR</name></expr></argument>)</argument_list></call></expr></argument>, 
            <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>RSIZE_MAX_STR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"strspn_s error 0x%xO\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return> 
    }</block></then></if>

    <return>return <expr><name>count</name></expr>;</return> 

}</block></function>

<comment type="line">// Skip the characters until one of the delimiters characters found.</comment>
<comment type="line">// 0-terminate resulting word. Skip the delimiter and following whitespaces.</comment>
<comment type="line">// Advance pointer to buffer to the next word. Return found 0-terminated word.</comment>
<comment type="line">// Delimiters can be quoted with quotechar.</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>skip_quoted</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiters</name></decl></parameter>,
                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>whitespace</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>quotechar</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>begin_word</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>end_word</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>end_whitespace</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>begin_word</name> <operator>=</operator> <operator>*</operator><name>buf</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>end_word</name> <operator>=</operator> <name>begin_word</name> <operator>+</operator> <call><name>est_strcspn</name><argument_list>(<argument><expr><name>begin_word</name></expr></argument>,<argument><expr><name>delimiters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Check for quotechar</comment>
    <if>if <condition>(<expr><name>end_word</name> <operator>&gt;</operator> <name>begin_word</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>end_word</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>quotechar</name></expr>)</condition> <block>{
            <comment type="line">// If there is anything beyond end_word, copy it</comment>
            <if>if <condition>(<expr><operator>*</operator><name>end_word</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then> <else>else <block>{

                <decl_stmt><decl><type><name>rsize_t</name></type> <name>end_off</name> <init>= <expr><operator>(</operator><name>rsize_t</name><operator>)</operator> <call><name>est_strcspn</name><argument_list>(<argument><expr><name>end_word</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>delimiters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>memmove_s</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end_off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>end_word</name></expr></argument>, <argument><expr><name>end_off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>end_off</name></expr>;</expr_stmt> <comment type="line">// p must correspond to end_word - 1</comment>
                <expr_stmt><expr><name>end_word</name> <operator>+=</operator> <name>end_off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
        <for>for <control>(<init><expr><name>p</name><operator>++</operator></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end_word</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

    <if>if <condition>(<expr><operator>*</operator><name>end_word</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>end_word</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{

        <expr_stmt><expr><name>end_whitespace</name> <operator>=</operator> <name>end_word</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>est_strspn</name><argument_list>(<argument><expr><name>end_word</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>whitespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>end_word</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end_whitespace</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{
            <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>end_whitespace</name></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>begin_word</name></expr>;</return>
}</block></function>

<comment type="line">// Simplified version of skip_quoted without quote char</comment>
<comment type="line">// and whitespace == delimiters</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>skip</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiters</name></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><call><name>skip_quoted</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiters</name></expr></argument>, <argument><expr><name>delimiters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="line">// Return HTTP header value, or NULL if not found.</comment>
<function><specifier>static</specifier> <type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_header</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ri</name><operator>-&gt;</operator><name>num_headers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <if>if <condition>(<expr><operator>!</operator><call><name>mg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>http_headers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name><name>ri</name><operator>-&gt;</operator><name>http_headers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mg_get_header</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><call><name>get_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// HTTP 1.1 assumes keep alive if "Connection:" header is not set</comment>
<comment type="line">// This function must tolerate situations when connection info is not</comment>
<comment type="line">// set up, for example if request parsing failed.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>should_keep_alive</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>http_version</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>http_version</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><call><name>mg_get_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Connection"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Slight deviation from Mongoose behavior here.  We will close the
     * connection when sending a 202 Accepted response.  We will also
     * close the connection for any 4xx response, where Mongoose was only
     * closing for the 401 Unauthorized
     */</comment>
    <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>must_close</name></name> <operator>||</operator>
	<name><name>conn</name><operator>-&gt;</operator><name>status_code</name></name> <operator>==</operator> <name>EST_HTTP_STAT_202</name> <operator>||</operator>
        <name><name>conn</name><operator>-&gt;</operator><name>status_code</name></name> <operator>&gt;=</operator> <literal type="number">400</literal> <operator>||</operator>
        <operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>enable_keepalives</name></name> <operator>||</operator>
        <operator>(</operator><name>header</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>mg_strcasecmp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"keep-alive"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>header</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>http_version</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>http_version</name></expr></argument>, <argument><expr><literal type="string">"1.1"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suggest_connection_header</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <return>return <expr><ternary><condition><expr><call><name>should_keep_alive</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"keep-alive"</literal></expr> </then><else>: <expr><literal type="string">"close"</literal></expr></else></ternary></expr>;</return>
}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>send_http_error</name></cpp:macro> <cpp:value>mg_send_http_error</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>mg_send_http_error</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reason</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MG_BUF_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status_code</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>ev_data</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>long</name><operator>)</operator><name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="line">// Errors 1xx, 204 and 304 MUST NOT send a body</comment>
    <if>if <condition>(<expr><name>status</name> <operator>&gt;</operator> <literal type="number">199</literal> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <literal type="number">204</literal> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <literal type="number">304</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>mg_snprintf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Error %d: %s"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>mg_vsnprintf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"[%s]"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>mg_printf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"HTTP/1.1 %d %s\r\n"</literal>
              <literal type="string">"Content-Length: %d\r\n"</literal>
              <literal type="string">"Connection: %s\r\n\r\n"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
              <argument><expr><call><name>suggest_connection_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>num_bytes_sent</name></name> <operator>+=</operator> <call><name>mg_printf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__SYMBIAN32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="line">// For Windows, change all slashes to backslashes in path names.</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>change_slashes_to_backslashes</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="line">// i &gt; 0 check is to preserve UNC paths, like \\server\file.txt</comment>
        <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name><name>path</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name><name>path</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove_s</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>,
                                <argument><expr><name>path</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, 
				                      <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
    }</block></for>
}</block></function>

<comment type="line">// Encode 'path' which is assumed UTF-8 string, into UNICODE string.</comment>
<comment type="line">// wbuf and wbuf_len is a target buffer and its length.</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>to_unicode</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>wbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>wbuf_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>buf2</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>mg_strlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>change_slashes_to_backslashes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Point p to the end of the file name</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="line">// Convert to Unicode and back. If doubly-converted string does not</comment>
    <comment type="line">// match the original, something is fishy, reject.</comment>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>wbuf</name></expr></argument>, <argument><expr><name>wbuf_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>wbuf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>wbuf_len</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>wbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">L'</literal>\0'</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="line">// Windows happily opens files with some garbage at the end of file name.</comment>
<comment type="line">// For example, fopen("a.cgi    ", "r") on Windows successfully opens</comment>
<comment type="line">// "a.cgi", despite one would expect an error back.</comment>
<comment type="line">// This function returns non-0 if path ends with some garbage.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>path_cannot_disclose_cgi</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><specifier>static</specifier> <type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>allowed_last_characters</name> <init>= <expr><literal type="string">"_-"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><name><name>path</name><index>[<expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>isalnum</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>allowed_last_characters</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>HANDLE</name></type> <name>dlopen</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dll_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>wchar_t</name></type> <name><name>wbuf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Unused</comment>
    <expr_stmt><expr><call><name>to_unicode</name><argument_list>(<argument><expr><name>dll_name</name></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>LoadLibraryW</name><argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>

<comment type="line">// Write data to the IO channel - opened file descriptor, socket or SSL</comment>
<comment type="line">// descriptor. Return number of bytes written.</comment>
<function><specifier>static</specifier> <type><name>int64_t</name></type> <name>push</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>SOCKET</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
                     <parameter><decl><type><name>int64_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int64_t</name></type> <name>sent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>sent</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{

        <comment type="line">// How many bytes we send in this iteration</comment>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>-</operator> <name>sent</name> <operator>&gt;</operator> <name>INT_MAX</name></expr> ?</condition><then> <expr><name>INT_MAX</name></expr> </then><else>: <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>len</name> <operator>-</operator> <name>sent</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>ssl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SSL_write</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>sent</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>sent</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>k</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>send</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>sent</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>k</name></expr></argument>, <argument><expr><name>MSG_NOSIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>

        <expr_stmt><expr><name>sent</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>sent</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * Number of msecs for the poll call to wait before returning
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSEC_POLL_WAIT_TIME</name></cpp:macro> <cpp:value>250</cpp:value></cpp:define>  <comment type="block">/* .25 second wait on the the poll */</comment>

<comment type="line">// This function is needed to prevent Mongoose to be stuck in a blocking</comment>
<comment type="line">// socket read when user requested exit. To do that, we sleep in poll</comment>
<comment type="line">// with a timeout, and when returned, check the context for the stop flag.</comment>
<comment type="line">// If it is set, we return 0, and this means that we must not continue</comment>
<comment type="line">// reading, must give up and close the connection and exit serving thread.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>wait_until_socket_is_readable</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pfd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>times_up</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_UINT</name></type> <name>total_wait_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_UINT</name></type> <name>read_timeout</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>read_timeout</name></name> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

    <do>do <block>{
        <comment type="block">/* accumlate the total amount of time waited */</comment>
        <expr_stmt><expr><name>total_wait_time</name> <operator>+=</operator> <name>MSEC_POLL_WAIT_TIME</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>sock</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>POLL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MSEC_POLL_WAIT_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SSL_pending</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        
        <comment type="block">/*
         * check to see if it's time to give up.  If it is, set
         * things accordingly to close the session down
         */</comment>
        <if>if <condition>(<expr><operator>(</operator><name>total_wait_time</name> <operator>&gt;</operator> <name>read_timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>times_up</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>must_close</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/*
         * Continue waiting,
         * - while there's nothing to read from the socket or
         *   the poll was interrupted by a signal AND
         * - the master process has not indicated to stop AND
         * - the waiting for read timeout has not occurred
         */</comment>                
    }</block> while <condition>(<expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ERRNO</name> <operator>==</operator> <name>EINTR</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
             <name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>stop_flag</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <operator>!</operator><name>times_up</name></expr>)</condition>;</do>

    <return>return <expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>stop_flag</name></name> <operator>||</operator> <name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
}</block></function>

<comment type="line">// Read from IO channel - opened file descriptor, socket, or SSL descriptor.</comment>
<comment type="line">// Return negative value on error, or number of bytes read on success.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>pull</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err_cd</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="line">// Use read() instead of fread(), because if we're reading from the CGI</comment>
        <comment type="line">// pipe, fread() may block until IO buffer is filled up. We cannot afford</comment>
        <comment type="line">// to block and must pass all read bytes immediately to the client.</comment>
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>read</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <elseif>else <if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>must_close</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>wait_until_socket_is_readable</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>SSL_read</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>err_cd</name> <operator>=</operator> <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument> ,<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch<condition>(<expr><name>err_cd</name></expr>)</condition> <block>{
	<case>case <expr><name>SSL_ERROR_NONE</name></expr>:</case>
	    <comment type="block">/* Nothing to do, it's a graceful shutdown */</comment>
	    <break>break;</break>
	<case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:</case>
	    <comment type="block">/*
	     * More data may be coming, change nread to zero
	     * so Mongoose will attempt to read more data
	     * from the peer.  This would occur if the peer
	     * initiated an SSL renegotation.
	     */</comment>
	    <expr_stmt><expr><name>nread</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	    <break>break;</break>
	<case>case <expr><name>SSL_ERROR_WANT_X509_LOOKUP</name></expr>:</case>
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SSL_read error, wants lookup\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <break>break;</break>
	<default>default:</default>
	    <comment type="block">/*
	     * For all other errors, simply log the error
	     * and make sure nread is -1 to indicate an
	     * error to the function above us.
	     */</comment>
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SSL_read error, code: %d\n"</literal></expr></argument>, <argument><expr><name>err_cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>nread</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	    <break>break;</break>
	}</block></switch>
    }</block></then></if></elseif> <else>else <block>{
        <expr_stmt><expr><name>nread</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>sock</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>stop_flag</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>nread</name></expr></else></ternary></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>mg_read</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>buffered_len</name></decl>, <decl><type ref="prev"/><name>nread</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rsize_t</name></type> <name>max_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nread</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_len</name> <operator>=</operator> <operator>(</operator><name>rsize_t</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>consumed_content</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name></expr>)</condition><then> <block>{
        <comment type="line">// Adjust number of bytes to read.</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>to_read</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>consumed_content</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>to_read</name> <operator>&lt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>to_read</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// Return buffered data</comment>
        <expr_stmt><expr><name>body</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>consumed_content</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buffered_len</name> <operator>=</operator> <call>(<name>int</name>) <argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name></expr>]</index></name> <operator>-</operator> <name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>buffered_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>buffered_len</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>buffered_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>max_len</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><operator>(</operator><name>rsize_t</name><operator>)</operator><name>buffered_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>buffered_len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>consumed_content</name></name> <operator>+=</operator> <name>buffered_len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nread</name> <operator>+=</operator> <name>buffered_len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>buffered_len</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// We have returned all buffered data. Read new data from the remote socket.</comment>
        <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pull</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>nread</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt> <comment type="line">// Propagate the error</comment>
                <break>break;</break>
            }</block></then> <elseif>else <if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>consumed_content</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nread</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
            }</block></then></if></elseif> <else>else <block>{
                <comment type="block">/* n == 0. retry */</comment>
            }</block></else></if>   
        }</block></while>
    }</block></then></if>
    <return>return <expr><name>nread</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>mg_write</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int64_t</name></type> <name>total</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>push</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>,
                 <argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>total</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>mg_printf</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>mem</name><index>[<expr><name>MG_BUF_LEN</name></expr>]</index></name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>buf</name> <init>= <expr><name>mem</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <comment type="line">// Print in a local buffer first, hoping that it is large enough to</comment>
    <comment type="line">// hold the whole message</comment>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <comment type="line">// Do nothing. mg_printf(conn, "%s", "") was called.</comment>
    }</block></then> <elseif>else <if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <comment type="line">// vsnprintf() error, give up</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cry</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"%s(%s, ...): vsnprintf() error"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <operator>(</operator><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="line">// Local buffer is not large enough, allocate big buffer on heap</comment>
        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>mg_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
        <comment type="line">// Failed to allocate large enough buffer, give up</comment>
        <expr_stmt><expr><call><name>cry</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"%s(%s, ...): Can't allocate %d bytes, not printing anything"</literal></expr></argument>,
            <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    }</block></then></if></elseif> <else>else <block>{
        <comment type="line">// Copy to the local buffer succeeded</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>mg_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<comment type="line">// URL-decode input buffer into destination buffer.</comment>
<comment type="line">// 0-terminate the destination buffer. Return the length of decoded data.</comment>
<comment type="line">// form-url-encoded data differs from URI encoding in a way that it</comment>
<comment type="line">// uses '+' as character for space, see RFC 1866 section 8.2.1</comment>
<comment type="line">// http://ftp.ics.uci.edu/pub/ietf/html/rfc1866.txt</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>url_decode</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>src_len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>dst_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_form_url_encoded</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEXTOI</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isdigit(x) ? x - '0' : x - 'W')</cpp:value></cpp:define>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>src_len</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>dst_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{
        <if>if <condition>(<expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal> <operator>&amp;&amp;</operator>
            <call><name>isxdigit</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>isxdigit</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>src</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call>(<name>char</name>)<argument_list>(<argument><expr><operator>(</operator><call><name>HEXTOI</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <call><name>HEXTOI</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>is_form_url_encoded</name> <operator>&amp;&amp;</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

    <expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> <comment type="line">// Null-terminate the destination</comment>

    <return>return <expr><ternary><condition><expr><name>i</name> <operator>&gt;=</operator> <name>src_len</name></expr> ?</condition><then> <expr><name>j</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
}</block></function>

<comment type="line">// Check whether full request is buffered. Return:</comment>
<comment type="line">//   -1  if request is malformed</comment>
<comment type="line">//    0  if request is not yet fully buffered</comment>
<comment type="line">//   &gt;0  actual request length, including last \r\n\r\n</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>get_request_len</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>buf</name></expr><operator>,</operator> <expr><name>e</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>buflen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>s</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{
        <comment type="line">// Control characters are not allowed but &gt;=128 is.</comment>
        <if>if <condition>(<expr><operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator>
            <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break> <comment type="line">// [i_a] abort scan as soon as one malformed character is found; don't let subsequent \r\n\r\n win us over anyhow</comment>
        }</block></then> <elseif>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><name>s</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator>
                   <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><name>s</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        }</block></then></if></elseif></if>
    }</block></for>

    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<comment type="line">// Protect against directory disclosure attack by removing '..',</comment>
<comment type="line">// excessive '/' and '\' characters</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>remove_double_dots_and_double_slashes</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>s</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><then> <block>{
            <comment type="line">// Skip all following slashes, backslashes and double-dots</comment>
            <while>while <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{
                <if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
                }</block></then> <elseif>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                }</block></then></if></elseif> <else>else <block>{
                    <break>break;</break>
                }</block></else></if>
            }</block></while>
        }</block></then></if>
    }</block></while>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_AUTH_HDR_LEN</name></cpp:macro> <cpp:value>(256)+(EST_MAX_PATH_SEGMENT_LEN)</cpp:value></cpp:define>
<comment type="block">/*
 * Performs parsing of HTTP Authentication header from
 * the client when Basic authentication is used.
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>mg_parse_auth_hdr_basic</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, 
				     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>auth_header</name></decl></parameter>,
	                             <parameter><decl><type><name>EST_HTTP_AUTH_HDR</name> <modifier>*</modifier></type><name>ah</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>save_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>both</name><index>[<expr><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* will contain both UID and PWD */</comment>
    <decl_stmt><decl><type><name>rsize_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">":"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>colon_found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>possible_pw</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>auth_header</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt>

    <comment type="line">// Gobble initial spaces</comment>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>est_base64_decode</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>both</name></expr></argument>, <argument><expr><operator>(</operator><name>MAX_UIDPWD</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Base64 decode of HTTP auth header failed, HTTP auth will fail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * Make sure there's a ':' in the string
     */</comment>
    <expr_stmt><expr><name>colon_found</name> <operator>=</operator> <call><name>strstr_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>possible_pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>colon_found</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Invalid format of Basic HTTP credentials, missing :"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><operator>(</operator><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * did it start with a colon, meaning no userid?
     */</comment>
    <if>if <condition>(<expr><name><name>both</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
            <comment type="block">/* just a password */</comment>
            <expr_stmt><expr><name>possible_pw</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>pwd</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>possible_pw</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Authentication header contains only password"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* We got neither userid nor password */</comment>
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Authentication header contains no userid or password"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><operator>(</operator><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></else></if>
    }</block></then> <else>else <block>{
        <comment type="block">/* Started with a userid, 
         * Parse the username and password, which are separated by a ":"
         */</comment>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>strtok_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>pwd</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>save_ptr</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>AUTH_BASIC</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><operator>(</operator><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Performs parsing of HTTP Authentication header from
 * the client when Digest authentication is used.
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>mg_parse_auth_hdr_digest</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, 
				      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>auth_header</name></decl></parameter>,
	                              <parameter><decl><type><name>EST_HTTP_AUTH_HDR</name> <modifier>*</modifier></type><name>ah</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>value</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_AUTH_HDR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>AUTH_DIGEST</name></expr>;</expr_stmt>

    <comment type="line">// Make modifiable copy of the auth header</comment>
    <expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAX_AUTH_HDR_LEN</name></expr></argument>, <argument><expr><name>auth_header</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><name>MAX_AUTH_HDR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

    <comment type="line">// Parse authorization header</comment>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{
        <comment type="line">// Gobble initial spaces</comment>
        <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	    <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
	}</block></while>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>skip_quoted</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Value is either quote-delimited, or ends at first comma or space.</comment>
	<if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\"'</literal></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
	    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>skip_quoted</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then> <else>else <block>{
	    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>skip_quoted</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// IE uses commas, FF uses spaces</comment>
	}</block></else></if>
	<if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
	    <break>break;</break>
	}</block></then></if>

        <expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"username"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if> 

        <expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"cnonce"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>cnonce</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_NONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if> 

	<expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"response"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>response</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_RESPONSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
        }</block></then></if> 

	<expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"uri"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>uri</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_REALM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if> 

	<expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"qop"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>qop</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_QOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
	}</block></then></if> 

	<expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"nc"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>nc</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_NC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <continue>continue;</continue>
        }</block></then></if> 

	<expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"nonce"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>nonce</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_NONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></while>
}</block></function>


<comment type="block">/*
 * Performs parsing of HTTP Authentication header from
 * the client when Token(bearer) authentication is used.
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>mg_parse_auth_hdr_token</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, 
				     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>auth_header</name></decl></parameter>,
	                             <parameter><decl><type><name>EST_HTTP_AUTH_HDR</name> <modifier>*</modifier></type><name>ah</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>value_decoded</name><index>[<expr><name>MAX_AUTH_TOKEN_LEN</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>auth_header</name> <operator>+</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>EST_BEARER_TOKEN_STR</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="line">// Gobble initial spaces</comment>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
	<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>value_decoded</name></expr></argument>, <argument><expr><name>MAX_AUTH_TOKEN_LEN</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>est_base64_decode</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_decoded</name></expr></argument>, <argument><expr><operator>(</operator><name>MAX_AUTH_TOKEN_LEN</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Base64 decode of HTTP auth credentials failed, HTTP auth will fail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
        <comment type="block">/*Copy the token into the auth header structure. */</comment>
        <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>auth_token</name></name> <operator>=</operator> <call><name>STRNDUP</name><argument_list>(<argument><expr><name>value_decoded</name></expr></argument>, <argument><expr><name>MAX_AUTH_TOKEN_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>AUTH_TOKEN</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>ah</name><operator>-&gt;</operator><name>auth_token</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to obtain memory for authentication token buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Authentication header from client contained no Token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>   
}</block></function>


<comment type="block">/*
 * This function parses the HTTP Authentication header
 * from the client.  It will fill in the fields on the
 * EST_HTTP_AUTH_HDR struct, which are used later for
 * verifying the user's credentials using either HTTP
 * Basic or HTTP Digest authentication. The ah parameter
 * should already be allocated when calling this function.
 *
 * Return either good, bad, or missing 
 */</comment>
<function><type><name>EST_HTTP_AUTH_HDR_RESULT</name></type> <name>mg_parse_auth_header</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, 
                                               <parameter><decl><type><name>EST_HTTP_AUTH_HDR</name> <modifier>*</modifier></type><name>ah</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>auth_header</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get the Auth header from the HTTP client 
     */</comment>
    <if>if <condition>(<expr><operator>(</operator><name>auth_header</name> <operator>=</operator> <call><name>mg_get_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Authorization"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<return>return <expr><name>EST_AUTH_HDR_MISSING</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>mg_strncasecmp</name><argument_list>(<argument><expr><name>auth_header</name></expr></argument>, <argument><expr><literal type="string">"Digest "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<comment type="block">/* Make sure server is configured for digest auth */</comment>
	<if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>!=</operator> <name>AUTH_DIGEST</name></expr>)</condition><then> <block>{
	    <return>return <expr><name>EST_AUTH_HDR_BAD</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>mg_parse_auth_hdr_digest</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>auth_header</name></expr></argument>, <argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    }</block></then> <elseif>else <if>if <condition>(<expr><call><name>mg_strncasecmp</name><argument_list>(<argument><expr><name>auth_header</name></expr></argument>, <argument><expr><literal type="string">"Basic "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<comment type="block">/* Make sure server is configured for basic auth */</comment>
	<if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>!=</operator> <name>AUTH_BASIC</name></expr>)</condition><then> <block>{
	    <return>return <expr><name>EST_AUTH_HDR_BAD</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>mg_parse_auth_hdr_basic</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>auth_header</name></expr></argument>, <argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><call><name>mg_strncasecmp</name><argument_list>(<argument><expr><name>auth_header</name></expr></argument>, <argument><expr><name>EST_BEARER_TOKEN_STR</name></expr></argument>,
                              <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>EST_BEARER_TOKEN_STR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<comment type="block">/* Make sure server is configured for bearer(token) auth */</comment>
	<if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>!=</operator> <name>AUTH_TOKEN</name></expr>)</condition><then> <block>{
	    <return>return <expr><name>EST_AUTH_HDR_BAD</name></expr>;</return>
	}</block></then></if>
	<expr_stmt><expr><call><name>mg_parse_auth_hdr_token</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>auth_header</name></expr></argument>, <argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></elseif> <else>else <block>{
	<comment type="block">/* Only Basic, Digest and Bearer Token authentication are supported */</comment>
	<expr_stmt><expr><name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
        <return>return <expr><name>EST_AUTH_HDR_BAD</name></expr>;</return>
    }</block></else></if>

    <comment type="block">/* 
     * If we're doing digest auth, make sure all the values
     * were parsed
     */</comment>
    <if>if <condition>(<expr><name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>ah</name><operator>-&gt;</operator><name>uri</name></name> <operator>||</operator>
		                    <operator>!</operator><name><name>ah</name><operator>-&gt;</operator><name>nonce</name></name> <operator>||</operator>
				    <operator>!</operator><name><name>ah</name><operator>-&gt;</operator><name>nc</name></name> <operator>||</operator>
				    <operator>!</operator><name><name>ah</name><operator>-&gt;</operator><name>cnonce</name></name><operator>)</operator></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Parsing of HTTP auth header failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EST_AUTH_HDR_BAD</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If we were not able to parse a user ID and we're not
     * in token auth mode, then make sure we fail the authentication.
     */</comment>
    <if>if <condition>(<expr><name><name>ah</name><operator>-&gt;</operator><name>user</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>AUTH_TOKEN</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_AUTH_HDR_BAD</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ah</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>AUTH_TOKEN</name></expr>)</condition><then> <block>{   
        <comment type="block">/*
         * Save the user ID on the connection context.
         * We will want to pass this to the CA later.
         */</comment>
        <expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>user_id</name></name></expr></argument>, <argument><expr><name>MG_UID_MAX</name></expr></argument>, <argument><expr><name><name>ah</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>MG_UID_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <return>return <expr><name>EST_AUTH_HDR_GOOD</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>mg_send_authorization_request</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status_code</name></name> <operator>=</operator> <literal type="number">401</literal></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>auth_mode</name></name></expr>)</condition> <block>{
    <case>case <expr><name>AUTH_BASIC</name></expr>:</case>
	<expr_stmt><expr><call><name>mg_printf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
              <argument><expr><literal type="string">"%s\r\n"</literal>
              <literal type="string">"%s: 0\r\n"</literal>
              <literal type="string">"%s: Basic realm=\"%s\"\r\n\r\n"</literal></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_401</name></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_AUTH</name></expr></argument>,
              <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>AUTH_DIGEST</name></expr>:</case>
	<expr_stmt><expr><call><name>mg_printf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
              <argument><expr><literal type="string">"%s\r\n"</literal>
              <literal type="string">"%s: 0\r\n"</literal>
              <literal type="string">"%s: Digest qop=\"auth\", "</literal>
              <literal type="string">"realm=\"%s\", nonce=\"%lu\"\r\n\r\n"</literal></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_401</name></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_AUTH</name></expr></argument>,
              <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>,
              <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>AUTH_TOKEN</name></expr>:</case>
	<expr_stmt><expr><call><name>mg_printf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
              <argument><expr><literal type="string">"%s\r\n"</literal>
              <literal type="string">"%s: 0\r\n"</literal>
              <literal type="string">"%s: Bearer realm=\"%s\"\r\n\r\n"</literal></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_401</name></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>,
	      <argument><expr><name>EST_HTTP_HDR_AUTH</name></expr></argument>,
              <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>AUTH_FAIL</name></expr>:</case>
    <case>case <expr><name>AUTH_NONE</name></expr>:</case>
    <default>default:</default>
	<comment type="block">/* These modes are not valid at this point
	 * nothing to do here. */</comment>
	<break>break;</break>
    }</block></switch>
}</block></function>


<comment type="line">// Parse HTTP headers from the given buffer, advance buffer to the point</comment>
<comment type="line">// where parsing stopped.</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>parse_http_headers</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>http_headers</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>http_headers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>skip_quoted</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>http_headers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>skip</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>http_headers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>num_headers</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>is_valid_http_method</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>method</name></decl></parameter>)</parameter_list>
<block>{
    <comment type="block">/* EST only allows GET &amp; POST */</comment>
    <return>return <expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><literal type="string">"GET"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><literal type="string">"POST"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// Parse HTTP request, fill in mg_request_info structure.</comment>
<comment type="line">// This function modifies the buffer by NUL-terminating</comment>
<comment type="line">// HTTP request components, header names and header values.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>parse_http_message</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>request_length</name> <init>= <expr><call><name>get_request_len</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>request_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <comment type="line">// Reset attributes. DO NOT TOUCH is_ssl, remote_ip, remote_port</comment>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>uri</name></name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>num_headers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>request_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <comment type="line">// RFC says that all initial whitespaces should be ingored</comment>
        <while>while <condition>(<expr><operator>*</operator><name>buf</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name> <operator>=</operator> <call><name>skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name> <operator>=</operator> <call><name>skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name> <operator>=</operator> <call><name>skip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>parse_http_headers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"request_len=%d"</literal></expr></argument>, <argument><expr><name>request_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"request uri=%s"</literal></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>request_length</name></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>parse_http_request</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>parse_http_message</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <call><name>is_valid_http_method</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name></expr></argument>, <argument><expr><literal type="string">"HTTP/"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt> <comment type="line">// Skip "HTTP/"</comment>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="line">// Keep reading the input (either opened file descriptor fd, or socket sock,</comment>
<comment type="line">// or SSL descriptor ssl) into buffer buf, until \r\n\r\n appears in the</comment>
<comment type="line">// buffer (which marks the end of HTTP request). Buffer buf may already</comment>
<comment type="line">// have some data. The length of the data is stored in nread.</comment>
<comment type="line">// Upon every read operation, increase nread by the number of bytes read.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>read_request</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
                         <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsiz</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nread</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>request_len</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>request_len</name> <operator>=</operator> <call><name>get_request_len</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>nread</name> <operator>&lt;</operator> <name>bufsiz</name> <operator>&amp;&amp;</operator> <name>request_len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pull</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <operator>*</operator><name>nread</name></expr></argument>, <argument><expr><name>bufsiz</name> <operator>-</operator> <operator>*</operator><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><operator>*</operator><name>nread</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>request_len</name> <operator>=</operator> <call><name>get_request_len</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>

    <if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <comment type="line">// recv() error -&gt; propagate error; do not process a b0rked-with-very-high-probability request</comment>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>request_len</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is called by the Mongoose code when an
 * incoming HTTP request is processed.
 * Returns 0 on success, non-zero if the request wasn't
 * handled.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_mg_handler</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>request_info</name> <init>= <expr><call><name>mg_get_request_info</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ectx</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>est_rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cl_hdr</name></decl>;</decl_stmt> <comment type="block">/* content length html header */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ct_hdr</name></decl>;</decl_stmt> <comment type="block">/* content type html header */</comment>

    <expr_stmt><expr><name>cl_hdr</name> <operator>=</operator> <call><name>mg_get_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Content-Length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cl_hdr</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * At this point, Content-Length value has already been
         * error checked and is guaranteed to be within the correct
         * range.  Obtain the length, allocate the buffer for the
         * body, and read it in.
         */</comment>
        <expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>cl_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>cl</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>mg_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make sure the buffer is null terminated */</comment>
	<expr_stmt><expr><name><name>body</name><index>[<expr><name>cl</name></expr>]</index></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>cl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>body</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>ct_hdr</name> <operator>=</operator> <call><name>mg_get_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Content-Type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>ectx</name><operator>-&gt;</operator><name>est_mode</name></name> <operator>==</operator> <name>EST_SERVER</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>est_rv</name> <operator>=</operator> <call><name>est_http_request</name><argument_list>(<argument><expr><name>ectx</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>request_info</name><operator>-&gt;</operator><name>request_method</name></name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>request_info</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>, <argument><expr><name>ct_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <elseif>else <if>if <condition>(<expr><name><name>ectx</name><operator>-&gt;</operator><name>est_mode</name></name> <operator>==</operator> <name>EST_PROXY</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>est_rv</name> <operator>=</operator> <call><name>est_proxy_http_request</name><argument_list>(<argument><expr><name>ectx</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>request_info</name><operator>-&gt;</operator><name>request_method</name></name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>request_info</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>, <argument><expr><name>ct_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></elseif></if>
    <if>if <condition>(<expr><name>est_rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST error response code: %d (%s)\n"</literal></expr></argument>, 
		    <argument><expr><name>est_rv</name></expr></argument>, <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>est_rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>cl_hdr</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>est_rv</name></expr>;</return>
}</block></function>


<comment type="line">// This is the heart of the Mongoose's logic.</comment>
<comment type="line">// This function is called when the request is read, parsed and validated,</comment>
<comment type="line">// and Mongoose must decide what action to take: serve a file, or</comment>
<comment type="line">// a directory, or call embedded function, etcetera.</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>handle_request</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>uri_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>query_string</name></name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>query_string</name></name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>uri_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>url_decode</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name>uri_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>remove_double_dots_and_double_slashes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Process the request
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_mg_handler</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>EST_ERR_NONE</name> <operator>!=</operator> <name>rv</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Incoming request failed rv=%d (%s)"</literal></expr></argument>, 
		     <argument><expr><name>rv</name></expr></argument>, <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><specifier>static</specifier> <type><name>void</name></type> <name>log_header</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>header_value</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>(</operator><name>header_value</name> <operator>=</operator> <call><name>mg_get_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">" -"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name>header_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><specifier>static</specifier> <type><name>void</name></type> <name>log_access</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>date</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>src_addr</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>


    <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d/%b/%Y:%H:%M:%S %z"</literal></expr></argument>,
             <argument><expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>birth_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ri</name> <operator>=</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sockaddr_to_string</name><argument_list>(<argument><expr><name>src_addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>src_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>rsa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"%s [%s] \"%s %s HTTP/%s\" %d %"</literal> <name>INT64_FMT</name></expr></argument>,
                 <argument><expr><name>src_addr</name></expr></argument>, <argument><expr><name>date</name></expr></argument>,
                 <argument><expr><ternary><condition><expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name></expr> ?</condition><then> <expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>,
                 <argument><expr><ternary><condition><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr> ?</condition><then> <expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr> </then><else>: <expr><literal type="string">"-"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>status_code</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>num_bytes_sent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>log_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Referer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>log_header</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"User-Agent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Return OpenSSL error message</comment>
<function><specifier>static</specifier> <type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ssl_error</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>err</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>ERR_get_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>err</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>ERR_error_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
}</block></function>

<comment type="line">// Dynamically load SSL library. Set up ctx-&gt;ssl_ctx pointer.</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>set_ssl_option</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ectx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>ssl_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EC_KEY</name> <modifier>*</modifier></type><name>ecdh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_VERIFY_PARAM</name> <modifier>*</modifier></type><name>vpm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>sic</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <init>= <expr><literal type="string">"EST"</literal></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>(</operator><name>ssl_ctx</name> <operator>=</operator> <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_server_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>cry</name><argument_list>(<argument><expr><call><name>fc</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"SSL_CTX_new (server) error: %s"</literal></expr></argument>, <argument><expr><call><name>ssl_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name> <operator>=</operator> <name>ssl_ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ectx</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>fc</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>ev_data</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr>;</expr_stmt>


    <expr_stmt><expr><call><name>SSL_CTX_set_verify</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>SSL_VERIFY_PEER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the Session ID context to enable OpenSSL session
     * reuse, which improves performance.  We set the ID to
     * ESTxxxxxxxx, where the x values are random numbers
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><call><name>RAND_bytes</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sic</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"RNG failure while setting SIC: %s"</literal></expr></argument>, <argument><expr><call><name>ssl_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>SSL_CTX_set_session_id_context</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sic</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// load in the CA cert(s) used to verify client certificates</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_cert_store</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>trusted_certs_store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//The ssl code will free this store from ssl_ctx later</comment>
    <expr_stmt><expr><name><name>ectx</name><operator>-&gt;</operator><name>trusted_certs_store</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  

    <comment type="block">/*
     * Note that we disable TLS tickets, which is another
     * way to reuse TLS sessions to avoid all the key exchange
     * overhead of the TLS handshake.  We've enabled session
     * reuse above.  But session reuse will not 
     * work when ticket support is enabled on the server.
     * We may want to look into enabling tickets
     * in the future, but for now the session reuse
     * above gives us a performance boost.
     *
     * The other options set here are to improve forward
     * secrecty and comply with the EST draft.
     */</comment>

    <expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>SSL_OP_NO_SSLv2</name> <operator>|</operator>
                        <name>SSL_OP_NO_SSLv3</name> <operator>|</operator>
                        <name>SSL_OP_NO_TLSv1</name> <operator>|</operator>
                        <name>SSL_OP_SINGLE_ECDH_USE</name> <operator>|</operator>
                        <name>SSL_OP_NO_TICKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* 
     * Set the ECDH single use parms.  Use the configured
     * curve, or use prime256v1 as the default.
     */</comment>
    <if>if <condition>(<expr><name><name>ectx</name><operator>-&gt;</operator><name>ecdhe_nid</name></name></expr>)</condition><then> <block>{
	<comment type="block">/* Setup the user selected curve */</comment>
	<expr_stmt><expr><name>ecdh</name> <operator>=</operator> <call><name>EC_KEY_new_by_curve_name</name><argument_list>(<argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>ecdhe_nid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Using non-default ECDHE curve (nid=%d)"</literal></expr></argument>, <argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>ecdhe_nid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* Default to prime256 curve */</comment>
	<expr_stmt><expr><name>ecdh</name> <operator>=</operator> <call><name>EC_KEY_new_by_curve_name</name><argument_list>(<argument><expr><name>NID_X9_62_prime256v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Using default ECDHE curve (prime256v1)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name>ecdh</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to generate temp ecdh parameters\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>SSL_CTX_set_tmp_ecdh</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>ecdh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EC_KEY_free</name><argument_list>(<argument><expr><name>ecdh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup additional cert checks including CRL, depth
     * and purpose.
     */</comment>
    <expr_stmt><expr><name>vpm</name> <operator>=</operator> <call><name>X509_VERIFY_PARAM_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Enable CRL checks */</comment>
    <if>if <condition>(<expr><name><name>ectx</name><operator>-&gt;</operator><name>enable_crl</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_flags</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>X509_V_FLAG_CRL_CHECK</name> <operator>|</operator>
                                    <name>X509_V_FLAG_CRL_CHECK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_depth</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>EST_TLS_VERIFY_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Note: the purpose is only checked when the keyusage
     * value is present in the client's cert */</comment>
    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_purpose</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>X509_PURPOSE_SSL_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SSL_CTX_set1_param</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>vpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_free</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the single-use DH parameters if the application
     * has requested this capability.
     */</comment>
    <if>if <condition>(<expr><name><name>ectx</name><operator>-&gt;</operator><name>dh_tmp</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>SSL_OP_SINGLE_DH_USE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SSL_CTX_set_tmp_dh</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>dh_tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DH_free</name><argument_list>(<argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>dh_tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ectx</name><operator>-&gt;</operator><name>dh_tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ectx</name><operator>-&gt;</operator><name>enable_srp</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Enabling TLS SRP mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><call><name>SSL_CTX_set_cipher_list</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>EST_CIPHER_LIST_SRP_SERVER</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to set SSL cipher suites\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><literal type="number">0</literal></expr>;</return>
	}</block></then></if>
	<comment type="block">/*
	 * Set the application specific handler for
	 * providing the SRP parameters during user 
	 * authentication.
	 */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_set_srp_username_callback</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>est_srp_username_cb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"TLS SRP not enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Set the TLS cipher suites that should be allowed.
	 * This disables anonymous and null ciphers
	 */</comment>
	<if>if <condition>(<expr><operator>!</operator><call><name>SSL_CTX_set_cipher_list</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name>EST_CIPHER_LIST</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to set SSL cipher suites\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><literal type="number">0</literal></expr>;</return>
	}</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><call><name>SSL_CTX_use_certificate</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>server_cert</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set server certificate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>SSL_CTX_use_PrivateKey</name><argument_list>(<argument><expr><name>ssl_ctx</name></expr></argument>, <argument><expr><name><name>ectx</name><operator>-&gt;</operator><name>server_priv_key</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set server private key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * There should be no need to include the cert chain for the
     * server's certificate in the TLS Certificate message from
     * the server.  The reason is the EST draft specifies that
     * all the subordinate CA certs should be included in the
     * cacerts message flow.  Hence, the client will already have
     * the full cert chain.  Therfore, the TLS handshake will only
     * contain the server's cert, not the full chain. 
     *
      SSL_CTX_use_certificate_chain_file(ctx-&gt;ssl_ctx,
                                         ctx-&gt;est_ctx-&gt;http_cert_file);
     */</comment>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>void</name></type> <name>reset_per_request_attributes</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>path_info</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>ev_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>num_bytes_sent</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>consumed_content</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status_code</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>must_close</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>is_valid_uri</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list>
<block>{
    <comment type="line">// Conform to http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2</comment>
    <comment type="line">// URI can be an asterisk (*) or should start with slash.</comment>
    <return>return <expr><name><name>uri</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>(</operator><name><name>uri</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>uri</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>void</name></type> <name>process_new_connection</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>mg_request_info</name></name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>keep_alive_enabled</name></decl>, <decl><type ref="prev"/><name>keep_alive</name></decl>, <decl><type ref="prev"/><name>discard_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>keep_alive_enabled</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>enable_keepalives</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>keep_alive</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="line">// Important: on new connection, reset the receiving buffer. Credit goes</comment>
    <comment type="line">// to crule42.</comment>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr><call><name>reset_per_request_attributes</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>=</operator> <call><name>read_request</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf_size</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>buf_size</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>send_http_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">413</literal></expr></argument>, <argument><expr><literal type="string">"Request Too Large"</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <return>return;</return> <comment type="line">// Remote end closed the connection</comment>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>parse_http_request</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf_size</name></name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>!</operator><call><name>is_valid_uri</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Do not put garbage in the access log, just send it back to the client</comment>
            <expr_stmt><expr><call><name>send_http_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><literal type="string">"Bad Request"</literal></expr></argument>,
                            <argument><expr><literal type="string">"Cannot parse HTTP request: [%.*s]"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>must_close</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name></expr></argument>, <argument><expr><literal type="string">"1.0"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                   <call><name>strncmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>http_version</name></name></expr></argument>, <argument><expr><literal type="string">"1.1"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="line">// Request seems valid, but HTTP version is strange</comment>
            <expr_stmt><expr><call><name>send_http_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">505</literal></expr></argument>, <argument><expr><literal type="string">"HTTP version not supported"</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>log_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <comment type="line">// Request is valid, handle it</comment>
            <if>if <condition>(<expr><operator>(</operator><name>cl</name> <operator>=</operator> <call><name>get_header</name><argument_list>(<argument><expr><name>ri</name></expr></argument>, <argument><expr><literal type="string">"Content-Length"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>cl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>mg_strcasecmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name></expr></argument>, <argument><expr><literal type="string">"POST"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
                       <operator>!</operator><call><name>mg_strcasecmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>request_method</name></name></expr></argument>, <argument><expr><literal type="string">"PUT"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then></if></elseif> <else>else <block>{
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            }</block></else></if>
            <comment type="block">/*
             * Ensure that the content-length value is a size that
             * the EST code is willing to accept
             */</comment>
            <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>&gt;</operator> <name>EST_MAX_CONTENT_LEN</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"HTTP request content length greater than EST"</literal>
                             <literal type="string">" maximum supported content length (%d)"</literal></expr></argument>, 
                             <argument><expr><name>EST_MAX_CONTENT_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                <expr_stmt><expr><call><name>send_http_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">413</literal></expr></argument>, <argument><expr><literal type="string">"Content-Length too large"</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>log_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <elseif>else <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"HTTP request content length is a negative value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>send_http_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><literal type="string">"Bad Request"</literal></expr></argument>,
                                <argument><expr><literal type="string">"Content-Length is negative"</literal></expr></argument>,
                                <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>log_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif> <else>else <block>{
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>birth_time</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>handle_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>log_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if> 
        }</block></else></if>

        <comment type="line">// NOTE(lsm): order is important here. should_keep_alive() call</comment>
        <comment type="line">// is using parsed request, which will be invalid after memmove's below.</comment>
        <comment type="line">// Therefore, memorize should_keep_alive() result now for later use</comment>
        <comment type="line">// in loop exit condition.</comment>
        <expr_stmt><expr><name>keep_alive</name> <operator>=</operator> <call><name>should_keep_alive</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Discard all buffered data for this request</comment>
        <expr_stmt><expr><name>discard_len</name> <operator>=</operator> <ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                      <name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>&lt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name></expr> ?</condition><then>
                      <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>request_len</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name></expr></else></ternary></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>-</operator> <name>discard_len</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>memmove_s</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>MAX_REQUEST_SIZE</name></expr></argument>,
		      <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>discard_len</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>-</operator> <name>discard_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>-=</operator> <name>discard_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data_len</name></name> <operator>&lt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>buf_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block> while <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>stop_flag</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <name>keep_alive_enabled</name> <operator>&amp;&amp;</operator>
             <name><name>conn</name><operator>-&gt;</operator><name>content_len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <name>keep_alive</name></expr>)</condition>;</do>
}</block></function>


<comment type="block">/*! @brief est_server_handle_request() is used by an application 
    to process an EST request.  The application is responsible
    for opening a listener socket.  When an EST request comes in
    on the socket, the application uses this function to hand-off
    the request to libEST.

    @param ctx Pointer to the EST_CTX, which was provided
               when est_server_init()  or est_proxy_init() was invoked.
    @param fd File descriptor that will be read to retrieve the
              HTTP request from the client.  This is typically
	      a TCP socket file descriptor.

    est_server_handle_request() is used by an application 
    when an incoming EST request needs to be processed.  This request
    would be a cacerts, simpleenroll, reenroll, or csrattrs request. 
    This is used when implementing an EST server.  The application 
    is responsible for opening and listening to a TCP socket for
    incoming EST requests.  When data is ready to be read from
    the socket, this API entry point should be used to allow libEST
    to read the request from the socket and respond to the request.
 

    @return EST_ERROR.
*/</comment>
<function><type><name>EST_ERROR</name></type> <name>est_server_handle_request</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>mg_connection</name></name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>socket</name></name></type> <name>accepted</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>socklen_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ipstr</name><index>[<expr><name>INET6_ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ssl_err</name></decl>, <decl><type ref="prev"/><name>err_code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null EST context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>mg_ctx</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null EST MG context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>accepted</name><operator>.</operator><name>sock</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>accepted</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_storage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>getpeername</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"getpeername() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* This should never happen, not sure what would cause this */</comment>
	<return>return <expr><operator>(</operator><name>EST_ERR_UNKNOWN</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <comment type="line">// deal with both IPv4 and IPv6:</comment>
    <if>if <condition>(<expr><name><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>accepted</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		 <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>accepted</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>accepted</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><name>ipstr</name></expr></argument>, <argument><expr><sizeof>sizeof <name>ipstr</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{ <comment type="line">// AF_INET6</comment>
        <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>accepted</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin6</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		 <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>accepted</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin6</name><operator>.</operator><name>sin6_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>accepted</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><name>ipstr</name></expr></argument>, <argument><expr><sizeof>sizeof <name>ipstr</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Peer IP address: %s"</literal></expr></argument>, <argument><expr><name>ipstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Peer port      : %d"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>(</operator>struct <name>mg_connection</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>conn</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>MAX_REQUEST_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>cry</name><argument_list>(<argument><expr><call><name>fc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mg_ctx</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"Cannot create new connection struct, OOM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>buf_size</name></name> <operator>=</operator> <name>MAX_REQUEST_SIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>conn</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>accepted</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>birth_time</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>mg_ctx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>read_timeout</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>server_read_timeout</name></name></expr>;</expr_stmt>

        <comment type="line">// Fill in IP, port info early so even if SSL setup below fails,</comment>
        <comment type="line">// error handler would have the corresponding info.</comment>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>remote_port</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>remote_ip</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>,
                 <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>rsa</name><operator>.</operator><name>sin</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>remote_ip</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>remote_ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>request_info</name><operator>.</operator><name>is_ssl</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * EST require TLS,  Setup the TLS tunnel
         */</comment>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>SSL_set_fd</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client</name><operator>.</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ssl_err</name> <operator>=</operator> <call><name>SSL_accept</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <if>if <condition>(<expr><name>ssl_err</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err_code</name> <operator>=</operator> <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>, <argument><expr><name>ssl_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>err_code</name></expr>)</condition> <block>{
		<case>case <expr><name>SSL_ERROR_SYSCALL</name></expr>:</case>
		    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"OpenSSL system call error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_SYSCALL</name></expr>;</expr_stmt>
		    <break>break;</break>
		<case>case <expr><name>SSL_ERROR_SSL</name></expr>:</case>
		    <comment type="block">/* Some unknown OpenSSL error, dump the 
		     * OpenSSL error log to learn more about this */</comment>
		    <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_UNKNOWN</name></expr>;</expr_stmt>
		    <break>break;</break>
		<case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:</case>
		<case>case <expr><name>SSL_ERROR_WANT_WRITE</name></expr>:</case>
		    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"App using non-blocking socket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>process_new_connection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <break>break;</break>
		<case>case <expr><name>SSL_ERROR_WANT_X509_LOOKUP</name></expr>:</case>
		    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SSL_accept error, wants lookup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_UNKNOWN</name></expr>;</expr_stmt>
		    <break>break;</break>
		<case>case <expr><name>SSL_ERROR_NONE</name></expr>:</case>
		<default>default:</default>
		    <break>break;</break>
		}</block></switch>
	    }</block></then> <else>else <block>{
		<expr_stmt><expr><call><name>process_new_connection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></else></if>
            <expr_stmt><expr><name>ssl_err</name> <operator>=</operator> <call><name>SSL_shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <switch>switch <condition>(<expr><name>ssl_err</name></expr>)</condition> <block>{
	    <case>case <expr><literal type="number">0</literal></expr>:</case>
		<comment type="block">/* OpenSSL docs say to call shutdown again for this case */</comment>
		<expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Two-phase SSL_shutdown initiated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    <case>case <expr><literal type="number">1</literal></expr>:</case>
		<comment type="block">/* Nothing to do, shutdown worked */</comment>
		<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"SSL_shutdown succeeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    <default>default:</default>
		<comment type="block">/* Log an error */</comment>
		<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"SSL_shutdown failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	    }</block></switch>
            <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ssl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>conn</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>MAX_REQUEST_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>


<function><specifier>static</specifier> <type><name>void</name></type> <name>free_context</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <comment type="line">// Deallocate SSL context</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="line">// Deallocate context itself</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>mg_stop</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mg_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>stop_flag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__SYMBIAN32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>WSACleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>
}</block></function>

<function><type><name><name>struct</name> <name>mg_context</name></name> <modifier>*</modifier></type><name>mg_start</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>mg_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__SYMBIAN32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>WSADATA</name></type> <name>data</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_log_file_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// _WIN32</comment>

    <comment type="line">// Allocate context and initialize reasonable general case defaults.</comment>
    <comment type="line">// TODO(lsm): do proper error handling here.</comment>
    <if>if <condition>(<expr><operator>(</operator><name>ctx</name> <operator>=</operator> <operator>(</operator>struct <name>mg_context</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_ctx</name></name> <operator>=</operator> <operator>(</operator><name>EST_CTX</name><operator>*</operator><operator>)</operator><name>user_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enable_keepalives</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
    <if>if <condition>(<expr><operator>!</operator><call><name>set_ssl_option</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>ctx</name></expr>;</return>
}</block></function>

<function><type><name>EST_ERROR</name></type> <name>est_send_csrattr_data</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>csr_data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>csr_len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>http_ctx</name></decl></parameter>)</parameter_list>
<block>{
   <decl_stmt><decl><type><name>char</name></type> <name><name>http_hdr</name><index>[<expr><name>EST_HTTP_HDR_MAX</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>hdrlen</name></decl>;</decl_stmt>

   <if>if <condition>(<expr><operator>(</operator><name>csr_len</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>csr_data</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Send HTTP 200 header
         */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name>EST_HTTP_HDR_200</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_EOL</name></expr></argument>,
                 <argument><expr><name>EST_HTTP_HDR_STAT_200</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>http_hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_hdr</name> <operator>+</operator> <name>hdrlen</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>, <argument><expr><literal type="string">"%s: %s%s"</literal></expr></argument>, <argument><expr><name>EST_HTTP_HDR_CT</name></expr></argument>,
                 <argument><expr><name>EST_HTTP_CT_CSRATTRS</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>http_hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_hdr</name> <operator>+</operator> <name>hdrlen</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>, <argument><expr><literal type="string">"%s: %s%s"</literal></expr></argument>, <argument><expr><name>EST_HTTP_HDR_CE</name></expr></argument>,
                 <argument><expr><name>EST_HTTP_CE_BASE64</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>http_hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_hdr</name> <operator>+</operator> <name>hdrlen</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>, <argument><expr><literal type="string">"%s: %d%s%s"</literal></expr></argument>, <argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>,
                 <argument><expr><name>csr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_EOL</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_EOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name>mg_write</name><argument_list>(<argument><expr><name>http_ctx</name></expr></argument>, <argument><expr><name>http_hdr</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>http_hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_WRITE</name><operator>)</operator></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * Send the CSR in the body
         */</comment>
        <if>if <condition>(<expr><operator>!</operator><call><name>mg_write</name><argument_list>(<argument><expr><name>http_ctx</name></expr></argument>, <argument><expr><name>csr_data</name></expr></argument>, <argument><expr><name>csr_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_WRITE</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<if>if <condition>(<expr><name>csr_data</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
        <comment type="block">/* Send a 204 response indicating the server doesn't have a CSR */</comment>
	<expr_stmt><expr><call><name>est_send_http_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>http_ctx</name></expr></argument>, <argument><expr><name>EST_ERR_HTTP_NO_CONTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>
</unit>
