<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C" filename="est_client.c"><comment type="block">/** @file */</comment>
<comment type="block">/*------------------------------------------------------------------
 * est/est_client.c - EST client specific code
 *
 *	       Assumptions:  - Web server using this module utilizes
 *	                       OpenSSL for HTTPS services.
 *	                     - OpenSSL is linked along with this
 *	                       module.
 *
 * April, 2013
 *
 * Copyright (c) 2013, 2016, 2017 by cisco Systems, Inc.
 * All rights reserved.
 **------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Ws2tcpip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;BaseTsd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;WinDef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;WinNT.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wincrypt.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/rand.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_locl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_ossl_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_mem_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_str_lib.h"</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/x509v3.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/asn1.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_URIPARSER</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"uriparser/Uri.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>close</name><parameter_list>(<parameter><type><name>socket</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>closesocket(socket)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>WSADATA</name></type> <name>wsaData</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SSL_EXDATA_INDEX_INVALID</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>e_ctx_ssl_exdata_index</name> <init>= <expr><name>SSL_EXDATA_INDEX_INVALID</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*****************************************************************************
* EST Client operations
*****************************************************************************/</comment>
<comment type="block">/*
 * Utility function to set the certificate and private key to use
 * for a SSL context.
 *
 * Returns 0 on success
 */</comment>
<function><type><name>int</name></type> <name>est_client_set_cert_and_key</name> <parameter_list>(<parameter><decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>cert</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{

    <if>if <condition>(<expr><call><name>SSL_CTX_use_certificate</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cert</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Error setting certificate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>SSL_CTX_use_PrivateKey</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{

        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set private key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Verify the key matches the cert
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><call><name>SSL_CTX_check_private_key</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Private key does not match the certificate public key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    }</block></then></if>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></function>


<comment type="block">/*
 * Sign an X509 certificate request using the digest and the key passed.
 * Returns OpenSSL error code from X509_REQ_sign_ctx();
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_X509_REQ_sign</name> <parameter_list>(<parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>md</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EVP_PKEY_CTX</name> <modifier>*</modifier></type><name>pkctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EVP_MD_CTX</name></type> <name>mctx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>EVP_MD_CTX_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><operator>!</operator><call><name>EVP_DigestSignInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkctx</name></expr></argument>, <argument><expr><name>md</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Encode using DER (ASN.1) 
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     */</comment>
    <expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>req_info</name><operator>-&gt;</operator><name>enc</name><operator>.</operator><name>modified</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>X509_REQ_sign_ctx</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EVP_MD_CTX_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>
<comment type="block">/*
 * populate_x509_request will build an x509 request buffer.  It does this by
 * calls into OpenSSL to insert the fields of the x509 header.
 *
 * Parameters:
 *	req:	pointer to the buffer that is to hold the x509 request header
 *	pkey:   public key to be placed into the x509 request
 *	cn:     Common Name to be placed into the x509 request
 *      cp:     challenge password to be placed into the x509 header
 *
 * Return value:
 *	EST_ERR_NONE if success
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>populate_x509_request</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, 
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>X509_NAME</name> <modifier>*</modifier></type><name>subj</name></decl>;</decl_stmt>


    <comment type="block">/* setup version number */</comment>
    <if>if <condition>(<expr><operator>!</operator><call><name>X509_REQ_set_version</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set X509 version"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_X509_VER</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Add Common Name entry
     */</comment>
    <expr_stmt><expr><name>subj</name> <operator>=</operator> <call><name>X509_REQ_get_subject_name</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><call><name>X509_NAME_add_entry_by_txt</name><argument_list>(<argument><expr><name>subj</name></expr></argument>, <argument><expr><literal type="string">"CN"</literal></expr></argument>, <argument><expr><name>MBSTRING_ASC</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>cn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set X509 common name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_X509_CN</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Add challengePassword attribute if required
     * No need to remove/add attributes here, only the PoP is
     * part of the simple enroll flow.
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>csr_pop_required</name></name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client_force_pop</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Client will include challengePassword in CSR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><call><name>X509_REQ_add1_attr_by_NID</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>NID_pkcs9_challengePassword</name></expr></argument>,
                                       <argument><expr><name>MBSTRING_ASC</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>cp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set X509 challengePassword attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>EST_ERR_X509_ATTR</name><operator>)</operator></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <comment type="block">/*
     * Set the public key on the request
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><call><name>X509_REQ_set_pubkey</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set public key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_X509_PUBKEY</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function will generate a PKCS10 request.
 *
 * Parameters:
 *	cn:	Common Name to put into the certificate.
 *	cp:     TLS unique ID for the SSL session, becomes the challenge password
 *	pkey:	Private key to use for signing the request.
 *
 * Return value:
 *	EST_ERR_NONE if success
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_generate_pkcs10</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, 
	                              <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier><modifier>*</modifier></type><name>pkcs10</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ossl_rv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>X509_REQ_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>req</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate X509_REQ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>populate_x509_request</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>X509_REQ_free</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Sign the request
     */</comment>
    <expr_stmt><expr><name>ossl_rv</name> <operator>=</operator> <call><name>est_client_X509_REQ_sign</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>ossl_rv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to sign X509 cert request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X509_REQ_free</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_X509_SIGN</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><operator>*</operator><name>pkcs10</name> <operator>=</operator> <name>req</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function is a callback used by OpenSSL's verify_cert function.
 * It's called at the end of a cert verification to allow an opportunity to
 * gather more information regarding a failing cert verification, and to
 * possibly change the result of the verification.
 *
 * This callback is similar to the ossl routine, but does not alter
 * the verification result.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_cacert_verify_cb</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>cert_error</name> <init>= <expr><call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>current_cert</name> <init>= <expr><call><name>X509_STORE_CTX_get_current_cert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"enter function: ok=%d cert_error=%d"</literal></expr></argument>, <argument><expr><name>ok</name></expr></argument>, <argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>current_cert</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_NAME_print_ex_fp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,
                                  <argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>current_cert</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XN_FLAG_ONELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"%s error %d at %d depth lookup: %s\n"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><call><name>X509_STORE_CTX_get0_parent_ctx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"[CRL path]"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                     <argument><expr><name>cert_error</name></expr></argument>,
                     <argument><expr><call><name>X509_STORE_CTX_get_error_depth</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>ok</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function will remove CRLs from a received cacert response buffer.
 *
 * Parameters:
 *	ctx:	EST Context representing this session
 *  cacerts:    pointer to the buffer holding the resulting CA certs 
 *  cacerts_len: length of the cacerts buffer
 *       p7:    pointer to the pkcs7 buffer that was received
 *
 * Return value:
 *	EST_ERR_NONE if success
 
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_remove_crls</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cacerts</name></decl></parameter>,
                                         <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cacerts_len</name></decl></parameter>, <parameter><decl><type><name>PKCS7</name> <modifier>*</modifier></type><name>p7</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>crls_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b64_enc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>p7bio_out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_cacerts_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_cacerts_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    
    <expr_stmt><expr><name>nid</name><operator>=</operator><call><name>OBJ_obj2nid</name><argument_list>(<argument><expr><name><name>p7</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>nid</name></expr>)</condition>
        <block>{
        <case>case <expr><name>NID_pkcs7_signed</name></expr>:</case>
            <if>if <condition>(<expr><name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sign</name><operator>-&gt;</operator><name>crl</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>sk_X509_CRL_pop_free</name><argument_list>(<argument><expr><name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sign</name><operator>-&gt;</operator><name>crl</name></name></expr></argument>, <argument><expr><name>X509_CRL_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sign</name><operator>-&gt;</operator><name>crl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>crls_found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        <case>case <expr><name>NID_pkcs7_signedAndEnveloped</name></expr>:</case>
            <if>if <condition>(<expr><name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>signed_and_enveloped</name><operator>-&gt;</operator><name>crl</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>sk_X509_CRL_pop_free</name><argument_list>(<argument><expr><name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>signed_and_enveloped</name><operator>-&gt;</operator><name>crl</name></name></expr></argument>, <argument><expr><name>X509_CRL_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sign</name><operator>-&gt;</operator><name>crl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>crls_found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid NID value on PKCS7 structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>EST_ERR_CACERT_VERIFICATION</name><operator>)</operator></expr>;</return>            
            <break>break;</break>
        }</block></switch>

    <comment type="block">/*
     * If CRLs were removed, then the original PKCS7 buffer needs to be
     * updated.  This will always be base64 encoded.
     * - Allocate the BIOs,
     * - Write the PKCS7 struct back into PEM format,
     * - Get the pointer and length to the new base64 PEM encoded buffer,
     * - and then copy it into the original buffer that was passed in.
     * Since the CRLs are being removed, the new buffer will always be shorter
     * and will fit into the original buffer.
     */</comment>
    <if>if <condition>(<expr><name>crls_found</name></expr>)</condition><then> <block>{

        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"CRL(s) attached with the CA Certificates.  Removing CRL(s)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>b64_enc</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_f_base64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>b64_enc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>p7bio_out</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>p7bio_out</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to access the CA cert buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return<expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>p7bio_out</name> <operator>=</operator> <call><name>BIO_push</name><argument_list>(<argument><expr><name>b64_enc</name></expr></argument>, <argument><expr><name>p7bio_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>cacerts</name></expr></argument>, <argument><expr><operator>*</operator><name>cacerts_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>i2d_PKCS7_bio</name><argument_list>(<argument><expr><name>p7bio_out</name></expr></argument>, <argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"PEM_write_bio_PKCS7 failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p7bio_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <return>return <expr><operator>(</operator><name>EST_ERR_CACERT_VERIFICATION</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>BIO_flush</name><argument_list>(<argument><expr><name>p7bio_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * BIO_get_mem_data just returns the pointer and length to the data
         * contained in the mem BIO.  Nothing is allocated and passed back
         */</comment>
        <expr_stmt><expr><name>new_cacerts_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>BIO_get_mem_data</name><argument_list>(<argument><expr><name>p7bio_out</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>new_cacerts_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_cacerts_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to copy PKCS7 data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p7bio_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <return>return <expr><operator>(</operator><name>EST_ERR_CACERT_VERIFICATION</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <comment type="block">/*
         * copy the new buffer back into the old buffer
         */</comment>
        <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>cacerts</name></expr></argument>, <argument><expr><operator>*</operator><name>cacerts_len</name></expr></argument>, <argument><expr><name>new_cacerts_buf</name></expr></argument>, <argument><expr><name>new_cacerts_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>cacerts_len</name> <operator>=</operator> <name>new_cacerts_len</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p7bio_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function will decode the passed base64 encoded buffer and return the
 * decoded cacerts. If returning EST_ERR_NONE, caller is responsible for
 * freeing the cacerts_decoded buffer
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>b64_decode_cacerts</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cacerts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cacerts_len</name></decl></parameter>,
                                     <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cacerts_decoded</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cacerts_decoded_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b64</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>decoded_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>decoded_buf_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>cacerts_decoded</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cacerts_decoded_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>b64</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_f_base64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>b64</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>    
    <comment type="block">/*
     * Decoding will always take up less than the original buffer.
     */</comment>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name><argument_list>(<argument><expr><name>cacerts</name></expr></argument>, <argument><expr><operator>*</operator><name>cacerts_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if>if <condition>(<expr><name>in</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to access the CA cert buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>BIO_push</name><argument_list>(<argument><expr><name>b64</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><name>decoded_buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>*</operator><name>cacerts_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>decoded_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate CA cert buffer for decode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>        
    }</block></then></if>
    
    <expr_stmt><expr><name>decoded_buf_len</name> <operator>=</operator> <call><name>BIO_read</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>decoded_buf</name></expr></argument>, <argument><expr><operator>*</operator><name>cacerts_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><operator>*</operator><name>cacerts_decoded</name> <operator>=</operator> <name>decoded_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cacerts_decoded_len</name> <operator>=</operator> <name>decoded_buf_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * If returning EST_ERR_NONE, caller is responsible for freeing the PKCS7 struct
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>create_PKCS7</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cacerts_decoded</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacerts_decoded_len</name></decl></parameter>,
                               <parameter><decl><type><name>PKCS7</name> <modifier>*</modifier><modifier>*</modifier></type><name>pkcs7out</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>p7bio_in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PKCS7</name> <modifier>*</modifier></type><name>pkcs7</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Now get the PKCS7 formatted buffer of certificates read into a stack of
     * X509 certs
     */</comment>
    <expr_stmt><expr><name>p7bio_in</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>, <argument><expr><name>cacerts_decoded_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>p7bio_in</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to access the PKCS7 buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>
        
    <expr_stmt><expr><name>pkcs7</name> <operator>=</operator> <call><name>d2i_PKCS7_bio</name><argument_list>(<argument><expr><name>p7bio_in</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>pkcs7</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to read in PKCS7 based certificate buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p7bio_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
        <return>return <expr><operator>(</operator><name>EST_ERR_LOAD_CACERTS</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p7bio_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pkcs7out</name> <operator>=</operator> <name>pkcs7</name></expr>;</expr_stmt>
    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>    
}</block></function>


<decl_stmt><decl><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>PKCS7_to_stack</name> <argument_list>(<argument><expr><name>PKCS7</name> <operator>*</operator><name>pkcs7</name></expr></argument>, <argument><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>*</operator><name>stack</name></expr></argument>)</argument_list> 
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nid</name><operator>=</operator><call><name>OBJ_obj2nid</name><argument_list>(<argument><expr><name><name>pkcs7</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>nid</name></expr>)</condition>
        <block>{
        <case>case <expr><name>NID_pkcs7_signed</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>stack</name> <operator>=</operator> <name><name>pkcs7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sign</name><operator>-&gt;</operator><name>cert</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NID_pkcs7_signedAndEnveloped</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>stack</name> <operator>=</operator> <name><name>pkcs7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>signed_and_enveloped</name><operator>-&gt;</operator><name>cert</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid NID value on PKCS7 structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>EST_ERR_CACERT_VERIFICATION</name><operator>)</operator></expr>;</return>
            <break>break;</break>
        }</block></switch>

    <if>if <condition>(<expr><operator>*</operator><name>stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"X509 certs not found within PKCS7 buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_CACERT_VERIFICATION</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>    
}</block></decl></decl_stmt>


<comment type="block">/*
 * This function is invoked when the CACerts response has been received.  The
 * cert chain is built into a cert store and then each certificate is verified
 * against this store essentially verifying the cert chain against itself to
 * ensure that each intermediate can be verified back to one of the included
 * root certs in the CACerts response.  If CRLs are attached these will be
 * removed and a new PKCS7 buffer is created.
 *
 * Parameters:
 *	ctx:	EST Context representing this session
 *  cacerts:    pointer to the buffer holding the received CA certs 
 *  cacerts_len: length of the cacerts buffer
 *
 * Return value:
 *	EST_ERR_NONE if success
 
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>verify_cacert_resp</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cacerts</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cacerts_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>est_rc</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>X509_STORE</name>  <modifier>*</modifier></type><name>trusted_cacerts_store</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> <operator>*</operator><name>stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>current_cert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cacerts_decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>cacerts_decoded_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>store_ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PKCS7</name> <modifier>*</modifier></type><name>pkcs7</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cacerts</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cacerts_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid parameter. ctx = %x cacerts = %x cacerts_len = %x"</literal></expr></argument>,
                    <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cacerts</name></expr></argument>, <argument><expr><name>cacerts_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>    

    <comment type="block">/*
     * - Base64 decode the incoming ca certs buffer,
     * - convert to a PKCS7 structure,
     * - extract out the stack of certs.
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>b64_decode_cacerts</name><argument_list>(<argument><expr><name>cacerts</name></expr></argument>, <argument><expr><name>cacerts_len</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>cacerts_decoded</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cacerts_decoded_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Base64 decode of received CA certs failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>create_PKCS7</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>, <argument><expr><name>cacerts_decoded_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to build PKCS7 structure from receievd buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>PKCS7_to_stack</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Could not obtain stack of ca certs from PKCS7 structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    
    <comment type="block">/*
     * At this point we have the stack of X509 certs that make up
     * the CA certs response sent from the EST server.
     * - Build a store of "trusted" certs to use in the verify
     * - walk through each cert and verify it 
     *   - Build a store context from the store and the cert to be verified and
     *     call the verify function
     */</comment>
    <expr_stmt><expr><name>trusted_cacerts_store</name> <operator>=</operator> <call><name>X509_STORE_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>trusted_cacerts_store</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate cert store"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>X509_STORE_set_verify_cb</name><argument_list>(<argument><expr><name>trusted_cacerts_store</name></expr></argument>, <argument><expr><name>est_client_cacert_verify_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>sk_X509_num</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <expr_stmt><expr><name>current_cert</name> <operator>=</operator> <call><name>sk_X509_value</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Is it self signed?  If so, add it in the trusted store, otherwise,
         * add it to the untrusted store.
         */</comment>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>X509_check_issued</name><argument_list>(<argument><expr><name>current_cert</name></expr></argument>, <argument><expr><name>current_cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>X509_V_OK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Adding cert to trusted store (%s)"</literal></expr></argument>, <argument><expr><name><name>current_cert</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_add_cert</name><argument_list>(<argument><expr><name>trusted_cacerts_store</name></expr></argument>, <argument><expr><name>current_cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <comment type="block">/*
     * set up a X509 Store Context
     */</comment>
    <expr_stmt><expr><name>store_ctx</name> <operator>=</operator> <call><name>X509_STORE_CTX_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>store_ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate a new store context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X509_STORE_free</name><argument_list>(<argument><expr><name>trusted_cacerts_store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return<expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>sk_X509_num</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{

        <if>if <condition>(<expr><operator>!</operator><call><name>X509_STORE_CTX_init</name><argument_list>(<argument><expr><name>store_ctx</name></expr></argument>, <argument><expr><name>trusted_cacerts_store</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to initialize the new store context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_free</name><argument_list>(<argument><expr><name>trusted_cacerts_store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_CTX_free</name><argument_list>(<argument><expr><name>store_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <return>return <expr><operator>(</operator> <name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>current_cert</name> <operator>=</operator> <call><name>sk_X509_value</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Adding cert to store (%s)"</literal></expr></argument>, <argument><expr><name><name>current_cert</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>X509_STORE_CTX_set_cert</name><argument_list>(<argument><expr><name>store_ctx</name></expr></argument>, <argument><expr><name>current_cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>X509_verify_cert</name><argument_list>(<argument><expr><name>store_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><name>rv</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * this cert failed verification.  Log this and continue on
             */</comment>
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Certificate failed verification (%s)"</literal></expr></argument>, <argument><expr><name><name>current_cert</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>failed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <comment type="block">/*
     * Finally, remove any CRLs that might be attached.
     */</comment>
    <expr_stmt><expr><name>est_rc</name> <operator>=</operator> <call><name>est_client_remove_crls</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cacerts</name></expr></argument>, <argument><expr><name>cacerts_len</name></expr></argument>, <argument><expr><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X509_STORE_free</name><argument_list>(<argument><expr><name>trusted_cacerts_store</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X509_STORE_CTX_free</name><argument_list>(<argument><expr><name>store_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>failed</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_CACERT_VERIFICATION</name><operator>)</operator></expr>;</return>
    }</block></then> <else>else <block>{
        <return>return <expr><name>est_rc</name></expr>;</return>
    }</block></else></if>
}</block></function>


<comment type="block">/*
 * This function is registered with SSL to be called during the verification
 * of each certificate in the server's identity cert chain.  The main purpose
 * is to look for the case where the cert could not be verified.  In this case,
 * if the EST client app has registered a callback to receive these untrusted
 * certs, it will be forwarded up to the EST client application.
 *
 * Parameters:
 *	ok:	The status of this certificate from the SSL verify code.
 *   x_ctx:     Ptr to the X509 certificate store structure  
 *
 * Return value:
 *   int: The potentially modified status after processing this certificate. This cane
 *        be modified by the ET client application if they've provided a callback
 *        allowing it to be processed, or modified here in this callback.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>cert_verify_cb</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>x_ctx</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSL</name>    <modifier>*</modifier></type><name>ssl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>e_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>approve</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cert_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>current_cert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>approve</name> <operator>=</operator> <name>ok</name></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>x_ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid X509 context pointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>approve</name><operator>)</operator></expr>;</return>
    }</block></then></if>    
    
    <expr_stmt><expr><name>cert_error</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>x_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>current_cert</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_current_cert</name><argument_list>(<argument><expr><name>x_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"entering: Cert passed up from OpenSSL. error = %d (%s) \n"</literal></expr></argument>,
                 <argument><expr><name>cert_error</name></expr></argument>, <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Retrieve the pointer to the SSL structure for this connection and then
     * the application specific data stored into the SSL object.  This will be
     * our EST ctx for this EST session.
     */</comment>
    <if>if <condition>(<expr><name>e_ctx_ssl_exdata_index</name> <operator>==</operator> <name>SSL_EXDATA_INDEX_INVALID</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid SSL exdata index for EST context value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>approve</name><operator>)</operator></expr>;</return>
    }</block></then></if>
        
    <expr_stmt><expr><name>ssl</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_ex_data</name><argument_list>(<argument><expr><name>x_ctx</name></expr></argument>, <argument><expr><call><name>SSL_get_ex_data_X509_STORE_CTX_idx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>ssl</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"NULL pointer retrieved for SSL session pointer from X509 ctx ex_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>approve</name><operator>)</operator></expr>;</return>
    }</block></then></if>        
    <expr_stmt><expr><name>e_ctx</name> <operator>=</operator> <call><name>SSL_get_ex_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>e_ctx_ssl_exdata_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>e_ctx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"NULL pointer retrieved for EST context from SSL ex_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>approve</name><operator>)</operator></expr>;</return>
    }</block></then></if>        

    <if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>cert_error</name></expr>)</condition> <block>{

            <comment type="block">/*
             * Cases where we notify the client application:
             *
             * CERT_UNTRUSTED is what is expected, but not what we get in the
             * case where we cannot verify our server's cert.
             * SELF_SIGNED_CERT_IN_CHAIN is what currently results with our server
             * when we cannot verify its cert.
             * UNABLE_TO_GET_CRL is passed up to make sure the application knows
             * that although
             */</comment>
        <case>case <expr><name>X509_V_ERR_CERT_UNTRUSTED</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN</name></expr>:</case>  
        <case>case <expr><name>X509_V_ERR_UNABLE_TO_GET_CRL</name></expr>:</case>
            
            <comment type="block">/*
             * If the application provided a callback then go ahead and pass
             * this cert store up.  If not, then log a warning and return what
             * SSL gave us for a status.
             */</comment>            
            <if>if <condition>(<expr><name><name>e_ctx</name><operator>-&gt;</operator><name>manual_cert_verify_cb</name></name></expr>)</condition><then> <block>{
                
                <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"EST client application server cert verify function is registered\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>approve</name> <operator>=</operator> <call><name><name>e_ctx</name><operator>-&gt;</operator><name>manual_cert_verify_cb</name></name><argument_list>(<argument><expr><name>current_cert</name></expr></argument>, <argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
            }</block></then> <else>else <block>{
                                
                <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"NO EST client application server cert verify function registered\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>cert_error</name> <operator>==</operator> <name>X509_V_ERR_UNABLE_TO_GET_CRL</name></expr>)</condition><then> <block>{

                    <comment type="block">/*
                     * We've enabled CRL checking in the TLS stack.  If the
                     * application hasn't loaded a CRL, then this verify error
                     * can occur.  The peer's cert is valid, but we can't
                     * confirm if it was revoked.  The app has not provided
                     * a way for us to notify on this, so our only option is
                     * to log a warning and proceed on.
                     */</comment>
                    <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"No CRL loaded, TLS peer will be allowed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>approve</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
            <break>break;</break>

        <comment type="block">/* The remainder of these will result in the ok state remaining unchanged
         * and a EST log warning message being logged.
         */</comment>
        <case>case <expr><name>X509_V_ERR_NO_EXPLICIT_POLICY</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CERT_HAS_EXPIRED</name></expr>:</case>

        <comment type="block">/* since we are just checking the certificates, it is
         * ok if they are self signed. But we should still warn
         * the user.
         */</comment>
        <case>case <expr><name>X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT</name></expr>:</case>
        <comment type="block">/* Continue after extension errors too */</comment>
        <case>case <expr><name>X509_V_ERR_INVALID_CA</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_INVALID_NON_CA</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_PATH_LENGTH_EXCEEDED</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_INVALID_PURPOSE</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CRL_HAS_EXPIRED</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CRL_NOT_YET_VALID</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CERT_REVOKED</name></expr>:</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Certificate verify failed (reason = %d) (%s)"</literal></expr></argument>,
                         <argument><expr><name>cert_error</name></expr></argument>, <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></switch>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>approve</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function is used to create and initialize an
 * SSL_CTX that will be used for client and proxy EST operations.
 * The SSL_CTX is stored on the EST_CTX.
 *
 * Parameters:
 *	ctx:	EST Context
 *
 * Return value:
 *	EST_ERROR
 *         EST_ERR_NONE if success
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_init_ssl_ctx</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSL_CTX</name>     <modifier>*</modifier></type><name>s_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_VERIFY_PARAM</name> <modifier>*</modifier></type><name>vpm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>est_log_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid context pointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_NO_CTX</name></expr>;</return>
    }</block></then></if>
        
    <if>if <condition>(<expr><operator>(</operator><name>s_ctx</name> <operator>=</operator> <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_client_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to obtain a new SSL Context\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_SSL_CTX_NEW</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Only TLS 1.1 or above can be used for EST
     */</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>s_ctx</name></expr></argument>, <argument><expr><name>SSL_OP_NO_SSLv2</name> <operator>|</operator>
                        <name>SSL_OP_NO_SSLv3</name> <operator>|</operator>
                        <name>SSL_OP_NO_TLSv1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * limit the cipher suites that are offered
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><call><name>SSL_CTX_set_cipher_list</name><argument_list>(<argument><expr><name>s_ctx</name></expr></argument>, <argument><expr><name>EST_CIPHER_LIST</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to set SSL cipher suites\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_SSL_CIPHER_LIST</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Make sure we're verifying the server
     */</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_verify</name><argument_list>(<argument><expr><name>s_ctx</name></expr></argument>, <argument><expr><name>SSL_VERIFY_PEER</name><operator>|</operator><name>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</name></expr></argument>,
                       <argument><expr><name>cert_verify_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * leverage the cert store we already created from the
     * trusted CA chain provided by the application.
     *
     * In either case, the SSL stack will clean up the cert store during the
     * SSL_CTX_free(), so let's remove our reference to it so we don't try to
     * clean it up ourselves later
     */</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_cert_store</name><argument_list>(<argument><expr><name>s_ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>trusted_certs_store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>trusted_certs_store</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        

    <comment type="block">/*
     * Set up X509 params and assign them to the SSL ctx
     * - Enable CRL checks
     * - Max # of untrusted CA certs that can exist in a chain
     * - ensure that the cert is being used as intended, if
     *   it contains the X509 KeyUsage extension
     */</comment>
    <expr_stmt><expr><name>vpm</name> <operator>=</operator> <call><name>X509_VERIFY_PARAM_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>vpm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate a verify parameter structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>
        
    <comment type="block">/* Enable CRL checks */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>enable_crl</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_flags</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>X509_V_FLAG_CRL_CHECK</name> <operator>|</operator>
                                    <name>X509_V_FLAG_CRL_CHECK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_flags</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>X509_V_FLAG_CRL_CHECK</name> <operator>|</operator>
                                <name>X509_V_FLAG_CRL_CHECK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_depth</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>EST_TLS_VERIFY_DEPTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_set_purpose</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>, <argument><expr><name>X509_PURPOSE_SSL_SERVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SSL_CTX_set1_param</name><argument_list>(<argument><expr><name>s_ctx</name></expr></argument>, <argument><expr><name>vpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>X509_VERIFY_PARAM_free</name><argument_list>(<argument><expr><name>vpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Save the reference to the SSL session
     * This will be used later when matching the EST_CTX to the SSL context
     * in est_ssl_info_cb().
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name> <operator>=</operator> <name>s_ctx</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>e_ctx_ssl_exdata_index</name> <operator>==</operator> <name>SSL_EXDATA_INDEX_INVALID</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>e_ctx_ssl_exdata_index</name> <operator>=</operator> <call><name>SSL_get_ex_new_index</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"EST Context"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    }</block></then></if>

    <comment type="block">/*
     * This last config setting is not ctx based, but instead, global to the
     * entire libcrypto library.  Need to ensure that CSR string attributes
     * are added in ASCII printable format.
     */</comment>
    <expr_stmt><expr><call><name>ASN1_STRING_set_default_mask</name><argument_list>(<argument><expr><name>B_ASN1_PRINTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function calculates the digest value to be
 * used in HTTP requests when the server has asked
 * the client to use HTTP digest authentication.
 * It uses the tokens that were parsed from the HTTP
 * server response earlier to calculate the digest.
 */</comment>
<function><specifier>static</specifier> <type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>est_client_generate_auth_digest</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>,
                                                       <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EVP_MD_CTX</name> <modifier>*</modifier></type><name>mdctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>md</name> <init>= <expr><call><name>EVP_md5</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>ha1</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ha1_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ha1_str</name><index>[<expr><name>EST_MAX_MD5_DIGEST_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>ha2</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ha2_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ha2_str</name><index>[<expr><name>EST_MAX_MD5_DIGEST_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>nonce_cnt</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <init>= <expr><literal type="string">"00000001"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>d_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Calculate HA1 using username, realm, password, and server nonce
     */</comment>
    <expr_stmt><expr><name>mdctx</name> <operator>=</operator> <call><name>EVP_MD_CTX_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><call><name>EVP_DigestInit_ex</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>md</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to Initialize digest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>, <argument><expr><name>MAX_REALM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestFinal</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>ha1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ha1_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_MD_CTX_destroy</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_hex_to_str</name><argument_list>(<argument><expr><name>ha1_str</name></expr></argument>, <argument><expr><name>ha1</name></expr></argument>, <argument><expr><name>ha1_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate HA2 using method, URI,
     */</comment>
    <expr_stmt><expr><name>mdctx</name> <operator>=</operator> <call><name>EVP_MD_CTX_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><call><name>EVP_DigestInit_ex</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>md</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to Initialize digest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">"POST"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>MAX_REALM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestFinal</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>ha2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ha2_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_MD_CTX_destroy</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_hex_to_str</name><argument_list>(<argument><expr><name>ha2_str</name></expr></argument>, <argument><expr><name>ha2</name></expr></argument>, <argument><expr><name>ha2_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate auth digest using HA1, nonce, nonce count, client nonce, qop, HA2
     */</comment>
    <expr_stmt><expr><name>mdctx</name> <operator>=</operator> <call><name>EVP_MD_CTX_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><call><name>EVP_DigestInit_ex</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>md</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to Initialize digest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>ha1_str</name></expr></argument>, <argument><expr><name>ha1_len</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>s_nonce</name></name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>s_nonce</name></name></expr></argument>, <argument><expr><name>MAX_NONCE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>nonce_cnt</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>nonce_cnt</name></expr></argument>, <argument><expr><name>MAX_NC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>c_nonce</name></name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>c_nonce</name></name></expr></argument>, <argument><expr><name>MAX_NONCE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">"auth"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestUpdate</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>ha2_str</name></expr></argument>, <argument><expr><name>ha2_len</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_DigestFinal</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EVP_MD_CTX_destroy</name><argument_list>(<argument><expr><name>mdctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>EST_MAX_MD5_DIGEST_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory for digest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><call><name>est_hex_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rv</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>d_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * est_client_retrieve_credentials() is used to retrieve the credentials when
 * the server has requested either BASIC or DIGEST mode.  The values needed from
 * the application layer in either mode are the same, username, password, but the
 * API will indicate the mode to the callback in case anything changes.
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>est_client_retrieve_credentials</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>EST_HTTP_AUTH_MODE</name></type> <name>auth_mode</name></decl></parameter>,
                                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>EST_HTTP_AUTH_HDR</name></type> <name>auth_credentials</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_HTTP_AUTH_CRED_RC</name></type> <name>rc</name></decl>;</decl_stmt>
    
    <comment type="block">/*
     * See if we only have one part of them.  If so, reset the part we
     * have.
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
            
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>password</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>password</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
                
    <comment type="block">/*
     * Need to ask the application layer for the credentials
     */</comment>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auth_credentials</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>auth_credentials</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_credentials_cb</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>auth_credentials</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>auth_mode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>auth_credentials_cb</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>auth_credentials</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>EST_HTTP_AUTH_CRED_NOT_AVAILABLE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Attempt to obtain token from application failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * Did we get the credentials we expected?  If not, point to a NULL string
     * to generate the header
     */</comment>
    <if>if <condition>(<expr><name><name>auth_credentials</name><operator>.</operator><name>user</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>user</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
    }</block></then> <elseif>else <if>if <condition>(<expr><name>MAX_UIDPWD</name> <operator>&lt;</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>auth_credentials</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Userid provided is larger than the max of %d"</literal></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>user</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
    }</block></then></if></elseif> <else>else <block>{
        <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>, <argument><expr><name><name>auth_credentials</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid User ID provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
    
    <if>if <condition>(<expr><name><name>auth_credentials</name><operator>.</operator><name>pwd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pwd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
    }</block></then> <elseif>else <if>if <condition>(<expr><name>MAX_UIDPWD</name> <operator>&lt;</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>auth_credentials</name><operator>.</operator><name>pwd</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Password provided is larger than the max of %d"</literal></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pwd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
    }</block></then></if></elseif> <else>else <block>{
        <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>, <argument><expr><name><name>auth_credentials</name><operator>.</operator><name>pwd</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid User password provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr><call><name>cleanse_auth_credentials</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auth_credentials</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
}</block></function>

<comment type="block">/*
 * This function adds the HTTP authentication header to
 * an outgoing HTTP request, allowing the server to
 * authenticate the EST client.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 *      uri:        pointer to a buffer that holds the uri to be used in the header
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>est_client_add_auth_hdr</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>digest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>client_random</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>both</name><index>[<expr><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* both UID and PWD + ":" + /0 */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>both_b64</name><index>[<expr><literal type="number">2</literal><operator>*</operator><literal type="number">2</literal><operator>*</operator><name>MAX_UIDPWD</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>both_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_HTTP_AUTH_HDR</name></type> <name>auth_credentials</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_HTTP_AUTH_CRED_RC</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>token_b64</name><index>[<expr><name>MAX_AUTH_TOKEN_LEN</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>user</name><index>[<expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>pwd</name><index>[<expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>enc_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>token_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>both_b64</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><literal type="number">2</literal><operator>*</operator><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <name>EST_HTTP_REQ_TOTAL_LEN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Authentication header took up the maximum amount in buffer (%d)"</literal></expr></argument>,
                     <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <switch>switch <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name></expr>)</condition> <block>{
    <case>case <expr><name>AUTH_BASIC</name></expr>:</case>
        <comment type="block">/*
         * make sure we have both parts of the credentials to send.  If we do,
         * then we're operating in the original mode where the app layer
         * provides them up front before they're needed.  If not, then we can
         * now go ask for them from the app layer.
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>est_client_retrieve_credentials</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * regardless of what comes back, build the string containing both
             */</comment>            
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * Use what was given during configuration through est_client_set_auth
             */</comment>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>,
                     <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>password</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        
        <comment type="block">/*
         * base64 encode the combined string and build the HTTP auth header
         */</comment>
        <expr_stmt><expr><name>both_len</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>both</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>enc_len</name> <operator>=</operator> <call><name>est_base64_encode</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>both</name></expr></argument>, <argument><expr><name>both_len</name></expr></argument>, <argument><expr><name>both_b64</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><literal type="number">2</literal><operator>*</operator><name>MAX_UIDPWD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>enc_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to encode basic auth value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>    
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>,
                 <argument><expr><literal type="string">"Authorization: Basic %s\r\n"</literal></expr></argument>, <argument><expr><name>both_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AUTH_DIGEST</name></expr>:</case>

        <comment type="block">/* Generate a client nonce */</comment>
        <if>if <condition>(<expr><operator>!</operator><call><name>RAND_bytes</name><argument_list>(<argument><expr><name>client_random</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"RNG failure while generating nonce"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Force hdr to a null string */</comment>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        
        <expr_stmt><expr><call><name>est_hex_to_str</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>c_nonce</name></name></expr></argument>, <argument><expr><name>client_random</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check to see if the application layer has provided username and password
         * up front during configuration.  If it has not, go retrieve them now, otherwise,
         * copy them into the local buffers to get them ready
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>est_client_retrieve_credentials</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid User ID provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>password</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid User password provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
        
        <expr_stmt><expr><name>digest</name> <operator>=</operator> <call><name>est_client_generate_auth_digest</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>digest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Error while generating digest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Force hdr to a null string */</comment>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>c_nonce</name></name></expr></argument>, <argument><expr><name>MAX_NONCE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
            
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>,
                 <argument><expr><literal type="string">"Authorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", cnonce=\"%s\", nc=00000001, qop=\"auth\", response=\"%s\"\r\n"</literal></expr></argument>,
                <argument><expr><name>user</name></expr></argument>,
                <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>,
                <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>s_nonce</name></name></expr></argument>,
                <argument><expr><name>uri</name></expr></argument>,
                <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>c_nonce</name></name></expr></argument>,
                <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>EST_MAX_MD5_DIGEST_STR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>c_nonce</name></name></expr></argument>, <argument><expr><name>MAX_NONCE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AUTH_TOKEN</name></expr>:</case>
        
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Server requested Token based authentication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auth_credentials</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>auth_credentials</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_credentials_cb</name></name></expr>)</condition><then> <block>{    
            <expr_stmt><expr><name><name>auth_credentials</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>AUTH_TOKEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>ctx</name><operator>-&gt;</operator><name>auth_credentials_cb</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>auth_credentials</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>EST_HTTP_AUTH_CRED_NOT_AVAILABLE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Attempt to obtain token from application failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/*
         * Did we get the credentials we expected?  If not, point to a NULL string
         * to generate the header
         */</comment>
        <if>if <condition>(<expr><name><name>auth_credentials</name><operator>.</operator><name>auth_token</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Requested token credentials, but application did not provide any."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>token</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt> 
        }</block></then> <else>else <block>{

            <comment type="block">/*
             * Make sure the token we were given is not too long.
             * If it is, force it to NULL to cause the auth failure at
             * the server just as if no credentials were provided
             */</comment>
            <if>if <condition>(<expr><name>MAX_AUTH_TOKEN_LEN</name> <operator>&lt;</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>auth_credentials</name><operator>.</operator><name>auth_token</name></name></expr></argument>, <argument><expr><name>MAX_AUTH_TOKEN_LEN</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Token provided is larger than the max of %d"</literal></expr></argument>,
                            <argument><expr><name>MAX_AUTH_TOKEN_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>token</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>token</name> <operator>=</operator> <name><name>auth_credentials</name><operator>.</operator><name>auth_token</name></name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>

        <comment type="block">/*
         * base64 encode the combined string and build the HTTP auth header
         */</comment>
        <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>token_b64</name></expr></argument>, <argument><expr><name>MAX_AUTH_TOKEN_LEN</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>token_len</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>MAX_AUTH_TOKEN_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>enc_len</name> <operator>=</operator> <call><name>est_base64_encode</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>token</name></expr></argument>, <argument><expr><name>token_len</name></expr></argument>,
                                    <argument><expr><name>token_b64</name></expr></argument>, <argument><expr><name>MAX_AUTH_TOKEN_LEN</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><name>enc_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to encode bearer token auth value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>    
        
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>,
                 <argument><expr><literal type="string">"Authorization: Bearer %s\r\n"</literal></expr></argument>, <argument><expr><name>token_b64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>cleanse_auth_credentials</name><argument_list>(<argument><expr><operator>&amp;</operator><name>auth_credentials</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"No HTTP auth mode set, sending anonymous request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    }</block></switch>
}</block></function>


<comment type="block">/*
 * This function is used to build the HTTP header for
 * the CAcerts request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_build_cacerts_header</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>, <argument><expr><literal type="string">"GET %s%s%s/%s HTTP/1.1\r\n"</literal>
            <literal type="string">"User-Agent: %s\r\n"</literal>
            <literal type="string">"Connection: close\r\n"</literal>
            <literal type="string">"Host: %s:%d\r\n"</literal>
            <literal type="string">"Accept: */*\r\n"</literal></expr></argument>,
            <argument><expr><name>EST_PATH_PREFIX</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><literal type="string">"/"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><name>EST_GET_CACERTS</name></expr></argument>, 
            <argument><expr><name>EST_HTTP_HDR_EST_CLIENT</name></expr></argument>,
            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_port_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <name>EST_HTTP_REQ_TOTAL_LEN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"CA Certs header took up the maximum amount in buffer (%d)"</literal></expr></argument>,
                     <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <return>return <expr><operator>(</operator><name>hdr_len</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is used to build the HTTP header for
 * the CSR attributes request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_build_csr_header</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>,<argument><expr><literal type="string">"GET %s%s%s/%s HTTP/1.1\r\n"</literal>
            <literal type="string">"User-Agent: %s\r\n"</literal>
            <literal type="string">"Connection: close\r\n"</literal>
            <literal type="string">"Host: %s:%d\r\n"</literal>
            <literal type="string">"Accept: */*\r\n"</literal></expr></argument>,
            <argument><expr><name>EST_PATH_PREFIX</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><literal type="string">"/"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><name>EST_GET_CSRATTRS</name></expr></argument>,
            <argument><expr><name>EST_HTTP_HDR_EST_CLIENT</name></expr></argument>,
            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_port_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_add_auth_hdr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_SIMPLE_ENROLL_URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <name>EST_HTTP_REQ_TOTAL_LEN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"CSR attributes request header took up the maximum amount in buffer (%d)"</literal></expr></argument>,
                     <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>hdr_len</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function does the work for the CSR attributes request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_send_csrattrs_request</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>,
					     <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>csrattrs</name></decl></parameter>, 
					     <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>csrattrs_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>http_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>read_size</name></decl>, <decl><type ref="prev"/><name>write_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>csr_attrs_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/* assume defeat */</comment>
    <expr_stmt><expr><operator>*</operator><name>csrattrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>csrattrs_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/*
     * Build the HTTP request
     * - allocate buffer: header, no data, terminating characters
     * - build the header
     * - no data
     * - terminate it
     */</comment>    
    <expr_stmt><expr><name>http_data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>http_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory for http_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <call><name>est_client_build_csr_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"CSR attributes HTTP header could not be built correctly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_CANNOT_BUILD_HEADER</name><operator>)</operator></expr>;</return>
    }</block></then></if>    

    <comment type="block">/*
     * terminate the HTTP header
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * no data is being sent so go ahead and terminate the HTTP request
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>


    <comment type="block">/*
     * Send the request to the server and wait for a response
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>last_http_status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>write_size</name> <operator>=</operator> <call><name>SSL_write</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>write_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"TLS write error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_SSL_WRITE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"TLS wrote %d bytes, attempted %d bytes\n"</literal></expr></argument>,
                     <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
         * Try to get the response from the server
         */</comment>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_get_response</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>EST_OP_CSRATTRS</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>csr_attrs_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>rv</name></expr>)</condition> <block>{
        <case>case <expr><name>EST_ERR_NONE</name></expr>:</case>
	    <if>if <condition>(<expr><name>csr_attrs_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><operator>*</operator><name>csrattrs</name> <operator>=</operator> <name>csr_attrs_buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>csrattrs_len</name> <operator>=</operator> <name>read_size</name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        <case>case <expr><name>EST_ERR_AUTH_FAIL</name></expr>:</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST request failed: %d (%s)"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>csr_attrs_buf</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>csr_attrs_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        }</block></switch>
    }</block></else></if>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is used to build the HTTP header for
 * the Simple Enroll flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 *      pkcs10_len: length of the buffer pointed to by hdr 
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_build_enroll_header</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pkcs10_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>, <argument><expr><literal type="string">"POST %s%s%s/%s HTTP/1.1\r\n"</literal>
            <literal type="string">"User-Agent: %s\r\n"</literal>
            <literal type="string">"Connection: close\r\n"</literal>
            <literal type="string">"Host: %s:%d\r\n"</literal>
            <literal type="string">"Accept: */*\r\n"</literal>
            <literal type="string">"Content-Type: application/pkcs10\r\n"</literal>
            <literal type="string">"Content-Length: %d\r\n"</literal></expr></argument>,
            <argument><expr><name>EST_PATH_PREFIX</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><literal type="string">"/"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><name>EST_SIMPLE_ENROLL</name></expr></argument>, 
            <argument><expr><name>EST_HTTP_HDR_EST_CLIENT</name></expr></argument>,
            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_port_num</name></name></expr></argument>, <argument><expr><name>pkcs10_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_add_auth_hdr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_SIMPLE_ENROLL_URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <name>EST_HTTP_REQ_TOTAL_LEN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Client enroll request header took up the maximum amount in buffer (%d)"</literal></expr></argument>,
                     <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <return>return <expr><operator>(</operator><name>hdr_len</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is used to build the HTTP header for
 * the Simple ReEnroll flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 *      pkcs10_len: length of the buffer pointed to by hdr 
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_build_reenroll_header</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pkcs10_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>, <argument><expr><literal type="string">"POST %s%s%s/%s HTTP/1.1\r\n"</literal>
            <literal type="string">"User-Agent: %s\r\n"</literal>
            <literal type="string">"Connection: close\r\n"</literal>
            <literal type="string">"Host: %s:%d\r\n"</literal>
            <literal type="string">"Accept: */*\r\n"</literal>
            <literal type="string">"Content-Type: application/pkcs10\r\n"</literal>
            <literal type="string">"Content-Length: %d\r\n"</literal></expr></argument>,
            <argument><expr><name>EST_PATH_PREFIX</name></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><literal type="string">"/"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr>?</condition><then><expr><name><name>ctx</name><operator>-&gt;</operator><name>uri_path_segment</name></name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><name>EST_SIMPLE_REENROLL</name></expr></argument>, 
            <argument><expr><name>EST_HTTP_HDR_EST_CLIENT</name></expr></argument>,
            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_port_num</name></name></expr></argument>, <argument><expr><name>pkcs10_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_add_auth_hdr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_SIMPLE_ENROLL_URI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <name>EST_HTTP_REQ_TOTAL_LEN</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Client reenroll request header took up the maximum amount in buffer (%d)"</literal></expr></argument>,
                     <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>hdr_len</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function sends the HTTP request for a Simple Enroll
 * The CSR (pkcs10) is already built at this point.  This
 * function simply creates the HTTP header and body and puts
 * it on the wire.  It then waits for a response from the
 * server and copies the response to a buffer provided by
 * the caller
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 *	bptr:	    pointer containing PKCS10 CSR
 *	pkcs7:	    pointer that will receive the pkcs7 response
 *	pkcs7_len:  length of pkcs7 response
 *	reenroll:   Set to 1 to do a reenroll instead of an enroll
 *
 */</comment>
<function><type><name>int</name></type> <name>est_client_send_enroll_request</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>BUF_MEM</name> <modifier>*</modifier></type><name>bptr</name></decl></parameter>,
                                    <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pkcs7</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>,
				    <parameter><decl><type><name>int</name></type> <name>reenroll</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>http_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>write_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>enroll_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>enroll_buf_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Assume the enroll will fail, set return length to zero
     * to be defensive.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>pkcs7_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Build the HTTP request
     * - allocate buffer: header, data, terminating characters
     * - build the header
     * - no data
     * - terminate it
     */</comment>    
    <expr_stmt><expr><name>http_data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>http_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory for http_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>reenroll</name></expr>)</condition><then> <block>{
	<comment type="block">/* Perform a /simpleenroll */</comment>
        <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <call><name>est_client_build_enroll_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bptr</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/* Perform a /simplereenroll */</comment>
        <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <call><name>est_client_build_reenroll_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bptr</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>hdr_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Enroll HTTP header could not be built correctly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_CANNOT_BUILD_HEADER</name><operator>)</operator></expr>;</return>
    }</block></then></if>
        
    <comment type="block">/*
     * terminate the HTTP header
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>,<argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Build the HTTP body containing the pkcs10 request
     */</comment>
    <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_DATA_MAX</name></expr></argument>,
             <argument><expr><name><name>bptr</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>rsize_t</name><operator>)</operator><name><name>bptr</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <name><name>bptr</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * terminate the HTTP request
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>


    <comment type="block">/*
     * Send the request to the server and wait for a response
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>last_http_status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>write_size</name> <operator>=</operator> <call><name>SSL_write</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>write_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"TLS write error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_SSL_WRITE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"TLS wrote %d bytes, attempted %d bytes\n"</literal></expr></argument>,
                     <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Try to get the response from the server
         */</comment>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_get_response</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>EST_OP_SIMPLE_ENROLL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>enroll_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enroll_buf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>rv</name></expr>)</condition> <block>{
        <case>case <expr><name>EST_ERR_NONE</name></expr>:</case>
            <if>if <condition>(<expr><name>enroll_buf_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Enroll buf is zero bytes in length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_ZERO_LENGTH_BUF</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>, <argument><expr><name>EST_MAX_CLIENT_CERT_LEN</name></expr></argument>, <argument><expr><name>enroll_buf</name></expr></argument>, <argument><expr><name>enroll_buf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>pkcs7_len</name> <operator>=</operator> <name>enroll_buf_len</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>EST_ERR_AUTH_FAIL</name></expr>:</case>
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"HTTP auth failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST request failed: %d (%s)"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></switch>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>enroll_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>OPENSSL_cleanse</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>http_data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function does a sanity check on the X509
 * prior to attempting to convert the X509 to
 * a CSR for a reenroll operation.
 *
 * Returns an EST_ERROR code
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_check_x509</name> <parameter_list>(<parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>cert</name></decl></parameter>)</parameter_list> 
<block>{
    <comment type="block">/*
     * Make sure the cert is signed
     */</comment>
    <if>if<condition>(<expr><operator>!</operator><name><name>cert</name><operator>-&gt;</operator><name>signature</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"The certificate provided does not contain a signature."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_BAD_X509</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Make sure the signature length is not invalid 
     */</comment>
    <if>if <condition>(<expr><name><name>cert</name><operator>-&gt;</operator><name>signature</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"The certificate provided contains an invalid signature length."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_BAD_X509</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is used to clear any ChallengePassword
 * attributes in an X509 CSR.  This is used because when
 * HTTP authentication is used during the enrollment
 * process, the PoP value will change when the client
 * sends the second HTTP request that contains the HTTP
 * authorization values. Since the CSR is reused between
 * both the initial and secondary requests, we need to
 * clear the PoP value from the CSR before submitting
 * the secondary request.
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>est_client_clear_csr_pop</name> <parameter_list>(<parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>csr</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_ATTRIBUTE</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The challenge password (PoP) may be in the CSR 
     * more than once.  This should never happen, but
     * we're being defensive.
     */</comment>
    <while>while <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{
	<comment type="block">/*
	 * Look for the PoP value in the CSR 
	 */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>X509_REQ_get_attr_by_NID</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>NID_pkcs9_challengePassword</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	    <comment type="block">/* 
	     * If found, delete it
	     */</comment>
	    <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>X509_REQ_delete_attr</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><name>attr</name></expr>)</condition><then> <block>{
		<comment type="block">/*
		 * There are no docs in OpenSSL that show how
		 * to use X509_REQ_delete_attr.  Going to assume
		 * we need to free the attribute ourselves.  There
		 * do not appear to be any good examples on how
		 * to use this API.
		 */</comment>
		<expr_stmt><expr><call><name>X509_ATTRIBUTE_free</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    }</block></then></if>
	}</block></then></if>
    }</block></while>
}</block></function>


<comment type="block">/*
 * This function does the work of converting the X509_REQ* to
 * the base64 encoded DER format as specified in the EST RFC.
 * Once converted to the proper format, this routine will
 * forward the request to the server, check the response,
 * and save the cert on the local context where it can be
 * retrieved later by the application layer.
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_enroll_req</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, 
	                                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reenroll</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type>    <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name>         <modifier>*</modifier></type><name>p10out</name> <init>= <expr><name>NULL</name></expr></init></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>b64</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BUF_MEM</name>     <modifier>*</modifier></type><name>bptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>recv_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>new_cert_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>          <name>new_cert_buf_len</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Grab the PKCS10 PEM encoded data
     */</comment>
    <expr_stmt><expr><name>b64</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_f_base64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>b64</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>p10out</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>p10out</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>p10out</name> <operator>=</operator> <call><name>BIO_push</name><argument_list>(<argument><expr><name>b64</name></expr></argument>, <argument><expr><name>p10out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Encode using DER (ASN.1) 
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     * */</comment>
    <expr_stmt><expr><name><name>req</name><operator>-&gt;</operator><name>req_info</name><operator>-&gt;</operator><name>enc</name><operator>.</operator><name>modified</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>i2d_X509_REQ_bio</name><argument_list>(<argument><expr><name>p10out</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>BIO_flush</name><argument_list>(<argument><expr><name>p10out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_get_mem_ptr</name><argument_list>(<argument><expr><name>p10out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the buffer in which to place the entire response from the server
     */</comment>
    <expr_stmt><expr><name>recv_buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>EST_CA_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>recv_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to allocate buffer for server response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>new_cert_buf</name> <operator>=</operator> <name>recv_buf</name></expr>;</expr_stmt> 
    <expr_stmt><expr><name>new_cert_buf_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Send the PKCS10 as an HTTP request to the EST server
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_send_enroll_request</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>,
                                        <argument><expr><name>new_cert_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_cert_buf_len</name></expr></argument>, 
					<argument><expr><name>reenroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>rv</name></expr>)</condition> <block>{

    <case>case <expr><name>EST_ERR_NONE</name></expr>:</case>
        <comment type="block">/*
         * Make sure that even though we got a success return code, that we
         * actually received something
         */</comment>
        <if>if <condition>(<expr><name>new_cert_buf_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Buffer containing newly enrolled client certificate is zero bytes in length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_ZERO_LENGTH_BUF</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/*
         * Resize the buffer holding the retrieved client certificate and link
         * it into the ctx.  Get rid of the http hdr and any extra space on
         * the back.
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then><block>{
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>new_cert_buf_len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
            
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate newly enrolled client certificate buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_MALLOC</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name><index>[<expr><name>new_cert_buf_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name></expr></argument>, <argument><expr><name>new_cert_buf_len</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>new_cert_buf</name></expr></argument>,
                 <argument><expr><name>new_cert_buf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name> <operator>=</operator> <name>new_cert_buf_len</name></expr>;</expr_stmt>

        <comment type="block">/*
         * pass back the length of this newly enrolled cert
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>pkcs7_len</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Newly Enrolled Client certificate: %s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"length: %d"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>EST_ERR_AUTH_FAIL</name></expr>:</case>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Authorization failed. Requested auth mode = %d"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST enrollment failed, error code is %d (%s)"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                    <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    }</block></switch>

    <if>if <condition>(<expr><name>recv_buf</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>recv_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p10out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*  est_client_enroll_pkcs10() This function implements the Simple Enroll
 *  flow. It signs the CSR that was provided and then sends the CSR
 *  to the EST server and retrieves the pkcs7 response.
 *
 *  Parameters:
 *    ctx    EST context
 *    ssl    SSL context being used for this EST session
 *    csr    Pointer to X509_REQ object containing the PKCS10 CSR
 *    pkcs7_len  pointer to an integer in which the length of the recieved
 *               pkcs7 response is placed.
 *    priv_key Pointer to the private key used to sign the CSR.
 *    reenroll Set to 1 to do a reenroll instead of an enroll
 *
 *  Returns EST_ERROR  
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_enroll_pkcs10</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>csr</name></decl></parameter>,
                                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>priv_key</name></decl></parameter>,
                                           <parameter><decl><type><name>int</name></type> <name>reenroll</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type>    <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>tls_uid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>          <name>ossl_rv</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Make sure the PoP is removed from the CSR before we proceed
     */</comment>
    <expr_stmt><expr><call><name>est_client_clear_csr_pop</name><argument_list>(<argument><expr><name>csr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the PoP value from the TLS session and embed this into
     * the CSR if required.
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>csr_pop_required</name></name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client_force_pop</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Client will include challengePassword in CSR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tls_uid</name> <operator>=</operator> <call><name>est_get_tls_uid</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>tls_uid</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>ossl_rv</name> <operator>=</operator> <call><name>X509_REQ_add1_attr_by_NID</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>NID_pkcs9_challengePassword</name></expr></argument>,
                                                <argument><expr><name>MBSTRING_ASC</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>tls_uid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tls_uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if>if <condition>(<expr><operator>!</operator><name>ossl_rv</name></expr>)</condition><then> <block>{
	        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set X509 challengePassword attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>EST_ERR_X509_ATTR</name><operator>)</operator></expr>;</return>
	    }</block></then></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to obtain the TLS UID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><operator>(</operator><name>EST_ERR_AUTH_FAIL_TLSUID</name><operator>)</operator></expr>;</return>
	}</block></else></if>
    }</block></then></if>

    <comment type="block">/*
     * Sign the CSR
     */</comment>
    <expr_stmt><expr><name>ossl_rv</name> <operator>=</operator> <call><name>est_client_X509_REQ_sign</name><argument_list>(<argument><expr><name>csr</name></expr></argument>, <argument><expr><name>priv_key</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>ossl_rv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to sign X509 cert request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_X509_SIGN</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_req</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>reenroll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*  est_client_enroll_cn() This function implements the Simple Enroll
    flow. It uses the private key to generate a CSR (pkcs10) request.  It
    then sends the request to the EST server and retrieves the pkcs7
    response.  The user of this function simply provides the CommonName
    value to be placed in the PKCS10 CSR.  This is a simplified interface,
    none of the other CSR attributes can be specified.

    @param ctx EST context
    @param ssl SSL context being used for this EST session
    @param cn pointer to the common name that is to be placed in the x509
    request
    @param pkcs7_len pointer to an integer in which the length of the recieved
    pkcs7 response is placed.
    @param pkey The new client public key that is to be enrolled

    @return EST_ERROR 
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_enroll_cn</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cn</name></decl></parameter>,
                                         <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>X509_REQ</name>    <modifier>*</modifier></type><name>pkcs10</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type>    <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>tls_uid</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Attempt to create the PKCS10 certificate request.
     * Get the TLS uid in case we need it during populate.
     */</comment>
    <expr_stmt><expr><name>tls_uid</name> <operator>=</operator> <call><name>est_get_tls_uid</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tls_uid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_generate_pkcs10</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr><name>tls_uid</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkcs10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tls_uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to obtain the TLS UID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_AUTH_FAIL_TLSUID</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_req</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>pkcs10</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>pkcs10</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>X509_REQ_free</name><argument_list>(<argument><expr><name>pkcs10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/* 
 * The following function was taken from cURL
 *
 * The content that was incorporated were portions of
 * - lib/hostcheck.c
 * - lib/rawstr.c
 *
 * Portable, consistent toupper (remember EBCDIC). Do not use toupper() because
 * its behavior is altered by the current locale. 
 */</comment>
<function><specifier>static</specifier> <type><name>char</name></type> <name>est_client_Curl_raw_toupper</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>in</name></decl></parameter>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>in</name></expr>)</condition> <block>{
    <case>case <expr><literal type="char">'a'</literal></expr>:</case>
        <return>return <expr><literal type="char">'A'</literal></expr>;</return>
    <case>case <expr><literal type="char">'b'</literal></expr>:</case>
        <return>return <expr><literal type="char">'B'</literal></expr>;</return>
    <case>case <expr><literal type="char">'c'</literal></expr>:</case>
        <return>return <expr><literal type="char">'C'</literal></expr>;</return>
    <case>case <expr><literal type="char">'d'</literal></expr>:</case>
        <return>return <expr><literal type="char">'D'</literal></expr>;</return>
    <case>case <expr><literal type="char">'e'</literal></expr>:</case>
        <return>return <expr><literal type="char">'E'</literal></expr>;</return>
    <case>case <expr><literal type="char">'f'</literal></expr>:</case>
        <return>return <expr><literal type="char">'F'</literal></expr>;</return>
    <case>case <expr><literal type="char">'g'</literal></expr>:</case>
        <return>return <expr><literal type="char">'G'</literal></expr>;</return>
    <case>case <expr><literal type="char">'h'</literal></expr>:</case>
        <return>return <expr><literal type="char">'H'</literal></expr>;</return>
    <case>case <expr><literal type="char">'i'</literal></expr>:</case>
        <return>return <expr><literal type="char">'I'</literal></expr>;</return>
    <case>case <expr><literal type="char">'j'</literal></expr>:</case>
        <return>return <expr><literal type="char">'J'</literal></expr>;</return>
    <case>case <expr><literal type="char">'k'</literal></expr>:</case>
        <return>return <expr><literal type="char">'K'</literal></expr>;</return>
    <case>case <expr><literal type="char">'l'</literal></expr>:</case>
        <return>return <expr><literal type="char">'L'</literal></expr>;</return>
    <case>case <expr><literal type="char">'m'</literal></expr>:</case>
        <return>return <expr><literal type="char">'M'</literal></expr>;</return>
    <case>case <expr><literal type="char">'n'</literal></expr>:</case>
        <return>return <expr><literal type="char">'N'</literal></expr>;</return>
    <case>case <expr><literal type="char">'o'</literal></expr>:</case>
        <return>return <expr><literal type="char">'O'</literal></expr>;</return>
    <case>case <expr><literal type="char">'p'</literal></expr>:</case>
        <return>return <expr><literal type="char">'P'</literal></expr>;</return>
    <case>case <expr><literal type="char">'q'</literal></expr>:</case>
        <return>return <expr><literal type="char">'Q'</literal></expr>;</return>
    <case>case <expr><literal type="char">'r'</literal></expr>:</case>
        <return>return <expr><literal type="char">'R'</literal></expr>;</return>
    <case>case <expr><literal type="char">'s'</literal></expr>:</case>
        <return>return <expr><literal type="char">'S'</literal></expr>;</return>
    <case>case <expr><literal type="char">'t'</literal></expr>:</case>
        <return>return <expr><literal type="char">'T'</literal></expr>;</return>
    <case>case <expr><literal type="char">'u'</literal></expr>:</case>
        <return>return <expr><literal type="char">'U'</literal></expr>;</return>
    <case>case <expr><literal type="char">'v'</literal></expr>:</case>
        <return>return <expr><literal type="char">'V'</literal></expr>;</return>
    <case>case <expr><literal type="char">'w'</literal></expr>:</case>
        <return>return <expr><literal type="char">'W'</literal></expr>;</return>
    <case>case <expr><literal type="char">'x'</literal></expr>:</case>
        <return>return <expr><literal type="char">'X'</literal></expr>;</return>
    <case>case <expr><literal type="char">'y'</literal></expr>:</case>
        <return>return <expr><literal type="char">'Y'</literal></expr>;</return>
    <case>case <expr><literal type="char">'z'</literal></expr>:</case>
        <return>return <expr><literal type="char">'Z'</literal></expr>;</return>
    }</block></switch>
    <return>return <expr><name>in</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * The following function was taken from cURL
 *
 * Curl_raw_equal() is for doing "raw" case insensitive strings. This is meant
 * to be locale independent and only compare strings we know are safe for
 * this.  See http://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for
 * some further explanation to why this function is necessary.
 *
 * The function is capable of comparing a-z case insensitively even for
 * non-ascii.
 */</comment>

<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_Curl_raw_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>first</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>second</name></decl></parameter>)</parameter_list>
<block>{
    <while>while<condition>(<expr><operator>*</operator><name>first</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>second</name></expr>)</condition> <block>{
	<if>if<condition>(<expr><call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <comment type="block">/* get out of the loop as soon as they don't match */</comment>
	    <break>break;</break>
	}</block></then></if>
	<expr_stmt><expr><name>first</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>second</name><operator>++</operator></expr>;</expr_stmt>
    }</block></while>
    <comment type="block">/* we do the comparison here (possibly again), just to make sure that if the
       loop above is skipped because one of the strings reached zero, we must not
       return this as a successful match */</comment>
    <return>return <expr><operator>(</operator><call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_Curl_raw_nequal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>first</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>second</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{
    <while>while<condition>(<expr><operator>*</operator><name>first</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>second</name> <operator>&amp;&amp;</operator> <name>max</name></expr>)</condition> <block>{
	<if>if<condition>(<expr><call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	    <break>break;</break>
	}</block></then></if>
	<expr_stmt><expr><name>max</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>first</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>second</name><operator>++</operator></expr>;</expr_stmt>
    }</block></while>
    <if>if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>max</name></expr>)</condition><then> <block>{
	<return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* they are equal this far */</comment>
    }</block></then></if>

    <return>return <expr><operator>(</operator><call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>est_client_Curl_raw_toupper</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * The following function was taken from cURL
 *
 * Match a hostname against a wildcard pattern.
 * E.g.
 *  "foo.host.com" matches "*.host.com".
 *
 * We use the matching rule described in RFC6125, section 6.4.3.
 * http://tools.ietf.org/html/rfc6125#section-6.4.3
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOST_NOMATCH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOST_MATCH</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_hostmatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern_label_end</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>pattern_wildcard</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>hostname_label_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wildcard_enabled</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>prefixlen</name></decl>, <decl><type ref="prev"/><name>suffixlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name>ignored</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name></type> <name>si6</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pattern_wildcard</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>pattern_wildcard</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<return>return <expr><ternary><condition><expr><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>HOST_MATCH</name></expr> </then><else>: <expr><name>HOST_NOMATCH</name></expr></else></ternary></expr>;</return>
    }</block></then></if>
    
    <comment type="block">/* detect IP address as hostname and fail the match if so */</comment>
    <if>if<condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignored</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then>
        <block type="pseudo"><return>return <expr><name>HOST_NOMATCH</name></expr>;</return></block></then>
    <elseif>else <if>if<condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>si6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then>
        <block type="pseudo"><return>return <expr><name>HOST_NOMATCH</name></expr>;</return></block></then></if></elseif></if>

    <comment type="block">/* We require at least 2 dots in pattern to avoid too wide wildcard
       match. */</comment>
    <expr_stmt><expr><name>wildcard_enabled</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pattern_label_end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>pattern_label_end</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pattern_label_end</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
	<name>pattern_wildcard</name> <operator>&gt;</operator> <name>pattern_label_end</name> <operator>||</operator>
	<call><name>est_client_Curl_raw_nequal</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><literal type="string">"xn--"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>wildcard_enabled</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>(<expr><operator>!</operator><name>wildcard_enabled</name></expr>)</condition><then> <block>{
	<return>return <expr><ternary><condition><expr><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>HOST_MATCH</name></expr> </then><else>: <expr><name>HOST_NOMATCH</name></expr></else></ternary></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>hostname_label_end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>hostname_label_end</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>pattern_label_end</name></expr></argument>, <argument><expr><name>hostname_label_end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<return>return <expr><name>HOST_NOMATCH</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* The wildcard must match at least one character, so the left-most
       label of the hostname is at least as large as the left-most label
       of the pattern. */</comment>
    <if>if<condition>(<expr><name>hostname_label_end</name> <operator>-</operator> <name>hostname</name> <operator>&lt;</operator> <name>pattern_label_end</name> <operator>-</operator> <name>pattern</name></expr>)</condition><then> <block>{
	<return>return <expr><name>HOST_NOMATCH</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <name>pattern_wildcard</name> <operator>-</operator> <name>pattern</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>suffixlen</name> <operator>=</operator> <name>pattern_label_end</name> <operator>-</operator> <operator>(</operator><name>pattern_wildcard</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><call><name>est_client_Curl_raw_nequal</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <call><name>est_client_Curl_raw_nequal</name><argument_list>(<argument><expr><name>pattern_wildcard</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>hostname_label_end</name> <operator>-</operator> <name>suffixlen</name></expr></argument>,
                                       <argument><expr><name>suffixlen</name></expr></argument>)</argument_list></call></expr> ?</condition><then>  <expr><name>HOST_MATCH</name></expr> </then><else>: <expr><name>HOST_NOMATCH</name></expr></else></ternary><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * The following function was taken from cURL for the
 * FQDN check on the server cert
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_cert_hostcheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match_pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>)</parameter_list>
<block>{
    <comment type="block">/*
     * Sanity check input 
     */</comment>
    <if>if<condition>(<expr><operator>!</operator><name>match_pattern</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>match_pattern</name> <operator>||</operator> <operator>!</operator><name>hostname</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>hostname</name></expr>)</condition><then> <block>{ 
	<return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * trival case
     */</comment>
    <if>if<condition>(<expr><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>match_pattern</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<return>return <expr><literal type="number">1</literal></expr>;</return>
    }</block></then></if>

    <if>if<condition>(<expr><call><name>est_client_hostmatch</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>,<argument><expr><name>match_pattern</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>HOST_MATCH</name></expr>)</condition><then> <block>{
	<return>return <expr><literal type="number">1</literal></expr>;</return>
    }</block></then></if>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></function>

<comment type="block">/* 
 * This function was taken from cURL and adapted to EST.
 *
 * cURL file name is ./lib/ssluse.c, function: verifyhost()
 *
 * Quote from RFC2818 section 3.1 "Server Identity"

   If a subjectAltName extension of type dNSName is present, that MUST
   be used as the identity. Otherwise, the (most specific) Common Name
   field in the Subject field of the certificate MUST be used. Although
   the use of the Common Name is existing practice, it is deprecated and
   Certification Authorities are encouraged to use the dNSName instead.

   Matching is performed using the matching rules specified by
   [RFC2459].  If more than one identity of a given type is present in
   the certificate (e.g., more than one dNSName name, a match in any one
   of the set is considered acceptable.) Names may contain the wildcard
   character * which is considered to match any single domain name
   component or component fragment. E.g., *.a.com matches foo.a.com but
   not bar.foo.a.com. f*.com matches foo.com but not bar.com.

   In some cases, the URI is specified as an IP address rather than a
   hostname. In this case, the iPAddress subjectAltName must be present
   in the certificate and must exactly match the IP in the URI.

 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_verifyhost</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>server_cert</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>matched</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* -1 is no alternative match yet, 1 means match and 0
                             means mismatch */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>addrlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>GENERAL_NAME</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>altnames</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>addr_v6</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name>addr_v4</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addr_is_v4</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addr_is_v6</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>res</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errno_t</name></type> <name>safec_rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numalts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>GENERAL_NAME</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>altptr</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>size_t</name></type> <name>altlen</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nulstr</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>peer_CN</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>X509_NAME</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>ASN1_STRING</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Attempt to resolve host name to v4 address 
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr_v4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>addr_is_v4</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>addrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>in_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<comment type="block">/*
	 * Try to see if hostname resolves to v6 address
	 */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr_v6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>addr_is_v6</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	    <expr_stmt><expr><name>addrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>in6_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	}</block></then></if>
    }</block></else></if>

    <comment type="block">/* get a "list" of alternative names */</comment>
    <expr_stmt><expr><name>altnames</name> <operator>=</operator> <call><name>X509_get_ext_d2i</name><argument_list>(<argument><expr><name>server_cert</name></expr></argument>, <argument><expr><name>NID_subject_alt_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>altnames</name></expr>)</condition><then> <block>{
        <comment type="block">/* get amount of alternatives, RFC2459 claims there MUST be at least
           one, but we don't depend on it... */</comment>
        <expr_stmt><expr><name>numalts</name> <operator>=</operator> <call><name>sk_GENERAL_NAME_num</name><argument_list>(<argument><expr><name>altnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Found %d SubjectAlternateNames"</literal></expr></argument>, <argument><expr><name>numalts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* loop through all alternatives while none has matched */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>numalts</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>matched</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
            <comment type="block">/* get a handle to alternative name number i */</comment>
            <expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>sk_GENERAL_NAME_value</name><argument_list>(<argument><expr><name>altnames</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* get data and length */</comment>
            <expr_stmt><expr><name>altptr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>ASN1_STRING_data</name><argument_list>(<argument><expr><name><name>check</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>ia5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>altlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>ASN1_STRING_length</name><argument_list>(<argument><expr><name><name>check</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>ia5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><name><name>check</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{
            <case>case <expr><name>GEN_DNS</name></expr>:</case> <comment type="block">/* name/pattern comparison */</comment>
                <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Checking FQDN against SAN %s"</literal></expr></argument>, <argument><expr><name>altptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* The OpenSSL man page explicitly says: "In general it cannot be
                   assumed that the data returned by ASN1_STRING_data() is null
                   terminated or does not contain embedded nulls." But also that
                   "The actual format of the data will depend on the actual string
                   type itself: for example for and IA5String the data will be ASCII"

                   Gisle researched the OpenSSL sources:
                   "I checked the 0.9.6 and 0.9.8 sources before my patch and
                   it always 0-terminates an IA5String."
                 */</comment>
                <if>if <condition>(<expr><operator>(</operator><name>altlen</name> <operator>==</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>altptr</name></expr></argument>, <argument><expr><name>EST_MAX_SERVERNAME_LEN</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
                    <comment type="block">/* if this isn't true, there was an embedded zero in the name
                       string and we cannot match it. */</comment>
                    <call><name>est_client_cert_hostcheck</name><argument_list>(<argument><expr><name>altptr</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>matched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                }</block></then> <else>else<block>{
                    <expr_stmt><expr><name>matched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>

            <case>case <expr><name>GEN_IPADD</name></expr>:</case> <comment type="block">/* IP address comparison */</comment>
                <comment type="block">/* compare alternative IP address if the data chunk is the same size
                   our server IP address is */</comment>

                <comment type="block">/*
                 * For PSB compliance, use SafeC library memcmp_s
                 */</comment> 
		
                 <if>if <condition>(<expr><name>addr_is_v4</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>memcmp_s</name><argument_list>(<argument><expr><name>altptr</name></expr></argument>, <argument><expr><name>altlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr_v4</name></expr></argument>, <argument><expr><name>altlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
                    	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"memcmp_s error 0x%xO with IPv4 address\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>  
                 }</block></then> <elseif>else <if>if <condition>(<expr><name>addr_is_v6</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>memcmp_s</name><argument_list>(<argument><expr><name>altptr</name></expr></argument>, <argument><expr><name>altlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr_v6</name></expr></argument>, <argument><expr><name>altlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
                    	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"memcmp_s error 0x%xO with IPv6 address\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>  
                 }</block></then></if></elseif> <else>else <block>{
                   <comment type="block">/*
                    * Should never get here...so force matched to be 0
                    */</comment>
	           <expr_stmt><expr><name>diff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 
	 	 }</block></else></if>

                <if>if <condition>(<expr><operator>(</operator><name>addr_is_v4</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>altlen</name> <operator>==</operator> <name>addrlen</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>diff</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>matched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                }</block></then> <elseif>else <if>if <condition>(<expr><operator>(</operator><name>addr_is_v6</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>altlen</name> <operator>==</operator> <name>addrlen</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>diff</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>matched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                }</block></then></if></elseif> <else>else<block>{
                    <expr_stmt><expr><name>matched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
            }</block></switch>
        }</block></for>
        <expr_stmt><expr><call><name>GENERAL_NAMES_free</name><argument_list>(<argument><expr><name>altnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>matched</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then> <block>{
        <comment type="block">/* an alternative name matched the server hostname */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"subjectAltName: %s matched\n"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <elseif>else <if>if <condition>(<expr><name>matched</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <comment type="block">/* an alternative name field existed, but didn't match and then
           we MUST fail */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"subjectAltName does not match %s\n"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>EST_ERR_FQDN_MISMATCH</name></expr>;</expr_stmt>
    }</block></then></if></elseif><else>else  <block>{
        <comment type="block">/* we have to look to the last occurrence of a commonName in the
           distinguished one to get the most significant one. */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* The following is done because of a bug in 0.9.6b */</comment>
        <expr_stmt><expr><name>nulstr</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>peer_CN</name> <operator>=</operator> <name>nulstr</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>server_cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>name</name></expr>)</condition><then> <block>{
            <while>while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>X509_NAME_get_index_by_NID</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NID_commonName</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{
                <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>

        <comment type="block">/* we have the name entry and we will now convert this to a string
           that we can use for comparison. Doing this we support BMPstring,
           UTF8 etc. */</comment>

        <if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>X509_NAME_ENTRY_get_data</name><argument_list>(<argument><expr><call><name>X509_NAME_get_entry</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* In OpenSSL 0.9.7d and earlier, ASN1_STRING_to_UTF8 fails if the input
               is already UTF-8 encoded. We check for this case and copy the raw
               string manually to avoid the problem. This code can be made
               conditional in the future when OpenSSL has been fixed. Work-around
               brought by Alexis S. L. Carvalho. */</comment>
            <if>if <condition>(<expr><name>tmp</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>ASN1_STRING_type</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>V_ASN1_UTF8STRING</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>ASN1_STRING_length</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>peer_CN</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>peer_CN</name></expr>)</condition><then> <block>{
			    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>memcpy_s</name><argument_list>(<argument><expr><name>peer_CN</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>ASN1_STRING_data</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"memcpy_s error 0x%xO with ASN1 string\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                            <expr_stmt><expr><name><name>peer_CN</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                }</block></then><else>else  <block>{ <comment type="block">/* not a UTF8 name */</comment>
                    <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>ASN1_STRING_to_UTF8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peer_CN</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name>peer_CN</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strnlen_s</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>peer_CN</name></expr></argument>, <argument><expr><name>EST_MAX_SERVERNAME_LEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>j</name><operator>)</operator></expr>)</condition><then> <block>{
                    <comment type="block">/* there was a terminating zero before the end of string, this
                       cannot match and we return failure! */</comment>
                    <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"SSL: illegal cert name field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>EST_ERR_FQDN_MISMATCH</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><name>peer_CN</name> <operator>==</operator> <name>nulstr</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>peer_CN</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else<block>{
            <comment type="block">/* convert peer_CN from UTF8 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="line">// UTF8 currently not supported in the first release of libest</comment>
            CURLcode rc = Curl_convert_from_utf8(data, peer_CN, strlen(peer_CN));
            <comment type="block">/* Curl_convert_from_utf8 calls failf if unsuccessful */</comment>
            if (rc) {
                free(peer_CN);
                return EST_ERR_FQDN_MISMATCH;
            }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>

        <if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <comment type="block">/* error already detected, pass through */</comment>
            <empty_stmt>;</empty_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><operator>!</operator><name>peer_CN</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"SSL: unable to obtain common name from peer certificate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>EST_ERR_FQDN_MISMATCH</name></expr>;</expr_stmt>
        }</block></then></if></elseif><elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>est_client_cert_hostcheck</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>peer_CN</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"SSL: FQDN hostname mismatch in server certificate, '%s' does not match "</literal>
                      <literal type="string">"target host name '%s'"</literal></expr></argument>, <argument><expr><name>peer_CN</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <name>EST_ERR_FQDN_MISMATCH</name></expr>;</expr_stmt>
        }</block></then></if></elseif><else>else  <block>{
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"common name: %s (matched)"</literal></expr></argument>, <argument><expr><name>peer_CN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>peer_CN</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>peer_CN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
    <return>return <expr><name>res</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * This routine checks the FQDN in the server certificate
 * against the configure server name used to establish
 * the TCP connection with the EST server.
 * This is required per section 3.6 in the EST spec.
 * Note, we only do the FQDN check as defined in RFC 6125.
 * We do not look for the id-kp-cmcRA extended key usage
 * extension in the server cert.  While this is more 
 * restrictive by not allowing FQDN mismatches when the
 * id-kp-cmcRA is present, we currently have no way to
 * determine when we're using the explicit trust anchor to
 * allow this additional flexibility.
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_check_fqdn</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>cert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>er</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cert</name> <operator>=</operator> <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>cert</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>er</name> <operator>=</operator> <call><name>est_client_verifyhost</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>er</name><operator>)</operator></expr>;</return>
    }</block></then> <elseif>else <if>if <condition>(<expr><operator>!</operator><name>cert</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>enable_srp</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"No peer certificate, skipping FQDN check since SRP is enabled."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EST_ERR_NONE</name></expr>;</return>
    }</block></then></if></elseif> <else>else <block>{
	<expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Unable to perform FQDN check, no peer certificate."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EST_ERR_FQDN_MISMATCH</name></expr>;</return>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * This function will open a TCP socket and establish a TLS session
 * with the EST server.  This should be called after est_client_init().
 *
 * Parameters:
 *	ctx:	    Pointer to EST context for client session
 *      ssl:        pointer to an SSL context structure to return the
 *                  SSL context created,
 * Reurns:
 *	EST_ERR_NONE if success
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_connect</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier><modifier>*</modifier></type><name>ssl</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>BIO</name>             <modifier>*</modifier></type><name>tcp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_CTX</name>         <modifier>*</modifier></type><name>s_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type>       <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type>             <name>sock</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>SOCKET</name></type>          <name>sock</name> <init>= <expr><name>INVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>             <name>rc</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type>             <name>oval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>ssl_connect_ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tcw_err_t</name></type>       <name>tcw_err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tcw_opts_t</name></type>      <name>tcw_opts</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_NO_CTX</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>s_ctx</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Establish the connection through a proxy (if applicable)
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>use_proxy</name></name></expr>)</condition><then> <block>{

        <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_proto</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>proxy_proto</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_host</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>proxy_server</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_port</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>proxy_port</name></name></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_username</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>proxy_password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
                <name><name>ctx</name><operator>-&gt;</operator><name>proxy_auth</name></name> <operator>!=</operator> <name>EST_CLIENT_PROXY_AUTH_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_username</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>proxy_username</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_password</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>proxy_password</name></name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_auth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* initialize */</comment>
            <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_auth</name></name> <operator>&amp;</operator> <name>EST_CLIENT_PROXY_AUTH_BASIC</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_auth</name></name> <operator>|=</operator> <name>EST_CLIENT_PROXY_AUTH_BASIC</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_auth</name></name> <operator>&amp;</operator> <name>EST_CLIENT_PROXY_AUTH_NTLM</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_auth</name></name> <operator>|=</operator> <name>EST_CLIENT_PROXY_AUTH_NTLM</name></expr>;</expr_stmt>
            }</block></then></if>
            
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>tcw_opts</name><operator>.</operator><name>proxy_proto</name></name> <operator>=</operator> <name>EST_CLIENT_PROXY_NONE</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>tcw_err</name> <operator>=</operator> <call><name>tcw_connect</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcw_opts</name></expr></argument>,
                          <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_port_num</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tcw_err</name> <operator>==</operator> <name>TCW_ERR_RESOLV</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to lookup hostname %s."</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_IP_GETADDR</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>tcw_err</name> <operator>!=</operator> <name>TCW_OK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to connect to EST server at %s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_IP_CONNECT</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Enable TCP keep-alive
     */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>setsockopt</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>,<argument><expr><name>SO_KEEPALIVE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>oval</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>oval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>tcw_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sock</name> <operator>=</operator> <name>SOCK_INVALID</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to connect to EST server at address %s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_IP_CONNECT</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <comment type="block">/*
     * Pass the socket to the BIO interface, which OpenSSL uses
     * to create the TLS session.
     */</comment>
    <expr_stmt><expr><name>tcp</name> <operator>=</operator> <call><name>BIO_new_socket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>BIO_NOCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tcp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Error creating IP socket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tcw_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sock</name> <operator>=</operator> <name>SOCK_INVALID</name></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_IP_CONNECT</name><operator>)</operator></expr>;</return>
    }</block></then></if>        
    
    <if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>ssl</name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><name>s_ctx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Error creating TLS context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>tcp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>tcw_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sock</name> <operator>=</operator> <name>SOCK_INVALID</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_SSL_NEW</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Need to set the EST ctx into the exdata of the SSL session context so
     * that it can be retrieved on a per session basis.
     */</comment>
    <expr_stmt><expr><call><name>SSL_set_ex_data</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>, <argument><expr><name>e_ctx_ssl_exdata_index</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set the EST server name in the SSL context so that it'll be sent in the
     * in the server name extension in the client hello.
     */</comment>
    <expr_stmt><expr><call><name>SSL_set_tlsext_host_name</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SSL_set_bio</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>, <argument><expr><name>tcp</name></expr></argument>, <argument><expr><name>tcp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>sess</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>SSL_set_session</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>sess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><operator>(</operator><name>ssl_connect_ret</name> <operator>=</operator> <call><name>SSL_connect</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Error connecting TLS context. %d"</literal></expr></argument>, <argument><expr><call><name>SSL_get_error</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>, <argument><expr><name>ssl_connect_ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tcw_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sock</name> <operator>=</operator> <name>SOCK_INVALID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_SSL_CONNECT</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock_connected</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * Now that we've established a TLS session with the EST server,
     * we need to verify that the FQDN in the server cert matches
     * the server name we used to establish the connection.
     * This is from section 3.6 in the EST spec.
     */</comment>
    <if>if <condition>(<expr><operator>(</operator><name>EST_ERR_NONE</name> <operator>==</operator> <name>rv</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>est_client_check_fqdn</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<comment type="block">/*
	 * The host name did not match, shut down the tunnel and bail
	 */</comment>
	<expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"EST server name did not match FQDN in server certificate."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_FQDN_MISMATCH</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function will close the TLS session and the underlying socket.
 *
 * Parameters:
 *	ssl:	    Pointer to SSL context that has been set up for this connection
 *                  to the EST server.
 */</comment>
<function><type><name>void</name></type> <name>est_client_disconnect</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier><modifier>*</modifier></type><name>ssl</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSL_SESSION</name> <modifier>*</modifier></type><name>new_sess</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>ssl</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * if first disconnect, get the session id to cache it away to use for
     * session resumption.
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>sess</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sess</name></name> <operator>=</operator> <call><name>SSL_get1_session</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <comment type="block">/*
         * if not the first time to disconnect, see if the session id changed.
         * If it did, officially re-obtain it with a get1 call and cache it away
         */</comment>
        <expr_stmt><expr><name>new_sess</name> <operator>=</operator> <call><name>SSL_get0_session</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_sess</name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>sess</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sess</name></name> <operator>=</operator> <call><name>SSL_get1_session</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
    
    <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><operator>*</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ssl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock_connected</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>tcw_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>tcw_sock_connected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


<comment type="block">/*
 * This function does the work for the CACerts request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 *      ca_certs_len: pointer to the unsigned int that will hold the length of the
 *                    returned CA certs.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_client_send_cacerts_request</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>,
                                            <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ca_certs_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>http_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>hdr_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>write_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ca_certs_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>ca_certs_buf_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Build the HTTP request
     * - allocate buffer: header, no data, terminating characters
     * - build the header
     * - no data
     * - terminate it
     */</comment>
    <expr_stmt><expr><name>http_data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>http_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory for http_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <call><name>est_client_build_cacerts_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * terminate the HTTP header
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>, <argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>,<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * no data is being sent so go ahead and terminate the HTTP request
     */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>http_data</name> <operator>+</operator> <name>hdr_len</name></expr></argument>,<argument><expr><name>EST_HTTP_REQ_TOTAL_LEN</name><operator>-</operator><name>hdr_len</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Send the request to the server and wait for a response
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>last_http_status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>write_size</name> <operator>=</operator> <call><name>SSL_write</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>http_data</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>write_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"TLS write error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_SSL_WRITE</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"TLS wrote %d bytes, attempted %d bytes\n"</literal></expr></argument>,
                     <argument><expr><name>write_size</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Try to get the response from the server
         */</comment>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_get_response</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>EST_OP_CACERTS</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>ca_certs_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ca_certs_buf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>rv</name></expr>)</condition> <block>{
        <case>case <expr><name>EST_ERR_NONE</name></expr>:</case>
            
            <comment type="block">/*
             * Make sure that even though we got a success return code, that we
             * actually received something
             */</comment>
            <if>if <condition>(<expr><name>ca_certs_buf_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retrieved CA Cert buf is zero bytes in length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_ZERO_LENGTH_BUF</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name>ca_certs_buf_len</name><operator>+</operator><literal type="number">1</literal> <operator>&gt;</operator> <name>EST_CA_MAX</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retrieved CA Cert buf is larger than maximum allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_BUF_EXCEEDS_MAX_LEN</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            
            <comment type="block">/*
             * Resize the buffer holding the retrieved CA cert and link it
             * into the ctx.  Get rid of the http hdr and any extra space on
             * the back.
             */</comment>
            <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then><block>{
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>ca_certs_buf_len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
                
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate CA certs buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_MALLOC</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            
            <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name><index>[<expr><name>ca_certs_buf_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name></expr></argument>, <argument><expr><name>ca_certs_buf_len</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ca_certs_buf</name></expr></argument>,
                   <argument><expr><name>ca_certs_buf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name> <operator>=</operator> <name>ca_certs_buf_len</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Verify the returned CA cert chain
             */</comment>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>verify_cacert_resp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Returned CACerts chain was invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>ca_certs_len</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            
            <comment type="block">/*
             * pass back the length of the retrieved CA cert buffer
             */</comment>
            <expr_stmt><expr><operator>*</operator><name>ca_certs_len</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"CACerts buf: %s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"CACerts length: %d"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>EST_ERR_AUTH_FAIL</name></expr>:</case>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP auth failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>EST_ERR_CA_ENROLL_RETRY</name></expr>:</case>
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP request failed with a RETRY AFTER resp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST request failed: %d (%s)"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></switch>
    }</block></else></if>
    
    <if>if <condition>(<expr><name>http_data</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>http_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>ca_certs_buf</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ca_certs_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>


<function><type><name>EST_ERROR</name></type> <name>est_client_set_uid_pw</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>)</parameter_list> 
<block>{
    <comment type="block">/*
     * If there's a userid, there must be a password, and vice versa.
     * The userid can still be an empty string ( "" ), but it cannot
     * be NULL if there's a password. (3.2.3).
     */</comment>
    <if>if <condition>(<expr><name>uid</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"User ID provided with no password"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
    }</block></then></if>        
    <if>if <condition>(<expr><name>uid</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pwd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Password provided with no user ID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * if uid/pwd set, then we're doing basic/digest authentication
     */</comment>
    <if>if <condition>(<expr><name>uid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid User ID provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>   
        }</block></then></if>
        <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>password</name></name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid Password provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * Application API
 */</comment>

<comment type="block">/*! @brief est_client_enroll_csr() performs the simple enroll request with the EST
     server using a PKCS10 CSR provided by the application layer.
 
    @param ctx Pointer to an EST context
    @param csr Pointer to the PKCS10 CSR data, which is defined as an OpenSSL
    X509_REQ.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    buffer.
    @param priv_key Pointer to the private key that will be used to sign the CSR,
    or NULL
 
    @return EST_ERROR

    est_client_enroll_csr() connects to the EST server, establishes a SSL/TLS
    connection to the EST server that was configured with the previous call to
    est_client_set_server(), and sends the simple enroll request.  The application
    layer must provide the PKCS10 CSR that will be enrolled.
    If the priv_key argument given is not NULL, then the CSR should not
    need to be signed by the private key. However, the CSR must contain everything 
    else that is required, including the public key. If the private key is provided
    with an already signed CSR, then the EST library will re-sign the CSR. 
    
    The enroll response is stored in the EST context and the length 
    is passed back to the application through the pkcs7_len paramter of this 
    function.  The application can then allocate a correctly sized buffer and 
    call est_client_copy_enrolled_cert() to retrieve the new client certificate 
    from the context.

    Unless the CSR is not already signed, which is indicated by a NULL priv_key,
    the application must provide a pointer to the private key used to sign the CSR.
    This is required by the EST library in the event that the EST server has
    requested the proof-of-possession value be included in the CSR.  The EST library
    will automatically include the proof-of-posession value and sign the CSR
    again.

    Be aware that the X509_REQ data passed to this function must be valid.  Passing
    corrupted CSR data may result in a system crash.  libEST utilizes the OpenSSL
    ASN decoding logic to read the X509_REQ data.  OpenSSL does not perform
    safety checks on the X509_REQ data when parsing.  If your application is
    reading externally generated PEM or DER encoded CSR data, then please use
    the est_read_x509_request() helper function to convert the PEM/DER CSR into a
    valid X509_REQ pointer.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_enroll_csr</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>csr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>priv_key</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>csr</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CSR</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Establish TLS session with the EST server
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <goto>goto <name>err</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>priv_key</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_pkcs10</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>priv_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_req</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>EST_ERR_AUTH_FAIL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>||</operator>
         <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_BASIC</name>  <operator>||</operator>
         <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_TOKEN</name><operator>)</operator></expr>)</condition><then> <block>{

        <comment type="block">/*
         * HTTPS digest mode requires the use of MD5.  Make sure we're not
         * in FIPS mode and can use MD5
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>FIPS_mode</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><then><block>{
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP digest auth not allowed while in FIPS mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_BAD_MODE</name></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        }</block></then></if>
        
        <comment type="block">/* Try one more time if we're doing Digest auth */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Auth failed, trying again with digest/basic parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Connection failed on second attempt with basic/digest parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        }</block></then></if>
	<if>if <condition>(<expr><name>priv_key</name></expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_pkcs10</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>priv_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
	  <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_req</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>csr</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
        <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Enroll failed on second attempt during basic/digest authentication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<label><name>err</name>:</label>    
    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>

}</block></function>


<comment type="block">/*! @brief est_client_enroll() performs the simple enroll request with the EST
     server
 
    @param ctx Pointer to an EST context
    @param cn Pointer to the Common Name value to be used in the enrollment
    request.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    buffer.
    @param new_public_key Pointer an EVP_PKEY structure that holds the
    client's key pair to be used in the simple enroll request .  The public
    key is included in the Certificate Signing Request (CSR) sent to the CA
    Server, and the private key is used to sign the request.
 
    @return EST_ERROR

    est_client_enroll() connects to the EST server, builds a simple enroll
    request using the Common Name passed in cn, establishes a SSL/TLS
    connection to the EST server that was configured with the previous call to
    est_client_set_server(), and sends the simple enroll request.  The
    response is stored in the EST context and the length is passed back to the
    application through the pkcs7_len parameter of this function.  The
    application can then allocate a correctly sized buffer and call
    est_client_copy_enrolled_cert() to retrieve the new client certificate
    from the context.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_enroll</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>,
                             <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>new_public_key</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>new_public_key</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_KEY</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <goto>goto <name>err</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_cn</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>new_public_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>EST_ERR_AUTH_FAIL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>||</operator>
         <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_BASIC</name>  <operator>||</operator>
         <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_TOKEN</name><operator>)</operator></expr>)</condition><then> <block>{

        <comment type="block">/*
         * HTTPS digest mode requires the use of MD5.  Make sure we're not
         * in FIPS mode and can use MD5
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>FIPS_mode</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><then><block>{
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP digest auth not allowed while in FIPS mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_BAD_MODE</name></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        }</block></then></if>
        
        <comment type="block">/* Try one more time if we're doing Digest auth */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Auth failed, trying again with basic/digest/token parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Connection failed on second attempt with basic/digest/token parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_cn</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>new_public_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Enroll failed on second attempt during basic/digest authentication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If we're attempting token mode for the second time, and
             * the server responded with error attributes, log them now
             */</comment>
            <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Token Auth mode failed, server provided error information: \n"</literal>
                            <literal type="string">"   Error = %s\n Error description: %s"</literal></expr></argument>,
                            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            }</block></then></if>            
        }</block></then></if>
        
        <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_NONE</name></expr>;</expr_stmt>

  <label><name>err</name>:</label>    
    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*! @brief est_client_provision_cert() performs the full sequence of
    EST operations to enroll a new certificate using a trusted message flow.
 
    @param ctx Pointer to an EST context
    @param cn Pointer to the Common Name value to be used in the enrollment
    request.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    certificate returned from the RA or CA.
    @param ca_cert_len Pointer to an integer to hold the length of the buffer 
    that will hold the new trusted CA certificates.
    @param new_public_key Pointer an EVP_PKEY structure that holds the
    client's key pair to be used in the simple enroll request .  The public
    key is included in the Certificate Signing Request (CSR) sent to the CA
    Server, and the private key is used to sign the request.
 
    @return EST_ERROR

    est_client_provision_cert() connects to the EST server, retrieves the
    latest trusted CA certifictes from the server, retrieves the CSR attributes
    from the server, and sends the simple enroll request to the server to
    provision a new certificate from the RA or CA.  This is a convenience 
    function that is equivalent to invoking the following three functions
    in order:

    est_client_get_cacerts()
    est_client_get_csrattrs()
    est_client_enroll() 

    This function takes a Common Name (CN) as the only entity identifier
    that will be used in the CSR.  If additional X509 attributes
    or extensions are required because the EST server is enforcing the
    presence of all the CSR attributes, then this function should not be used
    to provision a certificate.  The est_client_enroll_csr() function should
    be used when additional X509 attributes are to be included in the
    enroll request. 

    The provisioning response is stored in the EST context and the length is passed 
    back to the application through the pkcs7_len parameter of this function.  The
    application can then allocate a correctly sized buffer and call
    est_client_copy_enrolled_cert() to retrieve the new client certificate
    from the context.

    The provisioning response also includes the latest copy of the trusted
    CA certificates from the EST server.  These should be persisted locally
    by the application for future use.  The ca_cert_len argument will contain the 
    length of the certicates, which can then be retrieved by invoking 
    est_client_copy_cacerts().
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_provision_cert</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cn</name></decl></parameter>, 
	                             <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>,
				     <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ca_cert_len</name></decl></parameter>,
                                     <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>new_public_key</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>new_ta_p7</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>new_ta_pem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>attr_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>attr_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_ta_len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Make sure we have non-NULL pointers for the lengths
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><name>pkcs7_len</name> <operator>||</operator> <operator>!</operator><name>ca_cert_len</name></expr>)</condition><then> <block>{
	<return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>new_public_key</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_KEY</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * First, get the latest trust anchor certs from the server.
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_get_cacerts</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ca_cert_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
	<return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>new_ta_p7</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>*</operator><name>ca_cert_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>new_ta_p7</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate CA certs buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_MALLOC</name></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_copy_cacerts</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>new_ta_p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_ta_p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * The certs are base64 DER encoded.  We need to convert
     * them to PEM.
     */</comment>
    <expr_stmt><expr><name>new_ta_len</name> <operator>=</operator> <call><name>est_convert_p7b64_to_pem</name> <argument_list>(<argument><expr><name>new_ta_p7</name></expr></argument>, <argument><expr><operator>*</operator><name>ca_cert_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_ta_pem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_ta_p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>new_ta_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<return>return <expr><operator>(</operator><name>EST_ERR_PEM_READ</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * We now have the new trust anchor and it's PEM encoded.
     * Let's load it into the current EST context.  All
     * future EST operations will then be using this new
     * trust anchor.
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>trusted_certs_store</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>X509_STORE_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>trusted_certs_store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_load_trusted_certs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>new_ta_pem</name></expr></argument>, <argument><expr><name>new_ta_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_ta_pem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    
    <comment type="block">/*
     * Since we've reset the trust store, mark the client
     * context as initialized.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Next we need to get the CSR attributes, which allows libEST
     * to know if the challengePassword needs to be included in the
     * CSR.
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_get_csrattrs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to get CSR attributes while provisioning a new certificate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Finally, we can attempt to enroll a new certificate using the
     * Common Name provided by the application.
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>new_public_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*! @brief est_client_reenroll() performs a re-enroll request with the EST
     server using an existing X509 certificate.
 
    @param ctx Pointer to an EST context
    @param cert Pointer to the X509 certificate, which is defined as an OpenSSL
    X509.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    buffer.
    @param priv_key Pointer to the private key that will be used to sign the CSR.
 
    @return EST_ERROR

    est_client_reenroll() connects to the EST server, establishes a SSL/TLS
    connection to the EST server that was configured with the previous call to
    est_client_set_server(), and sends the re-enroll request.  The application
    layer must provide the X509 certificate that will be enrolled.  This certificate
    should have previously been enrolled with the CA.  The application also
    needs to provide the private key associated with the public key in the
    X509 certificate.  This private key is required to sign the CSR that is
    generated from the X509 certificate. 
    
    The enroll response is stored in the EST context and the length 
    is passed back to the application through the pkcs7_len paramter of this 
    function.  The application can then allocate a correctly sized buffer and 
    call est_client_copy_enrolled_cert() to retrieve the new client certificate 
    from the context.

    The application must provide a pointer to the private key used to sign the CSR.
    This is required by the EST library in the event that the EST server has
    requested the proof-of-possession value be included in the CSR.  The EST library
    will automatically include the proof-of-posession value and sign the CSR
    again.

    Be aware that only the public key and subject name from the X509 certificate
    are included in the re-enroll request sent to the EST server.  The CA is
    responsible for re-applying any X509 extensions that are to be issued with
    the renewed certificate.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_reenroll</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>cert</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pkcs7_len</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>priv_key</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>X509_REQ</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ossl_rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>cert</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CERT</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>priv_key</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_KEY</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_CLIENT_NOT_INITIALIZED</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Check the X509 given to us
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_check_x509</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
	<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Check that the private key matches the public key
     * in the cert.
     */</comment>
    <if>if <condition>(<expr><call><name>X509_check_private_key</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr><name>priv_key</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_CLIENT_INVALID_KEY</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Convert the existing certificate to a CSR
     * This will copy the subject name from the cert into
     * a new CSR.  We pass in NULL for the private key parameter
     * below because we will sign this CSR ourselves later.
     */</comment>
    <expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>X509_to_X509_REQ</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>req</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"X509 to CSR conversion failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CSR</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Copy the X509 extensions from the old certificate
     * to the CSR.  The CA may or may not retain these, as
     * this behavior depends on policy.  When using the 
     * OpenSSL test CA, set the copy_extensions setting 
     * in the config file to copyall to retain the
     * extensions in the CSR when issuing a new cert.
     */</comment>
    <if>if <condition>(<expr><name><name>cert</name><operator>-&gt;</operator><name>cert_info</name></name> <operator>&amp;&amp;</operator> <name><name>cert</name><operator>-&gt;</operator><name>cert_info</name><operator>-&gt;</operator><name>extensions</name></name></expr>)</condition><then> <block>{
	<expr_stmt><expr><name>ossl_rv</name> <operator>=</operator> <call><name>X509_REQ_add_extensions</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name><name>cert</name><operator>-&gt;</operator><name>cert_info</name><operator>-&gt;</operator><name>extensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>ossl_rv</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Failed to copy X509 extensions to the CSR. Your new certificate may not contain the extensions present in the old certificate."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * Establish TLS session with the EST server
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <goto>goto <name>err</name>;</goto>
    }</block></then></if>

    <comment type="block">/*
     * Send the re-enroll request
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_pkcs10</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>priv_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>EST_ERR_AUTH_FAIL</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>||</operator>
         <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_BASIC</name>  <operator>||</operator>
         <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_TOKEN</name><operator>)</operator></expr>)</condition><then> <block>{

        <comment type="block">/*
         * HTTPS digest mode requires the use of MD5.  Make sure we're not
         * in FIPS mode and can use MD5
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>FIPS_mode</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><then><block>{
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP digest auth not allowed while in FIPS mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_BAD_MODE</name></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        }</block></then></if>
        
        <comment type="block">/* Try one more time if we're doing Digest auth */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Auth failed, trying again with digest/basic parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Connection failed on second attempt with basic/digest parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>err</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_enroll_pkcs10</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name>pkcs7_len</name></expr></argument>, <argument><expr><name>priv_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Reenroll failed on second attempt during basic/digest authentication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/*
             * If we're attempting token mode for the second time, and
             * the server responded with error attributes, log them now
             */</comment>
            <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Token Auth mode failed, server provided error information: \n"</literal>
                            <literal type="string">"   Error = %s\n Error description: %s"</literal></expr></argument>,
                            <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            }</block></then></if>            
            
        }</block></then></if>
        <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<label><name>err</name>:</label>    
    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>X509_REQ_free</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>

    
}</block></function>

<comment type="block">/*! @brief est_client_copy_enrolled_cert() passes back the client certificate
    that was previously obtained from the EST server by the call to
    est_client_enroll().
 
    @param ctx Pointer to an EST context
    @param cn Pointer to the Common Name value to be used in the enrollment
    request.
    @param pkcs7 Pointer to a pointer that will point to the buffer that
    contains the newly enrolled client certificate.
 
    @return EST_ERROR

    est_client_copy_enrolled_cert() copies the previously obtained client
    certificate from the EST context to the application's buffer.  Once this
    client certificate is copied out of the context it is removed from the
    context.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_copy_enrolled_cert</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pkcs7</name></decl></parameter>)</parameter_list>
<block>{

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>pkcs7</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then><block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST Client: Simple Enroll, invalid parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
    }</block></then></if>
         
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then><block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"No client certificate to copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><name>EST_ERR_NO_CERTIFICATE</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>pkcs7</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name></expr></argument>,
             <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Now that the copy in the context has been handed over,
     * free it up
     */</comment>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enrolled_client_cert_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_get_cacerts() performs a CAcerts GET request to the EST server
 
    @param ctx Pointer to an EST context
    @param ca_certs_len Pointer to an integer to hold the length of the CA certs
    buffer
 
    @return EST_ERROR

    est_client_get_cacerts() connects to the EST server, builds a CA certs
    request, and sends the GET CA certs request.  The response is placed in a
    buffer allocated and maintained by the EST client library and a pointer to
    this buffer is returned to the calling application.  The returned CA certs
    are in base64 encoded DER format and is stored in a NULL terminated string
    buffer.

    Once the CA certificates are retrieved from the EST server, the ET Client
    library must be reset.  The retrieved CA certificates should now be passed
    into the EST client initialization function as the explicit TA database.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_get_cacerts</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ca_certs_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>ca_certs_len</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST Client: Get CACerts, invalid parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>        
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_send_cacerts_request</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>ca_certs_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_copy_cacerts() copies the previously retrieved CA
    certificates to the application's buffer.
 
    @param ctx Pointer to the current EST context.
    @param ca_certs Pointer to the buffer into which the retrieved CA certificates
    are to be copied. 
 
    @return EST_ERROR

    est_client_copy_cacerts() copies the most recently retrieved CA
    certificates from the EST server.  Once these CA certificates are copied
    to the application's buffer pointed to by ca_certs they are removed from
    the EST clietn context.

    Once the CA certificates are retrieved by the application, the EST client
    library must be reset.  When this reset is performed, the CA certificates
    retrieved in this est_client_copy_cacerts call should be passed into the
    EST client initialization function as the explicit TA database.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_copy_cacerts</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ca_certs</name></decl></parameter>)</parameter_list>
<block>{

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>ca_certs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"EST Client: Get CACerts, invalid parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
    }</block></then></if>
    
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"No CA certificates to copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><name>EST_ERR_NO_CERTIFICATE</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>ca_certs</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>ca_certs</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs</name></name></expr></argument>,
             <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_ca_certs_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * if the CA certs were obtained, then the client lib needs to be reset.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_get_csrattrs() performs the CSR attributes request to
    the EST server.
 
    @param ctx Pointer to EST context for a client session
    @param csr_data Pointer to a buffer that is to hold the returned CSR
    attributes
    @param csr_len Pointer to an integer that is to hold the length of the CSR
    attributes buffer
 
    @return EST_ERROR

    est_client_get_csrattrs() connects to the EST server, sends the CSR attributes
    request to the server, saves aways the returned CSR attribute data, and then
    disconnects from the EST server.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_get_csrattrs</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>csr_data</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>csr_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>new_csr_len</name></decl>, <decl><type ref="prev"/><name>pop_required</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>new_csr_data</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>csr_data</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name>csr_len</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/* assume defeat */</comment>
    <expr_stmt><expr><operator>*</operator><name>csr_data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>csr_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Connect to the EST server
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_connect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * free the current attributes if cached
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Send the HTTP request to the EST server
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_send_csrattrs_request</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_csr_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_csr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>est_client_disconnect</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"CSR request failed, error code is %d (%s)"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><call><name>EST_ERR_NUM_TO_STR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>new_csr_data</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>new_csr_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"CSR attributes are: NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <comment type="block">/* 
     * have to allocate the new memory prior to 
     * parsing to be sure it is null terminated.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>new_csr_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_MALLOC</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name> <operator>=</operator> <name>new_csr_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr></argument>, <argument><expr><name>new_csr_len</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>new_csr_data</name></expr></argument>, <argument><expr><name>new_csr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name><index>[<expr><name>new_csr_len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"CSR attributes are(%d): %s"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name></expr></argument>, 
		 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_csr_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now make sure the data is valid */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_asn1_parse_attributes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>pop_required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><operator>*</operator><name>csr_data</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>csr_len</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>retrieved_csrattrs_len</name></name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>csr_pop_required</name></name> <operator>=</operator> <name>pop_required</name></expr>;</expr_stmt>
    
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*! @brief est_client_enable_srp() is used by an application to enable
    TLS-SRP as the transport, which is used in place of traditional
    TLS.  TLS-SRP allows for secure transport when an X.509 certificate
    is not available or when a trust anchor is not available.
 
    @param ctx EST context obtained from the est_client_init() call.
    @param strength Specifies the SRP strength to use.
    @param uid char buffer containing the user id to be used as the
    SRP user name. 
    @param pwd char buffer containing the passowrd to be used as the
    SRP password.

    This function allows an application to enable TLS-SRP cipher suites,
    which is another form for TLS.  This could be used when the EST client
    does not have an X.509 certificate to identify itself to the EST
    server.  It can also be used by the EST client when a trust anchor
    is not available to authenticate the EST server identity.  
    The EST server must support TLS-SRP when using this API. 

    This function must be invoked after est_client_init() and prior to 
    issuing any EST commands..

    All string parameters are NULL terminated strings.
    
    @return EST_ERROR.  
*/</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_enable_srp</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strength</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>X509_STORE</name> <modifier>*</modifier></type><name>store</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>    

    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SSL context has not been initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_SSL_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>strength</name> <operator>&lt;</operator> <name>EST_SRP_STRENGTH_MIN</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SRP strength must be greater than %d"</literal></expr></argument>, <argument><expr><name>EST_SRP_STRENGTH_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_SRP_STRENGTH_LOW</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>uid</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SRP user ID must be provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>pwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"SRP password must be provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>enable_srp</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Enable just the SRP cipher suites.  When SRP is enabled,
     * it's used exclusively.
     *
     * Check if we have a trust anchor configured.  We will
     * enable the DSS and RSA auth cipher suites if we do.
     */</comment>
    <expr_stmt><expr><name>store</name> <operator>=</operator> <call><name>SSL_CTX_get_cert_store</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>store</name> <operator>&amp;&amp;</operator> <name><name>store</name><operator>-&gt;</operator><name>objs</name></name> <operator>&amp;&amp;</operator> <call><name>sk_X509_OBJECT_num</name><argument_list>(<argument><expr><name><name>store</name><operator>-&gt;</operator><name>objs</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Enable SSL SRP cipher suites with RSA/DSS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>SSL_CTX_set_cipher_list</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>EST_CIPHER_LIST_SRP_AUTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
	<expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Enable SSL SRP cipher suites w/o RSA/DSS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>SSL_CTX_set_cipher_list</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>EST_CIPHER_LIST_SRP_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><operator>!</operator><name>rv</name></expr>)</condition><then> <block>{ 
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to set SSL SRP cipher suites\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EST_ERR_SSL_CIPHER_LIST</name></expr>;</return>
    }</block></then></if>
	
    <comment type="block">/* 
     * Set the SRP user name and password.  
     */</comment>
    <if>if <condition>(<expr><operator>!</operator><call><name>SSL_CTX_set_srp_username</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>uid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set SRP username\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EST_ERR_UNKNOWN</name></expr>;</return> 
    }</block></then></if>
    <if>if <condition>(<expr><operator>!</operator><call><name>SSL_CTX_set_srp_password</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to set SRP password\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EST_ERR_UNKNOWN</name></expr>;</return> 
    }</block></then></if>
    <expr_stmt><expr><call><name>SSL_CTX_set_srp_strength</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"TLS-SRP enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_set_auth() is used by an application to set up the
    authentication parameters to be used.
 
    @param ctx EST context obtained from the est_client_init() call.
    @param uid char buffer containing the user id to be used for basic
    and digest based authentication
    @param pwd char buffer containing the passowrd to be used for basic
    and digest based authentication
    @param client_cert_raw char buffer containing the client application
    certificate.
    @param pkey_raw Private key that can be used with the client cert
    @param pkey_len Length of buffer holding the private key

    This function allows an application to provide the information required
    for authenticating the EST client with the EST server.  Until this call is
    made, the only accepted request is the GET CA Certs.  If the user id is
    provided, a password must also be provided.

    The application may pass the private key (pkey_raw/pkey_len) to be used
    for signing requests to the server, otherwise, only basic or digest based
    authentication will be performed on the TLS session for these requests.
    If the private key is passed, it must contain the private key that matches
    the public key contained in the client_cert parameter.

    All string parameters are NULL terminated strings.
    
    @return EST_ERROR.  If error, NULL.
*/</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_set_auth</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl></parameter>,
                               <parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>client_cert</name></decl></parameter>, <parameter><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>private_key</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>    

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_set_uid_pw</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>uid</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>            

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_NONE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * cache away the client cert and the associated private key, then
     * get them loaded into the SSL context so that they'll be used.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>client_key</name></name> <operator>=</operator> <name>private_key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>client_cert</name></name> <operator>=</operator> <name>client_cert</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Load the client cert if it's available
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>client_cert</name></name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>client_key</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>est_client_set_cert_and_key</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client_cert</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>client_key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to load local certificate and private key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EST_ERR_CLIENT_INVALID_KEY</name></expr>;</return>
        }</block></then></if>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Not using client certificate for TLS session, HTTP basic or digest auth will be used."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_set_auth_cred_cb() is used by an application to register
  its callback function.
    
  @param ctx EST context obtained from the est_client_init() call.
  @param auth_credentials_cb  Function pointer to the application layer callback

  The registered callback function is used by the EST client library to obtain
  authentication credentials.  The application can provide authentication
  credentials during initialization if they are available, such as the userid
  and password used with HTTP basic authentication.  During the processing of
  a request, the EST client library will call this application callback in the
  event that it does not have the authentication credentials that are being
  requested by the EST server.

  The callback function definition must match the following function
  prototype,

  int (*auth_credentials_cb)(EST_HTTP_AUTH_HDR *auth_credentials);

  auth_credentials - A pointer to a EST_HTTP_AUTH_HDR structure.  The
                     structure is provided by the EST library and the callback
                     function fills in the specific credentials being
                     requested.  These credential values must be passed in the
                     format in which they will be sent to the server, that is,
                     the EST client library will perform no reformatting of
                     these credentials.  Ownership of the memory holding these
                     credential values is transferred from the application
                     layer to the EST library when the application layer
                     returns these values to the EST library.  This allows the
                     EST library to free up this memory as soon as it is done
                     using these values.
                         
  The return value from the callback must be one of the following values:

  EST_HTTP_AUTH_CRED_SUCCESS - If the callback was able to provide the
                               requested credentials.
  EST_HTTP_AUTH_CRED_NOT_AVAILABLE - If the callback could not provide the
                                     requested credentials.

  The auth_credentials_cb parameter can be set to NULL to reset the callback
  function.
  
  All string parameters are NULL terminated strings.
    
  @return EST_ERROR.
  EST_ERR_NONE - Success.
  EST_ERR_NO_CTX
*/</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_set_auth_cred_cb</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>auth_credentials_cb</name></type> <name>callback</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_credentials_cb</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
    
    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_enable_basic_auth_hint() is used by an application to 
    reduce overhead at the TCP and TLS layers when the client knows that
    the EST server is using HTTP Basic Authentication. 
 
    @param ctx Pointer to EST context for a client session

    Normally libEST will send an anonymous HTTP request when doing the
    initial request from the EST server.  This function allows an application 
    to improve performance by sending the HTTP Basic Auth header in the initial 
    request sent to the EST server.  This eliminates the need for the server to send
    the HTTP authentication challene response, which eliminates a round-trip
    between the EST client and server.  This function should be called immediately
    after invoking est_client_set_auth().

    Precautions should be taken by your application to ensure this hint is
    only enabled when it is known that the EST server is configured for HTTP
    Basic Authentication.  If the EST server is configured for HTTP Digest
    Authentication, then enabling this hint will cause the EST transaction
    to fail.
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
*/</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_enable_basic_auth_hint</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>    

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_BASIC</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_init() is used by an application to create
    a context in the EST library.  This context is used when invoking
    other functions in the client API.
 
    @param ca_chain Required char buffer containing CA certificates as raw byte
    data, to be used for authenticating the EST server
    @param ca_chain_len length of ca_chain char buffer.
    @param cert_format defines the format of the certificates that will be
    passed down during this instantiation of the EST client library.  Currently,
    the only value accepted is EST_CERT_FORMAT_PEM
    @param cert_verify_cb A pointer to a function in the EST client application
    that is called when a received server identity certificate has failed
    verification from the SSL code.  This function takes as input two
    parameters, a pointer to the X509 structure containing the server's
    certificate, and a integer value set to the OpenSSL defined error
    for this certificate.  This callback function returns a 0 if the server's
    identity certificate has been rejected, and any other value if it
    has been approved.

    This function allows an application to initialize an EST client context.
    The application must provide the local CA certificates
    (ca_chain/ca_chain_len) to use for client operation.  The certificates
    provided must be in the format specified by the cert_format parameter.
    Currently, only PEM encoded certificates are supported.  The length
    parameters for the certificates (ca_chain_len) are to be used when DER
    formatted certificates are passed.  The CA certificates may contain CRL
    entries that will be used when authenticating the certificates received
    from the server.
 
    @return EST_CTX.  If error, NULL.
*/</comment>
<function><type><name>EST_CTX</name> <modifier>*</modifier></type><name>est_client_init</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ca_chain</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ca_chain_len</name></decl></parameter>,
                          <parameter><decl><type><name>EST_CERT_FORMAT</name></type> <name>cert_format</name></decl></parameter>,
                          <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cert_verify_cb</name>)<parameter_list>(<parameter><decl><type><name>X509</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>iResult</name></decl>;</decl_stmt>

	<comment type="block">/*
	*Initialize Winsock
	*/</comment>
	<expr_stmt><expr><name>iResult</name> <operator>=</operator> <call><name>WSAStartup</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>iResult</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"WSAStartup Failed: %d\n"</literal></expr></argument>, <argument><expr><name>iResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>

	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	

    <if>if <condition>(<expr><name>cert_format</name> <operator>!=</operator> <name>EST_CERT_FORMAT_PEM</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Only PEM encoding of certificates is supported."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
        
    <comment type="block">/* 
     * If a CA chain was passed in, then check the length value passed in.  It
     * should match the calculated length of the buffer.  This will verify
     * both that the length value is correct, and that the buffer is properly
     * null terminated.
     */</comment>
    <if>if <condition>(<expr><name>ca_chain</name></expr>)</condition><then> <block>{    
        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ca_chain</name></expr></argument>, <argument><expr><name>EST_CA_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>ca_chain_len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Length of ca_chain doesn't match passed ca_chain_len"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    
    <expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_CTX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory for EST Context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_CTX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_mode</name></name> <operator>=</operator> <name>EST_CLIENT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Load the local CA certificates into memory and retain
     * for future use.  This will be used for /CACerts requests.
     */</comment>
    <if>if <condition>(<expr><call><name>est_load_trusted_certs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ca_chain</name></expr></argument>, <argument><expr><name>ca_chain_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to load trusted certificate store"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>est_destroy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_client_init_ssl_ctx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to initialize SSL context with certificiate and private key passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>est_destroy</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * save away the client's callback function that allows for manual verification of
     * the server's identity certificate
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>manual_cert_verify_cb</name></name> <operator>=</operator> <name>cert_verify_cb</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Set the default value for the  socket read timeout.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_timeout</name></name> <operator>=</operator> <name>EST_SSL_READ_TIMEOUT_DEF</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We use SHA-256 as the default hash algorithm
     * for signing the CSR.  This can be changed by the
     * application by using the est_client_set_sign_digest() 
     * function.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name> <operator>=</operator> <call><name>EVP_sha256</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_delay</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_date</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>ctx</name><operator>)</operator></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_URIPARSER</name></cpp:ifdef>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_client_parse_path_seg</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path_seg</name></decl></parameter>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>UriParserStateA</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UriUriA</name></type> <name>parsed_uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>uriparse_rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UriPathSegmentA</name> <modifier>*</modifier></type><name>cur_seg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cur_seg_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_OPERATION</name></type> <name>operation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>canned_uri</name><index>[<expr><name>EST_URI_MAX_LEN</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
     * build out a canned URI to pass to the uriparser library.
     * This will cause the incoming path segment to be in the
     * correct spot within a URI as it gets validated.  Main issue
     * is the possible use of a ':' in the path segment becoming a
     * theme delimiter
     */</comment>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>canned_uri</name></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name>canned_uri</name></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>, <argument><expr><literal type="string">"/.well-known/est/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat_s</name><argument_list>(<argument><expr><name>canned_uri</name></expr></argument>, <argument><expr><name>EST_URI_MAX_LEN</name></expr></argument>, <argument><expr><name>path_seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>uri</name></name> <operator>=</operator> <operator>&amp;</operator><name>parsed_uri</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>uriparse_rc</name> <operator>=</operator> <call><name>uriParseUriA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>canned_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>uriparse_rc</name> <operator>!=</operator> <name>URI_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>uriFreeUriMembersA</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_INVALID_PATH_SEGMENT</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>cur_seg</name> <operator>=</operator> <name><name>parsed_uri</name><operator>.</operator><name>pathHead</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cur_seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"No valid path segment in supplied string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>uriFreeUriMembersA</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_INVALID_PATH_SEGMENT</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>cur_seg</name> <operator>=</operator> <name><name>cur_seg</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur_seg_str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>cur_seg</name><operator>-&gt;</operator><name>text</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>operation</name> <operator>=</operator> <call><name>est_parse_operation</name><argument_list>(<argument><expr><name>cur_seg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * look to see if the operation path comes next:
         * cacerts, csrattrs, simpleenroll, simplereenroll.
         * If any of the operations occur in this path segment
         * string, then this is a problem.
         */</comment>
    <if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>EST_OP_MAX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Path segment string contains an operation value. path segment passed in =  %s\n"</literal></expr></argument>, <argument><expr><name>cur_seg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>uriFreeUriMembersA</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_INVALID_PATH_SEGMENT</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Look to see if there are multiple segments
     */</comment>
    <if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>cur_seg</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name><name>cur_seg</name><operator>-&gt;</operator><name>text</name><operator>.</operator><name>afterLast</name></name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Path segment string contains multiple path segments or more than a path segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>uriFreeUriMembersA</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_INVALID_PATH_SEGMENT</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><call><name>uriFreeUriMembersA</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*! @brief est_client_set_server() is called by the application layer to
     specify the address/port of the EST server. It must be called after
     est_client_init() and prior to issuing any EST commands.
 
    @param ctx Pointer to EST context for a client session
    @param server Name of the EST server to connect to.  The ASCII string
    representing the name of the server is limited to 254 characters
    @param port TCP port on the EST server to connect
    @param path_segment A string containing the optional path segment
    to be added to the URI.  If not used, set to NULL.
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_SERVER_NAME - NULL value passed for EST server name, or
    server name string too long
    EST_ERR_CLIENT_NOT_INITIALIZED - Called before est_client_init()
    EST_ERR_INVALID_PORT_NUM - Invalid port number input, less than zero or
    greater than 65535

    est_client_set_server error checks its input parameters and then stores
    both the hostname and port number into the EST context.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_set_server</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>,
                                 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path_segment</name></decl></parameter>)</parameter_list>
<block>{
    
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_NO_CTX</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>server</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_SERVER_NAME</name></expr>;</return>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>port</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>port</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_PORT_NUM</name></expr>;</return>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_server</name></name></expr></argument>, <argument><expr><name>EST_MAX_SERVERNAME_LEN</name></expr></argument>, <argument><expr><name>server</name></expr></argument>,
                         <argument><expr><name>EST_MAX_SERVERNAME_LEN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_SERVER_NAME</name></expr>;</return>
    }</block></then></if>   

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>est_port_num</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_URIPARSER</name></cpp:ifdef>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>path_segment_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rc</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>path_segment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{

            <if>if <condition>(<expr><operator>*</operator><name>path_segment</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
                <return>return <expr><name>EST_ERR_HTTP_INVALID_PATH_SEGMENT</name></expr>;</return>
            }</block></then></if>
            
            <comment type="block">/*
             * Make sure it's not too long
             */</comment>
            <expr_stmt><expr><name>path_segment_len</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>path_segment</name></expr></argument>, <argument><expr><name>EST_MAX_PATH_SEGMENT_LEN</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>path_segment_len</name> <operator>&gt;</operator> <name>EST_MAX_PATH_SEGMENT_LEN</name></expr>)</condition><then> <block>{
                <return>return <expr><name>EST_ERR_HTTP_INVALID_PATH_SEGMENT</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/*
             * Validate the incoming path segment string
             */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>est_client_parse_path_seg</name><argument_list>(<argument><expr><name>path_segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"path segment failed validation."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><operator>(</operator><name>rc</name><operator>)</operator></expr>;</return>
            }</block></then></if>

            <comment type="block">/*
             * valid.  store it away in the context
             */</comment>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>est_store_path_segment</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>path_segment</name></expr></argument>, <argument><expr><name>path_segment_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to store URI path segment."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><operator>(</operator><name>rc</name><operator>)</operator></expr>;</return>
            }</block></then></if>        
        }</block></then></if>
    }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <block>{
        <comment type="block">/*
         * If no uriparser support, then we cannot support
         * a path segment being passed in
         */</comment>
        <if>if <condition>(<expr><name>path_segment</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Use of path segments not supported in this build of libEST."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EST_ERR_HTTP_PATH_SEGMENT_NOT_SUPPORTED</name></expr>;</return>
        }</block></then></if>  
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_set_proxy() is called by the application layer to
    specify the proxy to the EST server. It must be called after
    est_client_init() and prior to issuing any EST commands.

    @param ctx Pointer to EST context for a client session
    @param proxy_proto Proxy protocol
    @param proxy_server Name of the proxy server to connect to.  The ASCII string
    representing the name of the server is limited to 254 characters (EST_MAX_SERVERNAME_LEN)
    @param port TCP port on the proxy server to connect
    @param proxy_auth Proxy authentication method
    @param username Username to use to authenticate with the proxy
    @param password Password to use to authenticate with the proxy

    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_SERVER_NAME - NULL value passed for EST server name, or
    server name string too long
    EST_ERR_INVALID_PORT_NUM - port num to proxy server is invalid
    EST_ERR_CLIENT_NOT_INITIALIZED - Called before est_client_init()
    EST_ERR_INVALID_PARAMETERS - NULL value passed for either username or password
    OR username or password is too long
    EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED - client proxy mode is only supported when
    built with libcurl support
    EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL - An invalid proxy protocol has been specified 
    
    est_client_set_proxy error checks its input parameters and then stores
    the proxy information into the EST context.

    NOTE: HTTP proxy tunnelling is not supported by libEST in server mode.
    If configuring libEST in client mode to communicate with libEST in
    server mode, then EST_CLIENT_PROXY_HTTP_NOTUNNEL must be specified
    for the proxy protocol.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_set_proxy</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>EST_CLIENT_PROXY_PROTO</name></type> <name>proxy_proto</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proxy_server</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>proxy_port</name></decl></parameter>,
                                <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>proxy_auth</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name></decl></parameter>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBCURL</name></cpp:ifdef>
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_NO_CTX</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>proxy_server</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>proxy_server</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_SERVER_NAME</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>EST_MAX_SERVERNAME_LEN</name> <operator>&lt;</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>proxy_server</name></expr></argument>, <argument><expr><name>EST_MAX_SERVERNAME_LEN</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_SERVER_NAME</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_server</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_server</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_server</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                         <argument><expr><name>proxy_server</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_server</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_SERVER_NAME</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>proxy_port</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>proxy_port</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_PORT_NUM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_port</name></name> <operator>=</operator> <name>proxy_port</name></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>proxy_proto</name> <operator>&lt;</operator> <name>EST_CLIENT_PROXY_HTTP_NOTUNNEL</name> <operator>||</operator>
        <name>proxy_proto</name> <operator>&gt;</operator> <name>EST_CLIENT_PROXY_SOCKS5_HOSTNAME</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_proto</name></name> <operator>=</operator> <name>proxy_proto</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>proxy_auth</name> <operator>!=</operator> <name>EST_CLIENT_PROXY_AUTH_NONE</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>proxy_auth</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>EST_CLIENT_PROXY_AUTH_BASIC</name><operator>|</operator><name>EST_CLIENT_PROXY_AUTH_NTLM</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_INVALID_CLIENT_PROXY_AUTH</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_auth</name></name> <operator>=</operator> <name>proxy_auth</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>username</name> <operator>&amp;&amp;</operator> <name>password</name> <operator>&amp;&amp;</operator> <name>proxy_auth</name> <operator>!=</operator> <name>EST_CLIENT_PROXY_AUTH_NONE</name></expr>)</condition><then> <block>{
        
        <if>if <condition>(<expr><name>MAX_UIDPWD</name> <operator>&lt;</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>username</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_username</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_username</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_username</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
                             <argument><expr><name>username</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_username</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>MAX_UIDPWD</name> <operator>&lt;</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>password</name></expr></argument>, <argument><expr><name>MAX_UIDPWD</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_password</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_password</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>password</name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_password</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>EST_ERR_INVALID_PARAMETERS</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>proxy_auth</name></name> <operator>=</operator> <name>proxy_auth</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>use_proxy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    
    <return>return <expr><name>EST_ERR_NONE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * If the EST library was not built with support for libcurl then client
     * proxy mode is not supported.
     */</comment>
    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Client proxy mode requires libest to be built with libcurl."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
}</block></function>


<comment type="block">/*! @brief est_client_set_sign_digest() is called by the application layer to
     specify the hash algorithm used to sign the PKCS10 CSR during the
     enroll operation. It must be called after
     est_client_init() and prior to issuing any EST commands.
 
    @param ctx Pointer to EST context for a client session
    @param nid This is the NID value defined in the OpenSSL header file obj_mac.h
               for the desired digest to use for signing.  
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_DIGEST - An unsupported NID was provided.

    libEST supports SHA1, SHA224, SHA256, SHA384, and SHA512 digests.  
    SHA256 is the default digest to use for signing.  There's no need
    to invoke this function unless another digest is desired. The
    supported NID values are:
	NID_sha1
	NID_sha224 
	NID_sha256 
	NID_sha384 
	NID_sha512 
    
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_set_sign_digest</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nid</name></decl></parameter>)</parameter_list> 
<block>{
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_NO_CTX</name></expr>;</return>
    }</block></then></if>

    <switch>switch <condition>(<expr><name>nid</name></expr>)</condition> <block>{
    <case>case <expr><name>NID_sha512</name></expr>:</case>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name> <operator>=</operator> <call><name>EVP_sha512</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
    <case>case <expr><name>NID_sha384</name></expr>:</case>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name> <operator>=</operator> <call><name>EVP_sha384</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
    <case>case <expr><name>NID_sha256</name></expr>:</case>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name> <operator>=</operator> <call><name>EVP_sha256</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
    <case>case <expr><name>NID_sha224</name></expr>:</case>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name> <operator>=</operator> <call><name>EVP_sha224</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
    <case>case <expr><name>NID_sha1</name></expr>:</case>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>signing_digest</name></name> <operator>=</operator> <call><name>EVP_sha1</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
        <break>break;</break>
    <default>default:</default>
	<return>return <expr><operator>(</operator><name>EST_ERR_INVALID_DIGEST</name><operator>)</operator></expr>;</return>
        <break>break;</break>
    }</block></switch>

    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>



<comment type="block">/*! @brief est_client_copy_retry_after() copies the retry after value stored
    in this client context.
 
    @param ctx Pointer to the current EST context.
    
    @param retry_delay Pointer to the integer where the retry-after delay secs
    value is copied.  If the server sent a retry-after in delay seconds format
    then it will be passed here.  If it did not, then this value will be zero.
    
    @param retry_time Pointer to the time_t where the retry-after time date
    value is copied.  If the server sent a retry-after in time and date string
    format then this string is converted into a time_t value and passed up
    in this parameter.  This value will only be set if the server sent a time
    and date string response, otherwise, this value is set to zero.
 
    @return EST_ERROR

    When a response is received from the EST server the headers are checked to
    see if the server has included a Retry-After header, indicating that this
    request currently cannot be processed.  If a Retry-After HTTP header is
    included in the received response from the server the delay value is saved
    in the context and an EST error code is given to the application on this
    request indicating that the client must retry the request at a later time.

    The value specified by the server can be in one of two basic formats, a
    string version of a integer value that represents the number of seconds
    the client must wait before retrying the request, and a string containing
    a date and time when the client can retry the request.  The date and time
    string can be in any format specified in RFC 2616.  If the second delay
    value is sent it is converted into an integer and saved in the EST context
    and if the date time string value is sent it is converted into a time_t
    value and saved into the EST context.  The application must then call
    est_client_copy_retry_after() to obtain the amount of time to wait before
    retrying the request.  est_client_copy_retry_after() copies the current
    retry-after value from the client context and returns it to the
    application.  Only one of the two return values will be set with a
    non-zero value.

    NOTE: The processing of a Retry-After value in time/date format is currently
    not supported.  The EST Client will always return only a retry delay
    value in seconds.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_copy_retry_after</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>retry_delay</name></decl></parameter>,
                                       <parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>retry_time</name></decl></parameter>)</parameter_list>
<block>{

    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>est_client_initialized</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>EST_ERR_CLIENT_NOT_INITIALIZED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><operator>*</operator><name>retry_delay</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>retry_after_delay</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_delay</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>retry_time</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>retry_after_date</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_date</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*! @brief est_client_force_pop() is used by an application to enable 
    the proof-of-possession generation at the EST client.  This proves
    that the EST client that sent the CSR to the server/proxy is in possession
    of the private key that was used to sign the CSR.  This binds the TLS 
    session ID to the CSR.

    Note, if the CSR attributes configured on the server require PoP 
    checking, then there is no need to call this function to enable
    PoP.  The PoP will be enabled automatically under this scenario
    when the CSR attributes are requested from the server/proxy.
    
    @param ctx Pointer to the EST context

    This function may be called at any time.   
 
    @return EST_ERROR.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_force_pop</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>client_force_pop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*! @brief est_client_unforce_pop() is used by an application to disable 
    the proof-of-possession generation at the EST client.  Please see
    the documenation for est_client_force_pop() for more information
    on the proof-of-possession check.

    @param ctx Pointer to the EST context

    This function may be called at any time.   
 
    @return EST_ERROR.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_unforce_pop</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>client_force_pop</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*! @brief est_client_set_read_timeout() is used by an application to set
    timeout value of read operations.  After the EST client sends a request to
    the EST server it will attempt to read the response from the server.  This
    timeout value limits the amount of time the client will wait for the
    response.

    @param ctx Pointer to the EST context
    @param timeout Integer value representing the read timeout in seconds.
    The minimum value is EST_SSL_READ_TIMEOUT_MIN and the maximum value is
    EST_SSL_READ_TIMEOUT_MAX.
 
    @return EST_ERROR.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_client_set_read_timeout</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Null context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_NO_CTX</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>timeout</name> <operator>&lt;</operator> <name>EST_SSL_READ_TIMEOUT_MIN</name> <operator>||</operator>
        <name>timeout</name> <operator>&gt;</operator> <name>EST_SSL_READ_TIMEOUT_MAX</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid read timeout value passed: %d "</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_INVALID_PARAMETERS</name><operator>)</operator></expr>;</return>
    }</block></then></if>
        
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_timeout</name></name> <operator>=</operator> <name>timeout</name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*! @brief est_client_get_last_http_status() is used by an application to get
    the HTTP status code returned by the EST server for the most recent
    operation. 

    @param ctx Pointer to the EST context

    This can be called after an EST operation, such as an enroll operation.
    This function will return the most recent HTTP status code received
    from the EST server.  Normally, a status of 200 would be returned
    by the EST server to indicate a successful operation.  However, if the
    operation failed for some reason, the HTTP status code may be useful
    to understand the reason for failure.  For instance, the EST server 
    would return a HTTP status of 401 if the EST client was not authorized.
    Please see RFC 2616 for a description of the various HTTP status codes.
 
    @return int value representing the HTTP status code, or NULL if the
    a NULL EST context was provided.
 */</comment>
<function><type><name>int</name></type> <name>est_client_get_last_http_status</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>ctx</name></expr>)</condition><then> <block>{
	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>last_http_status</name></name></expr>;</return>
    }</block></then> <else>else <block>{
	<return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></else></if>
}</block></function>
</unit>
