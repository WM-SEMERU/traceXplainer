<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C" filename="est_ossl_util.c"><comment type="block">/** @file */</comment>
<comment type="block">/*------------------------------------------------------------------
 * est_ossl_util.c - Interface between EST server and OpenSSL for
 *                   EST server operations.  Some of this code was taken
 *                   from the OpenSSL /apps directory and modified to work
 *                   with the EST stack, which is why the OpenSSL copyright
 *                   statement is retained here.  
 *
 * November, 2012
 *
 * Copyright (c) 2012-2014, 2016 by cisco Systems, Inc.
 * All rights reserved.
 **------------------------------------------------------------------
 */</comment>
<comment type="block">/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */</comment>

<comment type="block">/* This was written by Gordon Chaffee &lt;chaffee@plateau.cs.berkeley.edu&gt;
 * and donated 'to the cause' along with lots and lots of other fixes to
 * the library. */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/x509v3.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/pem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_ossl_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_locl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_mem_lib.h"</cpp:file></cpp:include>

<comment type="block">/*****************************************************************************************
* Authorization routines
*****************************************************************************************/</comment>
<function><type><name>int</name></type> <name>ossl_verify_cb</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>cert_error</name> <init>= <expr><call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>current_cert</name> <init>= <expr><call><name>X509_STORE_CTX_get_current_cert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"enter function: ok=%d cert_error=%d"</literal></expr></argument>, <argument><expr><name>ok</name></expr></argument>, <argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>current_cert</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_NAME_print_ex_fp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,
                                  <argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>current_cert</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XN_FLAG_ONELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"%serror %d at %d depth lookup:%s\n"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><call><name>X509_STORE_CTX_get0_parent_ctx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"[CRL path]"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
                     <argument><expr><name>cert_error</name></expr></argument>,
                     <argument><expr><call><name>X509_STORE_CTX_get_error_depth</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>cert_error</name></expr>)</condition> <block>{
        <case>case <expr><name>X509_V_ERR_UNABLE_TO_GET_CRL</name></expr>:</case>
            <comment type="block">/*
             * We've enabled CRL checking in the TLS stack.  If
             * the application hasn't loaded a CRL, then this
             * verify error can occur.  The peer's cert is valid,
             * but we can't confirm if it was revoked.  We'll
             * warn the application.
             */</comment>
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"No CRL loaded, TLS peer will be allowed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>X509_V_ERR_NO_EXPLICIT_POLICY</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CERT_HAS_EXPIRED</name></expr>:</case>

        <comment type="block">/* since we are just checking the certificates, it is
         * ok if they are self signed. But we should still warn
         * the user.
         */</comment>

        <case>case <expr><name>X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT</name></expr>:</case>
        <comment type="block">/* Continue after extension errors too */</comment>
        <case>case <expr><name>X509_V_ERR_INVALID_CA</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_INVALID_NON_CA</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_PATH_LENGTH_EXCEEDED</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_INVALID_PURPOSE</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CRL_HAS_EXPIRED</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CRL_NOT_YET_VALID</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION</name></expr>:</case>
        <case>case <expr><name>X509_V_ERR_CERT_REVOKED</name></expr>:</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Certificate verify failed (reason=%d)"</literal></expr></argument>,
                         <argument><expr><name>cert_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></switch>
        <return>return <expr><name>ok</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>ok</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is used to load an X509_STORE using raw
 * data from a buffer.  The data is expected to be PEM
 * encoded.
 *
 * Returns the number of certs added to the store
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>ossl_init_cert_store_from_raw</name> <parameter_list>(<parameter><decl><type><name>X509_STORE</name> <modifier>*</modifier></type><name>store</name></decl></parameter>,
                                           <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>raw</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509_INFO</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>sk</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>X509_INFO</name> <modifier>*</modifier></type><name>xi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cert_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name><argument_list>(<argument><expr><name>raw</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>in</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to open the raw CA cert buffer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>

    <comment type="block">/* This loads from a file, a stack of x509/crl/pkey sets */</comment>
    <expr_stmt><expr><name>sk</name> <operator>=</operator> <call><name>PEM_X509_INFO_read_bio</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>sk</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to read PEM encoded certs from BIO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* scan over it and pull out the CRL's */</comment>
    <while>while <condition>(<expr><call><name>sk_X509_INFO_num</name><argument_list>(<argument><expr><name>sk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>xi</name> <operator>=</operator> <call><name>sk_X509_INFO_shift</name><argument_list>(<argument><expr><name>sk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>xi</name><operator>-&gt;</operator><name>x509</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Adding cert to store (%s)"</literal></expr></argument>, <argument><expr><name><name>xi</name><operator>-&gt;</operator><name>x509</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_add_cert</name><argument_list>(<argument><expr><name>store</name></expr></argument>, <argument><expr><name><name>xi</name><operator>-&gt;</operator><name>x509</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>cert_cnt</name><operator>++</operator></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>xi</name><operator>-&gt;</operator><name>crl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Adding CRL to store"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_add_crl</name><argument_list>(<argument><expr><name>store</name></expr></argument>, <argument><expr><name><name>xi</name><operator>-&gt;</operator><name>crl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>X509_INFO_free</name><argument_list>(<argument><expr><name>xi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>sk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>sk_X509_INFO_pop_free</name><argument_list>(<argument><expr><name>sk</name></expr></argument>, <argument><expr><name>X509_INFO_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>cert_cnt</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function is used to populate an X509_STORE structure,
 * which can be used by the OpenSSL TLS stack to verifying
 * a TLS peer.  The X509_STORE should already have been allocated.
 *
 * Parameters:
 *  store   - Pointer to X509_STORE structure to hold the certs
 *  raw1    - char array containing PEM encoded certs to put
 *            into the store.
 *  size1   - Length of the raw1 char array
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>ossl_init_cert_store</name> <parameter_list>(<parameter><decl><type><name>X509_STORE</name> <modifier>*</modifier></type><name>store</name></decl></parameter>,
                                <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>raw1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size1</name></decl></parameter>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>X509_STORE_set_flags</name><argument_list>(<argument><expr><name>store</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>raw1</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>ossl_init_cert_store_from_raw</name><argument_list>(<argument><expr><name>store</name></expr></argument>, <argument><expr><name>raw1</name></expr></argument>, <argument><expr><name>size1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><operator>!</operator><name>cnt</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Cert count is zero for store"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><operator>(</operator><name>EST_ERR_NO_CERTS_FOUND</name><operator>)</operator></expr>;</return>
	}</block></then></if>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function can be used to output the OpenSSL
 * error buffer.  This is useful when an OpenSSL
 * API call fails and you'd like to provide some
 * detail to the user regarding the cause of the
 * failure.
 */</comment>
<function><type><name>void</name></type> <name>ossl_dump_ssl_errors</name> <parameter_list>()</parameter_list>
<block>{
    <decl_stmt><decl><type><name>BIO</name>		<modifier>*</modifier></type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BUF_MEM</name>	<modifier>*</modifier></type><name>bptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>ERR_print_errors</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>BIO_flush</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_get_mem_ptr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"OSSL error: %s"</literal></expr></argument>, <argument><expr><name><name>bptr</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*! @brief est_convert_p7b64_to_pem() converts the base64 encoded
    PKCS7 response from the EST server into PEM format.   
 
    @param certs_p7 Points to a buffer containing the base64 encoded pkcs7 data.
    @param certs_len Indicates the size of the *certs_p7 buffer.
    @param pem Double pointer that will receive the PEM encoded data. 
 
    Several of the EST message return data that contains base64 encoded PKCS7
    certificates.  This function is used to convert the data to PEM format.
    This function will allocate memory pointed to by the **pem argument.
    The caller is responsible for releasing this memory.  The return value
    is the length of the PEM buffer, or -1 on error.
 
    @return int.
 */</comment>
<function><type><name>int</name></type> <name>est_convert_p7b64_to_pem</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>certs_p7</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>certs_len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pem</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> <operator>*</operator><name>certs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b64</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>in</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cacerts_decoded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>cacerts_decoded_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>p7bio_in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PKCS7</name> <modifier>*</modifier></type><name>p7</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pem_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>pem_len</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Base64 decode the incoming ca certs buffer.  Decoding will
     * always take up no more than the original buffer.
     */</comment>
    <expr_stmt><expr><name>b64</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_f_base64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>b64</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>    
    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name><argument_list>(<argument><expr><name>certs_p7</name></expr></argument>, <argument><expr><name>certs_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if>if <condition>(<expr><operator>!</operator><name>in</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>BIO_push</name><argument_list>(<argument><expr><name>b64</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><name>cacerts_decoded</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>certs_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>cacerts_decoded</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>cacerts_decoded_len</name> <operator>=</operator> <call><name>BIO_read</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>cacerts_decoded</name></expr></argument>, <argument><expr><name>certs_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Now get the PKCS7 formatted buffer of certificates read into a stack of
     * X509 certs
     */</comment>
    <expr_stmt><expr><name>p7bio_in</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>, <argument><expr><name>cacerts_decoded_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>p7bio_in</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed while attempting to create mem BIO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>p7</name> <operator>=</operator> <call><name>d2i_PKCS7_bio</name><argument_list>(<argument><expr><name>p7bio_in</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>p7</name></expr>)</condition><then> <block>{
	<expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"PEM_read_bio_PKCS7 failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>p7bio_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cacerts_decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Now that we've decoded the certs, get a reference
     * the the stack of certs
     */</comment>
    <expr_stmt><expr><name>nid</name><operator>=</operator><call><name>OBJ_obj2nid</name><argument_list>(<argument><expr><name><name>p7</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>nid</name></expr>)</condition>
        <block>{
        <case>case <expr><name>NID_pkcs7_signed</name></expr>:</case>
            <expr_stmt><expr><name>certs</name> <operator>=</operator> <name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>sign</name><operator>-&gt;</operator><name>cert</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>NID_pkcs7_signedAndEnveloped</name></expr>:</case>
            <expr_stmt><expr><name>certs</name> <operator>=</operator> <name><name>p7</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>signed_and_enveloped</name><operator>-&gt;</operator><name>cert</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Invalid NID value on PKCS7 structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
            <break>break;</break>
        }</block></switch>

    <if>if <condition>(<expr><operator>!</operator><name>certs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Failed to attain X509 cert stack from PKCS7 data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Output the certs to a new BIO using the PEM format 
     */</comment>
    <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_new failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>sk_X509_num</name><argument_list>(<argument><expr><name>certs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <expr_stmt><expr><name>x</name><operator>=</operator><call><name>sk_X509_value</name><argument_list>(<argument><expr><name>certs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PEM_write_bio_X509</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BIO_puts</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>BIO_flush</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now convert the BIO to char*
     */</comment>
    <expr_stmt><expr><name>pem_len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>BIO_get_mem_data</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pem_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pem_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"BIO_get_mem_data failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><operator>*</operator><name>pem</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>pem_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>pem</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><operator>*</operator><name>pem</name></expr></argument>, <argument><expr><name>pem_len</name></expr></argument>, <argument><expr><name>pem_data</name></expr></argument>, <argument><expr><name>pem_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>pem</name><operator>)</operator><index>[<expr><name>pem_len</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="line">//Make sure it's null termianted</comment>
    <expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PKCS7_free</name><argument_list>(<argument><expr><name>p7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>pem_len</name><operator>)</operator></expr>;</return>
}</block></function>

</unit>
