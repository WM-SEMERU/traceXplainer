<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C" filename="est_client_http.c"><comment type="block">/*------------------------------------------------------------------
 * est/est_client_http.c - SSL and HTTP I/O routines for EST implementation
 *
 * November, 2012
 *
 * Copyright (c) 2013, 2016, 2017 by cisco Systems, Inc.
 * All rights reserved.
 **------------------------------------------------------------------
 */</comment>
<comment type="block">/* Portions of this code (as indicated) are derived from the Internet Draft
** draft-ietf-http-authentication-03 and are covered by the following
** copyright:

** Copyright (C) The Internet Society (1998). All Rights Reserved.

** This document and translations of it may be copied and furnished to
** others, and derivative works that comment on or otherwise explain it or
** assist in its implmentation may be prepared, copied, published and
** distributed, in whole or in part, without restriction of any kind,
** provided that the above copyright notice and this paragraph are included
** on all such copies and derivative works. However, this document itself
** may not be modified in any way, such as by removing the copyright notice
** or references to the Internet Society or other Internet organizations,
** except as needed for the purpose of developing Internet standards in
** which case the procedures for copyrights defined in the Internet
** Standards process must be followed, or as required to translate it into
** languages other than English.

** The limited permissions granted above are perpetual and will not be
** revoked by the Internet Society or its successors or assigns.

** This document and the information contained herein is provided on an "AS
** IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK
** FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
** LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
** INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR
** FITNESS FOR A PARTICULAR PURPOSE.
**/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Ws2tcpip.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_locl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_server_http.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_mem_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_str_lib.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vsnprintf</name></cpp:macro> <cpp:value>_vsnprintf</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strcasecmp</name></cpp:macro> <cpp:value>_stricmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strncasecmp</name></cpp:macro> <cpp:value>_strnicmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atoll</name><parameter_list>(<parameter><type><name>string</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_atoi64(string)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"est_ossl_util.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTH_STR_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RETRY_AFTER_DELAY_TIME_SUPPORT</name></cpp:ifdef>

<comment type="block">/* 
 * The following function was taken from cURL (curl-7.31.0-20130613).
 *
 * This code would be used to support the server's sending of a
 * Retry-After value that is in a time/date stamp format.  This
 * code handles all three formats specified in RFC2616, section 3.3.*
 *
 * Right now, the EST server side of this library sends only a
 * retry delay value in seconds, and does not make use of the
 * time/date string.  If support for this is needed, this code
 * can be introduced.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISSPACE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isspace((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISDIGIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isdigit((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISALNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isalnum((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISXDIGIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isxdigit((int) ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISGRAPH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isgraph((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISALPHA</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isalpha((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISPRINT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isprint((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISUPPER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isupper((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISLOWER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(islower((int)  ((unsigned char)x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISASCII</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(isascii((int)  ((unsigned char)x)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISBLANK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(int)((((unsigned char)x) == ' ') || \
                          (((unsigned char)x) == '\t'))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOLOWER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(tolower((int)  ((unsigned char)x)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOF_INT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> <comment type="line">//(sizeof(int))</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_SIZEOF_LONG</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> <comment type="line">// (sizeof(long))</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>SIZEOF_INT</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_SINT</name></cpp:macro>  <cpp:value>0x7FFF</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_UINT</name></cpp:macro>  <cpp:value>0xFFFF</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>SIZEOF_INT</name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_SINT</name></cpp:macro>  <cpp:value>0x7FFFFFFF</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_UINT</name></cpp:macro>  <cpp:value>0xFFFFFFFF</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>SIZEOF_INT</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_SINT</name></cpp:macro>  <cpp:value>0x7FFFFFFFFFFFFFFF</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_UINT</name></cpp:macro>  <cpp:value>0xFFFFFFFFFFFFFFFF</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>SIZEOF_INT</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_SINT</name></cpp:macro>  <cpp:value>0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MASK_UINT</name></cpp:macro>  <cpp:value>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#  <cpp:directive>error</cpp:directive> <cpp:literal>"SIZEOF_INT not defined"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRNO</name></cpp:macro>         <cpp:value>((int)GetLastError())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ERRNO</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(SetLastError((DWORD)(x)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ERRNO</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(errno = (x))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 
<comment type="block">/*
** signed long to signed int
*/</comment>

<function><type><name>int</name></type> <name>curlx_sltosi</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>slnum</name></decl></parameter>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__INTEL_COMPILER</name></cpp:ifdef>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>810</name><name>)</name></cpp:pragma> <comment type="block">/* conversion may lose significant bits */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>slnum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>SIZEOF_INT</name> <operator>&lt;</operator> <name>CURL_SIZEOF_LONG</name><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>slnum</name> <operator>&lt;=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>CURL_MASK_SINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>slnum</name> <operator>&amp;</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>CURL_MASK_SINT</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__INTEL_COMPILER</name></cpp:ifdef>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>Curl_wkday</name><index>[]</index></name> <init>=
<expr><block>{<expr><literal type="string">"Mon"</literal></expr>, <expr><literal type="string">"Tue"</literal></expr>, <expr><literal type="string">"Wed"</literal></expr>, <expr><literal type="string">"Thu"</literal></expr>, <expr><literal type="string">"Fri"</literal></expr>, <expr><literal type="string">"Sat"</literal></expr>, <expr><literal type="string">"Sun"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><specifier>static</specifier> <type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>weekday</name><index>[]</index></name> <init>=
<expr><block>{ <expr><literal type="string">"Monday"</literal></expr>, <expr><literal type="string">"Tuesday"</literal></expr>, <expr><literal type="string">"Wednesday"</literal></expr>, <expr><literal type="string">"Thursday"</literal></expr>,
  <expr><literal type="string">"Friday"</literal></expr>, <expr><literal type="string">"Saturday"</literal></expr>, <expr><literal type="string">"Sunday"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>Curl_month</name><index>[]</index></name><init>=
<expr><block>{ <expr><literal type="string">"Jan"</literal></expr>, <expr><literal type="string">"Feb"</literal></expr>, <expr><literal type="string">"Mar"</literal></expr>, <expr><literal type="string">"Apr"</literal></expr>, <expr><literal type="string">"May"</literal></expr>, <expr><literal type="string">"Jun"</literal></expr>,
  <expr><literal type="string">"Jul"</literal></expr>, <expr><literal type="string">"Aug"</literal></expr>, <expr><literal type="string">"Sep"</literal></expr>, <expr><literal type="string">"Oct"</literal></expr>, <expr><literal type="string">"Nov"</literal></expr>, <expr><literal type="string">"Dec"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>tzinfo</name> <block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt> <comment type="block">/* +/- in minutes */</comment>
}</block>;</struct>

<comment type="block">/*
 * parsedate()
 *
 * Returns:
 *
 * PARSEDATE_OK     - a fine conversion
 * PARSEDATE_FAIL   - failed to convert
 * PARSEDATE_LATER  - time overflow at the far end of time_t
 * PARSEDATE_SOONER - time underflow at the low end of time_t
 */</comment>

<function_decl><specifier>static</specifier> <type><name>int</name></type> <name>parsedate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>date</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSEDATE_OK</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSEDATE_FAIL</name></cpp:macro>   <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSEDATE_LATER</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSEDATE_SOONER</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EST_CURL_MAX_NAME_STR</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Here's a bunch of frequently used time zone names. These were supported
   by the old getdate parser. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tDAYZONE</name></cpp:macro> <cpp:value>-60</cpp:value></cpp:define>       <comment type="block">/* offset for daylight savings time */</comment>
<decl_stmt><decl><specifier>static</specifier> <type><specifier>const</specifier> <name><name>struct</name> <name>tzinfo</name></name></type> <name><name>tz</name><index>[]</index></name><init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"GMT"</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,              <comment type="block">/* Greenwich Mean */</comment>
  <expr><block>{<expr><literal type="string">"UTC"</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,              <comment type="block">/* Universal (Coordinated) */</comment>
  <expr><block>{<expr><literal type="string">"WET"</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,              <comment type="block">/* Western European */</comment>
  <expr><block>{<expr><literal type="string">"BST"</literal></expr>, <expr><literal type="number">0</literal> <name>tDAYZONE</name></expr>}</block></expr>,     <comment type="block">/* British Summer */</comment>
  <expr><block>{<expr><literal type="string">"WAT"</literal></expr>, <expr><literal type="number">60</literal></expr>}</block></expr>,             <comment type="block">/* West Africa */</comment>
  <expr><block>{<expr><literal type="string">"AST"</literal></expr>, <expr><literal type="number">240</literal></expr>}</block></expr>,            <comment type="block">/* Atlantic Standard */</comment>
  <expr><block>{<expr><literal type="string">"ADT"</literal></expr>, <expr><literal type="number">240</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Atlantic Daylight */</comment>
  <expr><block>{<expr><literal type="string">"EST"</literal></expr>, <expr><literal type="number">300</literal></expr>}</block></expr>,            <comment type="block">/* Eastern Standard */</comment>
  <expr><block>{<expr><literal type="string">"EDT"</literal></expr>, <expr><literal type="number">300</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Eastern Daylight */</comment>
  <expr><block>{<expr><literal type="string">"CST"</literal></expr>, <expr><literal type="number">360</literal></expr>}</block></expr>,            <comment type="block">/* Central Standard */</comment>
  <expr><block>{<expr><literal type="string">"CDT"</literal></expr>, <expr><literal type="number">360</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Central Daylight */</comment>
  <expr><block>{<expr><literal type="string">"MST"</literal></expr>, <expr><literal type="number">420</literal></expr>}</block></expr>,            <comment type="block">/* Mountain Standard */</comment>
  <expr><block>{<expr><literal type="string">"MDT"</literal></expr>, <expr><literal type="number">420</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Mountain Daylight */</comment>
  <expr><block>{<expr><literal type="string">"PST"</literal></expr>, <expr><literal type="number">480</literal></expr>}</block></expr>,            <comment type="block">/* Pacific Standard */</comment>
  <expr><block>{<expr><literal type="string">"PDT"</literal></expr>, <expr><literal type="number">480</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Pacific Daylight */</comment>
  <expr><block>{<expr><literal type="string">"YST"</literal></expr>, <expr><literal type="number">540</literal></expr>}</block></expr>,            <comment type="block">/* Yukon Standard */</comment>
  <expr><block>{<expr><literal type="string">"YDT"</literal></expr>, <expr><literal type="number">540</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Yukon Daylight */</comment>
  <expr><block>{<expr><literal type="string">"HST"</literal></expr>, <expr><literal type="number">600</literal></expr>}</block></expr>,            <comment type="block">/* Hawaii Standard */</comment>
  <expr><block>{<expr><literal type="string">"HDT"</literal></expr>, <expr><literal type="number">600</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* Hawaii Daylight */</comment>
  <expr><block>{<expr><literal type="string">"CAT"</literal></expr>, <expr><literal type="number">600</literal></expr>}</block></expr>,            <comment type="block">/* Central Alaska */</comment>
  <expr><block>{<expr><literal type="string">"AHST"</literal></expr>, <expr><literal type="number">600</literal></expr>}</block></expr>,           <comment type="block">/* Alaska-Hawaii Standard */</comment>
  <expr><block>{<expr><literal type="string">"NT"</literal></expr>,  <expr><literal type="number">660</literal></expr>}</block></expr>,            <comment type="block">/* Nome */</comment>
  <expr><block>{<expr><literal type="string">"IDLW"</literal></expr>, <expr><literal type="number">720</literal></expr>}</block></expr>,           <comment type="block">/* International Date Line West */</comment>
  <expr><block>{<expr><literal type="string">"CET"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal></expr>}</block></expr>,            <comment type="block">/* Central European */</comment>
  <expr><block>{<expr><literal type="string">"MET"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal></expr>}</block></expr>,            <comment type="block">/* Middle European */</comment>
  <expr><block>{<expr><literal type="string">"MEWT"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal></expr>}</block></expr>,           <comment type="block">/* Middle European Winter */</comment>
  <expr><block>{<expr><literal type="string">"MEST"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal> <name>tDAYZONE</name></expr>}</block></expr>,  <comment type="block">/* Middle European Summer */</comment>
  <expr><block>{<expr><literal type="string">"CEST"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal> <name>tDAYZONE</name></expr>}</block></expr>,  <comment type="block">/* Central European Summer */</comment>
  <expr><block>{<expr><literal type="string">"MESZ"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal> <name>tDAYZONE</name></expr>}</block></expr>,  <comment type="block">/* Middle European Summer */</comment>
  <expr><block>{<expr><literal type="string">"FWT"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal></expr>}</block></expr>,            <comment type="block">/* French Winter */</comment>
  <expr><block>{<expr><literal type="string">"FST"</literal></expr>, <expr><operator>-</operator><literal type="number">60</literal> <name>tDAYZONE</name></expr>}</block></expr>,   <comment type="block">/* French Summer */</comment>
  <expr><block>{<expr><literal type="string">"EET"</literal></expr>, <expr><operator>-</operator><literal type="number">120</literal></expr>}</block></expr>,           <comment type="block">/* Eastern Europe, USSR Zone 1 */</comment>
  <expr><block>{<expr><literal type="string">"WAST"</literal></expr>, <expr><operator>-</operator><literal type="number">420</literal></expr>}</block></expr>,          <comment type="block">/* West Australian Standard */</comment>
  <expr><block>{<expr><literal type="string">"WADT"</literal></expr>, <expr><operator>-</operator><literal type="number">420</literal> <name>tDAYZONE</name></expr>}</block></expr>, <comment type="block">/* West Australian Daylight */</comment>
  <expr><block>{<expr><literal type="string">"CCT"</literal></expr>, <expr><operator>-</operator><literal type="number">480</literal></expr>}</block></expr>,           <comment type="block">/* China Coast, USSR Zone 7 */</comment>
  <expr><block>{<expr><literal type="string">"JST"</literal></expr>, <expr><operator>-</operator><literal type="number">540</literal></expr>}</block></expr>,           <comment type="block">/* Japan Standard, USSR Zone 8 */</comment>
  <expr><block>{<expr><literal type="string">"EAST"</literal></expr>, <expr><operator>-</operator><literal type="number">600</literal></expr>}</block></expr>,          <comment type="block">/* Eastern Australian Standard */</comment>
  <expr><block>{<expr><literal type="string">"EADT"</literal></expr>, <expr><operator>-</operator><literal type="number">600</literal> <name>tDAYZONE</name></expr>}</block></expr>, <comment type="block">/* Eastern Australian Daylight */</comment>
  <expr><block>{<expr><literal type="string">"GST"</literal></expr>, <expr><operator>-</operator><literal type="number">600</literal></expr>}</block></expr>,           <comment type="block">/* Guam Standard, USSR Zone 9 */</comment>
  <expr><block>{<expr><literal type="string">"NZT"</literal></expr>, <expr><operator>-</operator><literal type="number">720</literal></expr>}</block></expr>,           <comment type="block">/* New Zealand */</comment>
  <expr><block>{<expr><literal type="string">"NZST"</literal></expr>, <expr><operator>-</operator><literal type="number">720</literal></expr>}</block></expr>,          <comment type="block">/* New Zealand Standard */</comment>
  <expr><block>{<expr><literal type="string">"NZDT"</literal></expr>, <expr><operator>-</operator><literal type="number">720</literal> <name>tDAYZONE</name></expr>}</block></expr>, <comment type="block">/* New Zealand Daylight */</comment>
  <expr><block>{<expr><literal type="string">"IDLE"</literal></expr>, <expr><operator>-</operator><literal type="number">720</literal></expr>}</block></expr>,          <comment type="block">/* International Date Line East */</comment>
  <comment type="block">/* Next up: Military timezone names. RFC822 allowed these, but (as noted in
     RFC 1123) had their signs wrong. Here we use the correct signs to match
     actual military usage.
   */</comment>
  <expr><block>{<expr><literal type="string">"A"</literal></expr>,  <expr><operator>+</operator><literal type="number">1</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Alpha */</comment>
  <expr><block>{<expr><literal type="string">"B"</literal></expr>,  <expr><operator>+</operator><literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Bravo */</comment>
  <expr><block>{<expr><literal type="string">"C"</literal></expr>,  <expr><operator>+</operator><literal type="number">3</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Charlie */</comment>
  <expr><block>{<expr><literal type="string">"D"</literal></expr>,  <expr><operator>+</operator><literal type="number">4</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Delta */</comment>
  <expr><block>{<expr><literal type="string">"E"</literal></expr>,  <expr><operator>+</operator><literal type="number">5</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Echo */</comment>
  <expr><block>{<expr><literal type="string">"F"</literal></expr>,  <expr><operator>+</operator><literal type="number">6</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Foxtrot */</comment>
  <expr><block>{<expr><literal type="string">"G"</literal></expr>,  <expr><operator>+</operator><literal type="number">7</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Golf */</comment>
  <expr><block>{<expr><literal type="string">"H"</literal></expr>,  <expr><operator>+</operator><literal type="number">8</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Hotel */</comment>
  <expr><block>{<expr><literal type="string">"I"</literal></expr>,  <expr><operator>+</operator><literal type="number">9</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* India */</comment>
  <comment type="block">/* "J", Juliet is not used as a timezone, to indicate the observer's local
     time */</comment>
  <expr><block>{<expr><literal type="string">"K"</literal></expr>, <expr><operator>+</operator><literal type="number">10</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Kilo */</comment>
  <expr><block>{<expr><literal type="string">"L"</literal></expr>, <expr><operator>+</operator><literal type="number">11</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Lima */</comment>
  <expr><block>{<expr><literal type="string">"M"</literal></expr>, <expr><operator>+</operator><literal type="number">12</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Mike */</comment>
  <expr><block>{<expr><literal type="string">"N"</literal></expr>,  <expr><operator>-</operator><literal type="number">1</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* November */</comment>
  <expr><block>{<expr><literal type="string">"O"</literal></expr>,  <expr><operator>-</operator><literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Oscar */</comment>
  <expr><block>{<expr><literal type="string">"P"</literal></expr>,  <expr><operator>-</operator><literal type="number">3</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Papa */</comment>
  <expr><block>{<expr><literal type="string">"Q"</literal></expr>,  <expr><operator>-</operator><literal type="number">4</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Quebec */</comment>
  <expr><block>{<expr><literal type="string">"R"</literal></expr>,  <expr><operator>-</operator><literal type="number">5</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Romeo */</comment>
  <expr><block>{<expr><literal type="string">"S"</literal></expr>,  <expr><operator>-</operator><literal type="number">6</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Sierra */</comment>
  <expr><block>{<expr><literal type="string">"T"</literal></expr>,  <expr><operator>-</operator><literal type="number">7</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Tango */</comment>
  <expr><block>{<expr><literal type="string">"U"</literal></expr>,  <expr><operator>-</operator><literal type="number">8</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Uniform */</comment>
  <expr><block>{<expr><literal type="string">"V"</literal></expr>,  <expr><operator>-</operator><literal type="number">9</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Victor */</comment>
  <expr><block>{<expr><literal type="string">"W"</literal></expr>, <expr><operator>-</operator><literal type="number">10</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Whiskey */</comment>
  <expr><block>{<expr><literal type="string">"X"</literal></expr>, <expr><operator>-</operator><literal type="number">11</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* X-ray */</comment>
  <expr><block>{<expr><literal type="string">"Y"</literal></expr>, <expr><operator>-</operator><literal type="number">12</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,         <comment type="block">/* Yankee */</comment>
  <expr><block>{<expr><literal type="string">"Z"</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,                <comment type="block">/* Zulu, zero meridian, a.k.a. UTC */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* returns:
   -1 no day
   0 monday - 6 sunday
*/</comment>

<function><specifier>static</specifier> <type><name>int</name></type> <name>checkday</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>check</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>what</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>found</name><init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><then>
    <block type="pseudo"><expr_stmt><expr><name>what</name> <operator>=</operator> <operator>&amp;</operator><name><name>weekday</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block></then>
  <else>else
    <block type="pseudo"><expr_stmt><expr><name>what</name> <operator>=</operator> <operator>&amp;</operator><name><name>Curl_wkday</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block></else></if>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">7</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
    <if>if<condition>(<expr><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name><name>what</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>found</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>what</name><operator>++</operator></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><ternary><condition><expr><name>found</name></expr>?</condition><then><expr><name>i</name></expr></then><else>:<expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>int</name></type> <name>checkmonth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>check</name></decl></parameter>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>what</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>found</name><init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>what</name> <operator>=</operator> <operator>&amp;</operator><name><name>Curl_month</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">12</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
    <if>if<condition>(<expr><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name><name>what</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>found</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>what</name><operator>++</operator></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><ternary><condition><expr><name>found</name></expr>?</condition><then><expr><name>i</name></expr></then><else>:<expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return> <comment type="block">/* return the offset or -1, no real offset is -1 */</comment>
}</block></function>

<comment type="block">/* return the time zone offset between GMT and the input one, in number
   of seconds or -1 if the timezone wasn't found/legal */</comment>

<function><specifier>static</specifier> <type><name>int</name></type> <name>checktz</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>check</name></decl></parameter>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>tzinfo</name></name> <modifier>*</modifier></type><name>what</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>found</name><init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>what</name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tz</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tz</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
    <if>if<condition>(<expr><call><name>est_client_Curl_raw_equal</name><argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name><name>what</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>found</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>what</name><operator>++</operator></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><ternary><condition><expr><name>found</name></expr>?</condition><then><expr><name><name>what</name><operator>-&gt;</operator><name>offset</name></name><operator>*</operator><literal type="number">60</literal></expr></then><else>:<expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
}</block></function>

<function><specifier>static</specifier> <type><name>void</name></type> <name>skip_over_white</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>date</name></decl></parameter>)</parameter_list>
<block>{
  <comment type="block">/* skip everything that aren't letters or digits */</comment>
  <while>while<condition>(<expr><operator>*</operator><operator>*</operator><name>date</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>date</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block type="pseudo"><expr_stmt><expr><operator>(</operator><operator>*</operator><name>date</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block></while>
}</block></function>

<enum>enum <name>assume</name> <block>{
  <decl><name>DATE_MDAY</name></decl>,
  <decl><name>DATE_YEAR</name></decl>,
  <decl><name>DATE_TIME</name></decl>
}</block>;</enum>

<comment type="block">/* this is a clone of 'struct tm' but with all fields we don't need or use
   cut out */</comment>
<struct>struct <name>my_tm</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>tm_sec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tm_min</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tm_hour</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tm_mday</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tm_mon</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tm_year</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* struct tm to time since epoch in GMT time zone.
 * This is similar to the standard mktime function but for GMT only, and
 * doesn't suffer from the various bugs and portability problems that
 * some systems' implementations have.
 */</comment>
<function><specifier>static</specifier> <type><name>time_t</name></type> <name>my_timegm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>my_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>)</parameter_list>
<block>{
  <decl_stmt><decl><specifier>static</specifier> <type><specifier>const</specifier> <name>int</name></type> <name><name>month_days_cumulative</name> <index>[<expr><literal type="number">12</literal></expr>]</index></name> <init>=
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">90</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">151</literal></expr>, <expr><literal type="number">181</literal></expr>, <expr><literal type="number">212</literal></expr>, <expr><literal type="number">243</literal></expr>, <expr><literal type="number">273</literal></expr>, <expr><literal type="number">304</literal></expr>, <expr><literal type="number">334</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>month</name></decl>, <decl><type ref="prev"/><name>year</name></decl>, <decl><type ref="prev"/><name>leap_days</name></decl>;</decl_stmt>

  <if>if<condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">70</literal></expr>)</condition><then>
    <comment type="block">/* we don't support years before 1970 as they will cause this function
       to return a negative value */</comment>
    <block type="pseudo"><return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block></then></if>

  <expr_stmt><expr><name>year</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>month</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>;</expr_stmt>
  <if>if<condition>(<expr><name>month</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>year</name> <operator>+=</operator> <operator>(</operator><literal type="number">11</literal> <operator>-</operator> <name>month</name><operator>)</operator> <operator>/</operator> <literal type="number">12</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>month</name> <operator>=</operator> <literal type="number">11</literal> <operator>-</operator> <operator>(</operator><literal type="number">11</literal> <operator>-</operator> <name>month</name><operator>)</operator> <operator>%</operator> <literal type="number">12</literal></expr>;</expr_stmt>
  }</block></then>
  <elseif>else <if>if<condition>(<expr><name>month</name> <operator>&gt;=</operator> <literal type="number">12</literal></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>year</name> <operator>-=</operator> <name>month</name> <operator>/</operator> <literal type="number">12</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>month</name> <operator>=</operator> <name>month</name> <operator>%</operator> <literal type="number">12</literal></expr>;</expr_stmt>
  }</block></then></if></elseif></if>

  <expr_stmt><expr><name>leap_days</name> <operator>=</operator> <name>year</name> <operator>-</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>leap_days</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>leap_days</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>leap_days</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>leap_days</name> <operator>/</operator> <literal type="number">400</literal><operator>)</operator>
               <operator>-</operator> <operator>(</operator><literal type="number">1969</literal> <operator>/</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">1969</literal> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">1969</literal> <operator>/</operator> <literal type="number">400</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><call>(<name>time_t</name>) <argument_list>(<argument><expr><name>year</name> <operator>-</operator> <literal type="number">1970</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">365</literal>
            <operator>+</operator> <name>leap_days</name> <operator>+</operator> <name><name>month_days_cumulative</name> <index>[<expr><name>month</name></expr>]</index></name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">24</literal>
           <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name><operator>)</operator> <operator>*</operator> <literal type="number">60</literal> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <literal type="number">60</literal> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr>;</return>
}</block></function>

<comment type="block">/*
 * parsedate()
 *
 * Returns:
 *
 * PARSEDATE_OK     - a fine conversion
 * PARSEDATE_FAIL   - failed to convert
 * PARSEDATE_LATER  - time overflow at the far end of time_t
 * PARSEDATE_SOONER - time underflow at the low end of time_t
 */</comment>

<function><specifier>static</specifier> <type><name>int</name></type> <name>parsedate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>date</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wdaynum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* day of the week number, 0-6 (mon-sun) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>monnum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* month of the year number, 0-11 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mdaynum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* day of month, 1 - 31 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hournum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>minnum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>secnum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>yearnum</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tzoff</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>my_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>enum</name> <name>assume</name></name></type> <name>dignext</name> <init>= <expr><name>DATE_MDAY</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indate</name> <init>= <expr><name>date</name></expr></init></decl>;</decl_stmt> <comment type="block">/* save the original pointer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>part</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* max 6 parts */</comment>

  <while>while<condition>(<expr><operator>*</operator><name>date</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>part</name> <operator>&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>found</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>skip_over_white</name><argument_list>(<argument><expr><operator>&amp;</operator><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr><call><name>ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="block">/* a name coming up */</comment>
      <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>EST_CURL_MAX_NAME_STR</name></expr>]</index></name><init>=<expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><literal type="string">"%31[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]"</literal></expr></argument>,
             <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strnlen_s</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>EST_CURL_MAX_NAME_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if<condition>(<expr><name>wdaynum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>wdaynum</name> <operator>=</operator> <call><name>checkday</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>wdaynum</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then>
          <block type="pseudo"><expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></then></if>
      }</block></then></if>
      <if>if<condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>monnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>monnum</name> <operator>=</operator> <call><name>checkmonth</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>monnum</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then>
          <block type="pseudo"><expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></then></if>
      }</block></then></if>

      <if>if<condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>tzoff</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
        <comment type="block">/* this just must be a time zone string */</comment>
        <expr_stmt><expr><name>tzoff</name> <operator>=</operator> <call><name>checktz</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>tzoff</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then>
          <block type="pseudo"><expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></then></if>
      }</block></then></if>

      <if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><then>
        <block type="pseudo"><return>return <expr><name>PARSEDATE_FAIL</name></expr>;</return></block></then></if> <comment type="block">/* bad string */</comment>

      <expr_stmt><expr><name>date</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    }</block></then>
    <elseif>else <if>if<condition>(<expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <comment type="block">/* a digit */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
      <if>if<condition>(<expr><operator>(</operator><name>secnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
         <operator>(</operator><literal type="number">3</literal> <operator>==</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><literal type="string">"%02d:%02d:%02d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hournum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
        <comment type="block">/* time stamp! */</comment>
        <expr_stmt><expr><name>date</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      }</block></then>
      <elseif>else <if>if<condition>(<expr><operator>(</operator><name>secnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><literal type="number">2</literal> <operator>==</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><literal type="string">"%02d:%02d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hournum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
        <comment type="block">/* time stamp without seconds */</comment>
        <expr_stmt><expr><name>date</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>secnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      }</block></then></if></elseif>
      <else>else <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>lval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>old_errno</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>old_errno</name> <operator>=</operator> <name>ERRNO</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_ERRNO</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lval</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <name>ERRNO</name></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>error</name> <operator>!=</operator> <name>old_errno</name></expr>)</condition><then>
          <block type="pseudo"><expr_stmt><expr><call><name>SET_ERRNO</name><argument_list>(<argument><expr><name>old_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

        <if>if<condition>(<expr><name>error</name></expr>)</condition><then>
          <block type="pseudo"><return>return <expr><name>PARSEDATE_FAIL</name></expr>;</return></block></then></if>

        <if>if<condition>(<expr><operator>(</operator><name>lval</name> <operator>&gt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>INT_MAX</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>lval</name> <operator>&lt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>INT_MIN</name><operator>)</operator></expr>)</condition><then>
          <block type="pseudo"><return>return <expr><name>PARSEDATE_FAIL</name></expr>;</return></block></then></if>

        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>curlx_sltosi</name><argument_list>(<argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if<condition>(<expr><operator>(</operator><name>tzoff</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>date</name><operator>)</operator> <operator>==</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><name>val</name> <operator>&lt;=</operator> <literal type="number">1400</literal><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><name>indate</name><operator>&lt;</operator> <name>date</name><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><operator>(</operator><name><name>date</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>date</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator><operator>)</operator></expr>)</condition><then> <block>{
          <comment type="block">/* four digits and a value less than or equal to 1400 (to take into
             account all sorts of funny time zone diffs) and it is preceded
             with a plus or minus. This is a time zone indication.  1400 is
             picked since +1300 is frequently used and +1400 is mentioned as
             an edge number in the document "ISO C 200X Proposal: Timezone
             Functions" at http://david.tribble.com/text/c0xtimezone.html If
             anyone has a more authoritative source for the exact maximum time
             zone offsets, please speak up! */</comment>
          <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>tzoff</name> <operator>=</operator> <operator>(</operator><name>val</name><operator>/</operator><literal type="number">100</literal> <operator>*</operator> <literal type="number">60</literal> <operator>+</operator> <name>val</name><operator>%</operator><literal type="number">100</literal><operator>)</operator><operator>*</operator><literal type="number">60</literal></expr>;</expr_stmt>

          <comment type="block">/* the + and - prefix indicates the local time compared to GMT,
             this we need ther reversed math to get what we want */</comment>
          <expr_stmt><expr><name>tzoff</name> <operator>=</operator> <ternary><condition><expr><name><name>date</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'+'</literal></expr>?</condition><then><expr><operator>-</operator><name>tzoff</name></expr></then><else>:<expr><name>tzoff</name></expr></else></ternary></expr>;</expr_stmt>
        }</block></then></if>

        <if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>date</name><operator>)</operator> <operator>==</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><name>yearnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><name>monnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
           <operator>(</operator><name>mdaynum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
          <comment type="block">/* 8 digits, no year, month or day yet. This is YYYYMMDD */</comment>
          <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>yearnum</name> <operator>=</operator> <name>val</name><operator>/</operator><literal type="number">10000</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>monnum</name> <operator>=</operator> <operator>(</operator><name>val</name><operator>%</operator><literal type="number">10000</literal><operator>)</operator><operator>/</operator><literal type="number">100</literal><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* month is 0 - 11 */</comment>
          <expr_stmt><expr><name>mdaynum</name> <operator>=</operator> <name>val</name><operator>%</operator><literal type="number">100</literal></expr>;</expr_stmt>
        }</block></then></if>

        <if>if<condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dignext</name> <operator>==</operator> <name>DATE_MDAY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>mdaynum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
          <if>if<condition>(<expr><operator>(</operator><name>val</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>val</name><operator>&lt;</operator><literal type="number">32</literal><operator>)</operator></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>mdaynum</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>dignext</name> <operator>=</operator> <name>DATE_YEAR</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if<condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>dignext</name> <operator>==</operator> <name>DATE_YEAR</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>yearnum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>yearnum</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if>if<condition>(<expr><name>yearnum</name> <operator>&lt;</operator> <literal type="number">1900</literal></expr>)</condition><then> <block>{
            <if>if<condition>(<expr><name>yearnum</name> <operator>&gt;</operator> <literal type="number">70</literal></expr>)</condition><then>
              <block type="pseudo"><expr_stmt><expr><name>yearnum</name> <operator>+=</operator> <literal type="number">1900</literal></expr>;</expr_stmt></block></then>
            <else>else
              <block type="pseudo"><expr_stmt><expr><name>yearnum</name> <operator>+=</operator> <literal type="number">2000</literal></expr>;</expr_stmt></block></else></if>
          }</block></then></if>
          <if>if<condition>(<expr><name>mdaynum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then>
            <block type="pseudo"><expr_stmt><expr><name>dignext</name> <operator>=</operator> <name>DATE_MDAY</name></expr>;</expr_stmt></block></then></if>
        }</block></then></if>

        <if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><then>
          <block type="pseudo"><return>return <expr><name>PARSEDATE_FAIL</name></expr>;</return></block></then></if>

        <expr_stmt><expr><name>date</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if></elseif></if>

    <expr_stmt><expr><name>part</name><operator>++</operator></expr>;</expr_stmt>
  }</block></while>

  <if>if<condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <name>secnum</name></expr>)</condition><then>
    <block type="pseudo"><expr_stmt><expr><name>secnum</name> <operator>=</operator> <name>minnum</name> <operator>=</operator> <name>hournum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block></then></if> <comment type="block">/* no time, make it zero */</comment>

  <if>if<condition>(<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <name>mdaynum</name><operator>)</operator> <operator>||</operator>
     <operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <name>monnum</name><operator>)</operator> <operator>||</operator>
     <operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <name>yearnum</name><operator>)</operator></expr>)</condition><then>
    <comment type="block">/* lacks vital info, fail */</comment>
    <block type="pseudo"><return>return <expr><name>PARSEDATE_FAIL</name></expr>;</return></block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_TIME_T</name> <operator>&lt;</operator> <literal type="number">5</literal></expr></cpp:if>
  <comment type="block">/* 32 bit time_t can only hold dates to the beginning of 2038 */</comment>
  <if>if<condition>(<expr><name>yearnum</name> <operator>&gt;</operator> <literal type="number">2037</literal></expr>)</condition><then> <block>{
    <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
    <return>return <expr><name>PARSEDATE_LATER</name></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>(<expr><name>yearnum</name> <operator>&lt;</operator> <literal type="number">1970</literal></expr>)</condition><then> <block>{
    <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>PARSEDATE_SOONER</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>(<expr><operator>(</operator><name>mdaynum</name> <operator>&gt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>monnum</name> <operator>&gt;</operator> <literal type="number">11</literal><operator>)</operator> <operator>||</operator>
     <operator>(</operator><name>hournum</name> <operator>&gt;</operator> <literal type="number">23</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>minnum</name> <operator>&gt;</operator> <literal type="number">59</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>secnum</name> <operator>&gt;</operator> <literal type="number">60</literal><operator>)</operator></expr>)</condition><then>
    <block type="pseudo"><return>return <expr><name>PARSEDATE_FAIL</name></expr>;</return></block></then></if> <comment type="block">/* clearly an illegal date */</comment>

  <expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <name>secnum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <name>minnum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <name>hournum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <name>mdaynum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <name>monnum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <name>yearnum</name> <operator>-</operator> <literal type="number">1900</literal></expr>;</expr_stmt>

  <comment type="block">/* my_timegm() returns a time_t. time_t is often 32 bits, even on many
     architectures that feature 64 bit 'long'.

     Some systems have 64 bit time_t and deal with years beyond 2038. However,
     even on some of the systems with 64 bit time_t mktime() returns -1 for
     dates beyond 03:14:07 UTC, January 19, 2038. (Such as AIX 5100-06)
  */</comment>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>my_timegm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* time zone adjust (cast t to int to compare to negative one) */</comment>
  <if>if<condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>t</name></expr>)</condition><then> <block>{

    <comment type="block">/* Add the time zone diff between local time zone and GMT. */</comment>
    <decl_stmt><decl><type><name>long</name></type> <name>delta</name> <init>= <expr><call>(<name>long</name>)<argument_list>(<argument><expr><ternary><condition><expr><name>tzoff</name><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr>?</condition><then><expr><name>tzoff</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if<condition>(<expr><operator>(</operator><name>delta</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>t</name> <operator>+</operator> <name>delta</name> <operator>&lt;</operator> <name>t</name><operator>)</operator></expr>)</condition><then>
      <block type="pseudo"><return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block></then></if> <comment type="block">/* time_t overflow */</comment>

    <expr_stmt><expr><name>t</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

  <return>return <expr><name>PARSEDATE_OK</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * This table maps an EST operation to the expected
 * URI and HTTP content type.  It's used to verify that
 * the response from the server meets the EST draft.  This
 * table is implicitly tied to EST_OPERATION.  If that ENUM
 * changes, this table must change.
 */</comment>
<decl_stmt><decl><type><name>EST_OP_DEF</name></type> <name><name>est_op_map</name> <index>[<expr><name>EST_OP_MAX</name></expr>]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><name>EST_OP_SIMPLE_ENROLL</name></expr>,   <expr><name>EST_SIMPLE_ENROLL_URI</name></expr>, <expr><name>EST_HTTP_CT_PKCS7_CO</name></expr>, <expr>sizeof<operator>(</operator><name>EST_HTTP_CT_PKCS7_CO</name><operator>)</operator></expr> }</block></expr>,
    <expr><block>{ <expr><name>EST_OP_SIMPLE_REENROLL</name></expr>, <expr><name>EST_RE_ENROLL_URI</name></expr>,     <expr><name>EST_HTTP_CT_PKCS7_CO</name></expr>, <expr>sizeof<operator>(</operator><name>EST_HTTP_CT_PKCS7_CO</name><operator>)</operator></expr> }</block></expr>,
    <expr><block>{ <expr><name>EST_OP_CACERTS</name></expr>,         <expr><name>EST_CACERTS_URI</name></expr>,       <expr><name>EST_HTTP_CT_PKCS7</name></expr>,    <expr>sizeof<operator>(</operator><name>EST_HTTP_CT_PKCS7</name><operator>)</operator></expr>    }</block></expr>,
    <expr><block>{ <expr><name>EST_OP_CSRATTRS</name></expr>,        <expr><name>EST_CSR_ATTRS_URI</name></expr>,     <expr><name>EST_HTTP_CT_CSRATTRS</name></expr>, <expr>sizeof<operator>(</operator><name>EST_HTTP_CT_CSRATTRS</name><operator>)</operator></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/**********************************************************************
 * The following function was taken from libwww and is used
 * for parsing the HTTP header.
 *********************************************************************/</comment>
<comment type="block">/*	Find next Field
**	---------------
**	Finds the next RFC822 token in a string
**	On entry,
**	*pstr	points to a string containing a word separated
**		by white white space "," ";" or "=". The word
**		can optionally be quoted using &lt;"&gt; or "&lt;" "&gt;"
**		Comments surrrounded by '(' ')' are filtered out
**
**  On exit,
**	*pstr	has been moved to the first delimiter past the
**		field
**		THE STRING HAS BEEN MUTILATED by a 0 terminator
**
**	Returns	a pointer to the first word or NULL on error
*/</comment>
<function><specifier>static</specifier> <type><name>char</name> <modifier>*</modifier></type> <name>HTNextField</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>pstr</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><operator>!</operator><name>pstr</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>pstr</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pstr</name></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{
        <comment type="block">/* Strip white space and other delimiters */</comment>
        <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>)</condition> <block>{
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><operator>*</operator><name>pstr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>                                         <comment type="block">/* No field */</comment>
        }</block></then></if>

        <if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><then> <block>{                                     <comment type="block">/* quoted field */</comment>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>
            <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>                               <comment type="block">/* Skip escaped chars */</comment>
                }</block></then></if>
            }</block></for>
            <break>break;</break>                          <comment type="block">/* kr95-10-9: needs to stop here */</comment>
        }</block></then> <elseif>else <if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><then> <block>{             <comment type="block">/* quoted field */</comment>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>
            <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'&gt;'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>                               <comment type="block">/* Skip escaped chars */</comment>
                }</block></then></if>
            }</block></for>
            <break>break;</break>                          <comment type="block">/* kr95-10-9: needs to stop here */</comment>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><then> <block>{             <comment type="block">/* Comment */</comment>
            <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">')'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{
                <if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>                               <comment type="block">/* Skip escaped chars */</comment>
                }</block></then></if>
            }</block></for>
            <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{                                              <comment type="block">/* Spool field */</comment>
            <expr_stmt><expr><name>start</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">';'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition> <block>{
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            }</block></while>
            <break>break;</break>                                                 <comment type="block">/* Got it */</comment>
        }</block></else></if>
    }</block></while>
    <if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><operator>*</operator><name>pstr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <return>return <expr><name>start</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int est_strcasecmp_s (char *s1, char *s2)
{
    errno_t safec_rc;
    int diff;
    
    safec_rc = strcasecmp_s(s1, strnlen_s(s1, RSIZE_MAX_STR), s2, &amp;diff);

    if (safec_rc != EOK) {
    	<comment type="block">/*
    	 * Log that we encountered a SafeC error
     	 */</comment>
     	EST_LOG_INFO("strcasecmp_s error 0x%xO\n", safec_rc);
    } 

    return diff;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * This function parses the authentication tokens from
 * the server when the server is requesting HTTP digest
 * authentication.  The tokens are required to generate
 * a valid authentication response in future HTTP
 * requests.
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_io_parse_auth_tokens</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>hdr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errno_t</name></type> <name>safec_rc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * header will come in with the basic or digest field still on the front.
     * skip over it.
     */</comment>

    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>token</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{
        <if>if <condition>(<expr><operator>!</operator><call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"realm"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>realm</name></name></expr></argument>, <argument><expr><name>MAX_REALM</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_REALM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"nonce"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>s_nonce</name></name></expr></argument>, <argument><expr><name>MAX_NONCE</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_NONCE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
                }</block></then></if>                
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"qop"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{

                <if>if <condition>(<expr><name><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Unsupported qop value: %s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>memcmp_s</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"auth"</literal></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"auth"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"auth"</literal></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"memcmp_s error 0x%xO\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>diff</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>safec_rc</name> <operator>==</operator> <name>EOK</name><operator>)</operator></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Unsupported qop value: %s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"algorithm"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unsupported digest algorithm: %s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 **  We only support MD5 for the moment
                 */</comment>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error</name></name></expr></argument>, <argument><expr><name>MAX_TOKEN_ERROR</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_TOKEN_ERROR</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>est_strcasecmp_s</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"error_description"</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>HTNextField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>EOK</name> <operator>!=</operator> <call><name>strncpy_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>token_error_desc</name></name></expr></argument>, <argument><expr><name>MAX_TOKEN_ERROR_DESC</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>MAX_TOKEN_ERROR_DESC</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Unsupported auth token ignored: %s"</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>EST_ERR_INVALID_TOKEN</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>s_nonce</name></name></expr></argument>, <argument><expr><name>MAX_NONCE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>   
    }</block></while>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/**********************************************************************
 * The following function is derived from Mongoose.  The Mongoose
 * copyright is included. This is used to parse the HTTP headers
 * that are received from the server.
 *
   Copyright (c) 2004-2012 Sergey Lyubka

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   THE SOFTWARE.

 *
 *********************************************************************/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>          <comment type="line">// HTTP header name</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>         <comment type="line">// HTTP header value</comment>
}</block></struct></type> <name>HTTP_HEADER</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_HEADERS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_HEADER_DELIMITER_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<function><specifier>static</specifier> <type><name>HTTP_HEADER</name> <modifier>*</modifier></type> <name>parse_http_headers</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_headers</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTTP_HEADER</name> <modifier>*</modifier></type><name>hdrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hdr_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errno_t</name></type> <name>safec_rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>num_headers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdrs</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HTTP_HEADER</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_HEADERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><operator>!</operator><name>hdrs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"malloc failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Find offset of header deliminter
     */</comment>
    <expr_stmt><expr><name>safec_rc</name> <operator>=</operator> <call><name>strstr_s</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>RSIZE_MAX_STR</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><literal type="string">"\r\n\r\n"</literal></expr></argument>, <argument><expr><name>MAX_HEADER_DELIMITER_LEN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>safec_rc</name> <operator>!=</operator> <name>EOK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"strstr_s error 0x%xO\n"</literal></expr></argument>, <argument><expr><name>safec_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Skip the first line
     */</comment>
    <expr_stmt><expr><call><name>skip</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_HEADERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <expr_stmt><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>skip_quoted</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>skip</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Found HTTP header -&gt; %s:%s"</literal></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><operator>*</operator><name>num_headers</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>buf</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>hdr_end</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Found %d HTTP headers\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>num_headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>hdrs</name><operator>)</operator></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function parses the HTTP status code
 * in the first header.  Only a handful of codes are
 * handled by EST.  We are not a full HTTP stack.  Any
 * unrecognized codes will result in an error.
 * Note that HTTP 1.1 is expected.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_io_parse_response_status_code</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{
    <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_200</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_200</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">200</literal></expr>;</return>
    }</block></then> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_202</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_202</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">202</literal></expr>;</return>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_204</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_204</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">204</literal></expr>;</return>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_400</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_400</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">400</literal></expr>;</return>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_401</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_401</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">401</literal></expr>;</return>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_404</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_404</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">404</literal></expr>;</return>
    }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_423</name></expr></argument>,
                        <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name>EST_HTTP_HDR_423</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><literal type="number">423</literal></expr>;</return>
    }</block></then></if></elseif> <else>else <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unhandled HTTP response %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></else></if>
}</block></function>


<comment type="block">/*
 * This function searches for and processes the WWW-Authenticate header from
 * the server.  The result is the setting of the auth_mode value in the
 * context.  If there is no WWW-Authenticate header, or the values in the
 * header are invalid, it will set the auth_mode to a failure setting.  If
 * there are multiple Authenticate headers, only the first one will be
 * processed.
 */</comment>
<function><specifier>static</specifier> <type><name>void</name></type> <name>est_io_parse_http_auth_request</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                            <parameter><decl><type><name>HTTP_HEADER</name> <modifier>*</modifier></type><name>hdrs</name></decl></parameter>,
                                            <parameter><decl><type><name>int</name></type> <name>hdr_cnt</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>auth_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Walk the headers looking for the WWW-Authenticate.  We'll
     * only process the first one.  If an erroneous second one
     * is included, it will be ignored.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hdr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>EST_HTTP_HDR_AUTH</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

            <expr_stmt><expr><name>auth_found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            
            <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"Basic"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_BASIC</name></expr>;</expr_stmt>
                <comment type="block">/* Parse the realm */</comment>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_parse_auth_tokens</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
                }</block></then></if>    
            }</block></then> <elseif>else
            <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"Digest"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_DIGEST</name></expr>;</expr_stmt>
                <comment type="block">/* Parse the realm and nonce */</comment>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_parse_auth_tokens</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
                }</block></then></if>    
            }</block></then></if></elseif> <elseif>else <if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"Bearer"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_TOKEN</name></expr>;</expr_stmt>
                <comment type="block">/* Parse the realm and possible token error fields */</comment>
                <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_parse_auth_tokens</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
                }</block></then></if>    
            }</block></then></if></elseif> <else>else <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unsupported WWW-Authenticate method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
            }</block></else></if>

            <break>break;</break>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><operator>!</operator><name>auth_found</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"No WWW-Authenticate header found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
    }</block></then></if>    
    <return>return;</return>
}</block></function>

<comment type="block">/*
 * This function takes in the list of headers that were in the server's
 * response, it walks through the headers looking for a Retry-After response
 * header.  If one is found, the value is parsed and saved away in the EST
 * context.  This value can be in one of two formats, both are represented as
 * an ASCII string.  The first format can be a count of the number of seconds
 * the client should wait before retrying the request.  The second format is a
 * time/date stamp of the point in time at which the client should retry the
 * request.  The result of this function is the setting of the retry_after
 * values in the context.  If no retry-after header was received, or was
 * received and could not be parsed, the values will be zero, otherwise, they
 * are set to the value received.
 *
 * NOTE: The EST client currently does not support the time/date format
 * response and will not process a response in this format.
 */</comment>
<function><specifier>static</specifier> <type><name>EST_ERROR</name></type> <name>est_io_parse_http_retry_after_resp</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                                     <parameter><decl><type><name>HTTP_HEADER</name> <modifier>*</modifier></type><name>hdrs</name></decl></parameter>,
                                                     <parameter><decl><type><name>int</name></type> <name>hdr_cnt</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>EST_ERROR</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_INVALID_RETRY_VALUE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp_result</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name> <name>long</name> <name>int</name></type> <name>temp_ll</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/*
     * Initialize assuming there was no retry-after header.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_delay</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_date</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hdr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        
        <expr_stmt><expr><name>cmp_result</name> <operator>=</operator> <call><name>strcasecmp_s</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_HTTP_HDR_RETRY_AFTER</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                  <argument><expr><name>EST_HTTP_HDR_RETRY_AFTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>cmp_result</name> <operator>==</operator> <name>EOK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>diff</name></expr>)</condition><then> <block>{
            
            <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Retry-After value = %s"</literal></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <comment type="block">/*
             * Determine whether or not the value is a date/time string
             * or is an integer representing the number of seconds
             * that the client must wait.
             */</comment>
            <if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RETRY_AFTER_DELAY_TIME_SUPPORT</name></cpp:ifdef>
                <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
                <comment type="block">/*
                 * Convert the date/time string into a time_t
                 */</comment>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parsedate</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PARSEDATE_OK</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retry-After value could not be parsed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <comment type="block">/*
                 * This format is not currently supported.
                 */</comment>
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retry-After value not in the correct format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                
            }</block></then> <else>else <block>{
                <comment type="block">/*
                 * make sure it's all digits, make sure it's no larger than a
                 * four byte integer, and cache away the value returned for
                 * the retry delay.
                 */</comment>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>strisdigit_s</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// max of 10 decimal places</comment>
                <if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>temp_ll</name> <operator>=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>temp_ll</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>retry_after_delay</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>temp_ll</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_CA_ENROLL_RETRY</name></expr>;</expr_stmt>
                    }</block></then> <else>else <block>{
                        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retry-After value too large"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retry-After value could not be parsed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
        }</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>found</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Retry-After header missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>    
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * This function verifies the content type header and also
 * returns the length of the content header.  The
 * content type is important.  For example, the content
 * type is expected to be pkcs7 on a simple enrollment.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_io_check_http_hdrs</name> <parameter_list>(<parameter><decl><type><name>HTTP_HEADER</name> <modifier>*</modifier></type><name>hdrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hdr_cnt</name></decl></parameter>,
                                   <parameter><decl><type><name>EST_OPERATION</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>content_type_present</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>content_length_present</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp_result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Traverse all the http headers and process the ones that need to be
     * checked
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hdr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{
        <comment type="block">/*
         * Content type
         */</comment>
        <expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_HTTP_HDR_CT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>EST_HTTP_HDR_CT</name></expr></argument>,
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_HTTP_HDR_CT</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmp_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><operator>!</operator><name>cmp_result</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>content_type_present</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <comment type="block">/*
             * Verify content is pkcs7 data
             */</comment>
            <expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
                     <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>est_op_map</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>content_type</name></expr></argument>, <argument><expr><name><name>est_op_map</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>length</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name><name>est_op_map</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>content_type</name></expr></argument>, <argument><expr><call><name>strnlen_s</name><argument_list>(<argument><expr><name><name>est_op_map</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>content_type</name></expr></argument>, <argument><expr><name><name>est_op_map</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>length</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>cmp_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>cmp_result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP content type is %s"</literal></expr></argument>, <argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
                }</block></then></if>
        }</block></then> <else>else <block>{
            <comment type="block">/*
             * Content Length
             */</comment>
            <expr_stmt><expr><call><name>memcmp_s</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EST_HTTP_HDR_CL</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmp_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><operator>!</operator><name>cmp_result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>content_length_present</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name><name>hdrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></for>
    
    <comment type="block">/*
     * Make sure all the necessary headers were present.
     */</comment>
    <if>if <condition>(<expr><name>content_type_present</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Missing HTTP content type  header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then> <elseif>else <if>if <condition>(<expr><name>content_length_present</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Missing HTTP content length header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    }</block></then></if></elseif></if> 
    
    <return>return <expr><name>cl</name></expr>;</return>
}</block></function>


<function><specifier>static</specifier> <type><name>int</name></type> <name>est_ssl_read</name> <parameter_list>(<parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_max</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>sock_read_timeout</name></decl></parameter>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>read_fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pfd</name></decl>;</decl_stmt>
    
    <comment type="block">/*
     * load up the timeval struct to be passed to the select
     */</comment>
    <expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>sock_read_timeout</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>read_fd</name> <operator>=</operator> <call><name>SSL_get_fd</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>read_fd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pfd</name><operator>.</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>POLL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Socket poll timeout.  No data received from server."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></then> <elseif>else <if>if <condition>( <expr><name>rv</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Socket read failure. errno = %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    }</block></then></if></elseif> <else>else <block>{
        <return>return <expr><operator>(</operator><call><name>SSL_read</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_max</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    }</block></else></if>
}</block></function>


<comment type="block">/*
 * This function extracts data from the SSL context and puts
 * it into a buffer.
 */</comment>
<function><specifier>static</specifier> <type><name>int</name></type> <name>est_io_read_raw</name> <parameter_list>(<parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buf_max</name></decl></parameter>,
                            <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>read_cnt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sock_read_timeout</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>cur_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>peek_read_buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>read_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur_cnt</name>  <operator>=</operator> <call><name>est_ssl_read</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_max</name></expr></argument>, <argument><expr><name>sock_read_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cur_cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"TLS read error 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_SSL_READ</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><operator>*</operator><name>read_cnt</name> <operator>+=</operator> <name>cur_cnt</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Multiple calls to SSL_read may be required to get the full
     * HTTP payload.
     */</comment>
    <while>while <condition>(<expr><name>cur_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>read_cnt</name> <operator>&lt;</operator> <name>buf_max</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>cur_cnt</name> <operator>=</operator> <call><name>est_ssl_read</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><operator>(</operator><name>buf</name> <operator>+</operator> <operator>*</operator><name>read_cnt</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>buf_max</name> <operator>-</operator> <operator>*</operator><name>read_cnt</name><operator>)</operator></expr></argument>,
                               <argument><expr><name>sock_read_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>cur_cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"TLS read error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>ossl_dump_ssl_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>EST_ERR_SSL_READ</name><operator>)</operator></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><operator>*</operator><name>read_cnt</name> <operator>+=</operator> <name>cur_cnt</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>read_cnt</name> <operator>==</operator> <name>buf_max</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>SSL_peek</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peek_read_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Buffer too small for received message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return<expr><operator>(</operator><name>EST_ERR_READ_BUFFER_TOO_SMALL</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    
    <return>return <expr><operator>(</operator><name>EST_ERR_NONE</name><operator>)</operator></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function provides the primary entry point into
 * this module.  It's used by the EST client to read the
 * HTTP response from the server.  The data is read from
 * the SSL context and HTTP parsing is invoked.
 *
 * If EST_ERR_NONE is returned then the raw_buf buffer must
 * be freed by the caller, otherwise, it is freed here.
 */</comment>
<function><type><name>EST_ERROR</name></type> <name>est_io_get_response</name> <parameter_list>(<parameter><decl><type><name>EST_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>EST_OPERATION</name></type> <name>op</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>payload_len</name></decl></parameter>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><name>EST_ERR_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTTP_HEADER</name> <modifier>*</modifier></type><name>hdrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hdr_cnt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>http_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>raw_buf</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>payload_buf</name></decl>, <modifier>*</modifier><decl><type ref="prev"/><name>payload</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type> <name>raw_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    

    <expr_stmt><expr><name>raw_buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>EST_CA_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>raw_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memzero_s</name><argument_list>(<argument><expr><name>raw_buf</name></expr></argument>, <argument><expr><name>EST_CA_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>payload</name> <operator>=</operator> <name>raw_buf</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Read the raw data from the SSL connection
     */</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_read_raw</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>raw_buf</name></expr></argument>, <argument><expr><name>EST_CA_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raw_len</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>read_timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"No valid response to process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>raw_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>raw_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>EST_LOG_WARN</name><argument_list>(<argument><expr><literal type="string">"Received empty HTTP response from server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>raw_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>EST_ERR_HTTP_NOT_FOUND</name><operator>)</operator></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"Read %d bytes of HTTP data"</literal></expr></argument>, <argument><expr><name>raw_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Parse the HTTP header to get the status
     * Look for status 200 for success
     */</comment>
    <expr_stmt><expr><name>http_status</name> <operator>=</operator> <call><name>est_io_parse_response_status_code</name><argument_list>(<argument><expr><name>raw_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>last_http_status</name></name> <operator>=</operator> <name>http_status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdrs</name> <operator>=</operator> <call><name>parse_http_headers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>payload</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP status %d received"</literal></expr></argument>, <argument><expr><name>http_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check the Status header first to see
     * if the server accepted our request.
     */</comment>
    <switch>switch <condition>(<expr><name>http_status</name></expr>)</condition> <block>{
    <case>case <expr><literal type="number">200</literal></expr>:</case>
        <comment type="block">/* Server reported OK, nothing to do */</comment>
        <break>break;</break>
    <case>case <expr><literal type="number">204</literal></expr>:</case>
    <case>case <expr><literal type="number">404</literal></expr>:</case>
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Server responded with 204/404, no content or not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>EST_OP_CSRATTRS</name></expr>)</condition><then> <block>{
	    <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_NONE</name></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><name>http_status</name> <operator>==</operator> <literal type="number">404</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_HTTP_NOT_FOUND</name></expr>;</expr_stmt>            
        }</block></then></if></elseif> <else>else <block>{
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_UNKNOWN</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
    <case>case <expr><literal type="number">202</literal></expr>:</case>
        <comment type="block">/* Server is asking for a retry */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"EST server responded with retry-after"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>est_io_parse_http_retry_after_resp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hdrs</name></expr></argument>, <argument><expr><name>hdr_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><literal type="number">400</literal></expr>:</case>
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP response from EST server was BAD REQUEST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_HTTP_BAD_REQ</name></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><literal type="number">401</literal></expr>:</case>
        <comment type="block">/* Server is requesting user auth credentials */</comment>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"EST server requesting user authentication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Check if we've already tried authenticating, if so, then bail
         * First time through, auth_mode will be set to NONE
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_DIGEST</name> <operator>||</operator>
            <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_BASIC</name> <operator>||</operator>
            <name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>==</operator> <name>AUTH_TOKEN</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>auth_mode</name></name> <operator>=</operator> <name>AUTH_FAIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_AUTH_FAIL</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><call><name>est_io_parse_http_auth_request</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hdrs</name></expr></argument>, <argument><expr><name>hdr_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_AUTH_FAIL</name></expr>;</expr_stmt>
        <break>break;</break>
            
    <case>case <expr><literal type="number">423</literal></expr>:</case>
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Server responded with 423, the content we are attempting to access is locked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_HTTP_LOCKED</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
        <comment type="block">/* Unsupported HTTP response */</comment>
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unsupported HTTP response from EST server (%d)"</literal></expr></argument>, <argument><expr><name>http_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_UNKNOWN</name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <comment type="block">/* Some other HTTP response was given, do we want to handle these? */</comment>
        <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"HTTP response from EST server was %d"</literal></expr></argument>, <argument><expr><name>http_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_HTTP_UNSUPPORTED</name></expr>;</expr_stmt>
        <break>break;</break>
    }</block></switch>

    <if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>EST_ERR_NONE</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Get the Content-Type and Content-Length headers
         * and verify the HTTP response contains the correct amount
         * of data.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>payload_len</name> <operator>=</operator> <call><name>est_io_check_http_hdrs</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr><name>hdr_cnt</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EST_LOG_INFO</name><argument_list>(<argument><expr><literal type="string">"HTTP Content len=%d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>payload_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><operator>*</operator><name>payload_len</name> <operator>&gt;</operator> <name>EST_CA_MAX</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Content Length larger than maximum value of %d."</literal></expr></argument>,
                        <argument><expr><name>EST_CA_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> <operator>=</operator> <name>EST_ERR_UNKNOWN</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>payload_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <elseif>else <if>if <condition>(<expr><operator>*</operator><name>payload_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
            <expr_stmt><expr><operator>*</operator><name>payload_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if></elseif> <else>else <block>{
            <comment type="block">/*
             * Allocate the buffer to hold the payload to be passed back
             */</comment>
            <expr_stmt><expr><name>payload_buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>*</operator><name>payload_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
            <if>if <condition>(<expr><operator>!</operator><name>payload_buf</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>EST_LOG_ERR</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>raw_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>EST_ERR_MALLOC</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>payload_buf</name></expr></argument>, <argument><expr><operator>*</operator><name>payload_len</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>, <argument><expr><operator>*</operator><name>payload_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>payload_buf</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>raw_buf</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>raw_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>hdrs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
}</block></function>
</unit>
