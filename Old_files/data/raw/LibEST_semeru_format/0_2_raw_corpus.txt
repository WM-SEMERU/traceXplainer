REQUIREMENT 38: SIMPLE ENROLL AND RE-ENROLL RESPONSE
     
If the enrollment is successful, the server response MUST contain an HTTP 200 response code with a content-type of "application/pkcs7-mime".

A successful response MUST be a certs-only CMC Simple PKI Response, as defined in [RFC5272], containing only the certificate that was issued. The HTTP content-type of "application/pkcs7-mime" with an smime-type parameter "certs-only" is used, as specified in [RFC5273].

The server MUST answer with a suitable 4xx or 5xx HTTP [RFC2616] error code when a problem occurs. A Simple PKI Response with an HTTP content-type of "application/pkcs7-mime" (see Section 4.3.2) MAY be included in the response data to convey an error response. If the content-type is not set, the response data MUST be a plaintext human- readable error message containing explanatory information describing why the request was rejected (for example, indicating that CSR attributes are incomplete).

If the server responds with an HTTP [RFC2616] 202, this indicates that the request has been accepted for processing but that a response is not yet available. The server MUST include a Retry-After header as defined for HTTP 503 responses. The server also MAY include informative human-readable content. The client MUST wait at least the specified "retry-after" time before repeating the same request. The client repeats the initial enrollment request after the appropriate "retry-after" interval has expired. The client SHOULD log or inform the end-user of this event. The server is responsible for maintaining all states necessary to recognize and handle retry operations as the client is stateless in this regard; it simply sends the same request repeatedly until it receives a different response code. All other return codes are handled as specified in HTTP [RFC2616].

If the client closes the TLS connections while waiting for the Retry- After time to expire, then the client initiates a new TLS connection and performs all applicable security checks. If the client has already generated a CSR that includes linking identity and POP information (Section 3.5), then the CSR will need to be recreated to incorporate the tls-unique from the new, redirected session. Note: the key pair need not be regenerated. These are processing and interface burdens on the client. EST server administrators are advised to take this into consideration.

The EST client MAY also make the certificate response, and associated private key, available to end-entity software for use as an end-entity certificate.
REQUIREMENT 10: SERVER KEY GENERATION
     
The EST client can request a server-generated certificate and key pair (see Section 4.4).
REQUIREMENT 11: FULL PKI REQUEST MESSAGES
     
Full PKI Request [RFC5272] messages can be transported via EST using the Full CMC Request function. This affords access to functions not provided by the Simple Enrollment functions. Full PKI Request messages are defined in Sections 3.2 and 4.2 of [RFC5272]. See Section 4.3 for a discussion of how EST provides a transport for these messages.
REQUIREMENT 39: FULL CMC
     
An EST client can request a certificate from an EST server with an HTTPS POST using the operation path value of "/fullcmc". Support for the /fullcmc function is OPTIONAL for both clients and servers.
REQUIREMENT 13: PROTOCOL DESIGN AND LAYERING
     
Figure 2 provides an expansion of Figure 1, describing how the layers are used. Each aspect is described in more detail in the sections that follow.

EST Layering:

Protocols and uses:


   +----------------------------------------------------+
   |                                                    |
   | Message types:                                     |
   |   - "Simple PKI" messages                          |
   |     (incorporates proof-of-possession)             |
   |   - CA certificate retrieval                       |
   |   - "Full PKI" messages (OPTIONAL)                 |
   |     (incorporates proof-of-possession)             |
   |   - CSR Attributes Request (OPTIONAL)              |
   |   - Server-generated key request (OPTIONAL)        |
   |                                                    |
   +----------------------------------------------------+
   |                                                    |
   | HTTP:                                              |
   |   - HTTP headers and URIs for control              |
   |      - Content-Type headers specify message type   |
   |      - Headers for control/error messages          |
   |      - URIs for selecting functions                |
   |   - Basic or Digest authentication (OPTIONAL)      |
   |                                                    |
   +----------------------------------------------------+
   |                                                    |
   | TLS for transport security:                        |
   |   - Authentication of the EST server               |
   |   - Authentication of the EST client (OPTIONAL)    |
   |   - Provides communications integrity              |
   |     and confidentiality                            |
   |   - Supplies channel-binding [RFC5929] information |
   |     to link proof-of-identity with message-based   |
   |     proof-of-possession (OPTIONAL)                 |
   |                                                    |
   +----------------------------------------------------+

                                 Figure 2

                
Specifying HTTPS as the secure transport for enrollment messages introduces two "layers" to communicate authentication and control messages: TLS and HTTP.

The TLS layer provides integrity and confidentiality during transport. The proof-of-identity is supplied by TLS handshake authentication and optionally also by the HTTP layer headers. The message type and control/error messages are included in the HTTP headers.

CMC ([RFC5272], Section 3.1) notes that "the Simple PKI Request MUST NOT be used if a proof-of-identity needs to be included". Since the TLS and HTTP layers can provide proof-of-identity for EST clients and servers, the Simple PKI message types are used.

The TLS layer certificate exchange provides a method for authorizing client enrollment requests using existing certificates. Such certificates may have been issued by the CA (from which the client is requesting a certificate), or they may have been issued under a distinct PKI (e.g., an IEEE 802.1AR Initial Device Identifier (IDevID) [IDevID] credential).

Proof-of-possession (POP) is a distinct issue from proof-of-identity and is included in the Simple PKI message type as described in Section 3.4. A method of linking proof-of-identity and proof-of-possession is described in Section 3.5.

This document also defines transport for CMC [RFC5272] that complies with the CMC Transport Protocols [RFC5273]. CMC's POP and proof-of-identity mechanisms are defined in CMC, but the mechanisms here can also be used in conjunction with those mechanisms in "Full PKI" messages.

During protocol exchanges, different certificates can be used. The following table provides an informative overview. End-entities can have one or more certificates of each type listed in Figure 3 and use one or more trust anchor databases of each type listed in Figure 4.

Certificates and their corresponding uses:


   +--------------+--------------------+-------------------------------+
   | Certificate  | Issuer             | Use and section references    |
   +==============+====================+===============================+
   | EST server   | The CA served by   | Presented by the EST server   |
   | certificate  | the EST server     | during the TLS handshake.     |
   |              |                    |                               |
   |              |                    | Section 3.3.1                 |
   +--------------+--------------------+-------------------------------+
   | EST server   | A CA               | Presented by the EST server   |
   | certificate  | authenticatable by | during the TLS handshake.     |
   |              | a third-party TA,  |                               |
   |              | e.g., a web server | Section 3.3.1 and             |
   |              | CA                 | Security Considerations       |
   +--------------+--------------------+-------------------------------+
   | Third-party  | A CA               | Presented by the EST client   |
   | EST client   | authenticatable by | to the EST server by clients  |
   | certificate  | a third-party TA,  | that have not yet enrolled.   |
   |              | e.g., a device     |                               |
   |              | manufacturer       | Section 3.3.2                 |
   +--------------+--------------------+-------------------------------+
   | EST client   | The CA served by   | Presented to the EST server   |
   | certificate  | the EST server     | during future EST operations. |
   |              |                    |                               |
   |              |                    | Section 3.3.2                 |
   +--------------+--------------------+-------------------------------+
   | End-entity   | The CA served by   | Clients can obtain certs      |
   | certificate  | the EST server     | that are intended for         |
   |              |                    | non-EST uses.  This includes  |
   |              |                    | certs that cannot be used     |
   |              |                    | for EST operations.           |
   |              |                    |                               |
   |              |                    | Section 4.2.3                 |
   +--------------+--------------------+-------------------------------+


                                 Figure 3

                
Trust anchor databases and their corresponding uses:

  

   +--------------+----------------------------------------------------+
   | TA database  | Use and section references                         |
   +==============+====================================================+
   | EST server   | EST servers use this TA database to authenticate   |
   | Explicit     | certificates issued by the EST CA, including EST   |
   | TA database  | client certificates during enroll/re-enroll        |
   |              | operations.                                        |
   |              |                                                    |
   |              | Section 3.3.2                                      |
   +--------------+----------------------------------------------------+
   | EST server   | EST servers use this TA database to authenticate   |
   | Implicit     | certificates issued by third-party TAs;            |
   | TA database  | e.g., EST client certificates issued by a device   |
   |              | manufacturer.                                      |
   |              | An Implicit TA database can be disabled.           |
   |              |                                                    |
   |              | Section 3.3.2                                      |
   +--------------+----------------------------------------------------+
   | EST client   | EST clients use this TA database to authenticate   |
   | Explicit     | certificates issued by the EST CA, including EST   |
   | TA database  | server certificates.                               |
   |              |                                                    |
   |              | Sections 3.1, 3.3.1, 3.6.1, and 4.1.1              |
   +--------------+----------------------------------------------------+
   | EST client   | EST clients use this TA database to                |
   | Implicit     | authenticate an EST server that uses an externally |
   | TA database  | issued certificate.                                |
   |              | An Implicit TA database can be disabled.           |
   |              |                                                    |
   |              | Sections 3.1, 3.3.1, 3.6.2, and                    |
   |              | Security Considerations                            |
   +--------------+----------------------------------------------------+


                                 Figure 4

  
REQUIREMENT 16: HTTP HEADERS FOR CONTROL
     
The HTTP Status value is used to communicate success or failure of an EST function. HTTP authentication is used by a client when requested by the server.

The media types specified in the HTTP Content-Type header indicate which EST message is being transferred. Media types used by EST are specified in Section 3.2.4.

HTTP redirections (3xx status codes) to the same web origin (see [RFC6454]) SHOULD be handled by the client without user input so long as all applicable security checks (Sections 3.3 and 3.6) have been enforced on the initial connection. The client initiates a new TLS connection and performs all applicable security checks when redirected to other web origin servers. Redirections to other web origins require the EST client to obtain user input for non-GET or HEAD requests as specified in [RFC2616]. Additionally, if the client has already generated a CSR that includes linking identity and POP information (Section 3.5), then the CSR will need to be recreated to incorporate the tls-unique from the new, redirected session. Note: the key pair need not be regenerated. These are processing and interface burdens on the client. EST server administrators are advised to take this into consideration.
REQUIREMENT 17: HTTP URIS FOR CONTROL
     
The EST server MUST support the use of the path-prefix of "/.well- known/" as defined in [RFC5785] and the registered name of "est". Thus, a valid EST server URI path begins with "https://www.example.com/.well-known/est". Each EST operation is indicated by a path-suffix that indicates the intended operation:

Operations and their corresponding URIs:


   +------------------------+-----------------+-------------------+
   | Operation              |Operation path   | Details           |
   +========================+=================+===================+
   | Distribution of CA     | /cacerts        | Section 4.1       |
   | Certificates (MUST)    |                 |                   |
   +------------------------+-----------------+-------------------+
   | Enrollment of          | /simpleenroll   | Section 4.2       |
   | Clients (MUST)         |                 |                   |
   +------------------------+-----------------+-------------------+
   | Re-enrollment of       | /simplereenroll | Section 4.2.2     |
   | Clients (MUST)         |                 |                   |
   +------------------------+-----------------+-------------------+
   | Full CMC (OPTIONAL)    | /fullcmc        | Section 4.3       |
   +------------------------+-----------------+-------------------+
   | Server-Side Key        | /serverkeygen   | Section 4.4       |
   | Generation (OPTIONAL)  |                 |                   |
   +------------------------+-----------------+-------------------+
   | CSR Attributes         | /csrattrs       | Section 4.5       |
   | (OPTIONAL)             |                 |                   |
   +------------------------+-----------------+-------------------+

                                 Figure 5

                
The operation path (Figure 5) is appended to the path-prefix to form the URI used with HTTP GET or POST to perform the desired EST operation. An example valid URI absolute path for the "/cacerts" operation is "/.well-known/est/cacerts". To retrieve the CA's certificates, the EST client would use the following HTTP request-line:

GET /.well-known/est/cacerts HTTP/1.1

Likewise, to request a new certificate in this example scheme, the EST client would use the following request-line:

POST /.well-known/est/simpleenroll HTTP/1.1

The use of distinct operation paths simplifies implementation for servers that do not perform client authentication when distributing /cacerts responses.

An EST server MAY provide service for multiple CAs as indicated by an OPTIONAL additional path segment between the registered application name and the operation path. To avoid conflict, the CA label MUST NOT be the same as any defined operation path segment. The EST server MUST provide services regardless of whether the additional path segment is present. The following are three example valid URIs:

https://www.example.com/.well-known/est/cacerts
 
https://www.example.com/.well-known/est/arbitraryLabel1/cacerts
 
https://www.example.com/.well-known/est/arbitraryLabel2/cacerts
In this specification, the distinction between enroll and renew/rekey is explicitly indicated by the HTTP URI. When requesting /fullcmc operations, CMC [RFC5272] uses the same messages for certificate renewal and certificate rekey.

An EST server can provide additional services using other URIs.
REQUIREMENT 15: HTTP LAYER
     
HTTP is used to transfer EST messages. URIs are defined for handling each media type (i.e., message type) as described in Section 3.2.2. HTTP is also used for client authentication services when TLS client authentication is not available, due to the lack of a client certificate suitable for use by TLS (see Section 3.2.3). HTTP authentication can also be used in addition to TLS client authentication if the EST server wishes additional authentication information, as noted in Section 2.2.3. Registered media types are used to convey EST messages as specified in Figure 6.

HTTP 1.1 [RFC2616] and above support persistent connections. As described in Section 8.1 of RFC 2616, persistent connections may be used to reduce network and processing loads associated with multiple HTTP requests. EST does not require or preclude persistent HTTP connections.
REQUIREMENT 29: CLIENT AUTHORIZATION
     
The decision to issue a certificate to a client is always controlled by local CA policy. The EST server configuration reflects this CA policy. This document does not specify any constraints on such policy. EST provides the EST server access to each client's authenticated identity -- e.g., the TLS client's certificate in addition to any HTTP user authentication credentials -- to help in implementing such policy.

If the client's certificate was issued by the EST CA, and it includes the id-kp-cmcRA [RFC6402] extended key usage extension, then the client is a Registration Authority (RA) as described in [RFC5272] and [RFC6402]. In this case, the EST server SHOULD apply authorization policy consistent with an RA client. For example, when handling /simpleenroll requests, the EST server could be configured to accept POP linking information that does not match the current TLS session because the authenticated EST client RA has verified this information when acting as an EST server (as specified in Section 3.5). More specific RA mechanisms are available if the EST client uses /fullcmc methods.
REQUIREMENT 28: CLIENT USE OF IMPLICIT TA DATABASE
     
When the EST client Implicit TA database is used to validate the EST server certificate, the client MUST check the configured URI and each HTTP redirection URI according to the rules specified in [RFC6125], Section 6.4. The provisioned URI or the most recent HTTP redirection URI provides the basis for authorization, and the server's authenticated identity confirms it is the authorized server.
REQUIREMENT 14: APPLICATION LAYER
     
The EST client MUST be capable of generating and parsing Simple PKI messages (see Section 4.2). Generating and parsing Full PKI messages is OPTIONAL (see Section 4.3). The client MUST also be able to request CA certificates from the EST server and parse the returned "bag" of certificates (see Section 4.1). Requesting CSR attributes and parsing the returned list of attributes is OPTIONAL (see Section 4.5).

Details of the EST client application configuration are out of scope of the protocol discussion but are necessary for understanding the prerequisites of initiating protocol operations. The EST client is RECOMMENDED to be configured with TA databases for Section 3.3.1 or with a secret key for Section 3.3.3. Implementations conforming to this standard MUST provide the ability to designate Explicit TAs. For human usability reasons, a "fingerprint" of an Explicit TA database entry can be configured for bootstrapping as discussed in Section 4.1.1. Configuration of an Implicit TA database, perhaps by its inclusion within the EST client distribution or available from the operating system, provides flexibility along with the caveats detailed in Section 6. Implementations conforming to this standard MUST provide the ability to disable use of any Implicit TA database.

The EST client is configured with sufficient information to form the EST server URI. This can be the full operation path segment (e.g., https://www.example.com/.well-known/est/ or https://www.example.com/.well-known/est/arbitraryLabel1), or the EST client can be configured with a tuple composed of the authority portion of the URI along with the OPTIONAL label (e.g., "www.example.com:80" and "arbitraryLabel1") or just the authority portion of the URI.
REQUIREMENT 58: SERVER KEY GENERATION
     
The following is an example of a valid /serverkeygen exchange. During this exchange, the EST client authenticates itself using an existing certificate issued by the CA the EST server provides services for.

The initial TLS handshake is identical to the enrollment example handshake. An example HTTP POSTed message is:

                
   POST /.well-known/est/serverkeygen HTTP/1.1
   Host: 192.0.2.1:8085
   Accept: */*
   Expect: 100-continue
   Content-Type: application/pkcs10
   Content-Transfer-Encoding: base64
   Content-Length: 963

   MIICwTCCAakCAQAwWzE+MDwGA1UEAxM1c2VydmVyS2V5R2VuIHJlcSBieSBjbGll
   bnQgaW4gZGVtbyBzdGVwIDEyIDEzNjgxNDE5NTUxGTAXBgNVBAUTEFBJRDpXaWRn
   ZXQgU046MTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvE1/6m4A/
   3/L32Suyzbf28LM9y8CQfp0aepa7o20BSfluvm8HXR44mlV+wpieM8H5n3Ub3RIo
   RUun/FllIzK9uV7UrkqJ3Yzmq2NOoTd4C+OPsV/RPTu873dhFrssDk3P4NIphlSS
   sSIkt5rhz7wYbCqCFR5Aphe/30Jx7D+xBI5Rs8e6vRS8IpuImh71BHiLfhq9AFhz
   4ZJsOUSVpUmqUogFsM7SOQ6XI4dl+djhpjT+YTJ6hQ2PXrqdch3KsTQ8c6aKs+e2
   5QJxh7O8JHVlPHo4YIxXtAYSutcbbTN5TXWFCWSrWDJ+zuMmk2yU+dio1oW7YR7V
   ftAvazJ3laQbAgMBAAGgITAfBgkqhkiG9w0BCQcxEhMQZEZzQVhtSm5qb2tCdER2
   cjANBgkqhkiG9w0BAQUFAAOCAQEAR+I0EQB+hSjrLCAjnVH6bZdHUNGszIdwx1iu
   L4n+0XK3SfEzeOMkC4T74yFGKj3redS1Ht9atYUPb0D1Qi9Jf9Co8eLblo1l19A6
   GaS798ofxIF0Pl0Dr6/GqjheqJEIbcDTAJq+kvDihyQ4GQnhosygIZHvKppQlebA
   gvp2RJSnMroPCe6RgTU9E2fmI9rin/9PyXeWFF1namp+lYbTGwjv1aE1ikhjCLlH
   veHhCdgOExPw+fqhKhHjp+0ZKBlo2bC3pqRWvDTiZuwt9UpFFfGtuxvpTp44oS/j
   M/965hWIw/5dshY/wQjIfYs07bbq2ERbpJiw9bAQY34gyoVmEQ==
                
                
Because the DecryptKeyIdentifier attribute is not included in this request, the response does not include additional encryption beyond the TLS session. The EST server response is:

                
   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: multipart/mixed ; boundary=estServerExampleBoundary
   Content-Length: 3219
                
                
This is the preamble. It is to be ignored, though it is a handy place for estServer to include an explanatory note, including contact or support information.

                
   f--estServerExampleBoundary
   Content-Type: application/pkcs8
   Content-Transfer-Encoding: base64

   MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDPwKtwJ7TjMgA+
   Poj64V909ryql0foP1hU4Yq5y8/bOP5ZTe6ArgVhUye099Ac+dfdwpyP/DESiujU
   F/dS62Vck3UWNbnw+4O38FUp0enLbbjSTud48KpEW6+FzkeuAanPGZMA1wKyrYy9
   rD5tQOOJU/CBVhUrITyYLZNYUe4agbpcR0wMtrRr2E58Mu8wQ80ryk6nkL7COk5Z
   IQdNRxldk7DFvpA85Yn1stumoGRtVLW51iXeTS1LtXwhuUb/j6Lds3vvAiJ2SiZ0
   Y3rxPlnJVyFmR8Mf2TBOjzuFqva/VLD2ayQjgaGEjq2ZWHXelQAOZ6N3lrChojEK
   FGq93yOhAgMBAAECggEBALQ5az/nYjd5x9Y3f7NMUffwl+jRRfMHCMTRx/u4AEAo
   KBYm0hFVZZtxfM+z7xlD8G0Th6gs2hFA6gwcIlUPmiX+UaOLxht0xWaLGgYmcNAm
   BiCDjLBQ7xRQCWtlcK9WCA5+HBWtcEy6244rXxh+IyWd6NT6bXC165AEcX87y/e3
   JFJ7XFNeDP656s2DmxSCci+iDte6SaEm7sJvYGu16qevJeMThcQcC9/rJjXkvpGL
   IKK2px5idad4Pb6+QHpqj3d4oM8djO6wYUvrH8XQLqAaF8Hd5lFWVU57nSYY+H79
   GaNDTfRTUL6AXr7kmMsKVFOJ0JjZExUCVMZtGiqhB6UCgYEA639OtdWLZCzyZFMe
   p7VlRddoz0VAtrU2dxnEb4cWD8Gerg8uNvp8OG84gH+6MbPwz4ZYWKCgDFqyrAlw
   SF02n9Sovh93eoJ5latSbfeYUkLtB8L/HVk5/CBGEsV9MUkdMF0+B43YlhyEDyKW
   fX2+0UeHLFgRrfpSzP2cXduEieMCgYEA4db/SIrwN2+g1Gjo3oE09kd89VGjVRer
   srbcqc7DcPXP6Lw42sx96h4jVWWqHVo3DfwFBdUb1LH2cnVXQjgDUHdNdpl01cf/
   BFYCFINi2qKMqiJYswkhYxZ1BLz/zuQTDbPFL2PgLniKFG2aFLrTS3S/tgeB5QwI
   RPigH3kfI6sCgYAPqsCJyFMlrvfRRNZdQewi4VnPsEPF4/hjpAs1gD8vfSoZWlkw
   vylUd9HCerzgYaA7rixieQ0sxTvtxhL6PXlM2NEBFQbV16hPFL6/IiG4F0u9oHNo
   eG8rHtqKlSjnBn4yoYFm70Dhe7QtbZelcaAoPCH6CUHj2St5B8ZHWDtREQKBgHNp
   wER+XIy4C2UByCANv9csaXulIOdXlXNbaCGPfOm5dWrm5ddLMf33MO9vaSRe+ku3
   Q4nbgsGLwPp1ZQZ+QZNZpMi7W6306yp4GdAJ5Pb+oww/ST0VqW5OB7dILyK4A9S4
   zkiNrf+Rsl8GM/vsDhc9rsuDwqofIAq/VHVBHNzJAoGBAOHQof5L6iGHOHcxLazx
   4MGvRTpmzU/PX6Q3QxqpetEGFEDZAaL58L67SSS3fFBnKrVAidF6llC1bAH1aoRa
   fYHUDi45xBoroy0hBwrnTKRxppua4UK75FUH5PPJfR6cCvw5stRkzIevTZHhozkX
   pM7PYH/x4BiBmgQ3bhOqTp4H
   --estServerExampleBoundary
   Content-Type: application/pkcs7-mime; smime-type=certs-only
   Content-Transfer-Encoding: base64
   MIIDRQYJKoZIhvcNAQcCoIIDNjCCAzICAQExADALBgkqhkiG9w0BBwGgggMYMIID
   FDCCAfygAwIBAgIBFjANBgkqhkiG9w0BAQUFADAbMRkwFwYDVQQDExBlc3RFeGFt
   cGxlQ0EgTndOMB4XDTEzMDUwOTIzMjU1NloXDTE0MDUwOTIzMjU1NlowLDEqMCgG
   A1UEAxMhc2VydmVyc2lkZSBrZXkgZ2VuZXJhdGVkIHJlc3BvbnNlMIIBIjANBgkq
   hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz8CrcCe04zIAPj6I+uFfdPa8qpdH6D9Y
   VOGKucvP2zj+WU3ugK4FYVMntPfQHPnX3cKcj/wxEoro1Bf3UutlXJN1FjW58PuD
   t/BVKdHpy2240k7nePCqRFuvhc5HrgGpzxmTANcCsq2Mvaw+bUDjiVPwgVYVKyE8
   mC2TWFHuGoG6XEdMDLa0a9hOfDLvMEPNK8pOp5C+wjpOWSEHTUcZXZOwxb6QPOWJ
   9bLbpqBkbVS1udYl3k0tS7V8IblG/4+i3bN77wIidkomdGN68T5ZyVchZkfDH9kw
   To87har2v1Sw9mskI4GhhI6tmVh13pUADmejd5awoaIxChRqvd8joQIDAQABo1Iw
   UDAOBgNVHQ8BAf8EBAMCBLAwHQYDVR0OBBYEFKeZixu9F+appDX2SS5HaxmV6Jr4
   MB8GA1UdIwQYMBaAFLHEaeZbowSn2Jejizu/uWqyMkI8MA0GCSqGSIb3DQEBBQUA
   A4IBAQBHhLmRAKrnTapqqBObDM9IQDQPuwW+fW1gYwZKlSm/IWIwHEZL1igXhpjj
   rf4xqpIkiJMmkaOeoXA8PFniX0/lZM9FQSM/j89CUf5dMoAqWj8s17xuXu9L/hVe
   XjjXHsL40WuDG6tMPN9vcT8tE3ruor608MKSHFX/NEM6+AaNVSUPTmB33BgYB1Wa
   E7pn3JMN6pjIxsHnF4pKi8qvoTSVVjaCEwUe8Q/fw1yvjoHoYJtyMn4v5Kb3Rt+m
   s8Yie1tcfVQrjQutqr34/IJsKdPziZwi92KZa+1958A6M9O/p5OI0up9ZXKg2DEC
   1O9qT0GyYJ6sxAyKiGTOxk6jMddDoQAxAA==
   --estServerExampleBoundary--
                
This is the epilogue. It is also to be ignored.
REQUIREMENT 8: HTTP-BASED CLIENT AUTHENTICATION
     
The EST server can optionally also request that the EST client submit a username/password using the HTTP Basic or Digest authentication methods (see Section 3.2.3). This approach is desirable if the EST client cannot be authenticated during the TLS handshake (see Section 3.3.2) or the EST server policy requires additional authentication information; see Section 3.2.3. In all cases, HTTP-based client authentication is only to be performed over a TLS-protected transport (see Section 3.3).
REQUIREMENT 9: CLIENT CERTIFICATE REISSUANCE
     
An EST client can renew/rekey its existing client certificate by submitting a re-enrollment request to an EST server. When the current EST client certificate can be used for TLS client authentication (Section 3.3.2), the client presents this certificate to the EST server for client authentication. When the to be reissued EST client certificate cannot be used for TLS client authentication, any of the authentication methods used for initial enrollment can be used. For example, if the client has an alternative certificate issued by the EST CA that can be used for TLS client authentication, then it can be used.

The certificate request message includes the same Subject and SubjectAltName as the current certificate. Name changes are requested as specified in Section 4.2.2.
REQUIREMENT 49: CSR ATTRIBUTES RESPONSE
     
If locally configured policy for an authenticated EST client indicates a CSR Attributes Response is to be provided, the server response MUST include an HTTP 200 response code. An HTTP response code of 204 or 404 indicates that a CSR Attributes Response is not available. Regardless of the response code, the EST server and CA MAY reject any subsequent enrollment requests for any reason, e.g., incomplete CSR attributes in the request.

Responses to attribute request messages MUST be encoded as the content-type of "application/csrattrs" with a Content-Transfer-Encoding of "base64" [RFC2045]. The syntax for application/csrattrs body is as follows:

CsrAttrs ::= SEQUENCE SIZE (0..MAX) OF AttrOrOID

AttrOrOID ::= CHOICE (oid OBJECT IDENTIFIER, attribute Attribute }

Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE { type ATTRIBUTE.&id({IOSet}), values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type}) }

An EST server includes zero or more OIDs or attributes [RFC2986] that it requests the client to use in the certification request. The client MUST ignore any OID or attribute it does not recognize. When the server encodes CSR Attributes as an empty SEQUENCE, it means that the server has no specific additional information it desires in a client certification request (this is functionally equivalent to an HTTP response code of 204 or 404).

If the CA requires a particular crypto system or use of a particular signature scheme (e.g., certification of a public key based on a certain elliptic curve, or signing using a certain hash algorithm) it MUST provide that information in the CSR Attribute Response. If an EST server requires the linking of identity and POP information (see Section 3.5), it MUST include the challengePassword OID in the CSR Attributes Response.

The structure of the CSR Attributes Response SHOULD, to the greatest extent possible, reflect the structure of the CSR it is requesting. Requests to use a particular signature scheme (e.g. using a particular hash function) are represented as an OID to be reflected in the SignatureAlgorithm of the CSR. Requests to use a particular crypto system (e.g., certification of a public key based on a certain elliptic curve) are represented as an attribute, to be reflected as the AlgorithmIdentifier of the SubjectPublicKeyInfo, with a type indicating the algorithm and the values indicating the particular parameters specific to the algorithm. Requests for descriptive information from the client are made by an attribute, to be represented as Attributes of the CSR, with a type indicating the [RFC2985] extensionRequest and the values indicating the particular attributes desired to be included in the resulting certificate's extensions.

The sequence is Distinguished Encoding Rules (DER) encoded [X.690] and then base64 encoded (Section 4 of [RFC4648]). The resulting text forms the application/csrattr body, without headers.

For example, if a CA requests a client to submit a certification request containing the challengePassword (indicating that linking of identity and POP information is requested; see Section 3.5), an extensionRequest with the Media Access Control (MAC) address ([RFC2307]) of the client, and to use the secp384r1 elliptic curve and to sign with the SHA384 hash function. Then, it takes the following:


         OID:        challengePassword (1.2.840.113549.1.9.7)

         Attribute:  type = extensionRequest (1.2.840.113549.1.9.14)
                     value = macAddress (1.3.6.1.1.1.1.22)

         Attribute:  type = id-ecPublicKey (1.2.840.10045.2.1)
                     value = secp384r1 (1.3.132.0.34)

         OID:        ecdsaWithSHA384 (1.2.840.10045.4.3.3)

                    
and encodes them into an ASN.1 SEQUENCE to produce:


       30 41 06 09 2a 86 48 86 f7 0d 01 09 07 30 12 06 07 2a 86 48 ce 3d
       02 01 31 07 06 05 2b 81 04 00 22 30 16 06 09 2a 86 48 86 f7 0d 01
       09 0e 31 09 06 07 2b 06 01 01 01 01 16 06 08 2a 86 48 ce 3d 04 03
       03

                    
and then base64 encodes the resulting ASN.1 SEQUENCE to produce:

MEEGCSqGSIb3DQEJBzASBgcqhkjOPQIBMQcGBSuBBAAiMBYGCSqGSIb3DQEJDjEJ
       BgcrBgEBAQEWBggqhkjOPQQDAw==
REQUIREMENT 48: CSR ATTRIBUTES REQUEST
     
The EST client requests a list of CA-desired CSR attributes from the CA by sending an HTTPS GET message to the EST server with an operations path of "/csrattrs".
REQUIREMENT 52: REFERENCES
     
                
   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2585]  Housley, R. and P. Hoffman, "Internet X.509 Public Key
              Infrastructure Operational Protocols: FTP and HTTP", RFC
              2585, May 1999.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, June 1999.

   [RFC2633]  Ramsdell, B., "S/MIME Version 3 Message Specification",
              RFC 2633, June 1999.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS https://tools.ietf.org/html/rfc7030#10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              November 2000.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005.
                
   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4108]  Housley, R., "Using Cryptographic Message Syntax (CMS) to
              Protect Firmware Packages", RFC 4108, August 2005.

   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", RFC 4210, September 2005.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, October 2006.

   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 5077, January 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5272]  Schaad, J. and M. Myers, "Certificate Management over CMS
              (CMC)", RFC 5272, June 2008.

   [RFC5273]  Schaad, J. and M. Myers, "Certificate Management over CMS
              (CMC): Transport Protocols", RFC 5273, June 2008.

   [RFC5274]  Schaad, J. and M. Myers, "Certificate Management Messages
              over CMS (CMC): Compliance Requirements", RFC 5274, June
              2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, September 2009.

   [RFC5746]  Rescorla, E., Ray, M., Dispensa, S., and N. Oskov,
              "Transport Layer Security (TLS) Renegotiation Indication
              Extension", RFC 5746, February 2010.

   [RFC5751]  Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification", RFC 5751, January 2010.            
   [RFC5785]  Nottingham, M. and E. Hammer-Lahav, "Defining Well-Known
              Uniform Resource Identifiers (URIs)", RFC 5785, April
              2010.

   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", RFC 5929, July 2010.

   [RFC5958]  Turner, S., "Asymmetric Key Packages", RFC 5958, August
              2010.

   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, March 2011.

   [RFC6402]  Schaad, J., "Certificate Management over CMS (CMC)
              Updates", RFC 6402, November 2011.

   [RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454, December
              2011.

   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", BCP 13, RFC
              6838, January 2013.

   [X.680]    ITU-T Recommendation X.680 (2008) | ISO/IEC 8824-1:2008,
              "Abstract Syntax Notation One (ASN.1): Specification of
              basic notation", November 2008,
              <http://www.itu.int/rec/T-REC-X.680-200811-I/en>.

   [X.690]    ITU-T Recommendation X.690 (2008) | ISO/IEC 8825-1:2008,
              "ASN.1 encoding rules: Specification of Basic Encoding
              Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)", November 2008,
              <http://www.itu.int/rec/T-REC-X.690-200811-I/en>.             
                
REQUIREMENT 46: SERVER-SIDE KEY GENERATION RESPONSE
     
If the request is successful, the server response MUST have an HTTP 200 response code with a content-type of "multipart/mixed" consisting of two parts: one part is the private key data and the other part is the certificate data.

The format in which the private key data part is returned is dependent on whether the private key is being returned with additional encryption on top of that provided by TLS.

If additional encryption is not being employed, the private key data MUST be placed in an "application/pkcs8". An "application/pkcs8" part consists of the base64-encoded DER-encoded [X.690] PrivateKeyInfo with a Content-Transfer-Encoding of "base64" [RFC2045].

If additional encryption is being employed, the private key is placed inside of a CMS SignedData. The SignedData is signed by the party that generated the private key, which may or may not be the EST server or the EST CA. The SignedData is further protected by placing it inside of a CMS EnvelopedData, as described in Section 4 of [RFC5958]. The following list shows how the EncryptedData is used, depending on the type of protection key specified by the client.

If the client specified a symmetric encryption key to protect the server-generated private key, the EnvelopedData content is encrypted using the secret key identified in the request. The EnvelopedData RecipientInfo field MUST indicate the key-encryption kekri key management technique. The values are as follows: version is set to 4, key-encryption key identifier (kekid) is set to the value of the DecryptKeyIdentifier from Section 4.4.1.1; keyEncryptionAlgorithm is set to one of the key wrap algorithms that the client included in the SMIMECapabilities accompanying the request; and encryptedKey is the encrypted key.
 
If the client specified an asymmetric encryption key suitable for key transport operations to protect the server-generated private key, the EnvelopedData content is encrypted using a randomly generated symmetric encryption key. The cryptographic strength of the symmetric encryption key SHOULD be equivalent to the client- specified asymmetric key. The EnvelopedData RecipientInfo field MUST indicate the KeyTransRecipientInfo (ktri) key management technique. In KeyTransRecipientInfo, the RecipientIdentifier (rid) is either the subjectKeyIdentifier copied from the attribute defined in Section 4.4.1.2 or the server determines an associated issuerAndSerialNumber from the attribute; version is derived from the choice of rid [RFC5652], keyEncryptionAlgorithm is set to one of the key wrap algorithms that the client included in the SMIMECapabilities accompanying the request, and encryptedKey is the encrypted key.
 
If the client specified an asymmetric encryption key suitable for key agreement operations to protect the server-generated private key, the EnvelopedData content is encrypted using a randomly generated symmetric encryption key. The cryptographic strength of the symmetric encryption key SHOULD be equivalent to the client- specified asymmetric key. The EnvelopedData RecipientInfo field MUST indicate the KeyAgreeRecipientInfo (kari) key management technique. In the KeyAgreeRecipientInfo type, version, originator, and user keying material (ukm) are as in [RFC5652], and keyEncryptionAlgorithm is set to one of the key wrap algorithms that the client included in the SMIMECapabilities accompanying the request. The recipient's key identifier is either copied from the attribute defined in Section 4.4.1.2 to subjectKeyIdentifier or the server determines an IssuerAndSerialNumber that corresponds to the value provided in the attribute.
In all three additional encryption cases, the EnvelopedData is returned in the response as an "application/pkcs7-mime" part with an smime-type parameter of "server-generated-key" and a Content- Transfer-Encoding of "base64".

The certificate data part is an "application/pkcs7-mime" and exactly matches the certificate response to /simpleenroll.

When rejecting a request, the server MUST specify either an HTTP 4xx error or an HTTP 5xx error. If the content-type is not set, the response data MUST be a plaintext human-readable error message.
REQUIREMENT 2: TERMINOLOGY
     
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].

It is assumed that the reader is familiar with the terms and concepts described in Public Key Cryptography Standard (PKCS) #10 [RFC2986], HTTPS [RFC2818], CMP [RFC4210], CMC [RFC5272][RFC5273][RFC5274], and TLS [RFC4346].

In addition to the terms defined in the terminology section of CMC [RFC5272], the following terms are defined for clarity:

EST CA: For certificate issuing services, the EST CA is reached through the EST server; the CA could be logically "behind" the EST server or embedded within it.

Third-Party Trust Anchor: Any trust anchor (TA) that is not authoritative for the PKI hierarchy for which the EST server is providing services.

Explicit Trust Anchor: Any TA that is explicitly configured on the client or server for use during EST TLS authentication; for example, a TA that is manually configured on the EST client or bootstrapped as described in Section 4.1.1. (See more details in Sections 3.6 and 6.)

Implicit Trust Anchor: Any third-party TA that is available on the client or server for use during TLS authentication but is not specifically indicated for use during EST TLS authentication; for example, TAs commonly used by web browsers to authenticate web servers or TAs used by servers to authenticate manufacturer- installed client credentials (such as certificates populated into cable modems or routers in the factory). The authorization model for these TAs is different from the authorization model for Explicit Trust Anchors. (See more details in Sections 3.6.1, 3.6.2, and 6).

Certificate-Less TLS: Certificate-less TLS cipher suites provide a way to perform mutual authentication in situations where neither the client nor server have certificates or are willing to use them. The credential used for authentication is a word, phrase, code, or key that is shared between the client and server. The credential must be uniquely shared between the client and server in order to provide authentication of an individual client to an individual server.
REQUIREMENT 47: CSR ATTRIBUTES
     
CA policy may allow inclusion of client-provided attributes in certificates that it issues, and some of these attributes may describe information that is not available to the CA. In addition, a CA may desire to certify a certain type of public key and a client may not have a priori knowledge of that fact. Therefore, clients SHOULD request a list of expected attributes that are required, or desired, by the CA in an enrollment request or if dictated by local policy.

The EST server SHOULD NOT require client authentication or authorization to reply to this request.

Requesting CSR attributes is optional, but clients are advised that CAs may refuse enrollment requests that are not encoded according to the CA's policy.
REQUIREMENT 53: INFORMATIVE REFERENCES
     

   [IDevID]   IEEE Standards Association, "IEEE 802.1AR Secure Device
              Identifier", December 2009, <http://standards.ieee.org/
              findstds/standard/802.1AR-2009.html>.

   [RFC2307]  Howard, L., "An Approach for Using LDAP as a Network
              Information Service", RFC 2307, March 1998.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818, May 2000.

   [RFC2985]  Nystrom, M. and B. Kaliski, "PKCS https://tools.ietf.org/html/rfc7030#9: Selected Object
              Classes and Attribute Types Version 2.0", RFC 2985,
              November 2000.

   [RFC3394]  Schaad, J. and R. Housley, "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, September 2002.

   [RFC5054]  Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin,
              "Using the Secure Remote Password (SRP) Protocol for TLS
              Authentication", RFC 5054, November 2007.

   [RFC5967]  Turner, S., "The application/pkcs10 Media Type", RFC 5967,
              August 2010.

   [RFC6403]  Zieglar, L., Turner, S., and M. Peck, "Suite B Profile of
              Certificate Management over CMS", RFC 6403, November 2011.

   [SHS]      National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", Federal Information Processing
              Standard Publication 180-4, March 2012,
              <http://csrc.nist.gov/publications/fips/
              fips180-4/fips-180-4.pdf>.

   [SP-800-57-Part-1]
              National Institute of Standards and Technology,
              "Recommendation for Key Management - Part 1: General
              (Revision 3)", July 2012,
              <http://csrc.nist.gov/publications/nistpubs/800-57/
              sp800-57_part1_rev3_general.pdf>.
                
REQUIREMENT 45: REQUESTS FOR ASYMMETRIC ENCRYPTION OF THE PRIVATE KEY
     
To specify an asymmetric encryption key to be used to encrypt the server-generated private key, the client MUST include an AsymmetricDecryptKeyIdentifier attribute. The AsymmetricDecryptKeyIdentifier attribute is defined as:

id-aa-asymmDecryptKeyID OBJECT IDENTIFIER ::= { id-aa 54 }

The asymmetric-decrypt-key-identifier attribute values have ASN.1 type AsymmetricDecryptKeyIdentifier (where ASN.1 is defined in [X.680])::

AsymmetricDecryptKeyIdentifier ::= OCTET STRING

If the server does not have a public key matching the identifier specified by the client, the request MUST be terminated and an error returned to the client. Distribution of the key specified by the AsymmetricDecryptKeyIdentifier to the key generator and the client is outside the scope of this document. If the key identified is bound to an X.509 certificate, then the key MUST either explicitly support keyTransport or keyAgreement or its use MUST be unrestricted.
REQUIREMENT 51: SECURITY CONSIDERATIONS
     
Support for Basic authentication, as specified in HTTP [RFC2617], allows the server access to a client's cleartext password. This provides support for legacy username/password databases but requires exposing the plaintext password to the EST server. Use of a PIN or one-time password can help mitigate such exposure, but it is RECOMMENDED that EST clients use such credentials only once to obtain a client certificate (that will be used during future interactions with the EST server).

When a client uses the Implicit TA database for certificate validation (see Section 3), then authorization proceeds as specified in Section 3.6.2. In this situation, the client has validated the server as being a responder that is certified by a third party for the URI configured, but it cannot verify that the responder is authorized to act as an RA for the PKI in which the client is trying to enroll. Clients using an Implicit Trust Anchor database are RECOMMENDED to use only TLS-based client authentication (to prevent exposing HTTP-based client authentication information). It is RECOMMENDED that such clients include "Linking Identity and POP Information" (Section 3.5) in requests (to prevent such requests from being forwarded to a real EST server by a man in the middle). It is RECOMMENDED that the Implicit Trust Anchor database used for EST server authentication be carefully managed to reduce the chance of a third-party CA with poor certification practices from being trusted. Disabling the Implicit Trust Anchor database after successfully receiving the Distribution of CA certificates response (Section 4.1.3) limits any vulnerability to the first TLS exchange.

Certificate-less TLS cipher suites that maintain security and perform the mutual authentication necessary for enrollment have the following properties:

the only information leaked by an active attack is whether or not a single guess of the secret is correct.
 
any advantage an adversary gains is through interaction and not computation.
 
it is possible to perform countermeasures, such as exponential backoff after a certain number of failed attempts, to frustrate repeated active attacks.
Using a certificate-less cipher suite that does not have the properties listed above would render the results of enrollment void and potentially result in certificates being issued to unauthenticated and/or unauthorized entities.

When using a certificate-less TLS cipher suite, the shared secret used for authentication and authorization cannot be shared with an entity that is not a party to the exchange: someone other than the client and the server. Any additional sharing of secrets voids the security afforded by a certificate-less cipher suite. Exposure of a shared secret used by a certificate-less cipher suite to a third party enables client impersonation that can result in corruption of a client's trust anchor database.

TLS cipher suites that include "_EXPORT_" and "_DES_" in their names MUST NOT be used. These ciphers do not offer a sufficient level of protection; 40-bit crypto in 2013 doesn't offer acceptable protection, and the use of DES is deprecated.

As described in CMC, Section 6.7 of [RFC5272], "For keys that can be used as signature keys, signing the certification request with the private key serves as a POP on that key pair". The inclusion of tls- unique within the certification request links the proof-of-possession to the TLS proof-of-identity by enforcing that the POP operation occurred while the TLS session was active. This implies to the server that the authenticated client currently has access to the private key. If the authenticated client is known to have specific capabilities, such as hardware protection for authentication credentials and key storage, this implication is strengthened but not proven.

The server-side key generation method allows keys to be transported over the TLS connection to the client without any application-layer protection. The distribution of private key material is inherently risky. Private key distribution uses the encryption mode of the negotiated TLS cipher suite. Keys are not protected by preferred key wrapping methods such as AES Key Wrap [RFC3394] or as specified in [RFC5958] as encryption of the private key beyond that provided by TLS is optional. It is RECOMMENDED that EST servers not support this operation by default. It is RECOMMENDED that clients not request this service unless there is a compelling operational benefit. Use of an Implicit Trust Anchor database is NOT RECOMMENDED when server-side key generation is employed. The use of an encrypted CMS Server-Side Key Generation Response is RECOMMENDED.

Regarding the CSR attributes that the CA may list for inclusion in an enrollment request, there are no real inherent security issues with the content being conveyed, but an adversary who is able to interpose herself into the conversation could exclude attributes that a server may want, include attributes that a server may not want, and render meaningless other attributes that a server may want.

ASN.1 encoding rules (e.g., DER and BER) have a type-length-value structure, and it is easy to construct malicious content with invalid length fields that can cause buffer overrun conditions. ASN.1 encoding rules allow for arbitrary levels of nesting, which may make it possible to construct malicious content that will cause a stack overflow. Interpreters of ASN.1 structures should be aware of these issues and should take appropriate measures to guard against buffer overflows and stack overruns in particular, and malicious content in general.
REQUIREMENT 1
     
This document profiles certificate enrollment for clients using Certificate Management over CMS (CMC) [RFC5272] messages over a secure transport. Enrollment over Secure Transport (EST) describes the use of Transport Layer Security (TLS) 1.1 [RFC4346], 1.2 [RFC5246], or any future version) and Hypertext Transfer Protocol (HTTP) [RFC2616] to provide an authenticated and authorized channel for Simple Public Key Infrastructure (PKI) Requests and Responses [RFC5272]. Architecturally, the EST service is located between a Certification Authority (CA) and a client. It performs several functions traditionally allocated to the Registration Authority (RA) role in a PKI. The nature of communication between an EST server and a CA is not described in this document. EST adopts the Certificate Management Protocol (CMP) [RFC4210] model for CA certificate rollover, but it does not use the CMP message syntax or protocol. EST servers are extensible in that new functions may be defined to provide additional capabilities not specified in CMC [RFC5272], and this document defines two such extensions: one for requesting Certificate Signing Request attributes and another for requesting server-generated keys. EST specifies how to transfer messages securely via HTTP over TLS (HTTPS) [RFC2818], where the HTTP headers and media types are used in conjunction with TLS. HTTPS operates over TCP; this document does not specify EST over HTTP/Datagram Transport Layer Security/User Datagram Protocol (HTTP/DTLS/UDP). With a suitable specification for combining HTTP, DTLS, and UDP, there are no EST requirements that would prevent it from working over such a stack. Figure 1 shows how the layers build upon each other.

EST Layering: Protocols:
   +--------------------------------------------+
   |                                            |
   | EST request/response messages              |
   |                                            |
   +--------------------------------------------+
   |                                            |
   | HTTP for message transfer and signaling    |
   |                                            |
   +--------------------------------------------+
   |                                            |
   | TLS for transport security                 |
   |                                            |
   +--------------------------------------------+
   |                                            |
   | TCP for transport                          |
   |                                            |
   +--------------------------------------------+
Figure 1
REQUIREMENT 50: IANA CONSIDERATIONS
     
Section 4.4.1.2 defines an OID that has been registered in an arc delegated by the IANA to the PKIX working group.

IANA has registered the following:

IANA updated the well-known URI registry with the following filled-in template from [RFC5785].

URI suffix: est

Change controller: IETF

IANA has updated the "Application Media Types" registry with the following filled-in templates from [RFC6838].

The media subtype for CSR attributes in a CSR Attributes Response is application/csrattrs.

                
       Type name: application

       Subtype name: csrattrs

       Required parameters: None

       Optional parameters: None

       Encoding considerations: binary;

       Security Considerations:

         Clients request a list of attributes that servers wish to be in
         certification requests.  The request/response is normally done
         in a TLS-protected tunnel.

       Interoperability considerations: None

       Published specification: This memo.

       Applications which use this media type: Enrollment over Secure
       Transport (EST)

       Additional information:

         Magic number(s): None

         File extension: .csrattrs

       Person & email address to contact for further information:

         Dan Harkins <dharkins@arubanetworks.com>

       Restrictions on usage: None

       Author: Dan Harkins <dharkins@arubanetworks.com>

       Intended usage: COMMON

       Change controller: The IESG <iesg@ietf.org>
                
                
The application/pkcs7-mime content-type defines the optional "smime-type" parameter [RFC5751] with a set of specific values. This document adds another value, "server-generated-key", as the parameter value for Server-side Key Generation Response.
REQUIREMENT 40: FULL CMC REQUEST
     
If the HTTP POST to /fullcmc is not a valid Full PKI Request, the server MUST reject the message. The HTTP content-type used is "application/pkcs7-mime" with an smime-type parameter "CMC-request", as specified in [RFC5273]. The body of the message is the binary value of the encoding of the PKI Request with a Content-Transfer-Encoding of "base64" [RFC2045].
REQUIREMENT 4: OBTAINING CA CERTIFICATES
     
The EST client can request a copy of the current EST CA certificate(s) from the EST server. The EST client is assumed to perform this operation before performing other operations.

Throughout this document we assume the EST CA has a certificate that is used by the client to verify signed objects issued by the CA, e.g., certificates and certificate revocation lists (CRLs), and that a different certificate than the one used to verify signatures on certificates and CRLs is used when EST protocol communication requires additional encryption.

The EST client authenticates and verifies the authorization scope of the EST server when requesting the current CA certificate(s). As detailed in Sections 3.3.1 and 3.3.3, available options include:

Verifying the EST server's HTTPS URI against the EST server's certificate using Implicit TAs (similar to a common HTTPS exchange). This allows the EST server and client to leverage existing TAs that might be known to the EST client.
 
The client can leverage a previously distributed trust anchor specific to the EST server. This allows the EST client to use an existing, potentially older, CA certificate to request a current CA certificate.
 
For bootstrapping, the EST client can rely upon manual authentication performed by the end-user as detailed in Section 4.1.1.
 
The client can leverage the binding of a shared credential to a specific EST server with a certificate-less TLS cipher suite.
Client authentication is not required for this exchange, so it is trivially supported by the EST server.
REQUIREMENT 5: INTIAL ENROLLMENT
     
After authenticating an EST server and verifying that it is authorized to provide services to the client, an EST client can acquire a certificate for itself by submitting an enrollment request to that server.

The EST server authenticates and authorizes the EST client as specified in Sections 3.3.2, 3.3.3, and 3.7. The methods described in the normative text that are discussed in this overview include:

TLS with a previously issued client certificate (e.g., an existing certificate issued by the EST CA);
 
TLS with a previously installed certificate (e.g., manufacturer- installed certificate or a certificate issued by some other party);
 
Certificate-less TLS (e.g., with a shared credential distributed out-of-band);
 
HTTP-based with a username/password distributed out-of-band.
REQUIREMENT 55: OBTAINING CA CERTIFICATES
     
The following is an example of a valid /cacerts exchange.

During the initial TLS handshake, the client can ignore the optional server-generated "certificate request" and can instead proceed with the HTTP GET request:

                
   GET /.well-known/est/cacerts HTTP/1.1
   User-Agent: curl/7.22.0 (i686-pc-linux-gnu) libcurl/7.22.0 OpenS
   SL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
   Host: 192.0.2.1:8085
   Accept: */*
                
                
In response, the server provides the current CA certificates:

                
   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: application/pkcs7-mime
   Content-Transfer-Encoding: base64
   Content-Length: 4246

   MIIMOQYJKoZIhvcNAQcCoIIMKjCCDCYCAQExADALBgkqhkiG9w0BBwGgggwMMIIC
   +zCCAeOgAwIBAgIJAJpY3nUZO3qcMA0GCSqGSIb3DQEBBQUAMBsxGTAXBgNVBAMT
   EGVzdEV4YW1wbGVDQSBPd08wHhcNMTMwNTA5MDM1MzMxWhcNMTQwNTA5MDM1MzMx
   WjAbMRkwFwYDVQQDExBlc3RFeGFtcGxlQ0EgT3dPMIIBIjANBgkqhkiG9w0BAQEF
   AAOCAQ8AMIIBCgKCAQEAwDqpiHopaICubpRqbpEN7LqTIqWELFIA9qDDheHIKuyO
   HW/ZAP7Rl4S5ZU6gaLW/ksseBUxdmox3KNyvtyjehIofTu28eZWhgy6/LCEGWR3P
   K+fgPBA0l0JfJR/8oeXZa70oLVQc3hI4kCeqjFMs+biYH0vp/RluhftyZ5kzQyH1
   EGsRkw1/qUKkTZ8PCF8VFlYfqmUoqsaRTyZbjII4J+Y6/jEG+p7QreW9zcz4sPe8
   3c/uhwMLOWQkZtKsQtgo5CpfYMjuAmk4Q2joQq2vcxlc+WNKHf+wbrDb11ORZril
   9ISlI94oumcRz3uBG1Yg7z83hdDfasmdfbp8gOSNFQIDAQABo0IwQDAPBgNVHRMB
   Af8EBTADAQH/MB0GA1UdDgQWBBQITTKxMqATXrfc4ffpCIbt6Gsz0jAOBgNVHQ8B
   Af8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBACPnQPu5WReUGuCMS0nBOGa2tXh6
   uZP4mS3J1qEfDePam/IiU9ssyYdcDwhVvKMoP4gI/yu4XFqhdpIoy/PyD4T15MT7
   KADCxXkh5rM1IqMui7FvBKLWYGdy9sjEf90wAkBjHBe/TMO1NNw3uELyONSkHIvo
   X0pu6aPmm/moIMyGi46niFse1iWlXXldGLkOQsh0e7U+wpBX07QpOr2KB2+Yf+uA
   KY1SWzEG23bUxXlvcbUMgANDGj5r6z+niKL0VlApip/iCuVEEOcZ91UlmJjVLQWA
   x6ie+v84oM+pIojiGM0C4XWcVlKKEgcMOsN3S4lvm8Ptpq0GLoIJY8NTD20wggMD
   MIIB66ADAgECAgEBMA0GCSqGSIb3DQEBBQUAMBsxGTAXBgNVBAMTEGVzdEV4YW1w
   bGVDQSBPd08wHhcNMTMwNTA5MDM1MzMyWhcNMTQwNTA5MDM1MzMyWjAbMRkwFwYD
   VQQDExBlc3RFeGFtcGxlQ0EgTndPMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
   CgKCAQEAnn3rZ3rMJHwf7MD9K4mubxHAvtdnrsQf5OfgtMhRIL4aePNhAdgPyj8C
   loxOgD3UTV+dQ1ViOzVxPN7acikoOnkIdRpjpOpkyMo+KkvHMQXGnQTbsMAv1qWt
   9S12DMpo0GOA1e4Ge3ud5YPOTR/q6PvjN51IEwYKksG7CglwZwB+5JbwhYr2D/0u
   btGltriRVixPWrvt+wz/ITp5rcjh/8RS3LE8tQy3kTNhJF3Y/esR2sSgOiPNgIto
   CATysbaINEPr4MemqML4tDpR/aG9y+8Qe7s1LyMFvDletp2mmBykAC/7nOat/pwU
   lB0sN524D1XAgz8ZKvWrkh+ZaOr3hwIDAQABo1IwUDAOBgNVHQ8BAf8EBAMCBLAw
   HQYDVR0OBBYEFLHEaeZbowSn2Jejizu/uWqyMkI8MB8GA1UdIwQYMBaAFAhNMrEy
   oBNet9zh9+kIhu3oazPSMA0GCSqGSIb3DQEBBQUAA4IBAQCLDkL7aLNV6hSOkIqH
   q+shV9YLO56/tj00vY/jV5skgDHk5d0B+OGortKVuGa57+v0avTrlJns3bNW8Ntv
   zkDEhmd00Ak02aPsi4wRHLFgttUf9HdEHAuTkAESPTU43DiptjkfHhtBMfsFrCkd
   sxWzCz+prDOMHYfUEkhRVV++1zyGEX6ov1Ap2IU2p3E+ASihL/amxTEQAsbwjUTI
   R52zoL6nMPzpbKeZi2M0eEBVF8sDueA9Hjo6woLjgJqV0/yc5vC2HAxUOhx0cWTY
   GcRBgL/yOyQLKiY5TKBH951OjQ4vhF2HmcoO7DkcNLYJOge16ssx4ogBHul20VgF
   XJJjMIIDAzCCAeugAwIBAgIBAjANBgkqhkiG9w0BAQUFADAbMRkwFwYDVQQDExBl
   c3RFeGFtcGxlQ0EgTndOMB4XDTEzMDUwOTAzNTMzMloXDTE0MDUwOTAzNTMzMlow
   GzEZMBcGA1UEAxMQZXN0RXhhbXBsZUNBIE93TjCCASIwDQYJKoZIhvcNAQEBBQAD
   ggEPADCCAQoCggEBAMA6qYh6KWiArm6Uam6RDey6kyKlhCxSAPagw4XhyCrsjh1v
   2QD+0ZeEuWVOoGi1v5LLHgVMXZqMdyjcr7co3oSKH07tvHmVoYMuvywhBlkdzyvn
   4DwQNJdCXyUf/KHl2Wu9KC1UHN4SOJAnqoxTLPm4mB9L6f0ZboX7cmeZM0Mh9RBr
   EZMNf6lCpE2fDwhfFRZWH6plKKrGkU8mW4yCOCfmOv4xBvqe0K3lvc3M+LD3vN3P
   7ocDCzlkJGbSrELYKOQqX2DI7gJpOENo6EKtr3MZXPljSh3/sG6w29dTkWa4pfSE
   pSPeKLpnEc97gRtWIO8/N4XQ32rJnX26fIDkjRUCAwEAAaNSMFAwDgYDVR0PAQH/
   BAQDAgSwMB0GA1UdDgQWBBQITTKxMqATXrfc4ffpCIbt6Gsz0jAfBgNVHSMEGDAW
   gBSxxGnmW6MEp9iXo4s7v7lqsjJCPDANBgkqhkiG9w0BAQUFAAOCAQEALhDaE6Mp
   BINBsJozdbXlijrWxL1CSv8f4GwpUFk3CgZjibt/qW9UoaNR4E58yRopuEhjwFZK
   2w8YtRqx8IZoFhcoLkpBDfgLLwhoztzbYvOVKQMidjBlkBEVNR5MWdrs7F/AxWuy
   iZ2+8AnR8GwqEIbCD0A7xIghmWEMh/BVI9C7GLqd6PxKrTAjuDfEpfdWhU/uYKmK
   cL3XDbSwr30j2EQyaTV/3W0Tn2UfuxdwDQ4ZJs9G+Mw50s7AG6CpISyOIFmX6/bU
   DpJXGLiLwfJ9C/aum9nylYuGCJ68BuTrCs9567KGfXEXI0mdFFCL7TaVR43kjsg3
   c43kZ7369MeEZzCCAvswggHjoAMCAQICCQDprp3DmjOyETANBgkqhkiG9w0BAQUF
   ADAbMRkwFwYDVQQDExBlc3RFeGFtcGxlQ0EgTndOMB4XDTEzMDUwOTAzNTMzMloX
   DTE0MDUwOTAzNTMzMlowGzEZMBcGA1UEAxMQZXN0RXhhbXBsZUNBIE53TjCCASIw
   DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJ5962d6zCR8H+zA/SuJrm8RwL7X
   Z67EH+Tn4LTIUSC+GnjzYQHYD8o/ApaMToA91E1fnUNVYjs1cTze2nIpKDp5CHUa
   Y6TqZMjKPipLxzEFxp0E27DAL9alrfUtdgzKaNBjgNXuBnt7neWDzk0f6uj74zed
   SBMGCpLBuwoJcGcAfuSW8IWK9g/9Lm7Rpba4kVYsT1q77fsM/yE6ea3I4f/EUtyx
   PLUMt5EzYSRd2P3rEdrEoDojzYCLaAgE8rG2iDRD6+DHpqjC+LQ6Uf2hvcvvEHu7
   NS8jBbw5XradppgcpAAv+5zmrf6cFJQdLDeduA9VwIM/GSr1q5IfmWjq94cCAwEA
   AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUscRp5lujBKfYl6OLO7+5
   arIyQjwwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUAA4IBAQBCz/CWdYvn
   GM/SdCdEiom5A1VxaW8nKgCWg/EyWtAIiaHQuViB+jTUAE9lona2MbJoFHW8U5e8
   9dCP0rJpA9UYXXhWvFQzd5ZWpms4wUYt1j3gqqd36KorJIAuPigVng13yKytxM7c
   VmxQnh0aux3aEnEyRGAhGalHp0RaKdgPRzUaGtipJTNBkSV5S4kD4yDCPHMNbBu+
   OcluerwEpbz6GvE7CpXl2jrTBZSqBsFelq0iz4kk9++9CnwZwrVgdzklhRfJ1Z4j
   NkLruwbQ+o4NvBZsXiKxNfn3K2o3SK8AuaEyDWkq18+5rjcfprRO8x4YTW+6mXPq
   jM0MAGNDEW+1oQAxAA==
                
REQUIREMENT 41: FULL CMC RESPONSE
     
If the enrollment is successful, the server response MUST include an HTTP 200 response code with a content-type of "application/pkcs7-mime" as specified in [RFC5273]. The response data includes either the Simple PKI Response with an smime-type parameter of "certs-only" or the Full PKI Response with an smime-type parameter "CMC-response", as specified in Section 3.2.1 of [RFC5751]. The body of the message is the binary value of the encoding of the PKI Response with a Content-Transfer-Encoding of "base64" [RFC2045].

When rejecting a request, the server MUST specify either an HTTP 4xx error or an HTTP 5xx error. A CMC response with the content-type of "application/pkcs7-mime" MUST be included in the response data for any CMC error response.

All other return codes are handled as specified in Section 4.2.3 or HTTP [RFC2616]. For example, a client interprets an HTTP 404 or 501 response to indicate that this service is not implemented.
REQUIREMENT 57: ENROLL/RE-ENROLL
     
The following is an example of a valid /simpleenroll exchange. The data messages for /simplereenroll are similar.

During this exchange, the EST client uses an out-of-band distributed username/password to authenticate itself to the EST server. This is the normal HTTP WWW-Authenticate behavior and is included here for informative purposes. When an existing TLS client certificate is used, the server might skip requesting the HTTP WWW-Authenticate header, such as during a /simplereenroll operation.

During the initial TLS handshake, the client can ignore the optional server-generated "certificate request" and can instead proceed with the HTTP POST request. In response to the initial HTTP POST attempt, the server requests WWW-Authenticate from the client (this might occur even if the client used a client certificate, as detailed in the normative text above):


   HTTP/1.1 401 Unauthorized
   Content-Length: 0
   WWW-Authenticate: Digest qop="auth", realm="estrealm",
   nonce="1368141352"

                
In the subsequent HTTP POST, the username/password is included, along with the complete application/pkcs10 content:


   POST /.well-known/est/simpleenroll HTTP/1.1
   Authorization: Digest username="estuser", realm="estrealm", nonc
   e="1368141352", uri="/.well-known/est/simpleenroll", cnonce="M
   TYwMzg3", nc=00000001, qop="auth", response="144cc27f96046f1d70e
   b16db20f75f22"
   Host: 192.0.2.1:8085
   Accept: */*
   Content-Type: application/pkcs10
   Content-Transfer-Encoding: base64
   Content-Length: 882

   MIIChTCCAW0CAQAwHzEdMBsGA1UEAxMUZGVtb3N0ZXA0IDEzNjgxNDEzNTIwggEi
   MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQClNp+kdz+Nj8XpEp9kaumWxDZ3
   eFYJpQKz9ddD5e5OzUeCm103ZIXQIxc0eVtMCatnRr3dnZRCAxGjwbqoB3eKt29/
   XSQffVv+odbyw0WdkQOIbntCQry8YdcBZ+8LjI/N7M2krmjmoSLmLwU2V4aNKf0Y
   MLR5Krmah3Ik31jmYCSvwTnv6mx6pr2pTJ82JavhTEIIt/fAYq1RYhkM1CXoBL+y
   hEoDanN7TzC94skfS3VV+f53J9SkUxTYcy1Rw0k3VXfxWwy+cSKEPREl7I6k0YeK
   tDEVAgBIEYM/L1S69RXTLujirwnqSRjOquzkAkD31BE961KZCxeYGrhxaR4PAgMB
   AAGgITAfBgkqhkiG9w0BCQcxEhMQK3JyQ2lyLzcrRVl1NTBUNDANBgkqhkiG9w0B
   AQUFAAOCAQEARBv0AJeXaHpl1MFIdzWqoi1dOCf6U+qaYWcBzpLADvJrPK1qx5pq
   wXM830A1O+7RvrFv+nyd6VF2rl/MrNp+IsKuA9LYWIBjVe/LXoBO8dB/KxrYl16c
   VUS+Yydi1m/a+DaftYSRGolMLtWeiqbc2SDBr2kHXW1TR130hIcpwmr29kC2Kzur
   5thsuj276FGL1vPu0dRfGQfx4WWa9uAHBgz6tW37CepZsrUKe/0pfVhr2oHxApYh
   cHGBQDQHVTFVjHccdUjAXicrtbsVhU5o1lPv7f4lEApv3SBQmJcaq5O832BzHw7n
   PyMFcM15E9gtUVee5C62bVwuk/tbnGsbwQ==

                
The EST server uses the username/password to perform authentication/authorization and responds with the issued certificate:

   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: application/pkcs7-mime; smime-type=certs-only
   Content-Transfer-Encoding: base64
   Content-Length: 1122

   MIIDOAYJKoZIhvcNAQcCoIIDKTCCAyUCAQExADALBgkqhkiG9w0BBwGgggMLMIID
   BzCCAe+gAwIBAgIBFTANBgkqhkiG9w0BAQUFADAbMRkwFwYDVQQDExBlc3RFeGFt
   cGxlQ0EgTndOMB4XDTEzMDUwOTIzMTU1M1oXDTE0MDUwOTIzMTU1M1owHzEdMBsG
   A1UEAxMUZGVtb3N0ZXA0IDEzNjgxNDEzNTIwggEiMA0GCSqGSIb3DQEBAQUAA4IB
   DwAwggEKAoIBAQClNp+kdz+Nj8XpEp9kaumWxDZ3eFYJpQKz9ddD5e5OzUeCm103
   ZIXQIxc0eVtMCatnRr3dnZRCAxGjwbqoB3eKt29/XSQffVv+odbyw0WdkQOIbntC
   Qry8YdcBZ+8LjI/N7M2krmjmoSLmLwU2V4aNKf0YMLR5Krmah3Ik31jmYCSvwTnv
   6mx6pr2pTJ82JavhTEIIt/fAYq1RYhkM1CXoBL+yhEoDanN7TzC94skfS3VV+f53
   J9SkUxTYcy1Rw0k3VXfxWwy+cSKEPREl7I6k0YeKtDEVAgBIEYM/L1S69RXTLuji
   rwnqSRjOquzkAkD31BE961KZCxeYGrhxaR4PAgMBAAGjUjBQMA4GA1UdDwEB/wQE
   AwIEsDAdBgNVHQ4EFgQU/qDdB6ii6icQ8wGMXvy1jfE4xtUwHwYDVR0jBBgwFoAU
   scRp5lujBKfYl6OLO7+5arIyQjwwDQYJKoZIhvcNAQEFBQADggEBACmxg1hvL6+7
   a+lFTARoxainBx5gxdZ9omSb0L+qL+4PDvg/+KHzKsDnMCrcU6M4YP5n0EDKmGa6
   4lY8fbET4tt7juJg6ixb95/760Th0vuctwkGr6+D6ETTfqyHnrbhX3lAhnB+0Ja7
   o1gv4CWxh1I8aRaTXdpOHORvN0SMXdcrlCys2vrtOl+LjR2a3kajJO6eQ5leOdzF
   QlZfOPhaLWen0e2BLNJI0vsC2Fa+2LMCnfC38XfGALa5A8e7fNHXWZBjXZLBCza3
   rEs9Mlh2CjA/ocSC/WxmMvd+Eqnt/FpggRy+F8IZSRvBaRUCtGE1lgDmu6AFUxce
   R4POrT2xz8ChADEA
REQUIREMENT 7: CERTIFICATE-LESS TLS AUTHENTICATION
     
The EST client and EST server can be mutually authenticated using a certificate-less TLS cipher suite (see Section 3.3.3).
REQUIREMENT 6: CERTIFICATE TLS AUTHENTICATION
     
If the EST client has a previously installed certificate issued by a third-party CA, this certificate can be used to authenticate the client's request for a certificate from the EST server (if that CA is recognized by the EST server). An EST client responds to the EST server's TLS certificate request message with the existing certificate already held by the client. The EST server will verify the client's existing certificate and authorize the client's request as described in Section 3.3.2.
REQUIREMENT 42: SERVER-SIDE KEY GENERATION
     
An EST client may request a private key and associated certificate from an EST server using an HTTPS POST with an operation path value of "/serverkeygen". Support for the /serverkeygen function is OPTIONAL.

A client MUST authenticate an EST server, as specified in Section 3.3.1 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used, and check the server's authorization as given in Section 3.6.

The EST server MUST authenticate the client, as specified in Section 3.3.2 if certificate-based authenticated is used or Section 3.3.3 if the optional certificate-less authentication is used, and check the client's authorization as given in Section 3.7. The EST server applies whatever authorization or logic it chooses to determine if the private key and certificate should be provided.

Cipher suites that have a NULL confidentiality algorithm MUST NOT be used as they will disclose the contents of an unprotected private key.

Proper random number and key generation [RFC4086] is a server implementation responsibility, and server archiving of generated keys is determined by CA policy. The key pair and certificate are transferred over the TLS session. The cipher suite used to return the private key and certificate MUST offer confidentiality commensurate with the private key being delivered to the client.

The EST client MAY request additional certificates even when using an existing certificate in the TLS client authentication. For example, the client can use an existing certificate for TLS client authentication when requesting a certificate that cannot be used for TLS client authentication.
REQUIREMENT 56: CSR ATTRIBUTES
     
The following is an example of a valid /csrattrs exchange. During this exchange, the EST client authenticates itself using an existing certificate issued by the CA for which the EST server provides services.

The initial TLS handshake is identical to the enrollment example handshake. The HTTP GET request:


   GET /.well-known/est/csrattrs HTTP/1.1
   User-Agent: curl/7.22.0 (i686-pc-linux-gnu) libcurl/7.22.0 OpenS
   SL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
   Host: 192.0.2.1:8085
   Accept: */*

                
In response, the server provides suggested attributes that are appropriate for the authenticated client. In this example, the EST server also includes two example attributes that the client would ignore unless the attribute type is known to the client:

                    
   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: application/csrattrs
   Content-Transfer-Encoding: base64
   Content-Length: 171

   MHwGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEG
   CSqGSIb3DQEJBzAsBgOINwIxJQYDiDcDBgOINwQTGVBhcnNlIFNFVCBhcyAyLjk5
   OS4yIGRhdGEGCSskAwMCCAEBCwYJYIZIAWUDBAIC
                    
REQUIREMENT 19: MESSAGE TYPES
     
This document uses existing media types for the messages as specified by FTP and HTTP [RFC2585], application/pkcs10 [RFC5967], and CMC [RFC5272].

For consistency with [RFC5273], each distinct EST message type uses an HTTP Content-Type header with a specific media type.

The EST messages and their corresponding media types for each operation are:

   +--------------------+--------------------------+-------------------+
   | Message type       | Request media type       | Request section(s)|
   |                    | Response media type(s)   | Response section  |
   | (per operation)    | Source(s) of types       |                   |
   +====================+==========================+===================+
   | Distribution of CA | N/A                      | Section 4.1       |
   | Certificates       | application/pkcs7-mime   | Section 4.1.1     |
   |                    | [RFC5751]                |                   |
   | /cacerts           |                          |                   |
   +--------------------+--------------------------+-------------------+
   | Client Certificate | application/pkcs10       | Sections 4.2/4.2.1|
   | Request Functions  | application/pkcs7-mime   | Section 4.2.2     |
   |                    | [RFC5967] [RFC5751]      |                   |
   | /simpleenroll      |                          |                   |
   | /simplereenroll    |                          |                   |
   +--------------------+--------------------------+-------------------+
   | Full CMC           | application/pkcs7-mime   | Section 4.3.1     |
   |                    | application/pkcs7-mime   | Section 4.3.2     |
   | /fullcmc           | [RFC5751]                |                   |
   +--------------------+--------------------------+-------------------+
   | Server-Side Key    | application/pkcs10       | Section 4.4.1     |
   | Generation         | multipart/mixed          | Section 4.4.2     |
   |                    | (application/pkcs7-mime &|                   |
   |                    | application/pkcs8)       |                   |
   |                    | [RFC5967] [RFC5751]      |                   |
   | /serverkeygen      | [RFC5958]                |                   |
   +--------------------+--------------------------+-------------------+
   | CSR Attributes     | N/A                      | Section 4.5.1     |
   |                    | application/csrattrs     | Section 4.5.2     |
   |                    | (This document)          |                   |
   | /csrattrs          |                          |                   |
   +--------------------+--------------------------+-------------------+

                                 Figure 6
REQUIREMENT 31: DISTRIBUTION OF CA CERTIFICATES
     
The EST client can request a copy of the current CA certificates. This function is generally performed before other EST functions.
REQUIREMENT 25: LINKING IDENTITY AND POP INFORMATION
     
Server policy will determine whether clients are required to use the mechanism specified in this section. This specification provides a method of linking identity and proof-of-possession by including information specific to the current authenticated TLS session within the signed certification request. The client can determine if the server requires the linking of identity and POP by examining the CSR Attributes Response (see Section 4.5.2). Regardless of the CSR Attributes Response, clients SHOULD link identity and POP by embedding tls-unique information in the certification request. If tls-unique information is included by the client, the server MUST verify it. The EST server MAY reject requests without tls-unique information as indicated by server policy.

Linking identity and proof-of-possession proves to the server that the authenticated TLS client has possession of the private key associated with the certification request, and that the client was able to sign the certification request after the TLS session was established. This is an alternative to the "Linking Identity and POP Information" method defined by Section 6 of [RFC5272] that is available if Full PKI messages are used.

The client generating the CSR obtains the tls-unique value from the TLS subsystem as described in Channel Bindings for TLS [RFC5929]. The EST client operations between obtaining the tls-unique value through generation of the CSR that contains the current tls-unique value and the subsequent verification of this value by the EST server are the "phases of the application protocol during which application- layer authentication occurs"; these operations are protected by the synchronization interoperability mechanism described in the "Channel Bindings for TLS" interoperability notes in Section 3.1 of [RFC5929].

When performing renegotiation, TLS "secure_renegotiation" [RFC5746] MUST be used.

The tls-unique value is base64 encoded as specified in Section 4 of [RFC4648], and the resulting string is placed in the certification request challenge-password field ([RFC2985], Section 5.4.1). The challenge-password field is limited to 255 bytes (Section 7.4.9 of [RFC5246] indicates that no existing cipher suite would result in an issue with this limitation). If the challenge-password attribute is absent, the client did not include the optional channel-binding information (the presence of the challenge-password attribute indicates the inclusion of tls-unique information).

If the EST server makes use of a back-end infrastructure for processing, it is RECOMMENDED that the results of this verification be communicated. (For example, this communication might use the CMC [RFC5272] "RA POP Witness Control" in a CMC Full PKI Request message. Or, an EST server might TLS-authenticate an EST client as being a trusted infrastructure element that does not forward invalid requests. A detailed discussion of back-end processing is out of scope.)

When rejecting requests, the EST server response is as described for all enroll responses (Section 4.2.3). If a Full PKI Response is included, the CMCFailInfo MUST be set to popFailed. If a human- readable reject message is included, it SHOULD include an informative text message indicating that the linking of identity and POP information is required.
REQUIREMENT 24: PROOF-OF-POSSESSION
     
As defined in Section 2.1 of CMC [RFC5272], proof-of-possession (POP) "refers to a value that can be used to prove that the private key corresponding to the public key is in the possession of and can be used by an end-entity".

The signed enrollment request provides a signature-based proof-of-possession. The mechanism described in Section 3.5 strengthens this by optionally including "Direct"-based proof-of-possession [RFC5272] by including TLS session-specific information within the data covered by the enrollment request signature (thus linking the enrollment request to the authenticated end point of the TLS connection).
REQUIREMENT 18: HTTP-BASED CLIENT AUTHENTICATION
     
The EST server MAY request HTTP-based client authentication. This request can be in addition to successful TLS client authentication (Section 3.3.2) if EST server policy requires additional authentication. (For example, the EST server may require that an EST client "knows" a password in addition to "having" an existing client certificate.) Or, HTTP-based client authentication can be an EST server policy-specified fallback in situations where the EST client did not successfully complete the TLS client authentication. (This might arise if the EST client is enrolling for the first time or if the certificates available to an EST client cannot be used for TLS client authentication.)

HTTP Basic and Digest authentication MUST only be performed over TLS 1.1 [RFC4346] or later versions. NULL and anon cipher suites MUST NOT be used because they do not provide confidentiality or support mutual certificate-based or certificate-less authentication, respectively. As specified in "Certificate Management over CMS (CMC): Transport Protocols" [RFC5273], the server "MUST NOT assume client support for any type of HTTP authentication such as cookies, Basic authentication, or Digest authentication". Clients SHOULD support the Basic and Digest authentication mechanism.

Servers that wish to use Basic and Digest authentication reject the HTTP request using the HTTP-defined WWW-Authenticate response-header ([RFC2616], Section 14.47). The client is expected to retry the request, including the appropriate Authorization Request header ([RFC2617], Section 3.2.2), if the client is capable of using the Basic or Digest authentication. If the client is not capable of retrying the request or it is not capable of Basic or Digest authentication, then the client MUST terminate the connection.

A client MAY set the username to the empty string ("") if it is presenting a password that is not associated with a username.

Support for HTTP-based client authentication has security ramifications as discussed in Section 6. The client MUST NOT respond to the server's HTTP authentication request unless the client has authorized the EST server (as per Section 3.6).
REQUIREMENT 26: SERVER AUTHORIZATION
     
The client MUST check EST server authorization before accepting any server responses or responding to HTTP authentication requests.

The EST client authorization method depends on which method was used to authenticate the server. When the Explicit TA database is used to authenticate the EST server, then Section 3.6.1 applies. When the Implicit TA database is used to authenticate the EST server, then Section 3.6.2 applies. Successful authentication using a certificate-less cipher suite implies authorization of the server.

The client MAY perform bootstrapping as specified in Section 4.1.1 even if these checks fail.
REQUIREMENT 32: BOOTSTRAP DISTRIBUTION OF CA CERTIFICATES
     
It is possible that the client was not configured with an Implicit TA database that allows a bootstrap installation of the Explicit TA database as described in 4.1.3. This section describes an alternate method by which minimally configured EST clients can populate their Explicit TA database.

If the EST client application does not specify either an Explicit TA database or an Implicit TA database, then the initial TLS server authentication and authorization will fail. The client MAY provisionally continue the TLS handshake to completion for the purposes of accessing the /cacerts or /fullcmc method. If the EST client continues with an unauthenticated connection, the client MUST extract the HTTP content data from the response (Sections 4.1.3 or 4.3.2) and engage a human user to authorize the CA certificate using out-of-band data such as a CA certificate "fingerprint" (e.g., a SHA-256 or SHA-512 [SHS] hash on the whole CA certificate). In a /fullcmc response, it is the Publish Trust Anchors control (CMC [RFC5272], Section 6.15) within the Full PKI Response that must be accepted manually. It is incumbent on the user to properly verify the TA information, or to provide the "fingerprint" data during configuration that is necessary to verify the TA information.

HTTP authentication requests MUST NOT be responded to if the server has not been authenticated as specified in Section 3.3.1 or if the optional certificate-less authentication is used as specified in Section 3.3.3.

The EST client uses the /cacerts response to establish an Explicit Trust Anchor database for subsequent TLS authentication of the EST server. EST clients MUST NOT engage in any other protocol exchange until after the /cacerts response has been accepted and a new TLS session has been established (using TLS certificate-based authentication).
REQUIREMENT 33: CA CERTIFICATES REQUEST
     
EST clients request the EST CA TA database information of the CA (in the form of certificates) with an HTTPS GET message using an operation path of "/cacerts". EST clients and servers MUST support the /cacerts function. Clients SHOULD request an up-to-date response before stored information has expired in order to ensure the EST CA TA database is up to date.

The EST server SHOULD NOT require client authentication or authorization to reply to this request.

The client MUST authenticate the EST server, as specified in Section 3.3.1 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used, and check the server's authorization as given in Section 3.6, or follow the procedure outlined in Section 4.1.1.
REQUIREMENT 27: CLIENT USE OF EXPLICIT TA DATABASE
     
When the EST client Explicit TA database is used to validate the EST server certificate, the client MUST check either the configured URI or the most recent HTTP redirection URI against the server's identity according to the rules specified in [RFC6125], Section 6.4, or the EST server certificate MUST contain the id-kp-cmcRA [RFC6402] extended key usage extension.
REQUIREMENT 23: CERTIFICATE-LESS TLS MUTUAL AUTHENTICATION
     
Certificate-less TLS cipher suites provide a way to perform mutual authentication in situations where neither the client nor server have certificates, do not desire to use certificates, or do not have the trust anchors necessary to verify a certificate. The client and server MAY negotiate a certificate-less cipher suite for mutual authentication.

When using certificate-less mutual authentication in TLS for enrollment, the cipher suite MUST be based on a protocol that is resistant to dictionary attack and MUST be based on a zero knowledge protocol. Transport Layer Security-Secure Remote Password (TLS-SRP) cipher suites, i.e., those with _SRP_ in the name, listed in Section 2.7 of [RFC5054] are suitable for this purpose. Section 6 lists the characteristics of a cipher suite that are suitable for use in certificate-less mutual authentication for enrollment.

Successful authentication using a certificate-less cipher suite proves knowledge of a pre-shared secret that implicitly authorizes a peer in the exchange.
REQUIREMENT 37: SIMPLE RE-ENROLLMENT OF CLIENTS
     
EST clients renew/rekey certificates with an HTTPS POST using the operation path value of "/simplereenroll".

A certificate request employs the same format as the "simpleenroll" request, using the same HTTP content-type. The request Subject field and SubjectAltName extension MUST be identical to the corresponding fields in the certificate being renewed/rekeyed. The ChangeSubjectName attribute, as defined in [RFC6402], MAY be included in the CSR to request that these fields be changed in the new certificate.

If the Subject Public Key Info in the certification request is the same as the current client certificate, then the EST server renews the client certificate. If the public key information in the certification request is different than the current client certificate, then the EST server rekeys the client certificate.
REQUIREMENT 36: SIMPLE ENROLLMENT OF CLIENTS
     
When HTTPS POSTing to /simpleenroll, the client MUST include a Simple PKI Request as specified in CMC [RFC5272], Section 3.1 (i.e., a PKCS https://tools.ietf.org/html/rfc7030#10 Certification Request [RFC2986]).

The Certification Signing Request (CSR) signature provides proof-of-possession of the client-possessed private key to the EST server. If the CSR KeyUsage extension indicates that the private key can be used to generate digital signatures, then the client MUST generate the CSR signature using the private key. If the key can be used to generate digital signatures but the requested CSR KeyUsage extension prohibits generation of digital signatures, then the CSR signature MAY still be generated using the private key, but the key MUST NOT be used for any other signature operations (this is consistent with the recommendations concerning submission of proof-of-possession to an RA or CA as described in [SP-800-57-Part-1]). The use of /fullcmc operations provides access to more advanced proof-of-possession methods that are used when the key pair cannot be used for digital signature generation (see Section 4.3).

The HTTP content-type of "application/pkcs10" is used here. The format of the message is as specified in [RFC5967] with a Content- Transfer-Encoding of "base64" [RFC2045].

If the EST client authenticated using a previously installed certificate issued by a third-party CA (see Section 2.2.1), the client MAY include the ChangeSubjectName attribute, as defined in [RFC6402], in the CSR to request that the subjectName and SubjectAltName be changed in the new certificate.

The EST client MAY request additional certificates even when using an existing certificate in the TLS client authentication. For example, the client can use an existing certificate for TLS client authentication when requesting a certificate that cannot be used for TLS client authentication.
REQUIREMENT 22:
     
TLS client authentication is the RECOMMENDED method for identifying EST clients. HTTP-based client authentication (Section 3.2.3) MAY be used.

The EST server authenticates the EST client as defined for the cipher suite negotiated. The following text provides details assuming a certificate-based cipher suite such as the TLS 1.1 [RFC4346] mandatory cipher suite (TLS_RSA_WITH_3DES_EDE_CBC_SHA). The EST server MUST support certificate-based client authentication.

Generally, the client will use an existing certificate for renew or rekey operations. If the certificate to be renewed or rekeyed is appropriate for the negotiated cipher suite, then the client MUST use it for the TLS handshake, otherwise the client SHOULD use an alternate certificate that is suitable for the cipher suite and contains the same subject identity information. When requesting an enroll operation, the client MAY use a client certificate issued by a third party to authenticate itself.

Certificate validation MUST be performed as per [RFC5280]. The EST client certificate MUST conform to the [RFC5280] certificate profile.

The server validates the TLS client certificate using the EST server Explicit and, if enabled, Implicit TA database(s). The server MUST maintain a distinction between the use of Explicit and Implicit TA databases during authentication in order to support proper authorization.

The EST server MUST perform authorization checks as specified in Section 3.7.

If a client does not support TLS client authentication, then it MUST support HTTP-based client authentication (Section 3.2.3) or certificate-less TLS authentication (Section 3.3.3).
REQUIREMENT 34: CA CERTIFICATES RESPONSE
     
If successful, the server response MUST have an HTTP 200 response code. Any other response code indicates an error and the client MUST abort the protocol.

A successful response MUST be a certs-only CMC Simple PKI Response, as defined in [RFC5272], containing the certificates described in the following paragraph. The HTTP content-type of "application/pkcs7-mime" is used. The Simple PKI Response is sent with a Content-Transfer-Encoding of "base64" [RFC2045].

The EST server MUST include the current root CA certificate in the response. The EST server MUST include any additional certificates the client would need to build a chain from an EST CA-issued certificate to the current EST CA TA. For example, if the EST CA is a subordinate CA, then all the appropriate subordinate CA certificates necessary to build a chain to the root EST CA are included in the response.

The EST server SHOULD include the three "Root CA Key Update" certificates OldWithOld, OldWithNew, and NewWithOld in the response chain. These are defined in Section 4.4 of CMP [RFC4210]. The EST client MUST be able to handle these certificates in the response. The EST CA's most recent self-signed certificate (e.g., NewWithNew certificate) is self-signed and has the latest NotAfter date. If the EST server does not include these in the response, then after the current EST CA certificate expires, the EST clients will need to be reinitialized with the PKI using the Bootstrap Distribution of CA certificates (Section 4.1.1) method, which involves user interaction.

After out-of-band validation occurs, all the other certificates MUST be validated using normal [RFC5280] certificate path validation (using the most recent CA certificate as the TA) before they can be used to build certificate paths during certificate validation.

The EST client MUST store the extracted EST CA certificate as an Explicit TA database entry for subsequent EST server authentication. The EST client SHOULD disable use of Implicit TA database entries for this EST server now that an Explicit TA database entry is available. If the client disables the Implicit TA database, and if the EST server certificate was verified using an Implicit TA database entry, then the client MUST include the "Trusted CA Indication" extension in future TLS sessions [RFC6066]. This indicates to the server that only an EST server certificate authenticatable by the Explicit TA database entry is now acceptable (otherwise, the EST server might continue to use a server certificate that is only verifiable by a now disabled Implicit TA).

The EST client SHOULD also make the CA Certificate response information available to the end-entity software for use when validating peer certificates.
REQUIREMENT 20: TLS LAYER
     
TLS provides authentication, which in turn enables authorization decisions. The EST server and EST client are responsible for ensuring that an acceptable cipher suite is negotiated and that mutual authentication has been performed. TLS authentication is most commonly enabled with the use of certificates [RFC5280]. Alternately, certificate-less TLS authentication, where neither the client nor server present a certificate, is also an acceptable method for EST mutual authentication (Section 3.3.3). The EST server MUST be authenticated during the TLS handshake unless the client is requesting Bootstrap Distribution of CA certificates (Section 4.1.1) or Full CMC (Section 4.3).

HTTPS [RFC2818] specifies how HTTP messages are carried over TLS. HTTPS MUST be used. TLS 1.1 [RFC4346] (or a later version) MUST be used for all EST communications. TLS session resumption [RFC5077] SHOULD be supported.

TLS channel-binding information can be inserted into a certificate request, as detailed in Section 3.5, in order to provide the EST server with assurance that the authenticated TLS client has access to the private key for the certificate being requested. The EST server MUST implement Section 3.5.
REQUIREMENT 21: TLS-BASED SERVER AUTHENTICATION
     
TLS server authentication with certificates MUST be supported.

The EST client authenticates the EST server as defined for the cipher suite negotiated. The following text provides details assuming a certificate-based cipher suite, such as the TLS 1.1 [RFC4346] mandatory cipher suite (TLS_RSA_WITH_3DES_EDE_CBC_SHA).

Certificate validation MUST be performed as per [RFC5280]. The EST server certificate MUST conform to the [RFC5280] certificate profile.

The client validates the TLS server certificate using the EST client Explicit and, if enabled, Implicit TA database(s). The client MUST maintain a distinction between the use of Explicit and Implicit TA databases during authentication in order to support proper authorization. The EST client MUST perform authorization checks as specified in Section 3.6.

If certificate validation fails, the client MAY follow the procedure outlined in Section 4.1.1 for Bootstrap Distribution of CA certificates.
REQUIREMENT 35: CLIENT CERTIFICATE REQUEST FUNCTIONS
     
EST clients request a certificate from the EST server with an HTTPS POST using the operation path value of "/simpleenroll". EST clients request a renew/rekey of existing certificates with an HTTP POST using the operation path value of "/simplereenroll". EST servers MUST support the /simpleenroll and /simplereenroll functions.

It is RECOMMENDED that a client obtain the current CA certificates, as described in Section 4.1, before performing certificate request functions. This ensures that the client will be able to validate the EST server certificate. The client MUST authenticate the EST server as specified in Section 3.3.1 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used. The client MUST verify the authorization of the EST server as specified in Section 3.6.

The server MUST authenticate the client as specified in Section 3.3.2 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used. The server MUST verify client authorization as specified in Section 3.7. The EST server MUST check the tls-unique value, as described in Section 3.5, if one is submitted by the client.

The server MAY accept a certificate request for manual authorization checking by an administrator. (Section 4.2.3 describes the use of an HTTP 202 response to the EST client if this occurs.)
/*------------------------------------------------------------------
 * us895.c - Unit Tests for User Story 895 - Proxy CSR Attributes
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US895_SERVER_PORT   29895
#define US895_PROXY_PORT   29095

#ifndef WIN32
#define US895_CACERT        "CA/estCA/cacert.crt"
#define US895_TRUSTED_CERT  "CA/trustedcerts.crt"
#define SERVER_UT_CACERT    "CA/estCA/cacert.crt"
#define SERVER_UT_PUBKEY    "./est_client_ut_keypair"

#define US895_SERVER_IP     "127.0.0.1" 
#define US895_CACERTS       "CA/estCA/cacert.crt"
#define US895_TRUST_CERTS   "CA/trustedcerts.crt"
#define US895_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else
#define US895_CACERT        "CA\\estCA\\cacert.crt"
#define US895_TRUSTED_CERT  "CA\\trustedcerts.crt"
#define SERVER_UT_CACERT     "CA\\estCA\\cacert.crt"
#define SERVER_UT_PUBKEY    "est_client_ut_keypair"

#define US895_SERVER_IP     "127.0.0.1" 
#define US895_CACERTS       "CA\\estCA\\cacert.crt"
#define US895_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US895_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif

#define TEST_ATTR_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR_NOPOP "MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\0"
#define TEST_ATTR_NOPOPPOP "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR_POPADDED "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR1 "MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\0"
#define TEST_ATTR2 "MAA=\0"
#define TEST_ATTR7 "MA==\0"
#define TEST_ATTR2_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR8 "MAthisis badsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR3 "MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\0"
#define TEST_ATTR4_122 "MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR4_122POP "MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR5_117 "MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR5_117POP "MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ATTR6_116 "MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR_244 "MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_245 "MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"
#define TEST_ATTR_250 "MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_250POP "MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ALL_ATTR "MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\0"
#define TEST_1024_NOPOP "MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\0"

#define TEST_1025_NOPOP "MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_1024_POP "MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\0"

#define TEST_LONG_ATTR "MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"

#define EST_UT_MAX_CMD_LEN 255
extern EST_CTX *ectx;

static void us895_clean (void)
{
}

static int us895_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US895_SERVER_PORT,
                  US895_SERVER_CERTKEY,
                  US895_SERVER_CERTKEY,
                  "US895 test realm",
                  US895_CACERT,
                  US895_TRUSTED_CERT,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);

    if (rv) {
        return (rv);
    }

    /*
     * Next we start an EST proxy acting as an RA
     */
    rv = st_proxy_start(US895_PROXY_PORT,
                        US895_SERVER_CERTKEY,
                        US895_SERVER_CERTKEY,
                        "US895 test realm",
                        US895_CACERT,
                        US895_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US895_SERVER_PORT,
                        0,
                        nid);

    SLEEP(1);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us895_init_suite (void)
{
    int rv = 0;
    char cmd[EST_UT_MAX_CMD_LEN];

    printf("Starting EST Server CSR attributes unit tests.\n");

    /*
     * gen the keypair to be used for EST Proxy testing
     */
    snprintf(
        cmd,
        EST_UT_MAX_CMD_LEN,
        "openssl ecparam -name prime256v1 -genkey -out %s",
        SERVER_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US895_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    /*
     * start the server for the tests that need to talk to a server
     */
    us895_clean();

    /*
     * Start an instance of the EST server
     */
    rv = us895_start_server(0, 0);
    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us895_destroy_suite (void)
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
    return 0;
}

static unsigned char * handle_short_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR7);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_corrupt_csrattrs_request (int *csr_len,
                                                        char *path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR8);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_long_csrattrs_request (int *csr_len,
                                                     char *path_seg,
                                                     void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_LONG_ATTR);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_correct_csrattrs_request (int *csr_len,
                                                        char * path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR1);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_nopop_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR_NOPOP);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_empty_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = 0;
    csr_data = NULL;
    return (csr_data);
}

/*
 * Callback function passed to est_proxy_init()
 */
static int proxy_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__,
        openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Test1 - exercise the server side variations triggered
 *         by est_client_get_csrattrs()
 */
static void us895_test1 (void)
{
    EST_CTX *ctx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY * priv_key;
    int csr_len;
    unsigned char *csr_data = NULL;

    SLEEP(1);

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(SERVER_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(SERVER_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", SERVER_UT_PUBKEY);
        return;
    }

    ctx = est_client_init(
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        proxy_manual_cert_verify);
    CU_ASSERT(ctx != NULL);

    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ctx, US895_SERVER_IP, US895_PROXY_PORT, NULL);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    /* should get 204 with no data */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    /* Real base64 string - should pass */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_short_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_corrupt_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_long_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Setting the smallest base64 size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2));
    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR3));
    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));
    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* Enable PoP and test responses with PoP added */
    st_enable_pop();

    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_data != NULL);
    CU_ASSERT(csr_len = 20);
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_POP));
    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));
    CU_ASSERT(
        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));
    CU_ASSERT(
        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);

    /* Real base64 string needs PoP added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 116 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 244 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 245 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 250 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));
    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_nopop_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_empty_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* disable PoP */
    st_disable_pop();

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Real base64 string PoP should not be added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));
    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);

    if (ctx) {
        est_destroy(ctx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us895_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us895_proxy_csrattrs",
            us895_init_suite,
            us895_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "CSR Proxy Attributes API1", us895_test1)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us748.c - Unit Tests for User Story 748 - Proxy simple enroll
 *
 * August, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US748_RETRY_INTERVAL    3600
//#define US748_TCP_PORT        29001

#define US748_TCP_SERVER_PORT       15748
#define US748_TCP_PROXY_PORT        16748

#ifndef WIN32
static char test5_outfile[FILENAME_MAX] = "US748/test5.hdr";
#define US748_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US748_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
/* #define US748_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US748_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US748_PROXY_CERT "US748/cert.pem"  
#define US748_PROXY_KEY "US748/key.pem"
#define US748_CACERT "CA/estCA/cacert.crt"
#define US748_TRUSTED_CERT "CA/trustedcerts.crt"
#else
static char test5_outfile[FILENAME_MAX] = "US748\\test5.hdr";
#define US748_SERVER_CERT "CA\\estCA/private\\estservercertandkey.pem"
#define US748_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
/* #define US748_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US748_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US748_PROXY_CERT "US748\\cert.pem"  
#define US748_PROXY_KEY "US748\\key.pem"
#define US748_CACERT "CA\\estCA\\cacert.crt"
#define US748_TRUSTED_CERT "CA\\trustedcerts.crt"
#endif
/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US748_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the ec.req file:
 *
 * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM
 */
#define US748_PKCS10_DSA1024 "MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\nzn9HujlXNaTA1OhjmPmcJSxT"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the dsa.req file:
 *
 * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM
 */
#define US748_PKCS10_ECDSA256 "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

#define US748_PKCS10_CORRUPT "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

/*
 * The following is a valid CSR that already contains a PoP
 * challengePassword.  This was collected using estserver with
 * the dumpbin() function.  This CSR should never work since
 * the PoP value in it will be stale.
 */
#define US748_PKCS10_STALE_POP "MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40="

#define US748_ENROLL_URL_BA "https://127.0.0.1:15748/.well-known/est/simpleenroll"

#define US748_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US748_UIDPWD_GOOD   "estuser:estpwd"
#define US748_CACERTS       "CA/estCA/cacert.crt"
#define US748_EXPLICIT_CERT "US748/cert-RA.pem" 
#define US748_EXPLICIT_KEY  "US748/key-RA.pem"

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__, openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

static FILE *outfile;
static size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

static void us748_clean (void)
{
}

static int us748_start_server (int manual_enroll, int nid)
{
    int rv = 0;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US748_TCP_SERVER_PORT,
                  US748_SERVER_CERT,
                  US748_SERVER_KEY,
                  "estrealm",
                  US748_CACERT,
                  US748_TRUSTED_CERT,
                  "US748/estExampleCA.cnf",
                  manual_enroll, // manual enroll
                  0,  // disable PoP
                  nid); // ecdhe nid info
    SLEEP(1);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy acting as an RA.
     */
    rv = st_proxy_start(US748_TCP_PROXY_PORT,
                        US748_PROXY_CERT,
                        US748_PROXY_KEY,
                        "estrealm",
                        US748_CACERT,
                        US748_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US748_TCP_SERVER_PORT,
                        0,  // disable PoP
                        nid);  // ecdhe nid info
    SLEEP(1);

    return rv;
}

void us748_stop_server ()
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us748_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US748_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us748_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us748_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us748_destroy_suite (void)
{
    us748_stop_server();
    free(cacerts);
    return 0;
}

/*
 * Simple enroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * enrollment of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - EC prime 256
 *
 * This test case uses libcurl to test simple
 * enrollment of a 256 bit EC CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_ECDSA256,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - DSA prime 1024
 *
 * This test case uses libcurl to test simple
 * enrollment of a 1024 bit DSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_DSA1024,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - Corrupted PKCS10
 *
 * This test case uses libcurl to test simple
 * enrollment usinga corrupted CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test4 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_CORRUPT,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since the CSR is not valid, the server should
     * respond with a 400.
     */
    CU_ASSERT(rv == 400);
}

/*
 * Simple enroll - manual enrollment
 *
 * This test case verifies the server is
 * sending the appropriate retry-after response.
 */
static void us748_test5 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /* Stop the EST server */
    us748_stop_server();

    /* Restart the server with manual enrollment enabled */
    us748_start_server(1, 0);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, &write_func);
    fclose(outfile);

    /*
     * Since the server hasn't seen this CSR in the past,
     * it should respond with a retry-after 202 response.
     */
    CU_ASSERT(rv == 202);

    /*
     * Verify the retry-after value
     
     sprintf(cmd, "grep Retry-After %s | grep %d", test5_outfile,
     US748_RETRY_INTERVAL);
     rv = system(cmd);
     */
    rv = grep(test5_outfile, "Retry-After: 3600");
    CU_ASSERT(rv == 0);

    /*
     * We will avoid waiting the full retry period since we're
     * only simulating manual enrollment.  Wait a second and then
     * try to enroll the cert again.
     */
    SLEEP(1);
    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    /*
     * This enrollment request should succeed this time
     * Our simulated manual enrollment will automatically
     * enroll on the second attempt.
     */
    CU_ASSERT(rv == 200);

    /* Stop the EST server */
    us748_stop_server();

    /* Restart the server with manual enrollment disabled */
    us748_start_server(0, 0);
}

/*
 * Simple enroll - PoP check fails with curl
 *
 * This test case verifies the server is
 * verifying the PoP from the client CSR.  Since curl does not
 * set the PoP, the EST enrollment should fail.
 */
static void us748_test6 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_enable_pop();

    /*
     * Send a valid enroll request using curl.  Curl does not
     * include the PoP
     */
    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    /*
     * The server should respond with a failure code
     */
    CU_ASSERT(rv == 400);

    st_disable_pop();
}

/*
 * Simple enroll - PoP check succeeds with estclient
 *
 * This test case verifies the proxy is
 * verifying the PoP from the client CSR.  We use
 * estclient since it supports the PoP.
 */
static void us748_test7 (void)
{
    long rv;
    EST_CTX *c_ctx;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len;
    unsigned char *attr_data;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * This test case requires PoP to be enabled
     */
    st_enable_pop();

    /*
     * Create a client context
     */
    c_ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(c_ctx != NULL);
    if (!c_ctx) {
        return;
    }

    /*
     * Specify user ID and password since the server is running
     * in Basic Authentication mode.
     */
    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);
    est_client_set_server(c_ctx, "127.0.0.1", US748_TCP_PROXY_PORT, NULL);

    /*
     * get a keypair to be used in the enroll.
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(c_ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll a CSR
     */
    rv = est_client_enroll(c_ctx, "US748-test7 CN", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Client library has obtained the new client certificate.
     * Now retrieve it from the library.
     */
    pkcs7 = malloc(pkcs7_len);
    if (!pkcs7) {
        return;
    }
    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Clean up
     */
    est_destroy(c_ctx);
    EVP_PKEY_free(new_pkey);
    free(pkcs7);

    /*
     * Disable PoP for future test cases
     */
    st_disable_pop();
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 valid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes a valid PoP even when
 * the server didn't request it.  We have to use
 * CiscoEST as the client to generate a CSR containing
 * a valid PoP.  There's no way to include a valid PoP
 * using Curl since the TLS channel binding information
 * is not known in advance.
 */
//The following include should never be used by an application
//but we use it here to hack the EST_CTX values mid-way
//through this test
#include "../../src/est/est_locl.h"
static void us748_test9 (void)
{
    EST_CTX *ctx;
    int rv;
    unsigned char *cacerts;
    int caclen = 0;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len = 0;
    unsigned char *attr_data;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    /*
     * Read in the CA certs
     */
    caclen = read_binary_file(US748_CACERTS, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Init the client context
     */
    ctx = est_client_init(cacerts, caclen, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);

    /*
     * We'll use simple HTTP auth to identify ourselves
     */
    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_client_set_server(ctx, "127.0.0.1", US748_TCP_PROXY_PORT, NULL);

    /*
     * Create some space to hold the cert and generate
     * a private key
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll
     */
    ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
    //We need to force the challengePassword into the CSR    
    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    pkcs7 = malloc(pkcs7_len);
    rv = est_client_copy_enrolled_cert(ctx, pkcs7);

    free(pkcs7);
    est_destroy(ctx);
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 invalid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes an invalid PoP even when
 * the server didn't request it.
 */
static void us748_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_STALE_POP,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * The enroll request should fail since the PoP was invalid
     * We expect a 400 response.
     */
    CU_ASSERT(rv == 400);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us748_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us748_srv_simpenroll",
            us748_init_suite,
            us748_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "Enroll RSA cert", us748_test1)) ||
        (NULL == CU_add_test(pSuite, "Enroll ECDSA cert", us748_test2)) ||
        (NULL == CU_add_test(pSuite, "Enroll DSA cert", us748_test3)) ||
        (NULL == CU_add_test(pSuite, "Enroll corrupted ECDSA cert", us748_test4)) ||
        (NULL == CU_add_test(pSuite, "Enroll retry-after manual approval ", us748_test5)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP fail with Curl", us748_test6)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP succeed with estclient", us748_test7)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes valid PoP", us748_test9)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes invalid PoP", us748_test10)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us3512.c - Unit Tests URI path segment support in the Server
 *
 * April, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include "../../util/test_utils.h"
#include "st_server.h"
#include "st_proxy.h"

#include "../../src/est/est_locl.h"

extern char tst_srvr_path_seg_enroll[];
extern char tst_srvr_path_seg_cacerts[];
extern char tst_srvr_path_seg_csrattrs[];
extern char tst_srvr_path_seg_auth[];
extern char tst_proxy_path_seg_auth[];

static int path_segment_support;

/*
 * max command line length when generating system commands
 */
#define EST_UT_MAX_CMD_LEN 256

#define US3512_SERVER_PORT      29496
#define US3512_SERVER_IP        "127.0.0.1"
#define US3512_UIDPWD_GOOD      "estuser:estpwd"
#define US3512_UID              "estuser"
#define US3512_PWD              "estpwd"
#ifndef WIN32
#define US3512_CACERTS          "CA/estCA/cacert.crt"
#define US3512_TRUST_CERTS      "CA/trustedcerts.crt"
#define US3512_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US3512_PROXY_CERT       "CA/estCA/private/estservercertandkey.pem"
#define US3512_PROXY_KEY        "CA/estCA/private/estservercertandkey.pem"
#define US3512_CACERT           "CA/estCA/cacert.crt"
/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define CLIENT_UT_CACERT        "CA/estCA/cacert.crt"
#define CLIENT_UT_PUBKEY        "./est_client_ut_keypair"
#else
#define US3512_CACERTS          "CA\\estCA\\cacert.crt"
#define US3512_TRUST_CERTS      "CA/trustedcerts.crt"
#define US3512_SERVER_CERTKEY   "CA\\estCA/private/estservercertandkey.pem"
#define US3512_PROXY_CERT       "CA\\estCA\\private/estservercertandkey.pem"
#define US3512_PROXY_KEY        "CA\\estCA\\private\\estservercertandkey.pem"
#define US3512_CACERT           "CA\\estCA\\cacert.crt"
/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define CLIENT_UT_CACERT        "CA\\estCA\\cacert.crt"
#define CLIENT_UT_PUBKEY        "est_client_ut_keypair"
#endif

#define US3512_ENROLL_URL_BA "https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll"
#define US3512_ENROLL_URL_BA_BACKSLASH "https://127.0.0.1:29496/.well-known/est/cacerts-\\somestring/simpleenroll"
#define US3512_ENROLL_URL_BA_NOSEGMENT "https://127.0.0.1:29496/.well-known/est/simpleenroll"
#define US3512_PKCS10_CT        "Content-Type: application/pkcs10" 

#define US3512_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

#define US3512_TCP_PROXY_PORT       16894
#define PATH_SEG_VALID    "somestring"
#define PATH_SEG_TOO_MANY_SEGS    "somestring1/somestring2"
#define PATH_SEG_IS_OPERATION    "cacerts"
#define PATH_SEG_CONTAINS_OPERATION    "cacertssomestring"
#define PATH_SEG_MAX "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
#define PATH_SEG_TOO_LONG "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"

#define US3512_PROXY_ENROLL_URL_VALID "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_VALID"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_TOO_LONG "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_TOO_LONG"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_MAX "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_MAX"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_TOO_MANY "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_TOO_MANY_SEGS"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_IS_OPERATION "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_IS_OPERATION"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_CONTAINS_OPERATION"/simpleenroll"
#define US3512_PROXY_CACERTS_URL_VALID "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_VALID"/cacerts"

#define US3512_PKCS10_REQ    "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"

static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);

static void us3512_clean (void)
{
}

static int us3512_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start_nocacerts(US3512_SERVER_PORT,
                            US3512_SERVER_CERTKEY,
                            US3512_SERVER_CERTKEY,
                            "US3512 test realm",
                            US3512_CACERTS,
                            US3512_TRUST_CERTS,
                            "CA/estExampleCA.cnf",
                            manual_enroll,
                            0,
                            nid);

    SLEEP(1);

    /*
     * Next we start an EST proxy acting as an RA.
     */
    rv = st_proxy_start_nocacerts(US3512_TCP_PROXY_PORT,
                                  US3512_PROXY_CERT,
                                  US3512_PROXY_KEY,
                                  "estrealm",
                                  US3512_CACERT,
                                  US3512_TRUST_CERTS,
                                  "estuser",
                                  "estpwd",
                                  "127.0.0.1",
                                  US3512_SERVER_PORT,
                                  0,  // disable PoP
                                  0);  // ecdhe nid info
    SLEEP(1);

    return rv;
}

static int path_seg_supported (void)
{

    EST_CTX *ectx;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);

    rc = est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        "test_segment");
    if (rc == EST_ERR_NONE) {
        return 1;
    } else {
        return 0;
    }

    return 0;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.
 * 1. Generate the keypair to be used for this EST Client UT suite
 */
static int us3512_init_suite (void)
{
    int rv = 0;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    char cmd[EST_UT_MAX_CMD_LEN];
    printf("Starting EST Server path segment unit tests.\n");

    if (!path_segment_support) {
        printf(
            "URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \n");
        return 0;
    }

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
        "openssl ecparam -name prime256v1 -genkey -out %s",
        CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us3512_clean();
    /*
     * Start an instance of the EST server
     */
    rv = us3512_start_server(0, 0);
    SLEEP(2);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us3512_destroy_suite (void)
{

    st_stop();
    st_proxy_stop();
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__, openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Sanity check of the server side path segment processing.
 * - simple enroll
 * - direct to server
 * - with path segment
 * Outcome: pass
 */
static void us3512_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US3512_ENROLL_URL_BA_NOSEGMENT, US3512_PKCS10_CT,
    US3512_PKCS10_RSA2048,
    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * This function performs a basic simple enroll using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variety of test cases in this module.
 */
static void us3512_simple_enroll (char *cn, char *server,
                                  EST_ERROR expected_enroll_rv,
                                  char *path_segment)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US3512_SERVER_PORT, path_segment);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * taken from US899/test1
 * Simple enroll -  including a path segment in the uri.
 *
 * Path Segment testing
 * - This verifies the client includes a configured
 *   path segment properly and sends it.
 * - This verifies that the server correctly parses out
 *   a valid path segment and passes it up on a simple enroll.
 *
 */
static void us3512_test2 (void)
{
    LOG_FUNC_NM
    ;
    char *path_segment = "path_segment";

    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    us3512_simple_enroll("TC3512-2", US3512_SERVER_IP, EST_ERR_NONE,
        path_segment);

    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);
}

/*
 * taken from US898/test1
 * Simple re-enroll -  including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on a simple re-enroll
 *   as well as the auth callback.
 */
static void us3512_test3 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) * certs = NULL;
    int i;
    unsigned char *attr_data = NULL;
    int attr_len;
    char *path_segment = "path_seg_us3512_test3";
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        path_segment);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);
    if (rv != EST_ERR_NONE)
        return;

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out, NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i = OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
        certs = p7->d.sign->cert;
        break;
    case NID_pkcs7_signedAndEnveloped:
        certs = p7->d.signed_and_enveloped->cert;
        break;
    default:
        break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs)
        return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);

    /*
     * Wow, that's a lot of work, but we finally have the X509.
     * (don't you just love OpenSSL!!!)
     * Now that we have an X509 representation of the cert,
     * let's try to re-enroll this cert with the CA
     */
    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);

    /*
     * Cleanup
     */
    if (cert)
        X509_free(cert);
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * taken from US897/test11
 * CAcerts to the server - including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on the CA certs callback.
 */
static void us3512_test4 (void)
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY * priv_key;

    char *path_segment = "path_seg_us3512_test4";

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        path_segment);

    /*
     * clear out the global that proves that the path segment
     * made it to the application layer's cal back function
     */
    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);
    /*
     * verify that the path segment made it all the way to the callback function
     * at the application layer
     */
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/*
 * taken from US898/test1
 * CSRAttributes -  including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on a csr attributes callback
 */
static void us3512_test5 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    unsigned char *new_cert = NULL;
    X509 *cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;
    char *path_segment = "path_seg_us3512_test5";
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        path_segment);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * clear out the global that proves that the path segment
     * made it to the application layer's cal back function
     */
    memset(tst_srvr_path_seg_csrattrs, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    /*
     * issue the get ca certs request
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rv == EST_ERR_NONE);
    /*
     * verify that the path segment made it all the way to the callback function
     * at the application layer
     */
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_csrattrs) == 0);

    /*
     * Cleanup
     */
    if (cert)
        X509_free(cert);
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * Test the flow of path segments through proxy mode - valid path segment
 * SimpleEnroll
 */
static void us3512_test6 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);

    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    rv = curl_http_post(US3512_PROXY_ENROLL_URL_VALID, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD,
    US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    CU_ASSERT(strcmp(PATH_SEG_VALID, tst_srvr_path_seg_enroll) == 0);

    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Test the flow of path segments through proxy mode -
 *  path segment is set to the maximum size
 *
 */
static void us3512_test7 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_MAX, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that is too long, it
     * should get caught at the proxy and a 400 should be returned
     */
    CU_ASSERT(rv == 200);
}

/*
 * Test the flow of path segments through proxy mode -
 *  path segment that is too large
 *
 */
static void us3512_test8 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_LONG, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that is too long, it
     * should get caught at the proxy and a 400 should be returned
     */
    CU_ASSERT(rv == 400);
}

/*
 * Test segment that is an operation path
 *
 */
static void us3512_test9 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_IS_OPERATION, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that equals an operation we
     * should get a 400 in return
     */
    CU_ASSERT(rv == 400);
}

/*
 * Test segment that is an operation path
 *
 */
static void us3512_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_MANY, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that equals an operation we
     * should get a 400 in return
     */
    CU_ASSERT(rv == 400);
}

/*
 * Test segment that contains a valid operation string within it,
 * in this case, at the front.  This is a valid path segment, so
 * the test should pass.
 *
 */
static void us3512_test11 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);

    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
    memset(tst_proxy_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    rv = curl_http_post(US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION,
    US3512_PKCS10_CT, US3512_PKCS10_REQ,
    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    CU_ASSERT(
        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_srvr_path_seg_enroll) == 0);
    CU_ASSERT(
        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_proxy_path_seg_auth) == 0);

    /*
     * Since we passed in a path segment that equals an operation we
     * should get a 400 in return
     */
    CU_ASSERT(rv == 200);
}

/*
 * taken from US897/test11
 * CAcerts to the server - including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on the CA certs callback.
 */
static void us3512_test12 (void)
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY * priv_key;

    char *path_segment = "path_seg_us3512_test4";

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US3512_SERVER_IP, US3512_TCP_PROXY_PORT,
        path_segment);

    /*
     * clear out the global that proves that the path segment
     * made it to the application layer's cal back function
     */
    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);
    /*
     * verify that the path segment made it all the way to the callback function
     * at the application layer
     */
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us3512_add_suite (void)
{
    CU_ErrorCode CU_error;

#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us3512_server_path_seg",
            us3512_init_suite,
            us3512_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /*
     * check to see if path segment support has been compiled in
     */
    if (!path_seg_supported()) {
        printf("URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \n");
        path_segment_support = 0;
        return 0;
    }
    path_segment_support = 1;

    if (path_segment_support) {

        /* add the tests to the suite */
        /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
        if (
            (NULL == CU_add_test(pSuite, "EST Client: Simple enroll with no path segment", us3512_test1)) ||
            (NULL == CU_add_test(pSuite, "EST Server: Simple Enroll with path segment", us3512_test2)) ||
            (NULL == CU_add_test(pSuite, "EST Server: Simple Re-enroll with path segment", us3512_test3)) ||
            (NULL == CU_add_test(pSuite, "EST Server: CACerts with path segment", us3512_test4)) ||
            (NULL == CU_add_test(pSuite, "EST Server: CSRAttrs with path segment", us3512_test5)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment", us3512_test6)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment at the max", us3512_test7)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment too long", us3512_test8)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment that is operation", us3512_test9)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment containing too many segments", us3512_test10)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment containing an operation", us3512_test11)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment valid and cacerts", us3512_test12))
            )
            {
                CU_error = CU_get_error();
                printf("%d\n", CU_error);

                CU_cleanup_registry();
                printf("%s\n", CU_get_error_msg());
                return CU_get_error();
            }
        }
        return CUE_SUCCESS;
     #endif
}


/*------------------------------------------------------------------
 * us3612.c - Unit Tests for User Story US3612 - Encrypted Private Key Support
 *
 *
 *
 * July, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
*/

#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static char *key_password = NULL;
static int cacerts_len = 0;

#define US3612_SERVER_PORT   29899
#define US3612_SERVER_IP     "127.0.0.1"
#define US3612_UID           "estuser"
#define US3612_PWD           "estpwd"
#define US3612_GOOD_PWD "us3612"
#define US3612_BAD_PWD  "thiscantpossiblywork"
#define RSA_KEYSIZE 4096

/*
 * Key wrap algorithm optionally used to protect private keys
 */
#define EST_PRIVATE_KEY_ENC EVP_aes_128_cbc()

/*
 * The following certs are used for FQDN testing
 */
#ifndef WIN32
#define US3612_CACERTS       "CA/estCA/cacert.crt"
#define US3612_TRUST_CERTS   "CA/trustedcerts.crt"
#define US3612_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US3612_PRIVATE_KEY_FILE "US3612/us3612_key.pem"

#else
#define US3612_CACERTS       "CA\\estCA\\cacert.crt"
#define US3612_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US3612_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"
#define US3612_PRIVATE_KEY_FILE "US3612\\us3612_key.pem"

static CRITICAL_SECTION logger_critical_section;
static void us3612_logger_stderr (char *format, va_list l)
{
    EnterCriticalSection(&logger_critical_section);
    vfprintf(stderr, format, l);
    fflush(stderr);
    LeaveCriticalSection(&logger_critical_section);
}
#endif

unsigned char *BIO_copy_data(BIO *out, int *data_lenp) {
    unsigned char *data, *tdata;
    int data_len;

    data_len = BIO_get_mem_data(out, &tdata);
    data = malloc(data_len+1);
    if (data) {
        memcpy(data, tdata, data_len);
	data[data_len]='\0';  // Make sure it's \0 terminated, in case used as string
	if (data_lenp) {
	    *data_lenp = data_len;
	}
    } else {
        printf("malloc failed");
    }
    return data;
}

char *generate_private_RSA_key (int key_size, pem_password_cb *cb)
{
    char *key_data = NULL;

    RSA *rsa = RSA_new();
    if (!rsa) {
        return NULL;
    }
    BIGNUM *bn = BN_new();
    if (!bn) {
        RSA_free(rsa);
        return NULL;
    }

    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, key_size, bn, NULL);

    do {
        BIO *out = BIO_new(BIO_s_mem());
        if (!out) {
            break;
        }
        PEM_write_bio_RSAPrivateKey(out, rsa, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);
        key_data = (char *)BIO_copy_data(out, NULL);
        BIO_free(out);
        if (key_data && !key_data[0]) {
            // happens if passphrase entered via STDIN does not verify or has less than 4 characters
            free(key_data);
            key_data = NULL;
        }
    } while (cb && !key_data);

    RSA_free(rsa);
    BN_free(bn);
    return (key_data);
}

char *generate_private_EC_key (int curve_nid, pem_password_cb *cb)
{
    EC_KEY *eckey;
    EC_GROUP *group = NULL;
    char *key_data = NULL;
    int asn1_flag = OPENSSL_EC_NAMED_CURVE;
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    /*
     * Generate an EC key
     */

    eckey = EC_KEY_new();
    if (!eckey) {
        return NULL;
    }

    group = EC_GROUP_new_by_curve_name(curve_nid);
    EC_GROUP_set_asn1_flag(group, asn1_flag);
    EC_GROUP_set_point_conversion_form(group, form);
    EC_KEY_set_group(eckey, group);
    if (!EC_KEY_generate_key(eckey)) {
        return (NULL);
    }

    do {
        BIO *out = BIO_new(BIO_s_mem());
        if (!out) {
            break;
        }
        PEM_write_bio_ECPKParameters(out, group);
        PEM_write_bio_ECPrivateKey(out, eckey, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);
        key_data = (char *)BIO_copy_data(out, NULL);
        BIO_free(out);
        if (key_data && !strstr(key_data, "-----BEGIN EC PRIVATE KEY-----")) {
            // happens if passphrase entered via STDIN does not verify or has less than 4 characters
            free(key_data);
            key_data = NULL;
        }
    } while (cb && !key_data);

    EC_KEY_free(eckey);
    return (key_data);
}

static int string_password_cb (char *buf, int size, int wflag, void *data)
{
    /*
     * Hard code a password for this suite
     */
    strncpy(buf, key_password, size);
    return(strnlen(buf, size));
}


static void us3612_clean (void)
{
}

static int us3612_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US3612_SERVER_PORT,
              US3612_SERVER_CERTKEY,
              US3612_SERVER_CERTKEY,
              "US3612 test realm",
              US3612_CACERTS,
              US3612_TRUST_CERTS,
              "CA/estExampleCA.cnf",
          manual_enroll,
          0,
          nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us3612_init_suite (void)
{
    int rv;

#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us3612_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US3612_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
    return 1;
    }

    us3612_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us3612_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us3612_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Simple Enroll b- client
 * Load in a password prortected private key with
 * the correct passphrase and attempt to enroll for a certificate
 */
static void us3612_test1 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len,
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);

    /*
     * Read in our test private key
     * generated via the command below:
     *
     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096
     */

    key_password = US3612_GOOD_PWD;

    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);

    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TCUS3612-1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
    new_cert = malloc(pkcs7_len);
    CU_ASSERT(new_cert != NULL);
    rv = est_client_copy_enrolled_cert(ectx, new_cert);
    CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Simple enroll CSR
 *
 * Load in a password protected private key with the incorrect password
 * and attempt to enroll for a certificate. This will fail.
 */
static void us3612_test2 (void)
{
     EST_CTX *ectx;
     EVP_PKEY *key;
     int rv;
     int pkcs7_len = 0;
     unsigned char *new_cert = NULL;
     unsigned char *attr_data = NULL;
     int attr_len;

     /*
      * Create a client context
      */
     ectx = est_client_init(cacerts, cacerts_len,
                            EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);

     /*
      * Set the authentication mode to use a user id/password
      */
     rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
     CU_ASSERT(rv == EST_ERR_NONE);

     /*
      * Set the EST server address/port
      */
     est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);

     /*
      * Read in our test private key
      * generated via the command below:
      *
      * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096
      */

     key_password = US3612_BAD_PWD;

     key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);

     CU_ASSERT(key == NULL);

     /*
      * Get the latest CSR attributes
      */
     rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
     CU_ASSERT(rv == EST_ERR_NONE);

     /*
      * Use the simplified API to enroll a CSR
      */
     rv = est_client_enroll(ectx, "TC3612-2", &pkcs7_len, key);
     CU_ASSERT(rv != EST_ERR_NONE);

     /*
      * Cleanup
      */
     EVP_PKEY_free(key);
     if (new_cert) free(new_cert);
     est_destroy(ectx);
}


/*
 * Simple enroll CSR
 *
 * Change the password used by the callback after reading
 * in the protected private key file.
 */
static void us3612_test3 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len,
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);

    /*
     * Read in our test private key
     * generated via the command below:
     *
     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096
     */

    key_password = US3612_GOOD_PWD;

    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);

    CU_ASSERT(key != NULL);

    /*
     * Change out the password, EVP_PKEY should remain unaffected
     */

    key_password = US3612_BAD_PWD;

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TCUS3612-3", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
    new_cert = malloc(pkcs7_len);
    CU_ASSERT(new_cert != NULL);
    rv = est_client_copy_enrolled_cert(ectx, new_cert);
    CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Test key generation utility functions
 * and associated password callbacks
 */
static void us3612_test4 (void)
{
    char * new_pkey = NULL;

    /*
     * Generate an RSA key without a password
     */

    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, NULL);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;

    /*
     * Generate an RSA key with password
     */

    key_password = US3612_GOOD_PWD;

    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, string_password_cb);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;

    /*
     * Generate an EC key without a password
     */

    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) "prime256v1"), NULL);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;


    /*
     * Generate an EC key with a password
     */
    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) "prime256v1"), string_password_cb);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;

}

int us3612_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us3612_encrypted_private_keys",
                      us3612_init_suite,
              us3612_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /*
    * Add the tests to the suite
    */
   if ((NULL == CU_add_test(pSuite, "Client simple enroll w/ correct pwd", us3612_test1)) ||
       (NULL == CU_add_test(pSuite, "Client simple enroll w/ incorrect pwd", us3612_test2)) ||
       (NULL == CU_add_test(pSuite, "Client simple enroll w/ incorrect pwd", us3612_test3)) ||
       (NULL == CU_add_test(pSuite, "Keygen Test", us3612_test4)))
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}

/*------------------------------------------------------------------
 * us1159.c - Unit Tests for User Story 1159 - CSR Attributes enforce
 *
 * October, 2014
 *
 * Copyright (c) 2014, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include "test_utils.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>
#include "st_server.h"

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifndef WIN32
#define US1159_CACERTS          "CA/estCA/cacert.crt"
#define US1159_CACERT           "CA/estCA/cacert.crt"
#define US1159_SERVER_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US1159_SERVER_KEY       "CA/estCA/private/estservercertandkey.pem"
#else
#define US1159_CACERTS          "CA\\estCA\\cacert.crt"
#define US1159_CACERT           "CA\\estCA\\cacert.crt"
#define US1159_SERVER_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US1159_SERVER_KEY       "CA\\estCA\\private\\estservercertandkey.pem"
#endif
#define US1159_UID              "estuser"
#define US1159_PWD              "estpwd"

#define US1159_SERVER_PORT      15897
#define US1159_SERVER_IP        "127.0.0.1"

#define US1159_ATTR_POP_ONLY    "MAsGCSqGSIb3DQEJBw==\0"
#define US1159_ATTR_CN_ONLY     "MAUGA1UEAw==\0"
#define US1159_ATTR_TEST        "MHEGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBgUrgQQAIgYDVQQDBggqhkjOPQQDAg==\0"

extern EST_CTX *ectx;
static unsigned char *cacerts = NULL;
static int cacerts_len = 0;
static char *attrs;

static unsigned char * handle_csrattrs_request (int *csr_len, char *path_seg,
                                                void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(attrs);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, attrs, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static void us1159_clean (void)
{
}

int us1159_start_server ()
{
    int rv = 0;

    /*
     * Start an EST server acting as the CA
     */
    rv = st_start(US1159_SERVER_PORT,
                  US1159_SERVER_CERT,
                  US1159_SERVER_KEY,
                  "estrealm",
                  US1159_CACERT,
                  "CA/trustedcerts.crt",
                  "CA/estExampleCA.cnf",
                  0, // manual enroll
                  0,  // disable PoP
                  0); // ecdhe nid info
    if (rv != EST_ERR_NONE) {
        printf("\nUnable to start EST server for US1159.\n");
        return rv;
    }

    st_enable_csrattr_enforce();

    rv = est_set_csr_cb(ectx, &handle_csrattrs_request);
    if (rv != EST_ERR_NONE) {
        printf("\nUnable to set EST CSR Attributes callback for US1159.\n");
        return (rv);
    }

    SLEEP(1);

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1159_init_suite (void)
{
    int rv;

    us1159_clean();

    printf(
        "\nStarting server for CSR attributes enforcement unit tests (US1159).\n");

    attrs = US1159_ATTR_POP_ONLY;
    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1159_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1159_start_server();

    return rv;
}

void us1159_stop_server ()
{
    st_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1159_destroy_suite (void)
{
    us1159_stop_server();
    free(cacerts);
    printf("Completed CSR attributes enforcement unit tests.\n");
    return 0;
}

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * This function generates an EC public/private key
 * pair that will be used with the certificate
 * we provision.
 */
static EVP_PKEY * generate_ec_private_key (int nid)
{
    EC_KEY *eckey;
    EC_GROUP *group = NULL;
    BIO *out;
    unsigned char *tdata;
    unsigned char *key_data;
    int key_len;
    BIO *keyin;
    EVP_PKEY *new_priv_key;
    int asn1_flag = OPENSSL_EC_NAMED_CURVE;
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    /*
     * Generate an EC key
     */
    group = EC_GROUP_new_by_curve_name(nid /*NID_X9_62_prime256v1*/);
    EC_GROUP_set_asn1_flag(group, asn1_flag);
    EC_GROUP_set_point_conversion_form(group, form);
    eckey = EC_KEY_new();
    EC_KEY_set_group(eckey, group);
    if (!EC_KEY_generate_key(eckey)) {
        printf("Failed to generate EC key\n");
        return NULL;
    }
    out = BIO_new(BIO_s_mem());
    PEM_write_bio_ECPKParameters(out, group);
    PEM_write_bio_ECPrivateKey(out, eckey, NULL, NULL, 0, NULL, NULL);
    key_len = BIO_get_mem_data(out, &tdata);
    key_data = malloc(key_len + 1);
    memcpy(key_data, tdata, key_len);
    EC_KEY_free(eckey);
    BIO_free(out);

    /*
     * read it back in to an EVP_PKEY struct
     */
    keyin = BIO_new(BIO_s_mem());
    keyin = BIO_new_mem_buf(key_data, key_len);

    /*
     * This reads in the private key file, which is expected to be a PEM
     * encoded private key.  If using DER encoding, you would invoke
     * d2i_PrivateKey_bio() instead.
     */
    new_priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    if (new_priv_key == NULL) {
        printf("\nError while reading PEM encoded private key\n");
        ERR_print_errors_fp(stderr);
        return NULL;
    }
    BIO_free(keyin);
    free(key_data);

    return (new_priv_key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing no CSR attributes other than
 * challengePassword. The enroll should succeed.
 */
static void us1159_test1 (void)
{
    EST_CTX *ctx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;

    LOG_FUNC_NM
    ;

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ctx, "Test 1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ctx);
}

/*
 * This routine builds a PKCS10 CSR.
 */
static EST_ERROR populate_x509_request (X509_REQ *req, EVP_PKEY *pkey, char *cn)
{
    X509_NAME *subj;
    int rv;

    /* setup version number */
    rv = X509_REQ_set_version(req, 0L);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_VER);
    }

    /*
     * Add Common Name entry
     */
    subj = X509_REQ_get_subject_name(req);
    rv = X509_NAME_add_entry_by_txt(subj, "CN", MBSTRING_ASC,
        (const unsigned char*) cn, -1, -1, 0);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_CN);
    }

    /*
     * Add serial number Name entry
     */
    rv = X509_NAME_add_entry_by_NID(subj, NID_serialNumber, MBSTRING_ASC,
        (unsigned char*) "12349999B", -1, -1, 0);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_CN);
    }

    /*
     * Add all the other attributes that the server will be expecting
     */
    rv = X509_REQ_add1_attr_by_txt(req, "1.3.6.1.1.1.1.22", MBSTRING_ASC,
        (const unsigned char*) "dummymac", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.1", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.2", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.3", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.4", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "1.2.840.10045.2.1", MBSTRING_ASC,
        (const unsigned char*) "1.3.132.0.34", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "1.2.840.10045.4.3.3", MBSTRING_ASC,
        (const unsigned char*) "", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_NID(req, NID_serialNumber, MBSTRING_ASC,
        (const unsigned char*) "123456789A", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    /*
     * Set the public key on the request
     */
    rv = X509_REQ_set_pubkey(req, pkey);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_PUBKEY);
    }

    X509_REQ_print_fp(stderr, req);

    return (EST_ERR_NONE);
}

#if 0
/*
 * Sign an X509 certificate request using the digest and the key passed.
 * Returns OpenSSL error code from X509_REQ_sign_ctx();
 */
static int sign_X509_REQ(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
    int rv;
    EVP_PKEY_CTX *pkctx = NULL;
    EVP_MD_CTX mctx;

    EVP_MD_CTX_init(&mctx);

    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {
        return 0;
    }

    /*
     * Encode using DER (ASN.1)
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     */
    x->req_info->enc.modified = 1;
    rv = X509_REQ_sign_ctx(x, &mctx);

    EVP_MD_CTX_cleanup(&mctx);

    return (rv);
}
#endif

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR. The enroll should succeed.
 */
static void us1159_test2 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 2");
    CU_ASSERT(rv == EST_ERR_NONE);

#if 0
    /*
     * Sign the request
     */
    ossl_rv = sign_X509_REQ(req, key, EVP_sha256());
    CU_ASSERT(ossl_rv == 0);
    if (!ossl_rv) {
        ERR_print_errors_fp(stderr);
    }
#endif

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    if (new_cert)
        free(new_cert);
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR except that the 521-bit curve is used. The enroll
 * should fail since the server CSR attrs specify to
 * use the 384-bit curve.
 */
static void us1159_test3 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp521r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 3");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR except that SHA-384 is used for the
 * signature. The enroll should fail since the server
 * CSR attrs require SHA-256.
 */
static void us1159_test4 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 3");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Change to SHA-384 for the signature
     */
    rv = est_client_set_sign_digest(ctx, NID_sha384);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll when the
 * server has no CSR attributes configured to only
 * require the CommonName.  The CSR attributes on
 * the server are configured through the static API,
 * not the callback.
 */
static void us1159_test10 (void)
{
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * Disable the CSR attr callback on the server context
     */
    rv = est_set_csr_cb(ectx, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Configure the static CSR attributes value
     */
    rv = est_server_init_csrattrs(ectx, US1159_ATTR_CN_ONLY,
        strlen(US1159_ATTR_CN_ONLY));
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Enroll a new cert
     */
    rv = est_client_enroll(ctx, "Test 10", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR. The client also provides a large
 * quantity of additional attriutes.
 */
static void us1159_test20 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    int rv;
    EST_CTX *ctx = NULL;
    int i;
    char t_attr_str[50];

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 20");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Jam another 25 attributes into the request
     * We could do more, but this causes a failure on the EST server when
     * base64 decoding the CSR due to a safeC constraint.  The max string
     * size in safeC defaults to 4096 bytes.
     */
    for (i = 0; i < 25; i++) {
        sprintf(t_attr_str, "2.899.%d", i);
        rv = X509_REQ_add1_attr_by_txt(req, t_attr_str, MBSTRING_ASC,
            (const unsigned char*) "whatever", -1);
        CU_ASSERT(rv != 0);
        if (!rv) {
            ERR_print_errors_fp(stderr);
        }
    }

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    if (new_cert)
        free(new_cert);
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR. The client also provides an attribute with
 * a very long name and value.
 */
static void us1159_test21 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 21");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Add an attribute with a long value
     */
    rv =
            X509_REQ_add1_attr_by_txt(req, "2.993.8", MBSTRING_ASC,
                (const unsigned char*) "This is an attribute with a very long value that could potentially cause a problem on the EST server.  0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789",
                -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
    }

    /*
     * Add an attribute with a long name
     */
    rv =
            X509_REQ_add1_attr_by_txt(req,
                "2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.7",
                MBSTRING_ASC, (const unsigned char*) "0123456789", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
    }
    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    if (new_cert)
        free(new_cert);
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll when the
 * server has no CSR attributes configured with
 * PoP enabled.
 */
static void us1159_test50 (void)
{
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    st_enable_pop();

    /*
     * Disable the CSR attr callback on the server context
     */
    rv = est_set_csr_cb(ectx, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Enroll a new cert
     */
    rv = est_client_enroll(ctx, "Test 50", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll when the
 * server has no CSR attributes configured with
 * PoP disabled.
 */
static void us1159_test51 (void)
{
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    st_disable_pop();

    /*
     * Disable the CSR attr callback on the server context
     */
    rv = est_set_csr_cb(ectx, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Enroll a new cert
     */
    rv = est_client_enroll(ctx, "Test 51", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (key)
        EVP_PKEY_free(key);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us1159_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1159_csr_attr_enforce",
            us1159_init_suite,
            us1159_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
    if ((NULL == CU_add_test(pSuite, "No attributes required w/pop", us1159_test1)) ||
        (NULL == CU_add_test(pSuite, "All attributes provided w/pop", us1159_test2)) ||
        (NULL == CU_add_test(pSuite, "EC public key wrong curve w/pop", us1159_test3)) ||
        (NULL == CU_add_test(pSuite, "Wrong hash algorithm in signature w/pop", us1159_test4)) ||
        (NULL == CU_add_test(pSuite, "CN only using static config w/pop", us1159_test10)) ||
        (NULL == CU_add_test(pSuite, "A lot of attributes w/pop", us1159_test20)) ||
        (NULL == CU_add_test(pSuite, "Long attribute w/pop", us1159_test21)) ||
        (NULL == CU_add_test(pSuite, "No CSR attrs on server w/pop", us1159_test50)) ||
        (NULL == CU_add_test(pSuite, "No CSR attrs on server w/o pop", us1159_test51)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us903.c - Unit Tests for User Story 903 - Server simple enroll
 *
 * August, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifndef WIN32
static char test5_outfile[FILENAME_MAX] = "US903/test5.hdr";
#define US903_CACERTS       "CA/estCA/cacert.crt"
#define US903_EXPLICIT_CERT "US903/cert-RA.pem" 
#define US903_EXPLICIT_KEY  "US903/key-RA.pem"
#define US903_CACERTS       "CA/estCA/cacert.crt"
#define US903_TRUSTED_CERT  "CA/trustedcerts.crt"
#define US903_SERVER_CERT_AND_KEY "CA/estCA/private/estservercertandkey.pem"
#else
static char test5_outfile[FILENAME_MAX] = "US903\\test5.hdr";
#define US903_CACERTS       "CA\\estCA\\cacert.crt"
#define US903_EXPLICIT_CERT "US903\\cert-RA.pem" 
#define US903_EXPLICIT_KEY  "US903\\key-RA.pem"
#define US903_CACERTS       "CA\\estCA\\cacert.crt"
#define US903_TRUSTED_CERT  "CA\\trustedcerts.crt"
#define US903_SERVER_CERT_AND_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US903_RETRY_INTERVAL    3600
#define US903_TCP_PORT      29001

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US903_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the ec.req file:
 *
 * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM
 */
#define US903_PKCS10_DSA1024 "MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\nzn9HujlXNaTA1OhjmPmcJSxT"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the dsa.req file:
 *
 * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM
 */
#define US903_PKCS10_ECDSA256 "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

#define US903_PKCS10_CORRUPT "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

/*
 * The following is a valid CSR that already contains a PoP
 * challengePassword.  This was collected using estserver with
 * the dumpbin() function.  This CSR should never work since
 * the PoP value in it will be stale.
 */
#define US903_PKCS10_STALE_POP "MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40="

#define US903_ENROLL_URL_BA "https://127.0.0.1:29001/.well-known/est/simpleenroll"
#define US903_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US903_UIDPWD_GOOD   "estuser:estpwd"

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__,
        openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

static FILE *outfile;
static size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

static void us903_clean (void)
{
}

static int us903_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US903_TCP_PORT,
                  US903_SERVER_CERT_AND_KEY,
                  US903_SERVER_CERT_AND_KEY,
                  "US903 test realm",
                  US903_CACERTS,
                  US903_TRUSTED_CERT,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us903_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US903_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us903_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us903_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us903_destory_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}

/*
 * Simple enroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * enrollment of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
    US903_PKCS10_RSA2048,
    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - EC prime 256
 *
 * This test case uses libcurl to test simple
 * enrollment of a 256 bit EC CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_ECDSA256,US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - DSA prime 1024
 *
 * This test case uses libcurl to test simple
 * enrollment of a 1024 bit DSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_DSA1024, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - Corrupted PKCS10
 *
 * This test case uses libcurl to test simple
 * enrollment usinga corrupted CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test4 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_CORRUPT, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since the CSR is not valid, the server should
     * respond with a 400.
     */
    CU_ASSERT(rv == 400);
}

/*
 * Simple enroll - manual enrollment
 *
 * This test case verifies the server is
 * sending the appropriate retry-after response.
 */
static void us903_test5 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /* Stop the EST server */
    st_stop();

    /* Restart the server with manual enrollment enabled */
    us903_start_server(1, 0);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, &write_func);
    fclose(outfile);

    /*
     * Since the server hasn't seen this CSR in the past,
     * it should respond with a retry-after 202 response.
     */
    CU_ASSERT(rv == 202);

    /*
     * Verify the retry-after value
     */
    rv = grep(test5_outfile, "Retry-After: 3600");
    CU_ASSERT(rv == 0);

    /*
     * We will avoid waiting the full retry period since we're
     * only simulating manual enrollment.  Wait a second and then
     * try to enroll the cert again.
     */
    SLEEP(1);
    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);

    /*
     * This enrollment request should succeed this time
     * Our simulated manual enrollment will automatically
     * enroll on the second attempt.
     */
    CU_ASSERT(rv == 200);

    /* Stop the EST server */
    st_stop();

    /* Restart the server with manual enrollment disabled */
    us903_start_server(0, 0);
}

/*
 * Simple enroll - PoP check fails with curl
 *
 * This test case verifies the server is
 * verifying the PoP from the client CSR.  Since curl does not
 * set the PoP, the EST enrollment should fail.
 */
static void us903_test6 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_enable_pop();

    /*
     * Send a valid enroll request using curl.  Curl does not
     * include the PoP
     */
    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);

    /*
     * The server should respond with a failure code
     */
    CU_ASSERT(rv == 400);

    st_disable_pop();
}

/*
 * Simple enroll - PoP check succeeds with estclient
 *
 * This test case verifies the server is
 * verifying the PoP from the client CSR.  We use
 * estclient since it supports the PoP.
 */
static void us903_test7 (void)
{
    long rv;
    EST_CTX *c_ctx;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len;
    unsigned char *attr_data;
    int attr_len;
    int http_status;

    LOG_FUNC_NM
    ;

    /*
     * This test case requires PoP to be enabled
     */
    st_enable_pop();

    /*
     * Create a client context
     */
    c_ctx = est_client_init(
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(c_ctx != NULL);
    if (!c_ctx) {
        return;
    }

    /*
     * Specify user ID and password since the server is running
     * in Basic Authentication mode.
     */
    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);
    est_client_set_server(c_ctx, "127.0.0.1", US903_TCP_PORT, NULL);

    /*
     * get a keypair to be used in the enroll.
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(c_ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll a CSR
     */
    rv = est_client_enroll(c_ctx, "US903-test7 CN", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Check HTTP status code received from server is 200
     */
    http_status = est_client_get_last_http_status(c_ctx);
    CU_ASSERT(http_status == 200);

    /*
     * Client library has obtained the new client certificate.
     * Now retrieve it from the library.
     */
    pkcs7 = malloc(pkcs7_len);
    if (!pkcs7) {
        return;
    }
    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Clean up
     */
    est_destroy(c_ctx);
    EVP_PKEY_free(new_pkey);
    free(pkcs7);

    /*
     * Disable PoP for future test cases
     */
    st_disable_pop();
}

/*
 * Simple enroll - Use a non-default ECDHE curve
 *
 * This test case verifies the est_server_set_ecdhe_curve()
 * function is working.
 */
static void us903_test8 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /* Stop the EST server */
    st_stop();

    /* Restart the server using the secp384r1 curve  */
    us903_start_server(0, NID_secp384r1);

    rv = curl_http_post(
        US903_ENROLL_URL_BA,
        US903_PKCS10_CT,
        US903_PKCS10_RSA2048,
        US903_UIDPWD_GOOD,
        US903_CACERTS,
        CURLAUTH_BASIC,
        "ECDHE-ECDSA-AES256-GCM-SHA384",
        NULL,
        NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 valid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes a valid PoP even when
 * the server didn't request it.  We have to use
 * CiscoEST as the client to generate a CSR containing
 * a valid PoP.  There's no way to include a valid PoP
 * using Curl since the TLS channel binding information
 * is not known in advance.
 */
//The following include should never be used by an application
//be we use it here to hack the EST_CTX values mid-way
//through this test
#include "../../src/est/est_locl.h"
static void us903_test9 (void)
{
    EST_CTX *ctx;
    int rv;
    unsigned char *cacerts;
    int caclen = 0;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len = 0;
    unsigned char *attr_data;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    /*
     * Read in the CA certs
     */
    caclen = read_binary_file(US903_CACERTS, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Init the client context
     */
    ctx = est_client_init(
        cacerts,
        caclen,
        EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);

    /*
     * We'll use simple HTTP auth to identify ourselves
     */
    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_client_set_server(ctx, "127.0.0.1", US903_TCP_PORT, NULL);

    /*
     * Create some space to hold the cert and generate
     * a private key
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll
     */
    ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
    //We need to force the challengePassword into the CSR    
    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    pkcs7 = malloc(pkcs7_len);
    rv = est_client_copy_enrolled_cert(ctx, pkcs7);

    free(pkcs7);
    est_destroy(ctx);
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 invalid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes an invalid PoP even when
 * the server didn't request it.
 */
static void us903_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
    US903_PKCS10_STALE_POP,
    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * The enroll request should fail since the PoP was invalid
     * We expect a 400 response.
     */
    CU_ASSERT(rv == 400);
}

/*
 * Simple enroll - PoP is enabled, the CSR contains a
 *                 invalid PoP, and the client uses
 *                 a cert that contains id-kp-cmcRA.
 *
 * This test case ensures the server disables the PoP
 * check when the client is using a cert that contains
 * id-kp-cmcRA, which indicates the client is an RA.
 */
static void us903_test11 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_enable_pop();

    rv = curl_http_post_certuid(
    US903_ENROLL_URL_BA,
    US903_PKCS10_CT,
    US903_PKCS10_STALE_POP,
    US903_UIDPWD_GOOD,
    US903_EXPLICIT_CERT,
    US903_EXPLICIT_KEY,
    US903_CACERTS, NULL);

    /*
     * Even though the PoP value doesn't match in this CSR,
     * the enroll will succeed since the client is using
     * an RA certificate. We expect a 200 response.
     */
    CU_ASSERT(rv == 200);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us903_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us903_srv_simpenroll",
            us903_init_suite,
            us903_destory_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "Enroll RSA cert", us903_test1)) ||
        (NULL == CU_add_test(pSuite, "Enroll ECDSA cert", us903_test2)) ||
        (NULL == CU_add_test(pSuite, "Enroll DSA cert", us903_test3)) ||
        (NULL == CU_add_test(pSuite, "Enroll corrupted ECDSA cert", us903_test4)) ||
        (NULL == CU_add_test(pSuite, "Enroll retry-after manual approval ", us903_test5)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP fail with Curl", us903_test6)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP succeed with estclient", us903_test7)) ||
        (NULL == CU_add_test(pSuite, "Non-default ECDHE curve", us903_test8)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes valid PoP", us903_test9)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes invalid PoP", us903_test10)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP enabled using RA cert, CSR includes invalid PoP", us903_test11)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us4020.c - Unit Test for User Story 4020 - Unit test client
 *            proxy mode.  Test the new API function and
 *            verify correct operation of Client proxy modes.
 *
 * October, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include "est.h"
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include <errno.h>
#include <fcntl.h>

#define MAX_4020_CMDS 1024

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US4020_SERVER_DOMAIN_NAME "localhost.cisco.com"
#define US4020_SERVER_IP        "127.0.0.1"	
#define US4020_SERVER_TCP_PORT	40200

#define US4020_PROXY_IP         "127.0.0.1"	
#define US4020_PROXY_TCP_PORT	40208

#define US4020_UID	    "estuser"
#define US4020_PWD	    "estpwd"

#ifndef WIN32
#define US4020_CACERTS	     "CA/estCA/cacert.crt"
/* #define US4020_CACERT "CA/estCA/cacert.crt" */
/* #define US4020_SERVER_CERT "CA/estCA/private/estservercertandkey.pem" */
/* #define US4020_SERVER_KEY "CA/estCA/private/estservercertandkey.pem" */
/* #define US4020_CLIENT_CERT "CA/estCA/private/estservercertandkey.pem" */
/* #define US4020_CLIENT_KEY  "CA/estCA/private/estservercertandkey.pem" */
#else
#define US4020_CACERTS	     "CA\\estCA\\cacert.crt"
/* #define US4020_CACERT "CA\\estCA\\cacert.crt" */
/* #define US4020_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem" */
/* #define US4020_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem" */
/* #define US4020_CLIENT_CERT "CA\\estCA\\private\\estservercertandkey.pem" */
/* #define US4020_CLIENT_KEY  "CA\\estCA\\private/estservercertandkey.pem" */

static CRITICAL_SECTION logger_critical_section;  
static void us4020_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}
#endif 

static EVP_PKEY *generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}


static void us4020_clean (void)
{
}

int us4020_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US4020_SERVER_TCP_PORT, 
	          "CA/estCA/private/estservercertandkey.pem",
	          "CA/estCA/private/estservercertandkey.pem",
	          "estrealm",
	          "CA/estCA/cacert.crt",
	          "CA/trustedcerts.crt",
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

#define MAX_CMD_BUF 256
#define MAX_PID_BUF 128
static void shutdown_antinat (void)
{
    int fh;
    char read_pid[MAX_PID_BUF];
    char cmd[MAX_CMD_BUF];
    int rv = 0;
    
    fh = open ("./antinat-pid", O_RDWR, 0666);
    
    (void)read(fh, read_pid, MAX_PID_BUF);    
    printf("pid read back in = %s\n", read_pid);

    snprintf(cmd, MAX_CMD_BUF, "kill %s\n", read_pid);
    rv = system(cmd);

    if (rv) {
        printf("Failed to terminate antinat.\n");
    }
}

static void shutdown_haproxy (void)
{
    int fh;
/*     int readbyte_count = 0; */
    char read_pid[MAX_PID_BUF];
    char cmd[MAX_CMD_BUF];
    int rv = 0;

    fh = open ("./haproxy.pid", O_RDWR, 0666);
    
/*     readbyte_count = read(fh, read_pid, MAX_PID_BUF); */
    (void)read(fh, read_pid, MAX_PID_BUF);
    printf("pid read back in = %s\n", read_pid);

    snprintf(cmd, MAX_CMD_BUF, "kill %s\n", read_pid);
    rv = system(cmd);

    if (rv) {
        printf("Failed to terminate haproxy.\n");
    }
}


/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us4020_init_suite (void)
{
    int rv;
#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us4020_logger_stderr);
#else 
    est_init_logger(EST_LOG_LVL_INFO, NULL);
#endif    

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US4020_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us4020_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us4020_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us4020_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}


/*
 * Error check the parameters to the API
 */
static void us4020_test1 (void) 
{
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
     
    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  Attempt to call the API without a context
     */
    e_rc= est_client_set_proxy(NULL, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NO_CTX);

    /*
     * valid call
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * don't set the server 
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               NULL,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * server to empty string
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               "",
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * max server name 
     */
    char * max_server_name = "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               max_server_name,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * server name too long
     */
    char * long_server_name = "123456789012345678901234567890123456789012345678901234567890"
                              "123456789012345678901234567890123456789012345678901234567890"
                              "123456789012345678901234567890123456789012345678901234567890"
                              "123456789012345678901234567890123456789012345678901234567890"
                              "1234567890123456";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               long_server_name,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * don't set the port
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               0,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PORT_NUM);

    /* proxy protocol invalid */
    e_rc= est_client_set_proxy(ectx, 25,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);

    /* proxy protocol invalid */
    e_rc= est_client_set_proxy(ectx, -2,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);

    /* proxy auth invalid */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               25,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_AUTH);

    /*
     * max userid
     */
    char * max_userid = "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               max_userid, "estpwd");

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * userid too long
     */
    char * long_userid = "123456789012345678901234567890123456789012345678901234567890"
                         "123456789012345678901234567890123456789012345678901234567890"
                         "123456789012345678901234567890123456789012345678901234567890"
                         "123456789012345678901234567890123456789012345678901234567890"
                         "1234567890123456";

    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               long_userid, "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);

    /*
     * userid is an empty string
     */    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);

    /*
     * max pwd
     */
    char * max_pwd = "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", max_pwd);

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * pwd too long
     */    
    char * long_pwd = "123456789012345678901234567890123456789012345678901234567890"
                      "123456789012345678901234567890123456789012345678901234567890"
                      "123456789012345678901234567890123456789012345678901234567890"
                      "123456789012345678901234567890123456789012345678901234567890"
                      "1234567890123456";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", long_pwd);

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);

    /*
     * password is an empty string
     */    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);    
    
    est_destroy(ectx);
    
}


/*
 * Test for SOCKS 4 mode, no credentials, should pass
 *
 */
static void us4020_test2 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-2", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 4 mode, with credentials, should pass
 *
 */
static void us4020_test3 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-3", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode
 *
 */
static void us4020_test4 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
/*                                "estuser", "estpwd"); */
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-4", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 4A mode
 *
 */
static void us4020_test5 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
/*                                "estuser", "estpwd"); */
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-5", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with no credentials
 *
 */
static void us4020_test6 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);
    
    shutdown_antinat();
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with good credentials
 *
 */
static void us4020_test7 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg-goodcred.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);
    
    shutdown_antinat();
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with good credentials, but forgotten
 *
 */
static void us4020_test8 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg-goodcred.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);
    
    shutdown_antinat();
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with bad credentials
 *
 */
static void us4020_test9 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg-badcred.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);
    
    shutdown_antinat();
    est_destroy(ectx);
}


#if 0
/*
 * could be tested, but needs certifcates updated
 */
/*
 * Test for SOCKS 4A mode, with domain name 
 *
 */
static void us4020_test8 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_DOMAIN_NAME, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-7", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}
#endif

/*
 * Test HTTP proxy mode
 *
 * NOTE: only non-tunnel mode is tested.  tunnel mode does not
 * work with CiscoEST server.
 */
static void us4020_test10 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a HTTP proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "haproxy -D -f US4020/haproxy.cfg -p ./haproxy.pid");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-8", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_haproxy();    
    est_destroy(ectx);
}


/*
 * Indicate whether client proxy support has been built into
 * the library or not
 */
static int client_proxy_enabled (void) 
{
    EST_ERROR e_rc;
    
    e_rc = est_client_set_proxy(NULL, 0, NULL, 0, 0, NULL, NULL);
    if (e_rc == EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED) {
        return 0;
    } else {
        return 1;
    }
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us4020_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us4020_tok_auth_client", 
	                  us4020_init_suite, 
			  us4020_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }
#ifndef WIN32
   /*
    * client proxy mode is only supported when libcurl has been specified.
    */
   if (client_proxy_enabled()){
       
       /* add the tests to the suite */
       if (
           (NULL == CU_add_test(pSuite, "parameter check API", us4020_test1)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 4 mode", us4020_test2)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 4 mode w/ credentials", us4020_test3)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode", us4020_test4)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 4A mode", us4020_test5)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, no credentials", us4020_test6)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, good credentials", us4020_test7)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, forgotten credentials", us4020_test8)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, bad credentials", us4020_test9)) ||
/*            (NULL == CU_add_test(pSuite, "SOCKS 4A mode with domain name instead of IP address", us4020_test7)) || */
           (NULL == CU_add_test(pSuite, "HTTP proxy", us4020_test10))
           )
           {
               CU_cleanup_registry();
               return CU_get_error();
           }
   }
#endif   
   return CUE_SUCCESS;
#endif
}

/*------------------------------------------------------------------
 * us896.c - Unit Tests for User Story 896 - Client CSR Attributes
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifndef WIN32
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define US896_CACERTS       "CA/estCA/cacert.crt"
#define US896_TRUST_CERTS   "CA/trustedcerts.crt"
#define US896_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else 
#define CLIENT_UT_CACERT "CA\\estCA\\cacert.crt"
#define US896_CACERTS       "CA\\estCA\\cacert.crt"
#define US896_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US896_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif 

#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"
#define US896_SERVER_PORT   29896
#define US896_SERVER_IP     "127.0.0.1" 
#define TEST_SHORT_ATTR "M==\0"
#define TEST_LONG_ATTR "MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"
#define TEST_CORRUPT_ATTR1 "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOIExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_CORRUPT_ATTR2 "MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFM12345TIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\0"

#define EST_UT_MAX_CMD_LEN 255

static void us896_clean(void) {
}

static int us896_start_server(int manual_enroll, int nid) {
    int rv;

    rv = st_start(US896_SERVER_PORT,
    US896_SERVER_CERTKEY,
    US896_SERVER_CERTKEY, "US896 test realm",
    US896_CACERTS,
    US896_TRUST_CERTS, "CA/estExampleCA.cnf", manual_enroll, 0, nid);

    SLEEP(1);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us896_init_suite(void) {
    int rv = 0;
    char cmd[EST_UT_MAX_CMD_LEN];

    printf("Starting EST Server CSR attributes unit tests.\n");

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
            "openssl ecparam -name prime256v1 -genkey -out %s",
            CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us896_clean();

    /*
     * Start an instance of the EST server 
     */
    rv = us896_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us896_destroy_suite(void) {
    st_stop();
    SLEEP(2);
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error) {
    BIO *bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
            "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
            __FUNCTION__, openssl_cert_error,
            X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Test1 - exercise the est_client_get_csrattrs() API.
 */
static void us896_test1(void) {
    int rc;
    unsigned char *csr_data;
    int csr_len;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, NULL, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, NULL);
    CU_ASSERT(rc != EST_ERR_NONE);

}

/*
 * Test2 - exercise the response  variations triggered
 *         by est_client_get_csrattrs()
 */
static void us896_test2(void) {
    EST_CTX *ctx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY *priv_key;

    SLEEP(1);

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
            client_manual_cert_verify);
    CU_ASSERT(ctx != NULL);

    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ctx, US896_SERVER_IP, US896_SERVER_PORT, NULL);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ctx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    /* 
     * All of these are negative tests and require that code in the
     * EST server is modified such that it will allow bad/corrupted
     * attributes to be initialized so they can be sent to the client.
     */
#ifdef NEGATIVE_UNIT_TEST
    unsigned char *csr_data;
    int csr_len;

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR1, strlen(TEST_CORRUPT_ATTR1));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR2, strlen(TEST_CORRUPT_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    rc = est_server_init_csrattrs(ectx, TEST_SHORT_ATTR, strlen(TEST_SHORT_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

#endif

    if (ctx) {
        est_destroy(ctx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us896_add_suite(void) {
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us896_client_csrattrs",
            us896_init_suite,
            us896_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "CSR Client Attributes API1", us896_test1)) ||
            (NULL == CU_add_test(pSuite, "CSR Client Attributes API2 ", us896_test2)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us898.c - Unit Tests for User Story 898 - Client re-enroll 
 *
 * October, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <est_ossl_util.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US898_SERVER_PORT   29898
#define US898_SERVER_IP	    "127.0.0.1"	
#define US898_UID	    "estuser"
#define US898_PWD	    "estpwd"
#ifndef WIN32
#define US898_CACERTS	    "CA/estCA/cacert.crt"
#define US898_TRUST_CERTS   "CA/trustedcerts.crt"
#define US898_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"

#define US898_TC2_CERT_TXT "US898/tc2-new-cert.txt"
#define US898_TC2_CERT_B64 "US898/tc2-new-cert.pkcs7b64"
#define US898_TC2_CERT_PK7 "US898/tc2-new-cert.pkcs7"
#define US898_TC2_CERT_PEM "US898/tc2-new-cert.pem"

#define US898_TC10_CSR	"US898/tc10_csr.pem"
#define US898_TC10_KEY	"US898/tc10_key.pem"
#define US898_TC10_CERT	"US898/tc10_cert.pem"

#define US898_TC11_KEY	"US898/tc11_key.pem"
#define US898_TC11_CERT	"US898/tc11_cert.pem"
#else
  #define US898_CACERTS	    "CA\\estCA\\cacert.crt"
#define US898_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US898_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"

#define US898_TC2_CERT_TXT "US898\\tc2-new-cert.txt"
#define US898_TC2_CERT_B64 "US898\\tc2-new-cert.pkcs7b64"
#define US898_TC2_CERT_PK7 "US898\\tc2-new-cert.pkcs7"
#define US898_TC2_CERT_PEM "US898\\tc2-new-cert.pem"

#define US898_TC10_CSR	"US898\\tc10_csr.pem"
#define US898_TC10_KEY	"US898\\tc10_key.pem"
#define US898_TC10_CERT	"US898\\tc10_cert.pem"

#define US898_TC11_KEY	"US898\\tc11_key.pem"
#define US898_TC11_CERT	"US898\\tc11_cert.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us898_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}

#endif

static void us898_clean (void)
{
    char cmd[200];

    /*
     * These are all temporary files created 
     * by the various test cases.
     */
#ifndef WIN32
    sprintf(cmd, "rm %s", US898_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC2_CERT_PEM);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC10_CERT);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC10_KEY);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC10_CSR);
    system(cmd);
#else
    sprintf(cmd, "del %s", US898_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC2_CERT_PEM);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC10_CERT);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC10_KEY);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC10_CSR);
    system(cmd);
#endif 
}

/*
 * This starts an instance of the EST server running on
 * a separate thread.  We use this to test the
 * client side API in this module.
 */
static int us898_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US898_SERVER_PORT, 
	          US898_SERVER_CERTKEY,
	          US898_SERVER_CERTKEY,
	          "estrealm",
	          US898_CACERTS,
	          US898_TRUST_CERTS,
	          "US898/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us898_init_suite (void)
{
    int rv;

#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us898_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US898_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us898_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us898_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us898_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        return (1);
    }    
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
//    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);


    BIO_free(bio_err);
    
    return approve;
}    

/*
 * This function performs a basic simple enroll using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variet of test cases in this module.
 */
static void us898_test1 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) *certs = NULL;
    int i;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);
    if (rv != EST_ERR_NONE) return;

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.  
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out,NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i=OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
	certs = p7->d.sign->cert;
	break;
    case NID_pkcs7_signedAndEnveloped:
	certs = p7->d.signed_and_enveloped->cert;
	break;
    default:
	break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs) return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);


    /* 
     * Wow, that's a lot of work, but we finally have the X509.
     * (don't you just love OpenSSL!!!)
     * Now that we have an X509 representation of the cert,
     * let's try to re-enroll this cert with the CA
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (cert) X509_free(cert);
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  The expired certs contains
 * several X509 extensions. We verify the new issued
 * cert preserves these extensions using grep.  Note, 
 * preserving these extensions requires the OpenSSL CA
 * to enable the "copy_extensions" knob in the OpenSSL
 * config file.  This is why this test suite uses a
 * unique copy of estExampleCA.cnf.
 */
static void us898_test2 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    X509 *cert = NULL;
    BIO *in;
    char cmd[200];
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Save the cert to a local file
     */
    rv = write_binary_file(US898_TC2_CERT_B64, new_cert, pkcs7_len);
    CU_ASSERT(rv == 1);

    /*
     * Base 64 decode the cert response
     */
    sprintf(cmd, "openssl base64 -d -in %s -out %s", US898_TC2_CERT_B64, US898_TC2_CERT_PK7);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert the pkcs7 cert to a PEM cert
     */
    sprintf(cmd, "openssl pkcs7 -in %s -inform DER -print_certs -out %s", US898_TC2_CERT_PK7, US898_TC2_CERT_PEM);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert PEM cert to a textual representation of the cert
     */
    sprintf(cmd, "openssl x509 -text -in %s > %s", US898_TC2_CERT_PEM, US898_TC2_CERT_TXT);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Verify the jimbob DNS extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT, "jimbob");
    CU_ASSERT(rv == 0);

    /*
     * Verify the bobcat DNS extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT, "bobcat");
    CU_ASSERT(rv == 0);

    /*
     * Verify the IP address extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT,"172");
    CU_ASSERT(rv == 0);

    /*
     * Verify the Repudiation key usage extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT,"Repudiation");
    CU_ASSERT(rv == 0);

    /*
     * Verify the public key was preserved
     */
    rv = grep(US898_TC2_CERT_TXT, "00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50");
    CU_ASSERT(rv == 0);

    /*
     * Clean up
     */
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}

/*
 * Test the re-enroll API to ensure it gracefully
 * handles a null X509 cert pointer.
 */
static void us898_test3 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    int rv;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * re-enroll using a null x509 pointer.
     */
    rv = est_client_reenroll(ectx, NULL, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NO_CERT);

    /*
     * Clean up
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 * Test the re-enroll API to ensure it gracefully
 * handles a null EVP_PKEY pointer.
 */
static void us898_test4 (void) 
{
    EST_CTX *ectx;
    int pkcs7_len = 0;
    int rv;
    X509 *cert = NULL;
    unsigned char *cert_raw;
    int cert_len;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in an old cert that we can use for re-enroll
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * re-enroll using a null EVP_KEY pointer.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, NULL);
    CU_ASSERT(rv == EST_ERR_NO_KEY);

    /*
     * Clean up
     */
    X509_free(cert);
    est_destroy(ectx);
}

/*
 * This test attempts to re-enroll a corrupted cert
 * The public key in the cert is has been corrupted.
 */
static void us898_test5 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-corrupt.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-corrupt.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CLIENT_INVALID_KEY);

    /*
     * Clean up
     */
    est_destroy(ectx);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured for manual
 * approval.  The server will send back a retry-after
 * response.
 */
static void us898_test6 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Stop the server.
     */
    st_stop();

    /*
     * Restart the server with manual approval enabled
     */
    rv = us898_start_server(1, 0);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);

    /*
     * Clean up
     */
    est_destroy(ectx);

    /*
     * Stop the server.
     */
    st_stop();

    /*
     * Restart the server with manual approval disabled
     */
    rv = us898_start_server(0, 0);
    CU_ASSERT(rv == 0);
}

/*
 * Verify that a bogus user ID/password fails when
 * using HTTP basic auth.
 */
static void us898_test7 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, "hoagie", "chili", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);

    est_destroy(ectx);
}

/*
 * Verify that a good user ID/password passes when
 * using HTTP digest auth.
 */
static void us898_test8 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Enable HTTP digest authentication
     */
    st_enable_http_digest_auth();

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_destroy(ectx);

    /*
     * Re-enable HTTP basic authentication
     */
    st_enable_http_basic_auth();

}

/*
 * Verify that a bogus user ID/password fails when
 * using HTTP digest auth.
 */
static void us898_test9 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;
    int http_status;

    LOG_FUNC_NM;

    /*
     * Enable HTTP digest authentication
     */
    st_enable_http_digest_auth();

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, "jdoe", "panthers", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);

    /*
     * Check the HTTP status code from the reenroll operation
     */
    http_status = est_client_get_last_http_status(ectx);
    CU_ASSERT(http_status == 401);

    est_destroy(ectx);

    /*
     * Re-enable HTTP basic authentication
     */
    st_enable_http_basic_auth();

}

/*
 * Verify the server fails authentication when the
 * client sends a valid identity cert but doesn't 
 * provide HTTP auth credentials.
 */
static void us898_test10 (void) 
{
    char cmd[200];
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a CSR
     */
    sprintf(cmd, "openssl req -new -nodes -out %s -newkey rsa:2048 -keyout %s -subj /CN=127.0.0.1 "
	    "-config CA/estExampleCA.cnf", 
	    US898_TC10_CSR, US898_TC10_KEY);  
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Sign the CSR using our local CA
     */
    sprintf(cmd, "openssl ca -out %s -batch -config CA/estExampleCA.cnf -infiles %s", 
	    US898_TC10_CERT, US898_TC10_CSR);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US898_TC10_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US898_TC10_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);


    /*
     * Set the authentication mode to use the certificate 
     * No HTTP auth credentials are provided.
     */
    rv = est_client_set_auth(ectx, NULL, NULL, cert, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll a cert, should fail because we 
     * didn't provide valid HTTP auth credentials
     */
    rv = est_client_enroll(ectx, "TC-US898-10", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);

    /*
     * Re-Enroll the cert, should work since
     * we provide a valid cert to identify ourselves
     * and HTTP auth isn't required for re-enroll even when
     * the server has enabled HTTP auth.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_destroy(ectx);
}

/*
 * Verify the server fails authentication when the
 * client sends an expired identy cert and uses 
 * valid HTTP auth credentials.
 */
static void us898_test11 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US898_TC11_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US898_TC11_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);


    /*
     * Set the authentication mode to use the expired certificate 
     * and valid HTTP auth credentials.
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, cert, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    /*
     * Re-Enroll the cert 
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    est_destroy(ectx);
}


int us898_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us898_client_reenroll", 
	                  us898_init_suite, 
			  us898_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* 
    * Add the tests to the suite 
    */
   if ((NULL == CU_add_test(pSuite, "Simple enroll and re-enroll", us898_test1)) ||
       (NULL == CU_add_test(pSuite, "Re-enroll expired cert with extensions", us898_test2)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll using NULL cert", us898_test3)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll using NULL key", us898_test4)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll using corrupted X509 cert", us898_test5)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll retry-after", us898_test6)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll invalid UID/PWD Basic", us898_test7)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll valid UID/PWD Digest", us898_test8)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll invalid UID/PWD Digest", us898_test9)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll valid certificate no HTTP auth", us898_test10)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll expired certificate with HTTP auth", us898_test11))) 
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us1864.c - Unit Tests for User Story 1864 - Enable Token Auth mode in server
 *
 * March, 2015
 *
 * Copyright (c) 2015, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include <errno.h>

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US1864_TCP_PORT     29001

/*
 * The following CSR was generated using the following openssl command and theng
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US1864_PKCS10_RSA2048   "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"
#define US1864_PKCS10_4096_REQ  "MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\n"

#define US1864_ENROLL_URL_BA    "https://127.0.0.1:29001/.well-known/est/simpleenroll"
#define US1864_PKCS10_CT        "Content-Type: application/pkcs10"
#define US1864_UIDPWD_GOOD      "estuser:estpwd"
#ifndef WIN32
#define US1864_CACERTS          "CA/estCA/cacert.crt"
#define US1864_CACERT           "CA/estCA/cacert.crt"
#define US1864_TRUSTED_CERT     "CA/trustedcerts.crt"
#define US1864_SERVER_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US1864_SERVER_KEY       "CA/estCA/private/estservercertandkey.pem"
#define US1864_CLIENT_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US1864_CLIENT_KEY       "CA/estCA/private/estservercertandkey.pem"
#else
#define US1864_CACERTS          "CA\\estCA\\cacert.crt"
#define US1864_CACERT           "CA\\estCA\\cacert.crt"
#define US1864_TRUSTED_CERT     "CA\\trustedcerts.crt"
#define US1864_SERVER_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US1864_SERVER_KEY       "CA\\estCA\\private\\estservercertandkey.pem"
#define US1864_CLIENT_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US1864_CLIENT_KEY       "CA\\estCA\\private\\estservercertandkey.pem"
#endif

/*
 * curl_data_cb is passed to Curl and will be called from Curl whenever data
 * has been received, or if this function has been specified to retrieve the
 * http headers.  In this test it's used to retrieve the http headers and
 * look for the "bearer" token Authorization challenge.
 */
static int bearer_found = 0;
static size_t curl_data_cb (void *ptr, size_t size, size_t nmemb,
                            void *userdata)
{
    void * rc;

    if (bearer_found == 0) {

        /*
         * WARNING: strstr can be dangerous because it assumes null terminated
         * strings.  In this case the http headers came from EST server and we
         * know they are null terminated
         */
        rc = strstr(ptr, "WWW-Authenticate: Bearer");
        if (rc) {
            bearer_found = 1;
        }
    }

    return size * nmemb;
}

static void us1864_clean (void)
{
}

static int us1864_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US1864_TCP_PORT,
                  US1864_SERVER_CERT,
                  US1864_SERVER_KEY,
                  "US1864 test realm",
                  US1864_CACERTS,
                  US1864_TRUSTED_CERT,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1864_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1864_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us1864_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1864_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1864_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}

/*
 * est_server_set_auth_mode() - unit test
 *
 * First, Test the parameters of est_server_set_auth_mode()
 */
static void us1864_test1 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;
    EST_ERROR est_rv;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1864_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US1864_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US1864_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * init EST in server mode
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
        EST_CERT_FORMAT_PEM, "testrealm", x, priv_key);

    CU_ASSERT(ctx != NULL);

    est_rv = est_server_set_auth_mode(ctx, AUTH_NONE);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);
    est_rv = est_server_set_auth_mode(ctx, AUTH_BASIC);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_server_set_auth_mode(ctx, AUTH_TOKEN);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_server_set_auth_mode(ctx, 0xffffffff);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);

    /*
     * Make sure we don't allow DIGEST mode when in FIPS mode
     */
    FIPS_mode_set(1);
    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);
    FIPS_mode_set(0);

    X509_free(x);
    EVP_PKEY_free(priv_key);

    est_destroy(ctx);
}

/*
 * Simple enroll - Token Auth Mode
 *
 * The goal of this test is to verify that the EST server responds with the
 * correct auth challenge when it's configured for Token Auth mode.  It will
 * first perform a sanity check by performing an HTTP Basic request while the
 * server is still in its default mode of HTTP Basic auth.  The test will then
 * configure the server for Token Auth mode and issue a request that does not
 * contain any auth header.  This should force the server to respond with a
 * token auth challenge header.
 */
static void us1864_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US1864_ENROLL_URL_BA, US1864_PKCS10_CT,
    US1864_PKCS10_RSA2048,
    US1864_UIDPWD_GOOD, US1864_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we specify BASIC and the server is still in BASIC
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    /*
     * Switch the server over to Token mode.
     *
     * NOTE: I see this being done in numerous places, and it's probably safe
     * in a test setting, but it is dangerous to change this on the fly in an
     * operational setting.  Also note, no return code for any of these
     * set/enable functions.
     */
    st_enable_http_token_auth();

    bearer_found = 0;

    rv = curl_http_post_cert_write(US1864_ENROLL_URL_BA,
    US1864_PKCS10_CT,
    US1864_PKCS10_RSA2048,
    US1864_CLIENT_CERT,
    US1864_CLIENT_KEY,
    US1864_CACERTS, curl_data_cb, curl_data_cb);

    /*
     * Since we changed auth modes on the server we expect this to now
     * fail.  We're not capturing the actual auth challenge we
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 401);
    CU_ASSERT(bearer_found == 1);

}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us1864_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1864_cfg_tok_auth",
            us1864_init_suite,
            us1864_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "Check parms", us1864_test1)) ||
        (NULL == CU_add_test(pSuite, "Attempt enroll - BASIC pass", us1864_test2))
        )
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
 #endif
 }


/*------------------------------------------------------------------
 * us2174.c - Unit Tests for User Story 2174 - Proxy simple enroll
 *
 * August, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US2174_RETRY_INTERVAL   3600
//#define US2174_TCP_PORT       29001

#define US2174_TCP_SERVER_PORT      52174
#define US2174_TCP_PROXY_PORT       62174

#ifndef WIN32
#define US2174_SERVER_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US2174_SERVER_KEY       "CA/estCA/private/estservercertandkey.pem"
/* #define US2174_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US2174_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US2174_PROXY_CERT       "US2174/cert.pem"
#define US2174_PROXY_KEY        "US2174/key.pem"
#define US2174_CACERT           "CA/estCA/cacert.crt"
#define US2174_CACERTS          "CA/estCA/cacert.crt"
#define US2174_TRUSTED_CERTS    "CA/trustedcerts.crt"
#define US2174_EXPLICIT_CERT    "US2174/cert-RA.pem"
#define US2174_EXPLICIT_KEY     "US2174/key-RA.pem"

#else
#define US2174_SERVER_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US2174_SERVER_KEY       "CA\\estCA\\private/estservercertandkey.pem"
/* #define US2174_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US2174_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US2174_PROXY_CERT       "US2174\\cert.pem"
#define US2174_PROXY_KEY        "US2174\\key.pem"
#define US2174_CACERT           "CA\\estCA\\cacert.crt"
#define US2174_CACERTS          "CA\\estCA\\cacert.crt"
#define US2174_TRUSTED_CERTS    "CA\\trustedcerts.crt"
#define US2174_EXPLICIT_CERT    "US2174\\cert-RA.pem"
#define US2174_EXPLICIT_KEY     "US2174\\key-RA.pem"
#endif

#define US2174_SERVER_IP        "127.0.0.1"
#define US2174_TCP_PORT         US2174_TCP_SERVER_PORT

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US2174_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the ec.req file:
 *
 * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM
 */
#define US2174_PKCS10_DSA1024 "MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\nzn9HujlXNaTA1OhjmPmcJSxT"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the dsa.req file:
 *
 * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM
 */
#define US2174_PKCS10_ECDSA256 "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

#define US2174_PKCS10_CORRUPT "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

/*
 * The following is a valid CSR that already contains a PoP
 * challengePassword.  This was collected using estserver with
 * the dumpbin() function.  This CSR should never work since
 * the PoP value in it will be stale.
 */
#define US2174_PKCS10_STALE_POP "MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40="

#define US2174_ENROLL_URL_BA    "https://127.0.0.1:62175/.well-known/est/simpleenroll"
#define US2174_PKCS10_CT        "Content-Type: application/pkcs10" 
#define US2174_UIDPWD_GOOD      "estuser:estpwd"

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

#define GOOD_TOKEN "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U="
#define DIFFERENT_TOKEN "V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy"
#define NULL_TOKEN NULL;
#define LONG_TOKEN "SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U="
static char *test_token = "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=";

static int auth_cred_callback_called = 0;
static int auth_cred_force_error = 0;

/*
 * auth_credentials_token_cb() is the application layer callback function that will
 * return a token based authentication credential when called.  It's registered
 * with the EST Client using the est_client_set_auth_cred_cb().
 * The test function is required to set some global values in order to make this
 * callback operate the way that the test case wants.
 * - auth_cred_force_error = tell this function to force a response code error
 * - test_token = pointer to a hard coded string that is the token string to return
 *
 * This callback must provide the token credentials in a heap based buffer, and
 * ownership of that buffer is implicitly transferred to the ET client library upon
 * return.
 */
static EST_HTTP_AUTH_CRED_RC auth_credentials_token_cb (
        EST_HTTP_AUTH_HDR *auth_credentials)
{
    char *token_ptr = NULL;
    int token_len = 0;

    CU_ASSERT(auth_credentials->mode == AUTH_TOKEN);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }

    if (auth_credentials->mode == AUTH_TOKEN) {
        /*
         * If the test_token is set to anything, then we need to allocate
         * space from the heap and copy in the value.
         */
        if (test_token != NULL) {
            token_len = strlen(test_token); /* use strlen() so that the string can be as large
             as needed to test the EST client */
            if (token_len == 0) {
                printf(
                    "\nError determining length of token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }
            token_ptr = malloc(token_len + 1);
            if (token_ptr == NULL) {
                printf(
                    "\nError allocating token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }
            strncpy(token_ptr, test_token, strlen(test_token));
            token_ptr[token_len] = '\0';
        }
        /*
         * If we made it this far, token_ptr is pointing to a string
         * containing the token to be returned. Assign it and return success
         */
        auth_credentials->auth_token = token_ptr;

        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }

    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}

/*
 * auth_credentials_basic_cb() is the same as the token based one above, but
 * instead returns the basic credentials of userid and password
 */
static EST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb (
        EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_BASIC);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }

    if (auth_credentials->mode == AUTH_BASIC) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));

        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }

    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}

#if 0
/*
 * auth_credentials_digest_cb() is the same as the basic based one above, but
 * instead verfies that the auth_mode passed is digest
 */
static
EST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_DIGEST);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }

    if (auth_credentials->mode == AUTH_DIGEST) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));

        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }

    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}
#endif

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__, openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * us2174_simple_enroll() is used by test cases to perform a simple enroll.
 */
static void us2174_simple_enroll (char *cn, char *server,
                                  EST_ERROR expected_enroll_rv,
                                  auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    EST_ERROR e_rc;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

static
void us2174_simple_reenroll (char *cn, char *server,
                             EST_ERROR expected_enroll_rv,
                             auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;

    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) * certs = NULL;
    int i;

    EST_ERROR e_rc;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    est_destroy(ectx);
    ectx = NULL;
    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Now that we have the cert, switch the server over to token mode
     */
    st_enable_http_token_auth();

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US2174_TCP_PORT, NULL);

    /*
     * And attempt a reenroll while in token mode
     *
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.
     * PDB: This conversion code comes from other test cases.
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out, NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i = OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
        certs = p7->d.sign->cert;
        break;
    case NID_pkcs7_signedAndEnveloped:
        certs = p7->d.signed_and_enveloped->cert;
        break;
    default:
        break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs)
        return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);

    /*
     * PDB NOTE: At the moment, this is expected to fail since
     * the server does not yet understand requests with token authentication.
     * Once 1884 is complete, the below ASSERT will begin to fail and will need
     * to be changed to a passing response.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

static void us2174_clean (void)
{
}

static int us2174_start_server (int manual_enroll, int nid)
{
    int rv = 0;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US2174_TCP_SERVER_PORT,
                  US2174_SERVER_CERT,
                  US2174_SERVER_KEY,
                  "estrealm",
                  US2174_CACERT,
                  US2174_TRUSTED_CERTS,
                  "US2174/estExampleCA.cnf",
                  manual_enroll, // manual enroll
                  0,  // disable PoP
                  nid); // ecdhe nid info
    SLEEP(1);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy acting as an RA with the server side
     * operating in token auth mode.
     */
    rv = st_proxy_start_token(US2174_TCP_PROXY_PORT,
                              US2174_PROXY_CERT,
                              US2174_PROXY_KEY, "estrealm",
                              US2174_CACERT,
                              US2174_TRUSTED_CERTS,
                              "estuser",
                              "estpwd",
                              "127.0.0.1",
                              US2174_TCP_SERVER_PORT,
                              0); //  disable PoP

    SLEEP(1);

    return rv;
}

void us2174_stop_server ()
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us2174_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US2174_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us2174_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us2174_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us2174_destroy_suite (void)
{
    us2174_stop_server();
    free(cacerts);
    return 0;
}

#if 0
/*
 * Simple enroll -
 * proxy - BASIC
 * server - BASIC
 *
 * Make sure token auth mode did not break anything.
 *
 */
static void us2174_test1(void)
{
    long rv;

    LOG_FUNC_NM;

    rv = curl_http_post(US2174_ENROLL_URL_BA, US2174_PKCS10_CT,
            US2174_PKCS10_RSA2048,
            US2174_UIDPWD_GOOD, US2174_CACERTS, CURLAUTH_BASIC,
            NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}
#endif

/*
 * Simple enroll -
 * proxy - TOKEN
 * server - TOKEN
 *
 */
static void us2174_test2 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do token auth challenges
     * tell the server which tokens to accept
     */
    st_enable_http_token_auth();
    st_set_token(GOOD_TOKEN);
    /*
     * set the proxy to do token auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_token_auth();
    st_proxy_set_srv_valid_token(GOOD_TOKEN);
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us2174_simple_enroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/*
 * Simple enroll -
 * proxy - TOKEN
 * server - BASIC
 */
static void us2174_test3 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do BASIC auth challenges
     */
    st_enable_http_basic_auth();
    /*
     * set the proxy to do token auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_token_auth();
    st_proxy_set_srv_valid_token(GOOD_TOKEN);
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us2174_simple_enroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/*
 * Simple enroll -
 * proxy - BASIC
 * server - TOKEN
 */
static void us2174_test4 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do token auth challenges
     * tell the server which tokens to accept
     */
    st_enable_http_token_auth();
    st_set_token(GOOD_TOKEN);
    /*
     * set the proxy to do BASIC auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_basic_auth();
    /*     st_proxy_set_srv_valid_token(GOOD_TOKEN); */
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us2174_simple_enroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_basic_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/*
 * Simple RE-enroll -
 * proxy - TOKEN
 * server - TOKEN
 *
 */
static void us2174_test5 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do token auth challenges
     * tell the server which tokens to accept
     */
    st_enable_http_token_auth();
    st_set_token(GOOD_TOKEN);
    /*
     * set the proxy to do token auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_token_auth();
    st_proxy_set_srv_valid_token(GOOD_TOKEN);
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple RE-enroll.
     *
     * RE-enroll should succeed.
     */
    us2174_simple_reenroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us2174_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us2174_token_proxy",
            us2174_init_suite,
            us2174_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if (/* (NULL == CU_add_test(pSuite, "Proxy Enroll basic sanity test", us2174_test1)) || */
        (NULL == CU_add_test(pSuite, "Proxy Enroll token auth, both proxy and server", us2174_test2)) ||
        (NULL == CU_add_test(pSuite, "Proxy Enroll token auth, proxy token/server basic", us2174_test3)) ||
        (NULL == CU_add_test(pSuite, "Proxy Enroll token auth, proxy basic/server token", us2174_test4)) ||
        (NULL == CU_add_test(pSuite, "Proxy RE-Enroll token auth, proxy basic/server token", us2174_test5))
        )
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us1883.c - Unit Tests for User Story 1883 - Enable token auth mode for
 *            the EST Client.
 *
 * March, 2015
 *
 * Copyright (c) 2015, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include <errno.h>


static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US1883_SERVER_IP        "127.0.0.1"	
#define US1883_TCP_PORT		29001

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US1883_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"
#define US1883_PKCS10_4096_REQ "MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\n"
#define US1883_ENROLL_URL_BA "https://127.0.0.1:29001/.well-known/est/simpleenroll"
#define US1883_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US1883_UIDPWD_GOOD   "estuser:estpwd"
#ifndef WIN32
#define US1883_CACERTS	     "CA/estCA/cacert.crt"
#define US1883_CACERT "CA/estCA/cacert.crt"
#define US1883_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US1883_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
#define US1883_CLIENT_CERT "CA/estCA/private/estservercertandkey.pem"
#define US1883_CLIENT_KEY  "CA/estCA/private/estservercertandkey.pem"
#else
#define US1883_CACERTS	     "CA\\estCA\\cacert.crt"
#define US1883_CACERT "CA\\estCA\\cacert.crt"
#define US1883_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US1883_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US1883_CLIENT_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US1883_CLIENT_KEY  "CA\\estCA\\private/estservercertandkey.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us1883_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}

#endif 


static void us1883_clean (void)
{
}

static int us1883_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US1883_TCP_PORT, 
	          "CA/estCA/private/estservercertandkey.pem",
	          "CA/estCA/private/estservercertandkey.pem",
	          "estrealm",
	          "CA/estCA/cacert.crt",
	          "CA/trustedcerts.crt",
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1883_init_suite (void)
{
    int rv;
#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us1883_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1883_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us1883_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us1883_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1883_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}


static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}

#define GOOD_TOKEN "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U="
#define DIFFERENT_TOKEN "V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy"
#define NULL_TOKEN NULL;
#define LONG_TOKEN "SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U="
char *test_token = "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=";

int auth_cred_callback_called = 0;
int auth_cred_force_error = 0;

/*
 * auth_credentials_token_cb() is the application layer callback function that will
 * return a token based authentication credential when called.  It's registered
 * with the EST Client using the est_client_set_auth_cred_cb().
 * The test function is required to set some global values in order to make this
 * callback operate the way that the test case wants.
 * - auth_cred_force_error = tell this function to force a response code error
 * - test_token = pointer to a hard coded string that is the token string to return
 *
 * This callback must provide the token credentials in a heap based buffer, and
 * ownership of that buffer is implicitly transferred to the ET client library upon
 * return.
 */
EST_HTTP_AUTH_CRED_RC auth_credentials_token_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    char *token_ptr = NULL;
    int token_len = 0;

    CU_ASSERT(auth_credentials->mode == AUTH_TOKEN);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }
    
    if (auth_credentials->mode == AUTH_TOKEN) {
        /*
         * If the test_token is set to anything, then we need to allocate
         * space from the heap and copy in the value.
         */
        if (test_token != NULL) {
            token_len = strlen(test_token); /* use strlen() so that the string can be as large
                                               as needed to test the EST client */
            if (token_len == 0) {
                printf("\nError determining length of token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }   
            token_ptr = malloc(token_len+1);
            if (token_ptr == NULL){
                printf("\nError allocating token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }   
            strncpy(token_ptr, test_token, strlen(test_token));
            token_ptr[token_len] = '\0';
        }
        /*
         * If we made it this far, token_ptr is pointing to a string
         * containing the token to be returned. Assign it and return success
         */
        auth_credentials->auth_token = token_ptr;
        
        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }
    
    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}

/*
 * auth_credentials_basic_cb() is the same as the token based one above, but
 * instead returns the basic credentials of userid and password
 */
EST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_BASIC);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }
    
    if (auth_credentials->mode == AUTH_BASIC) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));
        
        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }
    
    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}


/*
 * auth_credentials_digest_cb() is the same as the basic based one above, but
 * instead verfies that the auth_mode passed is digest
 */
EST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_DIGEST);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }
    
    if (auth_credentials->mode == AUTH_DIGEST) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));
        
        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }
    
    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}


/*
 * Test the est_client_set_auth_cred_cb API
 *
 * Exercise the parameters
 */
static void us1883_test1 (void) 
{
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
     
    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /* Forgot to specify any parameters. Context will
     * get caught
     */
    e_rc = est_client_set_auth_cred_cb(NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NO_CTX);

    /*
     * valid call
     */
    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_token_cb);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * attempt to reset the callback function
     */
    e_rc = est_client_set_auth_cred_cb(ectx, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    est_destroy(ectx);
}

/*
 * us1883_simple_enroll() is used by test cases to perform a simple enroll.
 */
static void us1883_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    EST_ERROR e_rc; 

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Perform a simple enroll first in order to get a valid cert, then perform the
 * reenroll.  The simple enroll needs to be successful, so it's currently
 * being done using basic mode because the EST server does not yet have token
 * based support.
 * PDB NOTE:  Once the server side token support have been implemented, this
 * this function can optionally be updated to do token mode on the first enroll,
 * but it's not absolutely necessary since the purpose of this is to test reenroll
 * and the initial enroll is needed just to get the cert.
 */
static
void us1883_simple_reenroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;

    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) *certs = NULL;
    int i;
    
    EST_ERROR e_rc;    

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Make sure the server is currently in  BASIC auth mode
     */
    st_enable_http_basic_auth();
    
    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_basic_cb);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    est_destroy(ectx);
    ectx = NULL;
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);    
    
    /*
     * Now that we have the cert, switch the server over to token mode
     */
    st_enable_http_token_auth();
    
    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);
    
    /*
     * And attempt a reenroll while in token mode
     *
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.
     * PDB: This conversion code comes from other test cases.
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out,NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i=OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
	certs = p7->d.sign->cert;
	break;
    case NID_pkcs7_signedAndEnveloped:
	certs = p7->d.signed_and_enveloped->cert;
	break;
    default:
	break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs) return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);

    /*
     * PDB NOTE: At the moment, this is expected to fail since
     * the server does not yet understand requests with token authentication.
     * Once 1884 is complete, the below ASSERT will begin to fail and will need
     * to be changed to a passing response.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);
    
    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Test2 - Application layer did not register callback, causing an
 *         HTTP Aithentication header with an empty token credential
 *         
 * In this test,
 * - application layer DOES NOT register its callback
 * - EST Client gets the challenge, finds no callback registered and goes with
 *   the credentials it has stored in the Context, which is nothing.
 *   NOTE: This is the way the preloaded credential flow has always worked.
 * - enroll is sent with no token credentials
 * - server fails and does not give a certificate
 */
static void us1883_test2 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass no callback function to catch and handle the request for a token auth.
     *
     * enroll better fail due to missing credentials
     */
    us1883_simple_enroll("TC1883-2", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, NULL);

    /*
     * callback was never registered, so it should not have been invoked.
     */
    CU_ASSERT(auth_cred_callback_called == 0);
}


/*
 * Test3 - Application layer registers callback, BUT does not set any
 *         credentials when invoked.  Same result as previous test
 *         
 * In this test,
 * - application layer registers its callback
 * - EST Client gets the challenge, calls the callback, gets back an 
 *   empty credential structure and ends up sending an HTTP auth header
 *   with no credentials.
 *   NOTE: This is the way the preloaded credential flow has always worked.
 * - enroll is sent with no token credentials
 * - server fails and does not give a certificate
 */
static void us1883_test3 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = NULL_TOKEN;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Register the token based callback, but set it so that it passes back no token.
     *
     * enroll better fail due to missing credentials
     */
    us1883_simple_enroll("TC1883-3", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test4 - Good token is sent to server and is accepted.  Cert should
 * be generated and returned
 *
 * In this test,
 * - application layer registers its callback and responds with a valid token
 * - enroll is sent with this token credential
 * - server is set to match on this token and send back a cert
 */
static void us1883_test4 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = GOOD_TOKEN;

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us1883_simple_enroll("TC1883-4", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test EST client receiving a token auth challenge
 *
 * In this test, the application layer registers its callback and responds
 * with a failing return code.
 */
static void us1883_test5 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();

    auth_cred_callback_called = 0;
    /* Force the callback to give a failing return code */
    auth_cred_force_error = 1;
    test_token = GOOD_TOKEN;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * enroll better fail due to credentials not being supplied by the application layer
     * and eventual failure at the server due to missing credentials.
     */
    us1883_simple_enroll("TC1883-5", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test6 - Sanity test BASIC auth mode
 *
 * In this test,
 * - server into BASIC mode
 * - Client application registers its BASIC based callback
 * - Client should send the estuser/estpwd credentials and get a cert
 */
static void us1883_test6 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to BASIC mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_basic_auth();

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass a callback function to catch and handle the request for a token auth.
     *
     * enroll should pass because BASIC mode fully works.  Make sure that the
     * callback is called.  This will ensure that the credentials came from
     * the callback.
     */
    us1883_simple_enroll("TC1883-6", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_basic_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test7 - Make sure re-enroll works with the credential callback flow
 *         to obtain credentials
 *
 * In this test,
 * - server into TOKEN mode
 * - Client application registers its TOKEN based callback
 * - Client should send the valid token credential and get a cert
 */
static void us1883_test7 (void) 
{

    LOG_FUNC_NM;
    
    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = GOOD_TOKEN;

    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Re-enroll should succeed.
     *
     */
    us1883_simple_reenroll("TC1883-7", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test7 - Token credentials that are too long
 *
 * In this test,
 * - server into TOKEN mode and told to match against the GOOD token
 * - Client application registers its TOKEN based callback and is told to
 *   give back a token that is TOO LONG.
 * - Client should send a corrupted token that does not match the GOOD token.
 */
static void us1883_test8 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    /* Force the callback to give a failing return code */
    auth_cred_force_error = 0;
    test_token = LONG_TOKEN;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass a callback function to catch and handle the request for a token auth.
     *
     */
    us1883_simple_enroll("TC1883-8", US1883_SERVER_IP, EST_ERR_AUTH_FAIL,
                         auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test7 - Test DIGEST mode with on demand credential flow
 *
 * In this test,
 * - server into DIGEST mode
 *   NOTE: This means the server is expecting: "estuser"/"estpwd" and "estrealm"
 *         These values are hardcoded into data in the st_server, so st_server
 *         must be started with estrealm so that it returns this realm to client
 *         so that the client returns it in its request.
 * - Client application registers its DIGEST based callback
 * - Client should send a valid DIGEST and get a cert
 */
static void us1883_test9 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to DIGEST mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_digest_auth();

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass a callback function to catch and handle the request for a token auth.
     *
     * enroll should pass because DIGEST mode fully works.  Make sure that the
     * callback is called.  This will ensure that the credentials came from
     * the callback.
     */
    us1883_simple_enroll("TC1883-6", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_digest_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test4 - Valid token is provided by appliaction callback, but it's the WRONG
 *         token
 *
 * In this test,
 * - application layer registers its callback and responds with a valid token
 * - Server is set up for token mode, but with a different token.
 * - enroll is sent with this token credential
 * - server is set to match on this token and send back a cert
 */
static void us1883_test10 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(DIFFERENT_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = GOOD_TOKEN;

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should FAIL because the tokens will not match
     */
    us1883_simple_enroll("TC1883-4", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us1883_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us1883_tok_auth_client", 
	                  us1883_init_suite, 
			  us1883_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* add the tests to the suite */
   if ((NULL == CU_add_test(pSuite, "parse response", us1883_test1)) ||
       (NULL == CU_add_test(pSuite, "simple enroll no cb", us1883_test2)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb no token", us1883_test3)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb good token", us1883_test4)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb bad rc", us1883_test5)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb basic mode", us1883_test6)) ||
       (NULL == CU_add_test(pSuite, "simple re-enroll reg cb good token", us1883_test7)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb token too long", us1883_test8)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb digest mode", us1883_test9)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb mismatched valid token", us1883_test10))
       )
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us900.c - Unit Tests for User Story 900 - Server CSR Attributes
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US900_SERVER_PORT   29900
#define US900_SERVER_IP     "127.0.0.1" 

#ifndef WIN32
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"
#define US900_CACERTS       "CA/estCA/cacert.crt"
#define US900_TRUST_CERTS   "CA/trustedcerts.crt"
#define US900_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else
#define CLIENT_UT_CACERT "CA\\estCA\\cacert.crt"
#define CLIENT_UT_PUBKEY "est_client_ut_keypair"
#define US900_CACERTS       "CA\\estCA/cacert.crt"
#define US900_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US900_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif

#define TEST_ATTR_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR_NOPOP "MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\0"
#define TEST_ATTR_NOPOPPOP "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR_POPADDED "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR1 "MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\0"
#define TEST_ATTR2 "MAA=\0"
#define TEST_ATTR7 "MA==\0"
#define TEST_ATTR2_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR8 "MAthisis badsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR3 "MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\0"
#define TEST_ATTR4_122 "MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR4_122POP "MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR5_117 "MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR5_117POP "MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ATTR6_116 "MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR_244 "MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_245 "MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"
#define TEST_ATTR_250 "MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_250POP "MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ALL_ATTR "MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\0"
#define TEST_1024_NOPOP "MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\0"

#define TEST_1025_NOPOP "MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_1024_POP "MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\0"

#define TEST_LONG_ATTR "MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"

#define EST_UT_MAX_CMD_LEN 255
extern EST_CTX *ectx;

static void us900_clean (void)
{
}

static int us900_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US900_SERVER_PORT,
                  US900_SERVER_CERTKEY,
                  US900_SERVER_CERTKEY,
                  "US900 test realm",
                  US900_CACERTS,
                  US900_TRUST_CERTS,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);

    SLEEP(1);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us900_init_suite (void)
{
    int rv = 0;
    char cmd[EST_UT_MAX_CMD_LEN];

    printf("Starting EST Server CSR attributes unit tests.\n");

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(
        cmd,
        EST_UT_MAX_CMD_LEN,
        "openssl ecparam -name prime256v1 -genkey -out %s",
        CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us900_clean();

    /*
     * Start an instance of the EST server
     */
    rv = us900_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us900_destroy_suite (void)
{
    st_stop();
    SLEEP(2);
    return 0;
}

static unsigned char * handle_correct_csrattrs_request (int *csr_len,
                                                        char *path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR1);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_corrupt_csrattrs_request (int *csr_len,
                                                        char *path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR8);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_short_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR7);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_long_csrattrs_request (int *csr_len,
                                                     char *path_seg,
                                                     void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_LONG_ATTR);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_nopop_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR_NOPOP);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_empty_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = 0;
    csr_data = NULL;
    return (csr_data);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__,
        openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Test1 - exercise the est_server_init_csrattrs() API.
 */
static void us900_test1 (void)
{
    int rc;

    LOG_FUNC_NM
    ;

    /* NULL ctx - should fail */
    rc = est_server_init_csrattrs(NULL, "US900 test1", 10);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* NULL string - should pass */
    rc = est_server_init_csrattrs(ectx, NULL, 10);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Zero length - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 0);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Length too long - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", MAX_CSRATTRS + 1);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Real base64 string - should pass */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the smallest base64 size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting an illegally small base64 size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR7, strlen(TEST_ATTR7));
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* enable PoP */
    st_enable_pop();

    /* Real base64 string needs PoP added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 116 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 244 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 245 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 250 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* disable PoP */
    st_disable_pop();

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Real base64 string PoP should not be added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
}

/*
 * Test2 - exercise the server side variations triggered
 *         by est_client_get_csrattrs()
 */
static void us900_test2 (void)
{
    EST_CTX *ctx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY * priv_key;
    int csr_len;
    unsigned char *csr_data = NULL;

    SLEEP(1);

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ctx = est_client_init(
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ctx != NULL);

    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ctx, US900_SERVER_IP, US900_SERVER_PORT, NULL);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ctx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* should get 204 with no data */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    /* Real base64 string - should pass */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_corrupt_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_short_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_long_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2));
    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR3));
    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));
    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* Enable PoP and test responses with PoP added */
    st_enable_pop();

    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_data != NULL);
    CU_ASSERT(csr_len = 20);
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_POP));
    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));
    CU_ASSERT(
        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));
    CU_ASSERT(
        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);

    /* Real base64 string needs PoP added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 116 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 244 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 245 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 250 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));
    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_nopop_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_empty_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* disable PoP */
    st_disable_pop();

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Real base64 string PoP should not be added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));
    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1025_NOPOP,
        strlen(TEST_1025_NOPOP));
    CU_ASSERT(rc != EST_ERR_NONE);
    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));
    CU_ASSERT(rc != EST_ERR_NONE);

    if (ctx) {
        est_destroy(ctx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us900_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us900_srv_csrattrs",
            us900_init_suite,
            us900_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "CSR Server Attributes API1", us900_test1)) ||
        (NULL == CU_add_test(pSuite, "CSR Server Attributes API2", us900_test2)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us3496.c - Unit Tests URI path segment extension support 
 *
 * March, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include "../../util/test_utils.h"
#include "st_server.h"

#include "../../src/est/est_locl.h"

extern char tst_srvr_path_seg_enroll[];
extern char tst_srvr_path_seg_auth[];

static int path_segment_support;

/*
 * max command line length when generating system commands
 */
#define EST_UT_MAX_CMD_LEN 256

/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"

#define US3496_SERVER_PORT   29496
#define US3496_SERVER_IP    "127.0.0.1"	
#define US3496_UIDPWD_GOOD   "estuser:estpwd"
#define US3496_UID           "estuser"
#define US3496_PWD           "estpwd"
#ifndef WIN32
#define US3496_CACERTS	    "CA/estCA/cacert.crt"
#define US3496_TRUST_CERTS   "CA/trustedcerts.crt"
#define US3496_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else
#define US3496_CACERTS	    "CA\\estCA\\cacert.crt"
#define US3496_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US3496_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us3496_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}
#endif

#define US3496_ENROLL_URL_BA "https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll"
#define US3496_PKCS10_CT	    "Content-Type: application/pkcs10" 

#define US3496_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);

static void us3496_clean (void)
{
}

static int us3496_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US3496_SERVER_PORT, 
	          US3496_SERVER_CERTKEY,
	          US3496_SERVER_CERTKEY,
	          "US3496 test realm",
	          US3496_CACERTS,
	          US3496_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    
    SLEEP(1);
    return rv;
}

static int path_seg_supported(void) {

    EST_CTX *ectx;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);


    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, "test_segment");

    if (rc == EST_ERR_NONE) {
        return 1;
    } else {
        return 0;
    }

    return 0;
}


/*
 * This routine is called when CUnit initializes this test
 * suite. 
 * 1. Generate the keypair to be used for this EST Client UT suite
 */
static int us3496_init_suite (void)
{
    int rv = 0;
   
    char cmd[EST_UT_MAX_CMD_LEN];    
    printf("Starting EST Client/Proxy path segment unit tests.\n");

    /*
     * check to see if path segment support has been compiled in
     */
    if (!path_segment_support) {
        printf("URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \n");
        return 0;
    }
    
    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
             "openssl ecparam -name prime256v1 -genkey -out %s", CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);
    
    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us3496_clean();    
    /*
     * Start an instance of the EST server
     */
    rv = us3496_start_server(0, 0);
    SLEEP(2);
    
    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us3496_destroy_suite (void)
{
    
    st_stop();    
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}
    


/*
 * This test case tests the set server with valid parameters,
 * NO path segment
 */
static void us3496_test1 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, NULL);    
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is valid
 */
static void us3496_test2 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "somestring");
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that contains 2 segments, should fail
 */
static void us3496_test3 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "somestring1/somestring2");

    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * all valid characters
 */
#define PATH_SEG_ALL_VALID_CHARS "@%50%44%42ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-._~!$&'()*+,;="
static void us3496_test4 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                             PATH_SEG_ALL_VALID_CHARS);
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is invalid. invalid character.
 */
static void us3496_test5 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "someinvalid<string");
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is too long (129)
 */
#define path_segment_too_long "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
static void us3496_test6 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               path_segment_too_long);
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that is equal to an operation (cacerts)
 */
static void us3496_test7 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "cacerts");
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that contains an operation (cacerts),
 * in this case it's at the front of the string
 */
static void us3496_test8 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "cacerts-server");
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that is the empty string.
 * This should fail.
 */
static void us3496_test9 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "");
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that contains a ':'.
 * This should pass.
 */
static void us3496_test10 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, "-._~:@!$&'()*+,;=");    
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is too long (129)
 */
#define path_segment_max "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
static void us3496_test11 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               path_segment_max);
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us3496_add_suite (void)
{
    CU_ErrorCode CU_error;
    
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us3496_client_proxy_path_seg", 
	                  us3496_init_suite, 
			  us3496_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }
   
#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us3496_logger_stderr);
#endif

   /*
    * check to see if path segment support has been compiled in
    */
   if (!path_seg_supported()) {
       printf("URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \n");
       path_segment_support = 0;
       return 0;
   }
   path_segment_support = 1; 
   
   if (path_segment_support) {
       
       /* add the tests to the suite */
       /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
       if (
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, no path segment", us3496_test1)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, valid path segment", us3496_test2)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, multi segment path segment", us3496_test3)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, valid path segment - all valid chars", us3496_test4)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, invalid path segment", us3496_test5)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment too long", us3496_test6)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment equals operation string", us3496_test7)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment contains operation string", us3496_test8)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment is the empty string", us3496_test9)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment contains a colon", us3496_test10)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment is the max length", us3496_test11))
           ) {
           CU_error = CU_get_error();
           printf("%d\n", CU_error);
           
           CU_cleanup_registry();
           printf("%s\n", CU_get_error_msg());
           return CU_get_error();
       }
   }
   

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us897.c - Unit Tests for User Story 897 - Client CACerts 
 *
 * June, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include "../../util/test_utils.h"
#include "st_server.h"

/*
 * max command line length when generating system commands
 */
#define EST_UT_MAX_CMD_LEN 256
#define EST_CA_MAX	    200000
/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define US897_SERVER_PORT   29897
#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"
#define US897_SERVER_IP	    "127.0.0.1"	
#define US897_UID	    "estuser"
#define US897_PWD	    "estpwd"

#ifndef WIN32
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define US897_CACERTS	    "CA/estCA/cacert.crt"
#define US897_TRUST_CERTS   "CA/trustedcerts.crt"
#define US897_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS "US897/singlechain_10certs_trusted.crt"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING "US897/singlechain_9certs_missingcert.crt"
#define US897_CACERTS_SINGLE_CHAIN_EXPIRED "US897/singlechain_expired.crt"
#define US897_CACERTS_MULTI_CHAIN_CRLS "US897/trustedCHain10RevokedDepth6Implicit10andcacert.crt"
#else
#define CLIENT_UT_CACERT "CA\\estCA/cacert.crt"
#define US897_CACERTS	    "CA\\estCA\\cacert.crt"
#define US897_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US897_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS "US897\\singlechain_10certs_trusted.crt"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING "US897\\singlechain_9certs_missingcert.crt"
#define US897_CACERTS_SINGLE_CHAIN_EXPIRED "US897\\singlechain_expired.crt"
#define US897_CACERTS_MULTI_CHAIN_CRLS "US897\\trustedCHain10RevokedDepth6Implicit10andcacert.crt"
#endif 

static void us897_clean (void)
{
}

static int us897_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
	          US897_CACERTS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    
    SLEEP(1);
    return rv;
}


/*
 * This routine is called when CUnit initializes this test
 * suite. 
 * 1. Generate the keypair to be used for this EST Client UT suite
 */
static int us897_init_suite (void)
{
    int rv = 0;
    
    char cmd[EST_UT_MAX_CMD_LEN];    
    printf("Starting EST Client unit tests. PDB\n");

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
             "openssl ecparam -name prime256v1 -genkey -out %s", CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);
    
    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us897_clean();    
    /*
     * Start an instance of the EST server
     */
    rv = us897_start_server(0, 0);
    SLEEP(2);
    
    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us897_destroy_suite (void)
{
    
    st_stop();    
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}
    

/*
 * This test case initializes an EST client context
 * using local CA certs, no client cert, and a valid public key,
 * no userid and password.
 */
static void us897_test1 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;
    
    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    est_init_logger(EST_LOG_LVL_INFO, NULL);    
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
                             
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }    
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case initializes an EST client context
 * using no local CA certs.  This is expected to be a successful initialization
 * since the local CA trust anchor certs are not mandatory.
 */
static void us897_test2 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    ectx = est_client_init(NULL, 0, EST_CERT_FORMAT_PEM, client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    if (ectx) {
        est_destroy(ectx);
    }    
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case initializes an EST client context
 * using a local CA cert, no client cert,
 * and a valid public key, no userid and password.
 */
static void us897_test3 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

#if 0
/*
 * This test case initializes an EST client context
 * using explict CA certs, no client cert, and a valid public key,
 * no userid and password.
 */
static void us897_test3 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}
#endif


/*
 * This test case initializes an EST client context
 * using explict CA certs, no client cert, a public key,
 * and a userid and password.
 */
static void us897_test6 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "USER", "PASSWORD", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    if (ectx) {
        est_destroy(ectx);
    }    
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case initializes an EST client context
 * using explict CA certs, no client cert, a public key,
 * and a userid and NO password.
 */
static void us897_test7 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "USER", NULL, NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);

    if (ectx) {
        est_destroy(ectx);
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, NULL, "PASSWORD", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
    
    if (ectx) {
        est_destroy(ectx);
    }    
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the set server with valid parameters
 */
static void us897_test9 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);    
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the set server with invalid parameters
 */
static void us897_test10 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    char *server_name_too_long = "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890123456";
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    /*
     * Null server name
     */
    rc = est_client_set_server(ectx, NULL, US897_SERVER_PORT, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * server too long
     */
    rc = est_client_set_server(ectx, server_name_too_long, US897_SERVER_PORT, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     *  port num less than 0
     */
    rc = est_client_set_server(ectx, US897_SERVER_IP, -1, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);

    /*
     * port num greater than max
     */
    rc = est_client_set_server(ectx, US897_SERVER_IP, 65536, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the Get CACerts request
 *
 */
static void us897_test11 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);
    
    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);

    /*
     * make sure that the context is no longer valid and the EST client is
     * back to the uninitialized state
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    CU_ASSERT(rc == EST_ERR_CLIENT_NOT_INITIALIZED);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the Get CACerts request with invalid input parameters
 *
 */
static void us897_test12 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, NULL);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single certificate
 */
static void us897_test13 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
	          US897_CACERTS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);
    
    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single chain with multiple certs
 */
static void us897_test14 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);
    
    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single chain with multiple certs and
 * a missing cert in the chain.  
 */
static void us897_test15 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);
    CU_ASSERT(retrieved_cacerts_len == 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single chain with multiple certs 
 * with the intermediate cert expired.
 */
static void us897_test16 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_SINGLE_CHAIN_EXPIRED,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);
    CU_ASSERT(retrieved_cacerts_len == 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a multiple chains with multiple certs and
 * a CRL block.  The CRLs should be ignored.  
 */
static void us897_test17 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_MULTI_CHAIN_CRLS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in the startup CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NONE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the SSL read set timeout API.
 * The setting of the min, the max, a value in between, and a value
 * beyond the max.
 */
static void us897_test18 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    
  
    /*
     * Read in the startup CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);

    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MIN);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX+1);
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
    rc = est_client_set_read_timeout(ectx, 2);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Now proceed on with a GET /cacerts to verify that nothing gets broken */
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NONE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us897_add_suite (void)
{
    CU_ErrorCode CU_error;
    
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us897_client_cacerts", 
	                  us897_init_suite, 
			  us897_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* add the tests to the suite */
   /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
   if ((NULL == CU_add_test(pSuite, "EST Client Init: local CA, private key ", us897_test1))  ||
       (NULL == CU_add_test(pSuite, "EST Client Init: no local CA", us897_test2)) ||
       (NULL == CU_add_test(pSuite, "EST Client Init: local CA, explicit CA, private key", us897_test3)) ||
/*        (NULL == CU_add_test(pSuite, "EST Client Init: local CA, explicit CA, client CA, private key", us897_test4)) || */
       (NULL == CU_add_test(pSuite, "EST Client Init: local CA, userid/password", us897_test6)) ||
       (NULL == CU_add_test(pSuite, "EST Client Init: local CA, userid/no password", us897_test7)) ||
/*        (NULL == CU_add_test(pSuite, "EST Client Init: local CA, no userid/password", us897_test8)) || */
       (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters", us897_test9)) ||
       (NULL == CU_add_test(pSuite, "EST Client Set Server: no parameters", us897_test10)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: ca_cert valid parameters", us897_test11)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: missing ca_cert pointers", us897_test12)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-simple chain-success", us897_test13)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-multiple certs-success", us897_test14)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-broken chain-fail", us897_test15)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-bad date-fail", us897_test16)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-multiple chains-success", us897_test17)) ||
       (NULL == CU_add_test(pSuite, "EST Client SSL read timeout API", us897_test18))
       ) 
   {
      CU_error = CU_get_error();
      printf("%d\n", CU_error);
   
      CU_cleanup_registry();
      printf("%s\n", CU_get_error_msg());
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us1060.c - Unit Tests for User Story 1060 - TLS SRP support (Server/Proxy)
 *
 * May, 2014
 *
 * Copyright (c) 2014-2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#include <string.h>
#ifndef WIN32
#include <unistd.h>
#include <pthread.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "test_utils.h"
#include "curl_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US1060_SERVER_PORT      31060
#define US1060_SERVER_IP        "127.0.0.1"
#define US1060_UID              "estuser"
#define US1060_PWD              "estpwd"
#ifndef WIN32
#define US1060_CACERTS          "CA/estCA/cacert.crt"
#define US1060_TRUST_CERTS      "CA/trustedcerts.crt"
#define US1060_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US1060_VFILE            "US1060/passwd.srpv"

#define US1060_EXPLICIT_CERT    "US1060/explicit-cert.pem" 
#define US1060_EXPLICIT_KEY     "US1060/explicit-key.pem"
#define US1060_SELFSIGN_CERT    "US1060/selfsigned-cert.pem" 
#define US1060_SELFSIGN_KEY     "US1060/selfsigned-key.pem"
#else
#define US1060_CACERTS          "CA\\estCA\\cacert.crt"
#define US1060_TRUST_CERTS      "CA\\trustedcerts.crt"
#define US1060_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"
#define US1060_VFILE            "US1060\\passwd.srpv"

#define US1060_EXPLICIT_CERT    "US1060\\explicit-cert.pem" 
#define US1060_EXPLICIT_KEY     "US1060\\explicit-key.pem"
#define US1060_SELFSIGN_CERT    "US1060\\selfsigned-cert.pem" 
#define US1060_SELFSIGN_KEY     "US1060\\selfsigned-key.pem"
#endif

#define US1060_ENROLL_URL       "https://127.0.0.1:31060/.well-known/est/simpleenroll"
#define US1060_UIDPWD_GOOD      "estuser:estpwd"
#define US1060_UIDPWD_BAD       "estuser:xxx111222"
#define US1060_PKCS10_CT        "Content-Type: application/pkcs10"

#define US1060_PROXY_ENROLL_URL "https://127.0.0.1:41060/.well-known/est/simpleenroll"
#define US1060_PROXY_PORT       41060

#define US1060_PKCS10_REQ       "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"

static char *log_search_target = NULL;
static int search_target_found = 0;
static unsigned char *cacerts = NULL;
static int cacerts_len = 0;
static SRP_VBASE *srpdb = NULL;

#ifdef WIN32
CRITICAL_SECTION logger_critical_section;
#endif

/*
 * This is a simple callback used to override the default
 * logging facility in libest.  We'll use this to look
 * for specific debug output.
 */
static void us1060_logger_stderr (char *format, va_list l)
{
    char t_log[1024];
#ifndef WIN32
    flockfile(stderr);
#else
    EnterCriticalSection(&logger_critical_section);
#endif 
    if (log_search_target) {
        vsnprintf(t_log, 1024, format, l);
        if (strstr(t_log, log_search_target)) {
            search_target_found = 1;
        }
        fprintf(stderr, "%s", t_log);
    } else {
        vfprintf(stderr, format, l);
    }
    fflush(stderr);
#ifndef WIN32
    funlockfile(stderr);
#else
    LeaveCriticalSection(&logger_critical_section);
#endif
}

static int us1060_start_server (char *cert, char *key, int no_http_auth,
                                int enable_pop, int enable_srp)
{
    int rv;

    if (enable_srp) {
        rv = st_start_srp(US1060_SERVER_PORT,
                          cert,
                          key,
                          "US1060 test realm",
                          US1060_CACERTS,
                          US1060_TRUST_CERTS,
                          "CA/estExampleCA.cnf",
                          enable_pop,
                          US1060_VFILE);
    } else {
        rv = st_start(US1060_SERVER_PORT,
                      cert,
                      key,
                      "US1060 test realm",
                      US1060_CACERTS,
                      US1060_TRUST_CERTS,
                      "CA/estExampleCA.cnf",
                      0,
                      enable_pop,
                      0);
    }

    if (no_http_auth) {
        st_disable_http_auth();
    }

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1060_init_suite (void)
{
    int rv;

#ifdef WIN32
    /* Initialize critical section on Windows*/
    InitializeCriticalSection(&logger_critical_section);
#endif

    est_init_logger(EST_LOG_LVL_INFO, &us1060_logger_stderr);

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,
        1);

    /*
     * Start an instance of the proxy with SRP enabled
     */
    rv = st_proxy_start_srp(US1060_PROXY_PORT,
                            US1060_SERVER_CERTKEY,
                            US1060_SERVER_CERTKEY,
                            "US1060 proxy realm",
                            US1060_CACERTS,
                            US1060_TRUST_CERTS,
                            US1060_UID,
                            US1060_PWD,
                            US1060_SERVER_IP,
                            US1060_SERVER_PORT,
                            0,
                            US1060_VFILE);

    /*
     * Read in the CA certificates
     * Used for client-side API testing
     */
    cacerts_len = read_binary_file(US1060_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    srpdb = SRP_VBASE_new(NULL);
    if (!srpdb) {
        printf("\nUnable allocate SRP verifier database.  Aborting!!!\n");
    }
    if (SRP_VBASE_init(srpdb, US1060_VFILE) != SRP_NO_ERROR) {
        printf("\nUnable initialize SRP verifier database.  Aborting!!!\n");
    }

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1060_destroy_suite (void)
{
    if (srpdb) {
        SRP_VBASE_free(srpdb);
    }

    st_stop();
    st_proxy_stop();
    free(cacerts);
    return 0;
}

typedef enum {
    SRP_OFF, SRP_ON
} server_srp_mode;

typedef enum {
    SRP_GOOD, SRP_BAD, SRP_NONE,
} client_srp_mode;

typedef enum {
    HTTP_OFF, HTTP_OPTIONAL, HTTP_REQUIRED
} server_http_mode;

typedef struct {
    char *test_name;
    char *curl_cert;
    char *curl_key;
    char *curl_http_auth;
    client_srp_mode curl_srp;
    server_http_mode server_http;
    server_srp_mode server_srp;
    int expected_http_result;
} us1060_matrix;

/*
 * This is the unit test matrix for server-side SRP support.  Curl is
 * used as the EST client.  Because of this PoP is disabled on the
 * server for all test cases.  We try to cover a variety of configurations
 * and potential scenarios.  The client side variations include:
 *
 * curl_cert:  The certificate curl uses, which may be NULL
 * curl_key:   The key curl uses, which may be NULL
 * curl_http_auth:  The HTTP auth credentials used by curl.
 * client_srp_mode: Either GOOD, BAD, NONE.  Determines which SRP credentials are used
 *                  Curl.
 *
 * On the server side we configure the server using the following variations:
 *
 * server_http_mode:  HTTP auth is required, optional, or disabled.
 *                    (optional means it only occurs when TLS auth fails)
 * server_srp_mode:   SRP is either enabled or disabled on the server.
 *
 * expected_http_result:  This is the expected HTTP status code received on by Curl.
 *                        When SRP fails, this results in a failed TLS session.  Curl
 *                        returns a zero in this case since the HTTP layer can not
 *                        communicate.  If TLS succeeds, but HTTP auth fails, then
 *                        the server should return a HTTP 401 response to the client.
 *                        When enrollment succeeds, the server should send a
 *                        HTTP 200 response.
 *
 *
 */
static us1060_matrix test_matrix[] = {
    {"1", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 200},
    {"2", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},
    {"3", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 200},
    {"4", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},
    {"5", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},
    {"6", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 200},
    {"7", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},
    {"8", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},
    {"9", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},

    {"11", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 401},
    {"12", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},
    {"13", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 401},
    {"14", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},
    {"15", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},
    {"16", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 401},
    {"17", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},
    {"18", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},
    {"19", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},

    {"21", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},
    {"22", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},
    {"23", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},
    {"24", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},
    {"25", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},
    {"26", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},
    {"27", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},
    {"28", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},
    {"29", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},

    {"31", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},
    {"32", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},
    {"33", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},
    {"34", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},
    {"35", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},
    {"36", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 401},
    {"37", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},
    {"38", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},
    {"39", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},

    {"40", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  200},
    {"41", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  401},
    {"42", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},
    {"43", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},
    {"44", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  200},
    {"45", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  200},
    {"46", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},
    {"47", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},
    {"48", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},
    {"49", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},
    {"50", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 200},
    {"51", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 200},

    {"60", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},
    {"61", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},
    {"62", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},
    {"63", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},
    {"64", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  0},
    {"65", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  0},
    {"66", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},
    {"67", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},
    {"68", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},
    {"69", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},
    {"70", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 0},
    {"71", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 0},
};

/*
 * This is our worker for each entry in the test matrix above.
 * We read the configuration from the entry, configure the
 * server and client as needed, and attempt a simple enroll
 * using Curl as the client.
 * The argument i is the index of the entry in the table above.
 */
static void us1060_test_matrix_item (int i)
{
    long rv;

    LOG_FUNC_NM
    ;

    printf("\nRunning matrix test %s\n", test_matrix[i].test_name);

    /*
     * Stop the server and restart it to make sure
     * it's in the correct mode.
     */
    st_stop();
    SLEEP(1);
    if (test_matrix[i].server_srp == SRP_ON) {
        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,
            0, 0, 1);
    } else {
        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,
            0, 0, 0);
    }
    CU_ASSERT(rv == 0);

    /*
     * Set the server HTTP auth configuration
     */
    switch (test_matrix[i].server_http) {
    case HTTP_OFF:
        st_disable_http_auth();
        break;
    case HTTP_OPTIONAL:
        st_enable_http_auth();
        st_set_http_auth_optional();
        break;
    case HTTP_REQUIRED:
        st_enable_http_auth();
        st_set_http_auth_required();
        break;
    }

    switch (test_matrix[i].curl_srp) {
    case SRP_GOOD:
        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,
        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,
            NULL, "srp_user", "srp_pwd", NULL, NULL);
        break;
    case SRP_BAD:
        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,
        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,
            NULL, "srp_user", "boguspwd", NULL, NULL);
        break;
    case SRP_NONE:
        /*
         * Some of the SRP disabled test cases use a client
         * certificate.
         */
        if (test_matrix[i].curl_cert) {
            rv = curl_http_post_certuid(US1060_ENROLL_URL, US1060_PKCS10_CT,
            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,
                test_matrix[i].curl_cert, test_matrix[i].curl_key,
                US1060_CACERTS, NULL);
        } else {
            rv = curl_http_post(US1060_ENROLL_URL, US1060_PKCS10_CT,
            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,
            US1060_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
        }
        break;
    }
    CU_ASSERT(rv == test_matrix[i].expected_http_result);
    if (rv != test_matrix[i].expected_http_result) {
        printf("\nMatrix test %s failed with rv = %d\n",
            test_matrix[i].test_name, (int) rv);
    }
}

/*
 * This test case runs all the tests in the matrix
 */
static void us1060_test0 (void)
{
    int i;
    int test_cnt = sizeof(test_matrix) / sizeof(test_matrix[0]);

    for (i = 0; i < test_cnt; i++) {
        us1060_test_matrix_item(i);
    }
}

/*
 * This test case is verifies the happy path when EST
 * proxy is configured in SRP mode.  The client will attempt
 * to use SRP.  The connection between the proxy and
 * server does not use SRP.  We perform a simple enroll
 * operation.
 */
static void us1060_test200 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Restart the EST server with SRP disabled
     */
    st_stop();
    SLEEP(2);
    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,
        0);
    CU_ASSERT(rv == 0);

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ,
    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, "srp_user", "srp_pwd", NULL,
        NULL);
    /*
     * Since we passed in a valid SRP userID/password,
     * we expect the server to respond with success
     */
    CU_ASSERT(rv == 200);
}

/*
 * This test case is verifies the simple enroll fails
 * when the EST client provides a bad SRP password.
 * The connection between the proxy and server does not
 * use SRP.
 */
static void us1060_test201 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ,
    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, "srp_user", "boguspwd",
        NULL, NULL);
    CU_ASSERT(rv == 0);
}

/*
 * This test case is verifies the simple enroll fails
 * when the EST client provides a bad HTTP password
 * and SRP is used.  The connection between the proxy
 * and server does not use SRP.
 */
static void us1060_test202 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ,
    US1060_UIDPWD_BAD, NULL, CURLAUTH_BASIC, NULL, "srp_user", "srp_pwd", NULL,
        NULL);
    CU_ASSERT(rv == 401);
}

/*
 * This test case is verifies the simple enroll works
 * when the EST client provides no HTTP password
 * and SRP is used.  The connection between the proxy
 * and server does not use SRP.  HTTP auth is disabled
 * on the proxy.
 */
static void us1060_test203 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_http_disable(1);

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ, NULL, NULL, CURLAUTH_NONE, NULL, "srp_user", "srp_pwd",
        NULL, NULL);
    CU_ASSERT(rv == 200);
}

int us1060_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1060_tls_srp (server/proxy)",
            us1060_init_suite,
            us1060_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /*
     * Add the tests to the suite
     *
     * ********************IMPORTANT*********************
     * Do not change the order of these tests.
     * Some of the tests stop the EST server and restart
     * it using different certs.  If you change the order
     * then false negatives may occur.
     * **************************************************
     *
     */
    if ((NULL == CU_add_test(pSuite, "TLS-SRP server: matrix master", us1060_test0)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll w/SRP", us1060_test200)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll bad SRP pwd", us1060_test201)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll bad HTTP pwd", us1060_test202)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll w/o HTTP auth", us1060_test203)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us893.c - Unit Tests for User Story 893 - proxy reenroll
 *
 * October, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US893_TCP_SERVER_PORT       29893
#define US893_TCP_PROXY_PORT        29093

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US893_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

#define US893_PKCS10_CORRUPT "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDfffmdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

#define US893_SERVER_IP         "127.0.0.1" 
#define US893_REENROLL_URL_BA   "https://127.0.0.1:29093/.well-known/est/simplereenroll"
#define US893_PKCS10_CT         "Content-Type: application/pkcs10" 
#define US893_UIDPWD_GOOD       "estuser:estpwd"
#define US893_UID               "estuser"
#define US893_PWD               "estpwd"
#ifndef WIN32
#define US893_CACERTS           "CA/estCA/cacert.crt"
#define US893_TRUSTED_CERTS     "CA/trustedcerts.crt"
#define US893_SERVER_CERTKEY    "CA/estCA/private/estservercertandkey.pem"
#define US893_PROXY_CERT        "US893/cert.pem"
#define US893_PROXY_KEY         "US893/key.pem"
#define US893_UNTRUSTED_CERT    "US893/cert-untrusted.pem"
#define US893_UNTRUSTED_KEY     "US893/key-untrusted.pem"
#define US893_EXPIRED_KEY       "US893/key-expired.pem"
#define US893_EXPIRED_CERT      "US893/cert-expired.pem"

#define US893_TC2_CERT_TXT      "US893/tc2-new-cert.txt"
#define US893_TC2_CERT_B64      "US893/tc2-new-cert.pkcs7b64"
#define US893_TC2_CERT_PK7      "US893/tc2-new-cert.pkcs7"
#define US893_TC2_CERT_PEM      "US893/tc2-new-cert.pem"
#else
#define US893_CACERTS           "CA\\estCA\\cacert.crt"
#define US893_TRUSTED_CERTS     "CA\\trustedcerts.crt"
#define US893_SERVER_CERTKEY    "CA\\estCA\\private\\estservercertandkey.pem"
#define US893_PROXY_CERT        "US893\\cert.pem"
#define US893_PROXY_KEY         "US893\\key.pem"
#define US893_UNTRUSTED_CERT    "US893\\cert-untrusted.pem"
#define US893_UNTRUSTED_KEY     "US893\\key-untrusted.pem"
#define US893_EXPIRED_KEY       "US893\\key-expired.pem"
#define US893_EXPIRED_CERT      "US893\\cert-expired.pem"

#define US893_TC2_CERT_TXT      "US893\\tc2-new-cert.txt"
#define US893_TC2_CERT_B64      "US893\\tc2-new-cert.pkcs7b64"
#define US893_TC2_CERT_PK7      "US893\\tc2-new-cert.pkcs7"
#define US893_TC2_CERT_PEM      "US893\\tc2-new-cert.pem"
#endif

static void us893_clean (void)
{
    char cmd[200];

    /*
     * These are all temporary files created
     * by the various test cases.
     */
#ifndef WIN32
    sprintf(cmd, "rm %s", US893_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "rm %s", US893_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "rm %s", US893_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "rm %s", US893_TC2_CERT_PEM);
    system(cmd);
#else
    sprintf(cmd, "del %s", US893_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "del %s", US893_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "del %s", US893_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "del %s", US893_TC2_CERT_PEM);
    system(cmd);
#endif
}

static int us893_start_server (int manual_enroll, int nid)
{
    int rv;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US893_TCP_SERVER_PORT,
                  US893_SERVER_CERTKEY,
                  US893_SERVER_CERTKEY,
                  "US893 test realm",
                  US893_CACERTS,
                  US893_TRUSTED_CERTS,
                  "US893/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy actging as an RA
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us893_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US893_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us893_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us893_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us893_destory_suite (void)
{
    st_stop();
    st_proxy_stop();
    free(cacerts);
    return 0;
}

/*
 * Simple reenroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * reenroll of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us893_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
    US893_PKCS10_RSA2048,
    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  The expired certs contains
 * several X509 extensions. We verify the new issued
 * cert preserves these extensions using grep.  Note,
 * preserving these extensions requires the OpenSSL CA
 * to enable the "copy_extensions" knob in the OpenSSL
 * config file.  This is why this test suite uses a
 * unique copy of estExampleCA.cnf.
 */
static void us893_test2 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    X509 *cert = NULL;
    BIO *in;
    char cmd[200];
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Save the cert to a local file
     */
    rv = write_binary_file(US893_TC2_CERT_B64, new_cert, pkcs7_len);
    CU_ASSERT(rv == 1);

    /*
     * Base 64 decode the cert response
     */
    sprintf(cmd, "openssl base64 -d -in %s -out %s", US893_TC2_CERT_B64,
    US893_TC2_CERT_PK7);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert the pkcs7 cert to a PEM cert
     */
    sprintf(cmd, "openssl pkcs7 -in %s -inform DER -print_certs -out %s",
    US893_TC2_CERT_PK7,
    US893_TC2_CERT_PEM);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert PEM cert to a textual representation of the cert
     */
    sprintf(cmd, "openssl x509 -text -in %s > %s", US893_TC2_CERT_PEM,
    US893_TC2_CERT_TXT);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Verify the jimbob DNS extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "jimbob");
    CU_ASSERT(rv == 0);

    /*
     * Verify the bobcat DNS extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "bobcat");
    CU_ASSERT(rv == 0);

    /*
     * Verify the IP address extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "172");
    CU_ASSERT(rv == 0);

    /*
     * Verify the Repudiation key usage extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "Repudiation");
    CU_ASSERT(rv == 0);

    /*
     * Verify the public key was preserved
     */
    rv = grep(US893_TC2_CERT_TXT,
        "00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50");
    CU_ASSERT(rv == 0);

    /*
     * Clean up
     */
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * Simple reenroll - Corrupt CSR
 *
 * Use libcurl to send a reenroll request containing
 * a corrupted CSR.
 */
static void us893_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
    US893_PKCS10_CORRUPT,
    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a bad CSR,
     * we expect the server to respond with 400
     */
    CU_ASSERT(rv == 400);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured for manual
 * approval.  The server will send back a retry-after
 * response.  This verifies the proxy propagates the
 * retry-after response to the client.
 */
static void us893_test4 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    int retry_val = 0;
    time_t time_val;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Stop the server.
     */
    st_stop();
    st_proxy_stop();

    /*
     * Restart the server with manual approval enabled
     */
    rv = us893_start_server(1, 0);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);

    /*
     * The server should be configured with a retry-after
     * value of 3600 seconds, which is the default.
     */
    rv = est_client_copy_retry_after(ectx, &retry_val, &time_val);
    CU_ASSERT(rv == EST_ERR_NONE);
    CU_ASSERT(retry_val == 3600);

    /*
     * Clean up
     */
    est_destroy(ectx);

    /*
     * Stop the server.
     */
    st_stop();
    st_proxy_stop();

    /*
     * Restart the server with manual approval disabled
     */
    rv = us893_start_server(0, 0);
    CU_ASSERT(rv == 0);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured with PoP
 * enabled, but the proxy server is using a cert
 * that doesn't contain id-kp-cmcRA.  This should
 * result in a failure.
 */
static void us893_test5 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is enabled on the server
     */
    st_enable_pop();

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_SERVER_CERTKEY,
                        US893_SERVER_CERTKEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Use libcurl to send an enroll request.  We use libcurl
     * because it will not include the PoP.
     */
    rv = curl_http_post(US893_REENROLL_URL_BA,
                        US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD,
                        US893_CACERTS,
                        CURLAUTH_BASIC,
                        NULL,
                        NULL,
                        NULL);
    /*
     * The PoP check should fail
     */
    CU_ASSERT(rv == 400);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser", "estpwd", "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured with PoP
 * disabled, but the proxy server is using a cert
 * that doesn't contain id-kp-cmcRA.  This should
 * result in a successful reenroll.
 */
static void us893_test6 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_SERVER_CERTKEY,
                        US893_SERVER_CERTKEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Use libcurl to send an enroll request.  We use libcurl
     * because it will not include the PoP.
     */
    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
    US893_PKCS10_RSA2048,
    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * The reenroll should work since PoP is not enabled anywhere.
     */
    CU_ASSERT(rv == 200);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured with PoP
 * disabled, but the proxy server is using a cert
 * that doesn't contain id-kp-cmcRA.  The CSR will
 * contain the PoP, which forces it to be checked.
 * This should result in a failure since the RA
 * cert doesn't contain id-kp-cmcRA.
 */
//The following include should never be used by an application
//be we use it here to hack the EST_CTX values mid-way
//through this test
#include "../../src/est/est_locl.h"
static void us893_test7 (void)
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_SERVER_CERTKEY,
                        US893_SERVER_CERTKEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    ectx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
    //We need to force the challengePassword into the CSR
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();

    est_destroy(ectx);
}

/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  PoP is disabled on
 * the EST server.
 */
static void us893_test8 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    X509 *cert = NULL;
    int rv;
    int pkcs7_len = 0;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_destroy(ectx);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();
}

/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  PoP is disabled on
 * the EST server.  The CSR does not contain a PoP.
 */
static void us893_test9 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Use libcurl to send an enroll request.  We use libcurl
     * because it will not include the PoP.
     */
    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * The reenroll should work since PoP is not enabled anywhere.
     */
    CU_ASSERT(rv == 200);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();
}

/*
 * This test case uses a bad password configured on
 * the EST proxy context.  This should cause the EST
 * server to reject the reenroll request.
 */
static void us893_test10 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "bogus",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    CU_ASSERT(rv == 401);


    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);
}

static void us893_test11 (void)
{
    int rv;
    long http_code = 0;
    CURL *hnd;
    struct curl_slist *slist1;

    LOG_FUNC_NM
    ;

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using an untrusted cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_UNTRUSTED_CERT,
                        US893_UNTRUSTED_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * We don't use the normal curl util API here because
     * we need to disable TLS peer verification for this
     * special test case.
     */
    /*
     * Set the Content-Type header in the HTTP request
     */
    slist1 = NULL;
    slist1 = curl_slist_append(slist1, US893_PKCS10_CT);

    /*
     * Setup all the other fields that CURL requires
     */
    hnd = curl_easy_init();
    curl_easy_setopt(hnd, CURLOPT_URL, US893_REENROLL_URL_BA);
    curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
    curl_easy_setopt(hnd, CURLOPT_USERPWD, US893_UIDPWD_GOOD);
    curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, US893_PKCS10_RSA2048);
    curl_easy_setopt(hnd, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)strlen(US893_PKCS10_RSA2048));
    curl_easy_setopt(hnd, CURLOPT_USERAGENT, "curl/7.27.0");
    curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
    curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
    curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);
    curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
    curl_easy_setopt(hnd, CURLOPT_CAINFO, US893_CACERTS);
    curl_easy_setopt(hnd, CURLOPT_VERBOSE, 1L);
    curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);
    curl_easy_setopt(hnd, CURLOPT_FORBID_REUSE, 1L);

    /*
     * Issue the HTTP request
     */
    curl_easy_perform(hnd);

    /*
     * Get the HTTP reponse status code from the server
     */
    curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &http_code);
    curl_easy_cleanup(hnd);
    hnd = NULL;
    curl_slist_free_all(slist1);
    slist1 = NULL;

    CU_ASSERT(http_code == 400);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);
}

/*
 * Simple reenroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * reenroll of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.  However, PoP is now
 * enabled on the proxy, which should cause a
 * failure since libcurl doesn't include the PoP.
 */
static void us893_test12 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_enable_pop();

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Should fail since the proxy will fail the PoP check
     */
    CU_ASSERT(rv == 400);

    st_proxy_disable_pop();
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us893_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us893_proxy_simpreenroll",
                           us893_init_suite,
                           us893_destory_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "ReEnroll RSA cert", us893_test1)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert", us893_test2)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll corrupt CSR", us893_test3)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert with retry-after", us893_test4)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll no proxy id-kp-cmcRA with srv PoP", us893_test5)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll no proxy id-kp-cmcRA w/o srv PoP", us893_test6)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll no proxy id-kp-cmcRA w/o srv PoP CSR PoP", us893_test7)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert w/o srv PoP CSR PoP", us893_test8)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert w/o srv PoP no CSR PoP", us893_test9)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll proxy misconfigured HTTP auth", us893_test10)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll proxy untrusted identity cert", us893_test11)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll PoP enabled proxy no CSR PoP", us893_test12)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us899.c - Unit Tests for User Story 899 - Client simple enroll 
 *
 * September, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US899_SERVER_PORT   29899
#define US899_SERVER_IP	    "127.0.0.1"	
#define US899_UID	    "estuser"
#define US899_PWD	    "estpwd"

/*
 * The following certs are used for FQDN testing
 */
#ifndef WIN32
#define US899_CACERTS	    "CA/estCA/cacert.crt"
#define US899_TRUST_CERTS   "CA/trustedcerts.crt"
#define US899_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"

#define US899_SERVER_CERT_CN_MISMATCH	    "US899/cert_cn_mismatch.pem"
#define US899_SERVER_KEY_CN_MISMATCH	    "US899/key_cn_mismatch.pem"
#define US899_SERVER_CERT_CN_MISMATCH_IP    "US899/cert_cn_mismatch_ip.pem"
#define US899_SERVER_KEY_CN_MISMATCH_IP	    "US899/key_cn_mismatch_ip.pem"
#define US899_SERVER_CERT_CN_MATCH_WC       "US899/cert_cn_match_wc.pem"
#define US899_SERVER_KEY_CN_MATCH_WC	    "US899/key_cn_match_wc.pem"
#define US899_SERVER_CERT_CN_MISMATCH_WC    "US899/cert_cn_mismatch_wc.pem"
#define US899_SERVER_KEY_CN_MISMATCH_WC	    "US899/key_cn_mismatch_wc.pem"
#define US899_SERVER_CERT_SAN_MATCH	    "US899/cert_san_match.pem"
#define US899_SERVER_KEY_SAN_MATCH	    "US899/key_san_match.pem"
#define US899_SERVER_CERT_SAN_MISMATCH	    "US899/cert_san_mismatch.pem"
#define US899_SERVER_KEY_SAN_MISMATCH	    "US899/key_san_mismatch.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_IP   "US899/cert_san_mismatch_ip.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_IP    "US899/key_san_mismatch_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_IP      "US899/cert_san_match_ip.pem"
#define US899_SERVER_KEY_SAN_MATCH_IP       "US899/key_san_match_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_WC      "US899/cert_san_match_wc.pem"
#define US899_SERVER_KEY_SAN_MATCH_WC       "US899/key_san_match_wc.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_WC   "US899/cert_san_mismatch_wc.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_WC    "US899/key_san_mismatch_wc.pem"
#else 
#define US899_CACERTS	    "CA\\estCA\\cacert.crt"
#define US899_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US899_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"

#define US899_SERVER_CERT_CN_MISMATCH	    "US899\\cert_cn_mismatch.pem"
#define US899_SERVER_KEY_CN_MISMATCH	    "US899\\key_cn_mismatch.pem"
#define US899_SERVER_CERT_CN_MISMATCH_IP    "US899\\cert_cn_mismatch_ip.pem"
#define US899_SERVER_KEY_CN_MISMATCH_IP	    "US899\\key_cn_mismatch_ip.pem"
#define US899_SERVER_CERT_CN_MATCH_WC       "US899\\cert_cn_match_wc.pem"
#define US899_SERVER_KEY_CN_MATCH_WC	    "US899\\key_cn_match_wc.pem"
#define US899_SERVER_CERT_CN_MISMATCH_WC    "US899\\cert_cn_mismatch_wc.pem"
#define US899_SERVER_KEY_CN_MISMATCH_WC	    "US899\\key_cn_mismatch_wc.pem"
#define US899_SERVER_CERT_SAN_MATCH	    "US899\\cert_san_match.pem"
#define US899_SERVER_KEY_SAN_MATCH	    "US899\\key_san_match.pem"
#define US899_SERVER_CERT_SAN_MISMATCH	    "US899\\cert_san_mismatch.pem"
#define US899_SERVER_KEY_SAN_MISMATCH	    "US899\\key_san_mismatch.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_IP   "US899\\cert_san_mismatch_ip.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_IP    "US899\\key_san_mismatch_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_IP      "US899\\cert_san_match_ip.pem"
#define US899_SERVER_KEY_SAN_MATCH_IP       "US899\\key_san_match_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_WC      "US899\\cert_san_match_wc.pem"
#define US899_SERVER_KEY_SAN_MATCH_WC       "US899\\key_san_match_wc.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_WC   "US899\\cert_san_mismatch_wc.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_WC    "US899\\key_san_mismatch_wc.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us899_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}
#endif 



#define US899_VALID_CSR_PEM "-----BEGIN CERTIFICATE REQUEST-----\nMIIBhDCB7gIBADBFMQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEh\nMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEB\nAQUAA4GNADCBiQKBgQC13wEG36vBY8Mq+uu80SKvkx0ZCt0lc18kaMSDLwML2IRS\n+SaCLEZbjJYeSxwZ9qXy4Rt1vFDRRTL57/lQTgT5kzKI2D2YUZ+Dg6wQqx/4t99S\naCv/lxcUTfIPiaqATUQxeZA+h7Fo0ti9wLSw6AQft9hibYPRJZ6zHa24lXwd7wID\nAQABoAAwDQYJKoZIhvcNAQEFBQADgYEAjwSjLqFAzoPGa4GKn7AEitepVA+3QjXL\n45LSzrVJMW4Jl8Ovm/aPatnFRQYm82rVKb7Sq4Ddo9nDJ9tgZ450oqIWbujUmGEU\nsUUxJSJ3vGXyQy+8NeTy4GmmsNWIwhSKMkqh7YVlBvgkwGoNFuQ8mD90prFmld+J\nhHBZXCaekrE=\n-----END CERTIFICATE REQUEST-----"


/*
 * Note: this array was generated using:  xdd -i req.der req.c
 */
static unsigned char US899_VALID_CSR_DER[] = {
  0x30, 0x82, 0x01, 0xa8, 0x30, 0x82, 0x01, 0x11, 0x02, 0x01, 0x00, 0x30,
  0x68, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
  0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,
  0x02, 0x6e, 0x63, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x07,
  0x0c, 0x03, 0x73, 0x73, 0x73, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55,
  0x04, 0x0a, 0x0c, 0x03, 0x64, 0x64, 0x64, 0x31, 0x0d, 0x30, 0x0b, 0x06,
  0x03, 0x55, 0x04, 0x0b, 0x0c, 0x04, 0x66, 0x6a, 0x6a, 0x64, 0x31, 0x0c,
  0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x03, 0x31, 0x32, 0x37,
  0x31, 0x13, 0x30, 0x11, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
  0x01, 0x09, 0x01, 0x16, 0x04, 0x6e, 0x6f, 0x6e, 0x65, 0x30, 0x81, 0x9f,
  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81,
  0x81, 0x00, 0xb9, 0x9f, 0xdd, 0xd0, 0xa4, 0xdf, 0x06, 0x50, 0xf5, 0x4e,
  0x85, 0x80, 0xeb, 0x2a, 0x1e, 0xff, 0x3c, 0x0f, 0x0d, 0x98, 0x6e, 0xfe,
  0x08, 0x74, 0xf4, 0xce, 0xf5, 0xfd, 0xf9, 0x2f, 0x86, 0x20, 0xf7, 0xcc,
  0x08, 0x05, 0xce, 0x98, 0x69, 0x5c, 0x8c, 0xbd, 0x20, 0xa7, 0x28, 0xf7,
  0xe4, 0x22, 0xfa, 0xaf, 0xe4, 0x15, 0xc4, 0xb9, 0x85, 0xcb, 0x0f, 0x11,
  0xc6, 0x55, 0x0d, 0x31, 0x5c, 0xfb, 0x5e, 0xcf, 0x8e, 0xd1, 0xde, 0x77,
  0x15, 0x2c, 0x8c, 0x4e, 0x88, 0x4e, 0x21, 0xb6, 0x69, 0x9c, 0xa7, 0x7d,
  0x06, 0xc5, 0x75, 0x3f, 0xdc, 0x18, 0xf6, 0x00, 0x51, 0xd5, 0x00, 0x47,
  0x62, 0xfc, 0x95, 0xc8, 0xd4, 0xef, 0x31, 0x4a, 0xb0, 0x15, 0xa9, 0x50,
  0x04, 0x6e, 0x13, 0x14, 0xd4, 0xbb, 0x56, 0x22, 0x6f, 0x3b, 0x91, 0xb6,
  0xeb, 0xba, 0x25, 0x8f, 0x12, 0xea, 0xfd, 0xd4, 0xd0, 0x6d, 0x02, 0x03,
  0x01, 0x00, 0x01, 0xa0, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,
  0x3b, 0xa5, 0xb4, 0x97, 0x6c, 0xea, 0xe4, 0x9f, 0xeb, 0x56, 0xca, 0x7a,
  0x7f, 0xfa, 0x53, 0x8d, 0xee, 0x6f, 0x7e, 0xa1, 0x08, 0x65, 0xe0, 0x05,
  0x5b, 0x0e, 0x5a, 0x92, 0xdb, 0x3c, 0xc5, 0x6d, 0x0d, 0xcd, 0x2c, 0xcd,
  0x4d, 0x10, 0x2a, 0x92, 0x78, 0x1d, 0xfb, 0x92, 0x66, 0x33, 0x18, 0xdd,
  0xf8, 0x78, 0xc5, 0x1a, 0x03, 0xf9, 0x58, 0x9f, 0x32, 0x49, 0xde, 0xd2,
  0x26, 0x78, 0x80, 0x87, 0x18, 0xf3, 0x6d, 0xc3, 0x35, 0x5d, 0x21, 0x8b,
  0x4c, 0x8c, 0x87, 0xef, 0xb1, 0xfc, 0x2c, 0xec, 0xdb, 0xd6, 0x00, 0xe5,
  0x21, 0xfa, 0x34, 0x5a, 0x3c, 0xc3, 0x82, 0x52, 0x6f, 0x81, 0x2a, 0x05,
  0xcc, 0xdc, 0x8a, 0x51, 0xf6, 0x65, 0x1d, 0xc5, 0x64, 0x86, 0xc1, 0x28,
  0xf5, 0x0c, 0x8f, 0x09, 0xd4, 0x84, 0x8f, 0x69, 0x04, 0x24, 0x65, 0xf4,
  0x47, 0x6c, 0x90, 0x57, 0x3c, 0x04, 0x4d, 0x52
};
static unsigned int US899_VALID_CSR_DER_LEN = 428;
#if 0
//Leaving this in for now, we may need this for some test cases
static FILE *outfile;
static size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr,size,nmemb,outfile);
    return written;
}
#endif

static void us899_clean (void)
{
}

static int us899_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERTKEY,
	          US899_SERVER_CERTKEY,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us899_init_suite (void)
{
    int rv;

#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us899_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US899_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us899_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us899_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us899_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}    


static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}

static int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, char *cn)
{
    X509_NAME *subj;

    /* setup version number */
    if (!X509_REQ_set_version(req, 0L)) {
	printf("\nUnable to set X509 version#\n");
        return (-1);
    }

    /*
     * Add Common Name entry
     */
    subj = X509_REQ_get_subject_name(req);
    if (!X509_NAME_add_entry_by_txt(subj, "CN", MBSTRING_ASC,
                                    (unsigned char*)cn, -1, -1, 0)) {
	printf("\nUnable to create X509 Common Name entry\n");
        return (-1);
    }

    /*
     * Set the public key on the request
     */
    if (!X509_REQ_set_pubkey(req, pkey)) {
	printf("\nUnable to set X509 public key\n");
        return (-1);
    }

    return (0);
}

/*
 * Sign an X509 certificate request using the digest and the key passed.
 * Returns OpenSSL error code from X509_REQ_sign_ctx();
 */
static int sign_X509_req (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
    int rv;
    EVP_PKEY_CTX *pkctx = NULL;
    EVP_MD_CTX mctx;

    EVP_MD_CTX_init(&mctx);

    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {
        return 0;
    }

    /*
     * Encode using DER (ASN.1) 
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     */
    x->req_info->enc.modified = 1; 
    rv = X509_REQ_sign_ctx(x, &mctx);

    EVP_MD_CTX_cleanup(&mctx);

    return (rv);
}

/*
 * This function performs a basic simple enroll using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variety of test cases in this module.
 */
static void us899_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Simple enroll -  
 *
 * This is a basic test to perform a /simpleenroll using a 
 * user ID and password to identify the client to the server. 
 * No identity certificate is used by the client.
 */
static void us899_test1 (void) 
{
    LOG_FUNC_NM;

    us899_simple_enroll("TC899-1", US899_SERVER_IP, EST_ERR_NONE); 
}


/*
 * Simple enroll CSR  
 *
 * This is a basic test to perform a /simpleenroll using a 
 * user ID and password to identify the client to the server. 
 * No identity certificate is used by the client.
 * This test case uses the alternate enroll method where the CSR
 * is provided by the application layer rather than having libest
 * generate the CSR.
 */
static void us899_test2 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    X509_REQ *csr;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Generate a CSR
     */
    csr = X509_REQ_new();
    CU_ASSERT(csr != NULL);
    rv = populate_x509_csr(csr, key, "US899-TC2");

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the alternate API to enroll an existing CSR
     */
    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    X509_REQ_free(csr);
    EVP_PKEY_free(key);
    if (new_cert) {
        free(new_cert);
    }
    est_destroy(ectx);
}

/*
 * Simple enroll CSR - Null 
 *
 * This is a basic test to perform a /simpleenroll using a 
 * user ID and password to identify the client to the server. 
 * No identity certificate is used by the client.
 * This test case uses the alternate enroll method where the CSR
 * is provided by the application layer rather than having libest
 * generate the CSR.  It attempts to pass in null CSR, which should
 * fail.
 */
static void us899_test3 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the alternate API to enroll a null CSR
     */
    rv = est_client_enroll_csr(ectx, NULL, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NO_CSR);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 * Simple enroll CSR - corrupted  
 *
 * This test checks the X509_REQ helper function is working proplery.
 */
static void us899_test4 (void) 
{
    X509_REQ *csr;
    unsigned char badreq[14] = "bogus request";

    LOG_FUNC_NM;

    /*
     * First try PEM decoding 
     */
    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_PEM);
    CU_ASSERT(csr == NULL);

    /*
     * Next try DER decoding 
     */
    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_DER);
    CU_ASSERT(csr == NULL);

    /*
     * Next try an invalid format
     */
    csr = est_read_x509_request(badreq, 13, 999);
    CU_ASSERT(csr == NULL);

    /*
     * Next try an invalid csr length
     */
    csr = est_read_x509_request(badreq, 999999, EST_CERT_FORMAT_PEM);
    CU_ASSERT(csr == NULL);

    /*
     * Next try a valid PEM encoded csr
     */
    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_PEM, strlen(US899_VALID_CSR_PEM), 
	                         EST_CERT_FORMAT_PEM);
    CU_ASSERT(csr != NULL);
    if (csr) {
	X509_REQ_free(csr);
    }

    /*
     * Next try a valid DER encoded csr
     */
    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_DER, US899_VALID_CSR_DER_LEN, 
	                         EST_CERT_FORMAT_DER);
    CU_ASSERT(csr != NULL);
    if (csr) {
	X509_REQ_free(csr);
    }
}

//C. Attempt to enroll a newly created CSR that's already been signed 
//   via est_client_enroll_csr
static void us899_test5 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    X509_REQ *csr;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * Generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Generate a new CSR
     */
    csr = X509_REQ_new();
    CU_ASSERT(csr != NULL);
    rv = populate_x509_csr(csr, key, "US899-TC5");
    CU_ASSERT(csr != NULL);

    /*
     * Sign the CSR
     */

    rv = sign_X509_req(csr,key,EVP_sha256()); 

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the alternate API to enroll an existing CSR.  This should pass.
     */
    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    X509_REQ_free(csr);
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 * Simple enroll - FQDN mismatch hostname in CN 
 *
 * This test confirms that a mismatched host name on
 * the server cert CN will result in an auth failure
 * at the TLS layer on the client side.
 */
static void us899_test6 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MISMATCH,
	          US899_SERVER_KEY_CN_MISMATCH,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-6", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); 

}

/*
 * Simple enroll - FQDN mismatch IPv4 address in CN 
 *
 * This test confirms that a mismatched IP address in
 * the server cert CN will result in an auth failure
 * at the TLS layer on the client side.
 * Note: this test may be redundant since the IP address
 *       matching logic only occurs when the dNSName is 
 *       used instead of the CommonName.
 */
static void us899_test7 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MISMATCH_IP,
	          US899_SERVER_KEY_CN_MISMATCH_IP,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-7", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); 

}

/*
 * Simple enroll - FQDN matched wildcard in CN 
 *
 * This test confirms that wildcard matching logic
 * in the CN is working. The cert uses a wildcard
 * pattern of *.cisco.com with a server address
 * of localhost.cisco.com.
 */
static void us899_test8 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MATCH_WC,
	          US899_SERVER_KEY_CN_MATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-8", "localhost.cisco.com", EST_ERR_NONE); 

}

/*
 * Simple enroll - FQDN mismatched wildcard in CN 
 *
 * This test confirms that wildcard matching logic
 * in the CN is working. The cert uses a wildcard
 * pattern of *.google.com with a server address
 * of localhost.cisco.com.
 */
static void us899_test9 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MISMATCH_WC,
	          US899_SERVER_KEY_CN_MISMATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-9", "localhost.cisco.com", EST_ERR_FQDN_MISMATCH); 
}

/*
 * Simple enroll - FQDN matched hostname in SubjectAltName 
 *
 * This test confirms that a matched host name on
 * the server cert SubjectAltName ext will result in an auth success. 
 */
static void us899_test10 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MATCH,
	          US899_SERVER_KEY_SAN_MATCH,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-10", "localhost.cisco.com", EST_ERR_NONE); 
}

/*
 * Simple enroll - FQDN mismatched hostname in SubjectAltName 
 *
 * This test confirms that a mismatched host name on
 * the server cert SubjectAltName ext will result in an auth failure. 
 */
static void us899_test11 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MISMATCH,
	          US899_SERVER_KEY_SAN_MISMATCH,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-11", "localhost.cisco.com", EST_ERR_FQDN_MISMATCH); 
}

/*
 * Simple enroll - FQDN mismatched IPv4 address in SubjectAltName 
 *
 * This test confirms that a mismatched IPv4 address on
 * the server cert SubjectAltName ext will result in an auth failure. 
 */
static void us899_test12 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MISMATCH_IP,
	          US899_SERVER_KEY_SAN_MISMATCH_IP,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-12", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); 
}

/*
 * Simple enroll - FQDN matched IPv4 address in SubjectAltName 
 *
 * This test confirms that a matched IPv4 address on
 * the server cert SubjectAltName ext will result in an auth success. 
 */
static void us899_test13 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MATCH_IP,
	          US899_SERVER_KEY_SAN_MATCH_IP,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-13", US899_SERVER_IP, EST_ERR_NONE); 
}

/*
 * Simple enroll - FQDN matched hostname in SubjectAltName with wildcard 
 *
 * This test confirms that a hostname matches a wildcard pattern in
 * the server cert SubjectAltName ext, which will result in an auth success. 
 */
static void us899_test14 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MATCH_WC,
	          US899_SERVER_KEY_SAN_MATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-14", "localhost.cisco.com", EST_ERR_NONE); 
}

/*
 * Simple enroll - FQDN mismatched hostname in SubjectAltName with wildcard 
 *
 * This test confirms that a hostname mismatches a wildcard pattern in
 * the server cert SubjectAltName ext, which will result in an auth fail. 
 */
static void us899_test15 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MISMATCH_WC,
	          US899_SERVER_KEY_SAN_MISMATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-15", "localhost.cisco.com", EST_ERR_FQDN_MISMATCH); 
}


/*
 * Simple enroll - CRL check enabled on client
 *
 * We enable CRL checking on the client side.  We will
 * generate a CRL, but the server cert will not be
 * revoked.  The enroll should succeed.
 */
static void us899_test16 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *cacrlcerts = NULL;
    int cacrlcerts_len = 0;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Now that all the FQDN tests are completed, start
     * the normal server.
     */
    rv = us899_start_server(0, 0);
    CU_ASSERT(rv == 0);

    /*
     * Generate a CRL and append it to the CA chain
     * we're using on the client side.
     */
#ifndef WIN32
    system("openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem");
    SLEEP(1);
    system("cat CA/trustedcerts.crt > US899/test16trust.crt");
    SLEEP(1);
    system("cat US899/test16_crl.pem >> US899/test16trust.crt");
    SLEEP(1);
#else
    system("openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem");
    SLEEP(1);
    system("type CA\\trustedcerts.crt > US899\\test16trust.crt");
    SLEEP(1);
    system("type US899\\test16_crl.pem >> US899\\test16trust.crt");
    SLEEP(1);
#endif 

    /*
     * Read in the CA certificates
     */
    cacrlcerts_len = read_binary_file("US899/test16trust.crt", &cacrlcerts);
    CU_ASSERT(cacrlcerts > 0);
    if (cacrlcerts_len <= 0) {
	return;
    }

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacrlcerts, cacrlcerts_len, 
                           EST_CERT_FORMAT_PEM, 
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Enable CRL checking on the client
     */
    rv = est_enable_crl(ectx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TEST16-CN", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
    free(cacrlcerts);
}

/*
 * Simple enroll - CRL check enabled on client
 *
 * We enable CRL checking on the client side.  We will
 * generate a CRL, the server cert will  be
 * revoked.  The enroll should fail.
 */
static void us899_test17 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    unsigned char *cacrlcerts = NULL;
    int cacrlcerts_len = 0;
    unsigned char *attr_data = NULL;
    int attr_len;
    
    LOG_FUNC_NM;

    /*
     * Revoke the server cert, generate a CRL and append it to the CA chain
     * we're using on the client side.
     */
#ifndef WIN32
    system("cp CA/estCA/index.txt CA/estCA/index.txt.save");
    SLEEP(1);
    system("openssl ca -config CA/estExampleCA.cnf -revoke CA/estCA/private/estservercertandkey.pem");
    SLEEP(1);
    system("openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test17_crl.pem");
    SLEEP(1);
    system("cat CA/trustedcerts.crt > US899/test17trust.crt");
    SLEEP(1);
    system("cat US899/test17_crl.pem >> US899/test17trust.crt");
    SLEEP(1);
    system("cp CA/estCA/index.txt.save CA/estCA/index.txt");
    SLEEP(1);
#else 
    system("copy CA\\estCA\\index.txt CA\\estCA\\index.txt.save");
    SLEEP(1);
    system("openssl ca -config CA\\estExampleCA.cnf -revoke CA\\estCA\\private\\estservercertandkey.pem");
	SLEEP(1); 
    system("openssl ca -config CA\\estExampleCA.cnf -gencrl -out US899\\test17_crl.pem");
    SLEEP(1);
    system("type CA\\trustedcerts.crt > US899\\test17trust.crt");
    SLEEP(1);
    system("type US899\\test17_crl.pem >> US899\\test17trust.crt");
    SLEEP(1);
    system("copy CA\\estCA\\index.txt.save CA\\estCA\\index.txt");
    SLEEP(1);
#endif 

    /*
     * Read in the CA certificates
     */
    cacrlcerts_len = read_binary_file("US899/test17trust.crt", &cacrlcerts);
    CU_ASSERT(cacrlcerts > 0);
    if (cacrlcerts_len <= 0) {
	return;
    }

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacrlcerts, cacrlcerts_len, 
                           EST_CERT_FORMAT_PEM, 
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Enable CRL checking on the client
     */
    rv = est_enable_crl(ectx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TEST17-CN", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
    free(cacrlcerts);
}

/*
 * Simple enroll - Receive Retry-After response 
 *
 * Client issues an Enroll request and receives
 * a Retry-After response.  Ensure that the
 * retry after value can be obtained from the client.
 */
static void us899_test18 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    int delay_secs = 0;
    time_t retry_date = 0;
    unsigned char *attr_data = NULL;
    int attr_len;
    
    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to go into manual enroll mode
     */
    st_stop();

    /*
     * Start the server up in manual enroll mode
     */
    rv = us899_start_server(1, 0);
    CU_ASSERT(rv == 0);    

    /*
     * Create a client context using the default CA certs
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM, 
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TEST18-CN", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);

    if (rv == EST_ERR_CA_ENROLL_RETRY) {
        /*
         * go get the retry duration
         * make sure it's set to the default value
         */
        rv = est_client_copy_retry_after(ectx, &delay_secs, &retry_date);
        CU_ASSERT(rv == EST_ERR_NONE);
        CU_ASSERT(delay_secs == 3600);
    }
    
    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

//TO DO
//
//Auth (HTTP basic auth enabled on server) 
//A. Enroll CSR using valid cert, no UID
//B. Enroll CSR using valid cert, valid UID
//C. Enroll CSR using valid cert, invalid UID
//D. Enroll CSR using invalid cert, no UID
//E. Enroll CSR using invalid cert, valid UID
//F. Enroll CSR using invalid cert, invalid UID
//
//Auth (HTTP digest auth enabled on server) 
//A. Enroll CSR using valid cert, no UID
//B. Enroll CSR using valid cert, valid UID
//C. Enroll CSR using valid cert, invalid UID
//D. Enroll CSR using invalid cert, no UID
//E. Enroll CSR using invalid cert, valid UID
//F. Enroll CSR using invalid cert, invalid UID
//

int us899_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us899_client_simpenroll", 
	                  us899_init_suite, 
			  us899_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* 
    * Add the tests to the suite 
    *
    * ********************IMPORTANT*********************
    * Do not change the order of these tests.
    * Some of the tests stop the EST server and restart
    * it using different certs.  If you change the order
    * then false negatives may occur.
    * **************************************************
    *
    */
   if ((NULL == CU_add_test(pSuite, "Simple enroll", us899_test1)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll CSR", us899_test2)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll null CSR", us899_test3)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll corrupted CSR", us899_test4)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll signed CSR", us899_test5)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - hostname mismatch FQDN CN", us899_test6)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - IPv4 mismatch FQDN CN", us899_test7)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard match FQDN CN", us899_test8)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard mismatch FQDN CN", us899_test9)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - hostname match FQDN SAN", us899_test10)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - hostname mismatch FQDN SAN", us899_test11)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - IPv4 mismatch FQDN SAN", us899_test12)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - IPv4 match FQDN SAN", us899_test13)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard match FQDN SAN", us899_test14)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard mismatch FQDN SAN", us899_test15)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - CRL enabled, valid server cert", us899_test16)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - CRL enabled, revoked server cert", us899_test17)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - Retry-After received", us899_test18)))
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us1005.c - Unit Tests for User Story 1005 - Client easy provision
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#include <string.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifdef WIN32
static CRITICAL_SECTION logger_critical_section;
#endif 

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US1005_SERVER_PORT      31005
#define US1005_SERVER_IP    "127.0.0.1" 
#define US1005_UID          "estuser"
#define US1005_PWD          "estpwd"
#ifndef WIN32
#define US1005_CACERTS          "CA/estCA/cacert.crt"
#define US1005_TRUST_CERTS      "CA/trustedcerts.crt"
#define US1005_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US1005_CLIENT_KEY       "US1005/implicit-key.pem"
#define US1005_CLIENT_CERT      "US1005/implicit-cert.pem"
#else
#define US1005_CACERTS          "CA\\estCA\\cacert.crt"
#define US1005_TRUST_CERTS      "CA\\trustedcerts.crt"
#define US1005_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"
#define US1005_CLIENT_KEY       "US1005\\implicit-key.pem"
#define US1005_CLIENT_CERT      "US1005\\implicit-cert.pem"
#endif 
#define US1005_CSR_NOPOP        "MBQGBysGAQEBARYGCWCGSAFlAwQCAg==\0"

static char *log_search_target = NULL;
static int search_target_found = 0;
/*
 * This is a simple callback used to override the default
 * logging facility in libest.  We'll use this to look
 * for specific debug output.
 */
static void us1005_logger_stderr (char *format, va_list l)
{
    char t_log[1024];
#ifndef WIN32
    flockfile(stderr);
#else
    EnterCriticalSection(&logger_critical_section);
#endif 
    if (log_search_target) {
        vsnprintf(t_log, 1024, format, l);
        if (strstr(t_log, log_search_target)) {
            search_target_found = 1;
        }
        fprintf(stderr, "%s", t_log);
    } else {
        vfprintf(stderr, format, l);
    }
    fflush(stderr);
#ifndef WIN32
    funlockfile(stderr);
#else
    LeaveCriticalSection(&logger_critical_section);
#endif 
}

static void us1005_clean (void)
{
}

static int us1005_start_server (int manual_enroll, int nid, int no_http_auth,
                                int enable_pop)
{
    int rv;

    rv = st_start(US1005_SERVER_PORT,
                  US1005_SERVER_CERTKEY,
                  US1005_SERVER_CERTKEY,
                  "US1005 test realm",
                  US1005_CACERTS,
                  US1005_TRUST_CERTS,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  enable_pop,
                  nid);

    if (no_http_auth) {
        st_disable_http_auth();
    }

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1005_init_suite (void)
{
    int rv;

#ifdef WIN32
    /* Initialize critical section on Windows*/
    InitializeCriticalSection(&logger_critical_section);
#endif 

    est_init_logger(EST_LOG_LVL_INFO, &us1005_logger_stderr);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1005_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us1005_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1005_start_server(0, 0, 0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1005_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * This function performs the easy provision operation using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variety of test cases in this module.
 */
static void us1005_easy_provision (char *cn, char *server, int ba_hint,
                                   int use_cert)
{
    EST_CTX *ectx;
    EVP_PKEY *new_key;
    int rv;
    int pkcs7_len = 0;
    int ca_certs_len = 0;
    unsigned char *new_cert = NULL;
    EVP_PKEY *key = NULL;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    X509 *cert = NULL;
    BIO *in;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    if (use_cert) {
        /*
         * Read in the private key
         */
        key_len = read_binary_file(US1005_CLIENT_KEY, &key_raw);
        CU_ASSERT(key_len > 0);
        key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
        CU_ASSERT(key != NULL);
        free(key_raw);

        /*
         * Read in the old cert
         */
        cert_len = read_binary_file(US1005_CLIENT_CERT, &cert_raw);
        CU_ASSERT(cert_len > 0);
        in = BIO_new_mem_buf(cert_raw, cert_len);
        CU_ASSERT(in != NULL);
        if (!in)
            return;
        cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
        CU_ASSERT(cert != NULL);
        if (!cert)
            return;
        BIO_free_all(in);
        free(cert_raw);
    }

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, cert, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    if (ba_hint) {
        rv = est_client_enable_basic_auth_hint(ectx);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1005_SERVER_PORT, NULL);

    /*
     * generate a new private key
     */
    new_key = generate_private_key();
    CU_ASSERT(new_key != NULL);

    /*
     * Attempt to provision a new cert
     */
    rv = est_client_provision_cert(ectx, cn, &pkcs7_len, &ca_certs_len,
        new_key);
    CU_ASSERT(rv == EST_ERR_NONE);
    EVP_PKEY_free(new_key);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
        if (new_cert)
            free(new_cert);
    } else {
        est_destroy(ectx);
        return;
    }

    /*
     * Retrieve a copy of the new CA certs
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(ca_certs_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_cacerts(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
        if (new_cert)
            free(new_cert);
    } else {
        est_destroy(ectx);
        return;
    }

    EVP_PKEY_free(key);
    X509_free(cert);

    /*
     * Cleanup
     */
    est_destroy(ectx);
}

/*
 * Easy provision - HTTP basic auth, no client cert
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test1 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-1", US1005_SERVER_IP, 0, 0);
}

/*
 * Easy provision - with HTTP basic auth hint enabled, no client cert
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test2 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-2", US1005_SERVER_IP, 1, 0);
}

/*
 * Easy provision - client cert with HTTP basic auth enabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test3 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-3", US1005_SERVER_IP, 0, 1);
}

/*
 * Easy provision - client cert with HTTP basic auth hint enabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test4 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-4", US1005_SERVER_IP, 1, 1);
}

/*
 * Null pointers test
 */
static void us1005_test5 (void)
{
    int p7len = 0;
    int calen = 0;
    EVP_PKEY *key;
    int rv;
    EST_CTX *ectx;

    LOG_FUNC_NM
    ;

    /*
     * Create a valid context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US1005_SERVER_IP, US1005_SERVER_PORT, NULL);

    /*
     * Create a valid key pair
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Try with a NULL context
     */
    rv = est_client_provision_cert(NULL, "TEST2", &p7len, &calen, key);
    CU_ASSERT(rv == EST_ERR_NO_CTX);

    /*
     * Try with a NULL p7 length
     */
    rv = est_client_provision_cert(ectx, "TEST2", NULL, &calen, key);
    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);

    /*
     * Try with a NULL cacerts length
     */
    rv = est_client_provision_cert(ectx, "TEST2", &p7len, NULL, key);
    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);

    /*
     * Try with a NULL key
     */
    rv = est_client_provision_cert(ectx, "TEST2", &p7len, &calen, NULL);
    CU_ASSERT(rv == EST_ERR_NO_KEY);

    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 *  Enable pop on server, enable CSR attributes on server w/o challengePassword OID
 */
static void us1005_test6 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP enabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 1);

    /*
     * Set the CSR attributes to a value that doesn't include challengePassword OID
     */
    st_set_csrattrs(US1005_CSR_NOPOP);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-6", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Disable pop on server, enable CSR attributes on server w/o challengePassword OID
 */
static void us1005_test7 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP disabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 0);

    /*
     * Set the CSR attributes to a value that doesn't include challengePassword OID
     */
    st_set_csrattrs(US1005_CSR_NOPOP);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Cert request does not contain PoP\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-7", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Enable pop on server, enable CSR attributes on server w/ challengePassword OID
 */
static void us1005_test8 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP enabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 1);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-8", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Disable pop on server, enable CSR attributes on server w/challengePassword OID
 */
static void us1005_test9 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP disabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 0);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-9", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Enable pop on server, disable CSR attributes on server
 */
static void us1005_test10 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP enabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 1);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);
    st_disable_csr_cb();

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-10", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Disable pop on server, disable CSR attributes on server
 */
static void us1005_test11 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP disabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 0);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);
    st_disable_csr_cb();

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Cert request does not contain PoP\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-11", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

//
// The next two test caes repeate tests 3 & 4 but with
// HTTP auth disabled on the server.
//

/*
 * Easy provision - client cert with HTTP basic auth disabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test93 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with HTTP auth disabled
     */
    st_stop();
    us1005_start_server(0, 0, 1, 0);

    us1005_easy_provision("TC1005-93", US1005_SERVER_IP, 0, 1);
}

/*
 * Easy provision - client cert with HTTP basic auth hint enabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test94 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-94", US1005_SERVER_IP, 1, 1);
}

int us1005_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1005_client_easy_provision",
            us1005_init_suite,
            us1005_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /*
     * Add the tests to the suite
     *
     * ********************IMPORTANT*********************
     * Do not change the order of these tests.
     * Some of the tests stop the EST server and restart
     * it using different certs.  If you change the order
     * then false negatives may occur.
     * **************************************************
     *
     */
    if ((NULL == CU_add_test(pSuite, "Easy provision - no cert", us1005_test1)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - no cert HTTP BA hint", us1005_test2)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert", us1005_test3)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert HTTP BA hint", us1005_test4)) ||
        (NULL == CU_add_test(pSuite, "Null pointers", us1005_test5)) ||
        (NULL == CU_add_test(pSuite, "Enable PoP - no challengePassword", us1005_test6)) ||
        (NULL == CU_add_test(pSuite, "Disable PoP - no challengePassword", us1005_test7)) ||
        (NULL == CU_add_test(pSuite, "Enable PoP - w/challengePassword", us1005_test8)) ||
        (NULL == CU_add_test(pSuite, "Disable PoP - w/challengePassword", us1005_test9)) ||
        (NULL == CU_add_test(pSuite, "Enable PoP - CSR disabled", us1005_test10)) ||
        (NULL == CU_add_test(pSuite, "Disable PoP - CSR disabled", us1005_test11)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert no server auth", us1005_test93)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert HTTP BA hint no server auth", us1005_test94)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us901.c - Unit Tests for User Story 901 - Server cacerts
 *
 * June, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US901_PKCS10_REQ    "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"
#define US901_ENROLL_URL "https://127.0.0.1:29901/.well-known/est/simpleenroll"
#define US901_CACERT_URL "https://127.0.0.1:29901/.well-known/est/cacerts"
#define US901_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US901_UIDPWD_GOOD   "estuser:estpwd"
#define US901_UIDPWD_BAD    "estuser:bogus"
#define US901_SERVER_PORT 29901
#ifndef WIN32
#define US901_CACERTS       "CA/estCA/cacert.crt"
#define US901_EXPLICIT_CERT "US901/explicit-cert.pem" 
#define US901_EXPLICIT_KEY "US901/explicit-key.pem"
#define US901_IMPLICIT_CERT "US901/implicit-cert.pem" 
#define US901_IMPLICIT_KEY "US901/implicit-key.pem"
#define US901_REVOKED_CERT "US901/revoked-cert.pem" 
#define US901_REVOKED_KEY "US901/revoked-key.pem"
#define US901_SELFSIGN_CERT "US901/selfsigned-cert.pem" 
#define US901_SELFSIGN_KEY "US901/selfsigned-key.pem"
#define US901_CACERT "CA/estCA/cacert.crt"
#define US901_EXTCERT "CA/extCA/cacert.crt"
#define US901_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US901_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
#define US901_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
static char test5_outfile[FILENAME_MAX] = "US901/test5.crt";
#else
#define US901_CACERTS       "CA\\estCA\\cacert.crt"
#define US901_EXPLICIT_CERT "US901\\explicit-cert.pem" 
#define US901_EXPLICIT_KEY "US901\\explicit-key.pem"
#define US901_IMPLICIT_CERT "US901\\implicit-cert.pem" 
#define US901_IMPLICIT_KEY "US901\\implicit-key.pem"
#define US901_REVOKED_CERT "US901\\revoked-cert.pem" 
#define US901_REVOKED_KEY "US901\\revoked-key.pem"
#define US901_SELFSIGN_CERT "US901\\selfsigned-cert.pem" 
#define US901_SELFSIGN_KEY "US901\\selfsigned-key.pem"
#define US901_CACERT "CA\\estCA\\cacert.crt"
#define US901_EXTCERT "CA\\extCA\\cacert.crt"
#define US901_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US901_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US901_SERVER_CERTKEY "CA\\estCA\\private/estservercertandkey.pem"
static char test5_outfile[FILENAME_MAX] = "US901\\test5.crt";
#endif

static void us901_clean(void) {
    char cmd[200];
    sprintf(cmd, "rm %s", test5_outfile);
    system(cmd);
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us901_init_suite(void) {
    us901_clean();

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    return 0;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us901_destory_suite(void) {
    return 0;
}

/*
 * Start the appropriate flavor of st_server
 * based what character is specified
 * B - Basic auth
 * D - Digest auth
 * C - CRL checking
 * N = No auth
 */
static int us901_start_server(char server_type) {
    int rv;

    switch (server_type) {
    case 'B':
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "CA/trustedcerts.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_enable_http_basic_auth();
        break;
    case 'D':
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "CA/trustedcerts.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_enable_http_digest_auth();
        break;
    case 'C':
        system(
                "openssl ca -config CA/estExampleCA.cnf -gencrl -out CA/estCA/crl.pem");
        SLEEP(1);
        system(
                "cat CA/trustedcerts.crt CA/estCA/crl.pem > US901/trustedcertsandcrl.crt");
        SLEEP(1);
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "US901/trustedcertsandcrl.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_enable_crl();
        st_disable_http_auth();
        break;
    case 'N':
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "CA/trustedcerts.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_disable_http_auth();
        break;
    default:
        rv = -1;
        break;
    }

    return rv;
}

/*
 * HTTP Basic auth
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running and listing to port 8088 prior to this
 * test being run.
 */
static void us901_test1(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('B');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,
    NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    st_stop();
    SLEEP(1);

}

/*
 * HTTP Basic Auth failure
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST server,
 * while using a bogus password.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running prior to this test being run.
 */
static void us901_test2(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('B');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_BASIC,
    NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 400
     */
    CU_ASSERT(rv == 401);

    st_stop();
    SLEEP(1);
}

/*
 * HTTP Digest Auth
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running and listening to port 8087 prior to this
 * test being run.
 */
static void us901_test3(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_DIGEST,
    NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with success
     */
    CU_ASSERT(rv == 200);

    st_stop();
    SLEEP(1);
}

/*
 * HTTP Digest Auth fail
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST server.
 * This is the negative test case for Digest auth.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running and listening to port 8087 prior to this
 * test being run.
 */
static void us901_test4(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_DIGEST,
    NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 401);
    st_stop();
    SLEEP(1);
}

static FILE *outfile;
static size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata) {
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

/*
 * This test case does a simple cacerts request
 * and looks for the HTTP 200 response code.
 */
static void us901_test5(void) {
    long rv;
    char cmd[200];
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_get(US901_CACERT_URL, US901_CACERTS, &write_func);
    fclose(outfile);

    /*
     * we expect the server to respond with a 200
     */
    CU_ASSERT(rv == 200);

    sprintf(cmd,
            "openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs",
            test5_outfile);
    rv = system(cmd);
    CU_ASSERT(rv == 0);
    st_stop();
    SLEEP(1);
}

static void us901_test_sslversion(const SSL_METHOD *m, int expect_fail) {
    BIO *conn;
    SSL *ssl;
    SSL_CTX *ssl_ctx = NULL;
    int rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    ssl_ctx = SSL_CTX_new(m);
    CU_ASSERT(ssl_ctx != NULL);

    /*
     * Now that the SSL context is ready, open a socket
     * with the server and bind that socket to the context.
     */
    conn = open_tcp_socket_ipv4("127.0.0.1", "29901");
    CU_ASSERT(conn != NULL);

    /*
     * Creaea SSL session context
     */
    ssl = SSL_new(ssl_ctx);
    SSL_set_bio(ssl, conn, conn);

    /*
     * Now that we have everything ready, let's initiate the TLS
     * handshake.
     */
    rv = SSL_connect(ssl);
    if (!expect_fail) {
        CU_ASSERT(rv > 0);
    } else {
        CU_ASSERT(rv <= 0);
    }

    /*
     * Cleanup all the data
     */
    SSL_shutdown(ssl);
    SSL_free(ssl);
    SSL_CTX_free(ssl_ctx);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to create a SSL 3.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us901_test6(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(SSLv3_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us901_test7(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(TLSv1_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.1 connection
 * with the EST server.  This should succeed.
 */
static void us901_test8(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(TLSv1_1_client_method(), 0);
}

/*
 * This test attempts to create a TLS 1.2 connection
 * with the EST server.  This should succeed.
 */
static void us901_test9(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(TLSv1_2_client_method(), 0);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. This should succeed.
 */
static void us901_test10(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('N');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_EXPLICIT_CERT,
    US901_EXPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the implicit cert
 * chain. This should succeed.
 */
static void us901_test11(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('N');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_IMPLICIT_CERT,
    US901_IMPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a revoked client certificate to
 * verify CRL checks are working in the TLS layer.
 * This should fail.
 */
static void us901_test12(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('R');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_REVOKED_CERT,
    US901_REVOKED_KEY,
    US901_CACERTS,
    NULL);

    /*
     * Since the client cert has been revoked the TLS handshake
     * will fail.  The EST server should return a 401 response.
     */
    CU_ASSERT(rv == 0);
    st_stop();
}

/*
 * This test attempts to use a self-signed client certificate to
 * verify cert chain will reject a cert that has not been
 * signed by a valid CA.  This should fail.
 */
static void us901_test13(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_SELFSIGN_CERT,
    US901_SELFSIGN_KEY,
    US901_CACERTS,
    NULL);

    /*
     * Since the client cert is not signed by either the local CA
     * or external CA, the TLS handshake will fail.
     * We will not receive an HTTP status message
     * from the server.
     */
    CU_ASSERT(rv == 0);
    st_stop();
}

/*
 * TLS anonymous cipher suites disabled
 *
 * This test case uses libcurl to test that the
 * EST server will not accept anonymous cipher
 * suites from the client.  We only test a single
 * cipher suite here.  This attempts to do a
 * simple enroll with the server.
 */
static void us901_test14(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC, "ADH-AES128-SHA256", NULL,
            NULL);
    /*
     * TLS handshake should have failed, curl should return 0
     */
    CU_ASSERT(rv == 0);
    st_stop();
    SLEEP(1);
}

/*
 * Null HTTP realm when initializing server
 */
static void us901_test15(void) {
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US901_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL realm
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
            EST_CERT_FORMAT_PEM,
            NULL, x, priv_key);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate when initializing server
 */
static void us901_test16(void) {
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *keyin;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US901_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL server key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
            EST_CERT_FORMAT_PEM, "testrealm", NULL, priv_key);
    CU_ASSERT(ctx == NULL);

    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate private key when initializing server
 */
static void us901_test17(void) {
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin;
    X509 *x;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US901_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Attempt to init EST server using NULL private key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
            EST_CERT_FORMAT_PEM, "testrealm", x, NULL);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
}

/*
 * Null trusted CA chain when initializing server
 */
static void us901_test18(void) {
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL local CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(NULL, 0, NULL, 0, EST_CERT_FORMAT_PEM, "testrealm", x,
            priv_key);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Corrupted CA chain when initializing server
 */
static void us901_test19(void) {
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server a corrupted CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init((unsigned char*) "Bogus CA chain", 14,
            (unsigned char*) "Bogus CA chain", 14, EST_CERT_FORMAT_PEM,
            "testrealm", x, priv_key);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * This test case attempts simple cacerts request using
 * POST instead of GET.  It should fail.
 */
static void us901_test20(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US901_CACERT_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,
    NULL, NULL, NULL);
    fclose(outfile);

    /*
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 400);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Valid HTTP authentication credentials are
 * also provided.  This should succeed.
 */
static void us901_test21(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('B');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_UIDPWD_GOOD,
    US901_EXPLICIT_CERT,
    US901_EXPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Invalid HTTP authentication credentials are
 * also provided.  This should fail with a 401 response.
 */
static void us901_test22(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_UIDPWD_BAD,
    US901_EXPLICIT_CERT,
    US901_EXPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to enroll without using a certificate
 * to identity the client, while using a good user ID/pwd.
 * However, the EST server is setup to only perform
 * certificate authentication (HTTP auth disabled).
 * This should fail with a 401 response.
 */
static void us901_test23(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('N');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_UIDPWD_GOOD,
    US901_CACERTS,
    CURLAUTH_BASIC,
    NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);
    st_stop();
    SLEEP(1);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us901_add_suite(void) {
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us901_srv_cacerts",
            us901_init_suite,
            us901_destory_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
    if ((NULL == CU_add_test(pSuite, "HTTP Basic Auth", us901_test1)) ||
            (NULL == CU_add_test(pSuite, "HTTP Basic Auth Fail", us901_test2)) ||
            (NULL == CU_add_test(pSuite, "HTTP Digest Auth", us901_test3)) ||
            (NULL == CU_add_test(pSuite, "HTTP Digest Auth Fail", us901_test4)) ||
            (NULL == CU_add_test(pSuite, "Get CA Certificates", us901_test5)) ||
            (NULL == CU_add_test(pSuite, "SSL 3.0 Fail", us901_test6)) ||
            (NULL == CU_add_test(pSuite, "TLS 1.0 Fail", us901_test7)) ||
            (NULL == CU_add_test(pSuite, "TLS 1.1", us901_test8)) ||
            (NULL == CU_add_test(pSuite, "TLS 1.2", us901_test9)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - explicit cert chain", us901_test10)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - implicit cert chain", us901_test11)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - revoked cert", us901_test12)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - self-signed cert", us901_test13)) ||
            (NULL == CU_add_test(pSuite, "Anon cipher suite disabled", us901_test14)) ||
            (NULL == CU_add_test(pSuite, "NULL Realm", us901_test15)) ||
            (NULL == CU_add_test(pSuite, "NULL server cert", us901_test16)) ||
            (NULL == CU_add_test(pSuite, "NULL server key", us901_test17)) ||
            (NULL == CU_add_test(pSuite, "NULL local CA chain", us901_test18)) ||
            (NULL == CU_add_test(pSuite, "Corrupted local CA chain", us901_test19)) ||
            (NULL == CU_add_test(pSuite, "HTTP POST cacerts", us901_test20)) ||
            (NULL == CU_add_test(pSuite, "SimpleEnroll - good HTTP auth/good Cert", us901_test21)) ||
            (NULL == CU_add_test(pSuite, "SimpleEnroll - bad HTTP auth/good Cert", us901_test22)) ||
            (NULL == CU_add_test(pSuite, "SimpleEnroll - no HTTP auth/no Cert", us901_test23)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us894.c - Unit Tests for User Story 894 - Proxy cacerts
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 *
 *  Proxy mode is primarily server mode where the processing of certain
 *  requests from clients are passed long to the upstream server using
 *  client mode functionality.  In the case of Get CACerts, proxy mode
 *  functions almost identically as server mode.  The CA certs response
 *  chain is passed in and is then sent in reply to the Get CACerts
 *  requests from downstream clients.
 *
 *  This test code is taken largely from US901, Server Get CACerts,
 *
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include <openssl/ssl.h>
#include "st_server.h"
#include "st_proxy.h"

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US894_PKCS10_REQ    "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"
#define US894_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US894_UIDPWD_GOOD   "estuser:estpwd"
#define US894_UIDPWD_BAD    "estuser:bogus"
#ifndef WIN32
#define US894_CACERTS       "CA/estCA/cacert.crt"
#define US894_TRUSTED_CERT  "CA/trustedcerts.crt"
#define US894_TRUSTED_CERT_AND_CRL "US894/trustedcertsandcrl.crt"
#define US894_EXPLICIT_CERT "US894/explicit-cert.pem" 
#define US894_EXPLICIT_KEY "US894/explicit-key.pem"
#define US894_IMPLICIT_CERT "US894/implicit-cert.pem" 
#define US894_IMPLICIT_KEY "US894/implicit-key.pem"
#define US894_REVOKED_CERT "US894/revoked-cert.pem" 
#define US894_REVOKED_KEY "US894/revoked-key.pem"
#define US894_SELFSIGN_CERT "US894/selfsigned-cert.pem" 
#define US894_SELFSIGN_KEY "US894/selfsigned-key.pem"
#define US894_CACERT "CA/estCA/cacert.crt"
#define US894_EXTCERT "CA/extCA/cacert.crt"
#define US894_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US894_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
#define US894_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"  // change these other to dedicated ones
#define US894_PROXY_KEY "CA/estCA/private/estservercertandkey.pem"
static char test5_outfile[FILENAME_MAX] = "US894/test5.crt";
static char test26_outfile[FILENAME_MAX] = "US894/test26.crt";
static char test27_outfile[FILENAME_MAX] = "US894/test27.crt";
#else
#define US894_CACERTS       "CA\\estCA\\cacert.crt"
#define US894_TRUSTED_CERT "CA\\trustedcerts.crt"
#define US894_TRUSTED_CERT_AND_CRL  "US894\\trustedcertsandcrl.crt"
#define US894_EXPLICIT_CERT "US894\\explicit-cert.pem" 
#define US894_EXPLICIT_KEY "US894\\explicit-key.pem"
#define US894_IMPLICIT_CERT "US894\\implicit-cert.pem" 
#define US894_IMPLICIT_KEY "US894\\implicit-key.pem"
#define US894_REVOKED_CERT "US894\\revoked-cert.pem" 
#define US894_REVOKED_KEY "US894\\revoked-key.pem"
#define US894_SELFSIGN_CERT "US894\\selfsigned-cert.pem" 
#define US894_SELFSIGN_KEY "US894\\selfsigned-key.pem"
#define US894_CACERT "CA\\estCA\\cacert.crt"
#define US894_EXTCERT "CA\\extCA\\cacert.crt"
#define US894_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US894_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US894_PROXY_CERT "CA\\estCA\\private\\estservercertandkey.pem"  // change these other to dedicated ones
#define US894_PROXY_KEY "CA\\estCA\\private\\estservercertandkey.pem"

static char test5_outfile[FILENAME_MAX] = "US894\\test5.crt";
static char test26_outfile[FILENAME_MAX] = "US894\\test26.crt";
static char test27_outfile[FILENAME_MAX] = "US894\\test27.crt";
#endif

/* #define US894_TCP_SERVER_PORT_BASIC     12894 */
#define US894_ENROLL_URL "https://127.0.0.1:16894/.well-known/est/simpleenroll"
#define US894_CACERT_URL "https://127.0.0.1:16894/.well-known/est/cacerts"
/* #define US894_TCP_SERVER_PORT_DIGEST    13894 */
/* #define US894_TCP_SERVER_PORT_HTTP_DISABLE 14894 */
#define US894_TCP_SERVER_PORT       15894
#define US894_TCP_PROXY_PORT        16894

static void us894_clean (void)
{
    char cmd[200];
#ifndef WIN32
    sprintf(cmd, "rm %s", test5_outfile);
    system(cmd);
    sprintf(cmd, "rm %s", test26_outfile);
    system(cmd);
    sprintf(cmd, "rm %s", test27_outfile);
    system(cmd);
#else
    sprintf(cmd, "del %s", test5_outfile);
    system(cmd);
    sprintf(cmd, "del %s", test26_outfile);
    system(cmd);
    sprintf(cmd, "del %s", test27_outfile);
    system(cmd);
#endif
}

int us894_start_server ()
{
    int rv = 0;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US894_TCP_SERVER_PORT,
                  US894_SERVER_CERT,
                  US894_SERVER_KEY,
                  "estrealm",
                  US894_CACERT,
                  US894_TRUSTED_CERT,
                  "US894/estExampleCA.cnf",
                  0,  // manual enroll
                  0,  // disable PoP
                  0); // ecdhe nid info
    SLEEP(1);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy acting as an RA.
     */
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
    SLEEP(1);

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us894_init_suite (void)
{
    int rv;

    us894_clean();

    printf("\nStarting EST Proxy Get CACerts unit tests.\n");

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us894_start_server();

    return rv;
}

void us894_stop_server ()
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us894_destroy_suite (void)
{
    us894_stop_server();
    printf("Completed EST Proxy Get CACerts unit tests.\n");
    return 0;
}

/*
 * HTTP Basic auth
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST proxy/server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.
 */
static void us894_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * HTTP Basic Auth failure, Bad Password
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST proxy/server,
 * while using a bogus password.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.
 */
static void us894_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 400
     */
    CU_ASSERT(rv == 401);
}

/*
 * HTTP Digest Auth
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST proxy/server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.
 *
 * This test also tests the correct operation of est_proxy_set_auth()
 */
static void us894_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_set_auth(AUTH_DIGEST);
    SLEEP(1);

    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_DIGEST,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with success
     */
    CU_ASSERT(rv == 200);

    st_proxy_set_auth(AUTH_BASIC);
}

/*
 * HTTP Digest Auth fail
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST proxy/server.
 * This is the negative test case for Digest auth.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST proxy/server should be
 * running and listening to port 8087 prior to this
 * test being run.
 */
static void us894_test4 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_set_auth(AUTH_DIGEST);
    SLEEP(1);

    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_DIGEST,
                        NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 401);

    st_proxy_set_auth(AUTH_BASIC);
}

static FILE *outfile;
static size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

/*
 * This test case does a simple cacerts request
 * and looks for the HTTP 200 response code.
 */
static void us894_test5 (void)
{
    long rv;
    char cmd[200];

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &write_func);
    fclose(outfile);

    /*
     * we expect the server to respond with a 200
     */
    CU_ASSERT(rv == 200);

    sprintf(
        cmd,
        "openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs",
        test5_outfile);
    rv = system(cmd);
    CU_ASSERT(rv == 0);
}

static void us894_test_sslversion (const SSL_METHOD *m, int expect_fail)
{
    BIO *conn;
    SSL *ssl;
    SSL_CTX *ssl_ctx = NULL;
    int rv;

    ssl_ctx = SSL_CTX_new(m);
    CU_ASSERT(ssl_ctx != NULL);

    /*
     * Now that the SSL context is ready, open a socket
     * with the server and bind that socket to the context.
     */
    conn = open_tcp_socket_ipv4("127.0.0.1", "16894");
    CU_ASSERT(conn != NULL);

    /*
     * Create an SSL session context
     */
    ssl = SSL_new(ssl_ctx);
    SSL_set_bio(ssl, conn, conn);

    /*
     * Now that we have everything ready, let's initiate the TLS
     * handshake.
     */
    rv = SSL_connect(ssl);
    if (!expect_fail) {
        CU_ASSERT(rv > 0);
    } else {
        CU_ASSERT(rv <= 0);
    }

    /*
     * Cleanup all the data
     */
    SSL_shutdown(ssl);
    SSL_free(ssl);
    SSL_CTX_free(ssl_ctx);

}

/*
 * This test attempts to create a SSL 3.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us894_test6 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(SSLv3_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us894_test7 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(TLSv1_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.1 connection
 * with the EST server.  This should succeed.
 */
static void us894_test8 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(TLSv1_1_client_method(), 0);
}

/*
 * This test attempts to create a TLS 1.2 connection
 * with the EST server.  This should succeed.
 */
static void us894_test9 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(TLSv1_2_client_method(), 0);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. This should succeed.
 */
static void us894_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = st_proxy_http_disable(1);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_EXPLICIT_CERT,
    US894_EXPLICIT_KEY,
    US894_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    rv = st_proxy_http_disable(0);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentication is working.
 * The certificate used is signed by the implicit cert
 * chain. This should succeed.
 */
static void us894_test11 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = st_proxy_http_disable(1);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_IMPLICIT_CERT,
    US894_IMPLICIT_KEY,
    US894_CACERTS, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    rv = st_proxy_http_disable(0);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }
}

/*
 * This test attempts to use a revoked client certificate to
 * verify CRL checks are working in the TLS layer.
 * This should fail.
 */
static void us894_test12 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_stop();
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT_AND_CRL,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_REVOKED_CERT,
    US894_REVOKED_KEY,
    US894_CACERTS,
    NULL);


    /*
     * Since the client cert has been revoked the TLS handshake
     * will fail.  The EST server should return a 401 response.
     */
    CU_ASSERT(rv == 0);

    st_proxy_stop();
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
}

/*
 * This test attempts to use a self-signed client certificate to
 * verify cert chain will reject a cert that has not been
 * signed by a valid CA.  This should fail.
 */
static void us894_test13 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_SELFSIGN_CERT,
    US894_SELFSIGN_KEY,
    US894_CACERTS, NULL);

    /*
     * Since the client cert is not signed by either the local CA
     * or external CA, the TLS handshake will fail.
     * We will not receive an HTTP status message
     * from the server.
     */
    CU_ASSERT(rv == 0);
}

/*
 * TLS anonymous cipher suites disabled
 *
 * This test case uses libcurl to test that the
 * EST server will not accept anonymous cipher
 * suites from the client.  We only test a single
 * cipher suite here.  This attempts to do a
 * simple enroll with the server.
 */
static void us894_test14 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,
                        "ADH-AES128-SHA256", NULL, NULL);
    /*
     * TLS handshake should have failed, curl should return 0
     */
    CU_ASSERT(rv == 0);
}

/*
 * Null HTTP realm when initializing server
 */
static void us894_test15 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL realm
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         NULL,
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");

    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate when initializing server
 */
static void us894_test16 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *keyin;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy using NULL server key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         NULL,
                         priv_key,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx == NULL);

    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate private key when initializing server
 */
static void us894_test17 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin;
    X509 *x;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Attempt to init EST proxy using NULL private key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         NULL,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx == NULL);

    X509_free(x);
}

/*
 * Null trusted CA chain when initializing server
 */
static void us894_test18 (void)
{
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy using NULL local CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(NULL,
                         0,
                         NULL,
                         0,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Corrupted CA chain when initializing server
 */
static void us894_test19 (void)
{
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy a corrupted CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init((unsigned char*) "Bogus CA chain",
                         14,
                         (unsigned char*) "Bogus CA chain",
                         14,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");

    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * This test case attempts simple cacerts request using
 * POST instead of GET.  It should fail.
 */
static void us894_test20 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US894_CACERT_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    fclose(outfile);

    /*
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 400);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Valid HTTP authentication credentials are
 * also provided.  This should succeed.
 */
static void us894_test21 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US894_ENROLL_URL,
                                US894_PKCS10_CT,
                                US894_PKCS10_REQ,
                                US894_UIDPWD_GOOD,
                                US894_EXPLICIT_CERT,
                                US894_EXPLICIT_KEY,
                                US894_CACERTS, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Invalid HTTP authentication credentials are
 * also provided.  This should fail with a 401 response.
 */
static void us894_test22 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US894_ENROLL_URL,
                                US894_PKCS10_CT,
                                US894_PKCS10_REQ,
                                US894_UIDPWD_BAD,
                                US894_EXPLICIT_CERT,
                                US894_EXPLICIT_KEY,
                                US894_CACERTS,
                                NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);
}

/*
 * This test attempts to enroll without using a certificate
 * to identity the client, while using a good user ID/pwd.
 * However, the EST server is setup to only perform
 * certificate authentication (HTTP auth disabled).
 * This should fail with a 401 response.
 */
static void us894_test23 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = st_proxy_http_disable(1);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL,
                        US894_PKCS10_CT,
                        US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD,
                        US894_CACERTS,
                        CURLAUTH_BASIC,
                        NULL,
                        NULL,
                        NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);

    rv = st_proxy_http_disable(0);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

}

/*
 * Test the parameters of est_proxy_set_server()
 */
static void us894_test24 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;
    EST_ERROR est_rv;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * init EST in proxy mode
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(
        cacerts,
        cacerts_len,
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        "testrealm",
        x,
        priv_key,
        "estuser",
        "estpwd");

    CU_ASSERT(ctx != NULL);

    est_rv = est_proxy_set_server(NULL, "127.0.0.1", 8080);
    CU_ASSERT(est_rv == EST_ERR_NO_CTX);

    est_rv = est_proxy_set_server(ctx, NULL, 8080);
    CU_ASSERT(est_rv == EST_ERR_INVALID_SERVER_NAME);

    est_rv = est_proxy_set_server(ctx, "127.0.0.1", 65536);
    CU_ASSERT(est_rv == EST_ERR_INVALID_PORT_NUM);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Test the parameters of est_proxy_set_auth_mode()
 */
static void us894_test25 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;
    EST_ERROR est_rv;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * init EST in proxy mode
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx != NULL);

    est_rv = est_proxy_set_auth_mode(ctx, AUTH_NONE);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);
    est_rv = est_proxy_set_auth_mode(ctx, AUTH_BASIC);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_proxy_set_auth_mode(ctx, AUTH_DIGEST);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_proxy_set_auth_mode(ctx, 0xffffffff);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);

    est_rv = est_proxy_set_auth_mode(NULL, AUTH_BASIC);
    CU_ASSERT(est_rv == EST_ERR_NO_CTX);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Test the optional setting of the CA Certs response chain in est_proxy_init()
 * test passthrough (cache disabled) mode of the CA Certs response chain.
 */
static void us894_test26 (void)
{
    long rv;
    char cmd[200];

    LOG_FUNC_NM
    ;

    st_proxy_stop();
    SLEEP(1);

    /*
     * restart the proxy without passing the ca certs response change parameter
     * param 5
     */
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        NULL,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
    SLEEP(1);

    outfile = fopen(test26_outfile, "w");
    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &write_func);
    fclose(outfile);

    /*
     * we expect the server to respond with a 200
     */
    CU_ASSERT(rv == 200);

    sprintf(
        cmd,
        "openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs",
        test26_outfile);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * restart the proxy and include the CA Cert response chain
     */
    st_proxy_stop();
    SLEEP(1);
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
    SLEEP(1);
}

/*
 * Test the passing of bad userid/password values to est_proxy_init to make sure
 * they're error checked.
 */
static void us894_test27 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy using NULL userid
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(
        cacerts,
        cacerts_len,
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        "estrealm",
        x,
        priv_key,
        NULL,
        "estpwd");

    CU_ASSERT(ctx == NULL);

    ctx =
            est_proxy_init(
                cacerts,
                cacerts_len,
                cacerts,
                cacerts_len,
                EST_CERT_FORMAT_PEM,
                "estrealm",
                x,
                priv_key,
                "bad_userid_too_long_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
                "estpwd");

    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us894_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us894_proxy_cacerts",
            us894_init_suite,
            us894_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }


    /* add the tests to the suite */
    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
    if ((NULL == CU_add_test(pSuite, "HTTP Basic Auth", us894_test1)) ||
        (NULL == CU_add_test(pSuite, "HTTP Basic Auth Fail", us894_test2)) ||
        (NULL == CU_add_test(pSuite, "HTTP Digest Auth", us894_test3)) ||
        (NULL == CU_add_test(pSuite, "HTTP Digest Auth Fail", us894_test4)) ||
        (NULL == CU_add_test(pSuite, "Get CA Certificates", us894_test5)) ||
        (NULL == CU_add_test(pSuite, "SSL 3.0 Fail", us894_test6)) ||
        (NULL == CU_add_test(pSuite, "TLS 1.0 Fail", us894_test7)) ||
        (NULL == CU_add_test(pSuite, "TLS 1.1", us894_test8)) ||
        (NULL == CU_add_test(pSuite, "TLS 1.2", us894_test9)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - explicit cert chain", us894_test10)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - implicit cert chain", us894_test11)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - revoked cert", us894_test12)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - self-signed cert", us894_test13)) ||
        (NULL == CU_add_test(pSuite, "Anon cipher suite disabled", us894_test14)) ||
        (NULL == CU_add_test(pSuite, "NULL Realm", us894_test15)) ||
        (NULL == CU_add_test(pSuite, "NULL server cert", us894_test16)) ||
        (NULL == CU_add_test(pSuite, "NULL server key", us894_test17)) ||
        (NULL == CU_add_test(pSuite, "NULL local CA chain", us894_test18)) ||
        (NULL == CU_add_test(pSuite, "Corrupted local CA chain", us894_test19)) ||
        (NULL == CU_add_test(pSuite, "HTTP POST cacerts", us894_test20)) ||
        (NULL == CU_add_test(pSuite, "SimpleEnroll - good HTTP auth/good Cert", us894_test21)) ||
        (NULL == CU_add_test(pSuite, "SimpleEnroll - bad HTTP auth/good Cert", us894_test22)) ||
        (NULL == CU_add_test(pSuite, "SimpleEnroll - no HTTP auth/no Cert", us894_test23)) ||
        (NULL == CU_add_test(pSuite, "Set Server Invalid parameters", us894_test24)) ||
        (NULL == CU_add_test(pSuite, "Set Auth Mode Invalid parameters", us894_test25)) ||
        (NULL == CU_add_test(pSuite, "Optional CA Chain Response", us894_test26)) ||
        (NULL == CU_add_test(pSuite, "Bad userid/password for proxy init", us894_test27)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }


    return CUE_SUCCESS;
#endif
}


