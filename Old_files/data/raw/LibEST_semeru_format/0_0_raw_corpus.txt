REQUIREMENT 38: SIMPLE ENROLL AND RE-ENROLL RESPONSE
     
If the enrollment is successful, the server response MUST contain an HTTP 200 response code with a content-type of "application/pkcs7-mime".

A successful response MUST be a certs-only CMC Simple PKI Response, as defined in [RFC5272], containing only the certificate that was issued. The HTTP content-type of "application/pkcs7-mime" with an smime-type parameter "certs-only" is used, as specified in [RFC5273].

The server MUST answer with a suitable 4xx or 5xx HTTP [RFC2616] error code when a problem occurs. A Simple PKI Response with an HTTP content-type of "application/pkcs7-mime" (see Section 4.3.2) MAY be included in the response data to convey an error response. If the content-type is not set, the response data MUST be a plaintext human- readable error message containing explanatory information describing why the request was rejected (for example, indicating that CSR attributes are incomplete).

If the server responds with an HTTP [RFC2616] 202, this indicates that the request has been accepted for processing but that a response is not yet available. The server MUST include a Retry-After header as defined for HTTP 503 responses. The server also MAY include informative human-readable content. The client MUST wait at least the specified "retry-after" time before repeating the same request. The client repeats the initial enrollment request after the appropriate "retry-after" interval has expired. The client SHOULD log or inform the end-user of this event. The server is responsible for maintaining all states necessary to recognize and handle retry operations as the client is stateless in this regard; it simply sends the same request repeatedly until it receives a different response code. All other return codes are handled as specified in HTTP [RFC2616].

If the client closes the TLS connections while waiting for the Retry- After time to expire, then the client initiates a new TLS connection and performs all applicable security checks. If the client has already generated a CSR that includes linking identity and POP information (Section 3.5), then the CSR will need to be recreated to incorporate the tls-unique from the new, redirected session. Note: the key pair need not be regenerated. These are processing and interface burdens on the client. EST server administrators are advised to take this into consideration.

The EST client MAY also make the certificate response, and associated private key, available to end-entity software for use as an end-entity certificate.
REQUIREMENT 10: SERVER KEY GENERATION
     
The EST client can request a server-generated certificate and key pair (see Section 4.4).
REQUIREMENT 11: FULL PKI REQUEST MESSAGES
     
Full PKI Request [RFC5272] messages can be transported via EST using the Full CMC Request function. This affords access to functions not provided by the Simple Enrollment functions. Full PKI Request messages are defined in Sections 3.2 and 4.2 of [RFC5272]. See Section 4.3 for a discussion of how EST provides a transport for these messages.
REQUIREMENT 39: FULL CMC
     
An EST client can request a certificate from an EST server with an HTTPS POST using the operation path value of "/fullcmc". Support for the /fullcmc function is OPTIONAL for both clients and servers.
REQUIREMENT 13: PROTOCOL DESIGN AND LAYERING
     
Figure 2 provides an expansion of Figure 1, describing how the layers are used. Each aspect is described in more detail in the sections that follow.

EST Layering:

Protocols and uses:


   +----------------------------------------------------+
   |                                                    |
   | Message types:                                     |
   |   - "Simple PKI" messages                          |
   |     (incorporates proof-of-possession)             |
   |   - CA certificate retrieval                       |
   |   - "Full PKI" messages (OPTIONAL)                 |
   |     (incorporates proof-of-possession)             |
   |   - CSR Attributes Request (OPTIONAL)              |
   |   - Server-generated key request (OPTIONAL)        |
   |                                                    |
   +----------------------------------------------------+
   |                                                    |
   | HTTP:                                              |
   |   - HTTP headers and URIs for control              |
   |      - Content-Type headers specify message type   |
   |      - Headers for control/error messages          |
   |      - URIs for selecting functions                |
   |   - Basic or Digest authentication (OPTIONAL)      |
   |                                                    |
   +----------------------------------------------------+
   |                                                    |
   | TLS for transport security:                        |
   |   - Authentication of the EST server               |
   |   - Authentication of the EST client (OPTIONAL)    |
   |   - Provides communications integrity              |
   |     and confidentiality                            |
   |   - Supplies channel-binding [RFC5929] information |
   |     to link proof-of-identity with message-based   |
   |     proof-of-possession (OPTIONAL)                 |
   |                                                    |
   +----------------------------------------------------+

                                 Figure 2

                
Specifying HTTPS as the secure transport for enrollment messages introduces two "layers" to communicate authentication and control messages: TLS and HTTP.

The TLS layer provides integrity and confidentiality during transport. The proof-of-identity is supplied by TLS handshake authentication and optionally also by the HTTP layer headers. The message type and control/error messages are included in the HTTP headers.

CMC ([RFC5272], Section 3.1) notes that "the Simple PKI Request MUST NOT be used if a proof-of-identity needs to be included". Since the TLS and HTTP layers can provide proof-of-identity for EST clients and servers, the Simple PKI message types are used.

The TLS layer certificate exchange provides a method for authorizing client enrollment requests using existing certificates. Such certificates may have been issued by the CA (from which the client is requesting a certificate), or they may have been issued under a distinct PKI (e.g., an IEEE 802.1AR Initial Device Identifier (IDevID) [IDevID] credential).

Proof-of-possession (POP) is a distinct issue from proof-of-identity and is included in the Simple PKI message type as described in Section 3.4. A method of linking proof-of-identity and proof-of-possession is described in Section 3.5.

This document also defines transport for CMC [RFC5272] that complies with the CMC Transport Protocols [RFC5273]. CMC's POP and proof-of-identity mechanisms are defined in CMC, but the mechanisms here can also be used in conjunction with those mechanisms in "Full PKI" messages.

During protocol exchanges, different certificates can be used. The following table provides an informative overview. End-entities can have one or more certificates of each type listed in Figure 3 and use one or more trust anchor databases of each type listed in Figure 4.

Certificates and their corresponding uses:


   +--------------+--------------------+-------------------------------+
   | Certificate  | Issuer             | Use and section references    |
   +==============+====================+===============================+
   | EST server   | The CA served by   | Presented by the EST server   |
   | certificate  | the EST server     | during the TLS handshake.     |
   |              |                    |                               |
   |              |                    | Section 3.3.1                 |
   +--------------+--------------------+-------------------------------+
   | EST server   | A CA               | Presented by the EST server   |
   | certificate  | authenticatable by | during the TLS handshake.     |
   |              | a third-party TA,  |                               |
   |              | e.g., a web server | Section 3.3.1 and             |
   |              | CA                 | Security Considerations       |
   +--------------+--------------------+-------------------------------+
   | Third-party  | A CA               | Presented by the EST client   |
   | EST client   | authenticatable by | to the EST server by clients  |
   | certificate  | a third-party TA,  | that have not yet enrolled.   |
   |              | e.g., a device     |                               |
   |              | manufacturer       | Section 3.3.2                 |
   +--------------+--------------------+-------------------------------+
   | EST client   | The CA served by   | Presented to the EST server   |
   | certificate  | the EST server     | during future EST operations. |
   |              |                    |                               |
   |              |                    | Section 3.3.2                 |
   +--------------+--------------------+-------------------------------+
   | End-entity   | The CA served by   | Clients can obtain certs      |
   | certificate  | the EST server     | that are intended for         |
   |              |                    | non-EST uses.  This includes  |
   |              |                    | certs that cannot be used     |
   |              |                    | for EST operations.           |
   |              |                    |                               |
   |              |                    | Section 4.2.3                 |
   +--------------+--------------------+-------------------------------+


                                 Figure 3

                
Trust anchor databases and their corresponding uses:

  

   +--------------+----------------------------------------------------+
   | TA database  | Use and section references                         |
   +==============+====================================================+
   | EST server   | EST servers use this TA database to authenticate   |
   | Explicit     | certificates issued by the EST CA, including EST   |
   | TA database  | client certificates during enroll/re-enroll        |
   |              | operations.                                        |
   |              |                                                    |
   |              | Section 3.3.2                                      |
   +--------------+----------------------------------------------------+
   | EST server   | EST servers use this TA database to authenticate   |
   | Implicit     | certificates issued by third-party TAs;            |
   | TA database  | e.g., EST client certificates issued by a device   |
   |              | manufacturer.                                      |
   |              | An Implicit TA database can be disabled.           |
   |              |                                                    |
   |              | Section 3.3.2                                      |
   +--------------+----------------------------------------------------+
   | EST client   | EST clients use this TA database to authenticate   |
   | Explicit     | certificates issued by the EST CA, including EST   |
   | TA database  | server certificates.                               |
   |              |                                                    |
   |              | Sections 3.1, 3.3.1, 3.6.1, and 4.1.1              |
   +--------------+----------------------------------------------------+
   | EST client   | EST clients use this TA database to                |
   | Implicit     | authenticate an EST server that uses an externally |
   | TA database  | issued certificate.                                |
   |              | An Implicit TA database can be disabled.           |
   |              |                                                    |
   |              | Sections 3.1, 3.3.1, 3.6.2, and                    |
   |              | Security Considerations                            |
   +--------------+----------------------------------------------------+


                                 Figure 4

  
REQUIREMENT 16: HTTP HEADERS FOR CONTROL
     
The HTTP Status value is used to communicate success or failure of an EST function. HTTP authentication is used by a client when requested by the server.

The media types specified in the HTTP Content-Type header indicate which EST message is being transferred. Media types used by EST are specified in Section 3.2.4.

HTTP redirections (3xx status codes) to the same web origin (see [RFC6454]) SHOULD be handled by the client without user input so long as all applicable security checks (Sections 3.3 and 3.6) have been enforced on the initial connection. The client initiates a new TLS connection and performs all applicable security checks when redirected to other web origin servers. Redirections to other web origins require the EST client to obtain user input for non-GET or HEAD requests as specified in [RFC2616]. Additionally, if the client has already generated a CSR that includes linking identity and POP information (Section 3.5), then the CSR will need to be recreated to incorporate the tls-unique from the new, redirected session. Note: the key pair need not be regenerated. These are processing and interface burdens on the client. EST server administrators are advised to take this into consideration.
REQUIREMENT 17: HTTP URIS FOR CONTROL
     
The EST server MUST support the use of the path-prefix of "/.well- known/" as defined in [RFC5785] and the registered name of "est". Thus, a valid EST server URI path begins with "https://www.example.com/.well-known/est". Each EST operation is indicated by a path-suffix that indicates the intended operation:

Operations and their corresponding URIs:


   +------------------------+-----------------+-------------------+
   | Operation              |Operation path   | Details           |
   +========================+=================+===================+
   | Distribution of CA     | /cacerts        | Section 4.1       |
   | Certificates (MUST)    |                 |                   |
   +------------------------+-----------------+-------------------+
   | Enrollment of          | /simpleenroll   | Section 4.2       |
   | Clients (MUST)         |                 |                   |
   +------------------------+-----------------+-------------------+
   | Re-enrollment of       | /simplereenroll | Section 4.2.2     |
   | Clients (MUST)         |                 |                   |
   +------------------------+-----------------+-------------------+
   | Full CMC (OPTIONAL)    | /fullcmc        | Section 4.3       |
   +------------------------+-----------------+-------------------+
   | Server-Side Key        | /serverkeygen   | Section 4.4       |
   | Generation (OPTIONAL)  |                 |                   |
   +------------------------+-----------------+-------------------+
   | CSR Attributes         | /csrattrs       | Section 4.5       |
   | (OPTIONAL)             |                 |                   |
   +------------------------+-----------------+-------------------+

                                 Figure 5

                
The operation path (Figure 5) is appended to the path-prefix to form the URI used with HTTP GET or POST to perform the desired EST operation. An example valid URI absolute path for the "/cacerts" operation is "/.well-known/est/cacerts". To retrieve the CA's certificates, the EST client would use the following HTTP request-line:

GET /.well-known/est/cacerts HTTP/1.1

Likewise, to request a new certificate in this example scheme, the EST client would use the following request-line:

POST /.well-known/est/simpleenroll HTTP/1.1

The use of distinct operation paths simplifies implementation for servers that do not perform client authentication when distributing /cacerts responses.

An EST server MAY provide service for multiple CAs as indicated by an OPTIONAL additional path segment between the registered application name and the operation path. To avoid conflict, the CA label MUST NOT be the same as any defined operation path segment. The EST server MUST provide services regardless of whether the additional path segment is present. The following are three example valid URIs:

https://www.example.com/.well-known/est/cacerts
 
https://www.example.com/.well-known/est/arbitraryLabel1/cacerts
 
https://www.example.com/.well-known/est/arbitraryLabel2/cacerts
In this specification, the distinction between enroll and renew/rekey is explicitly indicated by the HTTP URI. When requesting /fullcmc operations, CMC [RFC5272] uses the same messages for certificate renewal and certificate rekey.

An EST server can provide additional services using other URIs.
REQUIREMENT 15: HTTP LAYER
     
HTTP is used to transfer EST messages. URIs are defined for handling each media type (i.e., message type) as described in Section 3.2.2. HTTP is also used for client authentication services when TLS client authentication is not available, due to the lack of a client certificate suitable for use by TLS (see Section 3.2.3). HTTP authentication can also be used in addition to TLS client authentication if the EST server wishes additional authentication information, as noted in Section 2.2.3. Registered media types are used to convey EST messages as specified in Figure 6.

HTTP 1.1 [RFC2616] and above support persistent connections. As described in Section 8.1 of RFC 2616, persistent connections may be used to reduce network and processing loads associated with multiple HTTP requests. EST does not require or preclude persistent HTTP connections.
REQUIREMENT 29: CLIENT AUTHORIZATION
     
The decision to issue a certificate to a client is always controlled by local CA policy. The EST server configuration reflects this CA policy. This document does not specify any constraints on such policy. EST provides the EST server access to each client's authenticated identity -- e.g., the TLS client's certificate in addition to any HTTP user authentication credentials -- to help in implementing such policy.

If the client's certificate was issued by the EST CA, and it includes the id-kp-cmcRA [RFC6402] extended key usage extension, then the client is a Registration Authority (RA) as described in [RFC5272] and [RFC6402]. In this case, the EST server SHOULD apply authorization policy consistent with an RA client. For example, when handling /simpleenroll requests, the EST server could be configured to accept POP linking information that does not match the current TLS session because the authenticated EST client RA has verified this information when acting as an EST server (as specified in Section 3.5). More specific RA mechanisms are available if the EST client uses /fullcmc methods.
REQUIREMENT 28: CLIENT USE OF IMPLICIT TA DATABASE
     
When the EST client Implicit TA database is used to validate the EST server certificate, the client MUST check the configured URI and each HTTP redirection URI according to the rules specified in [RFC6125], Section 6.4. The provisioned URI or the most recent HTTP redirection URI provides the basis for authorization, and the server's authenticated identity confirms it is the authorized server.
REQUIREMENT 14: APPLICATION LAYER
     
The EST client MUST be capable of generating and parsing Simple PKI messages (see Section 4.2). Generating and parsing Full PKI messages is OPTIONAL (see Section 4.3). The client MUST also be able to request CA certificates from the EST server and parse the returned "bag" of certificates (see Section 4.1). Requesting CSR attributes and parsing the returned list of attributes is OPTIONAL (see Section 4.5).

Details of the EST client application configuration are out of scope of the protocol discussion but are necessary for understanding the prerequisites of initiating protocol operations. The EST client is RECOMMENDED to be configured with TA databases for Section 3.3.1 or with a secret key for Section 3.3.3. Implementations conforming to this standard MUST provide the ability to designate Explicit TAs. For human usability reasons, a "fingerprint" of an Explicit TA database entry can be configured for bootstrapping as discussed in Section 4.1.1. Configuration of an Implicit TA database, perhaps by its inclusion within the EST client distribution or available from the operating system, provides flexibility along with the caveats detailed in Section 6. Implementations conforming to this standard MUST provide the ability to disable use of any Implicit TA database.

The EST client is configured with sufficient information to form the EST server URI. This can be the full operation path segment (e.g., https://www.example.com/.well-known/est/ or https://www.example.com/.well-known/est/arbitraryLabel1), or the EST client can be configured with a tuple composed of the authority portion of the URI along with the OPTIONAL label (e.g., "www.example.com:80" and "arbitraryLabel1") or just the authority portion of the URI.
REQUIREMENT 58: SERVER KEY GENERATION
     
The following is an example of a valid /serverkeygen exchange. During this exchange, the EST client authenticates itself using an existing certificate issued by the CA the EST server provides services for.

The initial TLS handshake is identical to the enrollment example handshake. An example HTTP POSTed message is:

                
   POST /.well-known/est/serverkeygen HTTP/1.1
   Host: 192.0.2.1:8085
   Accept: */*
   Expect: 100-continue
   Content-Type: application/pkcs10
   Content-Transfer-Encoding: base64
   Content-Length: 963

   MIICwTCCAakCAQAwWzE+MDwGA1UEAxM1c2VydmVyS2V5R2VuIHJlcSBieSBjbGll
   bnQgaW4gZGVtbyBzdGVwIDEyIDEzNjgxNDE5NTUxGTAXBgNVBAUTEFBJRDpXaWRn
   ZXQgU046MTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvE1/6m4A/
   3/L32Suyzbf28LM9y8CQfp0aepa7o20BSfluvm8HXR44mlV+wpieM8H5n3Ub3RIo
   RUun/FllIzK9uV7UrkqJ3Yzmq2NOoTd4C+OPsV/RPTu873dhFrssDk3P4NIphlSS
   sSIkt5rhz7wYbCqCFR5Aphe/30Jx7D+xBI5Rs8e6vRS8IpuImh71BHiLfhq9AFhz
   4ZJsOUSVpUmqUogFsM7SOQ6XI4dl+djhpjT+YTJ6hQ2PXrqdch3KsTQ8c6aKs+e2
   5QJxh7O8JHVlPHo4YIxXtAYSutcbbTN5TXWFCWSrWDJ+zuMmk2yU+dio1oW7YR7V
   ftAvazJ3laQbAgMBAAGgITAfBgkqhkiG9w0BCQcxEhMQZEZzQVhtSm5qb2tCdER2
   cjANBgkqhkiG9w0BAQUFAAOCAQEAR+I0EQB+hSjrLCAjnVH6bZdHUNGszIdwx1iu
   L4n+0XK3SfEzeOMkC4T74yFGKj3redS1Ht9atYUPb0D1Qi9Jf9Co8eLblo1l19A6
   GaS798ofxIF0Pl0Dr6/GqjheqJEIbcDTAJq+kvDihyQ4GQnhosygIZHvKppQlebA
   gvp2RJSnMroPCe6RgTU9E2fmI9rin/9PyXeWFF1namp+lYbTGwjv1aE1ikhjCLlH
   veHhCdgOExPw+fqhKhHjp+0ZKBlo2bC3pqRWvDTiZuwt9UpFFfGtuxvpTp44oS/j
   M/965hWIw/5dshY/wQjIfYs07bbq2ERbpJiw9bAQY34gyoVmEQ==
                
                
Because the DecryptKeyIdentifier attribute is not included in this request, the response does not include additional encryption beyond the TLS session. The EST server response is:

                
   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: multipart/mixed ; boundary=estServerExampleBoundary
   Content-Length: 3219
                
                
This is the preamble. It is to be ignored, though it is a handy place for estServer to include an explanatory note, including contact or support information.

                
   f--estServerExampleBoundary
   Content-Type: application/pkcs8
   Content-Transfer-Encoding: base64

   MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDPwKtwJ7TjMgA+
   Poj64V909ryql0foP1hU4Yq5y8/bOP5ZTe6ArgVhUye099Ac+dfdwpyP/DESiujU
   F/dS62Vck3UWNbnw+4O38FUp0enLbbjSTud48KpEW6+FzkeuAanPGZMA1wKyrYy9
   rD5tQOOJU/CBVhUrITyYLZNYUe4agbpcR0wMtrRr2E58Mu8wQ80ryk6nkL7COk5Z
   IQdNRxldk7DFvpA85Yn1stumoGRtVLW51iXeTS1LtXwhuUb/j6Lds3vvAiJ2SiZ0
   Y3rxPlnJVyFmR8Mf2TBOjzuFqva/VLD2ayQjgaGEjq2ZWHXelQAOZ6N3lrChojEK
   FGq93yOhAgMBAAECggEBALQ5az/nYjd5x9Y3f7NMUffwl+jRRfMHCMTRx/u4AEAo
   KBYm0hFVZZtxfM+z7xlD8G0Th6gs2hFA6gwcIlUPmiX+UaOLxht0xWaLGgYmcNAm
   BiCDjLBQ7xRQCWtlcK9WCA5+HBWtcEy6244rXxh+IyWd6NT6bXC165AEcX87y/e3
   JFJ7XFNeDP656s2DmxSCci+iDte6SaEm7sJvYGu16qevJeMThcQcC9/rJjXkvpGL
   IKK2px5idad4Pb6+QHpqj3d4oM8djO6wYUvrH8XQLqAaF8Hd5lFWVU57nSYY+H79
   GaNDTfRTUL6AXr7kmMsKVFOJ0JjZExUCVMZtGiqhB6UCgYEA639OtdWLZCzyZFMe
   p7VlRddoz0VAtrU2dxnEb4cWD8Gerg8uNvp8OG84gH+6MbPwz4ZYWKCgDFqyrAlw
   SF02n9Sovh93eoJ5latSbfeYUkLtB8L/HVk5/CBGEsV9MUkdMF0+B43YlhyEDyKW
   fX2+0UeHLFgRrfpSzP2cXduEieMCgYEA4db/SIrwN2+g1Gjo3oE09kd89VGjVRer
   srbcqc7DcPXP6Lw42sx96h4jVWWqHVo3DfwFBdUb1LH2cnVXQjgDUHdNdpl01cf/
   BFYCFINi2qKMqiJYswkhYxZ1BLz/zuQTDbPFL2PgLniKFG2aFLrTS3S/tgeB5QwI
   RPigH3kfI6sCgYAPqsCJyFMlrvfRRNZdQewi4VnPsEPF4/hjpAs1gD8vfSoZWlkw
   vylUd9HCerzgYaA7rixieQ0sxTvtxhL6PXlM2NEBFQbV16hPFL6/IiG4F0u9oHNo
   eG8rHtqKlSjnBn4yoYFm70Dhe7QtbZelcaAoPCH6CUHj2St5B8ZHWDtREQKBgHNp
   wER+XIy4C2UByCANv9csaXulIOdXlXNbaCGPfOm5dWrm5ddLMf33MO9vaSRe+ku3
   Q4nbgsGLwPp1ZQZ+QZNZpMi7W6306yp4GdAJ5Pb+oww/ST0VqW5OB7dILyK4A9S4
   zkiNrf+Rsl8GM/vsDhc9rsuDwqofIAq/VHVBHNzJAoGBAOHQof5L6iGHOHcxLazx
   4MGvRTpmzU/PX6Q3QxqpetEGFEDZAaL58L67SSS3fFBnKrVAidF6llC1bAH1aoRa
   fYHUDi45xBoroy0hBwrnTKRxppua4UK75FUH5PPJfR6cCvw5stRkzIevTZHhozkX
   pM7PYH/x4BiBmgQ3bhOqTp4H
   --estServerExampleBoundary
   Content-Type: application/pkcs7-mime; smime-type=certs-only
   Content-Transfer-Encoding: base64
   MIIDRQYJKoZIhvcNAQcCoIIDNjCCAzICAQExADALBgkqhkiG9w0BBwGgggMYMIID
   FDCCAfygAwIBAgIBFjANBgkqhkiG9w0BAQUFADAbMRkwFwYDVQQDExBlc3RFeGFt
   cGxlQ0EgTndOMB4XDTEzMDUwOTIzMjU1NloXDTE0MDUwOTIzMjU1NlowLDEqMCgG
   A1UEAxMhc2VydmVyc2lkZSBrZXkgZ2VuZXJhdGVkIHJlc3BvbnNlMIIBIjANBgkq
   hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz8CrcCe04zIAPj6I+uFfdPa8qpdH6D9Y
   VOGKucvP2zj+WU3ugK4FYVMntPfQHPnX3cKcj/wxEoro1Bf3UutlXJN1FjW58PuD
   t/BVKdHpy2240k7nePCqRFuvhc5HrgGpzxmTANcCsq2Mvaw+bUDjiVPwgVYVKyE8
   mC2TWFHuGoG6XEdMDLa0a9hOfDLvMEPNK8pOp5C+wjpOWSEHTUcZXZOwxb6QPOWJ
   9bLbpqBkbVS1udYl3k0tS7V8IblG/4+i3bN77wIidkomdGN68T5ZyVchZkfDH9kw
   To87har2v1Sw9mskI4GhhI6tmVh13pUADmejd5awoaIxChRqvd8joQIDAQABo1Iw
   UDAOBgNVHQ8BAf8EBAMCBLAwHQYDVR0OBBYEFKeZixu9F+appDX2SS5HaxmV6Jr4
   MB8GA1UdIwQYMBaAFLHEaeZbowSn2Jejizu/uWqyMkI8MA0GCSqGSIb3DQEBBQUA
   A4IBAQBHhLmRAKrnTapqqBObDM9IQDQPuwW+fW1gYwZKlSm/IWIwHEZL1igXhpjj
   rf4xqpIkiJMmkaOeoXA8PFniX0/lZM9FQSM/j89CUf5dMoAqWj8s17xuXu9L/hVe
   XjjXHsL40WuDG6tMPN9vcT8tE3ruor608MKSHFX/NEM6+AaNVSUPTmB33BgYB1Wa
   E7pn3JMN6pjIxsHnF4pKi8qvoTSVVjaCEwUe8Q/fw1yvjoHoYJtyMn4v5Kb3Rt+m
   s8Yie1tcfVQrjQutqr34/IJsKdPziZwi92KZa+1958A6M9O/p5OI0up9ZXKg2DEC
   1O9qT0GyYJ6sxAyKiGTOxk6jMddDoQAxAA==
   --estServerExampleBoundary--
                
This is the epilogue. It is also to be ignored.
REQUIREMENT 8: HTTP-BASED CLIENT AUTHENTICATION
     
The EST server can optionally also request that the EST client submit a username/password using the HTTP Basic or Digest authentication methods (see Section 3.2.3). This approach is desirable if the EST client cannot be authenticated during the TLS handshake (see Section 3.3.2) or the EST server policy requires additional authentication information; see Section 3.2.3. In all cases, HTTP-based client authentication is only to be performed over a TLS-protected transport (see Section 3.3).
REQUIREMENT 9: CLIENT CERTIFICATE REISSUANCE
     
An EST client can renew/rekey its existing client certificate by submitting a re-enrollment request to an EST server. When the current EST client certificate can be used for TLS client authentication (Section 3.3.2), the client presents this certificate to the EST server for client authentication. When the to be reissued EST client certificate cannot be used for TLS client authentication, any of the authentication methods used for initial enrollment can be used. For example, if the client has an alternative certificate issued by the EST CA that can be used for TLS client authentication, then it can be used.

The certificate request message includes the same Subject and SubjectAltName as the current certificate. Name changes are requested as specified in Section 4.2.2.
REQUIREMENT 49: CSR ATTRIBUTES RESPONSE
     
If locally configured policy for an authenticated EST client indicates a CSR Attributes Response is to be provided, the server response MUST include an HTTP 200 response code. An HTTP response code of 204 or 404 indicates that a CSR Attributes Response is not available. Regardless of the response code, the EST server and CA MAY reject any subsequent enrollment requests for any reason, e.g., incomplete CSR attributes in the request.

Responses to attribute request messages MUST be encoded as the content-type of "application/csrattrs" with a Content-Transfer-Encoding of "base64" [RFC2045]. The syntax for application/csrattrs body is as follows:

CsrAttrs ::= SEQUENCE SIZE (0..MAX) OF AttrOrOID

AttrOrOID ::= CHOICE (oid OBJECT IDENTIFIER, attribute Attribute }

Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE { type ATTRIBUTE.&id({IOSet}), values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type}) }

An EST server includes zero or more OIDs or attributes [RFC2986] that it requests the client to use in the certification request. The client MUST ignore any OID or attribute it does not recognize. When the server encodes CSR Attributes as an empty SEQUENCE, it means that the server has no specific additional information it desires in a client certification request (this is functionally equivalent to an HTTP response code of 204 or 404).

If the CA requires a particular crypto system or use of a particular signature scheme (e.g., certification of a public key based on a certain elliptic curve, or signing using a certain hash algorithm) it MUST provide that information in the CSR Attribute Response. If an EST server requires the linking of identity and POP information (see Section 3.5), it MUST include the challengePassword OID in the CSR Attributes Response.

The structure of the CSR Attributes Response SHOULD, to the greatest extent possible, reflect the structure of the CSR it is requesting. Requests to use a particular signature scheme (e.g. using a particular hash function) are represented as an OID to be reflected in the SignatureAlgorithm of the CSR. Requests to use a particular crypto system (e.g., certification of a public key based on a certain elliptic curve) are represented as an attribute, to be reflected as the AlgorithmIdentifier of the SubjectPublicKeyInfo, with a type indicating the algorithm and the values indicating the particular parameters specific to the algorithm. Requests for descriptive information from the client are made by an attribute, to be represented as Attributes of the CSR, with a type indicating the [RFC2985] extensionRequest and the values indicating the particular attributes desired to be included in the resulting certificate's extensions.

The sequence is Distinguished Encoding Rules (DER) encoded [X.690] and then base64 encoded (Section 4 of [RFC4648]). The resulting text forms the application/csrattr body, without headers.

For example, if a CA requests a client to submit a certification request containing the challengePassword (indicating that linking of identity and POP information is requested; see Section 3.5), an extensionRequest with the Media Access Control (MAC) address ([RFC2307]) of the client, and to use the secp384r1 elliptic curve and to sign with the SHA384 hash function. Then, it takes the following:


         OID:        challengePassword (1.2.840.113549.1.9.7)

         Attribute:  type = extensionRequest (1.2.840.113549.1.9.14)
                     value = macAddress (1.3.6.1.1.1.1.22)

         Attribute:  type = id-ecPublicKey (1.2.840.10045.2.1)
                     value = secp384r1 (1.3.132.0.34)

         OID:        ecdsaWithSHA384 (1.2.840.10045.4.3.3)

                    
and encodes them into an ASN.1 SEQUENCE to produce:


       30 41 06 09 2a 86 48 86 f7 0d 01 09 07 30 12 06 07 2a 86 48 ce 3d
       02 01 31 07 06 05 2b 81 04 00 22 30 16 06 09 2a 86 48 86 f7 0d 01
       09 0e 31 09 06 07 2b 06 01 01 01 01 16 06 08 2a 86 48 ce 3d 04 03
       03

                    
and then base64 encodes the resulting ASN.1 SEQUENCE to produce:

MEEGCSqGSIb3DQEJBzASBgcqhkjOPQIBMQcGBSuBBAAiMBYGCSqGSIb3DQEJDjEJ
       BgcrBgEBAQEWBggqhkjOPQQDAw==
REQUIREMENT 48: CSR ATTRIBUTES REQUEST
     
The EST client requests a list of CA-desired CSR attributes from the CA by sending an HTTPS GET message to the EST server with an operations path of "/csrattrs".
REQUIREMENT 52: REFERENCES
     
                
   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", RFC 2045, November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2585]  Housley, R. and P. Hoffman, "Internet X.509 Public Key
              Infrastructure Operational Protocols: FTP and HTTP", RFC
              2585, May 1999.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, June 1999.

   [RFC2633]  Ramsdell, B., "S/MIME Version 3 Message Specification",
              RFC 2633, June 1999.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS https://tools.ietf.org/html/rfc7030#10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              November 2000.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005.
                
   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4108]  Housley, R., "Using Cryptographic Message Syntax (CMS) to
              Protect Firmware Packages", RFC 4108, August 2005.

   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", RFC 4210, September 2005.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346, April 2006.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, October 2006.

   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 5077, January 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5272]  Schaad, J. and M. Myers, "Certificate Management over CMS
              (CMC)", RFC 5272, June 2008.

   [RFC5273]  Schaad, J. and M. Myers, "Certificate Management over CMS
              (CMC): Transport Protocols", RFC 5273, June 2008.

   [RFC5274]  Schaad, J. and M. Myers, "Certificate Management Messages
              over CMS (CMC): Compliance Requirements", RFC 5274, June
              2008.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, September 2009.

   [RFC5746]  Rescorla, E., Ray, M., Dispensa, S., and N. Oskov,
              "Transport Layer Security (TLS) Renegotiation Indication
              Extension", RFC 5746, February 2010.

   [RFC5751]  Ramsdell, B. and S. Turner, "Secure/Multipurpose Internet
              Mail Extensions (S/MIME) Version 3.2 Message
              Specification", RFC 5751, January 2010.            
   [RFC5785]  Nottingham, M. and E. Hammer-Lahav, "Defining Well-Known
              Uniform Resource Identifiers (URIs)", RFC 5785, April
              2010.

   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", RFC 5929, July 2010.

   [RFC5958]  Turner, S., "Asymmetric Key Packages", RFC 5958, August
              2010.

   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, March 2011.

   [RFC6402]  Schaad, J., "Certificate Management over CMS (CMC)
              Updates", RFC 6402, November 2011.

   [RFC6454]  Barth, A., "The Web Origin Concept", RFC 6454, December
              2011.

   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", BCP 13, RFC
              6838, January 2013.

   [X.680]    ITU-T Recommendation X.680 (2008) | ISO/IEC 8824-1:2008,
              "Abstract Syntax Notation One (ASN.1): Specification of
              basic notation", November 2008,
              <http://www.itu.int/rec/T-REC-X.680-200811-I/en>.

   [X.690]    ITU-T Recommendation X.690 (2008) | ISO/IEC 8825-1:2008,
              "ASN.1 encoding rules: Specification of Basic Encoding
              Rules (BER), Canonical Encoding Rules (CER) and
              Distinguished Encoding Rules (DER)", November 2008,
              <http://www.itu.int/rec/T-REC-X.690-200811-I/en>.             
                
REQUIREMENT 46: SERVER-SIDE KEY GENERATION RESPONSE
     
If the request is successful, the server response MUST have an HTTP 200 response code with a content-type of "multipart/mixed" consisting of two parts: one part is the private key data and the other part is the certificate data.

The format in which the private key data part is returned is dependent on whether the private key is being returned with additional encryption on top of that provided by TLS.

If additional encryption is not being employed, the private key data MUST be placed in an "application/pkcs8". An "application/pkcs8" part consists of the base64-encoded DER-encoded [X.690] PrivateKeyInfo with a Content-Transfer-Encoding of "base64" [RFC2045].

If additional encryption is being employed, the private key is placed inside of a CMS SignedData. The SignedData is signed by the party that generated the private key, which may or may not be the EST server or the EST CA. The SignedData is further protected by placing it inside of a CMS EnvelopedData, as described in Section 4 of [RFC5958]. The following list shows how the EncryptedData is used, depending on the type of protection key specified by the client.

If the client specified a symmetric encryption key to protect the server-generated private key, the EnvelopedData content is encrypted using the secret key identified in the request. The EnvelopedData RecipientInfo field MUST indicate the key-encryption kekri key management technique. The values are as follows: version is set to 4, key-encryption key identifier (kekid) is set to the value of the DecryptKeyIdentifier from Section 4.4.1.1; keyEncryptionAlgorithm is set to one of the key wrap algorithms that the client included in the SMIMECapabilities accompanying the request; and encryptedKey is the encrypted key.
 
If the client specified an asymmetric encryption key suitable for key transport operations to protect the server-generated private key, the EnvelopedData content is encrypted using a randomly generated symmetric encryption key. The cryptographic strength of the symmetric encryption key SHOULD be equivalent to the client- specified asymmetric key. The EnvelopedData RecipientInfo field MUST indicate the KeyTransRecipientInfo (ktri) key management technique. In KeyTransRecipientInfo, the RecipientIdentifier (rid) is either the subjectKeyIdentifier copied from the attribute defined in Section 4.4.1.2 or the server determines an associated issuerAndSerialNumber from the attribute; version is derived from the choice of rid [RFC5652], keyEncryptionAlgorithm is set to one of the key wrap algorithms that the client included in the SMIMECapabilities accompanying the request, and encryptedKey is the encrypted key.
 
If the client specified an asymmetric encryption key suitable for key agreement operations to protect the server-generated private key, the EnvelopedData content is encrypted using a randomly generated symmetric encryption key. The cryptographic strength of the symmetric encryption key SHOULD be equivalent to the client- specified asymmetric key. The EnvelopedData RecipientInfo field MUST indicate the KeyAgreeRecipientInfo (kari) key management technique. In the KeyAgreeRecipientInfo type, version, originator, and user keying material (ukm) are as in [RFC5652], and keyEncryptionAlgorithm is set to one of the key wrap algorithms that the client included in the SMIMECapabilities accompanying the request. The recipient's key identifier is either copied from the attribute defined in Section 4.4.1.2 to subjectKeyIdentifier or the server determines an IssuerAndSerialNumber that corresponds to the value provided in the attribute.
In all three additional encryption cases, the EnvelopedData is returned in the response as an "application/pkcs7-mime" part with an smime-type parameter of "server-generated-key" and a Content- Transfer-Encoding of "base64".

The certificate data part is an "application/pkcs7-mime" and exactly matches the certificate response to /simpleenroll.

When rejecting a request, the server MUST specify either an HTTP 4xx error or an HTTP 5xx error. If the content-type is not set, the response data MUST be a plaintext human-readable error message.
REQUIREMENT 2: TERMINOLOGY
     
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].

It is assumed that the reader is familiar with the terms and concepts described in Public Key Cryptography Standard (PKCS) #10 [RFC2986], HTTPS [RFC2818], CMP [RFC4210], CMC [RFC5272][RFC5273][RFC5274], and TLS [RFC4346].

In addition to the terms defined in the terminology section of CMC [RFC5272], the following terms are defined for clarity:

EST CA: For certificate issuing services, the EST CA is reached through the EST server; the CA could be logically "behind" the EST server or embedded within it.

Third-Party Trust Anchor: Any trust anchor (TA) that is not authoritative for the PKI hierarchy for which the EST server is providing services.

Explicit Trust Anchor: Any TA that is explicitly configured on the client or server for use during EST TLS authentication; for example, a TA that is manually configured on the EST client or bootstrapped as described in Section 4.1.1. (See more details in Sections 3.6 and 6.)

Implicit Trust Anchor: Any third-party TA that is available on the client or server for use during TLS authentication but is not specifically indicated for use during EST TLS authentication; for example, TAs commonly used by web browsers to authenticate web servers or TAs used by servers to authenticate manufacturer- installed client credentials (such as certificates populated into cable modems or routers in the factory). The authorization model for these TAs is different from the authorization model for Explicit Trust Anchors. (See more details in Sections 3.6.1, 3.6.2, and 6).

Certificate-Less TLS: Certificate-less TLS cipher suites provide a way to perform mutual authentication in situations where neither the client nor server have certificates or are willing to use them. The credential used for authentication is a word, phrase, code, or key that is shared between the client and server. The credential must be uniquely shared between the client and server in order to provide authentication of an individual client to an individual server.
REQUIREMENT 47: CSR ATTRIBUTES
     
CA policy may allow inclusion of client-provided attributes in certificates that it issues, and some of these attributes may describe information that is not available to the CA. In addition, a CA may desire to certify a certain type of public key and a client may not have a priori knowledge of that fact. Therefore, clients SHOULD request a list of expected attributes that are required, or desired, by the CA in an enrollment request or if dictated by local policy.

The EST server SHOULD NOT require client authentication or authorization to reply to this request.

Requesting CSR attributes is optional, but clients are advised that CAs may refuse enrollment requests that are not encoded according to the CA's policy.
REQUIREMENT 53: INFORMATIVE REFERENCES
     

   [IDevID]   IEEE Standards Association, "IEEE 802.1AR Secure Device
              Identifier", December 2009, <http://standards.ieee.org/
              findstds/standard/802.1AR-2009.html>.

   [RFC2307]  Howard, L., "An Approach for Using LDAP as a Network
              Information Service", RFC 2307, March 1998.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818, May 2000.

   [RFC2985]  Nystrom, M. and B. Kaliski, "PKCS https://tools.ietf.org/html/rfc7030#9: Selected Object
              Classes and Attribute Types Version 2.0", RFC 2985,
              November 2000.

   [RFC3394]  Schaad, J. and R. Housley, "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, September 2002.

   [RFC5054]  Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin,
              "Using the Secure Remote Password (SRP) Protocol for TLS
              Authentication", RFC 5054, November 2007.

   [RFC5967]  Turner, S., "The application/pkcs10 Media Type", RFC 5967,
              August 2010.

   [RFC6403]  Zieglar, L., Turner, S., and M. Peck, "Suite B Profile of
              Certificate Management over CMS", RFC 6403, November 2011.

   [SHS]      National Institute of Standards and Technology, "Secure
              Hash Standard (SHS)", Federal Information Processing
              Standard Publication 180-4, March 2012,
              <http://csrc.nist.gov/publications/fips/
              fips180-4/fips-180-4.pdf>.

   [SP-800-57-Part-1]
              National Institute of Standards and Technology,
              "Recommendation for Key Management - Part 1: General
              (Revision 3)", July 2012,
              <http://csrc.nist.gov/publications/nistpubs/800-57/
              sp800-57_part1_rev3_general.pdf>.
                
REQUIREMENT 45: REQUESTS FOR ASYMMETRIC ENCRYPTION OF THE PRIVATE KEY
     
To specify an asymmetric encryption key to be used to encrypt the server-generated private key, the client MUST include an AsymmetricDecryptKeyIdentifier attribute. The AsymmetricDecryptKeyIdentifier attribute is defined as:

id-aa-asymmDecryptKeyID OBJECT IDENTIFIER ::= { id-aa 54 }

The asymmetric-decrypt-key-identifier attribute values have ASN.1 type AsymmetricDecryptKeyIdentifier (where ASN.1 is defined in [X.680])::

AsymmetricDecryptKeyIdentifier ::= OCTET STRING

If the server does not have a public key matching the identifier specified by the client, the request MUST be terminated and an error returned to the client. Distribution of the key specified by the AsymmetricDecryptKeyIdentifier to the key generator and the client is outside the scope of this document. If the key identified is bound to an X.509 certificate, then the key MUST either explicitly support keyTransport or keyAgreement or its use MUST be unrestricted.
REQUIREMENT 51: SECURITY CONSIDERATIONS
     
Support for Basic authentication, as specified in HTTP [RFC2617], allows the server access to a client's cleartext password. This provides support for legacy username/password databases but requires exposing the plaintext password to the EST server. Use of a PIN or one-time password can help mitigate such exposure, but it is RECOMMENDED that EST clients use such credentials only once to obtain a client certificate (that will be used during future interactions with the EST server).

When a client uses the Implicit TA database for certificate validation (see Section 3), then authorization proceeds as specified in Section 3.6.2. In this situation, the client has validated the server as being a responder that is certified by a third party for the URI configured, but it cannot verify that the responder is authorized to act as an RA for the PKI in which the client is trying to enroll. Clients using an Implicit Trust Anchor database are RECOMMENDED to use only TLS-based client authentication (to prevent exposing HTTP-based client authentication information). It is RECOMMENDED that such clients include "Linking Identity and POP Information" (Section 3.5) in requests (to prevent such requests from being forwarded to a real EST server by a man in the middle). It is RECOMMENDED that the Implicit Trust Anchor database used for EST server authentication be carefully managed to reduce the chance of a third-party CA with poor certification practices from being trusted. Disabling the Implicit Trust Anchor database after successfully receiving the Distribution of CA certificates response (Section 4.1.3) limits any vulnerability to the first TLS exchange.

Certificate-less TLS cipher suites that maintain security and perform the mutual authentication necessary for enrollment have the following properties:

the only information leaked by an active attack is whether or not a single guess of the secret is correct.
 
any advantage an adversary gains is through interaction and not computation.
 
it is possible to perform countermeasures, such as exponential backoff after a certain number of failed attempts, to frustrate repeated active attacks.
Using a certificate-less cipher suite that does not have the properties listed above would render the results of enrollment void and potentially result in certificates being issued to unauthenticated and/or unauthorized entities.

When using a certificate-less TLS cipher suite, the shared secret used for authentication and authorization cannot be shared with an entity that is not a party to the exchange: someone other than the client and the server. Any additional sharing of secrets voids the security afforded by a certificate-less cipher suite. Exposure of a shared secret used by a certificate-less cipher suite to a third party enables client impersonation that can result in corruption of a client's trust anchor database.

TLS cipher suites that include "_EXPORT_" and "_DES_" in their names MUST NOT be used. These ciphers do not offer a sufficient level of protection; 40-bit crypto in 2013 doesn't offer acceptable protection, and the use of DES is deprecated.

As described in CMC, Section 6.7 of [RFC5272], "For keys that can be used as signature keys, signing the certification request with the private key serves as a POP on that key pair". The inclusion of tls- unique within the certification request links the proof-of-possession to the TLS proof-of-identity by enforcing that the POP operation occurred while the TLS session was active. This implies to the server that the authenticated client currently has access to the private key. If the authenticated client is known to have specific capabilities, such as hardware protection for authentication credentials and key storage, this implication is strengthened but not proven.

The server-side key generation method allows keys to be transported over the TLS connection to the client without any application-layer protection. The distribution of private key material is inherently risky. Private key distribution uses the encryption mode of the negotiated TLS cipher suite. Keys are not protected by preferred key wrapping methods such as AES Key Wrap [RFC3394] or as specified in [RFC5958] as encryption of the private key beyond that provided by TLS is optional. It is RECOMMENDED that EST servers not support this operation by default. It is RECOMMENDED that clients not request this service unless there is a compelling operational benefit. Use of an Implicit Trust Anchor database is NOT RECOMMENDED when server-side key generation is employed. The use of an encrypted CMS Server-Side Key Generation Response is RECOMMENDED.

Regarding the CSR attributes that the CA may list for inclusion in an enrollment request, there are no real inherent security issues with the content being conveyed, but an adversary who is able to interpose herself into the conversation could exclude attributes that a server may want, include attributes that a server may not want, and render meaningless other attributes that a server may want.

ASN.1 encoding rules (e.g., DER and BER) have a type-length-value structure, and it is easy to construct malicious content with invalid length fields that can cause buffer overrun conditions. ASN.1 encoding rules allow for arbitrary levels of nesting, which may make it possible to construct malicious content that will cause a stack overflow. Interpreters of ASN.1 structures should be aware of these issues and should take appropriate measures to guard against buffer overflows and stack overruns in particular, and malicious content in general.
REQUIREMENT 1
     
This document profiles certificate enrollment for clients using Certificate Management over CMS (CMC) [RFC5272] messages over a secure transport. Enrollment over Secure Transport (EST) describes the use of Transport Layer Security (TLS) 1.1 [RFC4346], 1.2 [RFC5246], or any future version) and Hypertext Transfer Protocol (HTTP) [RFC2616] to provide an authenticated and authorized channel for Simple Public Key Infrastructure (PKI) Requests and Responses [RFC5272]. Architecturally, the EST service is located between a Certification Authority (CA) and a client. It performs several functions traditionally allocated to the Registration Authority (RA) role in a PKI. The nature of communication between an EST server and a CA is not described in this document. EST adopts the Certificate Management Protocol (CMP) [RFC4210] model for CA certificate rollover, but it does not use the CMP message syntax or protocol. EST servers are extensible in that new functions may be defined to provide additional capabilities not specified in CMC [RFC5272], and this document defines two such extensions: one for requesting Certificate Signing Request attributes and another for requesting server-generated keys. EST specifies how to transfer messages securely via HTTP over TLS (HTTPS) [RFC2818], where the HTTP headers and media types are used in conjunction with TLS. HTTPS operates over TCP; this document does not specify EST over HTTP/Datagram Transport Layer Security/User Datagram Protocol (HTTP/DTLS/UDP). With a suitable specification for combining HTTP, DTLS, and UDP, there are no EST requirements that would prevent it from working over such a stack. Figure 1 shows how the layers build upon each other.

EST Layering: Protocols:
   +--------------------------------------------+
   |                                            |
   | EST request/response messages              |
   |                                            |
   +--------------------------------------------+
   |                                            |
   | HTTP for message transfer and signaling    |
   |                                            |
   +--------------------------------------------+
   |                                            |
   | TLS for transport security                 |
   |                                            |
   +--------------------------------------------+
   |                                            |
   | TCP for transport                          |
   |                                            |
   +--------------------------------------------+
Figure 1
REQUIREMENT 50: IANA CONSIDERATIONS
     
Section 4.4.1.2 defines an OID that has been registered in an arc delegated by the IANA to the PKIX working group.

IANA has registered the following:

IANA updated the well-known URI registry with the following filled-in template from [RFC5785].

URI suffix: est

Change controller: IETF

IANA has updated the "Application Media Types" registry with the following filled-in templates from [RFC6838].

The media subtype for CSR attributes in a CSR Attributes Response is application/csrattrs.

                
       Type name: application

       Subtype name: csrattrs

       Required parameters: None

       Optional parameters: None

       Encoding considerations: binary;

       Security Considerations:

         Clients request a list of attributes that servers wish to be in
         certification requests.  The request/response is normally done
         in a TLS-protected tunnel.

       Interoperability considerations: None

       Published specification: This memo.

       Applications which use this media type: Enrollment over Secure
       Transport (EST)

       Additional information:

         Magic number(s): None

         File extension: .csrattrs

       Person & email address to contact for further information:

         Dan Harkins <dharkins@arubanetworks.com>

       Restrictions on usage: None

       Author: Dan Harkins <dharkins@arubanetworks.com>

       Intended usage: COMMON

       Change controller: The IESG <iesg@ietf.org>
                
                
The application/pkcs7-mime content-type defines the optional "smime-type" parameter [RFC5751] with a set of specific values. This document adds another value, "server-generated-key", as the parameter value for Server-side Key Generation Response.
REQUIREMENT 40: FULL CMC REQUEST
     
If the HTTP POST to /fullcmc is not a valid Full PKI Request, the server MUST reject the message. The HTTP content-type used is "application/pkcs7-mime" with an smime-type parameter "CMC-request", as specified in [RFC5273]. The body of the message is the binary value of the encoding of the PKI Request with a Content-Transfer-Encoding of "base64" [RFC2045].
REQUIREMENT 4: OBTAINING CA CERTIFICATES
     
The EST client can request a copy of the current EST CA certificate(s) from the EST server. The EST client is assumed to perform this operation before performing other operations.

Throughout this document we assume the EST CA has a certificate that is used by the client to verify signed objects issued by the CA, e.g., certificates and certificate revocation lists (CRLs), and that a different certificate than the one used to verify signatures on certificates and CRLs is used when EST protocol communication requires additional encryption.

The EST client authenticates and verifies the authorization scope of the EST server when requesting the current CA certificate(s). As detailed in Sections 3.3.1 and 3.3.3, available options include:

Verifying the EST server's HTTPS URI against the EST server's certificate using Implicit TAs (similar to a common HTTPS exchange). This allows the EST server and client to leverage existing TAs that might be known to the EST client.
 
The client can leverage a previously distributed trust anchor specific to the EST server. This allows the EST client to use an existing, potentially older, CA certificate to request a current CA certificate.
 
For bootstrapping, the EST client can rely upon manual authentication performed by the end-user as detailed in Section 4.1.1.
 
The client can leverage the binding of a shared credential to a specific EST server with a certificate-less TLS cipher suite.
Client authentication is not required for this exchange, so it is trivially supported by the EST server.
REQUIREMENT 5: INTIAL ENROLLMENT
     
After authenticating an EST server and verifying that it is authorized to provide services to the client, an EST client can acquire a certificate for itself by submitting an enrollment request to that server.

The EST server authenticates and authorizes the EST client as specified in Sections 3.3.2, 3.3.3, and 3.7. The methods described in the normative text that are discussed in this overview include:

TLS with a previously issued client certificate (e.g., an existing certificate issued by the EST CA);
 
TLS with a previously installed certificate (e.g., manufacturer- installed certificate or a certificate issued by some other party);
 
Certificate-less TLS (e.g., with a shared credential distributed out-of-band);
 
HTTP-based with a username/password distributed out-of-band.
REQUIREMENT 55: OBTAINING CA CERTIFICATES
     
The following is an example of a valid /cacerts exchange.

During the initial TLS handshake, the client can ignore the optional server-generated "certificate request" and can instead proceed with the HTTP GET request:

                
   GET /.well-known/est/cacerts HTTP/1.1
   User-Agent: curl/7.22.0 (i686-pc-linux-gnu) libcurl/7.22.0 OpenS
   SL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
   Host: 192.0.2.1:8085
   Accept: */*
                
                
In response, the server provides the current CA certificates:

                
   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: application/pkcs7-mime
   Content-Transfer-Encoding: base64
   Content-Length: 4246

   MIIMOQYJKoZIhvcNAQcCoIIMKjCCDCYCAQExADALBgkqhkiG9w0BBwGgggwMMIIC
   +zCCAeOgAwIBAgIJAJpY3nUZO3qcMA0GCSqGSIb3DQEBBQUAMBsxGTAXBgNVBAMT
   EGVzdEV4YW1wbGVDQSBPd08wHhcNMTMwNTA5MDM1MzMxWhcNMTQwNTA5MDM1MzMx
   WjAbMRkwFwYDVQQDExBlc3RFeGFtcGxlQ0EgT3dPMIIBIjANBgkqhkiG9w0BAQEF
   AAOCAQ8AMIIBCgKCAQEAwDqpiHopaICubpRqbpEN7LqTIqWELFIA9qDDheHIKuyO
   HW/ZAP7Rl4S5ZU6gaLW/ksseBUxdmox3KNyvtyjehIofTu28eZWhgy6/LCEGWR3P
   K+fgPBA0l0JfJR/8oeXZa70oLVQc3hI4kCeqjFMs+biYH0vp/RluhftyZ5kzQyH1
   EGsRkw1/qUKkTZ8PCF8VFlYfqmUoqsaRTyZbjII4J+Y6/jEG+p7QreW9zcz4sPe8
   3c/uhwMLOWQkZtKsQtgo5CpfYMjuAmk4Q2joQq2vcxlc+WNKHf+wbrDb11ORZril
   9ISlI94oumcRz3uBG1Yg7z83hdDfasmdfbp8gOSNFQIDAQABo0IwQDAPBgNVHRMB
   Af8EBTADAQH/MB0GA1UdDgQWBBQITTKxMqATXrfc4ffpCIbt6Gsz0jAOBgNVHQ8B
   Af8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBACPnQPu5WReUGuCMS0nBOGa2tXh6
   uZP4mS3J1qEfDePam/IiU9ssyYdcDwhVvKMoP4gI/yu4XFqhdpIoy/PyD4T15MT7
   KADCxXkh5rM1IqMui7FvBKLWYGdy9sjEf90wAkBjHBe/TMO1NNw3uELyONSkHIvo
   X0pu6aPmm/moIMyGi46niFse1iWlXXldGLkOQsh0e7U+wpBX07QpOr2KB2+Yf+uA
   KY1SWzEG23bUxXlvcbUMgANDGj5r6z+niKL0VlApip/iCuVEEOcZ91UlmJjVLQWA
   x6ie+v84oM+pIojiGM0C4XWcVlKKEgcMOsN3S4lvm8Ptpq0GLoIJY8NTD20wggMD
   MIIB66ADAgECAgEBMA0GCSqGSIb3DQEBBQUAMBsxGTAXBgNVBAMTEGVzdEV4YW1w
   bGVDQSBPd08wHhcNMTMwNTA5MDM1MzMyWhcNMTQwNTA5MDM1MzMyWjAbMRkwFwYD
   VQQDExBlc3RFeGFtcGxlQ0EgTndPMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
   CgKCAQEAnn3rZ3rMJHwf7MD9K4mubxHAvtdnrsQf5OfgtMhRIL4aePNhAdgPyj8C
   loxOgD3UTV+dQ1ViOzVxPN7acikoOnkIdRpjpOpkyMo+KkvHMQXGnQTbsMAv1qWt
   9S12DMpo0GOA1e4Ge3ud5YPOTR/q6PvjN51IEwYKksG7CglwZwB+5JbwhYr2D/0u
   btGltriRVixPWrvt+wz/ITp5rcjh/8RS3LE8tQy3kTNhJF3Y/esR2sSgOiPNgIto
   CATysbaINEPr4MemqML4tDpR/aG9y+8Qe7s1LyMFvDletp2mmBykAC/7nOat/pwU
   lB0sN524D1XAgz8ZKvWrkh+ZaOr3hwIDAQABo1IwUDAOBgNVHQ8BAf8EBAMCBLAw
   HQYDVR0OBBYEFLHEaeZbowSn2Jejizu/uWqyMkI8MB8GA1UdIwQYMBaAFAhNMrEy
   oBNet9zh9+kIhu3oazPSMA0GCSqGSIb3DQEBBQUAA4IBAQCLDkL7aLNV6hSOkIqH
   q+shV9YLO56/tj00vY/jV5skgDHk5d0B+OGortKVuGa57+v0avTrlJns3bNW8Ntv
   zkDEhmd00Ak02aPsi4wRHLFgttUf9HdEHAuTkAESPTU43DiptjkfHhtBMfsFrCkd
   sxWzCz+prDOMHYfUEkhRVV++1zyGEX6ov1Ap2IU2p3E+ASihL/amxTEQAsbwjUTI
   R52zoL6nMPzpbKeZi2M0eEBVF8sDueA9Hjo6woLjgJqV0/yc5vC2HAxUOhx0cWTY
   GcRBgL/yOyQLKiY5TKBH951OjQ4vhF2HmcoO7DkcNLYJOge16ssx4ogBHul20VgF
   XJJjMIIDAzCCAeugAwIBAgIBAjANBgkqhkiG9w0BAQUFADAbMRkwFwYDVQQDExBl
   c3RFeGFtcGxlQ0EgTndOMB4XDTEzMDUwOTAzNTMzMloXDTE0MDUwOTAzNTMzMlow
   GzEZMBcGA1UEAxMQZXN0RXhhbXBsZUNBIE93TjCCASIwDQYJKoZIhvcNAQEBBQAD
   ggEPADCCAQoCggEBAMA6qYh6KWiArm6Uam6RDey6kyKlhCxSAPagw4XhyCrsjh1v
   2QD+0ZeEuWVOoGi1v5LLHgVMXZqMdyjcr7co3oSKH07tvHmVoYMuvywhBlkdzyvn
   4DwQNJdCXyUf/KHl2Wu9KC1UHN4SOJAnqoxTLPm4mB9L6f0ZboX7cmeZM0Mh9RBr
   EZMNf6lCpE2fDwhfFRZWH6plKKrGkU8mW4yCOCfmOv4xBvqe0K3lvc3M+LD3vN3P
   7ocDCzlkJGbSrELYKOQqX2DI7gJpOENo6EKtr3MZXPljSh3/sG6w29dTkWa4pfSE
   pSPeKLpnEc97gRtWIO8/N4XQ32rJnX26fIDkjRUCAwEAAaNSMFAwDgYDVR0PAQH/
   BAQDAgSwMB0GA1UdDgQWBBQITTKxMqATXrfc4ffpCIbt6Gsz0jAfBgNVHSMEGDAW
   gBSxxGnmW6MEp9iXo4s7v7lqsjJCPDANBgkqhkiG9w0BAQUFAAOCAQEALhDaE6Mp
   BINBsJozdbXlijrWxL1CSv8f4GwpUFk3CgZjibt/qW9UoaNR4E58yRopuEhjwFZK
   2w8YtRqx8IZoFhcoLkpBDfgLLwhoztzbYvOVKQMidjBlkBEVNR5MWdrs7F/AxWuy
   iZ2+8AnR8GwqEIbCD0A7xIghmWEMh/BVI9C7GLqd6PxKrTAjuDfEpfdWhU/uYKmK
   cL3XDbSwr30j2EQyaTV/3W0Tn2UfuxdwDQ4ZJs9G+Mw50s7AG6CpISyOIFmX6/bU
   DpJXGLiLwfJ9C/aum9nylYuGCJ68BuTrCs9567KGfXEXI0mdFFCL7TaVR43kjsg3
   c43kZ7369MeEZzCCAvswggHjoAMCAQICCQDprp3DmjOyETANBgkqhkiG9w0BAQUF
   ADAbMRkwFwYDVQQDExBlc3RFeGFtcGxlQ0EgTndOMB4XDTEzMDUwOTAzNTMzMloX
   DTE0MDUwOTAzNTMzMlowGzEZMBcGA1UEAxMQZXN0RXhhbXBsZUNBIE53TjCCASIw
   DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJ5962d6zCR8H+zA/SuJrm8RwL7X
   Z67EH+Tn4LTIUSC+GnjzYQHYD8o/ApaMToA91E1fnUNVYjs1cTze2nIpKDp5CHUa
   Y6TqZMjKPipLxzEFxp0E27DAL9alrfUtdgzKaNBjgNXuBnt7neWDzk0f6uj74zed
   SBMGCpLBuwoJcGcAfuSW8IWK9g/9Lm7Rpba4kVYsT1q77fsM/yE6ea3I4f/EUtyx
   PLUMt5EzYSRd2P3rEdrEoDojzYCLaAgE8rG2iDRD6+DHpqjC+LQ6Uf2hvcvvEHu7
   NS8jBbw5XradppgcpAAv+5zmrf6cFJQdLDeduA9VwIM/GSr1q5IfmWjq94cCAwEA
   AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUscRp5lujBKfYl6OLO7+5
   arIyQjwwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUAA4IBAQBCz/CWdYvn
   GM/SdCdEiom5A1VxaW8nKgCWg/EyWtAIiaHQuViB+jTUAE9lona2MbJoFHW8U5e8
   9dCP0rJpA9UYXXhWvFQzd5ZWpms4wUYt1j3gqqd36KorJIAuPigVng13yKytxM7c
   VmxQnh0aux3aEnEyRGAhGalHp0RaKdgPRzUaGtipJTNBkSV5S4kD4yDCPHMNbBu+
   OcluerwEpbz6GvE7CpXl2jrTBZSqBsFelq0iz4kk9++9CnwZwrVgdzklhRfJ1Z4j
   NkLruwbQ+o4NvBZsXiKxNfn3K2o3SK8AuaEyDWkq18+5rjcfprRO8x4YTW+6mXPq
   jM0MAGNDEW+1oQAxAA==
                
REQUIREMENT 41: FULL CMC RESPONSE
     
If the enrollment is successful, the server response MUST include an HTTP 200 response code with a content-type of "application/pkcs7-mime" as specified in [RFC5273]. The response data includes either the Simple PKI Response with an smime-type parameter of "certs-only" or the Full PKI Response with an smime-type parameter "CMC-response", as specified in Section 3.2.1 of [RFC5751]. The body of the message is the binary value of the encoding of the PKI Response with a Content-Transfer-Encoding of "base64" [RFC2045].

When rejecting a request, the server MUST specify either an HTTP 4xx error or an HTTP 5xx error. A CMC response with the content-type of "application/pkcs7-mime" MUST be included in the response data for any CMC error response.

All other return codes are handled as specified in Section 4.2.3 or HTTP [RFC2616]. For example, a client interprets an HTTP 404 or 501 response to indicate that this service is not implemented.
REQUIREMENT 57: ENROLL/RE-ENROLL
     
The following is an example of a valid /simpleenroll exchange. The data messages for /simplereenroll are similar.

During this exchange, the EST client uses an out-of-band distributed username/password to authenticate itself to the EST server. This is the normal HTTP WWW-Authenticate behavior and is included here for informative purposes. When an existing TLS client certificate is used, the server might skip requesting the HTTP WWW-Authenticate header, such as during a /simplereenroll operation.

During the initial TLS handshake, the client can ignore the optional server-generated "certificate request" and can instead proceed with the HTTP POST request. In response to the initial HTTP POST attempt, the server requests WWW-Authenticate from the client (this might occur even if the client used a client certificate, as detailed in the normative text above):


   HTTP/1.1 401 Unauthorized
   Content-Length: 0
   WWW-Authenticate: Digest qop="auth", realm="estrealm",
   nonce="1368141352"

                
In the subsequent HTTP POST, the username/password is included, along with the complete application/pkcs10 content:


   POST /.well-known/est/simpleenroll HTTP/1.1
   Authorization: Digest username="estuser", realm="estrealm", nonc
   e="1368141352", uri="/.well-known/est/simpleenroll", cnonce="M
   TYwMzg3", nc=00000001, qop="auth", response="144cc27f96046f1d70e
   b16db20f75f22"
   Host: 192.0.2.1:8085
   Accept: */*
   Content-Type: application/pkcs10
   Content-Transfer-Encoding: base64
   Content-Length: 882

   MIIChTCCAW0CAQAwHzEdMBsGA1UEAxMUZGVtb3N0ZXA0IDEzNjgxNDEzNTIwggEi
   MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQClNp+kdz+Nj8XpEp9kaumWxDZ3
   eFYJpQKz9ddD5e5OzUeCm103ZIXQIxc0eVtMCatnRr3dnZRCAxGjwbqoB3eKt29/
   XSQffVv+odbyw0WdkQOIbntCQry8YdcBZ+8LjI/N7M2krmjmoSLmLwU2V4aNKf0Y
   MLR5Krmah3Ik31jmYCSvwTnv6mx6pr2pTJ82JavhTEIIt/fAYq1RYhkM1CXoBL+y
   hEoDanN7TzC94skfS3VV+f53J9SkUxTYcy1Rw0k3VXfxWwy+cSKEPREl7I6k0YeK
   tDEVAgBIEYM/L1S69RXTLujirwnqSRjOquzkAkD31BE961KZCxeYGrhxaR4PAgMB
   AAGgITAfBgkqhkiG9w0BCQcxEhMQK3JyQ2lyLzcrRVl1NTBUNDANBgkqhkiG9w0B
   AQUFAAOCAQEARBv0AJeXaHpl1MFIdzWqoi1dOCf6U+qaYWcBzpLADvJrPK1qx5pq
   wXM830A1O+7RvrFv+nyd6VF2rl/MrNp+IsKuA9LYWIBjVe/LXoBO8dB/KxrYl16c
   VUS+Yydi1m/a+DaftYSRGolMLtWeiqbc2SDBr2kHXW1TR130hIcpwmr29kC2Kzur
   5thsuj276FGL1vPu0dRfGQfx4WWa9uAHBgz6tW37CepZsrUKe/0pfVhr2oHxApYh
   cHGBQDQHVTFVjHccdUjAXicrtbsVhU5o1lPv7f4lEApv3SBQmJcaq5O832BzHw7n
   PyMFcM15E9gtUVee5C62bVwuk/tbnGsbwQ==

                
The EST server uses the username/password to perform authentication/authorization and responds with the issued certificate:

   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: application/pkcs7-mime; smime-type=certs-only
   Content-Transfer-Encoding: base64
   Content-Length: 1122

   MIIDOAYJKoZIhvcNAQcCoIIDKTCCAyUCAQExADALBgkqhkiG9w0BBwGgggMLMIID
   BzCCAe+gAwIBAgIBFTANBgkqhkiG9w0BAQUFADAbMRkwFwYDVQQDExBlc3RFeGFt
   cGxlQ0EgTndOMB4XDTEzMDUwOTIzMTU1M1oXDTE0MDUwOTIzMTU1M1owHzEdMBsG
   A1UEAxMUZGVtb3N0ZXA0IDEzNjgxNDEzNTIwggEiMA0GCSqGSIb3DQEBAQUAA4IB
   DwAwggEKAoIBAQClNp+kdz+Nj8XpEp9kaumWxDZ3eFYJpQKz9ddD5e5OzUeCm103
   ZIXQIxc0eVtMCatnRr3dnZRCAxGjwbqoB3eKt29/XSQffVv+odbyw0WdkQOIbntC
   Qry8YdcBZ+8LjI/N7M2krmjmoSLmLwU2V4aNKf0YMLR5Krmah3Ik31jmYCSvwTnv
   6mx6pr2pTJ82JavhTEIIt/fAYq1RYhkM1CXoBL+yhEoDanN7TzC94skfS3VV+f53
   J9SkUxTYcy1Rw0k3VXfxWwy+cSKEPREl7I6k0YeKtDEVAgBIEYM/L1S69RXTLuji
   rwnqSRjOquzkAkD31BE961KZCxeYGrhxaR4PAgMBAAGjUjBQMA4GA1UdDwEB/wQE
   AwIEsDAdBgNVHQ4EFgQU/qDdB6ii6icQ8wGMXvy1jfE4xtUwHwYDVR0jBBgwFoAU
   scRp5lujBKfYl6OLO7+5arIyQjwwDQYJKoZIhvcNAQEFBQADggEBACmxg1hvL6+7
   a+lFTARoxainBx5gxdZ9omSb0L+qL+4PDvg/+KHzKsDnMCrcU6M4YP5n0EDKmGa6
   4lY8fbET4tt7juJg6ixb95/760Th0vuctwkGr6+D6ETTfqyHnrbhX3lAhnB+0Ja7
   o1gv4CWxh1I8aRaTXdpOHORvN0SMXdcrlCys2vrtOl+LjR2a3kajJO6eQ5leOdzF
   QlZfOPhaLWen0e2BLNJI0vsC2Fa+2LMCnfC38XfGALa5A8e7fNHXWZBjXZLBCza3
   rEs9Mlh2CjA/ocSC/WxmMvd+Eqnt/FpggRy+F8IZSRvBaRUCtGE1lgDmu6AFUxce
   R4POrT2xz8ChADEA
REQUIREMENT 7: CERTIFICATE-LESS TLS AUTHENTICATION
     
The EST client and EST server can be mutually authenticated using a certificate-less TLS cipher suite (see Section 3.3.3).
REQUIREMENT 6: CERTIFICATE TLS AUTHENTICATION
     
If the EST client has a previously installed certificate issued by a third-party CA, this certificate can be used to authenticate the client's request for a certificate from the EST server (if that CA is recognized by the EST server). An EST client responds to the EST server's TLS certificate request message with the existing certificate already held by the client. The EST server will verify the client's existing certificate and authorize the client's request as described in Section 3.3.2.
REQUIREMENT 42: SERVER-SIDE KEY GENERATION
     
An EST client may request a private key and associated certificate from an EST server using an HTTPS POST with an operation path value of "/serverkeygen". Support for the /serverkeygen function is OPTIONAL.

A client MUST authenticate an EST server, as specified in Section 3.3.1 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used, and check the server's authorization as given in Section 3.6.

The EST server MUST authenticate the client, as specified in Section 3.3.2 if certificate-based authenticated is used or Section 3.3.3 if the optional certificate-less authentication is used, and check the client's authorization as given in Section 3.7. The EST server applies whatever authorization or logic it chooses to determine if the private key and certificate should be provided.

Cipher suites that have a NULL confidentiality algorithm MUST NOT be used as they will disclose the contents of an unprotected private key.

Proper random number and key generation [RFC4086] is a server implementation responsibility, and server archiving of generated keys is determined by CA policy. The key pair and certificate are transferred over the TLS session. The cipher suite used to return the private key and certificate MUST offer confidentiality commensurate with the private key being delivered to the client.

The EST client MAY request additional certificates even when using an existing certificate in the TLS client authentication. For example, the client can use an existing certificate for TLS client authentication when requesting a certificate that cannot be used for TLS client authentication.
REQUIREMENT 56: CSR ATTRIBUTES
     
The following is an example of a valid /csrattrs exchange. During this exchange, the EST client authenticates itself using an existing certificate issued by the CA for which the EST server provides services.

The initial TLS handshake is identical to the enrollment example handshake. The HTTP GET request:


   GET /.well-known/est/csrattrs HTTP/1.1
   User-Agent: curl/7.22.0 (i686-pc-linux-gnu) libcurl/7.22.0 OpenS
   SL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
   Host: 192.0.2.1:8085
   Accept: */*

                
In response, the server provides suggested attributes that are appropriate for the authenticated client. In this example, the EST server also includes two example attributes that the client would ignore unless the attribute type is known to the client:

                    
   HTTP/1.1 200 OK
   Status: 200 OK
   Content-Type: application/csrattrs
   Content-Transfer-Encoding: base64
   Content-Length: 171

   MHwGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEG
   CSqGSIb3DQEJBzAsBgOINwIxJQYDiDcDBgOINwQTGVBhcnNlIFNFVCBhcyAyLjk5
   OS4yIGRhdGEGCSskAwMCCAEBCwYJYIZIAWUDBAIC
                    
REQUIREMENT 19: MESSAGE TYPES
     
This document uses existing media types for the messages as specified by FTP and HTTP [RFC2585], application/pkcs10 [RFC5967], and CMC [RFC5272].

For consistency with [RFC5273], each distinct EST message type uses an HTTP Content-Type header with a specific media type.

The EST messages and their corresponding media types for each operation are:

   +--------------------+--------------------------+-------------------+
   | Message type       | Request media type       | Request section(s)|
   |                    | Response media type(s)   | Response section  |
   | (per operation)    | Source(s) of types       |                   |
   +====================+==========================+===================+
   | Distribution of CA | N/A                      | Section 4.1       |
   | Certificates       | application/pkcs7-mime   | Section 4.1.1     |
   |                    | [RFC5751]                |                   |
   | /cacerts           |                          |                   |
   +--------------------+--------------------------+-------------------+
   | Client Certificate | application/pkcs10       | Sections 4.2/4.2.1|
   | Request Functions  | application/pkcs7-mime   | Section 4.2.2     |
   |                    | [RFC5967] [RFC5751]      |                   |
   | /simpleenroll      |                          |                   |
   | /simplereenroll    |                          |                   |
   +--------------------+--------------------------+-------------------+
   | Full CMC           | application/pkcs7-mime   | Section 4.3.1     |
   |                    | application/pkcs7-mime   | Section 4.3.2     |
   | /fullcmc           | [RFC5751]                |                   |
   +--------------------+--------------------------+-------------------+
   | Server-Side Key    | application/pkcs10       | Section 4.4.1     |
   | Generation         | multipart/mixed          | Section 4.4.2     |
   |                    | (application/pkcs7-mime &|                   |
   |                    | application/pkcs8)       |                   |
   |                    | [RFC5967] [RFC5751]      |                   |
   | /serverkeygen      | [RFC5958]                |                   |
   +--------------------+--------------------------+-------------------+
   | CSR Attributes     | N/A                      | Section 4.5.1     |
   |                    | application/csrattrs     | Section 4.5.2     |
   |                    | (This document)          |                   |
   | /csrattrs          |                          |                   |
   +--------------------+--------------------------+-------------------+

                                 Figure 6
REQUIREMENT 31: DISTRIBUTION OF CA CERTIFICATES
     
The EST client can request a copy of the current CA certificates. This function is generally performed before other EST functions.
REQUIREMENT 25: LINKING IDENTITY AND POP INFORMATION
     
Server policy will determine whether clients are required to use the mechanism specified in this section. This specification provides a method of linking identity and proof-of-possession by including information specific to the current authenticated TLS session within the signed certification request. The client can determine if the server requires the linking of identity and POP by examining the CSR Attributes Response (see Section 4.5.2). Regardless of the CSR Attributes Response, clients SHOULD link identity and POP by embedding tls-unique information in the certification request. If tls-unique information is included by the client, the server MUST verify it. The EST server MAY reject requests without tls-unique information as indicated by server policy.

Linking identity and proof-of-possession proves to the server that the authenticated TLS client has possession of the private key associated with the certification request, and that the client was able to sign the certification request after the TLS session was established. This is an alternative to the "Linking Identity and POP Information" method defined by Section 6 of [RFC5272] that is available if Full PKI messages are used.

The client generating the CSR obtains the tls-unique value from the TLS subsystem as described in Channel Bindings for TLS [RFC5929]. The EST client operations between obtaining the tls-unique value through generation of the CSR that contains the current tls-unique value and the subsequent verification of this value by the EST server are the "phases of the application protocol during which application- layer authentication occurs"; these operations are protected by the synchronization interoperability mechanism described in the "Channel Bindings for TLS" interoperability notes in Section 3.1 of [RFC5929].

When performing renegotiation, TLS "secure_renegotiation" [RFC5746] MUST be used.

The tls-unique value is base64 encoded as specified in Section 4 of [RFC4648], and the resulting string is placed in the certification request challenge-password field ([RFC2985], Section 5.4.1). The challenge-password field is limited to 255 bytes (Section 7.4.9 of [RFC5246] indicates that no existing cipher suite would result in an issue with this limitation). If the challenge-password attribute is absent, the client did not include the optional channel-binding information (the presence of the challenge-password attribute indicates the inclusion of tls-unique information).

If the EST server makes use of a back-end infrastructure for processing, it is RECOMMENDED that the results of this verification be communicated. (For example, this communication might use the CMC [RFC5272] "RA POP Witness Control" in a CMC Full PKI Request message. Or, an EST server might TLS-authenticate an EST client as being a trusted infrastructure element that does not forward invalid requests. A detailed discussion of back-end processing is out of scope.)

When rejecting requests, the EST server response is as described for all enroll responses (Section 4.2.3). If a Full PKI Response is included, the CMCFailInfo MUST be set to popFailed. If a human- readable reject message is included, it SHOULD include an informative text message indicating that the linking of identity and POP information is required.
REQUIREMENT 24: PROOF-OF-POSSESSION
     
As defined in Section 2.1 of CMC [RFC5272], proof-of-possession (POP) "refers to a value that can be used to prove that the private key corresponding to the public key is in the possession of and can be used by an end-entity".

The signed enrollment request provides a signature-based proof-of-possession. The mechanism described in Section 3.5 strengthens this by optionally including "Direct"-based proof-of-possession [RFC5272] by including TLS session-specific information within the data covered by the enrollment request signature (thus linking the enrollment request to the authenticated end point of the TLS connection).
REQUIREMENT 18: HTTP-BASED CLIENT AUTHENTICATION
     
The EST server MAY request HTTP-based client authentication. This request can be in addition to successful TLS client authentication (Section 3.3.2) if EST server policy requires additional authentication. (For example, the EST server may require that an EST client "knows" a password in addition to "having" an existing client certificate.) Or, HTTP-based client authentication can be an EST server policy-specified fallback in situations where the EST client did not successfully complete the TLS client authentication. (This might arise if the EST client is enrolling for the first time or if the certificates available to an EST client cannot be used for TLS client authentication.)

HTTP Basic and Digest authentication MUST only be performed over TLS 1.1 [RFC4346] or later versions. NULL and anon cipher suites MUST NOT be used because they do not provide confidentiality or support mutual certificate-based or certificate-less authentication, respectively. As specified in "Certificate Management over CMS (CMC): Transport Protocols" [RFC5273], the server "MUST NOT assume client support for any type of HTTP authentication such as cookies, Basic authentication, or Digest authentication". Clients SHOULD support the Basic and Digest authentication mechanism.

Servers that wish to use Basic and Digest authentication reject the HTTP request using the HTTP-defined WWW-Authenticate response-header ([RFC2616], Section 14.47). The client is expected to retry the request, including the appropriate Authorization Request header ([RFC2617], Section 3.2.2), if the client is capable of using the Basic or Digest authentication. If the client is not capable of retrying the request or it is not capable of Basic or Digest authentication, then the client MUST terminate the connection.

A client MAY set the username to the empty string ("") if it is presenting a password that is not associated with a username.

Support for HTTP-based client authentication has security ramifications as discussed in Section 6. The client MUST NOT respond to the server's HTTP authentication request unless the client has authorized the EST server (as per Section 3.6).
REQUIREMENT 26: SERVER AUTHORIZATION
     
The client MUST check EST server authorization before accepting any server responses or responding to HTTP authentication requests.

The EST client authorization method depends on which method was used to authenticate the server. When the Explicit TA database is used to authenticate the EST server, then Section 3.6.1 applies. When the Implicit TA database is used to authenticate the EST server, then Section 3.6.2 applies. Successful authentication using a certificate-less cipher suite implies authorization of the server.

The client MAY perform bootstrapping as specified in Section 4.1.1 even if these checks fail.
REQUIREMENT 32: BOOTSTRAP DISTRIBUTION OF CA CERTIFICATES
     
It is possible that the client was not configured with an Implicit TA database that allows a bootstrap installation of the Explicit TA database as described in 4.1.3. This section describes an alternate method by which minimally configured EST clients can populate their Explicit TA database.

If the EST client application does not specify either an Explicit TA database or an Implicit TA database, then the initial TLS server authentication and authorization will fail. The client MAY provisionally continue the TLS handshake to completion for the purposes of accessing the /cacerts or /fullcmc method. If the EST client continues with an unauthenticated connection, the client MUST extract the HTTP content data from the response (Sections 4.1.3 or 4.3.2) and engage a human user to authorize the CA certificate using out-of-band data such as a CA certificate "fingerprint" (e.g., a SHA-256 or SHA-512 [SHS] hash on the whole CA certificate). In a /fullcmc response, it is the Publish Trust Anchors control (CMC [RFC5272], Section 6.15) within the Full PKI Response that must be accepted manually. It is incumbent on the user to properly verify the TA information, or to provide the "fingerprint" data during configuration that is necessary to verify the TA information.

HTTP authentication requests MUST NOT be responded to if the server has not been authenticated as specified in Section 3.3.1 or if the optional certificate-less authentication is used as specified in Section 3.3.3.

The EST client uses the /cacerts response to establish an Explicit Trust Anchor database for subsequent TLS authentication of the EST server. EST clients MUST NOT engage in any other protocol exchange until after the /cacerts response has been accepted and a new TLS session has been established (using TLS certificate-based authentication).
REQUIREMENT 33: CA CERTIFICATES REQUEST
     
EST clients request the EST CA TA database information of the CA (in the form of certificates) with an HTTPS GET message using an operation path of "/cacerts". EST clients and servers MUST support the /cacerts function. Clients SHOULD request an up-to-date response before stored information has expired in order to ensure the EST CA TA database is up to date.

The EST server SHOULD NOT require client authentication or authorization to reply to this request.

The client MUST authenticate the EST server, as specified in Section 3.3.1 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used, and check the server's authorization as given in Section 3.6, or follow the procedure outlined in Section 4.1.1.
REQUIREMENT 27: CLIENT USE OF EXPLICIT TA DATABASE
     
When the EST client Explicit TA database is used to validate the EST server certificate, the client MUST check either the configured URI or the most recent HTTP redirection URI against the server's identity according to the rules specified in [RFC6125], Section 6.4, or the EST server certificate MUST contain the id-kp-cmcRA [RFC6402] extended key usage extension.
REQUIREMENT 23: CERTIFICATE-LESS TLS MUTUAL AUTHENTICATION
     
Certificate-less TLS cipher suites provide a way to perform mutual authentication in situations where neither the client nor server have certificates, do not desire to use certificates, or do not have the trust anchors necessary to verify a certificate. The client and server MAY negotiate a certificate-less cipher suite for mutual authentication.

When using certificate-less mutual authentication in TLS for enrollment, the cipher suite MUST be based on a protocol that is resistant to dictionary attack and MUST be based on a zero knowledge protocol. Transport Layer Security-Secure Remote Password (TLS-SRP) cipher suites, i.e., those with _SRP_ in the name, listed in Section 2.7 of [RFC5054] are suitable for this purpose. Section 6 lists the characteristics of a cipher suite that are suitable for use in certificate-less mutual authentication for enrollment.

Successful authentication using a certificate-less cipher suite proves knowledge of a pre-shared secret that implicitly authorizes a peer in the exchange.
REQUIREMENT 37: SIMPLE RE-ENROLLMENT OF CLIENTS
     
EST clients renew/rekey certificates with an HTTPS POST using the operation path value of "/simplereenroll".

A certificate request employs the same format as the "simpleenroll" request, using the same HTTP content-type. The request Subject field and SubjectAltName extension MUST be identical to the corresponding fields in the certificate being renewed/rekeyed. The ChangeSubjectName attribute, as defined in [RFC6402], MAY be included in the CSR to request that these fields be changed in the new certificate.

If the Subject Public Key Info in the certification request is the same as the current client certificate, then the EST server renews the client certificate. If the public key information in the certification request is different than the current client certificate, then the EST server rekeys the client certificate.
REQUIREMENT 36: SIMPLE ENROLLMENT OF CLIENTS
     
When HTTPS POSTing to /simpleenroll, the client MUST include a Simple PKI Request as specified in CMC [RFC5272], Section 3.1 (i.e., a PKCS https://tools.ietf.org/html/rfc7030#10 Certification Request [RFC2986]).

The Certification Signing Request (CSR) signature provides proof-of-possession of the client-possessed private key to the EST server. If the CSR KeyUsage extension indicates that the private key can be used to generate digital signatures, then the client MUST generate the CSR signature using the private key. If the key can be used to generate digital signatures but the requested CSR KeyUsage extension prohibits generation of digital signatures, then the CSR signature MAY still be generated using the private key, but the key MUST NOT be used for any other signature operations (this is consistent with the recommendations concerning submission of proof-of-possession to an RA or CA as described in [SP-800-57-Part-1]). The use of /fullcmc operations provides access to more advanced proof-of-possession methods that are used when the key pair cannot be used for digital signature generation (see Section 4.3).

The HTTP content-type of "application/pkcs10" is used here. The format of the message is as specified in [RFC5967] with a Content- Transfer-Encoding of "base64" [RFC2045].

If the EST client authenticated using a previously installed certificate issued by a third-party CA (see Section 2.2.1), the client MAY include the ChangeSubjectName attribute, as defined in [RFC6402], in the CSR to request that the subjectName and SubjectAltName be changed in the new certificate.

The EST client MAY request additional certificates even when using an existing certificate in the TLS client authentication. For example, the client can use an existing certificate for TLS client authentication when requesting a certificate that cannot be used for TLS client authentication.
REQUIREMENT 22:
     
TLS client authentication is the RECOMMENDED method for identifying EST clients. HTTP-based client authentication (Section 3.2.3) MAY be used.

The EST server authenticates the EST client as defined for the cipher suite negotiated. The following text provides details assuming a certificate-based cipher suite such as the TLS 1.1 [RFC4346] mandatory cipher suite (TLS_RSA_WITH_3DES_EDE_CBC_SHA). The EST server MUST support certificate-based client authentication.

Generally, the client will use an existing certificate for renew or rekey operations. If the certificate to be renewed or rekeyed is appropriate for the negotiated cipher suite, then the client MUST use it for the TLS handshake, otherwise the client SHOULD use an alternate certificate that is suitable for the cipher suite and contains the same subject identity information. When requesting an enroll operation, the client MAY use a client certificate issued by a third party to authenticate itself.

Certificate validation MUST be performed as per [RFC5280]. The EST client certificate MUST conform to the [RFC5280] certificate profile.

The server validates the TLS client certificate using the EST server Explicit and, if enabled, Implicit TA database(s). The server MUST maintain a distinction between the use of Explicit and Implicit TA databases during authentication in order to support proper authorization.

The EST server MUST perform authorization checks as specified in Section 3.7.

If a client does not support TLS client authentication, then it MUST support HTTP-based client authentication (Section 3.2.3) or certificate-less TLS authentication (Section 3.3.3).
REQUIREMENT 34: CA CERTIFICATES RESPONSE
     
If successful, the server response MUST have an HTTP 200 response code. Any other response code indicates an error and the client MUST abort the protocol.

A successful response MUST be a certs-only CMC Simple PKI Response, as defined in [RFC5272], containing the certificates described in the following paragraph. The HTTP content-type of "application/pkcs7-mime" is used. The Simple PKI Response is sent with a Content-Transfer-Encoding of "base64" [RFC2045].

The EST server MUST include the current root CA certificate in the response. The EST server MUST include any additional certificates the client would need to build a chain from an EST CA-issued certificate to the current EST CA TA. For example, if the EST CA is a subordinate CA, then all the appropriate subordinate CA certificates necessary to build a chain to the root EST CA are included in the response.

The EST server SHOULD include the three "Root CA Key Update" certificates OldWithOld, OldWithNew, and NewWithOld in the response chain. These are defined in Section 4.4 of CMP [RFC4210]. The EST client MUST be able to handle these certificates in the response. The EST CA's most recent self-signed certificate (e.g., NewWithNew certificate) is self-signed and has the latest NotAfter date. If the EST server does not include these in the response, then after the current EST CA certificate expires, the EST clients will need to be reinitialized with the PKI using the Bootstrap Distribution of CA certificates (Section 4.1.1) method, which involves user interaction.

After out-of-band validation occurs, all the other certificates MUST be validated using normal [RFC5280] certificate path validation (using the most recent CA certificate as the TA) before they can be used to build certificate paths during certificate validation.

The EST client MUST store the extracted EST CA certificate as an Explicit TA database entry for subsequent EST server authentication. The EST client SHOULD disable use of Implicit TA database entries for this EST server now that an Explicit TA database entry is available. If the client disables the Implicit TA database, and if the EST server certificate was verified using an Implicit TA database entry, then the client MUST include the "Trusted CA Indication" extension in future TLS sessions [RFC6066]. This indicates to the server that only an EST server certificate authenticatable by the Explicit TA database entry is now acceptable (otherwise, the EST server might continue to use a server certificate that is only verifiable by a now disabled Implicit TA).

The EST client SHOULD also make the CA Certificate response information available to the end-entity software for use when validating peer certificates.
REQUIREMENT 20: TLS LAYER
     
TLS provides authentication, which in turn enables authorization decisions. The EST server and EST client are responsible for ensuring that an acceptable cipher suite is negotiated and that mutual authentication has been performed. TLS authentication is most commonly enabled with the use of certificates [RFC5280]. Alternately, certificate-less TLS authentication, where neither the client nor server present a certificate, is also an acceptable method for EST mutual authentication (Section 3.3.3). The EST server MUST be authenticated during the TLS handshake unless the client is requesting Bootstrap Distribution of CA certificates (Section 4.1.1) or Full CMC (Section 4.3).

HTTPS [RFC2818] specifies how HTTP messages are carried over TLS. HTTPS MUST be used. TLS 1.1 [RFC4346] (or a later version) MUST be used for all EST communications. TLS session resumption [RFC5077] SHOULD be supported.

TLS channel-binding information can be inserted into a certificate request, as detailed in Section 3.5, in order to provide the EST server with assurance that the authenticated TLS client has access to the private key for the certificate being requested. The EST server MUST implement Section 3.5.
REQUIREMENT 21: TLS-BASED SERVER AUTHENTICATION
     
TLS server authentication with certificates MUST be supported.

The EST client authenticates the EST server as defined for the cipher suite negotiated. The following text provides details assuming a certificate-based cipher suite, such as the TLS 1.1 [RFC4346] mandatory cipher suite (TLS_RSA_WITH_3DES_EDE_CBC_SHA).

Certificate validation MUST be performed as per [RFC5280]. The EST server certificate MUST conform to the [RFC5280] certificate profile.

The client validates the TLS server certificate using the EST client Explicit and, if enabled, Implicit TA database(s). The client MUST maintain a distinction between the use of Explicit and Implicit TA databases during authentication in order to support proper authorization. The EST client MUST perform authorization checks as specified in Section 3.6.

If certificate validation fails, the client MAY follow the procedure outlined in Section 4.1.1 for Bootstrap Distribution of CA certificates.
REQUIREMENT 35: CLIENT CERTIFICATE REQUEST FUNCTIONS
     
EST clients request a certificate from the EST server with an HTTPS POST using the operation path value of "/simpleenroll". EST clients request a renew/rekey of existing certificates with an HTTP POST using the operation path value of "/simplereenroll". EST servers MUST support the /simpleenroll and /simplereenroll functions.

It is RECOMMENDED that a client obtain the current CA certificates, as described in Section 4.1, before performing certificate request functions. This ensures that the client will be able to validate the EST server certificate. The client MUST authenticate the EST server as specified in Section 3.3.1 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used. The client MUST verify the authorization of the EST server as specified in Section 3.6.

The server MUST authenticate the client as specified in Section 3.3.2 if certificate-based authentication is used or Section 3.3.3 if the optional certificate-less authentication is used. The server MUST verify client authorization as specified in Section 3.7. The EST server MUST check the tls-unique value, as described in Section 3.5, if one is submitted by the client.

The server MAY accept a certificate request for manual authorization checking by an administrator. (Section 4.2.3 describes the use of an HTTP 202 response to the EST client if this occurs.)
tcw_err_t tcw_connect(tcw_sock_t *sock, tcw_opts_t *opts, const char *host,
                      unsigned short int port, SOCK_TYPE *fd);
tcw_err_t tcw_close(tcw_sock_t *sock);

// MINGW typedefs pid_t to int. Using #define here.
static int pthread_mutex_lock(pthread_mutex_t *);
// MINGW typedefs pid_t to int. Using #define here.
static int pthread_mutex_unlock(pthread_mutex_t *);
// MINGW typedefs pid_t to int. Using #define here.
static void to_unicode(const char *path, wchar_t *wbuf, size_t wbuf_len);

/*
 * Utility function to set the certificate and private key to use
 * for a SSL context.
 *
 * Returns 0 on success
 */
int est_client_set_cert_and_key (SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)
{

    if (SSL_CTX_use_certificate(ctx, cert) <= 0) {
        EST_LOG_ERR("Error setting certificate");
        ossl_dump_ssl_errors();
        return 1;
    }

    if (SSL_CTX_use_PrivateKey(ctx, key) <= 0) {

        EST_LOG_ERR("Unable to set private key");
        ossl_dump_ssl_errors();
        return 1;
    }

    /*
     * Verify the key matches the cert
     */
    if (!SSL_CTX_check_private_key(ctx)) {
        EST_LOG_ERR("Private key does not match the certificate public key");
        ossl_dump_ssl_errors();
        return 1;
    }
    return 0;
}
/*
 * Sign an X509 certificate request using the digest and the key passed.
 * Returns OpenSSL error code from X509_REQ_sign_ctx();
 */
static int est_client_X509_REQ_sign (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
    int rv;
    EVP_PKEY_CTX *pkctx = NULL;
    EVP_MD_CTX mctx;

    EVP_MD_CTX_init(&mctx);

    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {
        return 0;
    }

    /*
     * Encode using DER (ASN.1) 
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     */
    x->req_info->enc.modified = 1; 
    rv = X509_REQ_sign_ctx(x, &mctx);

    EVP_MD_CTX_cleanup(&mctx);

    return (rv);
}
/*
 * populate_x509_request will build an x509 request buffer.  It does this by
 * calls into OpenSSL to insert the fields of the x509 header.
 *
 * Parameters:
 *	req:	pointer to the buffer that is to hold the x509 request header
 *	pkey:   public key to be placed into the x509 request
 *	cn:     Common Name to be placed into the x509 request
 *      cp:     challenge password to be placed into the x509 header
 *
 * Return value:
 *	EST_ERR_NONE if success
 */
static EST_ERROR populate_x509_request (EST_CTX *ctx, X509_REQ *req, EVP_PKEY *pkey, 
					char *cn, char *cp)
{
    X509_NAME *subj;


    /* setup version number */
    if (!X509_REQ_set_version(req, 0L)) {
        EST_LOG_ERR("Unable to set X509 version");
	ossl_dump_ssl_errors();
        return (EST_ERR_X509_VER);
    }

    /*
     * Add Common Name entry
     */
    subj = X509_REQ_get_subject_name(req);
    if (!X509_NAME_add_entry_by_txt(subj, "CN", MBSTRING_ASC,
                                    (unsigned char*)cn, -1, -1, 0)) {
        EST_LOG_ERR("Unable to set X509 common name");
	ossl_dump_ssl_errors();
        return (EST_ERR_X509_CN);
    }

    /*
     * Add challengePassword attribute if required
     * No need to remove/add attributes here, only the PoP is
     * part of the simple enroll flow.
     */
    if (ctx->csr_pop_required || ctx->client_force_pop) {
	EST_LOG_INFO("Client will include challengePassword in CSR");
        if (!X509_REQ_add1_attr_by_NID(req, NID_pkcs9_challengePassword,
                                       MBSTRING_ASC, (unsigned char*)cp, -1)) {
            EST_LOG_ERR("Unable to set X509 challengePassword attribute");
	    ossl_dump_ssl_errors();
            return (EST_ERR_X509_ATTR);
        }
    }
    /*
     * Set the public key on the request
     */
    if (!X509_REQ_set_pubkey(req, pkey)) {
        EST_LOG_ERR("Unable to set public key");
	ossl_dump_ssl_errors();
        return (EST_ERR_X509_PUBKEY);
    }

    return (EST_ERR_NONE);
}
/*
 * This function will generate a PKCS10 request.
 *
 * Parameters:
 *	cn:	Common Name to put into the certificate.
 *	cp:     TLS unique ID for the SSL session, becomes the challenge password
 *	pkey:	Private key to use for signing the request.
 *
 * Return value:
 *	EST_ERR_NONE if success
 */
static EST_ERROR est_generate_pkcs10 (EST_CTX *ctx, char *cn, char *cp, 
	                              EVP_PKEY *pkey, X509_REQ **pkcs10)
{
    X509_REQ *req = NULL;
    EST_ERROR rv;
    int ossl_rv = 0;

    req = X509_REQ_new();
    if (req == NULL) {
        EST_LOG_ERR("Unable to allocate X509_REQ");
        ossl_dump_ssl_errors();
        return (EST_ERR_MALLOC);
    }

    rv = populate_x509_request(ctx, req, pkey, cn, cp);
    if (rv != EST_ERR_NONE) {
        X509_REQ_free(req);
        return (rv);
    }

    /*
     * Sign the request
     */
    ossl_rv = est_client_X509_REQ_sign(req, pkey, ctx->signing_digest);
    if (!ossl_rv) {
        EST_LOG_ERR("Unable to sign X509 cert request");
        X509_REQ_free(req);
        ossl_dump_ssl_errors();
        return (EST_ERR_X509_SIGN);
    }

    *pkcs10 = req;

    return (EST_ERR_NONE);
}
/*
 * This function is a callback used by OpenSSL's verify_cert function.
 * It's called at the end of a cert verification to allow an opportunity to
 * gather more information regarding a failing cert verification, and to
 * possibly change the result of the verification.
 *
 * This callback is similar to the ossl routine, but does not alter
 * the verification result.
 */
static int est_client_cacert_verify_cb (int ok, X509_STORE_CTX *ctx)
{
    int cert_error = X509_STORE_CTX_get_error(ctx);
    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);

    EST_LOG_INFO("enter function: ok=%d cert_error=%d", ok, cert_error);

    if (!ok) {
        if (current_cert) {
            X509_NAME_print_ex_fp(stdout,
                                  X509_get_subject_name(current_cert),
                                  0, XN_FLAG_ONELINE);
            printf("\n");
        }
        EST_LOG_INFO("%s error %d at %d depth lookup: %s\n",
                     X509_STORE_CTX_get0_parent_ctx(ctx) ? "[CRL path]" : "",
                     cert_error,
                     X509_STORE_CTX_get_error_depth(ctx),
                     X509_verify_cert_error_string(cert_error));
    }
    return (ok);
}
/*
 * This function will remove CRLs from a received cacert response buffer.
 *
 * Parameters:
 *	ctx:	EST Context representing this session
 *  cacerts:    pointer to the buffer holding the resulting CA certs 
 *  cacerts_len: length of the cacerts buffer
 *       p7:    pointer to the pkcs7 buffer that was received
 *
 * Return value:
 *	EST_ERR_NONE if success
 
 */
static EST_ERROR est_client_remove_crls (EST_CTX *ctx, unsigned char *cacerts,
                                         int *cacerts_len, PKCS7 *p7)
{
    int nid = 0;
    int crls_found = 0;
    BIO *b64_enc = NULL;
    BIO *p7bio_out = NULL;
    int new_cacerts_len = 0;
    char *new_cacerts_buf = NULL;
    int count = 0;    
    
    nid=OBJ_obj2nid(p7->type);
    switch (nid)
        {
        case NID_pkcs7_signed:
            if (p7->d.sign->crl) {
                sk_X509_CRL_pop_free(p7->d.sign->crl, X509_CRL_free);
                p7->d.sign->crl = NULL;
                crls_found = 1;
            }
            break;
        case NID_pkcs7_signedAndEnveloped:
            if (p7->d.signed_and_enveloped->crl) {
                sk_X509_CRL_pop_free(p7->d.signed_and_enveloped->crl, X509_CRL_free);
                p7->d.sign->crl = NULL;
                crls_found = 1;
            }
            break;
        default:
            EST_LOG_ERR("Invalid NID value on PKCS7 structure");
            return (EST_ERR_CACERT_VERIFICATION);            
            break;
        }

    /*
     * If CRLs were removed, then the original PKCS7 buffer needs to be
     * updated.  This will always be base64 encoded.
     * - Allocate the BIOs,
     * - Write the PKCS7 struct back into PEM format,
     * - Get the pointer and length to the new base64 PEM encoded buffer,
     * - and then copy it into the original buffer that was passed in.
     * Since the CRLs are being removed, the new buffer will always be shorter
     * and will fit into the original buffer.
     */
    if (crls_found) {

        EST_LOG_INFO("CRL(s) attached with the CA Certificates.  Removing CRL(s)");
        
        b64_enc = BIO_new(BIO_f_base64());
        if (b64_enc == NULL) {
            EST_LOG_ERR("BIO_new failed");
            ossl_dump_ssl_errors();
            return(EST_ERR_MALLOC);
        }
        p7bio_out = BIO_new(BIO_s_mem());
        if (p7bio_out == NULL) {
            EST_LOG_ERR("Unable to access the CA cert buffer");
            ossl_dump_ssl_errors();
            return(EST_ERR_MALLOC);
        }
        p7bio_out = BIO_push(b64_enc, p7bio_out);
        
        memzero_s(cacerts, *cacerts_len);
        
        count = i2d_PKCS7_bio(p7bio_out, p7);
        if (count == 0) {
            EST_LOG_ERR("PEM_write_bio_PKCS7 failed");
            ossl_dump_ssl_errors();
            BIO_free_all(p7bio_out);            
            return (EST_ERR_CACERT_VERIFICATION);
        }
        (void)BIO_flush(p7bio_out);

        /*
         * BIO_get_mem_data just returns the pointer and length to the data
         * contained in the mem BIO.  Nothing is allocated and passed back
         */
        new_cacerts_len = (int) BIO_get_mem_data(p7bio_out, (char**)&new_cacerts_buf);
        if (new_cacerts_len <= 0) {
            EST_LOG_ERR("Failed to copy PKCS7 data");
            ossl_dump_ssl_errors();
            BIO_free_all(p7bio_out);            
            return (EST_ERR_CACERT_VERIFICATION);
        }
        /*
         * copy the new buffer back into the old buffer
         */
        memcpy_s(cacerts, *cacerts_len, new_cacerts_buf, new_cacerts_len);
        *cacerts_len = new_cacerts_len;
    }

    BIO_free_all(p7bio_out);

    return EST_ERR_NONE;
}
/*
 * This function will decode the passed base64 encoded buffer and return the
 * decoded cacerts. If returning EST_ERR_NONE, caller is responsible for
 * freeing the cacerts_decoded buffer
 */
static EST_ERROR b64_decode_cacerts (unsigned char *cacerts, int *cacerts_len,
                                     unsigned char **cacerts_decoded,
                                     int *cacerts_decoded_len)
{
    BIO *in = NULL;
    BIO *b64 = NULL;
    unsigned char *decoded_buf;
    int decoded_buf_len;

    *cacerts_decoded = NULL;
    *cacerts_decoded_len = 0;
    
    b64 = BIO_new(BIO_f_base64());
    if (b64 == NULL) {
        EST_LOG_ERR("BIO_new failed");
        ossl_dump_ssl_errors();
        return (EST_ERR_MALLOC);
    }    
    /*
     * Decoding will always take up less than the original buffer.
     */
    in = BIO_new_mem_buf(cacerts, *cacerts_len);    
    if (in == NULL) {
        EST_LOG_ERR("Unable to access the CA cert buffer");
        ossl_dump_ssl_errors();
        BIO_free_all(b64);
        return (EST_ERR_MALLOC);
    }
    in = BIO_push(b64, in);    
    decoded_buf = malloc(*cacerts_len);
    if (decoded_buf == NULL) {
        EST_LOG_ERR("Unable to allocate CA cert buffer for decode");
        BIO_free_all(in);        
        return (EST_ERR_MALLOC);        
    }
    
    decoded_buf_len = BIO_read(in, decoded_buf, *cacerts_len);
    
    *cacerts_decoded = decoded_buf;
    *cacerts_decoded_len = decoded_buf_len;

    BIO_free_all(in);
    
    return (EST_ERR_NONE);
}
/*
 * If returning EST_ERR_NONE, caller is responsible for freeing the PKCS7 struct
 */
static EST_ERROR create_PKCS7 (unsigned char *cacerts_decoded, int cacerts_decoded_len,
                               PKCS7 **pkcs7out)
{
    BIO *p7bio_in = NULL;
    PKCS7 *pkcs7 = NULL;

    /*
     * Now get the PKCS7 formatted buffer of certificates read into a stack of
     * X509 certs
     */
    p7bio_in = BIO_new_mem_buf(cacerts_decoded, cacerts_decoded_len);
    if (p7bio_in == NULL) {
        EST_LOG_ERR("Unable to access the PKCS7 buffer");
        ossl_dump_ssl_errors();
        return (EST_ERR_MALLOC);
    }
        
    pkcs7 = d2i_PKCS7_bio(p7bio_in,NULL);

    if (pkcs7 == NULL) {
        EST_LOG_ERR("Unable to read in PKCS7 based certificate buffer");
        ossl_dump_ssl_errors();
        BIO_free_all(p7bio_in);   
        return (EST_ERR_LOAD_CACERTS);
    }

    BIO_free_all(p7bio_in);
    *pkcs7out = pkcs7;
    return EST_ERR_NONE;    
}
/*
 * This function is invoked when the CACerts response has been received.  The
 * cert chain is built into a cert store and then each certificate is verified
 * against this store essentially verifying the cert chain against itself to
 * ensure that each intermediate can be verified back to one of the included
 * root certs in the CACerts response.  If CRLs are attached these will be
 * removed and a new PKCS7 buffer is created.
 *
 * Parameters:
 *	ctx:	EST Context representing this session
 *  cacerts:    pointer to the buffer holding the received CA certs 
 *  cacerts_len: length of the cacerts buffer
 *
 * Return value:
 *	EST_ERR_NONE if success
 
 */
static EST_ERROR verify_cacert_resp (EST_CTX *ctx, unsigned char *cacerts,
                                     int *cacerts_len)
{
    int rv = 0;
    int failed = 0;
    EST_ERROR est_rc = EST_ERR_NONE;
    
    X509_STORE  *trusted_cacerts_store = NULL;
    
    STACK_OF(X509) *stack = NULL;
    X509 *current_cert = NULL;
    int i;
    
    unsigned char *cacerts_decoded = NULL;
    int  cacerts_decoded_len = 0;

    X509_STORE_CTX *store_ctx = NULL;
    PKCS7 *pkcs7 = NULL;
    
    if (ctx == NULL || cacerts == NULL || cacerts_len == 0) {
        EST_LOG_ERR("Invalid parameter. ctx = %x cacerts = %x cacerts_len = %x",
                    ctx, cacerts, cacerts_len);
        return (EST_ERR_INVALID_PARAMETERS);
    }    

    /*
     * - Base64 decode the incoming ca certs buffer,
     * - convert to a PKCS7 structure,
     * - extract out the stack of certs.
     */
    rv = b64_decode_cacerts(cacerts, cacerts_len,
                            &cacerts_decoded, &cacerts_decoded_len);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Base64 decode of received CA certs failed");
        return (rv);
    }
    rv = create_PKCS7(cacerts_decoded, cacerts_decoded_len, &pkcs7);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Failed to build PKCS7 structure from receievd buffer");
        free(cacerts_decoded);
        return (rv);
    }
    rv = PKCS7_to_stack(pkcs7, &stack);    
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Could not obtain stack of ca certs from PKCS7 structure");
        free(cacerts_decoded);
        PKCS7_free(pkcs7);
        return (rv);
    }
    
    /*
     * At this point we have the stack of X509 certs that make up
     * the CA certs response sent from the EST server.
     * - Build a store of "trusted" certs to use in the verify
     * - walk through each cert and verify it 
     *   - Build a store context from the store and the cert to be verified and
     *     call the verify function
     */
    trusted_cacerts_store = X509_STORE_new();
    if (trusted_cacerts_store == NULL) {
        EST_LOG_ERR("Unable to allocate cert store");
        ossl_dump_ssl_errors();
        
        free(cacerts_decoded);
        PKCS7_free(pkcs7);
        
        return (EST_ERR_MALLOC);
    }

    X509_STORE_set_verify_cb(trusted_cacerts_store, est_client_cacert_verify_cb);

    for (i=0; i<sk_X509_num(stack); i++) {
        current_cert = sk_X509_value(stack, i);

        /*
         * Is it self signed?  If so, add it in the trusted store, otherwise,
         * add it to the untrusted store.
         */
        rv = X509_check_issued(current_cert, current_cert);
	if (rv == X509_V_OK) {
            EST_LOG_INFO("Adding cert to trusted store (%s)", current_cert->name);
            X509_STORE_add_cert(trusted_cacerts_store, current_cert);
        }
    }

    /*
     * set up a X509 Store Context
     */
    store_ctx = X509_STORE_CTX_new();
    if (store_ctx == NULL) {
        EST_LOG_ERR("Unable to allocate a new store context");
        ossl_dump_ssl_errors();
        
        free(cacerts_decoded);
        PKCS7_free(pkcs7);
        X509_STORE_free(trusted_cacerts_store);
        
        return(EST_ERR_MALLOC);
    }

    for (i=0; i<sk_X509_num(stack); i++) {

        if (!X509_STORE_CTX_init(store_ctx, trusted_cacerts_store, NULL, stack)) {
            EST_LOG_ERR("Unable to initialize the new store context");
            ossl_dump_ssl_errors();

            free(cacerts_decoded);
            PKCS7_free(pkcs7);
            X509_STORE_free(trusted_cacerts_store);
            X509_STORE_CTX_free(store_ctx);
            
            return ( EST_ERR_MALLOC);
        }
        current_cert = sk_X509_value(stack, i);
        EST_LOG_INFO("Adding cert to store (%s)", current_cert->name);
	X509_STORE_CTX_set_cert(store_ctx, current_cert);
        
        rv = X509_verify_cert(store_ctx);
        if (!rv) {
            /*
             * this cert failed verification.  Log this and continue on
             */
            EST_LOG_WARN("Certificate failed verification (%s)", current_cert->name);
            failed = 1;
        }
    }

    /*
     * Finally, remove any CRLs that might be attached.
     */
    est_rc = est_client_remove_crls(ctx, cacerts, cacerts_len, pkcs7);

    free(cacerts_decoded);
    X509_STORE_free(trusted_cacerts_store);
    X509_STORE_CTX_free(store_ctx);
    PKCS7_free(pkcs7);
    
    if (failed) {
        return (EST_ERR_CACERT_VERIFICATION);
    } else {
        return est_rc;
    }
}
/*
 * This function is registered with SSL to be called during the verification
 * of each certificate in the server's identity cert chain.  The main purpose
 * is to look for the case where the cert could not be verified.  In this case,
 * if the EST client app has registered a callback to receive these untrusted
 * certs, it will be forwarded up to the EST client application.
 *
 * Parameters:
 *	ok:	The status of this certificate from the SSL verify code.
 *   x_ctx:     Ptr to the X509 certificate store structure  
 *
 * Return value:
 *   int: The potentially modified status after processing this certificate. This cane
 *        be modified by the ET client application if they've provided a callback
 *        allowing it to be processed, or modified here in this callback.
 */
static int cert_verify_cb (int ok, X509_STORE_CTX *x_ctx)
{
    SSL    *ssl;
    EST_CTX *e_ctx;
    int     approve;
    int cert_error = 0;
    X509 *current_cert = NULL;

    approve = ok;
    
    if (x_ctx == NULL) {
        EST_LOG_ERR("Invalid X509 context pointer");
        return (approve);
    }    
    
    cert_error = X509_STORE_CTX_get_error(x_ctx);
    current_cert = X509_STORE_CTX_get_current_cert(x_ctx);

    EST_LOG_INFO("entering: Cert passed up from OpenSSL. error = %d (%s) \n",
                 cert_error, X509_verify_cert_error_string(cert_error));

    /*
     * Retrieve the pointer to the SSL structure for this connection and then
     * the application specific data stored into the SSL object.  This will be
     * our EST ctx for this EST session.
     */
    if (e_ctx_ssl_exdata_index == SSL_EXDATA_INDEX_INVALID) {
        EST_LOG_ERR("Invalid SSL exdata index for EST context value");
        return (approve);
    }
        
    ssl = X509_STORE_CTX_get_ex_data(x_ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
    if (!ssl) {
        EST_LOG_ERR("NULL pointer retrieved for SSL session pointer from X509 ctx ex_data");
        return (approve);
    }        
    e_ctx = SSL_get_ex_data(ssl, e_ctx_ssl_exdata_index);
    if (!e_ctx) {
        EST_LOG_ERR("NULL pointer retrieved for EST context from SSL ex_data");
        return (approve);
    }        

    if (!ok) {
        switch (cert_error) {

            /*
             * Cases where we notify the client application:
             *
             * CERT_UNTRUSTED is what is expected, but not what we get in the
             * case where we cannot verify our server's cert.
             * SELF_SIGNED_CERT_IN_CHAIN is what currently results with our server
             * when we cannot verify its cert.
             * UNABLE_TO_GET_CRL is passed up to make sure the application knows
             * that although
             */
        case X509_V_ERR_CERT_UNTRUSTED:
        case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:  
        case X509_V_ERR_UNABLE_TO_GET_CRL:
            
            /*
             * If the application provided a callback then go ahead and pass
             * this cert store up.  If not, then log a warning and return what
             * SSL gave us for a status.
             */            
            if (e_ctx->manual_cert_verify_cb) {
                
                EST_LOG_INFO("EST client application server cert verify function is registered\n");

                approve = e_ctx->manual_cert_verify_cb(current_cert, cert_error);
                
            } else {
                                
                EST_LOG_INFO("NO EST client application server cert verify function registered\n");

                if (cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {

                    /*
                     * We've enabled CRL checking in the TLS stack.  If the
                     * application hasn't loaded a CRL, then this verify error
                     * can occur.  The peer's cert is valid, but we can't
                     * confirm if it was revoked.  The app has not provided
                     * a way for us to notify on this, so our only option is
                     * to log a warning and proceed on.
                     */
                    EST_LOG_WARN("No CRL loaded, TLS peer will be allowed.");
                    approve = 1;
                }
            }
            break;

        /* The remainder of these will result in the ok state remaining unchanged
         * and a EST log warning message being logged.
         */
        case X509_V_ERR_NO_EXPLICIT_POLICY:
        case X509_V_ERR_CERT_HAS_EXPIRED:

        /* since we are just checking the certificates, it is
         * ok if they are self signed. But we should still warn
         * the user.
         */
        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
        /* Continue after extension errors too */
        case X509_V_ERR_INVALID_CA:
        case X509_V_ERR_INVALID_NON_CA:
        case X509_V_ERR_PATH_LENGTH_EXCEEDED:
        case X509_V_ERR_INVALID_PURPOSE:
        case X509_V_ERR_CRL_HAS_EXPIRED:
        case X509_V_ERR_CRL_NOT_YET_VALID:
        case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
        case X509_V_ERR_CERT_REVOKED:
        default:
            EST_LOG_WARN("Certificate verify failed (reason = %d) (%s)",
                         cert_error, X509_verify_cert_error_string(cert_error));
            break;
        }
    }
    return (approve);
}
/*
 * This function is used to create and initialize an
 * SSL_CTX that will be used for client and proxy EST operations.
 * The SSL_CTX is stored on the EST_CTX.
 *
 * Parameters:
 *	ctx:	EST Context
 *
 * Return value:
 *	EST_ERROR
 *         EST_ERR_NONE if success
 */
static EST_ERROR est_client_init_ssl_ctx (EST_CTX *ctx)
{
    SSL_CTX     *s_ctx;
    X509_VERIFY_PARAM *vpm = NULL;
    EST_ERROR rv = EST_ERR_NONE;

    est_log_version();

    if (ctx == NULL) {
        EST_LOG_ERR("Invalid context pointer");
        return EST_ERR_NO_CTX;
    }
        
    if ((s_ctx = SSL_CTX_new(SSLv23_client_method())) == NULL) {
        EST_LOG_ERR("Failed to obtain a new SSL Context\n");
        ossl_dump_ssl_errors();
        return EST_ERR_SSL_CTX_NEW;
    }

    /*
     * Only TLS 1.1 or above can be used for EST
     */
    SSL_CTX_set_options(s_ctx, SSL_OP_NO_SSLv2 |
                        SSL_OP_NO_SSLv3 |
                        SSL_OP_NO_TLSv1);

    /*
     * limit the cipher suites that are offered
     */
    if (!SSL_CTX_set_cipher_list(s_ctx, EST_CIPHER_LIST)) { 
        EST_LOG_ERR("Failed to set SSL cipher suites\n");
        ossl_dump_ssl_errors();
        return EST_ERR_SSL_CIPHER_LIST;
    }

    /*
     * Make sure we're verifying the server
     */
    SSL_CTX_set_verify(s_ctx, SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                       cert_verify_cb);

    /*
     * leverage the cert store we already created from the
     * trusted CA chain provided by the application.
     *
     * In either case, the SSL stack will clean up the cert store during the
     * SSL_CTX_free(), so let's remove our reference to it so we don't try to
     * clean it up ourselves later
     */
    SSL_CTX_set_cert_store(s_ctx, ctx->trusted_certs_store);
    ctx->trusted_certs_store = NULL;        

    /*
     * Set up X509 params and assign them to the SSL ctx
     * - Enable CRL checks
     * - Max # of untrusted CA certs that can exist in a chain
     * - ensure that the cert is being used as intended, if
     *   it contains the X509 KeyUsage extension
     */
    vpm = X509_VERIFY_PARAM_new();
    if (vpm == NULL) {
        EST_LOG_ERR("Unable to allocate a verify parameter structure");
        ossl_dump_ssl_errors();
        return (EST_ERR_MALLOC);
    }
        
    /* Enable CRL checks */
    if (ctx->enable_crl) {
	X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_CRL_CHECK |
                                    X509_V_FLAG_CRL_CHECK_ALL);
    }
    X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_CRL_CHECK |
                                X509_V_FLAG_CRL_CHECK_ALL);
    X509_VERIFY_PARAM_set_depth(vpm, EST_TLS_VERIFY_DEPTH);

    X509_VERIFY_PARAM_set_purpose(vpm, X509_PURPOSE_SSL_SERVER);

    SSL_CTX_set1_param(s_ctx, vpm);
    X509_VERIFY_PARAM_free(vpm);

    /*
     * Save the reference to the SSL session
     * This will be used later when matching the EST_CTX to the SSL context
     * in est_ssl_info_cb().
     */
    ctx->ssl_ctx = s_ctx;

    if (e_ctx_ssl_exdata_index == SSL_EXDATA_INDEX_INVALID) {
        e_ctx_ssl_exdata_index = SSL_get_ex_new_index(0, "EST Context", NULL, NULL, NULL);    
    }

    /*
     * This last config setting is not ctx based, but instead, global to the
     * entire libcrypto library.  Need to ensure that CSR string attributes
     * are added in ASCII printable format.
     */
    ASN1_STRING_set_default_mask(B_ASN1_PRINTABLE);
    
    return rv;
}
/*
 * This function calculates the digest value to be
 * used in HTTP requests when the server has asked
 * the client to use HTTP digest authentication.
 * It uses the tokens that were parsed from the HTTP
 * server response earlier to calculate the digest.
 */
static unsigned char *est_client_generate_auth_digest (EST_CTX *ctx, char *uri,
                                                       char *user, char *pwd)
{
    EVP_MD_CTX *mdctx;
    const EVP_MD *md = EVP_md5();
    uint8_t ha1[EVP_MAX_MD_SIZE];
    unsigned int ha1_len;
    char ha1_str[EST_MAX_MD5_DIGEST_STR_LEN];
    uint8_t ha2[EVP_MAX_MD_SIZE];
    unsigned int ha2_len;
    char ha2_str[EST_MAX_MD5_DIGEST_STR_LEN];
    char nonce_cnt[9] = "00000001";
    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int d_len;
    unsigned char *rv;

    /*
     * Calculate HA1 using username, realm, password, and server nonce
     */
    mdctx = EVP_MD_CTX_create();
    if (!EVP_DigestInit_ex(mdctx, md, NULL)) {
        EST_LOG_ERR("Unable to Initialize digest");
        return NULL;
    }
    EVP_DigestUpdate(mdctx, user, strnlen_s(user, MAX_UIDPWD));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ctx->realm, strnlen_s(ctx->realm, MAX_REALM));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, pwd, strnlen_s(pwd, MAX_UIDPWD));
    EVP_DigestFinal(mdctx, ha1, &ha1_len);
    EVP_MD_CTX_destroy(mdctx);
    est_hex_to_str(ha1_str, ha1, ha1_len);

    /*
     * Calculate HA2 using method, URI,
     */
    mdctx = EVP_MD_CTX_create();
    if (!EVP_DigestInit_ex(mdctx, md, NULL)) {
        EST_LOG_ERR("Unable to Initialize digest");
        return NULL;
    }
    EVP_DigestUpdate(mdctx, "POST", 4);
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, uri, strnlen_s(uri, MAX_REALM));
    EVP_DigestFinal(mdctx, ha2, &ha2_len);
    EVP_MD_CTX_destroy(mdctx);
    est_hex_to_str(ha2_str, ha2, ha2_len);

    /*
     * Calculate auth digest using HA1, nonce, nonce count, client nonce, qop, HA2
     */
    mdctx = EVP_MD_CTX_create();
    if (!EVP_DigestInit_ex(mdctx, md, NULL)) {
        EST_LOG_ERR("Unable to Initialize digest");
        return NULL;
    }
    EVP_DigestUpdate(mdctx, ha1_str, ha1_len * 2);
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ctx->s_nonce, strnlen_s(ctx->s_nonce, MAX_NONCE));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, nonce_cnt, strnlen_s(nonce_cnt, MAX_NC));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ctx->c_nonce, strnlen_s(ctx->c_nonce, MAX_NONCE));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, "auth", 4);
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ha2_str, ha2_len * 2);
    EVP_DigestFinal(mdctx, digest, &d_len);
    EVP_MD_CTX_destroy(mdctx);

    rv = malloc(EST_MAX_MD5_DIGEST_STR_LEN);
    if (rv == NULL) {
        EST_LOG_ERR("Unable to allocate memory for digest");
        return NULL;
    }
    
    est_hex_to_str((char *)rv, digest, d_len);
    return (rv);
}
/*
 * est_client_retrieve_credentials() is used to retrieve the credentials when
 * the server has requested either BASIC or DIGEST mode.  The values needed from
 * the application layer in either mode are the same, username, password, but the
 * API will indicate the mode to the callback in case anything changes.
 */
static void est_client_retrieve_credentials (EST_CTX *ctx, EST_HTTP_AUTH_MODE auth_mode,
                                             char *user, char *pwd) 
{
    EST_HTTP_AUTH_HDR auth_credentials;
    EST_HTTP_AUTH_CRED_RC rc;
    
    /*
     * See if we only have one part of them.  If so, reset the part we
     * have.
     */
    if (ctx->userid[0] != '\0') {
        memzero_s(ctx->userid, sizeof(ctx->userid));
    }
            
    if (ctx->password[0] != '\0') {
        memzero_s(ctx->password, sizeof(ctx->password));
    }
                
    /*
     * Need to ask the application layer for the credentials
     */
    memzero_s(&auth_credentials, sizeof(auth_credentials));
            
    if (ctx->auth_credentials_cb) {
        auth_credentials.mode = auth_mode;
        rc = ctx->auth_credentials_cb(&auth_credentials);
        if (rc == EST_HTTP_AUTH_CRED_NOT_AVAILABLE) {
            EST_LOG_ERR("Attempt to obtain token from application failed.");
        }
    }

    /*
     * Did we get the credentials we expected?  If not, point to a NULL string
     * to generate the header
     */
    if (auth_credentials.user == NULL) {
        user[0] = '\0'; 
    } else if (MAX_UIDPWD < strnlen_s(auth_credentials.user, MAX_UIDPWD+1)) {
        EST_LOG_ERR("Userid provided is larger than the max of %d", MAX_UIDPWD);
        user[0] = '\0'; 
    } else {
        if (EOK != strncpy_s(user, MAX_UIDPWD, auth_credentials.user, MAX_UIDPWD)) {
            EST_LOG_ERR("Invalid User ID provided");
        }
    }
    
    if (auth_credentials.pwd == NULL) {
        pwd[0] = '\0'; 
    } else if (MAX_UIDPWD < strnlen_s(auth_credentials.pwd, MAX_UIDPWD+1)) {
        EST_LOG_ERR("Password provided is larger than the max of %d", MAX_UIDPWD);
        pwd[0] = '\0'; 
    } else {
        if (EOK != strncpy_s(pwd, MAX_UIDPWD, auth_credentials.pwd, MAX_UIDPWD)) {
            EST_LOG_ERR("Invalid User password provided");
        }
    }

    cleanse_auth_credentials(&auth_credentials);    
}
/*
 * This function adds the HTTP authentication header to
 * an outgoing HTTP request, allowing the server to
 * authenticate the EST client.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 *      uri:        pointer to a buffer that holds the uri to be used in the header
 */
static void est_client_add_auth_hdr (EST_CTX *ctx, char *hdr, char *uri)
{
    int hdr_len;
    unsigned char *digest;
    unsigned char client_random[8];
    char both[MAX_UIDPWD*2+2]; /* both UID and PWD + ":" + /0 */
    char both_b64[2*2*MAX_UIDPWD];
    int both_len = 0;
    EST_HTTP_AUTH_HDR auth_credentials;
    EST_HTTP_AUTH_CRED_RC rc;
    char *token = NULL;
    char token_b64[MAX_AUTH_TOKEN_LEN*2];
    char user[MAX_UIDPWD+1];
    char pwd[MAX_UIDPWD+1];
    int enc_len = 0;
    int token_len = 0;

    memzero_s(both, MAX_UIDPWD*2+2);
    memzero_s(both_b64, 2*2*MAX_UIDPWD);
    
    hdr_len = (int) strnlen_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
    if (hdr_len == EST_HTTP_REQ_TOTAL_LEN) {
        EST_LOG_WARN("Authentication header took up the maximum amount in buffer (%d)",
                     EST_HTTP_REQ_TOTAL_LEN);
    }
    
    switch (ctx->auth_mode) {
    case AUTH_BASIC:
        /*
         * make sure we have both parts of the credentials to send.  If we do,
         * then we're operating in the original mode where the app layer
         * provides them up front before they're needed.  If not, then we can
         * now go ask for them from the app layer.
         */
        if (ctx->userid[0] == '\0' && ctx->password[0] == '\0') {

            memzero_s(user, MAX_UIDPWD+1);
            memzero_s(pwd, MAX_UIDPWD+1);
            
            est_client_retrieve_credentials(ctx, ctx->auth_mode, user, pwd);
            
            /*
             * regardless of what comes back, build the string containing both
             */            
            snprintf(both, MAX_UIDPWD*2+2, "%s:%s", user, pwd);
        } else {
            /*
             * Use what was given during configuration through est_client_set_auth
             */
            snprintf(both, MAX_UIDPWD*2+2, "%s:%s", ctx->userid,
                     ctx->password);
        }
        
        /*
         * base64 encode the combined string and build the HTTP auth header
         */
        both_len = strnlen_s(both, MAX_UIDPWD*2+2);
        enc_len = est_base64_encode((const char *)both, both_len, both_b64, (2*2*MAX_UIDPWD));
        if (enc_len <= 0) {
            EST_LOG_ERR("Unable to encode basic auth value");
        }    
        snprintf(hdr + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len,
                 "Authorization: Basic %s\r\n", both_b64);
        break;
    case AUTH_DIGEST:

        /* Generate a client nonce */
        if (!RAND_bytes(client_random, 8)) {
            EST_LOG_ERR("RNG failure while generating nonce");
            /* Force hdr to a null string */
            memzero_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
            break;
        }
        
        est_hex_to_str(ctx->c_nonce, client_random, 8);

        /*
         * Check to see if the application layer has provided username and password
         * up front during configuration.  If it has not, go retrieve them now, otherwise,
         * copy them into the local buffers to get them ready
         */
        if (ctx->userid[0] == '\0' && ctx->password[0] == '\0') {

            memzero_s(user, MAX_UIDPWD+1);
            memzero_s(pwd, MAX_UIDPWD+1);
            
            est_client_retrieve_credentials(ctx, ctx->auth_mode, user, pwd);
        } else {
            if (EOK != strncpy_s(user, MAX_UIDPWD, ctx->userid, MAX_UIDPWD)) {
                EST_LOG_ERR("Invalid User ID provided");
            }
            if (EOK != strncpy_s(pwd, MAX_UIDPWD, ctx->password, MAX_UIDPWD)) {
                EST_LOG_ERR("Invalid User password provided");
            }
        }
        
        digest = est_client_generate_auth_digest(ctx, uri, user, pwd);
        if (digest == NULL) {
            EST_LOG_ERR("Error while generating digest");
            /* Force hdr to a null string */
            memzero_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
            memzero_s(ctx->c_nonce, MAX_NONCE+1);
            memzero_s(user, MAX_UIDPWD+1);
            memzero_s(pwd, MAX_UIDPWD+1);
            break;
        }
            
        snprintf(hdr + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len,
                 "Authorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", cnonce=\"%s\", nc=00000001, qop=\"auth\", response=\"%s\"\r\n",
                user,
                ctx->realm,
                ctx->s_nonce,
                uri,
                ctx->c_nonce,
                digest);
        memzero_s(digest, EST_MAX_MD5_DIGEST_STR_LEN);
        memzero_s(ctx->c_nonce, MAX_NONCE+1);
        memzero_s(user, MAX_UIDPWD+1);
        memzero_s(pwd, MAX_UIDPWD+1);
        free(digest);
        break;
    case AUTH_TOKEN:
        
        EST_LOG_INFO("Server requested Token based authentication");

        memzero_s(&auth_credentials, sizeof(auth_credentials));
        
        if (ctx->auth_credentials_cb) {    
            auth_credentials.mode = AUTH_TOKEN;
            rc = ctx->auth_credentials_cb(&auth_credentials);
            if (rc == EST_HTTP_AUTH_CRED_NOT_AVAILABLE) {
                EST_LOG_ERR("Attempt to obtain token from application failed.");
            }
        }

        /*
         * Did we get the credentials we expected?  If not, point to a NULL string
         * to generate the header
         */
        if (auth_credentials.auth_token == NULL) {
            EST_LOG_ERR("Requested token credentials, but application did not provide any.");
            token = ""; 
        } else {

            /*
             * Make sure the token we were given is not too long.
             * If it is, force it to NULL to cause the auth failure at
             * the server just as if no credentials were provided
             */
            if (MAX_AUTH_TOKEN_LEN < strnlen_s(auth_credentials.auth_token, MAX_AUTH_TOKEN_LEN+1)) {
                EST_LOG_ERR("Token provided is larger than the max of %d",
                            MAX_AUTH_TOKEN_LEN);
                token = "";
            } else {
                token = auth_credentials.auth_token;
            }
        }

        /*
         * base64 encode the combined string and build the HTTP auth header
         */
        memzero_s(token_b64, MAX_AUTH_TOKEN_LEN*2);
        token_len = strnlen_s(token, MAX_AUTH_TOKEN_LEN);
        enc_len = est_base64_encode((const char *)token, token_len,
                                    token_b64, MAX_AUTH_TOKEN_LEN*2);
        
        if (enc_len <= 0) {
            EST_LOG_ERR("Unable to encode bearer token auth value");
        }    
        
        snprintf(hdr + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len,
                 "Authorization: Bearer %s\r\n", token_b64);

        cleanse_auth_credentials(&auth_credentials);
        
        break;
    default:
        EST_LOG_INFO("No HTTP auth mode set, sending anonymous request");
        break;
    }
}
/*
 * This function is used to build the HTTP header for
 * the CAcerts request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 */
static int est_client_build_cacerts_header (EST_CTX *ctx, char *hdr)
{
    int hdr_len;

    snprintf(hdr, EST_HTTP_REQ_TOTAL_LEN, "GET %s%s%s/%s HTTP/1.1\r\n"
            "User-Agent: %s\r\n"
            "Connection: close\r\n"
            "Host: %s:%d\r\n"
            "Accept: */*\r\n",
            EST_PATH_PREFIX,
            (ctx->uri_path_segment?"/":""),
            (ctx->uri_path_segment?ctx->uri_path_segment:""),
            EST_GET_CACERTS, 
            EST_HTTP_HDR_EST_CLIENT,
            ctx->est_server, ctx->est_port_num);
    hdr_len = (int) strnlen_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
    if (hdr_len == EST_HTTP_REQ_TOTAL_LEN) {
        EST_LOG_WARN("CA Certs header took up the maximum amount in buffer (%d)",
                     EST_HTTP_REQ_TOTAL_LEN);
    }
    
    return (hdr_len);
}
/*
 * This function is used to build the HTTP header for
 * the CSR attributes request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 */
static int est_client_build_csr_header (EST_CTX *ctx, char *hdr)
{
    int hdr_len;

    snprintf(hdr, EST_HTTP_REQ_TOTAL_LEN,"GET %s%s%s/%s HTTP/1.1\r\n"
            "User-Agent: %s\r\n"
            "Connection: close\r\n"
            "Host: %s:%d\r\n"
            "Accept: */*\r\n",
            EST_PATH_PREFIX,
            (ctx->uri_path_segment?"/":""),
            (ctx->uri_path_segment?ctx->uri_path_segment:""),
            EST_GET_CSRATTRS,
            EST_HTTP_HDR_EST_CLIENT,
            ctx->est_server, ctx->est_port_num);
    est_client_add_auth_hdr(ctx, hdr, EST_SIMPLE_ENROLL_URI);
    hdr_len = (int) strnlen_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
    if (hdr_len == EST_HTTP_REQ_TOTAL_LEN) {
        EST_LOG_WARN("CSR attributes request header took up the maximum amount in buffer (%d)",
                     EST_HTTP_REQ_TOTAL_LEN);
    }
    return (hdr_len);
}
/*
 * This function does the work for the CSR attributes request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 */
static int est_client_send_csrattrs_request (EST_CTX *ctx, SSL *ssl,
					     unsigned char **csrattrs, 
					     int *csrattrs_len)
{
    char        *http_data;
    int hdr_len;
    int read_size, write_size;
    unsigned char *csr_attrs_buf = NULL;
    int rv;

    /* assume defeat */
    *csrattrs = NULL;
    *csrattrs_len = 0;
    /*
     * Build the HTTP request
     * - allocate buffer: header, no data, terminating characters
     * - build the header
     * - no data
     * - terminate it
     */    
    http_data = malloc(EST_HTTP_REQ_TOTAL_LEN);
    if (http_data == NULL) {
        EST_LOG_ERR("Unable to allocate memory for http_data");
        return EST_ERR_MALLOC;
    }
    
    hdr_len = est_client_build_csr_header(ctx, http_data);

    if (hdr_len == 0) {
        EST_LOG_ERR("CSR attributes HTTP header could not be built correctly");
        free(http_data);
        return (EST_ERR_HTTP_CANNOT_BUILD_HEADER);
    }    

    /*
     * terminate the HTTP header
     */
    snprintf(http_data + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len, "\r\n");
    hdr_len += 2;

    /*
     * no data is being sent so go ahead and terminate the HTTP request
     */
    snprintf(http_data + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len, "\r\n");
    hdr_len += 2;


    /*
     * Send the request to the server and wait for a response
     */
    ctx->last_http_status = 0;
    write_size = SSL_write(ssl, http_data, hdr_len);
    if (write_size < 0) {
        EST_LOG_ERR("TLS write error");
	ossl_dump_ssl_errors();
        rv = EST_ERR_SSL_WRITE;
    } else {
        EST_LOG_INFO("TLS wrote %d bytes, attempted %d bytes\n",
                     write_size, hdr_len);

	/*
         * Try to get the response from the server
         */
        rv = est_io_get_response(ctx, ssl, EST_OP_CSRATTRS,
                                 &csr_attrs_buf, &read_size);
        switch (rv) {
        case EST_ERR_NONE:
	    if (csr_attrs_buf != NULL) {
		*csrattrs = csr_attrs_buf;
		*csrattrs_len = read_size;
            }
            break;
        case EST_ERR_AUTH_FAIL:
        default:
            EST_LOG_ERR("EST request failed: %d (%s)", rv, EST_ERR_NUM_TO_STR(rv));
	    if (csr_attrs_buf) {
                free(csr_attrs_buf);
            }
            break;
        }
    }
    free(http_data);
    return (rv);
}
/*
 * This function is used to build the HTTP header for
 * the Simple Enroll flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 *      pkcs10_len: length of the buffer pointed to by hdr 
 */
static int est_client_build_enroll_header (EST_CTX *ctx, char *hdr, int pkcs10_len)
{
    int hdr_len;

    snprintf(hdr, EST_HTTP_REQ_TOTAL_LEN, "POST %s%s%s/%s HTTP/1.1\r\n"
            "User-Agent: %s\r\n"
            "Connection: close\r\n"
            "Host: %s:%d\r\n"
            "Accept: */*\r\n"
            "Content-Type: application/pkcs10\r\n"
            "Content-Length: %d\r\n",
            EST_PATH_PREFIX,
            (ctx->uri_path_segment?"/":""),
            (ctx->uri_path_segment?ctx->uri_path_segment:""),
            EST_SIMPLE_ENROLL, 
            EST_HTTP_HDR_EST_CLIENT,
            ctx->est_server, ctx->est_port_num, pkcs10_len);
    est_client_add_auth_hdr(ctx, hdr, EST_SIMPLE_ENROLL_URI);
    hdr_len = (int) strnlen_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
    if (hdr_len == EST_HTTP_REQ_TOTAL_LEN) {
        EST_LOG_WARN("Client enroll request header took up the maximum amount in buffer (%d)",
                     EST_HTTP_REQ_TOTAL_LEN);
    }
    
    return (hdr_len);
}
/*
 * This function is used to build the HTTP header for
 * the Simple ReEnroll flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	hdr:        pointer to the buffer to hold the header
 *      pkcs10_len: length of the buffer pointed to by hdr 
 */
static int est_client_build_reenroll_header (EST_CTX *ctx, char *hdr, int pkcs10_len)
{
    int hdr_len;

    snprintf(hdr, EST_HTTP_REQ_TOTAL_LEN, "POST %s%s%s/%s HTTP/1.1\r\n"
            "User-Agent: %s\r\n"
            "Connection: close\r\n"
            "Host: %s:%d\r\n"
            "Accept: */*\r\n"
            "Content-Type: application/pkcs10\r\n"
            "Content-Length: %d\r\n",
            EST_PATH_PREFIX,
            (ctx->uri_path_segment?"/":""),
            (ctx->uri_path_segment?ctx->uri_path_segment:""),
            EST_SIMPLE_REENROLL, 
            EST_HTTP_HDR_EST_CLIENT,
            ctx->est_server, ctx->est_port_num, pkcs10_len);
    est_client_add_auth_hdr(ctx, hdr, EST_SIMPLE_ENROLL_URI);
    hdr_len = (int) strnlen_s(hdr, EST_HTTP_REQ_TOTAL_LEN);
    if (hdr_len == EST_HTTP_REQ_TOTAL_LEN) {
        EST_LOG_WARN("Client reenroll request header took up the maximum amount in buffer (%d)",
                     EST_HTTP_REQ_TOTAL_LEN);
    }
    return (hdr_len);
}
/*
 * This function sends the HTTP request for a Simple Enroll
 * The CSR (pkcs10) is already built at this point.  This
 * function simply creates the HTTP header and body and puts
 * it on the wire.  It then waits for a response from the
 * server and copies the response to a buffer provided by
 * the caller
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 *	bptr:	    pointer containing PKCS10 CSR
 *	pkcs7:	    pointer that will receive the pkcs7 response
 *	pkcs7_len:  length of pkcs7 response
 *	reenroll:   Set to 1 to do a reenroll instead of an enroll
 *
 */
int est_client_send_enroll_request (EST_CTX *ctx, SSL *ssl, BUF_MEM *bptr,
                                    unsigned char *pkcs7, int *pkcs7_len,
				    int reenroll)
{
    char *http_data;
    int hdr_len;
    int write_size;
    unsigned char *enroll_buf = NULL;
    int enroll_buf_len = 0;
    int rv;

    /*
     * Assume the enroll will fail, set return length to zero
     * to be defensive.
     */
    *pkcs7_len = 0;

    /*
     * Build the HTTP request
     * - allocate buffer: header, data, terminating characters
     * - build the header
     * - no data
     * - terminate it
     */    
    http_data = malloc(EST_HTTP_REQ_TOTAL_LEN);
    if (http_data == NULL) {
        EST_LOG_ERR("Unable to allocate memory for http_data");
        return EST_ERR_MALLOC;
    }

    if (!reenroll) {
	/* Perform a /simpleenroll */
        hdr_len = est_client_build_enroll_header(ctx, http_data, (int) bptr->length);
    } else {
	/* Perform a /simplereenroll */
        hdr_len = est_client_build_reenroll_header(ctx, http_data, (int) bptr->length);
    }

    if (hdr_len == 0) {
        EST_LOG_ERR("Enroll HTTP header could not be built correctly");
        free(http_data);
        return (EST_ERR_HTTP_CANNOT_BUILD_HEADER);
    }
        
    /*
     * terminate the HTTP header
     */
    snprintf(http_data + hdr_len,EST_HTTP_REQ_TOTAL_LEN-hdr_len, "\r\n");
    hdr_len += 2;

    /*
     * Build the HTTP body containing the pkcs10 request
     */
    memcpy_s(http_data + hdr_len, EST_HTTP_REQ_DATA_MAX,
             bptr->data, (rsize_t)bptr->length);
    hdr_len += bptr->length;

    /*
     * terminate the HTTP request
     */
    snprintf(http_data + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len,"\r\n");
    hdr_len += 2;


    /*
     * Send the request to the server and wait for a response
     */
    ctx->last_http_status = 0;
    write_size = SSL_write(ssl, http_data, hdr_len);
    if (write_size < 0) {
        EST_LOG_ERR("TLS write error");
	ossl_dump_ssl_errors();
        rv = EST_ERR_SSL_WRITE;
    } else {
        EST_LOG_INFO("TLS wrote %d bytes, attempted %d bytes\n",
                     write_size, hdr_len);

        /*
         * Try to get the response from the server
         */
        rv = est_io_get_response(ctx, ssl, EST_OP_SIMPLE_ENROLL,
                                 &enroll_buf, &enroll_buf_len);
        switch (rv) {
        case EST_ERR_NONE:
            if (enroll_buf_len == 0) {
                EST_LOG_ERR("Enroll buf is zero bytes in length");
                rv = EST_ERR_ZERO_LENGTH_BUF;
                break;
            }
            memcpy_s(pkcs7, EST_MAX_CLIENT_CERT_LEN, enroll_buf, enroll_buf_len);
            *pkcs7_len = enroll_buf_len;
            break;
        case EST_ERR_AUTH_FAIL:
            EST_LOG_WARN("HTTP auth failure");
            break;
        default:
            EST_LOG_ERR("EST request failed: %d (%s)", rv, EST_ERR_NUM_TO_STR(rv));
            break;
        }
        free(enroll_buf);
    }
    OPENSSL_cleanse(http_data, strnlen_s(http_data, EST_HTTP_REQ_TOTAL_LEN));
    free(http_data);
    http_data = NULL;
    return (rv);
}
/*
 * This function does a sanity check on the X509
 * prior to attempting to convert the X509 to
 * a CSR for a reenroll operation.
 *
 * Returns an EST_ERROR code
 */
static EST_ERROR est_client_check_x509 (X509 *cert) 
{
    /*
     * Make sure the cert is signed
     */
    if(!cert->signature) {
	EST_LOG_ERR("The certificate provided does not contain a signature.");
	return (EST_ERR_BAD_X509);
    }

    /*
     * Make sure the signature length is not invalid 
     */
    if (cert->signature->length <= 0) {
	EST_LOG_ERR("The certificate provided contains an invalid signature length.");
	return (EST_ERR_BAD_X509);
    }
    return (EST_ERR_NONE);
}
/*
 * This function is used to clear any ChallengePassword
 * attributes in an X509 CSR.  This is used because when
 * HTTP authentication is used during the enrollment
 * process, the PoP value will change when the client
 * sends the second HTTP request that contains the HTTP
 * authorization values. Since the CSR is reused between
 * both the initial and secondary requests, we need to
 * clear the PoP value from the CSR before submitting
 * the secondary request.
 */
static void est_client_clear_csr_pop (X509_REQ *csr)
{
    int pos = 0;
    X509_ATTRIBUTE *attr;

    /*
     * The challenge password (PoP) may be in the CSR 
     * more than once.  This should never happen, but
     * we're being defensive.
     */
    while (pos >= 0) {
	/*
	 * Look for the PoP value in the CSR 
	 */
	pos = X509_REQ_get_attr_by_NID(csr, NID_pkcs9_challengePassword, -1);
	if (pos >= 0) {
	    /* 
	     * If found, delete it
	     */
	    attr = X509_REQ_delete_attr(csr, pos);
	    if (attr) {
		/*
		 * There are no docs in OpenSSL that show how
		 * to use X509_REQ_delete_attr.  Going to assume
		 * we need to free the attribute ourselves.  There
		 * do not appear to be any good examples on how
		 * to use this API.
		 */
		X509_ATTRIBUTE_free(attr);
	    }
	}
    }
}
/*
 * This function does the work of converting the X509_REQ* to
 * the base64 encoded DER format as specified in the EST RFC.
 * Once converted to the proper format, this routine will
 * forward the request to the server, check the response,
 * and save the cert on the local context where it can be
 * retrieved later by the application layer.
 */
static EST_ERROR est_client_enroll_req (EST_CTX *ctx, SSL *ssl, X509_REQ *req, 
	                                int *pkcs7_len, int reenroll)
{
    EST_ERROR    rv = EST_ERR_NONE;
    BIO         *p10out = NULL, *b64;
    BUF_MEM     *bptr = NULL;
    unsigned char *recv_buf;
    unsigned char *new_cert_buf;
    int          new_cert_buf_len;

    /*
     * Grab the PKCS10 PEM encoded data
     */
    b64 = BIO_new(BIO_f_base64());
    if (!b64) {
        EST_LOG_ERR("BIO_new failed");
        ossl_dump_ssl_errors();
        return EST_ERR_MALLOC;
    }
    p10out = BIO_new(BIO_s_mem());
    if (!p10out) {
        EST_LOG_ERR("BIO_new failed");
	ossl_dump_ssl_errors();
        return EST_ERR_MALLOC;
    }
    p10out = BIO_push(b64, p10out);

    /*
     * Encode using DER (ASN.1) 
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     * */
    req->req_info->enc.modified = 1; 
    i2d_X509_REQ_bio(p10out, req);
    (void)BIO_flush(p10out);
    BIO_get_mem_ptr(p10out, &bptr);

    /*
     * Get the buffer in which to place the entire response from the server
     */
    recv_buf = malloc(EST_CA_MAX);
    if (recv_buf == NULL) {
        EST_LOG_ERR("Failed to allocate buffer for server response");
        return EST_ERR_MALLOC;
    }
    new_cert_buf = recv_buf; 
    new_cert_buf_len = 0;

    /*
     * Send the PKCS10 as an HTTP request to the EST server
     */
    rv = est_client_send_enroll_request(ctx, ssl, bptr,
                                        new_cert_buf, &new_cert_buf_len, 
					reenroll);
    switch (rv) {

    case EST_ERR_NONE:
        /*
         * Make sure that even though we got a success return code, that we
         * actually received something
         */
        if (new_cert_buf_len == 0) {
            EST_LOG_ERR("Buffer containing newly enrolled client certificate is zero bytes in length");
            rv = EST_ERR_ZERO_LENGTH_BUF;
            break;
        }

        /*
         * Resize the buffer holding the retrieved client certificate and link
         * it into the ctx.  Get rid of the http hdr and any extra space on
         * the back.
         */
        if (ctx->enrolled_client_cert != NULL){
            free(ctx->enrolled_client_cert);
        }
        ctx->enrolled_client_cert = malloc(new_cert_buf_len+1);
        if (ctx->enrolled_client_cert == NULL) {
            
            EST_LOG_ERR("Unable to allocate newly enrolled client certificate buffer");
            rv = EST_ERR_MALLOC;
            break;
        }
        ctx->enrolled_client_cert[new_cert_buf_len] = '\0';
        memcpy_s(ctx->enrolled_client_cert, new_cert_buf_len+1, new_cert_buf,
                 new_cert_buf_len);
        ctx->enrolled_client_cert_len = new_cert_buf_len;

        /*
         * pass back the length of this newly enrolled cert
         */
        *pkcs7_len = ctx->enrolled_client_cert_len;
        
        EST_LOG_INFO("Newly Enrolled Client certificate: %s", ctx->enrolled_client_cert);
        EST_LOG_INFO("length: %d", ctx->enrolled_client_cert_len);
        break;

    case EST_ERR_AUTH_FAIL:
        EST_LOG_INFO("HTTP Authorization failed. Requested auth mode = %d", ctx->auth_mode);
        break;

    default:
        
        EST_LOG_ERR("EST enrollment failed, error code is %d (%s)", rv,
                    EST_ERR_NUM_TO_STR(rv));
        break;
    }

    if (recv_buf) {
        free(recv_buf);
    }
    BIO_free_all(p10out);
    return (rv);
}
/*  est_client_enroll_pkcs10() This function implements the Simple Enroll
 *  flow. It signs the CSR that was provided and then sends the CSR
 *  to the EST server and retrieves the pkcs7 response.
 *
 *  Parameters:
 *    ctx    EST context
 *    ssl    SSL context being used for this EST session
 *    csr    Pointer to X509_REQ object containing the PKCS10 CSR
 *    pkcs7_len  pointer to an integer in which the length of the recieved
 *               pkcs7 response is placed.
 *    priv_key Pointer to the private key used to sign the CSR.
 *    reenroll Set to 1 to do a reenroll instead of an enroll
 *
 *  Returns EST_ERROR  
 */
static EST_ERROR est_client_enroll_pkcs10 (EST_CTX *ctx, SSL *ssl, X509_REQ *csr,
                                           int *pkcs7_len, EVP_PKEY *priv_key,
                                           int reenroll)
{
    EST_ERROR    rv = EST_ERR_NONE;
    char        *tls_uid;
    int          ossl_rv;

    /*
     * Make sure the PoP is removed from the CSR before we proceed
     */
    est_client_clear_csr_pop(csr);

    /*
     * Get the PoP value from the TLS session and embed this into
     * the CSR if required.
     */
    if (ctx->csr_pop_required || ctx->client_force_pop) {
	EST_LOG_INFO("Client will include challengePassword in CSR");
        tls_uid = est_get_tls_uid(ssl, 1);
	if (tls_uid) {
	    ossl_rv = X509_REQ_add1_attr_by_NID(csr, NID_pkcs9_challengePassword,
                                                MBSTRING_ASC, (unsigned char*)tls_uid, -1);
	    free(tls_uid);
	    if (!ossl_rv) {
	        EST_LOG_ERR("Unable to set X509 challengePassword attribute");
		ossl_dump_ssl_errors();
		return (EST_ERR_X509_ATTR);
	    }
        } else {
            EST_LOG_ERR("Unable to obtain the TLS UID");
	    return (EST_ERR_AUTH_FAIL_TLSUID);
	}
    }

    /*
     * Sign the CSR
     */
    ossl_rv = est_client_X509_REQ_sign(csr, priv_key, ctx->signing_digest);
    if (!ossl_rv) {
        EST_LOG_ERR("Unable to sign X509 cert request");
        ossl_dump_ssl_errors();
        return (EST_ERR_X509_SIGN);
    }

    rv = est_client_enroll_req(ctx, ssl, csr, pkcs7_len, reenroll);

    return (rv);
}
/*  est_client_enroll_cn() This function implements the Simple Enroll
    flow. It uses the private key to generate a CSR (pkcs10) request.  It
    then sends the request to the EST server and retrieves the pkcs7
    response.  The user of this function simply provides the CommonName
    value to be placed in the PKCS10 CSR.  This is a simplified interface,
    none of the other CSR attributes can be specified.

    @param ctx EST context
    @param ssl SSL context being used for this EST session
    @param cn pointer to the common name that is to be placed in the x509
    request
    @param pkcs7_len pointer to an integer in which the length of the recieved
    pkcs7 response is placed.
    @param pkey The new client public key that is to be enrolled

    @return EST_ERROR 
 */
static EST_ERROR est_client_enroll_cn (EST_CTX *ctx, SSL *ssl, char *cn,
                                         int *pkcs7_len, EVP_PKEY *pkey)
{
    X509_REQ    *pkcs10 = NULL;
    EST_ERROR    rv = EST_ERR_NONE;
    char        *tls_uid;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    /*
     * Attempt to create the PKCS10 certificate request.
     * Get the TLS uid in case we need it during populate.
     */
    tls_uid = est_get_tls_uid(ssl, 1);
    if (tls_uid) {
        rv = est_generate_pkcs10(ctx, cn, tls_uid, pkey, &pkcs10);
        free(tls_uid);
    } else {
        EST_LOG_ERR("Unable to obtain the TLS UID");
        rv = EST_ERR_AUTH_FAIL_TLSUID;
    }

    if (rv == EST_ERR_NONE) {
        rv = est_client_enroll_req(ctx, ssl, pkcs10, pkcs7_len, 0);
    }
    
    if (pkcs10) {
        X509_REQ_free(pkcs10);
    }

    return (rv);
}
/* 
 * The following function was taken from cURL
 *
 * The content that was incorporated were portions of
 * - lib/hostcheck.c
 * - lib/rawstr.c
 *
 * Portable, consistent toupper (remember EBCDIC). Do not use toupper() because
 * its behavior is altered by the current locale. 
 */
static char est_client_Curl_raw_toupper(char in)
{
    switch (in) {
    case 'a':
        return 'A';
    case 'b':
        return 'B';
    case 'c':
        return 'C';
    case 'd':
        return 'D';
    case 'e':
        return 'E';
    case 'f':
        return 'F';
    case 'g':
        return 'G';
    case 'h':
        return 'H';
    case 'i':
        return 'I';
    case 'j':
        return 'J';
    case 'k':
        return 'K';
    case 'l':
        return 'L';
    case 'm':
        return 'M';
    case 'n':
        return 'N';
    case 'o':
        return 'O';
    case 'p':
        return 'P';
    case 'q':
        return 'Q';
    case 'r':
        return 'R';
    case 's':
        return 'S';
    case 't':
        return 'T';
    case 'u':
        return 'U';
    case 'v':
        return 'V';
    case 'w':
        return 'W';
    case 'x':
        return 'X';
    case 'y':
        return 'Y';
    case 'z':
        return 'Z';
    }
    return in;
}
/*
 * The following function was taken from cURL
 *
 * Curl_raw_equal() is for doing "raw" case insensitive strings. This is meant
 * to be locale independent and only compare strings we know are safe for
 * this.  See http://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for
 * some further explanation to why this function is necessary.
 *
 * The function is capable of comparing a-z case insensitively even for
 * non-ascii.
 */
static int est_client_Curl_raw_equal(const char *first, const char *second)
{
    while(*first && *second) {
	if(est_client_Curl_raw_toupper(*first) != est_client_Curl_raw_toupper(*second)) {
	    /* get out of the loop as soon as they don't match */
	    break;
	}
	first++;
	second++;
    }
    /* we do the comparison here (possibly again), just to make sure that if the
       loop above is skipped because one of the strings reached zero, we must not
       return this as a successful match */
    return (est_client_Curl_raw_toupper(*first) == est_client_Curl_raw_toupper(*second));
}
/*
 * The following function was taken from cURL
 *
 * Curl_raw_equal() is for doing "raw" case insensitive strings. This is meant
 * to be locale independent and only compare strings we know are safe for
 * this.  See http://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for
 * some further explanation to why this function is necessary.
 *
 * The function is capable of comparing a-z case insensitively even for
 * non-ascii.
 */
static int est_client_Curl_raw_nequal(const char *first, const char *second, size_t max)
{
    while(*first && *second && max) {
	if(est_client_Curl_raw_toupper(*first) != est_client_Curl_raw_toupper(*second)) {
	    break;
	}
	max--;
	first++;
	second++;
    }
    if(0 == max) {
	return 1; /* they are equal this far */
    }

    return (est_client_Curl_raw_toupper(*first) == est_client_Curl_raw_toupper(*second));
}
/*
 * The following function was taken from cURL
 *
 * Curl_raw_equal() is for doing "raw" case insensitive strings. This is meant
 * to be locale independent and only compare strings we know are safe for
 * this.  See http://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for
 * some further explanation to why this function is necessary.
 *
 * The function is capable of comparing a-z case insensitively even for
 * non-ascii.
 */
static int est_client_hostmatch(const char *hostname, const char *pattern)
{
    const char *pattern_label_end, *pattern_wildcard, *hostname_label_end;
    int wildcard_enabled;
    size_t prefixlen, suffixlen;
    struct in_addr ignored;
    struct sockaddr_in6 si6;

    pattern_wildcard = strchr(pattern, '*');
    if(pattern_wildcard == NULL) {
	return est_client_Curl_raw_equal(pattern, hostname) ? HOST_MATCH : HOST_NOMATCH;
    }
    
    /* detect IP address as hostname and fail the match if so */
    if(inet_pton(AF_INET, hostname, &ignored) > 0)
        return HOST_NOMATCH;
    else if(inet_pton(AF_INET6, hostname, &si6.sin6_addr) > 0)
        return HOST_NOMATCH;

    /* We require at least 2 dots in pattern to avoid too wide wildcard
       match. */
    wildcard_enabled = 1;
    pattern_label_end = strchr(pattern, '.');
    if(pattern_label_end == NULL || strchr(pattern_label_end+1, '.') == NULL ||
	pattern_wildcard > pattern_label_end ||
	est_client_Curl_raw_nequal(pattern, "xn--", 4)) {
	wildcard_enabled = 0;
    }
    if(!wildcard_enabled) {
	return est_client_Curl_raw_equal(pattern, hostname) ? HOST_MATCH : HOST_NOMATCH;
    }
    hostname_label_end = strchr(hostname, '.');
    if(hostname_label_end == NULL || !est_client_Curl_raw_equal(pattern_label_end, hostname_label_end)) {
	return HOST_NOMATCH;
    }
    /* The wildcard must match at least one character, so the left-most
       label of the hostname is at least as large as the left-most label
       of the pattern. */
    if(hostname_label_end - hostname < pattern_label_end - pattern) {
	return HOST_NOMATCH;
    }
    prefixlen = pattern_wildcard - pattern;
    suffixlen = pattern_label_end - (pattern_wildcard+1);
    return (est_client_Curl_raw_nequal(pattern, hostname, prefixlen) &&
	    est_client_Curl_raw_nequal(pattern_wildcard+1, hostname_label_end - suffixlen,
                                       suffixlen) ?  HOST_MATCH : HOST_NOMATCH);
}
/*
 * The following function was taken from cURL for the
 * FQDN check on the server cert
 */
static int est_client_cert_hostcheck(const char *match_pattern, const char *hostname)
{
    /*
     * Sanity check input 
     */
    if(!match_pattern || !*match_pattern || !hostname || !*hostname) { 
	return 0;
    }

    /*
     * trival case
     */
    if(est_client_Curl_raw_equal(hostname, match_pattern)) {
	return 1;
    }

    if(est_client_hostmatch(hostname,match_pattern) == HOST_MATCH) {
	return 1;
    }
    return 0;
}
/* 
 * This function was taken from cURL and adapted to EST.
 *
 * cURL file name is ./lib/ssluse.c, function: verifyhost()
 *
 * Quote from RFC2818 section 3.1 "Server Identity"

   If a subjectAltName extension of type dNSName is present, that MUST
   be used as the identity. Otherwise, the (most specific) Common Name
   field in the Subject field of the certificate MUST be used. Although
   the use of the Common Name is existing practice, it is deprecated and
   Certification Authorities are encouraged to use the dNSName instead.

   Matching is performed using the matching rules specified by
   [RFC2459].  If more than one identity of a given type is present in
   the certificate (e.g., more than one dNSName name, a match in any one
   of the set is considered acceptable.) Names may contain the wildcard
   character * which is considered to match any single domain name
   component or component fragment. E.g., *.a.com matches foo.a.com but
   not bar.foo.a.com. f*.com matches foo.com but not bar.com.

   In some cases, the URI is specified as an IP address rather than a
   hostname. In this case, the iPAddress subjectAltName must be present
   in the certificate and must exactly match the IP in the URI.

 */
static EST_ERROR est_client_verifyhost (char *hostname, X509 *server_cert)
{
    int matched = -1;     /* -1 is no alternative match yet, 1 means match and 0
                             means mismatch */
    size_t addrlen = 0;
    STACK_OF(GENERAL_NAME) * altnames;
    struct in6_addr addr_v6;
    struct in_addr addr_v4;
    int addr_is_v4 = 0;
    int addr_is_v6 = 0;
    EST_ERROR res = EST_ERR_NONE;
    int rv;
    errno_t safec_rc;
    int numalts;
    int i, j;
    int diff;
    const GENERAL_NAME *check; 
    const char *altptr; 
    size_t altlen; 
    unsigned char *nulstr; 
    unsigned char *peer_CN; 
    X509_NAME *name; 
    ASN1_STRING *tmp;

    /*
     * Attempt to resolve host name to v4 address 
     */
    rv = inet_pton(AF_INET, hostname, &addr_v4);
    if (rv) {
	addr_is_v4 = 1;
        addrlen = sizeof(struct in_addr);
    } else {
	/*
	 * Try to see if hostname resolves to v6 address
	 */
	rv = inet_pton(AF_INET6, hostname, &addr_v6);
	if (rv) {
	    addr_is_v6 = 1;
	    addrlen = sizeof(struct in6_addr);
	}
    }

    /* get a "list" of alternative names */
    altnames = X509_get_ext_d2i(server_cert, NID_subject_alt_name, NULL, NULL);

    if (altnames) {
        /* get amount of alternatives, RFC2459 claims there MUST be at least
           one, but we don't depend on it... */
        numalts = sk_GENERAL_NAME_num(altnames);
        EST_LOG_INFO("Found %d SubjectAlternateNames", numalts);

        /* loop through all alternatives while none has matched */
        for (i = 0; (i < numalts) && (matched != 1); i++) {
            /* get a handle to alternative name number i */
            check = sk_GENERAL_NAME_value(altnames, i);

            /* get data and length */
            altptr = (char*)ASN1_STRING_data(check->d.ia5);
            altlen = (size_t)ASN1_STRING_length(check->d.ia5);

            switch (check->type) {
            case GEN_DNS: /* name/pattern comparison */
                EST_LOG_INFO("Checking FQDN against SAN %s", altptr);
                /* The OpenSSL man page explicitly says: "In general it cannot be
                   assumed that the data returned by ASN1_STRING_data() is null
                   terminated or does not contain embedded nulls." But also that
                   "The actual format of the data will depend on the actual string
                   type itself: for example for and IA5String the data will be ASCII"

                   Gisle researched the OpenSSL sources:
                   "I checked the 0.9.6 and 0.9.8 sources before my patch and
                   it always 0-terminates an IA5String."
                 */
                if ((altlen == strnlen_s(altptr, EST_MAX_SERVERNAME_LEN)) &&
                    /* if this isn't true, there was an embedded zero in the name
                       string and we cannot match it. */
                    est_client_cert_hostcheck(altptr, hostname)) {
                    matched = 1;
                } else{
                    matched = 0;
                }
                break;

            case GEN_IPADD: /* IP address comparison */
                /* compare alternative IP address if the data chunk is the same size
                   our server IP address is */

                /*
                 * For PSB compliance, use SafeC library memcmp_s
                 */ 
		
                 if (addr_is_v4) {
                    safec_rc = memcmp_s(altptr, altlen, &addr_v4, altlen, &diff);
                    if (safec_rc != EOK) {
                    	EST_LOG_INFO("memcmp_s error 0x%xO with IPv4 address\n", safec_rc);
                    }  
                 } else if (addr_is_v6) {
                    safec_rc = memcmp_s(altptr, altlen, &addr_v6, altlen, &diff);
                    if (safec_rc != EOK) {
                    	EST_LOG_INFO("memcmp_s error 0x%xO with IPv6 address\n", safec_rc);
                    }  
                 } else {
                   /*
                    * Should never get here...so force matched to be 0
                    */
	           diff = -1; 
	 	 }

                if ((addr_is_v4) && (altlen == addrlen) && !diff) {
                    matched = 1;
                } else if ((addr_is_v6) && (altlen == addrlen) && !diff) {
                    matched = 1;
                } else{
                    matched = 0;
                }
                break;
            }
        }
        GENERAL_NAMES_free(altnames);
    }

    if (matched == 1) {
        /* an alternative name matched the server hostname */
        EST_LOG_INFO("subjectAltName: %s matched\n", hostname);
    } else if (matched == 0) {
        /* an alternative name field existed, but didn't match and then
           we MUST fail */
        EST_LOG_INFO("subjectAltName does not match %s\n", hostname);
        res = EST_ERR_FQDN_MISMATCH;
    }else  {
        /* we have to look to the last occurrence of a commonName in the
           distinguished one to get the most significant one. */
        i = -1;

	/* The following is done because of a bug in 0.9.6b */
        nulstr = (unsigned char*)"";
        peer_CN = nulstr;

        name = X509_get_subject_name(server_cert);
        if (name) {
            while ((j = X509_NAME_get_index_by_NID(name, NID_commonName, i)) >= 0) {
                i = j;
            }
        }

        /* we have the name entry and we will now convert this to a string
           that we can use for comparison. Doing this we support BMPstring,
           UTF8 etc. */

        if (i >= 0) {
            tmp = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name, i));

            /* In OpenSSL 0.9.7d and earlier, ASN1_STRING_to_UTF8 fails if the input
               is already UTF-8 encoded. We check for this case and copy the raw
               string manually to avoid the problem. This code can be made
               conditional in the future when OpenSSL has been fixed. Work-around
               brought by Alexis S. L. Carvalho. */
            if (tmp) {
                if (ASN1_STRING_type(tmp) == V_ASN1_UTF8STRING) {
                    j = ASN1_STRING_length(tmp);
                    if (j >= 0) {
                        peer_CN = malloc(j + 1);
                        if (peer_CN) {
			    safec_rc = memcpy_s(peer_CN, j, ASN1_STRING_data(tmp), j);
                            if (safec_rc != EOK) {
				EST_LOG_INFO("memcpy_s error 0x%xO with ASN1 string\n", safec_rc);
                            }
                            peer_CN[j] = '\0';
                        }
                    }
                }else  { /* not a UTF8 name */
                    j = ASN1_STRING_to_UTF8(&peer_CN, tmp);
                }
                if (peer_CN && (strnlen_s((char*)peer_CN, EST_MAX_SERVERNAME_LEN) != j)) {
                    /* there was a terminating zero before the end of string, this
                       cannot match and we return failure! */
                    EST_LOG_WARN("SSL: illegal cert name field");
                    res = EST_ERR_FQDN_MISMATCH;
                }
            }
        }

        if (peer_CN == nulstr) {
            peer_CN = NULL;
        } else{
            /* convert peer_CN from UTF8 */
#if 0
// UTF8 currently not supported in the first release of libest
            CURLcode rc = Curl_convert_from_utf8(data, peer_CN, strlen(peer_CN));
            /* Curl_convert_from_utf8 calls failf if unsuccessful */
            if (rc) {
                free(peer_CN);
                return EST_ERR_FQDN_MISMATCH;
            }
#endif
        }

        if (res != EST_ERR_NONE) {
            /* error already detected, pass through */
            ;
        } else if (!peer_CN) {
            EST_LOG_WARN("SSL: unable to obtain common name from peer certificate");
            res = EST_ERR_FQDN_MISMATCH;
        }else if (!est_client_cert_hostcheck((const char*)peer_CN, hostname)) {
            EST_LOG_WARN("SSL: FQDN hostname mismatch in server certificate, '%s' does not match "
                      "target host name '%s'", peer_CN, hostname);
            res = EST_ERR_FQDN_MISMATCH;
        }else  {
            EST_LOG_INFO("common name: %s (matched)", peer_CN);
        }
        if (peer_CN) {
            free(peer_CN);
        }
    }
    return res;
}
/*
 * This routine checks the FQDN in the server certificate
 * against the configure server name used to establish
 * the TCP connection with the EST server.
 * This is required per section 3.6 in the EST spec.
 * Note, we only do the FQDN check as defined in RFC 6125.
 * We do not look for the id-kp-cmcRA extended key usage
 * extension in the server cert.  While this is more 
 * restrictive by not allowing FQDN mismatches when the
 * id-kp-cmcRA is present, we currently have no way to
 * determine when we're using the explicit trust anchor to
 * allow this additional flexibility.
 */
static EST_ERROR est_client_check_fqdn (EST_CTX *ctx, SSL *ssl)
{
    X509 *cert;
    EST_ERROR er;

    cert = SSL_get_peer_certificate(ssl);

    if (cert) {
	er = est_client_verifyhost(ctx->est_server, cert);
	X509_free(cert);
	return (er);
    } else if (!cert && ctx->enable_srp) {
	EST_LOG_INFO("No peer certificate, skipping FQDN check since SRP is enabled.");
	return EST_ERR_NONE;
    } else {
	EST_LOG_WARN("Unable to perform FQDN check, no peer certificate.");
	return EST_ERR_FQDN_MISMATCH;
    }
}
/*
 * This function will open a TCP socket and establish a TLS session
 * with the EST server.  This should be called after est_client_init().
 *
 * Parameters:
 *	ctx:	    Pointer to EST context for client session
 *      ssl:        pointer to an SSL context structure to return the
 *                  SSL context created,
 * Reurns:
 *	EST_ERR_NONE if success
 */
EST_ERROR est_client_connect (EST_CTX *ctx, SSL **ssl)
{
    BIO             *tcp;
    SSL_CTX         *s_ctx;
    EST_ERROR       rv = EST_ERR_NONE;
#ifndef WIN32
    int             sock;
#else
    SOCKET          sock = INVALID_SOCKET;
#endif
    int             rc; 
    int             oval = 1;
    int             ssl_connect_ret = -1;
    tcw_err_t       tcw_err;
    tcw_opts_t      tcw_opts = { 0 };
    
    if (!ctx) {
        return EST_ERR_NO_CTX;
    }

    s_ctx = ctx->ssl_ctx;

    /*
     * Establish the connection through a proxy (if applicable)
     */
    if (ctx->use_proxy) {

        tcw_opts.proxy_proto = ctx->proxy_proto;
        
        tcw_opts.proxy_host = ctx->proxy_server;
        tcw_opts.proxy_port = ctx->proxy_port;
        
        if (ctx->proxy_username[0] && ctx->proxy_password[0] &&
                ctx->proxy_auth != EST_CLIENT_PROXY_AUTH_NONE) {
            tcw_opts.proxy_username = ctx->proxy_username;
            tcw_opts.proxy_password = ctx->proxy_password;
            
            tcw_opts.proxy_auth = 0;  /* initialize */
            if (ctx->proxy_auth & EST_CLIENT_PROXY_AUTH_BASIC) {
                tcw_opts.proxy_auth |= EST_CLIENT_PROXY_AUTH_BASIC;
            }
            if (ctx->proxy_auth & EST_CLIENT_PROXY_AUTH_NTLM) {
                tcw_opts.proxy_auth |= EST_CLIENT_PROXY_AUTH_NTLM;
            }
            
        }
    } else {
        tcw_opts.proxy_proto = EST_CLIENT_PROXY_NONE;
    }

    tcw_err = tcw_connect(&ctx->tcw_sock, &tcw_opts,
                          ctx->est_server, ctx->est_port_num, &sock);
    if (tcw_err == TCW_ERR_RESOLV) {
        EST_LOG_ERR("Unable to lookup hostname %s.", ctx->est_server);
        return (EST_ERR_IP_GETADDR);
    }
    if (tcw_err != TCW_OK) {
        EST_LOG_ERR("Unable to connect to EST server at %s", ctx->est_server);
        return (EST_ERR_IP_CONNECT);
    }

    /*
     * Enable TCP keep-alive
     */
    rc = setsockopt(sock, SOL_SOCKET,SO_KEEPALIVE, (char *)&oval, sizeof(oval));
    if (rc < 0) {
        tcw_close(&ctx->tcw_sock);
        sock = SOCK_INVALID;
        EST_LOG_ERR("Unable to connect to EST server at address %s", ctx->est_server);
        return (EST_ERR_IP_CONNECT);
    }
    /*
     * Pass the socket to the BIO interface, which OpenSSL uses
     * to create the TLS session.
     */
    tcp = BIO_new_socket(sock, BIO_NOCLOSE);
    if (tcp == NULL) {
        EST_LOG_ERR("Error creating IP socket");
        tcw_close(&ctx->tcw_sock);
        sock = SOCK_INVALID;        
        ossl_dump_ssl_errors();
        return (EST_ERR_IP_CONNECT);
    }        
    
    if (!(*ssl = SSL_new(s_ctx))) {
        EST_LOG_ERR("Error creating TLS context");
        ossl_dump_ssl_errors();
        BIO_free_all(tcp);    
        tcw_close(&ctx->tcw_sock);
        sock = SOCK_INVALID;
        return (EST_ERR_SSL_NEW);
    }

    /*
     * Need to set the EST ctx into the exdata of the SSL session context so
     * that it can be retrieved on a per session basis.
     */
    SSL_set_ex_data(*ssl, e_ctx_ssl_exdata_index, ctx);

    /*
     * Set the EST server name in the SSL context so that it'll be sent in the
     * in the server name extension in the client hello.
     */
    SSL_set_tlsext_host_name(*ssl, ctx->est_server);

    SSL_set_bio(*ssl, tcp, tcp);
    if (ctx->sess) {
	SSL_set_session(*ssl, ctx->sess);
    }
    if ((ssl_connect_ret = SSL_connect(*ssl)) <= 0) {
        EST_LOG_ERR("Error connecting TLS context. %d", SSL_get_error(*ssl, ssl_connect_ret));
        ossl_dump_ssl_errors();
        tcw_close(&ctx->tcw_sock);
        sock = SOCK_INVALID;
        rv = EST_ERR_SSL_CONNECT;
    } else {
        ctx->tcw_sock_connected = 1;
    }

    /*
     * Now that we've established a TLS session with the EST server,
     * we need to verify that the FQDN in the server cert matches
     * the server name we used to establish the connection.
     * This is from section 3.6 in the EST spec.
     */
    if ((EST_ERR_NONE == rv) && est_client_check_fqdn(ctx, *ssl)) {
	/*
	 * The host name did not match, shut down the tunnel and bail
	 */
	est_client_disconnect(ctx, ssl);
        EST_LOG_WARN("EST server name did not match FQDN in server certificate.");
        rv = EST_ERR_FQDN_MISMATCH;
    }

    return rv;
}
/*
 * This function will close the TLS session and the underlying socket.
 *
 * Parameters:
 *	ssl:	    Pointer to SSL context that has been set up for this connection
 *                  to the EST server.
 */
void est_client_disconnect (EST_CTX *ctx, SSL **ssl)
{
    SSL_SESSION *new_sess;
    
    if (!*ssl) {
        return;
    }

    /*
     * if first disconnect, get the session id to cache it away to use for
     * session resumption.
     */
    if (!ctx->sess) {
	ctx->sess = SSL_get1_session(*ssl);
    } else {
        /*
         * if not the first time to disconnect, see if the session id changed.
         * If it did, officially re-obtain it with a get1 call and cache it away
         */
        new_sess = SSL_get0_session(*ssl);
        if (new_sess != ctx->sess) {
            ctx->sess = SSL_get1_session(*ssl);
        }
    }
    
    SSL_shutdown(*ssl);
    SSL_free(*ssl);
    *ssl = NULL;

    if (ctx->tcw_sock_connected) {
        tcw_close(&ctx->tcw_sock);
        ctx->tcw_sock_connected = 0;
    }
}
/*
 * This function does the work for the CACerts request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 *      ca_certs_len: pointer to the unsigned int that will hold the length of the
 *                    returned CA certs.
 */
static int est_client_send_cacerts_request (EST_CTX *ctx, SSL *ssl,
                                            int *ca_certs_len)
{
    char *http_data;
    int  hdr_len;
    int  write_size;
    int  rv;
    unsigned char *ca_certs_buf = NULL;
    int  ca_certs_buf_len = 0;

    /*
     * Build the HTTP request
     * - allocate buffer: header, no data, terminating characters
     * - build the header
     * - no data
     * - terminate it
     */
    http_data = malloc(EST_HTTP_REQ_TOTAL_LEN);
    if (http_data == NULL) {
        EST_LOG_ERR("Unable to allocate memory for http_data");
        return EST_ERR_MALLOC;
    }
    
    hdr_len = est_client_build_cacerts_header(ctx, http_data);
    /*
     * terminate the HTTP header
     */
    snprintf(http_data + hdr_len, EST_HTTP_REQ_TOTAL_LEN-hdr_len,"\r\n");
    hdr_len += 2;

    /*
     * no data is being sent so go ahead and terminate the HTTP request
     */
    snprintf(http_data + hdr_len,EST_HTTP_REQ_TOTAL_LEN-hdr_len, "\r\n");
    hdr_len += 2;
    
    /*
     * Send the request to the server and wait for a response
     */
    ctx->last_http_status = 0;
    write_size = SSL_write(ssl, http_data, hdr_len);
    if (write_size < 0) {
        EST_LOG_ERR("TLS write error");
	ossl_dump_ssl_errors();
        rv = EST_ERR_SSL_WRITE;
    } else {
        EST_LOG_INFO("TLS wrote %d bytes, attempted %d bytes\n",
                     write_size, hdr_len);

        /*
         * Try to get the response from the server
         */
        rv = est_io_get_response(ctx, ssl, EST_OP_CACERTS,
                                 &ca_certs_buf, &ca_certs_buf_len);

        switch (rv) {
        case EST_ERR_NONE:
            
            /*
             * Make sure that even though we got a success return code, that we
             * actually received something
             */
            if (ca_certs_buf_len == 0) {
                EST_LOG_ERR("Retrieved CA Cert buf is zero bytes in length");
                rv = EST_ERR_ZERO_LENGTH_BUF;
                break;
            }
            if (ca_certs_buf_len+1 > EST_CA_MAX) {
                EST_LOG_ERR("Retrieved CA Cert buf is larger than maximum allowed");
                rv = EST_ERR_BUF_EXCEEDS_MAX_LEN;
                break;
            }
            
            /*
             * Resize the buffer holding the retrieved CA cert and link it
             * into the ctx.  Get rid of the http hdr and any extra space on
             * the back.
             */
            if (ctx->retrieved_ca_certs != NULL){
                free(ctx->retrieved_ca_certs);
            }
            ctx->retrieved_ca_certs = malloc(ca_certs_buf_len+1);
            if (ctx->retrieved_ca_certs == NULL) {
                
                EST_LOG_ERR("Unable to allocate CA certs buffer");
                rv = EST_ERR_MALLOC;
                break;
            }
            
            ctx->retrieved_ca_certs[ca_certs_buf_len] = '\0';
            memcpy_s(ctx->retrieved_ca_certs, ca_certs_buf_len+1, ca_certs_buf,
                   ca_certs_buf_len);
            ctx->retrieved_ca_certs_len = ca_certs_buf_len;

            /*
             * Verify the returned CA cert chain
             */
            rv = verify_cacert_resp(ctx, ctx->retrieved_ca_certs,
                                    &ctx->retrieved_ca_certs_len);
            if (rv != EST_ERR_NONE) {
                EST_LOG_ERR("Returned CACerts chain was invalid");

                free(ctx->retrieved_ca_certs);
                ctx->retrieved_ca_certs = NULL;
                ctx->retrieved_ca_certs_len = 0;
                *ca_certs_len = ctx->retrieved_ca_certs_len;
                break;
            }
            
            /*
             * pass back the length of the retrieved CA cert buffer
             */
            *ca_certs_len = ctx->retrieved_ca_certs_len;
            
            EST_LOG_INFO("CACerts buf: %s", ctx->retrieved_ca_certs);
            EST_LOG_INFO("CACerts length: %d", ctx->retrieved_ca_certs_len);
            break;
        case EST_ERR_AUTH_FAIL:
            EST_LOG_ERR("HTTP auth failure");
            break;
        case EST_ERR_CA_ENROLL_RETRY:
            EST_LOG_INFO("HTTP request failed with a RETRY AFTER resp");
            break;
        default:
            EST_LOG_ERR("EST request failed: %d (%s)", rv, EST_ERR_NUM_TO_STR(rv));
            break;
        }
    }
    
    if (http_data) {
        free(http_data);
    }
    if (ca_certs_buf) {
        free(ca_certs_buf);
    }
    
    return (rv);
}
/*
 * This function does the work for the CACerts request flow.
 *
 * Parameters:
 *	ctx:	    EST context
 *	ssl:	    SSL context
 *      ca_certs_len: pointer to the unsigned int that will hold the length of the
 *                    returned CA certs.
 */
EST_ERROR est_client_set_uid_pw (EST_CTX *ctx, const char *uid, const char *pwd) 
{
    /*
     * If there's a userid, there must be a password, and vice versa.
     * The userid can still be an empty string ( "" ), but it cannot
     * be NULL if there's a password. (3.2.3).
     */
    if (uid != NULL && pwd == NULL) {
        EST_LOG_ERR("User ID provided with no password");
        return EST_ERR_INVALID_PARAMETERS;
    }        
    if (uid == NULL && pwd != NULL) {
        EST_LOG_ERR("Password provided with no user ID");
        return EST_ERR_INVALID_PARAMETERS;
    }

    /*
     * if uid/pwd set, then we're doing basic/digest authentication
     */
    if (uid != NULL) {
        if (EOK != strncpy_s(ctx->userid, MAX_UIDPWD, uid, MAX_UIDPWD)) {
            EST_LOG_ERR("Invalid User ID provided");
            return EST_ERR_INVALID_PARAMETERS;   
        }
        if (EOK != strncpy_s(ctx->password, MAX_UIDPWD, pwd, MAX_UIDPWD)) {
            EST_LOG_ERR("Invalid Password provided");
            return EST_ERR_INVALID_PARAMETERS;
        }
    }

    return (EST_ERR_NONE);
}
/*! @brief est_client_enroll_csr() performs the simple enroll request with the EST
     server using a PKCS10 CSR provided by the application layer.
 
    @param ctx Pointer to an EST context
    @param csr Pointer to the PKCS10 CSR data, which is defined as an OpenSSL
    X509_REQ.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    buffer.
    @param priv_key Pointer to the private key that will be used to sign the CSR,
    or NULL
 
    @return EST_ERROR

    est_client_enroll_csr() connects to the EST server, establishes a SSL/TLS
    connection to the EST server that was configured with the previous call to
    est_client_set_server(), and sends the simple enroll request.  The application
    layer must provide the PKCS10 CSR that will be enrolled.
    If the priv_key argument given is not NULL, then the CSR should not
    need to be signed by the private key. However, the CSR must contain everything 
    else that is required, including the public key. If the private key is provided
    with an already signed CSR, then the EST library will re-sign the CSR. 
    
    The enroll response is stored in the EST context and the length 
    is passed back to the application through the pkcs7_len paramter of this 
    function.  The application can then allocate a correctly sized buffer and 
    call est_client_copy_enrolled_cert() to retrieve the new client certificate 
    from the context.

    Unless the CSR is not already signed, which is indicated by a NULL priv_key,
    the application must provide a pointer to the private key used to sign the CSR.
    This is required by the EST library in the event that the EST server has
    requested the proof-of-possession value be included in the CSR.  The EST library
    will automatically include the proof-of-posession value and sign the CSR
    again.

    Be aware that the X509_REQ data passed to this function must be valid.  Passing
    corrupted CSR data may result in a system crash.  libEST utilizes the OpenSSL
    ASN decoding logic to read the X509_REQ data.  OpenSSL does not perform
    safety checks on the X509_REQ data when parsing.  If your application is
    reading externally generated PEM or DER encoded CSR data, then please use
    the est_read_x509_request() helper function to convert the PEM/DER CSR into a
    valid X509_REQ pointer.
 */
EST_ERROR est_client_enroll_csr (EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EVP_PKEY *priv_key)
{
    EST_ERROR rv;
    SSL *ssl = NULL;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!csr) {
        return (EST_ERR_NO_CSR);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    /*
     * Establish TLS session with the EST server
     */
    rv = est_client_connect(ctx, &ssl);
    if (rv != EST_ERR_NONE) {
        goto err;
    }

    if (priv_key) {
      rv = est_client_enroll_pkcs10(ctx, ssl, csr, pkcs7_len, priv_key, 0);
    } else {
        rv = est_client_enroll_req(ctx, ssl, csr, pkcs7_len, 0);
    }
    est_client_disconnect(ctx, &ssl);
    if (rv == EST_ERR_AUTH_FAIL &&
        (ctx->auth_mode == AUTH_DIGEST ||
         ctx->auth_mode == AUTH_BASIC  ||
         ctx->auth_mode == AUTH_TOKEN)) {

        /*
         * HTTPS digest mode requires the use of MD5.  Make sure we're not
         * in FIPS mode and can use MD5
         */
        if (ctx->auth_mode == AUTH_DIGEST && (FIPS_mode())){
	    EST_LOG_ERR("HTTP digest auth not allowed while in FIPS mode");
	    rv = EST_ERR_BAD_MODE;
            goto err;
        }
        
        /* Try one more time if we're doing Digest auth */
        EST_LOG_INFO("HTTP Auth failed, trying again with digest/basic parameters");
        rv = est_client_connect(ctx, &ssl);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Connection failed on second attempt with basic/digest parameters");
            goto err;
        }
	if (priv_key) {
	  rv = est_client_enroll_pkcs10(ctx, ssl, csr, pkcs7_len, priv_key, 0);
	} else {
	  rv = est_client_enroll_req(ctx, ssl, csr, pkcs7_len, 0);
	}
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Enroll failed on second attempt during basic/digest authentication");
        }
        est_client_disconnect(ctx, &ssl);
    }

err:    
    if (ssl) {
        SSL_shutdown(ssl);
        SSL_free(ssl);
    }

    return (rv);

}
/*! @brief est_client_enroll() performs the simple enroll request with the EST
     server
 
    @param ctx Pointer to an EST context
    @param cn Pointer to the Common Name value to be used in the enrollment
    request.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    buffer.
    @param new_public_key Pointer an EVP_PKEY structure that holds the
    client's key pair to be used in the simple enroll request .  The public
    key is included in the Certificate Signing Request (CSR) sent to the CA
    Server, and the private key is used to sign the request.
 
    @return EST_ERROR

    est_client_enroll() connects to the EST server, builds a simple enroll
    request using the Common Name passed in cn, establishes a SSL/TLS
    connection to the EST server that was configured with the previous call to
    est_client_set_server(), and sends the simple enroll request.  The
    response is stored in the EST context and the length is passed back to the
    application through the pkcs7_len parameter of this function.  The
    application can then allocate a correctly sized buffer and call
    est_client_copy_enrolled_cert() to retrieve the new client certificate
    from the context.
 */
EST_ERROR est_client_enroll (EST_CTX *ctx, char *cn, int *pkcs7_len,
                             EVP_PKEY *new_public_key)
{
    EST_ERROR rv;
    SSL *ssl = NULL;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!new_public_key) {
        return (EST_ERR_NO_KEY);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    rv = est_client_connect(ctx, &ssl);
    if (rv != EST_ERR_NONE) {
        goto err;
    }
    rv = est_client_enroll_cn(ctx, ssl, cn, pkcs7_len, new_public_key);
    est_client_disconnect(ctx, &ssl);
    if (rv == EST_ERR_AUTH_FAIL &&
        (ctx->auth_mode == AUTH_DIGEST ||
         ctx->auth_mode == AUTH_BASIC  ||
         ctx->auth_mode == AUTH_TOKEN)) {

        /*
         * HTTPS digest mode requires the use of MD5.  Make sure we're not
         * in FIPS mode and can use MD5
         */
        if (ctx->auth_mode == AUTH_DIGEST && (FIPS_mode())){
	    EST_LOG_ERR("HTTP digest auth not allowed while in FIPS mode");
	    rv = EST_ERR_BAD_MODE;
            goto err;
        }
        
        /* Try one more time if we're doing Digest auth */
        EST_LOG_INFO("HTTP Auth failed, trying again with basic/digest/token parameters");
        rv = est_client_connect(ctx, &ssl);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Connection failed on second attempt with basic/digest/token parameters");
            goto err;
        }
        rv = est_client_enroll_cn(ctx, ssl, cn, pkcs7_len, new_public_key);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Enroll failed on second attempt during basic/digest authentication");

            /*
             * If we're attempting token mode for the second time, and
             * the server responded with error attributes, log them now
             */
            if (ctx->token_error[0] != '\0' || ctx->token_error_desc[0] != '\0') {
                EST_LOG_ERR("Token Auth mode failed, server provided error information: \n"
                            "   Error = %s\n Error description: %s",
                            ctx->token_error, ctx->token_error_desc);
                ctx->token_error[0] = '\0';
                ctx->token_error_desc[0] = '\0';
            }            
        }
        
        est_client_disconnect(ctx, &ssl);
    }

    ctx->auth_mode = AUTH_NONE;

  err:    
    if (ssl) {
        SSL_shutdown(ssl);
        SSL_free(ssl);
    }

    return (rv);
}
/*! @brief est_client_provision_cert() performs the full sequence of
    EST operations to enroll a new certificate using a trusted message flow.
 
    @param ctx Pointer to an EST context
    @param cn Pointer to the Common Name value to be used in the enrollment
    request.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    certificate returned from the RA or CA.
    @param ca_cert_len Pointer to an integer to hold the length of the buffer 
    that will hold the new trusted CA certificates.
    @param new_public_key Pointer an EVP_PKEY structure that holds the
    client's key pair to be used in the simple enroll request .  The public
    key is included in the Certificate Signing Request (CSR) sent to the CA
    Server, and the private key is used to sign the request.
 
    @return EST_ERROR

    est_client_provision_cert() connects to the EST server, retrieves the
    latest trusted CA certifictes from the server, retrieves the CSR attributes
    from the server, and sends the simple enroll request to the server to
    provision a new certificate from the RA or CA.  This is a convenience 
    function that is equivalent to invoking the following three functions
    in order:

    est_client_get_cacerts()
    est_client_get_csrattrs()
    est_client_enroll() 

    This function takes a Common Name (CN) as the only entity identifier
    that will be used in the CSR.  If additional X509 attributes
    or extensions are required because the EST server is enforcing the
    presence of all the CSR attributes, then this function should not be used
    to provision a certificate.  The est_client_enroll_csr() function should
    be used when additional X509 attributes are to be included in the
    enroll request. 

    The provisioning response is stored in the EST context and the length is passed 
    back to the application through the pkcs7_len parameter of this function.  The
    application can then allocate a correctly sized buffer and call
    est_client_copy_enrolled_cert() to retrieve the new client certificate
    from the context.

    The provisioning response also includes the latest copy of the trusted
    CA certificates from the EST server.  These should be persisted locally
    by the application for future use.  The ca_cert_len argument will contain the 
    length of the certicates, which can then be retrieved by invoking 
    est_client_copy_cacerts().
 */
EST_ERROR est_client_provision_cert (EST_CTX *ctx, char *cn, 
	                             int *pkcs7_len,
				     int *ca_cert_len,
                                     EVP_PKEY *new_public_key)
{
    EST_ERROR rv;
    unsigned char *new_ta_p7;
    unsigned char *new_ta_pem;
    unsigned char *attr_data = NULL;
    int attr_len;
    int new_ta_len;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    /*
     * Make sure we have non-NULL pointers for the lengths
     */
    if (!pkcs7_len || !ca_cert_len) {
	return (EST_ERR_INVALID_PARAMETERS);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    if (!new_public_key) {
        return (EST_ERR_NO_KEY);
    }

    /*
     * First, get the latest trust anchor certs from the server.
     */
    rv = est_client_get_cacerts(ctx, ca_cert_len);
    if (rv != EST_ERR_NONE) {
	return rv;
    }
    new_ta_p7 = malloc(*ca_cert_len);
    if (new_ta_p7 == NULL) {
        EST_LOG_ERR("Unable to allocate CA certs buffer");
        rv = EST_ERR_MALLOC;
        return rv;
    }
    rv = est_client_copy_cacerts(ctx, new_ta_p7);
    if (rv != EST_ERR_NONE) {
	free(new_ta_p7);
	return (rv);
    }

    /*
     * The certs are base64 DER encoded.  We need to convert
     * them to PEM.
     */
    new_ta_len = est_convert_p7b64_to_pem (new_ta_p7, *ca_cert_len, &new_ta_pem);
    free(new_ta_p7);
    if (new_ta_len <= 0) {
	return (EST_ERR_PEM_READ);
    }

    /*
     * We now have the new trust anchor and it's PEM encoded.
     * Let's load it into the current EST context.  All
     * future EST operations will then be using this new
     * trust anchor.
     */
    if (ctx->trusted_certs_store != NULL) {
        X509_STORE_free(ctx->trusted_certs_store);
    }
    rv = est_load_trusted_certs(ctx, new_ta_pem, new_ta_len);
    free(new_ta_pem);
    if (rv != EST_ERR_NONE) {
        return rv;
    }
    
    /*
     * Since we've reset the trust store, mark the client
     * context as initialized.
     */
    ctx->est_client_initialized = 1;

    /*
     * Next we need to get the CSR attributes, which allows libEST
     * to know if the challengePassword needs to be included in the
     * CSR.
     */
    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);
    if (rv != EST_ERR_NONE) {
	EST_LOG_ERR("Unable to get CSR attributes while provisioning a new certificate");
	return (rv);
    }

    /*
     * Finally, we can attempt to enroll a new certificate using the
     * Common Name provided by the application.
     */
    rv = est_client_enroll(ctx, cn, pkcs7_len, new_public_key);

    return (rv);
}
/*! @brief est_client_reenroll() performs a re-enroll request with the EST
     server using an existing X509 certificate.
 
    @param ctx Pointer to an EST context
    @param cert Pointer to the X509 certificate, which is defined as an OpenSSL
    X509.
    @param pkcs7_len Pointer to an integer to hold the length of the PKCS7
    buffer.
    @param priv_key Pointer to the private key that will be used to sign the CSR.
 
    @return EST_ERROR

    est_client_reenroll() connects to the EST server, establishes a SSL/TLS
    connection to the EST server that was configured with the previous call to
    est_client_set_server(), and sends the re-enroll request.  The application
    layer must provide the X509 certificate that will be enrolled.  This certificate
    should have previously been enrolled with the CA.  The application also
    needs to provide the private key associated with the public key in the
    X509 certificate.  This private key is required to sign the CSR that is
    generated from the X509 certificate. 
    
    The enroll response is stored in the EST context and the length 
    is passed back to the application through the pkcs7_len paramter of this 
    function.  The application can then allocate a correctly sized buffer and 
    call est_client_copy_enrolled_cert() to retrieve the new client certificate 
    from the context.

    The application must provide a pointer to the private key used to sign the CSR.
    This is required by the EST library in the event that the EST server has
    requested the proof-of-possession value be included in the CSR.  The EST library
    will automatically include the proof-of-posession value and sign the CSR
    again.

    Be aware that only the public key and subject name from the X509 certificate
    are included in the re-enroll request sent to the EST server.  The CA is
    responsible for re-applying any X509 extensions that are to be issued with
    the renewed certificate.
 */
EST_ERROR est_client_reenroll (EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKEY *priv_key)
{
    X509_REQ *req;
    EST_ERROR rv;
    SSL *ssl = NULL;
    int ossl_rv;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!cert) {
        return (EST_ERR_NO_CERT);
    }

    if (!priv_key) {
        return (EST_ERR_NO_KEY);
    }

    if (!ctx->est_client_initialized) {
        return (EST_ERR_CLIENT_NOT_INITIALIZED);
    }

    /*
     * Check the X509 given to us
     */
    rv = est_client_check_x509(cert);
    if (rv != EST_ERR_NONE) {
	return (rv);
    }

    /*
     * Check that the private key matches the public key
     * in the cert.
     */
    if (X509_check_private_key(cert, priv_key) <= 0) {
        return (EST_ERR_CLIENT_INVALID_KEY);
    }

    /*
     * Convert the existing certificate to a CSR
     * This will copy the subject name from the cert into
     * a new CSR.  We pass in NULL for the private key parameter
     * below because we will sign this CSR ourselves later.
     */
    req = X509_to_X509_REQ(cert, NULL, ctx->signing_digest);
    if (!req) {
	EST_LOG_ERR("X509 to CSR conversion failed.");
        ossl_dump_ssl_errors();
        return (EST_ERR_NO_CSR);
    }

    /*
     * Copy the X509 extensions from the old certificate
     * to the CSR.  The CA may or may not retain these, as
     * this behavior depends on policy.  When using the 
     * OpenSSL test CA, set the copy_extensions setting 
     * in the config file to copyall to retain the
     * extensions in the CSR when issuing a new cert.
     */
    if (cert->cert_info && cert->cert_info->extensions) {
	ossl_rv = X509_REQ_add_extensions(req, cert->cert_info->extensions);
	if (!ossl_rv) {
	    EST_LOG_WARN("Failed to copy X509 extensions to the CSR. Your new certificate may not contain the extensions present in the old certificate.");
	}
    }

    /*
     * Establish TLS session with the EST server
     */
    rv = est_client_connect(ctx, &ssl);
    if (rv != EST_ERR_NONE) {
        goto err;
    }

    /*
     * Send the re-enroll request
     */
    rv = est_client_enroll_pkcs10(ctx, ssl, req, pkcs7_len, priv_key, 1);
    est_client_disconnect(ctx, &ssl);
    if (rv == EST_ERR_AUTH_FAIL &&
        (ctx->auth_mode == AUTH_DIGEST ||
         ctx->auth_mode == AUTH_BASIC  ||
         ctx->auth_mode == AUTH_TOKEN)) {

        /*
         * HTTPS digest mode requires the use of MD5.  Make sure we're not
         * in FIPS mode and can use MD5
         */
        if (ctx->auth_mode == AUTH_DIGEST && (FIPS_mode())){
	    EST_LOG_ERR("HTTP digest auth not allowed while in FIPS mode");
	    rv = EST_ERR_BAD_MODE;
            goto err;
        }
        
        /* Try one more time if we're doing Digest auth */
        EST_LOG_INFO("HTTP Auth failed, trying again with digest/basic parameters");
        rv = est_client_connect(ctx, &ssl);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Connection failed on second attempt with basic/digest parameters");
            goto err;
        }
        rv = est_client_enroll_pkcs10(ctx, ssl, req, pkcs7_len, priv_key, 1);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Reenroll failed on second attempt during basic/digest authentication");
            
            /*
             * If we're attempting token mode for the second time, and
             * the server responded with error attributes, log them now
             */
            if (ctx->token_error[0] != '\0' || ctx->token_error_desc[0] != '\0') {
                EST_LOG_ERR("Token Auth mode failed, server provided error information: \n"
                            "   Error = %s\n Error description: %s",
                            ctx->token_error, ctx->token_error_desc);
                ctx->token_error[0] = '\0';
                ctx->token_error_desc[0] = '\0';
            }            
            
        }
        est_client_disconnect(ctx, &ssl);
    }

err:    
    if (ssl) {
        SSL_shutdown(ssl);
        SSL_free(ssl);
    }
    X509_REQ_free(req);

    return (rv);

    
}
/*! @brief est_client_copy_enrolled_cert() passes back the client certificate
    that was previously obtained from the EST server by the call to
    est_client_enroll().
 
    @param ctx Pointer to an EST context
    @param cn Pointer to the Common Name value to be used in the enrollment
    request.
    @param pkcs7 Pointer to a pointer that will point to the buffer that
    contains the newly enrolled client certificate.
 
    @return EST_ERROR

    est_client_copy_enrolled_cert() copies the previously obtained client
    certificate from the EST context to the application's buffer.  Once this
    client certificate is copied out of the context it is removed from the
    context.
 */
EST_ERROR est_client_copy_enrolled_cert (EST_CTX *ctx, unsigned char *pkcs7)
{

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    if (pkcs7 == NULL){
        EST_LOG_ERR("EST Client: Simple Enroll, invalid parameter");
        return EST_ERR_INVALID_PARAMETERS;
    }
         
    if (ctx->enrolled_client_cert == NULL){
        EST_LOG_ERR("No client certificate to copy");
        return(EST_ERR_NO_CERTIFICATE);
    }

    memzero_s(pkcs7, ctx->enrolled_client_cert_len);
    memcpy_s(pkcs7, ctx->enrolled_client_cert_len, ctx->enrolled_client_cert,
             ctx->enrolled_client_cert_len);
    
    /*
     * Now that the copy in the context has been handed over,
     * free it up
     */
    free(ctx->enrolled_client_cert);
    ctx->enrolled_client_cert = NULL;
    ctx->enrolled_client_cert_len = 0;

    return (EST_ERR_NONE);
}
/*! @brief est_client_get_cacerts() performs a CAcerts GET request to the EST server
 
    @param ctx Pointer to an EST context
    @param ca_certs_len Pointer to an integer to hold the length of the CA certs
    buffer
 
    @return EST_ERROR

    est_client_get_cacerts() connects to the EST server, builds a CA certs
    request, and sends the GET CA certs request.  The response is placed in a
    buffer allocated and maintained by the EST client library and a pointer to
    this buffer is returned to the calling application.  The returned CA certs
    are in base64 encoded DER format and is stored in a NULL terminated string
    buffer.

    Once the CA certificates are retrieved from the EST server, the ET Client
    library must be reset.  The retrieved CA certificates should now be passed
    into the EST client initialization function as the explicit TA database.
 */
EST_ERROR est_client_get_cacerts (EST_CTX *ctx, int *ca_certs_len)
{
    EST_ERROR rv = EST_ERR_NONE;
    SSL *ssl = NULL;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    if (ca_certs_len == NULL) {
        EST_LOG_ERR("EST Client: Get CACerts, invalid parameter");
        return EST_ERR_INVALID_PARAMETERS;
    }
    
    rv = est_client_connect(ctx, &ssl);
    if (rv != EST_ERR_NONE) {
        if (ssl) {
            SSL_shutdown(ssl);
            SSL_free(ssl);
        }        
        return (rv);
    }
    rv = est_client_send_cacerts_request(ctx, ssl, ca_certs_len);
    est_client_disconnect(ctx, &ssl);

    if (ssl) {
        SSL_shutdown(ssl);    
        SSL_free(ssl);
    }
    
    return (rv);
}
/*! @brief est_client_copy_cacerts() copies the previously retrieved CA
    certificates to the application's buffer.
 
    @param ctx Pointer to the current EST context.
    @param ca_certs Pointer to the buffer into which the retrieved CA certificates
    are to be copied. 
 
    @return EST_ERROR

    est_client_copy_cacerts() copies the most recently retrieved CA
    certificates from the EST server.  Once these CA certificates are copied
    to the application's buffer pointed to by ca_certs they are removed from
    the EST clietn context.

    Once the CA certificates are retrieved by the application, the EST client
    library must be reset.  When this reset is performed, the CA certificates
    retrieved in this est_client_copy_cacerts call should be passed into the
    EST client initialization function as the explicit TA database.
 */
EST_ERROR est_client_copy_cacerts (EST_CTX *ctx, unsigned char *ca_certs)
{

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    if (ca_certs == NULL) {
        EST_LOG_ERR("EST Client: Get CACerts, invalid parameter");
        return EST_ERR_INVALID_PARAMETERS;
    }
    
    if (ctx->retrieved_ca_certs == NULL) {
        EST_LOG_ERR("No CA certificates to copy");
        return(EST_ERR_NO_CERTIFICATE);
    }

    memzero_s(ca_certs, ctx->retrieved_ca_certs_len);
    memcpy_s(ca_certs, ctx->retrieved_ca_certs_len, ctx->retrieved_ca_certs,
             ctx->retrieved_ca_certs_len);

    /*
     * if the CA certs were obtained, then the client lib needs to be reset.
     */
    ctx->est_client_initialized = 0;
    
    return (EST_ERR_NONE);
}
/*! @brief est_client_get_csrattrs() performs the CSR attributes request to
    the EST server.
 
    @param ctx Pointer to EST context for a client session
    @param csr_data Pointer to a buffer that is to hold the returned CSR
    attributes
    @param csr_len Pointer to an integer that is to hold the length of the CSR
    attributes buffer
 
    @return EST_ERROR

    est_client_get_csrattrs() connects to the EST server, sends the CSR attributes
    request to the server, saves aways the returned CSR attribute data, and then
    disconnects from the EST server.
 */
EST_ERROR est_client_get_csrattrs (EST_CTX *ctx, unsigned char **csr_data, int *csr_len)
{
    int rv, new_csr_len, pop_required = 0;
    SSL *ssl = NULL;
    unsigned char *new_csr_data;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!csr_data) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    if (!csr_len) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /* assume defeat */
    *csr_data = NULL;
    *csr_len = 0;
    
    /*
     * Connect to the EST server
     */
    rv = est_client_connect(ctx, &ssl);
    if (rv != EST_ERR_NONE) {
        if (ssl) {
            SSL_shutdown(ssl);
            SSL_free(ssl);
        }

        return (rv);
    }

    /*
     * free the current attributes if cached
     */
    if (ctx->retrieved_csrattrs) {
        free(ctx->retrieved_csrattrs);
	ctx->retrieved_csrattrs = NULL;
        ctx->retrieved_csrattrs_len = 0;
    }
    ctx->retrieved_csrattrs_len = 0;
    ctx->retrieved_csrattrs = NULL;

    /*
     * Send the HTTP request to the EST server
     */
    rv = est_client_send_csrattrs_request(ctx, ssl, &new_csr_data, &new_csr_len);
    est_client_disconnect(ctx, &ssl);

    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("CSR request failed, error code is %d (%s)", rv, EST_ERR_NUM_TO_STR(rv));
	if (new_csr_data) {
	    free(new_csr_data);
	}
	if (ssl) {
	    SSL_shutdown(ssl);
	    SSL_free(ssl);
	}
	return (rv);
    }

    if (ssl) {
        SSL_shutdown(ssl);
        SSL_free(ssl);
    }

    if (new_csr_data == NULL) {
        EST_LOG_INFO("CSR attributes are: NULL");
	return (EST_ERR_NONE);
    }
    /* 
     * have to allocate the new memory prior to 
     * parsing to be sure it is null terminated.
     */
    ctx->retrieved_csrattrs = malloc(new_csr_len + 1);
    if (!ctx->retrieved_csrattrs) {
        free(new_csr_data);
	return (EST_ERR_MALLOC);
    }

    ctx->retrieved_csrattrs_len = new_csr_len;
    memcpy_s(ctx->retrieved_csrattrs, new_csr_len+1, new_csr_data, new_csr_len);
    ctx->retrieved_csrattrs[new_csr_len] = 0;
    EST_LOG_INFO("CSR attributes are(%d): %s", ctx->retrieved_csrattrs_len, 
		 ctx->retrieved_csrattrs);
    free(new_csr_data);

    /* Now make sure the data is valid */
    rv = est_asn1_parse_attributes((char *)ctx->retrieved_csrattrs, ctx->retrieved_csrattrs_len,
				   &pop_required);
    if (rv != EST_ERR_NONE) {
	free(ctx->retrieved_csrattrs);
        ctx->retrieved_csrattrs = NULL;
        ctx->retrieved_csrattrs_len = 0;
    } else {
        *csr_data = ctx->retrieved_csrattrs;
        *csr_len = ctx->retrieved_csrattrs_len;
    }
    ctx->csr_pop_required = pop_required;
    
    return (rv);
}
/*! @brief est_client_enable_srp() is used by an application to enable
    TLS-SRP as the transport, which is used in place of traditional
    TLS.  TLS-SRP allows for secure transport when an X.509 certificate
    is not available or when a trust anchor is not available.
 
    @param ctx EST context obtained from the est_client_init() call.
    @param strength Specifies the SRP strength to use.
    @param uid char buffer containing the user id to be used as the
    SRP user name. 
    @param pwd char buffer containing the passowrd to be used as the
    SRP password.

    This function allows an application to enable TLS-SRP cipher suites,
    which is another form for TLS.  This could be used when the EST client
    does not have an X.509 certificate to identify itself to the EST
    server.  It can also be used by the EST client when a trust anchor
    is not available to authenticate the EST server identity.  
    The EST server must support TLS-SRP when using this API. 

    This function must be invoked after est_client_init() and prior to 
    issuing any EST commands..

    All string parameters are NULL terminated strings.
    
    @return EST_ERROR.  
*/
EST_ERROR est_client_enable_srp (EST_CTX *ctx, int strength, char *uid, char *pwd) 
{
    X509_STORE *store;
    int rv;

    if (ctx == NULL) {
	EST_LOG_ERR("Null context passed");
        return (EST_ERR_NO_CTX);
    }    

    if (ctx->ssl_ctx == NULL) {
	EST_LOG_ERR("SSL context has not been initialized");
        return (EST_ERR_NO_SSL_CTX);
    }
    
    if (strength < EST_SRP_STRENGTH_MIN) {
	EST_LOG_ERR("SRP strength must be greater than %d", EST_SRP_STRENGTH_MIN);
        return (EST_ERR_SRP_STRENGTH_LOW);
    }

    if (uid == NULL) {
	EST_LOG_ERR("SRP user ID must be provided");
	return (EST_ERR_INVALID_PARAMETERS);
    }

    if (pwd == NULL) {
	EST_LOG_ERR("SRP password must be provided");
	return (EST_ERR_INVALID_PARAMETERS);
    }

    ctx->enable_srp = 1;

    /*
     * Enable just the SRP cipher suites.  When SRP is enabled,
     * it's used exclusively.
     *
     * Check if we have a trust anchor configured.  We will
     * enable the DSS and RSA auth cipher suites if we do.
     */
    store = SSL_CTX_get_cert_store(ctx->ssl_ctx);
    if (store && store->objs && sk_X509_OBJECT_num(store->objs) > 0) {
	EST_LOG_INFO("Enable SSL SRP cipher suites with RSA/DSS\n");
        rv = SSL_CTX_set_cipher_list(ctx->ssl_ctx, EST_CIPHER_LIST_SRP_AUTH);
    } else {
	EST_LOG_INFO("Enable SSL SRP cipher suites w/o RSA/DSS\n");
        rv = SSL_CTX_set_cipher_list(ctx->ssl_ctx, EST_CIPHER_LIST_SRP_ONLY);
    }
    if (!rv) { 
	EST_LOG_ERR("Failed to set SSL SRP cipher suites\n");
	ossl_dump_ssl_errors();
	return EST_ERR_SSL_CIPHER_LIST;
    }
	
    /* 
     * Set the SRP user name and password.  
     */
    if (!SSL_CTX_set_srp_username(ctx->ssl_ctx, uid)) {
	EST_LOG_ERR("Unable to set SRP username\n");
	ossl_dump_ssl_errors();
	return EST_ERR_UNKNOWN; 
    }
    if (!SSL_CTX_set_srp_password(ctx->ssl_ctx, pwd)) {
	EST_LOG_ERR("Unable to set SRP password\n");
	ossl_dump_ssl_errors();
	return EST_ERR_UNKNOWN; 
    }
    SSL_CTX_set_srp_strength(ctx->ssl_ctx, strength);

    EST_LOG_INFO("TLS-SRP enabled");

    return (EST_ERR_NONE);
}
/*! @brief est_client_set_auth() is used by an application to set up the
    authentication parameters to be used.
 
    @param ctx EST context obtained from the est_client_init() call.
    @param uid char buffer containing the user id to be used for basic
    and digest based authentication
    @param pwd char buffer containing the passowrd to be used for basic
    and digest based authentication
    @param client_cert_raw char buffer containing the client application
    certificate.
    @param pkey_raw Private key that can be used with the client cert
    @param pkey_len Length of buffer holding the private key

    This function allows an application to provide the information required
    for authenticating the EST client with the EST server.  Until this call is
    made, the only accepted request is the GET CA Certs.  If the user id is
    provided, a password must also be provided.

    The application may pass the private key (pkey_raw/pkey_len) to be used
    for signing requests to the server, otherwise, only basic or digest based
    authentication will be performed on the TLS session for these requests.
    If the private key is passed, it must contain the private key that matches
    the public key contained in the client_cert parameter.

    All string parameters are NULL terminated strings.
    
    @return EST_ERROR.  If error, NULL.
*/
EST_ERROR est_client_set_auth (EST_CTX *ctx, const char *uid, const char *pwd,
                               X509 *client_cert, EVP_PKEY *private_key)
{
    EST_ERROR rv = EST_ERR_NONE;
    
    if (ctx == NULL) {
	EST_LOG_ERR("Null context passed");
        return (EST_ERR_NO_CTX);
    }    

    rv = est_client_set_uid_pw(ctx, uid, pwd);
    if (rv != EST_ERR_NONE) {
        return (rv);
    }            

    ctx->auth_mode = AUTH_NONE;

    /*
     * cache away the client cert and the associated private key, then
     * get them loaded into the SSL context so that they'll be used.
     */
    ctx->client_key = private_key;
    ctx->client_cert = client_cert;
    
    /*
     * Load the client cert if it's available
     */
    if (ctx->client_cert && ctx->client_key) {
        if (est_client_set_cert_and_key(ctx->ssl_ctx, ctx->client_cert, ctx->client_key)) {
            EST_LOG_ERR("Unable to load local certificate and private key");
            return EST_ERR_CLIENT_INVALID_KEY;
        }
    } else {
        EST_LOG_WARN("Not using client certificate for TLS session, HTTP basic or digest auth will be used.");
    }
    
    return EST_ERR_NONE;
}
/*! @brief est_client_set_auth_cred_cb() is used by an application to register
  its callback function.
    
  @param ctx EST context obtained from the est_client_init() call.
  @param auth_credentials_cb  Function pointer to the application layer callback

  The registered callback function is used by the EST client library to obtain
  authentication credentials.  The application can provide authentication
  credentials during initialization if they are available, such as the userid
  and password used with HTTP basic authentication.  During the processing of
  a request, the EST client library will call this application callback in the
  event that it does not have the authentication credentials that are being
  requested by the EST server.

  The callback function definition must match the following function
  prototype,

  int (*auth_credentials_cb)(EST_HTTP_AUTH_HDR *auth_credentials);

  auth_credentials - A pointer to a EST_HTTP_AUTH_HDR structure.  The
                     structure is provided by the EST library and the callback
                     function fills in the specific credentials being
                     requested.  These credential values must be passed in the
                     format in which they will be sent to the server, that is,
                     the EST client library will perform no reformatting of
                     these credentials.  Ownership of the memory holding these
                     credential values is transferred from the application
                     layer to the EST library when the application layer
                     returns these values to the EST library.  This allows the
                     EST library to free up this memory as soon as it is done
                     using these values.
                         
  The return value from the callback must be one of the following values:

  EST_HTTP_AUTH_CRED_SUCCESS - If the callback was able to provide the
                               requested credentials.
  EST_HTTP_AUTH_CRED_NOT_AVAILABLE - If the callback could not provide the
                                     requested credentials.

  The auth_credentials_cb parameter can be set to NULL to reset the callback
  function.
  
  All string parameters are NULL terminated strings.
    
  @return EST_ERROR.
  EST_ERR_NONE - Success.
  EST_ERR_NO_CTX
*/
EST_ERROR est_client_set_auth_cred_cb (EST_CTX *ctx, auth_credentials_cb callback)
{
    if (ctx == NULL) {
	EST_LOG_ERR("Null context passed");
        return (EST_ERR_NO_CTX);
    }
    
    ctx->auth_credentials_cb = callback;
    
    return EST_ERR_NONE;
}
/*! @brief est_client_enable_basic_auth_hint() is used by an application to 
    reduce overhead at the TCP and TLS layers when the client knows that
    the EST server is using HTTP Basic Authentication. 
 
    @param ctx Pointer to EST context for a client session

    Normally libEST will send an anonymous HTTP request when doing the
    initial request from the EST server.  This function allows an application 
    to improve performance by sending the HTTP Basic Auth header in the initial 
    request sent to the EST server.  This eliminates the need for the server to send
    the HTTP authentication challene response, which eliminates a round-trip
    between the EST client and server.  This function should be called immediately
    after invoking est_client_set_auth().

    Precautions should be taken by your application to ensure this hint is
    only enabled when it is known that the EST server is configured for HTTP
    Basic Authentication.  If the EST server is configured for HTTP Digest
    Authentication, then enabling this hint will cause the EST transaction
    to fail.
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
*/
EST_ERROR est_client_enable_basic_auth_hint (EST_CTX *ctx)
{
    if (ctx == NULL) {
	EST_LOG_ERR("Null context passed");
        return (EST_ERR_NO_CTX);
    }    

    ctx->auth_mode = AUTH_BASIC;
    return (EST_ERR_NONE);
}
/*! @brief est_client_init() is used by an application to create
    a context in the EST library.  This context is used when invoking
    other functions in the client API.
 
    @param ca_chain Required char buffer containing CA certificates as raw byte
    data, to be used for authenticating the EST server
    @param ca_chain_len length of ca_chain char buffer.
    @param cert_format defines the format of the certificates that will be
    passed down during this instantiation of the EST client library.  Currently,
    the only value accepted is EST_CERT_FORMAT_PEM
    @param cert_verify_cb A pointer to a function in the EST client application
    that is called when a received server identity certificate has failed
    verification from the SSL code.  This function takes as input two
    parameters, a pointer to the X509 structure containing the server's
    certificate, and a integer value set to the OpenSSL defined error
    for this certificate.  This callback function returns a 0 if the server's
    identity certificate has been rejected, and any other value if it
    has been approved.

    This function allows an application to initialize an EST client context.
    The application must provide the local CA certificates
    (ca_chain/ca_chain_len) to use for client operation.  The certificates
    provided must be in the format specified by the cert_format parameter.
    Currently, only PEM encoded certificates are supported.  The length
    parameters for the certificates (ca_chain_len) are to be used when DER
    formatted certificates are passed.  The CA certificates may contain CRL
    entries that will be used when authenticating the certificates received
    from the server.
 
    @return EST_CTX.  If error, NULL.
*/
EST_CTX *est_client_init (unsigned char *ca_chain, int ca_chain_len,
                          EST_CERT_FORMAT cert_format,
                          int (*cert_verify_cb)(X509 *, int))
{
    EST_CTX *ctx;
    volatile int len;
    int rv;
	
#ifdef WIN32
	int iResult;

	/*
	*Initialize Winsock
	*/
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		EST_LOG_ERR("WSAStartup Failed: %d\n", iResult);
		return 0;

	}
#endif	

    if (cert_format != EST_CERT_FORMAT_PEM) {
        EST_LOG_ERR("Only PEM encoding of certificates is supported.");
        return NULL;
    }
        
    /* 
     * If a CA chain was passed in, then check the length value passed in.  It
     * should match the calculated length of the buffer.  This will verify
     * both that the length value is correct, and that the buffer is properly
     * null terminated.
     */
    if (ca_chain) {    
        len = (int) strnlen_s((char *)ca_chain, EST_CA_MAX);
        if (len != ca_chain_len) {
            EST_LOG_ERR("Length of ca_chain doesn't match passed ca_chain_len");
            return NULL;
        }
    }
    
    ctx = malloc(sizeof(EST_CTX));
    if (!ctx) {
        EST_LOG_ERR("Unable to allocate memory for EST Context");
        return NULL;
    }
    memzero_s(ctx, sizeof(EST_CTX));
    ctx->est_mode = EST_CLIENT;

    /*
     * Load the local CA certificates into memory and retain
     * for future use.  This will be used for /CACerts requests.
     */
    if (est_load_trusted_certs(ctx, ca_chain, ca_chain_len)) {
        EST_LOG_ERR("Failed to load trusted certificate store");
        est_destroy(ctx);
        return NULL;
    }

    rv = est_client_init_ssl_ctx(ctx);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Failed to initialize SSL context with certificiate and private key passed");
        est_destroy(ctx);
        return NULL;
    }

    /*
     * save away the client's callback function that allows for manual verification of
     * the server's identity certificate
     */
    ctx->manual_cert_verify_cb = cert_verify_cb;
    
    /*
     * Set the default value for the  socket read timeout.
     */
    ctx->read_timeout = EST_SSL_READ_TIMEOUT_DEF;

    /*
     * We use SHA-256 as the default hash algorithm
     * for signing the CSR.  This can be changed by the
     * application by using the est_client_set_sign_digest() 
     * function.
     */
    ctx->signing_digest = EVP_sha256(); 

    ctx->retry_after_delay = 0;
    ctx->retry_after_date = 0;
    
    ctx->est_client_initialized = 1;
    return (ctx);
}
/*! @brief est_client_init() is used by an application to create
    a context in the EST library.  This context is used when invoking
    other functions in the client API.
 
    @param ca_chain Required char buffer containing CA certificates as raw byte
    data, to be used for authenticating the EST server
    @param ca_chain_len length of ca_chain char buffer.
    @param cert_format defines the format of the certificates that will be
    passed down during this instantiation of the EST client library.  Currently,
    the only value accepted is EST_CERT_FORMAT_PEM
    @param cert_verify_cb A pointer to a function in the EST client application
    that is called when a received server identity certificate has failed
    verification from the SSL code.  This function takes as input two
    parameters, a pointer to the X509 structure containing the server's
    certificate, and a integer value set to the OpenSSL defined error
    for this certificate.  This callback function returns a 0 if the server's
    identity certificate has been rejected, and any other value if it
    has been approved.

    This function allows an application to initialize an EST client context.
    The application must provide the local CA certificates
    (ca_chain/ca_chain_len) to use for client operation.  The certificates
    provided must be in the format specified by the cert_format parameter.
    Currently, only PEM encoded certificates are supported.  The length
    parameters for the certificates (ca_chain_len) are to be used when DER
    formatted certificates are passed.  The CA certificates may contain CRL
    entries that will be used when authenticating the certificates received
    from the server.
 
    @return EST_CTX.  If error, NULL.
*/
static EST_ERROR est_client_parse_path_seg (char *path_seg) 
{
    UriParserStateA state;
    UriUriA parsed_uri;
    int uriparse_rc;
    UriPathSegmentA *cur_seg = NULL;
    char *cur_seg_str = NULL;
    EST_OPERATION operation;
    char canned_uri[EST_URI_MAX_LEN];

    /*
     * build out a canned URI to pass to the uriparser library.
     * This will cause the incoming path segment to be in the
     * correct spot within a URI as it gets validated.  Main issue
     * is the possible use of a ':' in the path segment becoming a
     * theme delimiter
     */
    memzero_s(canned_uri, EST_URI_MAX_LEN);
    strcpy_s(canned_uri, EST_URI_MAX_LEN, "/.well-known/est/");
    strcat_s(canned_uri, EST_URI_MAX_LEN, path_seg);

    state.uri = &parsed_uri;
    uriparse_rc = uriParseUriA(&state, canned_uri);
    if (uriparse_rc != URI_SUCCESS) {
        uriFreeUriMembersA(state.uri);
        return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    }

    cur_seg = parsed_uri.pathHead;
    if (cur_seg == NULL) {
        EST_LOG_ERR("No valid path segment in supplied string");
        uriFreeUriMembersA(state.uri);
        return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    }

    cur_seg = cur_seg->next->next;
    cur_seg_str = (char *)cur_seg->text.first;
    operation = est_parse_operation(cur_seg_str);
        /*
         * look to see if the operation path comes next:
         * cacerts, csrattrs, simpleenroll, simplereenroll.
         * If any of the operations occur in this path segment
         * string, then this is a problem.
         */
    if (operation != EST_OP_MAX) {
        EST_LOG_ERR("Path segment string contains an operation value. path segment passed in =  %s\n", cur_seg_str);
        uriFreeUriMembersA(state.uri);
        return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    }

    /*
     * Look to see if there are multiple segments
     */
    if ((char *)cur_seg->next != NULL || *(cur_seg->text.afterLast) != '\0') {
        EST_LOG_ERR("Path segment string contains multiple path segments or more than a path segment");
        uriFreeUriMembersA(state.uri);        
        return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    }
    
    uriFreeUriMembersA(state.uri);    
    return (EST_ERR_NONE);
}
/*! @brief est_client_set_server() is called by the application layer to
     specify the address/port of the EST server. It must be called after
     est_client_init() and prior to issuing any EST commands.
 
    @param ctx Pointer to EST context for a client session
    @param server Name of the EST server to connect to.  The ASCII string
    representing the name of the server is limited to 254 characters
    @param port TCP port on the EST server to connect
    @param path_segment A string containing the optional path segment
    to be added to the URI.  If not used, set to NULL.
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_SERVER_NAME - NULL value passed for EST server name, or
    server name string too long
    EST_ERR_CLIENT_NOT_INITIALIZED - Called before est_client_init()
    EST_ERR_INVALID_PORT_NUM - Invalid port number input, less than zero or
    greater than 65535

    est_client_set_server error checks its input parameters and then stores
    both the hostname and port number into the EST context.
 */
EST_ERROR est_client_set_server (EST_CTX *ctx, const char *server, int port,
                                 char *path_segment)
{
    
    if (!ctx) {
        return EST_ERR_NO_CTX;
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    if (server == NULL) {
        return EST_ERR_INVALID_SERVER_NAME;
    }
    
    if (port <= 0 || port > 65535) {
        return EST_ERR_INVALID_PORT_NUM;
    }
    
    if (EOK != strncpy_s(ctx->est_server, EST_MAX_SERVERNAME_LEN, server,
                         EST_MAX_SERVERNAME_LEN)) {
        return EST_ERR_INVALID_SERVER_NAME;
    }   

    ctx->est_port_num = port;

#ifdef HAVE_URIPARSER
    {
        int path_segment_len;
        EST_ERROR rc;

        if (path_segment != NULL) {

            if (*path_segment == '\0') {
                return EST_ERR_HTTP_INVALID_PATH_SEGMENT;
            }
            
            /*
             * Make sure it's not too long
             */
            path_segment_len = strnlen_s(path_segment, EST_MAX_PATH_SEGMENT_LEN+1);
            if (path_segment_len > EST_MAX_PATH_SEGMENT_LEN) {
                return EST_ERR_HTTP_INVALID_PATH_SEGMENT;
            }

            /*
             * Validate the incoming path segment string
             */
            rc = est_client_parse_path_seg(path_segment);
            if (rc != EST_ERR_NONE) {
                EST_LOG_ERR("path segment failed validation.");
                return (rc);
            }

            /*
             * valid.  store it away in the context
             */
            rc = est_store_path_segment(ctx, path_segment, path_segment_len);
            if (rc != EST_ERR_NONE) {
                EST_LOG_ERR("Failed to store URI path segment.");
                return (rc);
            }        
        }
    }
#else
    {
        /*
         * If no uriparser support, then we cannot support
         * a path segment being passed in
         */
        if (path_segment) {
            EST_LOG_ERR("Use of path segments not supported in this build of libEST.");
            return EST_ERR_HTTP_PATH_SEGMENT_NOT_SUPPORTED;
        }  
    }
#endif
    return EST_ERR_NONE;
}
/*! @brief est_client_set_proxy() is called by the application layer to
    specify the proxy to the EST server. It must be called after
    est_client_init() and prior to issuing any EST commands.

    @param ctx Pointer to EST context for a client session
    @param proxy_proto Proxy protocol
    @param proxy_server Name of the proxy server to connect to.  The ASCII string
    representing the name of the server is limited to 254 characters (EST_MAX_SERVERNAME_LEN)
    @param port TCP port on the proxy server to connect
    @param proxy_auth Proxy authentication method
    @param username Username to use to authenticate with the proxy
    @param password Password to use to authenticate with the proxy

    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_SERVER_NAME - NULL value passed for EST server name, or
    server name string too long
    EST_ERR_INVALID_PORT_NUM - port num to proxy server is invalid
    EST_ERR_CLIENT_NOT_INITIALIZED - Called before est_client_init()
    EST_ERR_INVALID_PARAMETERS - NULL value passed for either username or password
    OR username or password is too long
    EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED - client proxy mode is only supported when
    built with libcurl support
    EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL - An invalid proxy protocol has been specified 
    
    est_client_set_proxy error checks its input parameters and then stores
    the proxy information into the EST context.

    NOTE: HTTP proxy tunnelling is not supported by libEST in server mode.
    If configuring libEST in client mode to communicate with libEST in
    server mode, then EST_CLIENT_PROXY_HTTP_NOTUNNEL must be specified
    for the proxy protocol.
 */
EST_ERROR est_client_set_proxy (EST_CTX *ctx, EST_CLIENT_PROXY_PROTO proxy_proto,
                                const char *proxy_server, unsigned short int proxy_port,
                                unsigned int proxy_auth, const char *username,
                                const char *password)
{
#ifdef HAVE_LIBCURL
    if (!ctx) {
        return EST_ERR_NO_CTX;
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    if (proxy_server == NULL || proxy_server[0] == '\0') {
        return EST_ERR_INVALID_SERVER_NAME;
    }

    if (EST_MAX_SERVERNAME_LEN < strnlen_s(proxy_server, EST_MAX_SERVERNAME_LEN+2)) {
        return EST_ERR_INVALID_SERVER_NAME;
    }

    ctx->proxy_server[0] = '\0';
    if (EOK != strncpy_s(ctx->proxy_server, sizeof(ctx->proxy_server),
                         proxy_server, sizeof(ctx->proxy_server))) {
        return EST_ERR_INVALID_SERVER_NAME;
    }

    if (proxy_port <= 0 || proxy_port > 65535) {
        return EST_ERR_INVALID_PORT_NUM;
    }
    ctx->proxy_port = proxy_port;
    
    if (proxy_proto < EST_CLIENT_PROXY_HTTP_NOTUNNEL ||
        proxy_proto > EST_CLIENT_PROXY_SOCKS5_HOSTNAME) {
        return EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL;
    }
    ctx->proxy_proto = proxy_proto;

    if (proxy_auth != EST_CLIENT_PROXY_AUTH_NONE &&
        (0 != (proxy_auth & ~(EST_CLIENT_PROXY_AUTH_BASIC|EST_CLIENT_PROXY_AUTH_NTLM)))) {
        return EST_ERR_INVALID_CLIENT_PROXY_AUTH;
    }
    ctx->proxy_auth = proxy_auth;

    if (username && password && proxy_auth != EST_CLIENT_PROXY_AUTH_NONE) {
        
        if (MAX_UIDPWD < strnlen_s(username, MAX_UIDPWD+2)) {
            return EST_ERR_INVALID_PARAMETERS;
        }

        if (username[0] == '\0') {
            return EST_ERR_INVALID_PARAMETERS;
        }

        ctx->proxy_username[0] = '\0';
        if (EOK != strncpy_s(ctx->proxy_username, sizeof(ctx->proxy_username),
                             username, sizeof(ctx->proxy_username))) {
            return EST_ERR_INVALID_PARAMETERS;
        }

        if (MAX_UIDPWD < strnlen_s(password, MAX_UIDPWD+2)) {
            return EST_ERR_INVALID_PARAMETERS;
        }

        if (password[0] == '\0') {
            return EST_ERR_INVALID_PARAMETERS;
        }

        ctx->proxy_password[0] = '\0';
        if (EOK != strncpy_s(ctx->proxy_password, sizeof(ctx->proxy_password), password,
                             sizeof(ctx->proxy_password))) {
            return EST_ERR_INVALID_PARAMETERS;
        }

        ctx->proxy_auth = proxy_auth;
    }

    ctx->use_proxy = 1;
    
    return EST_ERR_NONE;
#else
    /*
     * If the EST library was not built with support for libcurl then client
     * proxy mode is not supported.
     */
    EST_LOG_ERR("Client proxy mode requires libest to be built with libcurl.");
    return EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED;
#endif    
}
/*! @brief est_client_set_sign_digest() is called by the application layer to
     specify the hash algorithm used to sign the PKCS10 CSR during the
     enroll operation. It must be called after
     est_client_init() and prior to issuing any EST commands.
 
    @param ctx Pointer to EST context for a client session
    @param nid This is the NID value defined in the OpenSSL header file obj_mac.h
               for the desired digest to use for signing.  
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_DIGEST - An unsupported NID was provided.

    libEST supports SHA1, SHA224, SHA256, SHA384, and SHA512 digests.  
    SHA256 is the default digest to use for signing.  There's no need
    to invoke this function unless another digest is desired. The
    supported NID values are:
	NID_sha1
	NID_sha224 
	NID_sha256 
	NID_sha384 
	NID_sha512 
    
 */
EST_ERROR est_client_set_sign_digest (EST_CTX *ctx, int nid) 
{
    if (!ctx) {
        return EST_ERR_NO_CTX;
    }

    switch (nid) {
    case NID_sha512:
        ctx->signing_digest = EVP_sha512(); 
        break;
    case NID_sha384:
        ctx->signing_digest = EVP_sha384(); 
        break;
    case NID_sha256:
        ctx->signing_digest = EVP_sha256(); 
        break;
    case NID_sha224:
        ctx->signing_digest = EVP_sha224(); 
        break;
    case NID_sha1:
        ctx->signing_digest = EVP_sha1(); 
        break;
    default:
	return (EST_ERR_INVALID_DIGEST);
        break;
    }

    return (EST_ERR_NONE);
}
/*! @brief est_client_copy_retry_after() copies the retry after value stored
    in this client context.
 
    @param ctx Pointer to the current EST context.
    
    @param retry_delay Pointer to the integer where the retry-after delay secs
    value is copied.  If the server sent a retry-after in delay seconds format
    then it will be passed here.  If it did not, then this value will be zero.
    
    @param retry_time Pointer to the time_t where the retry-after time date
    value is copied.  If the server sent a retry-after in time and date string
    format then this string is converted into a time_t value and passed up
    in this parameter.  This value will only be set if the server sent a time
    and date string response, otherwise, this value is set to zero.
 
    @return EST_ERROR

    When a response is received from the EST server the headers are checked to
    see if the server has included a Retry-After header, indicating that this
    request currently cannot be processed.  If a Retry-After HTTP header is
    included in the received response from the server the delay value is saved
    in the context and an EST error code is given to the application on this
    request indicating that the client must retry the request at a later time.

    The value specified by the server can be in one of two basic formats, a
    string version of a integer value that represents the number of seconds
    the client must wait before retrying the request, and a string containing
    a date and time when the client can retry the request.  The date and time
    string can be in any format specified in RFC 2616.  If the second delay
    value is sent it is converted into an integer and saved in the EST context
    and if the date time string value is sent it is converted into a time_t
    value and saved into the EST context.  The application must then call
    est_client_copy_retry_after() to obtain the amount of time to wait before
    retrying the request.  est_client_copy_retry_after() copies the current
    retry-after value from the client context and returns it to the
    application.  Only one of the two return values will be set with a
    non-zero value.

    NOTE: The processing of a Retry-After value in time/date format is currently
    not supported.  The EST Client will always return only a retry delay
    value in seconds.
 */
EST_ERROR est_client_copy_retry_after (EST_CTX *ctx, int *retry_delay,
                                       time_t *retry_time)
{

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (!ctx->est_client_initialized) {
        return EST_ERR_CLIENT_NOT_INITIALIZED;
    }

    *retry_delay = ctx->retry_after_delay;
    ctx->retry_after_delay = 0;

    *retry_time = ctx->retry_after_date;
    ctx->retry_after_date = 0;
    
    return (EST_ERR_NONE);
}
/*! @brief est_client_force_pop() is used by an application to enable 
    the proof-of-possession generation at the EST client.  This proves
    that the EST client that sent the CSR to the server/proxy is in possession
    of the private key that was used to sign the CSR.  This binds the TLS 
    session ID to the CSR.

    Note, if the CSR attributes configured on the server require PoP 
    checking, then there is no need to call this function to enable
    PoP.  The PoP will be enabled automatically under this scenario
    when the CSR attributes are requested from the server/proxy.
    
    @param ctx Pointer to the EST context

    This function may be called at any time.   
 
    @return EST_ERROR.
 */
EST_ERROR est_client_force_pop (EST_CTX *ctx)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->client_force_pop = 1;
    return (EST_ERR_NONE);
}
/*! @brief est_client_unforce_pop() is used by an application to disable 
    the proof-of-possession generation at the EST client.  Please see
    the documenation for est_client_force_pop() for more information
    on the proof-of-possession check.

    @param ctx Pointer to the EST context

    This function may be called at any time.   
 
    @return EST_ERROR.
 */
EST_ERROR est_client_unforce_pop (EST_CTX *ctx)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->client_force_pop = 0;
    return (EST_ERR_NONE);
}
/*! @brief est_client_set_read_timeout() is used by an application to set
    timeout value of read operations.  After the EST client sends a request to
    the EST server it will attempt to read the response from the server.  This
    timeout value limits the amount of time the client will wait for the
    response.

    @param ctx Pointer to the EST context
    @param timeout Integer value representing the read timeout in seconds.
    The minimum value is EST_SSL_READ_TIMEOUT_MIN and the maximum value is
    EST_SSL_READ_TIMEOUT_MAX.
 
    @return EST_ERROR.
 */
EST_ERROR est_client_set_read_timeout (EST_CTX *ctx, int timeout)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    if (timeout < EST_SSL_READ_TIMEOUT_MIN ||
        timeout > EST_SSL_READ_TIMEOUT_MAX) {
	EST_LOG_ERR("Invalid read timeout value passed: %d ", timeout);
        return (EST_ERR_INVALID_PARAMETERS);
    }
        
    ctx->read_timeout = timeout;
    return (EST_ERR_NONE);
}
/*! @brief est_client_get_last_http_status() is used by an application to get
    the HTTP status code returned by the EST server for the most recent
    operation. 

    @param ctx Pointer to the EST context

    This can be called after an EST operation, such as an enroll operation.
    This function will return the most recent HTTP status code received
    from the EST server.  Normally, a status of 200 would be returned
    by the EST server to indicate a successful operation.  However, if the
    operation failed for some reason, the HTTP status code may be useful
    to understand the reason for failure.  For instance, the EST server 
    would return a HTTP status of 401 if the EST client was not authorized.
    Please see RFC 2616 for a description of the various HTTP status codes.
 
    @return int value representing the HTTP status code, or NULL if the
    a NULL EST context was provided.
 */
int est_client_get_last_http_status (EST_CTX *ctx)
{
    if (ctx) {
	return ctx->last_http_status;
    } else {
	return 0;
    }
}

static void (*est_log_func)(char *, va_list) = NULL;
/*
 * This is our default logger routine, which just
 * dumps log data to stderr.  The application can
 * override this by calling est_init_logger() and
 * passing in a function pointer to a function
 * that implements this prototype.
 */
static void est_logger_stderr (char *format, va_list l)
{
#ifndef WIN32
	flockfile(stderr);
#endif
	vfprintf(stderr, format, l);
	fflush(stderr);
#ifndef WIN32
	funlockfile(stderr);
#endif
}
/*
 * This is our default logger routine, which just
 * dumps log data to stderr.  The application can
 * override this by calling est_init_logger() and
 * passing in a function pointer to a function
 * that implements this prototype.
 */
static void est_log_msg (char *format, ...)
{
    va_list arguments;

    /*
     * Pull the arguments from the stack and invoke
     * the logger function
     */
    va_start(arguments, format);
    if (est_log_func != NULL) {
        (*est_log_func)(format, arguments);
    } else {
        est_logger_stderr(format, arguments);
    }
    va_end(arguments);
}
/*
 * Global function to be called to log something
 */
void est_log (EST_LOG_LEVEL lvl, char *format, ...)
{
    va_list arguments;

    /*
     * check if user is interested in this log message
     */
    if (lvl > est_desired_log_lvl) {
        return;
    }

    /*
     * Pull the arguments from the stack and invoke
     * the logger function
     */
    va_start(arguments, format);
    if (est_log_func != NULL) {
        (*est_log_func)(format, arguments);
    } else {
        est_logger_stderr(format, arguments);
    }
    va_end(arguments);

}
/*
 * Global function to be called to log something
 */
static void printStackTrace(void) {
	unsigned int i;
	void *stack[100];
	unsigned short frames;
	SYMBOL_INFO * symbol;
	HANDLE        process;

	process = GetCurrentProcess();

	SymInitialize(process, NULL, TRUE);

	frames = CaptureStackBackTrace(0, 100, stack, NULL);
	symbol = (SYMBOL_INFO *)calloc(sizeof(SYMBOL_INFO) + 256 * sizeof(char), 1);
	symbol->MaxNameLen = 255;
	symbol->SizeOfStruct = sizeof(SYMBOL_INFO);
	for (i = 0; i < frames; i++) {
		SymFromAddr(process, (DWORD64)(stack[i]), 0, symbol);
		est_log_msg("\n%i: [0x%0X] %s", (frames - i - 1), symbol->Address, symbol->Name);

	}

	free(symbol);
}
/*
 * Global function to be called to log something
 */
void est_log_backtrace (void)
{
#ifndef DISABLE_BACKTRACE
#ifdef WIN32
	/*
	* Spit out a backtrace if this is enabled globally
	*/
	if (est_backtrace_enabled) {
		printStackTrace();
	}
#else
    void* callstack[128];
    char **strs;
    int i, frames;

    /*
     * Spit out a backtrace if this is enabled globally
     */
    if (est_backtrace_enabled) {
        frames = backtrace(callstack, 128);
        strs = backtrace_symbols(callstack, frames);
        for (i = 0; i < frames; ++i) {
	    est_log_msg("\n%s", strs[i]);
            //fprintf(stderr, "%s\n", strs[i]);
        }
	est_log_msg("\n\n");
        free(strs);
    }
#endif /* WIN32*/
#endif /* DISABLE_BACKTRACE*/
}
/*! @brief est_get_version() allows the application to retrieve
    the libEST version string.  Returns a char* array containing
    the full version string value for the library.
 
    @return const char*
 */
const char * est_get_version (void) {
    return EST_VER_STRING; 
}
/*! @brief est_get_api_level() allows the application to retrieve
    the libEST API level.  This is a numeric value that
    indicates the API level of the library.  When new versions of
    libEST are released and the API changes, this value will be
    incremented.  Applications can use this to determine which capabilities
    in the libEST library should or should not be attempted.
 
    @return int
 */
int est_get_api_level (void) {
    return EST_API_LEVEL; 
}
/*
 * Use this to log the libEST version to an information
 * log message.  Also logs the compile-time and run-time 
 * OpenSSL versions.
 */
void est_log_version (void)
{
    EST_LOG_INFO("%s (API level %d)", est_get_version(), est_get_api_level());
#ifdef SOURCE_REVISION
    EST_LOG_INFO("Source repository revision# %d", SOURCE_REVISION);
#endif
    EST_LOG_INFO("Compiled against %s", OPENSSL_VERSION_TEXT);
    EST_LOG_INFO("Linking to %s", SSLeay_version(SSLEAY_VERSION));
}
/*! @brief est_init_logger() allows the application to override the 
    default log handler for EST logging messages.
 
    @param lvl Sets the desired logging level to EST_LOG_LEVEL
    @param loggerfunc Sets the callback function to handle logging
 
    This function allows an application that uses EST to provide
    a function for logging EST messages.  EST provides a default handler
    that sends messages to stderr.  Applications may desire to send
    messages to syslog or some other logging facility.  An application
    would provide a function pointer using this method to intercept
    and handle EST log messages.  This setting is global to the library
    and will impact all contexts.
 
    @return EST_ERROR.
 */
EST_ERROR est_init_logger (EST_LOG_LEVEL lvl, void (*loggerfunc)(char *, va_list))
{
    /* Initialize the logger */
    if (loggerfunc) {
        est_log_func = loggerfunc;
    } else {
        /* install our default logger */
        est_log_func = &est_logger_stderr;
    }

    /*
     * Set the desired logging level
     */
    est_desired_log_lvl = lvl;
    return (EST_ERR_NONE);
}
/*! @brief est_enable_backtrace() allows the application to toggle
    whether the stack trace is displayed for WARNING and ERROR
    log messages coming from libEST.   
 
    @param enable Set to zero to disable stack traces, non-zero to
                  enable stack traces through the logging facility.
 
    This function allows an application to enable stack traces, which
    may be useful for troubleshooting the libEST library.  Stack
    traces are disabled by default.  Call this function with a 
    non-zero argument to enable stack traces for both WARNING and
    ERROR log messages.  This setting is global to the library and
    will impact all contexts.
 
    @return void.
 */
void est_enable_backtrace (int enable)
{
    est_backtrace_enabled = enable;
}
/*! @brief est_read_x509_request() is a helper function that reads
 *  a char* and converts it to an OpenSSL X509_REQ*.  The char* data
 *  can be either PEM or DER encoded.   
 
    @param csr This is the char* that contains the PEM or DER encoded
               X509 CSR.
    @param csr_len This is the length of the csr char*.  DER encoded data
               may contain zeros, which requires the length to be provided
	       by the application layer.
    @param csr_format This parameter specifies the encoding method of the
               csr char* that was provided.  Set this to either EST_CERT_FORMAT_PEM
	       or EST_CERT_FORMAT_DER.
 
    This function converts a PEM or DER encoded char* to the OpenSSL
    X509_REQ structure.  This function will return NULL if the PEM/DER
    data is corrupted or unable to be parsed by the OpenSSL library.
    This function will allocate memory for the X509_REQ data.  You must
    free the memory in your application when it's no longer needed by
    calling X509_REQ_free().
 
    @return X509_REQ*
 */
X509_REQ *est_read_x509_request (unsigned char *csr, int csr_len,
	                         EST_CERT_FORMAT csr_format)
{
    X509_REQ *req = NULL;
    BIO *in;
    unsigned long err;

    if (!csr) {
	EST_LOG_ERR("CSR may not be NULL");
	return (NULL);
    }

    if (csr_len > EST_RAW_CSR_LEN_MAX) {
	EST_LOG_ERR("CSR length is greater than maximum allowed (%d)", EST_RAW_CSR_LEN_MAX);
	return (NULL);
    }

    if (csr_format != EST_CERT_FORMAT_PEM && csr_format != EST_CERT_FORMAT_DER) {
	EST_LOG_ERR("Only PEM and DER encoding formats are supported.");
	return (NULL);
    }

    in = BIO_new_mem_buf(csr, csr_len);
    if (in == NULL) {
        EST_LOG_ERR("Unable to open the CSR memory buffer");
        return (NULL);
    }

    switch (csr_format) {
    case EST_CERT_FORMAT_PEM:
	req = PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);
	break;
    case EST_CERT_FORMAT_DER:
	req = d2i_X509_REQ_bio(in,NULL);
	break;
    default:
	EST_LOG_ERR("Invalid CSR format specified.");
        break;
    }

    /*
     * Check for an error while parsing the input data
     */
    if (!req) {
        EST_LOG_ERR("An error occurred in the OpenSSL library while reading the CSR data.");
	err = ERR_get_error();
	EST_LOG_ERR("OpenSSL error string: %s", ERR_error_string(err, NULL));
    }

    BIO_free_all(in);
    return (req);
}
/*! @brief est_load_key() is a helper function that reads
 *  a char* and converts it to an OpenSSL EVP_PKEY*.  The char* data
 *  can be either PEM or DER encoded.   
 
    @param key This is the char* that contains the PEM or DER encoded
               key pair.
    @param key_len This is the length of the key char*.  DER encoded data
               may contain zeros, which requires the length to be provided
	       by the application layer.
    @param key_format This parameter specifies the encoding method of the
               key char* that was provided.  Set this to either EST_FORMAT_PEM
	       or EST_FORMAT_DER.
 
    This function converts a PEM or DER encoded char* to the OpenSSL
    EVP_PKEY* structure.  This function will return NULL if the PEM/DER
    data is corrupted or unable to be parsed by the OpenSSL library.
    This function will allocate memory for the EVP_PKEY data.  You must
    free the memory in your application when it's no longer needed by
    calling EVP_PKEY_free().
 
    @return EVP_PKEY*
 */
EVP_PKEY *est_load_key (unsigned char *key, int key_len, int format)
{
    BIO *in = NULL;
    EVP_PKEY *pkey = NULL;

    if (key == NULL) {
        EST_LOG_ERR("no key data provided");
        return NULL;
    }

    in = BIO_new_mem_buf(key, key_len);
    if (in == NULL) {
        EST_LOG_ERR("Unable to open the provided key buffer");
        return (NULL);
    }

    switch (format) {
    case EST_FORMAT_PEM:
        pkey = PEM_read_bio_PrivateKey(in, NULL, NULL, NULL);
        break;
    case EST_FORMAT_DER:
        pkey = d2i_PrivateKey_bio(in, NULL);
        break;
    default:
        EST_LOG_ERR("Invalid key format");
        BIO_free(in);
        return NULL;
        break;
    }
    BIO_free(in);

    return (pkey);
}
/*
 * Converts from PEM to pkcs7 encoded certs.  Optionally
 * applies base64 encoding to the output.  This is used
 * when creating the cached cacerts response.  The returned
 * BIO contains the PKCS7 encoded certs.  The response
 * can optionally be base64 encoded by passing in a
 * non-zero value for the do_base_64 argument.  The caller
 * of this function should invoke BIO_free_all() on the
 * return value to avoid memory leaks.  Note, BIO_free() 
 * will not be sufficient.
 */
static BIO * est_get_certs_pkcs7 (BIO *in, int do_base_64)
{
    STACK_OF(X509) * cert_stack = NULL;
    PKCS7_SIGNED *p7s = NULL;
    PKCS7 *p7 = NULL;
    BIO *out = NULL;
    BIO *b64;
    int buflen = 0;


    /*
     * Create a PKCS7 object 
     */
    if ((p7 = PKCS7_new()) == NULL) {
        EST_LOG_ERR("pkcs7_new failed");
	goto cleanup;
    }
    /*
     * Create the PKCS7 signed object
     */
    if ((p7s = PKCS7_SIGNED_new()) == NULL) {
        EST_LOG_ERR("pkcs7_signed_new failed");
	goto cleanup;
    }
    /*
     * Set the version
     */
    if (!ASN1_INTEGER_set(p7s->version, 1)) {
        EST_LOG_ERR("ASN1_integer_set failed");
	goto cleanup;
    }

    /*
     * Create a stack of X509 certs
     */
    if ((cert_stack = sk_X509_new_null()) == NULL) {
        EST_LOG_ERR("stack malloc failed");
	goto cleanup;
    }

    /*
     * Populate the cert stack
     */
    if (est_add_certs_from_BIO(cert_stack, in) < 0) {
        EST_LOG_ERR("Unable to load certificates");
	ossl_dump_ssl_errors();
	goto cleanup;
    }

    /*
     * Create the BIO which will receive the output
     */
    out = BIO_new(BIO_s_mem());
    if (!out) {
        EST_LOG_ERR("BIO_new failed");
	goto cleanup;
    }

    /*
     * Add the base64 encoder if needed
     */
    if (do_base_64) {
	b64 = BIO_new(BIO_f_base64());
        if (b64 == NULL) {
            EST_LOG_ERR("BIO_new failed while attempting to create base64 BIO");
            ossl_dump_ssl_errors();
            goto cleanup;
        }    
	out = BIO_push(b64, out);
    }

    p7->type = OBJ_nid2obj(NID_pkcs7_signed);
    p7->d.sign = p7s;
    p7s->contents->type = OBJ_nid2obj(NID_pkcs7_data);
    p7s->cert = cert_stack;

    /*
     * Convert from PEM to PKCS7
     */
    buflen = i2d_PKCS7_bio(out, p7);
    if (!buflen) {
        EST_LOG_ERR("PEM_write_bio_PKCS7 failed");
	ossl_dump_ssl_errors();
	BIO_free_all(out);
        out = NULL;
	goto cleanup;
    }
    (void)BIO_flush(out);

cleanup:
    /* 
     * Only need to cleanup p7.  This frees up the p7s and
     * cert_stack allocations for us since these are linked
     * to the p7.
     */
    if (p7) {
        PKCS7_free(p7);
    }

    return out;
}
/*
 * Takes a raw char array containg the CA certificates, reads the data
 * in and loads the certificates on to the context as pkcs7 certs.  This is
 * stored on the EST context and used to respond to the /cacerts request,
 * which requires PKCS7 encoding.
 *
 * This function also loads the x509 store on the context used to
 * verify the peer.
 */
EST_ERROR est_load_ca_certs (EST_CTX *ctx, unsigned char *raw, int size)
{
    BIO *cacerts = NULL;
    BIO *in;
    unsigned char *retval;

    /*
     * Only the server and proxy modes may load the cacerts response
     */
    if (ctx->est_mode == EST_CLIENT) {
	return EST_ERR_BAD_MODE;
    }

    in = BIO_new_mem_buf(raw, size);
    if (in == NULL) {
        EST_LOG_ERR("Unable to open the raw cert buffer");
        return (EST_ERR_LOAD_CACERTS);
    }

    /*
     * convert the CA certs to PKCS7 encoded char array
     * This is used by an EST server to respond to the
     * cacerts request.
     */
    cacerts = est_get_certs_pkcs7(in, 1);
    if (!cacerts) {
        EST_LOG_ERR("est_get_certs_pkcs7 failed");
        BIO_free(in);
        return (EST_ERR_LOAD_CACERTS);
    }

    ctx->ca_certs_len = (int) BIO_get_mem_data(cacerts, (char**)&retval);
    if (ctx->ca_certs_len <= 0) {
        EST_LOG_ERR("Failed to copy PKCS7 data");
        BIO_free_all(cacerts);
        BIO_free(in);
        return (EST_ERR_LOAD_CACERTS);
    }

    ctx->ca_certs = malloc(ctx->ca_certs_len);
    if (!ctx->ca_certs) {
        EST_LOG_ERR("malloc failed");
        BIO_free_all(cacerts);
        BIO_free(in);
        return (EST_ERR_LOAD_CACERTS);
    }
    memcpy_s(ctx->ca_certs, ctx->ca_certs_len, retval, ctx->ca_certs_len);
    BIO_free_all(cacerts);
    BIO_free(in);
    return (EST_ERR_NONE);
}
/*
 * Takes a char array containing the PEM encoded CA certificates,
 * both implicit and explict certs.  These are decoded and loaded
 * into the trusted_certs_store member on the EST context.  This cert
 * store is used by the TLS stack for peer verification at the TLS
 * layer.
 * Note: we do not include defensive code to check for NULL arguments
 *       because this function is not part of the public API.  These
 *       checks should have already been performed.
 */
EST_ERROR est_load_trusted_certs (EST_CTX *ctx, unsigned char *certs, int certs_len)
{
    EST_ERROR rv;

    /*
     * Create the combined cert store on the context
     * This contains both the implicit and explicit certs
     */
    ctx->trusted_certs_store = X509_STORE_new();
    if (ctx->trusted_certs_store == NULL) {
        EST_LOG_ERR("Unable to allocate combined cert store");
        return (EST_ERR_LOAD_TRUST_CERTS);
    }
    X509_STORE_set_verify_cb(ctx->trusted_certs_store, ossl_verify_cb);
    rv = ossl_init_cert_store(ctx->trusted_certs_store, certs, certs_len);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Unable to populate combined cert store");
	return (rv);
    }

    return (EST_ERR_NONE);
}
/*! @brief est_set_ex_data() sets the application specific data
    on the EST context. 
 
    @param ctx Pointer to an EST context
    @param ex_data Pointer to application specific data that will be
                   passed through to the EST callbacks.
 
    @return EST_ERROR

    This function is used to link application specific data to the
    EST_CTX structure.  This can be used by an application to bind
    application specific data to an EST operation.  libEST does 
    not use the application specific data.  The *ex_data pointer is
    passed back to the application when libEST invokes the 
    enroll, re-enroll, CSR attributes, and HTTP auth callbacks.

    libEST will not free the memory referenced by the *ex_data
    parameter when est_destroy() is invoked.  The application is
    responsible for releasing its application specific data. 
 */
EST_ERROR est_set_ex_data (EST_CTX *ctx, void *ex_data)
{
    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }
    if (ctx->ex_data) {
	EST_LOG_WARN("ex_data was already set, possible memory leak");
    }
    ctx->ex_data = ex_data;
    return (EST_ERR_NONE);
}
/*! @brief est_get_ex_data() retrieves the application specific data
    on the EST context. 
 
    @param ctx Pointer to an EST context
 
    @return void* 

    This function is used to attain a reference to the application 
    specific data on the EST_CTX structure.  This data should have
    been set by invoking est_set_ex_data() earlier.  Otherwise it
    will return NULL. 
 */
void * est_get_ex_data (EST_CTX *ctx)
{
    if (!ctx) {
        return (NULL);
    }
    return (ctx->ex_data);
}
/*! @brief est_destroy() frees an EST context 
 
    @param ctx Pointer to an EST context
 
    @return EST_ERROR

    This function is used to release all the memory allocated under
    the EST_CTX*.  This should be called last after performing EST
    operations using the context.
 */
EST_ERROR est_destroy (EST_CTX *ctx)
{

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    if (ctx->trusted_certs_store != NULL) {
        X509_STORE_free(ctx->trusted_certs_store);
    }

    if (ctx->ca_certs) {
        free(ctx->ca_certs);
    }

    if (ctx->retrieved_ca_certs) {
        free(ctx->retrieved_ca_certs);
    }

    if (ctx->retrieved_csrattrs) {
        free(ctx->retrieved_csrattrs);
    }

    if (ctx->server_csrattrs) {
        free(ctx->server_csrattrs);
    }

    if (ctx->enrolled_client_cert) {
        free(ctx->enrolled_client_cert);
    }

    if (ctx->ca_chain_raw) {
        free(ctx->ca_chain_raw);
    }

    if (ctx->uri_path_segment) {
        free(ctx->uri_path_segment);
    }

    if (ctx->dh_tmp) {
	DH_free(ctx->dh_tmp);
    }

    /* Only free the SSL context when acting as a client.  When
     * operating as a server, it's expected the web server
     * will free the context */
    if (ctx->ssl_ctx &&
        ((ctx->est_mode == EST_CLIENT)||(ctx->est_mode == EST_PROXY))) {
        /*
         * If the SSL session had been cached, this means that
         * SSL_get1_session() has been called, so now it needs to be explictly
         * freed to get its ref count decrememnted.
         */
        if (ctx->sess) {
            SSL_SESSION_free(ctx->sess);
        }
        SSL_CTX_free(ctx->ssl_ctx);
    }

    if (ctx->est_mode == EST_PROXY) {
        proxy_cleanup(ctx);
    }

    /*
     * And finally free the EST context itself
     */
    free(ctx);
    return (EST_ERR_NONE);
}
/*
 * This routine is used to determine whether the BIO_FLAGS_BASE64_NO_NL 
 * option needs to be used when using the OpenSSL
 * base64 decoder.  It takes a string as input and
 * checks if it contains newline characters.
 *
 * Returns 1 if OpenSSL should use the BIO_FLAGS_BASE64_NO_NL option
 * Returns 0 otherwise
 */
static int est_base64_contains_nl (const char *src, int len)
{
    int i;

    if (len < 64) {
	/* 
	 * Any base64 less than 64 bytes shouldn't be a 
	 * problem for OpenSSL since this is the minimum
	 * line length for base64 encoding.
	 */
	return 0;
    }

    /*
     * Start looking for newlines at the 64th position
     */
    for (i = 63; i < len-1; i++) {
	if (src[i] == 0xA) {
	    return 1;
	}
    }
    return 0;
}
/*
 * This routine is used to decode base64 encoded data.
 * Pass in the base64 encoded data and a pointer to a buffer
 * to receive the decoded data.  The length of the decoded 
 * data is returned.  If the return value is zero or negative, then
 * an error occurred.  The dst_size parameter is the maximum
 * allowed size of the decoded data.
 */
int est_base64_decode (const char *src, char *dst, int dst_size)
{
    BIO *b64, *b64in;
    int len;
    int max_in;

    /*
     * When decoding base64, the output will always be smaller by a
     * ratio of 4:3.  Determine what the max size can be for the input
     * based on the size of the given output buffer and then make sure that
     * the actual input buffer is not too big.
     */
    max_in = ((dst_size * 4) / 3) + 1;
    /*
     * Get the length of the base64 encoded data.  Make sure it's not too
     * big
     */
    len = strnlen_s(src, max_in+1); 
    if (len > max_in) {
        EST_LOG_ERR("Source buffer for base64 decode is loo large for destination buffer. "
                    "source buf len = %d, max input len = %d, max dest len = %d",
                    len, max_in, dst_size);
	return (0);
    }

    b64 = BIO_new(BIO_f_base64());
    if (b64 == NULL) {
        EST_LOG_ERR("BIO_new failed while attempting to create base64 BIO");
        ossl_dump_ssl_errors();
	return (0);
    }
    b64in = BIO_new_mem_buf((char *)src, len); 
    if (b64in == NULL) {
        EST_LOG_ERR("BIO_new failed while attempting to create mem BIO");
        ossl_dump_ssl_errors();
	return (0);
    }
    if (!est_base64_contains_nl (src, len)) {
	/*
	 * Enable the no newlines option if the input
	 * data doesn't contain any newline characters.
	 * It's too bad OpenSSL doesn't do this implicitly.
	 */
        BIO_set_flags(b64,BIO_FLAGS_BASE64_NO_NL);
    }
    b64in = BIO_push(b64, b64in);
    len = BIO_read(b64in, dst, dst_size);
    if (len <= 0) {
	EST_LOG_WARN("BIO_read failed while decoding base64 data (%d)", len);
    } else {
        /*
         * Make sure the response is null terminated
         */
        dst[len] = 0;
    }

    BIO_free_all(b64in);
    return (len);
}
/*
 * This routine is used to encode base64 data.
 * Pass in the unencoded data, the length of the source buffer,
 * and a pointer to a buffer to receive the encoded data.
 * The length of the encoded data is returned.  If the return value
 * is zero, then an error occurred.  The max_dest_len parameter
 * is the maximum allowed size of the encoded data.
 */
int est_base64_encode (const char *src, int actual_src_len, char *dst,
                       int max_dst_len)
{
    BIO *b64;
    BIO *out;
    int max_src_len;
    int actual_dst_len = 0;
    int write_cnt = 0;
    BUF_MEM *bptr = NULL;
    
    /*
     * When encoding base64, the output will always be larger by a
     * ratio of 3:4.  Determine what the max size can be for the input
     * based on the size of the given output buffer and then make sure that
     * the actual input buffer is not too big.
     */
    max_src_len = ((max_dst_len * 3) / 4) + 1;
    if (actual_src_len > max_src_len) {
        EST_LOG_ERR("Source buffer for base64 encode is loo large for destination buffer. "
                    "max source len = %d, actual_source len = %d",
                    max_src_len, actual_src_len);
	return 0;
    }

    b64 = BIO_new(BIO_f_base64());
    if (b64 == NULL) {
        EST_LOG_ERR("BIO_new failed while attempting to create base64 BIO");
        ossl_dump_ssl_errors();
        return 0;
    }    

    out = BIO_new(BIO_s_mem());
    if (out == NULL) {
        EST_LOG_ERR("BIO_new failed while attempting to create mem based BIO");
        ossl_dump_ssl_errors();
        BIO_free_all(b64);
        return 0;
    }
    out = BIO_push(b64, out);

    /*
     * We don't ever insert new lines
     */
    BIO_set_flags(out, BIO_FLAGS_BASE64_NO_NL);

    /*
     * Write the source buffer through the BIOs and then get a pointer
     * to the resulting memory buffer on the other side to obtain the
     * result.
     */
    write_cnt = BIO_write(out, src, actual_src_len);
    (void)BIO_flush(out);
    BIO_get_mem_ptr(out, &bptr);
    if (write_cnt <= 0) {
	EST_LOG_WARN("BIO_write failed while encoding base64 data (%d)", write_cnt);
    } else {
        /*
         * copy out the resulting base64 encoded string, make sure it's
         * null terminated, and return the length
         */
        memcpy_s(dst, max_dst_len, bptr->data, bptr->length);
        dst[bptr->length] = '\0';
        actual_dst_len = bptr->length;
    }

    BIO_free_all(b64);
    return (actual_dst_len);
}
/*
 * This routine is used to encode base64 data.
 * Pass in the unencoded data, the length of the source buffer,
 * and a pointer to a buffer to receive the encoded data.
 * The length of the encoded data is returned.  If the return value
 * is zero, then an error occurred.  The max_dest_len parameter
 * is the maximum allowed size of the encoded data.
 */
char * est_get_tls_uid (SSL *ssl, int is_client)
{
    char finished[MAX_FINISHED];
    BIO *bio = NULL, *b64 = NULL;
    BUF_MEM *bptr = NULL;
    int len;
    char *rv = NULL;

    /*
     * RFC5929 states the *first* finished message is used
     * to derive the tls-unique-id.  When session resumption
     * is used, the server sends the first finished message.
     * Normally the client sends the first finished messaged.
     */
    if ((is_client && !SSL_session_reused(ssl)) ||
        (!is_client && SSL_session_reused(ssl))) {
        len = (int) SSL_get_finished(ssl, finished, MAX_FINISHED);
    } else {
        len = (int) SSL_get_peer_finished(ssl, finished, MAX_FINISHED);
    }

    b64 = BIO_new(BIO_f_base64());
    if (b64 == NULL) {
        EST_LOG_ERR("BIO_new failed while attempting to create base64 BIO");
        ossl_dump_ssl_errors();
	return rv;
    }
    bio = BIO_new(BIO_s_mem());
    if (bio == NULL) {
        EST_LOG_ERR("BIO_new failed while attempting to create mem based BIO");
        ossl_dump_ssl_errors();
	return rv;
    }
    (void)BIO_flush(bio);
    bio = BIO_push(b64, bio);
    BIO_write(bio, finished, len);
    (void)BIO_flush(bio);
    BIO_get_mem_ptr(bio, &bptr);

    /*
     * Be aware that OpenSSL adds a newline character at the
     * end of the base64 encoded data
     */
    if (bptr->length != EST_TLS_UID_LEN) {
        EST_LOG_WARN("TLS UID length mismatch (%d/%d)", bptr->length,
                     EST_TLS_UID_LEN);
    } else {
        rv = malloc(EST_TLS_UID_LEN + 1);
        if (rv == NULL) {
            EST_LOG_ERR("Failed to allocate buffer");
            return rv;
        }    
        memcpy_s(rv, EST_TLS_UID_LEN, bptr->data, EST_TLS_UID_LEN);
        rv[EST_TLS_UID_LEN-1] = '\0';
        EST_LOG_INFO("TLS UID was found");
    }
    BIO_free_all(bio);
    return rv;
}
/*
 * This is a utility function to convert a hex value
 * to a string. This is used with the HTTP digest
 * authentication logic.
 */
void est_hex_to_str (char *dst, unsigned char *src, int len)
{
    static const char *hex = "0123456789abcdef";

    for (; len--; src++) {
        *dst++ = hex[src[0] >> 4];
        *dst++ = hex[src[0] & 0x0f];
    }
    *dst = '\0';
}
/*! @brief est_enable_crl() is used by an application to enable 
    checking of a certificate revocation list when validating the client
    TLS peer certificate during the TLS handshake. When enabled, 
    the ca_chain parameter provided to either est_server_init()
    or est_client_init() should contain both the trusted certificates 
    along with the CRL entries.  The CRL entries should be appened
    at the end.
 
    @param ctx Pointer to the EST context

    CRL checking is disabled by default.  This function must be called 
    after invoking est_server_init() or est_client_init() and prior 
    to performing any EST operations.  Therefore, there is no 'disable' 
    version of this method.  
 
    @return EST_ERROR.
 */
EST_ERROR est_enable_crl (EST_CTX *ctx)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->enable_crl = 1;
    return (EST_ERR_NONE);
}
/*
 * est_asn1_sanity_test - perform a sanity test on the CSR
 * attribute string.  This function operates on an ASN.1 hex
 * string, so it should already be un-based64.
 *
 * return EST_ERROR and the presence of challengePassword
 */
static 
EST_ERROR est_asn1_sanity_test (const unsigned char *string, long out_len, 
				int *pop_present)
{
    int tag, xclass, j, nid;
    long out_len_save = out_len;
    long len;
    const unsigned char *ostring = string;
    ASN1_OBJECT *a_object;
    int max_len = MAX_CSRATTRS;

    /*
     * Assume the challengePassword OID is not present
     */
    *pop_present = 0;

    /* make sure its long enough to be ASN.1 */
    if (out_len < MIN_ASN1_CSRATTRS) {
        return (EST_ERR_BAD_ASN1_HEX_TOO_SHORT);
    }

    while (out_len > 0) {
	j = ASN1_get_object(&string, &len, &tag, &xclass, out_len);

	EST_LOG_INFO("Sanity: tag=%d, len=%d, j=%d, out_len=%d", tag, len, j, out_len);
	if (j & 0x80) {
	    return (EST_ERR_BAD_ASN1_HEX);
        }
	switch (tag)
	{
	case V_ASN1_OBJECT:
            a_object = c2i_ASN1_OBJECT(NULL, &string, len);
	    if (a_object != NULL) {
	        nid = OBJ_obj2nid(a_object);
		EST_LOG_INFO("NID=%d", nid);
		if (nid == NID_pkcs9_challengePassword) {
	            EST_LOG_INFO("challengePassword OID found");
		    *pop_present = 1; /* just signifiy it's there */
		    max_len = MAX_CSRATTRS_WITHPOP;
		}
		ASN1_OBJECT_free(a_object);
            }
	    break;
	default:
	    /* have to adjust string pointer here */
	    string += len;
	    break;
	case V_ASN1_SET:
	case V_ASN1_SEQUENCE:
	    break;
	}
	out_len = (out_len_save - (string - ostring));	
    }
    if (out_len != 0) {
        return (EST_ERR_BAD_ASN1_HEX);
    }
    if (out_len_save > max_len) {
        return (EST_ERR_BAD_ASN1_HEX_TOO_LONG);
    }
    return (EST_ERR_NONE);
}
/*
 * est_is_challengePassword_present - take a base64 
 * encoded ASN.1 string and scan through it to see 
 * if challengePassword is included.
 *
 * return EST_ERROR and the presence of challengePassword
 */
EST_ERROR est_is_challengePassword_present (const char *base64_ptr, int b64_len, int *presence)
{

    /* assume its not there */
    *presence = 0;

    /* just return if no data */
    if ((base64_ptr == NULL) || (b64_len == 0)) {
        return (EST_ERR_NONE);
    }
    return (est_asn1_parse_attributes(base64_ptr, b64_len, presence));
}
/*
 * est_asn1_parse_attributes - base64 decode and sanity test
 * the given attributes string
 *
 * return EST_ERROR and the presence of challengePassword
 */
EST_ERROR est_asn1_parse_attributes (const char *p, int len, int *pop_present)
{
    unsigned char *der_ptr;
    int der_len, rv;

    /* 
     * check smallest possible base64 case here for now 
     * and sanity test will check min/max value for ASN.1 data
     */
    if (len < MIN_CSRATTRS) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    der_ptr = malloc(len*2);
    if (!der_ptr) {
        return (EST_ERR_MALLOC);
    }

    der_len = est_base64_decode(p, (char *)der_ptr, len*2);
    if (der_len <= 0) {
        EST_LOG_ERR("Invalid base64 encoded data");
	free(der_ptr);
        return (EST_ERR_BAD_BASE64);
    }

    rv = est_asn1_sanity_test(der_ptr, der_len, pop_present);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Invalid ASN1 encoded data. rv = %d (%s)",
                    rv, EST_ERR_NUM_TO_STR(rv));
	free(der_ptr);
	return (rv);
    }
    free(der_ptr);
    return (EST_ERR_NONE);
}
/* 
 * est_add_challengePassword - caller has verified that challengePassword 
 * is configured and not included, so add it to the attributes here.
 * No sanity check is needed since est_is_challengePassword_present
 * has already been called.
 */
EST_ERROR est_add_challengePassword (const char *base64_ptr, int b64_len, 
				     char **new_csr, int *pop_len)
{
    const unsigned char *der_ptr;
    char *orig_ptr, *new_der = NULL, *csrattrs;
    int der_len, tag, xclass, new_len;
    long len;
    int enc_len;

    der_ptr = malloc(b64_len*2);
    if (!der_ptr) {
        return (EST_ERR_MALLOC);
    }

    der_len = est_base64_decode(base64_ptr, (char *)der_ptr, b64_len*2);
    if (der_len <= 0) {
        EST_LOG_ERR("Malformed base64 data");
	free((void *)der_ptr);
        return (EST_ERR_MALLOC);
    }

    orig_ptr = (char *)der_ptr;

    /* grab the first one and do the POP stuff */
    (void)ASN1_get_object(&der_ptr, &len, &tag, &xclass, der_len);

    if (tag != V_ASN1_SEQUENCE) {
        EST_LOG_ERR("Malformed ASN.1 Hex, no leanding Sequence");
	free(orig_ptr);
	return (EST_ERR_BAD_ASN1_HEX);
    }

    len = (char *)der_ptr - orig_ptr;
    new_len = der_len - (int)len + sizeof(hex_chpw);
	    
    /* remove leading sequence and length and copy to new buffer */
    /* if >= 256 need 4 byte Seq header */
    if ((der_len - len + sizeof(hex_chpw)) >= 256) {
        new_len += 4;
	new_der = malloc(new_len);
	if (!new_der) {
	    free(orig_ptr);
	    return (EST_ERR_MALLOC);
	}
        memzero_s(new_der, new_len);
	*(new_der + 1) = 0x82;
        *(new_der + 2) = (new_len - 4) >> 8;
        *(new_der + 3) = ((new_len - 4) & 0xff);
        memcpy_s(new_der+4, der_len - (unsigned int) len, der_ptr, der_len - (unsigned int)len);
	/* if <= 256, but >= 128 need 3 byte Seq header */
    } else if ((der_len - len + sizeof(hex_chpw)) >= 128) {
        new_len += 3;
	new_der = malloc(new_len);
	if (!new_der) {
	    free(orig_ptr);
	    return (EST_ERR_MALLOC);
	}
        memzero_s(new_der, new_len);
        *(new_der + 1) = 0x81;
        *(new_der + 2) = new_len - 3;
        memcpy_s(new_der+3, der_len - ((rsize_t) len), der_ptr, der_len - ((rsize_t) len));
        /* else just need 2 byte header */
    } else {
        new_len += 2;
        new_der = malloc(new_len);
	if (!new_der) {
	    free(orig_ptr);
	    return (EST_ERR_MALLOC);
	}
        memzero_s(new_der, new_len);
        *(new_der + 1) = new_len - 2;
	if ((der_len - len) != 0) {
            memcpy_s(new_der+2, der_len - ((rsize_t) len), der_ptr, der_len - ((rsize_t) len));
	}
    }
    *new_der = 0x30;
    memcpy_s(new_der + (new_len - sizeof(hex_chpw)), sizeof(hex_chpw),
	     hex_chpw, sizeof(hex_chpw));

    csrattrs = malloc(new_len*2);
    if (!csrattrs) {
        free(orig_ptr);
        free(new_der);
	return (EST_ERR_MALLOC);
    }
    memzero_s(csrattrs, new_len*2);
    
    enc_len = est_base64_encode((const char *)new_der, new_len, (char *)csrattrs, new_len*2);
    if (enc_len <= 0) {
        EST_LOG_ERR("Invalid base64 encoded data");
        free(orig_ptr);
        free(new_der);
        free(csrattrs);
        return (EST_ERR_BAD_BASE64);
    }

    *new_csr = csrattrs;
    *pop_len = (int) strnlen_s(csrattrs, new_len*2);
    EST_LOG_INFO("CSR reconstituted attributes are(%d/%d): %s", b64_len, *pop_len, csrattrs);

    if (new_der) {
        free(new_der);
    }
    if (orig_ptr) {
        free(orig_ptr);
    }
    return (EST_ERR_NONE);
}
/*! @brief est_add_attributes_helper() Add a NID and its character string to
    an X509_REQ as an attribute.
 
    @param req an X509_REQ structure used for the CSR request
    @param nid NID to be added as an attribute
    @param string pointer to the NID string if needed
    @param chtype type of string used with this NID
 
    @return EST_ERROR

    This function is used to add a CSR attribute to a CSR request by the
    EST client.
 */
EST_ERROR est_add_attributes_helper (X509_REQ *req, int nid, void *string, int chtype)
{
    
    if (req == NULL) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    if (nid == 0) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    if (string == NULL) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /* Only MBSTRING_ASC used today, but callers could pass in other values */
    if (chtype == 0) {
        chtype = MBSTRING_ASC;
    }

    if(!X509_REQ_add1_attr_by_NID(req, nid, chtype,
				  (unsigned char *)string, -1)) {
	EST_LOG_WARN("Error adding attribute");
	return (EST_ERR_X509_ATTR);
    }
    return (EST_ERR_NONE);
}
/*! @brief est_decode_attributes_helper() Decode a base64 encoded string
    into DER format(ASN.1 hex).
 
    @param csrattrs pointer to a base64 encoded string
    @param csrattrs_len base64 string length
    @param der_ptr pointer to a pointer to store the DER encoded string
    @param der_len pointer to store the DER string length
 
    @return EST_ERROR

    This function is used decode a base64 encoded CSR attributes string
    into DER format.  It also performs range checking on the input parameters.
 */
EST_ERROR est_decode_attributes_helper (char *csrattrs, int csrattrs_len, 
					unsigned char **der, int *len)
{
    unsigned char *der_ptr;
    int der_len;

    /* just return if no data */
    if ((csrattrs == NULL) || (csrattrs_len == 0)) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    if ((der == NULL) || (len == NULL)) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /* 
     * check smallest possible base64 case here for now 
     * and sanity test will check min/max value for ASN.1 data
     */
    if (csrattrs_len < MIN_CSRATTRS) {
        return (EST_ERR_INVALID_PARAMETERS);
    }


    der_ptr = malloc(csrattrs_len*2);
    if (!der_ptr) {
        return (EST_ERR_MALLOC);
    }

    der_len = est_base64_decode(csrattrs, (char *)der_ptr, csrattrs_len*2);
    if (der_len <= 0) {
        EST_LOG_WARN("Invalid base64 encoded data");
	free(der_ptr);
	return (EST_ERR_BAD_BASE64);
    }

    *der = der_ptr;
    *len = der_len;

    return (EST_ERR_NONE);

}
/*! @brief est_get_attributes_helper() get attributes NID from a DER
    encoded string.
 
    @param der_ptr pointer to a pointer of DER encoded string
    @param der_len pointer to the DER encoded string length
    @param new_nid pointer to storage for NID, if found
 
    @return EST_ERROR

    This function is used to find the next NID in a DER encoded string.
    If no NID is found before reaching the end of the string, then
    new_nid returned as zero and EST_ERR_BAD_ASN1_HEX.
 */
EST_ERROR est_get_attributes_helper (unsigned char **der_ptr, int *der_len, int *new_nid)
{
    int tag, xclass, j, nid = 0;
    int out_len_save;
    long out_len;
    long len;
    const unsigned char *string;
    const unsigned char *ostring;
    ASN1_OBJECT *a_object = NULL;


    if (der_ptr == NULL) {
        return (EST_ERR_INVALID_PARAMETERS);
    }
    string = *der_ptr;
    ostring = *der_ptr;

    if (der_len == NULL) {
        return (EST_ERR_INVALID_PARAMETERS);
    }
    out_len = *der_len;
    out_len_save = *der_len;

    if (new_nid == NULL) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    while (out_len > 0) {
	j = ASN1_get_object(&string, &len, &tag, &xclass, out_len);

	if (j & 0x80) {
	    return (EST_ERR_BAD_ASN1_HEX);
        }
	switch (tag) {

	case V_ASN1_OBJECT:
            a_object = c2i_ASN1_OBJECT(NULL, &string, len);
	    if (a_object != NULL) {
	        nid = OBJ_obj2nid(a_object);
		EST_LOG_INFO("NID=%d", nid);
		*new_nid = nid;
		*der_len = (out_len_save - (int) (string - ostring));
		*der_ptr = (unsigned char *)string;
	        ASN1_OBJECT_free(a_object);
		return (EST_ERR_NONE);
            }
	    break;
	default:
	    /* have to adjust string pointer here */
	    string += len;
	    break;
	case V_ASN1_SET:
	case V_ASN1_SEQUENCE:
	    break;
	}
	out_len = (out_len_save - (string - ostring));	
    }

    return (EST_ERR_NONE);
}
/* 
 * cleanse_auth_credentials - Walk through the auth_credentials structure and
 * overwrite and free each value.
 */
void cleanse_auth_credentials(EST_HTTP_AUTH_HDR *auth_cred)
{

    if (auth_cred == NULL) {
        return;
    }
    
    if (auth_cred->user) {
        OPENSSL_cleanse(auth_cred->user, strnlen_s(auth_cred->user, MAX_UIDPWD));
        free(auth_cred->user);
        auth_cred->user = NULL;
    }
    
    if (auth_cred->pwd) {
        OPENSSL_cleanse(auth_cred->pwd, strnlen_s(auth_cred->pwd, MAX_UIDPWD));
        free(auth_cred->pwd);
        auth_cred->pwd = NULL;
    }
    
    if (auth_cred->uri) {
        OPENSSL_cleanse(auth_cred->uri, strnlen_s(auth_cred->uri, EST_URI_MAX_LEN));
        free(auth_cred->uri);
        auth_cred->uri = NULL;
    }
    
    if (auth_cred->cnonce) {
        OPENSSL_cleanse(auth_cred->cnonce, strnlen_s(auth_cred->cnonce, MAX_NONCE));
        free(auth_cred->cnonce);
        auth_cred->cnonce = NULL;
    }
    
    if (auth_cred->qop) {
        OPENSSL_cleanse(auth_cred->qop, strnlen_s(auth_cred->qop, MAX_QOP));
        free(auth_cred->qop);
        auth_cred->qop = NULL;
    }
    
    if (auth_cred->nc) {
        OPENSSL_cleanse(auth_cred->nc, strnlen_s(auth_cred->nc, MAX_NC));
        free(auth_cred->nc);
        auth_cred->nc = NULL;
    }
    
    if (auth_cred->nonce) {
        OPENSSL_cleanse(auth_cred->nonce, strnlen_s(auth_cred->nonce,
                                                    MAX_NONCE));
        free(auth_cred->nonce);
        auth_cred->nonce = NULL;
    }
    
    if (auth_cred->response) {
        OPENSSL_cleanse(auth_cred->response, strnlen_s(auth_cred->response,
                                                       MAX_RESPONSE));
        free(auth_cred->response);
        auth_cred->response = NULL;
    }
    
    if (auth_cred->auth_token) {
        OPENSSL_cleanse(auth_cred->auth_token, strnlen_s(auth_cred->auth_token,
                                                         MAX_AUTH_TOKEN_LEN));
        free(auth_cred->auth_token);
        auth_cred->auth_token = NULL;
    }        
    
    return;
}
/*
 * Given an input string, look for the four valid operations
 */
EST_OPERATION est_parse_operation (char *op_path) 
{
    EST_OPERATION operation;

    if (!est_strcasecmp_s(op_path, EST_GET_CACERTS)) {
        operation = EST_OP_CACERTS;
    } else if (!est_strcasecmp_s(op_path, EST_GET_CSRATTRS)) {
        operation = EST_OP_CSRATTRS;
    } else if (!est_strcasecmp_s(op_path, EST_SIMPLE_ENROLL)) {
        operation = EST_OP_SIMPLE_ENROLL;
    } else if (!est_strcasecmp_s(op_path, EST_SIMPLE_REENROLL)) {
        operation = EST_OP_SIMPLE_REENROLL;
    } else {
        operation = EST_OP_MAX;
    }
    
    return (operation);
}
/*
 * Given an input string, look for the four valid operations
 */
EST_ERROR est_parse_uri (char *uri, EST_OPERATION *operation,
                         char **path_seg) 
{
    /* char *path_seg_end; */
    /* int   path_seg_len = 0; */
    UriParserStateA state;
    UriUriA parsed_uri;
    EST_ERROR rv = EST_ERR_NONE;
    int uriparse_rc;
    errno_t safec_rc;    
    int diff;

    *path_seg = NULL;
    state.uri = &parsed_uri;
    uriparse_rc = uriParseUriA(&state, uri);
    if (uriparse_rc != URI_SUCCESS) {
        uriFreeUriMembersA(state.uri);
        return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    }

    if (parsed_uri.pathHead) {
        
        /*
         * validate the URI
         * - parse the path-prefix (/.well-known/est)
         * - look to see if there is a path segment extension
         * - determine which operation it is
         */        
        UriPathSegmentA *cur_seg = parsed_uri.pathHead;
        char *cur_seg_str = (char *)cur_seg->text.first;
        int cur_seg_len = 0;
        char *segment = NULL;
        
        safec_rc = memcmp_s(cur_seg_str, WELL_KNOWN_SEGMENT_LEN,
                            ".well-known", WELL_KNOWN_SEGMENT_LEN, &diff);
        if (diff || safec_rc != EOK) {
            EST_LOG_ERR("URI path does not start with %s, safec_rc = 0x%xO\n",
                        WELL_KNOWN_SEGMENT, safec_rc);
            uriFreeUriMembersA(state.uri);
            return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
        }
        
        cur_seg = cur_seg->next;
        cur_seg_str = (char *)cur_seg->text.first;
        safec_rc = memcmp_s(cur_seg_str, EST_SEGMENT_LEN,
                            "est", EST_SEGMENT_LEN, &diff);
        if (diff || safec_rc != EOK) {
            EST_LOG_ERR("URI does not contain %s segment 0x%xO\n",
                        EST_SEGMENT, safec_rc);
            uriFreeUriMembersA(state.uri);
            return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
        }
        
        /*
         * This next segment is either a segment extension
         * or it's the operation 
         */
        cur_seg = cur_seg->next;
        cur_seg_str = (char *)cur_seg->text.first;

        /*
         * If there's another segment after this one then use it
         * to find the end, else walk this one for the length
         */
        if (cur_seg->text.afterLast) {
            cur_seg_len = ((char *)cur_seg->text.afterLast) - cur_seg_str;
        } else {
            cur_seg_len = strnlen_s(cur_seg_str, EST_MAX_PATH_SEGMENT_LEN+1);
        }
        if (cur_seg_len > EST_MAX_PATH_SEGMENT_LEN) {
            EST_LOG_ERR("path segment exceeds maximum of %d\n",
                        EST_MAX_PATH_SEGMENT_LEN);
            uriFreeUriMembersA(state.uri);
            return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
        }

        /*
         * See if the current segment needs to be put into its own
         * string
         */
        if ((cur_seg->text.afterLast != NULL) &&
            *(cur_seg->text.afterLast) != '\0') {
            segment = STRNDUP(cur_seg_str, cur_seg_len);
        } else {
            segment = STRNDUP(cur_seg_str, EST_MAX_PATH_SEGMENT_LEN);
        }
        
        /*
         * look to see if the operation path comes next:
         * cacerts, csrattrs, simpleenroll, simplereenroll
         */
        *operation = est_parse_operation(segment);
        if (*operation == EST_OP_MAX) {
            
            /*
             * It wasn't one of the 4 known operations so
             * it must be a path segment.  parse it out.
             *
             * Find the end of the path segment,
             * determine the length,
             * save it away
             */
            /* path_seg_end = (char *)cur_seg->text.afterLast; */
            
            /* if (path_seg_end != NULL) { */
            /*     path_seg_len = path_seg_end - cur_seg_str; */
            /* } */
            
            *path_seg = malloc(cur_seg_len+1);
            if (*path_seg == NULL) {
                free(segment);
                uriFreeUriMembersA(state.uri);
                return (EST_ERR_MALLOC);
            }
            
            safec_rc = memcpy_s(*path_seg, cur_seg_len+1,
                                segment, cur_seg_len);
            if (safec_rc != EOK) {
                EST_LOG_ERR("URI path seg could not copied into the context");
                free(segment);
                free(*path_seg);
                *path_seg = NULL;
                uriFreeUriMembersA(state.uri);                
                return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
            }
            *((*path_seg)+cur_seg_len) = '\0';
            
            /*
             * now that we have the path segment parsed, try
             * for the operation again.  jump over the path segment
             * and the next '/'
             */
            cur_seg_str = cur_seg_str + cur_seg_len + 1;
            *operation = est_parse_operation(cur_seg_str);
            
            if (*operation == EST_OP_MAX) {
                /*
                 * Operation code was suppose to be next but is not
                 */
                free(segment);
                free(*path_seg);
                *path_seg = NULL;
                uriFreeUriMembersA(state.uri);                
                return (EST_ERR_HTTP_BAD_REQ);
            }
        } else {
            /*
             * It was one of the operations, make sure it's the end
             */
            if ((cur_seg->text.afterLast != NULL) &&
                *(cur_seg->text.afterLast) != '\0') {
                EST_LOG_ERR("Invalid path segment: contains an operation value");
                free(segment);
                free(*path_seg);
                *path_seg = NULL;
                *operation = EST_OP_MAX;
                uriFreeUriMembersA(state.uri);
                return (EST_ERR_HTTP_INVALID_PATH_SEGMENT);
            }
        }
        free(segment);
        uriFreeUriMembersA(state.uri);        
    }    
    return (rv);
}
/*
 * Given an input string, look for the four valid operations
 */
EST_ERROR est_parse_uri (char *uri, EST_OPERATION *operation,
                         char **path_seg) 
{
    EST_ERROR rc = EST_ERR_NONE;
    *path_seg = NULL;
    /*
     * Assume that the uri is pointing to
     *   /.well-known/est/<operation>
     */
    if (strncmp(uri, EST_CACERTS_URI, EST_URI_MAX_LEN) == 0) {
        *operation = EST_OP_CACERTS;
    } else if (strncmp(uri, EST_SIMPLE_ENROLL_URI, EST_URI_MAX_LEN) == 0) {
        *operation = EST_OP_SIMPLE_ENROLL;
    } else if (strncmp(uri, EST_RE_ENROLL_URI, EST_URI_MAX_LEN) == 0) {
        *operation = EST_OP_SIMPLE_REENROLL;
    } else if (strncmp(uri, EST_CSR_ATTRS_URI, EST_URI_MAX_LEN) == 0) {
        *operation = EST_OP_CSRATTRS;
    } else {
        *operation = EST_OP_MAX;
        rc = EST_ERR_HTTP_INVALID_PATH_SEGMENT;
        
    }
    
    return rc;
}
/*
 * Store the path segment into the context.
 */
EST_ERROR est_store_path_segment (EST_CTX *ctx, char *path_segment,
                                  int path_segment_len)
{
    /*
     * reset what might already be cached
     */
    if (ctx->uri_path_segment) {
        free(ctx->uri_path_segment);
        ctx->uri_path_segment = NULL;
    }
    
    ctx->uri_path_segment = malloc(strnlen_s(path_segment, path_segment_len)+1);
    if (ctx->uri_path_segment == NULL) {
        return EST_ERR_MALLOC;
    }
    
    if (EOK != strncpy_s(ctx->uri_path_segment, path_segment_len+1,
                         path_segment, path_segment_len)) {
        return EST_ERR_HTTP_INVALID_PATH_SEGMENT;
    }
    ctx->uri_path_segment[path_segment_len] = '\0';

    return EST_ERR_NONE;   
}
/*
 * Store the path segment into the context.
 */
int est_strcasecmp_s (char *s1, char *s2)
{
    errno_t safec_rc;
    int diff;
    
    safec_rc = strcasecmp_s(s1, strnlen_s(s1, RSIZE_MAX_STR), s2, &diff);

    if (safec_rc != EOK) {
    	/*
    	 * Log that we encountered a SafeC error
     	 */
     	EST_LOG_INFO("strcasecmp_s error 0x%xO\n", safec_rc);
    } 

    return diff;
}

/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
void est_send_http_error(EST_CTX *ctx, void *http_ctx, int fail_code);
/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
int est_enroll_auth(EST_CTX *ctx, void *http_ctx, SSL *ssl, char *path_seg,
                    int reenroll);
/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
int est_handle_cacerts (EST_CTX *ctx, unsigned char *ca_certs, int ca_certs_len,
                        void *http_ctx, char *path_seg);
/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
int est_tls_uid_auth(EST_CTX *ctx, SSL *ssl, X509_REQ *req);
/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
X509_REQ * est_server_parse_csr(unsigned char *pkcs10, int pkcs10_len);
/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
int est_server_check_csr(X509_REQ *req);
/*
 * These prototypes are private to est_server.c and are
 * not part of the public API.
 */
EST_ERROR est_server_send_http_retry_after(EST_CTX *ctx, void *http_ctx, int delay);

int ossl_verify_cb(int ok, X509_STORE_CTX *ctx);
LIBEST_TEST_API void ossl_dump_ssl_errors(void);
EST_ERROR ossl_init_cert_store (X509_STORE *store,
                                unsigned char *raw1, int size1);

static pthread_t pthread_self (void)
{
    return GetCurrentThreadId();
}
const void* mg_get_conn_ssl (struct mg_connection *conn)
{
    return conn ? conn->ssl : NULL;
}
static void sockaddr_to_string (char *buf, size_t len,
                                const union usa *usa)
{
    buf[0] = '\0';
#if defined(USE_IPV6)
    inet_ntop(usa->sa.sa_family, usa->sa.sa_family == AF_INET ?
              (void*)&usa->sin.sin_addr :
              (void*)&usa->sin6.sin6_addr, buf, (socklen_t) len);
#elif defined(_WIN32)
    // Only Windoze Vista (and newer) have inet_ntop()
    strncpy_s(buf, MAX_SRC_ADDR, inet_ntoa(usa->sin.sin_addr), len);
#else
    inet_ntop(usa->sa.sa_family, (void*)&usa->sin.sin_addr, buf, len);
#endif
}
// Print error message to the opened error log stream.
static void cry (struct mg_connection *conn, const char *fmt, ...)
{
    char buf[MG_BUF_LEN], src_addr[MAX_SRC_ADDR];
    va_list ap;
    time_t timestamp;

    va_start(ap, fmt);
    (void)vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);

    // Do not lock when getting the callback value, here and below.
    // I suppose this is fine, since function cannot disappear in the
    // same way string option can.
    conn->request_info.ev_data = buf;
    timestamp = time(NULL);

    sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);
    EST_LOG_ERR("[%010lu] [error] [client %s] ", (unsigned long)timestamp, src_addr);

    if (conn->request_info.request_method != NULL) {
        EST_LOG_ERR("%s %s: ", conn->request_info.request_method, conn->request_info.uri);
    }
    EST_LOG_ERR("%s", buf);
    conn->request_info.ev_data = NULL;
}
// is not applicable at the moment of logging.
static struct mg_connection *fc (struct mg_context *ctx)
{
    static struct mg_connection fake_connection;

    fake_connection.ctx = ctx;
    return &fake_connection;
}
// is not applicable at the moment of logging.
const char *mg_version (void)
{
    return MONGOOSE_VERSION;
}
// is not applicable at the moment of logging.
struct mg_request_info *mg_get_request_info (struct mg_connection *conn)
{
    return &conn->request_info;
}
// is not applicable at the moment of logging.
void mg_strlcpy (register char *dst, register const char *src, size_t n)
{
    for (; *src != '\0' && n > 1; n--) {
        *dst++ = *src++;
    }
    *dst = '\0';
}
// is not applicable at the moment of logging.
char * mg_strndup(const char *ptr, size_t len) {

	char *p;

	if ((p = (char *)malloc(len + 1)) != NULL) {
		mg_strlcpy(p, ptr, len + 1);
	}

	return p;
}
// is not applicable at the moment of logging.
static int lowercase (const char *s)
{
    return tolower(*(const unsigned char*)s);
}
// is not applicable at the moment of logging.
static int mg_strncasecmp (const char *s1, const char *s2, size_t len)
{
    int diff = 0;

    if (len > 0) {
        do {
            diff = lowercase(s1++) - lowercase(s2++);
        } while (diff == 0 && s1[-1] != '\0' && --len > 0);
    }

    return diff;
}
// is not applicable at the moment of logging.
static int mg_strcasecmp (const char *s1, const char *s2)
{
    int diff;

    do {
        diff = lowercase(s1++) - lowercase(s2++);
    } while (diff == 0 && s1[-1] != '\0');

    return diff;
}
// in his audit report.
static int mg_vsnprintf (struct mg_connection *conn, char *buf, size_t buflen,
                         const char *fmt, va_list ap)
{
    int n;

    if (buflen == 0) {
        return 0;
    }

    n = vsnprintf(buf, buflen, fmt, ap);

    if (n < 0) {
        cry(conn, "vsnprintf error");
        n = 0;
    } else if (n >= (int)buflen) {
        cry(conn, "truncating vsnprintf buffer: [%.*s]",
            n > 200 ? 200 : n, buf);
        n = (int)buflen - 1;
    }
    buf[n] = '\0';

    return n;
}
//PRINTF_ARGS(4, 5);
static int mg_snprintf (struct mg_connection *conn, char *buf, size_t buflen,
                        const char *fmt, ...)
{
    va_list ap;
    int n;

    va_start(ap, fmt);
    n = mg_vsnprintf(conn, buf, buflen, fmt, ap);
    va_end(ap);

    return n;
}
//PRINTF_ARGS(4, 5);
static size_t est_strcspn(const char * str1,const char * str2){

    rsize_t count;
    errno_t safec_rc; 

    if ((str1 != NULL) && (str1[0] == '\0')) {
        return 0; 
    }

    safec_rc = strcspn_s(str1, strnlen_s(str1, RSIZE_MAX_STR),
            str2, RSIZE_MAX_STR, &count);
    if (safec_rc != EOK) {
        EST_LOG_INFO("strcspn_s error 0x%xO\n", safec_rc);
        return 0;
    }

    return count; 


}
//PRINTF_ARGS(4, 5);
static size_t est_strspn(const char * str1,const char  * str2) {

    rsize_t count;
    errno_t safec_rc; 

    if ((str1 != NULL) && (str1[0] == '\0')) {
        return 0; 
    }

    safec_rc = strspn_s(str1, strnlen_s(str1, RSIZE_MAX_STR), 
            str2, RSIZE_MAX_STR, &count);
    if (safec_rc != EOK) {
        EST_LOG_INFO("strspn_s error 0x%xO\n", safec_rc);
        return 0; 
    }

    return count; 

}
// Delimiters can be quoted with quotechar.
char *skip_quoted (char **buf, const char *delimiters,
                   const char *whitespace, char quotechar)
{
    char *p, *begin_word, *end_word, *end_whitespace;

    begin_word = *buf;

    end_word = begin_word + est_strcspn(begin_word,delimiters);

    // Check for quotechar
    if (end_word > begin_word) {
        p = end_word - 1;
        while (*p == quotechar) {
            // If there is anything beyond end_word, copy it
            if (*end_word == '\0') {
                *p = '\0';
                break;
            } else {

                rsize_t end_off = (rsize_t) est_strcspn(end_word + 1, delimiters);
                memmove_s(p, end_off + 1, end_word, end_off + 1);
                p += end_off; // p must correspond to end_word - 1
                end_word += end_off + 1;
            }
        }
        for (p++; p < end_word; p++) {
            *p = '\0';
        }
    }

    if (*end_word == '\0') {
        *buf = end_word;
    } else {

        end_whitespace = end_word + 1 + est_strspn(end_word + 1, whitespace);

        for (p = end_word; p < end_whitespace; p++) {
            *p = '\0';
        }

        *buf = end_whitespace;
    }

    return begin_word;
}
// and whitespace == delimiters
char *skip (char **buf, const char *delimiters)
{
    return skip_quoted(buf, delimiters, delimiters, 0);
}
// Return HTTP header value, or NULL if not found.
static const char *get_header (const struct mg_request_info *ri,
                               const char *name)
{
    int i;

    for (i = 0; i < ri->num_headers; i++) {
        if (!mg_strcasecmp(name, ri->http_headers[i].name)) {
            return ri->http_headers[i].value;
        }
    }

    return NULL;
}
// Return HTTP header value, or NULL if not found.
const char *mg_get_header (const struct mg_connection *conn, const char *name)
{
    return get_header(&conn->request_info, name);
}
// set up, for example if request parsing failed.
static int should_keep_alive (const struct mg_connection *conn)
{
    const char *http_version = conn->request_info.http_version;
    const char *header = mg_get_header(conn, "Connection");

    /*
     * Slight deviation from Mongoose behavior here.  We will close the
     * connection when sending a 202 Accepted response.  We will also
     * close the connection for any 4xx response, where Mongoose was only
     * closing for the 401 Unauthorized
     */
    if (conn->must_close ||
	conn->status_code == EST_HTTP_STAT_202 ||
        conn->status_code >= 400 ||
        !conn->ctx->enable_keepalives ||
        (header != NULL && mg_strcasecmp(header, "keep-alive") != 0) ||
        (header == NULL && http_version && strncmp(http_version, "1.1", 3))) {
        return 0;
    }
    return 1;
}
// set up, for example if request parsing failed.
static const char *suggest_connection_header (const struct mg_connection *conn)
{
    return should_keep_alive(conn) ? "keep-alive" : "close";
}
// set up, for example if request parsing failed.
void mg_send_http_error (struct mg_connection *conn, int status,
                         const char *reason, const char *fmt, ...)
{
    char buf[MG_BUF_LEN];
    va_list ap;
    int len;

    conn->status_code = status;
    conn->request_info.ev_data = (void*)(long)status;
    buf[0] = '\0';
    len = 0;

    // Errors 1xx, 204 and 304 MUST NOT send a body
    if (status > 199 && status != 204 && status != 304) {
        len = mg_snprintf(conn, buf, sizeof(buf), "Error %d: %s", status, reason);
        buf[len++] = '\n';

        va_start(ap, fmt);
        len += mg_vsnprintf(conn, buf + len, sizeof(buf) - len, fmt, ap);
        va_end(ap);
    }
    EST_LOG_INFO("[%s]", buf);

    mg_printf(conn, "HTTP/1.1 %d %s\r\n"
              "Content-Length: %d\r\n"
              "Connection: %s\r\n\r\n", status, reason, len,
              suggest_connection_header(conn));
    conn->num_bytes_sent += mg_printf(conn, "%s", buf);
}
// For Windows, change all slashes to backslashes in path names.
static void change_slashes_to_backslashes (char *path)
{
    int i;

    for (i = 0; path[i] != '\0'; i++) {
        if (path[i] == '/') {
            path[i] = '\\';
        }
        // i > 0 check is to preserve UNC paths, like \\server\file.txt
        if (path[i] == '\\' && i > 0) {
            while (path[i + 1] == '\\' || path[i + 1] == '/') {
                (void)memmove_s(path + i + 1, EST_URI_MAX_LEN,
                                path + i + 2, strnlen_s(path + i + 1, 
				                      EST_URI_MAX_LEN));
            }
        }
    }
}
// wbuf and wbuf_len is a target buffer and its length.
static void to_unicode (const char *path, wchar_t *wbuf, size_t wbuf_len)
{
    char buf[PATH_MAX], buf2[PATH_MAX], *p;

    mg_strlcpy(buf, path, sizeof(buf));
    change_slashes_to_backslashes(buf);

    // Point p to the end of the file name
    p = buf + strnlen_s(buf, EST_URI_MAX_LEN) - 1;

    // Convert to Unicode and back. If doubly-converted string does not
    // match the original, something is fishy, reject.
    memzero_s(wbuf, wbuf_len * sizeof(wchar_t));
    MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int)wbuf_len);
    WideCharToMultiByte(CP_UTF8, 0, wbuf, (int)wbuf_len, buf2, sizeof(buf2),
                        NULL, NULL);
    if (strcmp(buf, buf2) != 0) {
        wbuf[0] = L'\0';
    }
}
// This function returns non-0 if path ends with some garbage.
static int path_cannot_disclose_cgi (const char *path)
{
    static const char *allowed_last_characters = "_-";
    int last = path[strnlen_s(path, EST_URI_MAX_LEN) - 1];

    return isalnum(last) || strchr(allowed_last_characters, last) != NULL;
}
// This function returns non-0 if path ends with some garbage.
static HANDLE dlopen (const char *dll_name, int flags)
{
    wchar_t wbuf[PATH_MAX];

    flags = 0; // Unused
    to_unicode(dll_name, wbuf, ARRAY_SIZE(wbuf));
    return LoadLibraryW(wbuf);
}
// descriptor. Return number of bytes written.
static int64_t push (FILE *fp, SOCKET sock, SSL *ssl, const char *buf,
                     int64_t len)
{
    int64_t sent;
    int n, k;

    sent = 0;
    while (sent < len) {

        // How many bytes we send in this iteration
        k = len - sent > INT_MAX ? INT_MAX : (int)(len - sent);

        if (ssl != NULL) {
            n = SSL_write(ssl, buf + sent, k);
        } else if (fp != NULL) {
            n = (int)fwrite(buf + sent, 1, (size_t)k, fp);
            if (ferror(fp)) {
                n = -1;
            }
        } else {
            n = (int) send(sock, buf + sent, (size_t)k, MSG_NOSIGNAL);
        }

        if (n < 0) {
            break;
        }

        sent += n;
    }

    return sent;
}
// reading, must give up and close the connection and exit serving thread.
static int wait_until_socket_is_readable (struct mg_connection *conn)
{
    struct pollfd pfd;
    int result;
    int times_up = 0;
    EST_UINT total_wait_time = 0;
    EST_UINT read_timeout = conn->read_timeout * 1000;

    do {
        /* accumlate the total amount of time waited */
        total_wait_time += MSEC_POLL_WAIT_TIME;

        pfd.fd = conn->client.sock;
        pfd.events = POLLIN;
        pfd.revents = 0;

        errno = 0;
        result = POLL(&pfd, 1, MSEC_POLL_WAIT_TIME);
        if (result == 0 && conn->ssl != NULL) {
            result = SSL_pending(conn->ssl);
        }
        
        /*
         * check to see if it's time to give up.  If it is, set
         * things accordingly to close the session down
         */
        if ((total_wait_time > read_timeout) && result == 0) {
            times_up = 1;
            conn->must_close = 1;
            result = -1;
        }
        /*
         * Continue waiting,
         * - while there's nothing to read from the socket or
         *   the poll was interrupted by a signal AND
         * - the master process has not indicated to stop AND
         * - the waiting for read timeout has not occurred
         */                
    } while ((result == 0 || (result < 0 && ERRNO == EINTR)) &&
             conn->ctx->stop_flag == 0 &&
             !times_up);

    return conn->ctx->stop_flag || result < 0 ? 0 : 1;
}
// Return negative value on error, or number of bytes read on success.
static int pull (FILE *fp, struct mg_connection *conn, char *buf, int len)
{
    int nread;
    int err_cd;

    if (fp != NULL) {
        // Use read() instead of fread(), because if we're reading from the CGI
        // pipe, fread() may block until IO buffer is filled up. We cannot afford
        // to block and must pass all read bytes immediately to the client.
        nread = (int) read(fileno(fp), buf, (size_t)len);
    } else if (!conn->must_close && !wait_until_socket_is_readable(conn)) {
        nread = -1;
    } else if (conn->ssl != NULL) {
        nread = SSL_read(conn->ssl, buf, len);
	err_cd = SSL_get_error(conn->ssl ,nread);
	switch(err_cd) {
	case SSL_ERROR_NONE:
	    /* Nothing to do, it's a graceful shutdown */
	    break;
	case SSL_ERROR_WANT_READ:
	    /*
	     * More data may be coming, change nread to zero
	     * so Mongoose will attempt to read more data
	     * from the peer.  This would occur if the peer
	     * initiated an SSL renegotation.
	     */
	    nread = 0;
	    break;
	case SSL_ERROR_WANT_X509_LOOKUP:
	    EST_LOG_ERR("SSL_read error, wants lookup\n");
	    break;
	default:
	    /*
	     * For all other errors, simply log the error
	     * and make sure nread is -1 to indicate an
	     * error to the function above us.
	     */
	    EST_LOG_ERR("SSL_read error, code: %d\n", err_cd);
	    nread = -1;
	    break;
	}
    } else {
        nread = (int) recv(conn->client.sock, buf, (size_t)len, 0);
    }

    return conn->ctx->stop_flag ? -1 : nread;
}
// Return negative value on error, or number of bytes read on success.
int mg_read (struct mg_connection *conn, void *buf, size_t len)
{
    int n, buffered_len, nread;
    const char *body;
    rsize_t max_len;

    nread = 0;
    max_len = (rsize_t) len;
    if (conn->consumed_content < conn->content_len) {
        // Adjust number of bytes to read.
        int64_t to_read = conn->content_len - conn->consumed_content;
        if (to_read < (int64_t)len) {
            len = (size_t)to_read;
        }

        // Return buffered data
        body = conn->buf + conn->request_len + conn->consumed_content;
        buffered_len = (int) (&conn->buf[conn->data_len] - body);
        if (buffered_len > 0) {
            if (len < (size_t)buffered_len) {
                buffered_len = (int)len;
            }
            memcpy_s(buf, max_len, body, (rsize_t)buffered_len);
            len -= buffered_len;
            conn->consumed_content += buffered_len;
            nread += buffered_len;
            buf = (char*)buf + buffered_len;
        }

        // We have returned all buffered data. Read new data from the remote socket.
        while (len > 0) {
            n = pull(NULL, conn, (char*)buf, (int)len);
            if (n < 0) {
                nread = n; // Propagate the error
                break;
            } else if (n > 0) {
                buf = (char*)buf + n;
                conn->consumed_content += n;
                nread += n;
                len -= n;
            } else {
                /* n == 0. retry */
            }   
        }
    }
    return nread;
}
// Return negative value on error, or number of bytes read on success.
int mg_write (struct mg_connection *conn, const void *buf, size_t len)
{
    int64_t total;

    total = push(NULL, conn->client.sock, conn->ssl, (const char*)buf,
                 (int64_t)len);
    return (int)total;
}
// Return negative value on error, or number of bytes read on success.
int mg_printf (struct mg_connection *conn, const char *fmt, ...)
{
    char mem[MG_BUF_LEN], *buf = mem;
    int len;
    va_list ap;

    // Print in a local buffer first, hoping that it is large enough to
    // hold the whole message
    va_start(ap, fmt);
    len = vsnprintf(mem, sizeof(mem), fmt, ap);
    va_end(ap);

    if (len == 0) {
        // Do nothing. mg_printf(conn, "%s", "") was called.
    } else if (len < 0) {
        // vsnprintf() error, give up
        len = -1;
        cry(conn, "%s(%s, ...): vsnprintf() error", __func__, fmt);
    } else if (len > (int)sizeof(mem) && (buf = (char*)malloc(len + 1)) != NULL) {
        // Local buffer is not large enough, allocate big buffer on heap
        va_start(ap, fmt);
        vsnprintf(buf, len + 1, fmt, ap);
        va_end(ap);
        len = mg_write(conn, buf, (size_t)len);
        free(buf);
    } else if (len > (int)sizeof(mem)) {
        // Failed to allocate large enough buffer, give up
        cry(conn, "%s(%s, ...): Can't allocate %d bytes, not printing anything",
            __func__, fmt, len);
        len = -1;
    } else {
        // Copy to the local buffer succeeded
        len = mg_write(conn, buf, (size_t)len);
    }

    return len;
}
// http://ftp.ics.uci.edu/pub/ietf/html/rfc1866.txt
static int url_decode (const char *src, int src_len, char *dst,
                       int dst_len, int is_form_url_encoded)
{
    int i, j, a, b;

#define HEXTOI(x) (isdigit(x) ? x - '0' : x - 'W')

    for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {
        if (src[i] == '%' &&
            isxdigit(*(const unsigned char*)(src + i + 1)) &&
            isxdigit(*(const unsigned char*)(src + i + 2))) {
            a = tolower(*(const unsigned char*)(src + i + 1));
            b = tolower(*(const unsigned char*)(src + i + 2));
            dst[j] = (char)((HEXTOI(a) << 4) | HEXTOI(b));
            i += 2;
        } else if (is_form_url_encoded && src[i] == '+') {
            dst[j] = ' ';
        } else {
            dst[j] = src[i];
        }
    }

    dst[j] = '\0'; // Null-terminate the destination

    return i >= src_len ? j : -1;
}
//   >0  actual request length, including last \r\n\r\n
static int get_request_len (const char *buf, int buflen)
{
    const char *s, *e;
    int len = 0;

    for (s = buf, e = s + buflen - 1; len <= 0 && s < e; s++) {
        // Control characters are not allowed but >=128 is.
        if (!isprint(*(const unsigned char*)s) && *s != '\r' &&
            *s != '\n' && *(const unsigned char*)s < 128) {
            len = -1;
            break; // [i_a] abort scan as soon as one malformed character is found; don't let subsequent \r\n\r\n win us over anyhow
        } else if (s[0] == '\n' && s[1] == '\n') {
            len = (int)(s - buf) + 2;
        } else if (s[0] == '\n' && &s[1] < e &&
                   s[1] == '\r' && s[2] == '\n') {
            len = (int)(s - buf) + 3;
        }
    }

    return len;
}
// excessive '/' and '\' characters
static void remove_double_dots_and_double_slashes (char *s)
{
    char *p = s;

    while (*s != '\0') {
        *p++ = *s++;
        if (s[-1] == '/' || s[-1] == '\\') {
            // Skip all following slashes, backslashes and double-dots
            while (s[0] != '\0') {
                if (s[0] == '/' || s[0] == '\\') {
                    s++;
                } else if (s[0] == '.' && s[1] == '.') {
                    s += 2;
                } else {
                    break;
                }
            }
        }
    }
    *p = '\0';
}
/*
 * Performs parsing of HTTP Authentication header from
 * the client when Basic authentication is used.
 */
static void mg_parse_auth_hdr_basic (struct mg_connection *conn, 
				     const char *auth_header,
	                             EST_HTTP_AUTH_HDR *ah)
{
    char *value, *s;
    char *save_ptr;
    char both[MAX_UIDPWD*2+2]; /* will contain both UID and PWD */
    rsize_t len;
    char *sep = ":";
    int colon_found;
    char *possible_pw;
    
    s = (char *) auth_header + 6;

    // Gobble initial spaces
    while (isspace(*(unsigned char*)s)) {
	s++;
    }
    value = s;

    len = est_base64_decode(value, both, (MAX_UIDPWD * 2 + 2));
    if (len <= 0) {
	EST_LOG_WARN("Base64 decode of HTTP auth header failed, HTTP auth will fail");
	return;
    }

    /*
     * Make sure there's a ':' in the string
     */
    colon_found = strstr_s(both, len, ":", 1, &possible_pw);
    if (colon_found != EOK) {
	EST_LOG_WARN("Invalid format of Basic HTTP credentials, missing :");
        memzero_s(both, (MAX_UIDPWD*2+2));
	return;
    }

    /*
     * did it start with a colon, meaning no userid?
     */
    if (both[0] == ':') {
        if (len > 1) {
            /* just a password */
            possible_pw++;
            ah->pwd = STRNDUP(possible_pw, MAX_UIDPWD);
            EST_LOG_INFO("HTTP Authentication header contains only password");
        } else {
            /* We got neither userid nor password */
            EST_LOG_INFO("HTTP Authentication header contains no userid or password");            
            memzero_s(both, (MAX_UIDPWD*2+2));
            return;
        }
    } else {
        /* Started with a userid, 
         * Parse the username and password, which are separated by a ":"
         */
        value = strtok_s(both, &len, sep, &save_ptr);
        if (value) {
            ah->user = STRNDUP(value, MAX_UIDPWD);
            ah->pwd = STRNDUP(save_ptr, MAX_UIDPWD);
        }
    }
    ah->mode = AUTH_BASIC;
    
    memzero_s(both, (MAX_UIDPWD*2+2));
}
/*
 * Performs parsing of HTTP Authentication header from
 * the client when Digest authentication is used.
 */
static void mg_parse_auth_hdr_digest (struct mg_connection *conn, 
				      const char *auth_header,
	                              EST_HTTP_AUTH_HDR *ah)
{
    char *name, *value, *s;
    char buf[MAX_AUTH_HDR_LEN];
    int i;

    ah->mode = AUTH_DIGEST;

    // Make modifiable copy of the auth header
    strncpy_s(buf, MAX_AUTH_HDR_LEN, auth_header + 7, MAX_AUTH_HDR_LEN);
    s = buf;

    // Parse authorization header
    while (1) {
        // Gobble initial spaces
        while (isspace(*(unsigned char*)s)) {
	    s++;
	}
	name = skip_quoted(&s, "=", " ", 0);
	// Value is either quote-delimited, or ends at first comma or space.
	if (s[0] == '\"') {
	    s++;
	    value = skip_quoted(&s, "\"", " ", '\\');
	    if (s[0] == ',') {
		s++;
	    }
	} else {
	    value = skip_quoted(&s, ", ", " ", 0); // IE uses commas, FF uses spaces
	}
	if (*name == '\0') {
	    break;
	}

        memcmp_s(name, 8, "username", 8, &i);
        if (!i) {
	    ah->user = STRNDUP(value, MAX_UIDPWD);
	    continue;
	} 

        memcmp_s(name, 6, "cnonce", 6, &i);
	if (!i) {
            ah->cnonce = STRNDUP(value, MAX_NONCE);
	    continue;
	} 

	memcmp_s(name, 8, "response", 8, &i);
	if (!i) {
            ah->response = STRNDUP(value, MAX_RESPONSE);
	    continue;
        } 

	memcmp_s(name, 3, "uri", 3, &i);
	if (!i) {
	    ah->uri = STRNDUP(value, MAX_REALM);
	    continue;
	} 

	memcmp_s(name, 3, "qop", 3, &i);
	if (!i) {
            ah->qop = STRNDUP(value, MAX_QOP);
	    continue;
	} 

	memcmp_s(name, 2, "nc", 2, &i);
	if (!i) {
	    ah->nc = STRNDUP(value, MAX_NC);
	    continue;
        } 

	memcmp_s(name, 5, "nonce", 5, &i);
	if (!i) {
	    ah->nonce = STRNDUP(value, MAX_NONCE);
	}
    }
}
/*
 * Performs parsing of HTTP Authentication header from
 * the client when Token(bearer) authentication is used.
 */
static void mg_parse_auth_hdr_token (struct mg_connection *conn, 
				     const char *auth_header,
	                             EST_HTTP_AUTH_HDR *ah)
{
    char *value, *s;
    char value_decoded[MAX_AUTH_TOKEN_LEN*2];
    int len;
    
    s = (char *) auth_header + (strlen(EST_BEARER_TOKEN_STR)-1);

    // Gobble initial spaces
    while (isspace(*(unsigned char*)s)) {
	s++;
    }

    value = s;
    memzero_s(value_decoded, MAX_AUTH_TOKEN_LEN*2);
    len = est_base64_decode(value, value_decoded, (MAX_AUTH_TOKEN_LEN*2));
    if (len <= 0) {
	EST_LOG_WARN("Base64 decode of HTTP auth credentials failed, HTTP auth will fail");
	return;
    }

    if (*s != '\0') {
        /*Copy the token into the auth header structure. */
        ah->auth_token = STRNDUP(value_decoded, MAX_AUTH_TOKEN_LEN);
        ah->mode = AUTH_TOKEN;
        if (ah->auth_token == NULL) {
            EST_LOG_ERR("Failed to obtain memory for authentication token buffer");
        }
    } else {
	EST_LOG_ERR("Authentication header from client contained no Token");
    }   
}
/*
 * This function parses the HTTP Authentication header
 * from the client.  It will fill in the fields on the
 * EST_HTTP_AUTH_HDR struct, which are used later for
 * verifying the user's credentials using either HTTP
 * Basic or HTTP Digest authentication. The ah parameter
 * should already be allocated when calling this function.
 *
 * Return either good, bad, or missing 
 */
EST_HTTP_AUTH_HDR_RESULT mg_parse_auth_header (struct mg_connection *conn, 
                                               EST_HTTP_AUTH_HDR *ah)
{
    const char *auth_header;

    /*
     * Get the Auth header from the HTTP client 
     */
    if ((auth_header = mg_get_header(conn, "Authorization")) == NULL) {
	return EST_AUTH_HDR_MISSING;
    }

    if (mg_strncasecmp(auth_header, "Digest ", 7) == 0) {
	/* Make sure server is configured for digest auth */
	if (conn->ctx->est_ctx->auth_mode != AUTH_DIGEST) {
	    return EST_AUTH_HDR_BAD;
	}
	mg_parse_auth_hdr_digest(conn, auth_header, ah); 
    } else if (mg_strncasecmp(auth_header, "Basic ", 6) == 0) {
	/* Make sure server is configured for basic auth */
	if (conn->ctx->est_ctx->auth_mode != AUTH_BASIC) {
	    return EST_AUTH_HDR_BAD;
	}
	mg_parse_auth_hdr_basic(conn, auth_header, ah);
    } else if (mg_strncasecmp(auth_header, EST_BEARER_TOKEN_STR,
                              strlen(EST_BEARER_TOKEN_STR)) == 0) {
	/* Make sure server is configured for bearer(token) auth */
	if (conn->ctx->est_ctx->auth_mode != AUTH_TOKEN) {
	    return EST_AUTH_HDR_BAD;
	}
	mg_parse_auth_hdr_token(conn, auth_header, ah);
    } else {
	/* Only Basic, Digest and Bearer Token authentication are supported */
	ah->mode = AUTH_FAIL;
        return EST_AUTH_HDR_BAD;
    }

    /* 
     * If we're doing digest auth, make sure all the values
     * were parsed
     */
    if (ah->mode == AUTH_DIGEST && (!ah->uri ||
		                    !ah->nonce ||
				    !ah->nc ||
				    !ah->cnonce)) {
	EST_LOG_ERR("Parsing of HTTP auth header failed");
	return EST_AUTH_HDR_BAD;
    }

    /* If we were not able to parse a user ID and we're not
     * in token auth mode, then make sure we fail the authentication.
     */
    if (ah->user == NULL && ah->mode != AUTH_TOKEN) {
        return EST_AUTH_HDR_BAD;
    }

    if (ah->mode != AUTH_TOKEN) {   
        /*
         * Save the user ID on the connection context.
         * We will want to pass this to the CA later.
         */
        strncpy_s(conn->user_id, MG_UID_MAX, ah->user, MG_UID_MAX);
    }
    
    return EST_AUTH_HDR_GOOD;
}
/*
 * This function parses the HTTP Authentication header
 * from the client.  It will fill in the fields on the
 * EST_HTTP_AUTH_HDR struct, which are used later for
 * verifying the user's credentials using either HTTP
 * Basic or HTTP Digest authentication. The ah parameter
 * should already be allocated when calling this function.
 *
 * Return either good, bad, or missing 
 */
void mg_send_authorization_request (struct mg_connection *conn)
{
    conn->status_code = 401;
    switch (conn->ctx->est_ctx->auth_mode) {
    case AUTH_BASIC:
	mg_printf(conn,
              "%s\r\n"
              "%s: 0\r\n"
              "%s: Basic realm=\"%s\"\r\n\r\n",
	      EST_HTTP_HDR_401,
	      EST_HTTP_HDR_CL,
	      EST_HTTP_HDR_AUTH,
              conn->ctx->est_ctx->realm);
	break;
    case AUTH_DIGEST:
	mg_printf(conn,
              "%s\r\n"
              "%s: 0\r\n"
              "%s: Digest qop=\"auth\", "
              "realm=\"%s\", nonce=\"%lu\"\r\n\r\n",
	      EST_HTTP_HDR_401,
	      EST_HTTP_HDR_CL,
	      EST_HTTP_HDR_AUTH,
              conn->ctx->est_ctx->realm,
              (unsigned long)time(NULL));
	break;
    case AUTH_TOKEN:
	mg_printf(conn,
              "%s\r\n"
              "%s: 0\r\n"
              "%s: Bearer realm=\"%s\"\r\n\r\n",
	      EST_HTTP_HDR_401,
	      EST_HTTP_HDR_CL,
	      EST_HTTP_HDR_AUTH,
              conn->ctx->est_ctx->realm);
	break;
    case AUTH_FAIL:
    case AUTH_NONE:
    default:
	/* These modes are not valid at this point
	 * nothing to do here. */
	break;
    }
}
// where parsing stopped.
static void parse_http_headers (char **buf, struct mg_request_info *ri)
{
    int i;

    for (i = 0; i < (int)ARRAY_SIZE(ri->http_headers); i++) {
        ri->http_headers[i].name = skip_quoted(buf, ":", " ", 0);
        ri->http_headers[i].value = skip(buf, "\r\n");
        if (ri->http_headers[i].name[0] == '\0') {
            break;
        }
        ri->num_headers = i + 1;
    }
}
// where parsing stopped.
static int is_valid_http_method (const char *method)
{
    /* EST only allows GET & POST */
    return !strncmp(method, "GET", 3) || !strncmp(method, "POST", 4);
}
// HTTP request components, header names and header values.
static int parse_http_message (char *buf, int len, struct mg_request_info *ri)
{
    int request_length = get_request_len(buf, len);

    if (request_length > 0) {
        // Reset attributes. DO NOT TOUCH is_ssl, remote_ip, remote_port
        ri->request_method = ri->uri = ri->http_version = NULL;
        ri->num_headers = 0;

        buf[request_length - 1] = '\0';

        // RFC says that all initial whitespaces should be ingored
        while (*buf != '\0' && isspace(*(unsigned char*)buf)) {
            buf++;
        }
        ri->request_method = skip(&buf, " ");
        ri->uri = skip(&buf, " ");
        ri->http_version = skip(&buf, "\r\n");
        parse_http_headers(&buf, ri);
    }
    EST_LOG_INFO("request_len=%d", request_length);
    EST_LOG_INFO("request uri=%s", ri->uri);
    return request_length;
}
// HTTP request components, header names and header values.
static int parse_http_request (char *buf, int len, struct mg_request_info *ri)
{
    int result = parse_http_message(buf, len, ri);

    if (result > 0 &&
        is_valid_http_method(ri->request_method) &&
        !strncmp(ri->http_version, "HTTP/", 5)) {
        ri->http_version += 5; // Skip "HTTP/"
    } else {
        result = -1;
    }
    return result;
}
// Upon every read operation, increase nread by the number of bytes read.
static int read_request (FILE *fp, struct mg_connection *conn,
                         char *buf, int bufsiz, int *nread)
{
    int request_len, n = 1;

    request_len = get_request_len(buf, *nread);
    while (*nread < bufsiz && request_len == 0 && n >= 0) {
        n = pull(fp, conn, buf + *nread, bufsiz - *nread);
        if (n > 0) {
            *nread += n;
            request_len = get_request_len(buf, *nread);
        }
    }

    if (n < 0) {
        // recv() error -> propagate error; do not process a b0rked-with-very-high-probability request
        return -1;
    }
    return request_len;
}
/*
 * This function is called by the Mongoose code when an
 * incoming HTTP request is processed.
 * Returns 0 on success, non-zero if the request wasn't
 * handled.
 */
static int est_mg_handler (struct mg_connection *conn)
{
    const struct mg_request_info *request_info = mg_get_request_info(conn);
    EST_CTX *ectx = conn->ctx->est_ctx;
    char *body;
    int cl;
    int est_rv = EST_ERR_NONE;
    const char *cl_hdr; /* content length html header */
    const char *ct_hdr; /* content type html header */

    cl_hdr = mg_get_header(conn, "Content-Length");
    if (cl_hdr) {
        /*
         * At this point, Content-Length value has already been
         * error checked and is guaranteed to be within the correct
         * range.  Obtain the length, allocate the buffer for the
         * body, and read it in.
         */
        cl = atoi(cl_hdr);
        body = malloc(cl+1);
        mg_read(conn, body, cl);
	/* Make sure the buffer is null terminated */
	body[cl] = 0x0;
    } else {
        cl = 0;
        body = NULL;
    }
    ct_hdr = mg_get_header(conn, "Content-Type");
    if (ectx->est_mode == EST_SERVER) {
        est_rv = est_http_request(ectx, conn,
                                  (char*)request_info->request_method,
                                  (char*)request_info->uri, body, cl, ct_hdr);
    } else if (ectx->est_mode == EST_PROXY) {
        est_rv = est_proxy_http_request(ectx, conn,
                                        (char*)request_info->request_method,
                                        (char*)request_info->uri, body, cl, ct_hdr);
    }
    if (est_rv != EST_ERR_NONE) {
        EST_LOG_ERR("EST error response code: %d (%s)\n", 
		    est_rv, EST_ERR_NUM_TO_STR(est_rv));
    }
    if (cl_hdr) {
        free(body);
    }
    return est_rv;
}
// a directory, or call embedded function, etcetera.
static void handle_request (struct mg_connection *conn)
{
    struct mg_request_info *ri = &conn->request_info;
    int uri_len;
    int rv;

    if ((conn->request_info.query_string = strchr(ri->uri, '?')) != NULL) {
        *((char*)conn->request_info.query_string++) = '\0';
    }
    uri_len = (int)strnlen_s(ri->uri, EST_URI_MAX_LEN);
    url_decode(ri->uri, uri_len, (char*)ri->uri, uri_len + 1, 0);
    remove_double_dots_and_double_slashes((char*)ri->uri);

    EST_LOG_INFO("%s", ri->uri);
    /*
     * Process the request
     */
    rv = est_mg_handler(conn);
    if (EST_ERR_NONE != rv) {
	EST_LOG_WARN("Incoming request failed rv=%d (%s)", 
		     rv, EST_ERR_NUM_TO_STR(rv));
    }
}
// a directory, or call embedded function, etcetera.
static void log_header (const struct mg_connection *conn, const char *header)
{
    const char *header_value;

    if ((header_value = mg_get_header(conn, header)) == NULL) {
        EST_LOG_INFO("%s", " -");
    } else {
        EST_LOG_INFO(" \"%s\"", header_value);
    }
}
// a directory, or call embedded function, etcetera.
static void log_access (const struct mg_connection *conn)
{
    const struct mg_request_info *ri;
    char date[64], src_addr[20];


    strftime(date, sizeof(date), "%d/%b/%Y:%H:%M:%S %z",
             localtime(&conn->birth_time));

    ri = &conn->request_info;

    sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);
    EST_LOG_INFO("%s [%s] \"%s %s HTTP/%s\" %d %" INT64_FMT,
                 src_addr, date,
                 ri->request_method ? ri->request_method : "-",
                 ri->uri ? ri->uri : "-", ri->http_version,
                 conn->status_code, conn->num_bytes_sent);
    log_header(conn, "Referer");
    log_header(conn, "User-Agent");
}
// Return OpenSSL error message
static const char *ssl_error (void)
{
    unsigned long err;

    err = ERR_get_error();
    return err == 0 ? "" : ERR_error_string(err, NULL);
}
// Dynamically load SSL library. Set up ctx->ssl_ctx pointer.
static int set_ssl_option (struct mg_context *ctx)
{
    struct mg_connection *conn;
    EST_CTX *ectx;
    SSL_CTX *ssl_ctx;
    EC_KEY *ecdh = NULL;
    X509_VERIFY_PARAM *vpm = NULL;
    char sic[12] = "EST";

    if ((ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {
        cry(fc(ctx), "SSL_CTX_new (server) error: %s", ssl_error());
        return 0;
    }
    ctx->ssl_ctx = ssl_ctx;
    ectx = ctx->est_ctx;

    conn = fc(ctx);
    conn->request_info.ev_data = ctx->ssl_ctx;


    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);

    /*
     * Set the Session ID context to enable OpenSSL session
     * reuse, which improves performance.  We set the ID to
     * ESTxxxxxxxx, where the x values are random numbers
     */
    if (!RAND_bytes((unsigned char*)&sic[3], 8)) {
	EST_LOG_WARN("RNG failure while setting SIC: %s", ssl_error());
    }
    SSL_CTX_set_session_id_context(ssl_ctx, (void*)&sic, 11);

    // load in the CA cert(s) used to verify client certificates
    SSL_CTX_set_cert_store(ssl_ctx, ectx->trusted_certs_store);
    //The ssl code will free this store from ssl_ctx later
    ectx->trusted_certs_store = NULL;  

    /*
     * Note that we disable TLS tickets, which is another
     * way to reuse TLS sessions to avoid all the key exchange
     * overhead of the TLS handshake.  We've enabled session
     * reuse above.  But session reuse will not 
     * work when ticket support is enabled on the server.
     * We may want to look into enabling tickets
     * in the future, but for now the session reuse
     * above gives us a performance boost.
     *
     * The other options set here are to improve forward
     * secrecty and comply with the EST draft.
     */

    SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_SSLv2 |
                        SSL_OP_NO_SSLv3 |
                        SSL_OP_NO_TLSv1 |
                        SSL_OP_SINGLE_ECDH_USE |
                        SSL_OP_NO_TICKET);


    /* 
     * Set the ECDH single use parms.  Use the configured
     * curve, or use prime256v1 as the default.
     */
    if (ectx->ecdhe_nid) {
	/* Setup the user selected curve */
	ecdh = EC_KEY_new_by_curve_name(ectx->ecdhe_nid);
	EST_LOG_INFO("Using non-default ECDHE curve (nid=%d)", ectx->ecdhe_nid);
    } else {
	/* Default to prime256 curve */
	ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
	EST_LOG_INFO("Using default ECDHE curve (prime256v1)");
    }
    if (ecdh == NULL) {
        EST_LOG_ERR("Failed to generate temp ecdh parameters\n");
        return 0;
    }
    SSL_CTX_set_tmp_ecdh(ssl_ctx, ecdh);
    EC_KEY_free(ecdh);

    /*
     * Setup additional cert checks including CRL, depth
     * and purpose.
     */
    vpm = X509_VERIFY_PARAM_new();
    /* Enable CRL checks */
    if (ectx->enable_crl) {
	X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_CRL_CHECK |
                                    X509_V_FLAG_CRL_CHECK_ALL);
    }
    X509_VERIFY_PARAM_set_depth(vpm, EST_TLS_VERIFY_DEPTH);
    /* Note: the purpose is only checked when the keyusage
     * value is present in the client's cert */
    X509_VERIFY_PARAM_set_purpose(vpm, X509_PURPOSE_SSL_CLIENT);
    SSL_CTX_set1_param(ssl_ctx, vpm);
    X509_VERIFY_PARAM_free(vpm);

    /*
     * Set the single-use DH parameters if the application
     * has requested this capability.
     */
    if (ectx->dh_tmp) {
	SSL_CTX_set_options(ssl_ctx, SSL_OP_SINGLE_DH_USE);
	SSL_CTX_set_tmp_dh(ssl_ctx, ectx->dh_tmp);
	DH_free(ectx->dh_tmp);
	ectx->dh_tmp = NULL;
    }

    if (ectx->enable_srp) {
	EST_LOG_INFO("Enabling TLS SRP mode\n");
	if (!SSL_CTX_set_cipher_list(ssl_ctx, EST_CIPHER_LIST_SRP_SERVER)) { 
	    EST_LOG_ERR("Failed to set SSL cipher suites\n");
	    return 0;
	}
	/*
	 * Set the application specific handler for
	 * providing the SRP parameters during user 
	 * authentication.
	 */
	SSL_CTX_set_srp_username_callback(ssl_ctx, ectx->est_srp_username_cb);
    } else {
	EST_LOG_INFO("TLS SRP not enabled");
	/*
	 * Set the TLS cipher suites that should be allowed.
	 * This disables anonymous and null ciphers
	 */
	if (!SSL_CTX_set_cipher_list(ssl_ctx, EST_CIPHER_LIST)) { 
	    EST_LOG_ERR("Failed to set SSL cipher suites\n");
	    return 0;
	}
    }

    if (SSL_CTX_use_certificate(ssl_ctx, ectx->server_cert) == 0) {
	EST_LOG_ERR("Unable to set server certificate");
        return 0;
    }
    if (SSL_CTX_use_PrivateKey(ssl_ctx, ectx->server_priv_key) == 0) {
	EST_LOG_ERR("Unable to set server private key");
        return 0;
    }

    /*
     * There should be no need to include the cert chain for the
     * server's certificate in the TLS Certificate message from
     * the server.  The reason is the EST draft specifies that
     * all the subordinate CA certs should be included in the
     * cacerts message flow.  Hence, the client will already have
     * the full cert chain.  Therfore, the TLS handshake will only
     * contain the server's cert, not the full chain. 
     *
      SSL_CTX_use_certificate_chain_file(ctx->ssl_ctx,
                                         ctx->est_ctx->http_cert_file);
     */

    return 1;
}
// Dynamically load SSL library. Set up ctx->ssl_ctx pointer.
static void reset_per_request_attributes (struct mg_connection *conn)
{
    conn->path_info = conn->request_info.ev_data = NULL;
    conn->num_bytes_sent = conn->consumed_content = 0;
    conn->status_code = -1;
    conn->must_close = conn->request_len = 0;
}
// Dynamically load SSL library. Set up ctx->ssl_ctx pointer.
static int is_valid_uri (const char *uri)
{
    // Conform to http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
    // URI can be an asterisk (*) or should start with slash.
    return uri[0] == '/' || (uri[0] == '*' && uri[1] == '\0');
}
// Dynamically load SSL library. Set up ctx->ssl_ctx pointer.
static void process_new_connection (struct mg_connection *conn)
{
    struct mg_request_info *ri = &conn->request_info;
    int keep_alive_enabled, keep_alive, discard_len;
    const char *cl;

    keep_alive_enabled = conn->ctx->enable_keepalives;
    keep_alive = 0;

    // Important: on new connection, reset the receiving buffer. Credit goes
    // to crule42.
    conn->data_len = 0;
    do {
        reset_per_request_attributes(conn);
        conn->request_len = read_request(NULL, conn, conn->buf, conn->buf_size,
                                         &conn->data_len);
        assert(conn->request_len < 0 || conn->data_len >= conn->request_len);
        if (conn->request_len == 0 && conn->data_len == conn->buf_size) {
            send_http_error(conn, 413, "Request Too Large", "%s", "");
            return;
        }
        if (conn->request_len <= 0) {
            return; // Remote end closed the connection
        }
        if (parse_http_request(conn->buf, conn->buf_size, ri) <= 0 ||
            !is_valid_uri(ri->uri)) {
            // Do not put garbage in the access log, just send it back to the client
            send_http_error(conn, 400, "Bad Request",
                            "Cannot parse HTTP request: [%.*s]", conn->data_len, conn->buf);
            conn->must_close = 1;
        } else if (strncmp(ri->http_version, "1.0", 3) &&
                   strncmp(ri->http_version, "1.1", 3)) {
            // Request seems valid, but HTTP version is strange
            send_http_error(conn, 505, "HTTP version not supported", "%s", "");
            log_access(conn);
        } else {
            // Request is valid, handle it
            if ((cl = get_header(ri, "Content-Length")) != NULL) {
                conn->content_len = strtoll(cl, NULL, 10);
            } else if (!mg_strcasecmp(ri->request_method, "POST") ||
                       !mg_strcasecmp(ri->request_method, "PUT")) {
                conn->content_len = -1;
            } else {
                conn->content_len = 0;
            }
            /*
             * Ensure that the content-length value is a size that
             * the EST code is willing to accept
             */
            if (conn->content_len > EST_MAX_CONTENT_LEN) {
                EST_LOG_WARN("HTTP request content length greater than EST"
                             " maximum supported content length (%d)", 
                             EST_MAX_CONTENT_LEN);                
                send_http_error(conn, 413, "Content-Length too large", "%s", "");
                log_access(conn);
            } else if (conn->content_len < 0) {
                EST_LOG_WARN("HTTP request content length is a negative value");
                send_http_error(conn, 400, "Bad Request",
                                "Content-Length is negative",
                                conn->data_len, conn->buf);
                log_access(conn);
            } else {
                conn->birth_time = time(NULL);
                handle_request(conn);
                log_access(conn);
            } 
        }

        // NOTE(lsm): order is important here. should_keep_alive() call
        // is using parsed request, which will be invalid after memmove's below.
        // Therefore, memorize should_keep_alive() result now for later use
        // in loop exit condition.
        keep_alive = should_keep_alive(conn);

        // Discard all buffered data for this request
        discard_len = conn->content_len >= 0 &&
                      conn->request_len + conn->content_len < (int64_t)conn->data_len ?
                      (int)(conn->request_len + conn->content_len) : conn->data_len;
	if ((conn->data_len - discard_len) > 0) {
	    memmove_s(conn->buf, MAX_REQUEST_SIZE,
		      conn->buf + discard_len, conn->data_len - discard_len);
	}
        conn->data_len -= discard_len;
        assert(conn->data_len >= 0);
        assert(conn->data_len <= conn->buf_size);

    } while (conn->ctx->stop_flag == 0 &&
             keep_alive_enabled &&
             conn->content_len >= 0 &&
             keep_alive);
}
/*! @brief est_server_handle_request() is used by an application 
    to process an EST request.  The application is responsible
    for opening a listener socket.  When an EST request comes in
    on the socket, the application uses this function to hand-off
    the request to libEST.

    @param ctx Pointer to the EST_CTX, which was provided
               when est_server_init()  or est_proxy_init() was invoked.
    @param fd File descriptor that will be read to retrieve the
              HTTP request from the client.  This is typically
	      a TCP socket file descriptor.

    est_server_handle_request() is used by an application 
    when an incoming EST request needs to be processed.  This request
    would be a cacerts, simpleenroll, reenroll, or csrattrs request. 
    This is used when implementing an EST server.  The application 
    is responsible for opening and listening to a TCP socket for
    incoming EST requests.  When data is ready to be read from
    the socket, this API entry point should be used to allow libEST
    to read the request from the socket and respond to the request.
 

    @return EST_ERROR.
*/
EST_ERROR est_server_handle_request (EST_CTX *ctx, int fd)
{
    struct mg_connection *conn;
    struct socket accepted;
    socklen_t len;
    char ipstr[INET6_ADDRSTRLEN];
    int port;
    struct sockaddr_storage addr;
    int ssl_err, err_code;
    EST_ERROR rv = EST_ERR_NONE;
    int rc;

    if (!ctx) {
        EST_LOG_ERR("Null EST context");
        return (EST_ERR_NO_CTX);
    }
    if (!ctx->mg_ctx) {
        EST_LOG_ERR("Null EST MG context");
        return (EST_ERR_NO_CTX);
    }

    accepted.sock = fd;
    accepted.next = NULL;
    
    len = sizeof(struct sockaddr_storage);
    rc = getpeername(fd, (struct sockaddr*)&addr, &len);
    if (rc < 0) {
	EST_LOG_ERR("getpeername() failed");
	/* This should never happen, not sure what would cause this */
	return (EST_ERR_UNKNOWN);
    }
    // deal with both IPv4 and IPv6:
    if (addr.ss_family == AF_INET) {
        memcpy_s(&accepted.rsa.sin, sizeof(struct sockaddr_in),
		 &addr, sizeof(struct sockaddr_in));
        port = ntohs(accepted.rsa.sin.sin_port);
        inet_ntop(AF_INET, &accepted.rsa.sin.sin_addr, ipstr, sizeof ipstr);
    } else { // AF_INET6
        memcpy_s(&accepted.rsa.sin6, sizeof(struct sockaddr_in6),
		 &addr, sizeof(struct sockaddr_in6));
        port = ntohs(accepted.rsa.sin6.sin6_port);
        inet_ntop(AF_INET6, &accepted.rsa.sin6.sin6_addr, ipstr, sizeof ipstr);
    }
    EST_LOG_INFO("Peer IP address: %s", ipstr);
    EST_LOG_INFO("Peer port      : %d", port);

    conn = (struct mg_connection*)calloc(1, sizeof(*conn) + MAX_REQUEST_SIZE);
    if (conn == NULL) {
        cry(fc(ctx->mg_ctx), "%s", "Cannot create new connection struct, OOM");
	return (EST_ERR_MALLOC);
    } else {
        conn->buf_size = MAX_REQUEST_SIZE;
        conn->buf = (char*)(conn + 1);

        conn->client = accepted;
        conn->birth_time = time(NULL);
        conn->ctx = ctx->mg_ctx;
        conn->read_timeout = ctx->server_read_timeout;

        // Fill in IP, port info early so even if SSL setup below fails,
        // error handler would have the corresponding info.
        conn->request_info.remote_port = ntohs(conn->client.rsa.sin.sin_port);
        memcpy_s(&conn->request_info.remote_ip, 4,
                 &conn->client.rsa.sin.sin_addr.s_addr, 4);
        conn->request_info.remote_ip = ntohl(conn->request_info.remote_ip);
        conn->request_info.is_ssl = 1;

        /*
         * EST require TLS,  Setup the TLS tunnel
         */
        conn->ssl = SSL_new(conn->ctx->ssl_ctx);
        if (conn->ssl != NULL) {
            SSL_set_fd(conn->ssl, conn->client.sock);
            ssl_err = SSL_accept(conn->ssl); 
            if (ssl_err <= 0) {
		err_code = SSL_get_error(conn->ssl, ssl_err);
		switch (err_code) {
		case SSL_ERROR_SYSCALL:
		    EST_LOG_ERR("OpenSSL system call error");
		    rv = EST_ERR_SYSCALL;
		    break;
		case SSL_ERROR_SSL:
		    /* Some unknown OpenSSL error, dump the 
		     * OpenSSL error log to learn more about this */
		    ossl_dump_ssl_errors();
		    rv = EST_ERR_UNKNOWN;
		    break;
		case SSL_ERROR_WANT_READ:
		case SSL_ERROR_WANT_WRITE:
		    EST_LOG_INFO("App using non-blocking socket");
		    process_new_connection(conn);
		    break;
		case SSL_ERROR_WANT_X509_LOOKUP:
		    EST_LOG_ERR("SSL_accept error, wants lookup");
		    rv = EST_ERR_UNKNOWN;
		    break;
		case SSL_ERROR_NONE:
		default:
		    break;
		}
	    } else {
		process_new_connection(conn);
	    }
            ssl_err = SSL_shutdown(conn->ssl);
	    switch (ssl_err) {
	    case 0:
		/* OpenSSL docs say to call shutdown again for this case */
		SSL_shutdown(conn->ssl);
		EST_LOG_INFO("Two-phase SSL_shutdown initiated");
		break;
	    case 1:
		/* Nothing to do, shutdown worked */
		EST_LOG_INFO("SSL_shutdown succeeded");
		break;
	    default:
		/* Log an error */
		EST_LOG_WARN("SSL_shutdown failed");
		break;
	    }
            SSL_free(conn->ssl);
            conn->ssl = NULL;
        }
        memzero_s(conn, sizeof(*conn) + MAX_REQUEST_SIZE);
        free(conn);
    }
    return (rv);
}
/*! @brief est_server_handle_request() is used by an application 
    to process an EST request.  The application is responsible
    for opening a listener socket.  When an EST request comes in
    on the socket, the application uses this function to hand-off
    the request to libEST.

    @param ctx Pointer to the EST_CTX, which was provided
               when est_server_init()  or est_proxy_init() was invoked.
    @param fd File descriptor that will be read to retrieve the
              HTTP request from the client.  This is typically
	      a TCP socket file descriptor.

    est_server_handle_request() is used by an application 
    when an incoming EST request needs to be processed.  This request
    would be a cacerts, simpleenroll, reenroll, or csrattrs request. 
    This is used when implementing an EST server.  The application 
    is responsible for opening and listening to a TCP socket for
    incoming EST requests.  When data is ready to be read from
    the socket, this API entry point should be used to allow libEST
    to read the request from the socket and respond to the request.
 

    @return EST_ERROR.
*/
static void free_context (struct mg_context *ctx)
{
    // Deallocate SSL context
    if (ctx->ssl_ctx != NULL) {
        SSL_CTX_free(ctx->ssl_ctx);
    }

    // Deallocate context itself
    free(ctx);
}
/*! @brief est_server_handle_request() is used by an application 
    to process an EST request.  The application is responsible
    for opening a listener socket.  When an EST request comes in
    on the socket, the application uses this function to hand-off
    the request to libEST.

    @param ctx Pointer to the EST_CTX, which was provided
               when est_server_init()  or est_proxy_init() was invoked.
    @param fd File descriptor that will be read to retrieve the
              HTTP request from the client.  This is typically
	      a TCP socket file descriptor.

    est_server_handle_request() is used by an application 
    when an incoming EST request needs to be processed.  This request
    would be a cacerts, simpleenroll, reenroll, or csrattrs request. 
    This is used when implementing an EST server.  The application 
    is responsible for opening and listening to a TCP socket for
    incoming EST requests.  When data is ready to be read from
    the socket, this API entry point should be used to allow libEST
    to read the request from the socket and respond to the request.
 

    @return EST_ERROR.
*/
void mg_stop (struct mg_context *ctx)
{
    ctx->stop_flag = 1;

    free_context(ctx);

#if defined(_WIN32) && !defined(__SYMBIAN32__)
    (void)WSACleanup();
#endif // _WIN32
}
/*! @brief est_server_handle_request() is used by an application 
    to process an EST request.  The application is responsible
    for opening a listener socket.  When an EST request comes in
    on the socket, the application uses this function to hand-off
    the request to libEST.

    @param ctx Pointer to the EST_CTX, which was provided
               when est_server_init()  or est_proxy_init() was invoked.
    @param fd File descriptor that will be read to retrieve the
              HTTP request from the client.  This is typically
	      a TCP socket file descriptor.

    est_server_handle_request() is used by an application 
    when an incoming EST request needs to be processed.  This request
    would be a cacerts, simpleenroll, reenroll, or csrattrs request. 
    This is used when implementing an EST server.  The application 
    is responsible for opening and listening to a TCP socket for
    incoming EST requests.  When data is ready to be read from
    the socket, this API entry point should be used to allow libEST
    to read the request from the socket and respond to the request.
 

    @return EST_ERROR.
*/
struct mg_context *mg_start (void *user_data)
{
    struct mg_context *ctx;

#if defined(_WIN32) && !defined(__SYMBIAN32__)
    WSADATA data;
    WSAStartup(MAKEWORD(2, 2), &data);
    InitializeCriticalSection(&global_log_file_lock);
#endif // _WIN32

    // Allocate context and initialize reasonable general case defaults.
    // TODO(lsm): do proper error handling here.
    if ((ctx = (struct mg_context*)calloc(1, sizeof(*ctx))) == NULL) {
        return NULL;
    }
    ctx->user_data = user_data;
    ctx->est_ctx = (EST_CTX*)user_data;
    ctx->enable_keepalives = 1; 
    if (!set_ssl_option(ctx)) {
        free_context(ctx);
        return NULL;
    }

    return ctx;
}
/*! @brief est_server_handle_request() is used by an application 
    to process an EST request.  The application is responsible
    for opening a listener socket.  When an EST request comes in
    on the socket, the application uses this function to hand-off
    the request to libEST.

    @param ctx Pointer to the EST_CTX, which was provided
               when est_server_init()  or est_proxy_init() was invoked.
    @param fd File descriptor that will be read to retrieve the
              HTTP request from the client.  This is typically
	      a TCP socket file descriptor.

    est_server_handle_request() is used by an application 
    when an incoming EST request needs to be processed.  This request
    would be a cacerts, simpleenroll, reenroll, or csrattrs request. 
    This is used when implementing an EST server.  The application 
    is responsible for opening and listening to a TCP socket for
    incoming EST requests.  When data is ready to be read from
    the socket, this API entry point should be used to allow libEST
    to read the request from the socket and respond to the request.
 

    @return EST_ERROR.
*/
EST_ERROR est_send_csrattr_data (EST_CTX *ctx, char *csr_data, int csr_len, void *http_ctx)
{
   char http_hdr[EST_HTTP_HDR_MAX];
   int hdrlen;

   if ((csr_len > 0) && csr_data) {
        /*
         * Send HTTP 200 header
         */
        snprintf(http_hdr, EST_HTTP_HDR_MAX, "%s%s%s%s", EST_HTTP_HDR_200, EST_HTTP_HDR_EOL,
                 EST_HTTP_HDR_STAT_200, EST_HTTP_HDR_EOL);
        hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
        snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CT,
                 EST_HTTP_CT_CSRATTRS, EST_HTTP_HDR_EOL);
        hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
        snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CE,
                 EST_HTTP_CE_BASE64, EST_HTTP_HDR_EOL);
        hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
        snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %d%s%s", EST_HTTP_HDR_CL,
                 csr_len, EST_HTTP_HDR_EOL, EST_HTTP_HDR_EOL);
        if (!mg_write(http_ctx, http_hdr, strnlen_s(http_hdr, EST_HTTP_HDR_MAX))) {
            free(csr_data);
            return (EST_ERR_HTTP_WRITE);
        }

        /*
         * Send the CSR in the body
         */
        if (!mg_write(http_ctx, csr_data, csr_len)) {
            free(csr_data);
            return (EST_ERR_HTTP_WRITE);
        }
        free(csr_data);
    } else {
	if (csr_data) {
            free(csr_data);
	}
        /* Send a 204 response indicating the server doesn't have a CSR */
	est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
    }
    return (EST_ERR_NONE);
}

/* Use WSAAddressToStringA instead of inet_ntop on Windows as inet_ntop does not
 * exist on Windows XP.
 * Can't use `const struct sockaddr *` here because WSAAddressToStringA takes
 * a LPSOCKADDR.
 */
static int addr_to_str (struct sockaddr *addr, char *str, size_t str_size,
                        unsigned short int *port)
{
    int ret = -1;
#ifdef WIN32
    DWORD dw_str_size;
    size_t addr_len = 0;

    switch (addr->sa_family) {
        case AF_INET:
            addr_len = sizeof(struct sockaddr_in);
            *port = ntohs(((struct sockaddr_in *)addr)->sin_port);
            break;
        case AF_INET6:
            addr_len = sizeof(struct sockaddr_in6);
            *port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
            break;
        default:
            break;
    }
    dw_str_size = str_size;
    if (addr_len != 0 &&
            WSAAddressToStringW(addr, addr_len, NULL, (LPWSTR)str, &dw_str_size) == 0) {
        ret = 0;
    }
#else
    switch (addr->sa_family) {
        case AF_INET:
            *port = ntohs(((struct sockaddr_in *)addr)->sin_port);
            if (inet_ntop(addr->sa_family,
                    &((struct sockaddr_in *)addr)->sin_addr,
                    str,
                    str_size)) {
                ret = 0;
            }
            break;
        case AF_INET6:
            *port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
            if (inet_ntop(addr->sa_family,
                    &((struct sockaddr_in6 *)addr)->sin6_addr,
                    str,
                    str_size)) {
                ret = 0;
            }
            break;
        default:
            break;
    }
#endif

    return ret;
}
/* Use WSAAddressToStringA instead of inet_ntop on Windows as inet_ntop does not
 * exist on Windows XP.
 * Can't use `const struct sockaddr *` here because WSAAddressToStringA takes
 * a LPSOCKADDR.
 */
static tcw_err_t tcw_direct_close (tcw_sock_t *sock)
{
    tcw_err_t ret = TCW_OK;

    if (CLOSE_SOCKET(sock->sock_fd) != 0) {
        EST_LOG_ERR("close failed: %d", GET_SOCK_ERR());
        ret = TCW_ERR_CLOSE;
        /* SOCK_ERR already set */
        goto done;
    }
    sock->sock_fd = SOCK_INVALID;

done:
    return ret;
}
/*
 * Establish a direct socket connection with the EST server using
 * normal system calls
 */
static tcw_err_t tcw_direct_connect (tcw_sock_t *sock, tcw_opts_t *opts,
                                      const char *host, unsigned short int port)
{
    tcw_err_t ret = TCW_OK;
    struct addrinfo *addrs = NULL;
    struct addrinfo *cur_addr;
    SOCK_TYPE fd;
    int err;
    int saved_err;
    char port_str[10];
    char sock_addr_str[INET6_ADDRSTRLEN];
    unsigned short int sock_port;
    struct addrinfo hints = { 0 };
    int n;

    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_ADDRCONFIG;

    n = snprintf(port_str, sizeof(port_str), "%hu", port);
    if (n < 0 || n >= (int)sizeof(port_str)) {
        errno = ENOMEM;
        ret = TCW_ERR_ALLOC;
        goto done;
    }
    EST_LOG_INFO("getaddrinfo(%s, %s)", host, port_str);
    if ((err = getaddrinfo(host, port_str, &hints, &addrs)) != 0) {
        EST_LOG_ERR("getaddrinfo returned %d: %s", err, gai_strerror(err));
        ret = TCW_ERR_RESOLV;
#ifdef WIN32
        /* SOCK_ERR already set */
#else
        switch (err) {
            case EAI_SYSTEM:
                /* SOCK_ERR already set */
                break;
            case EAI_MEMORY:
                SET_SOCK_ERR_NOMEM();
                break;
            default:
                /* Could not resolve host */
                SET_SOCK_ERR_NONAME();
                break;
        }
#endif
        goto done;
    }
    cur_addr = addrs;
    while (cur_addr) {
        ret = TCW_OK;
        fd = socket(cur_addr->ai_family, SOCK_STREAM, IPPROTO_TCP);
        if (fd < 0) {
            EST_LOG_WARN("socket failed: %d", GET_SOCK_ERR());
            ret = TCW_ERR_SOCKET;
            cur_addr = cur_addr->ai_next;
            continue;
        }

        err = addr_to_str(cur_addr->ai_addr, sock_addr_str, sizeof(sock_addr_str),
                          &sock_port);
        if (!err) {
            EST_LOG_INFO("connect(%s port %hu)", sock_addr_str, sock_port);
        }
        if (connect(fd, cur_addr->ai_addr, cur_addr->ai_addrlen) < 0) {
            EST_LOG_WARN("connect failed: %d", GET_SOCK_ERR());
            ret = TCW_ERR_CONNECT;
            /* CLOSE_SOCKET() may clobber SOCK_ERR */
            saved_err = GET_SOCK_ERR();
            CLOSE_SOCKET(fd);
            fd = SOCK_INVALID;
            SET_SOCK_ERR(saved_err);
            cur_addr = cur_addr->ai_next;
            continue;
        }
        break;
    }
    if (fd >= 0) {
        sock->sock_fd = fd;
    } else {
        EST_LOG_ERR("Could not connect to %s:%hu", host, port);
        /* ret and SOCK_ERR already set */
    }
done:
    return ret;
}
/*
 * Establish a direct socket connection with the EST server using
 * normal system calls
 */
static tcw_err_t tcw_curl_close (tcw_sock_t *sock)
{
    tcw_err_t ret = TCW_OK;

    if (sock->curl_handle) {
        curl_easy_cleanup(sock->curl_handle);
    }
    sock->curl_handle = NULL;
    sock->sock_fd = SOCK_INVALID;

    return ret;
}
/*
 * Establish a direct socket connection with the EST server using
 * normal system calls
 */
static tcw_err_t set_blocking_mode (tcw_sock_t *sock, int blocking)
{
    tcw_err_t ret = TCW_OK;

#ifdef WIN32
    int result;
    unsigned long mode = blocking ? 0 : 1;

    result = ioctlsocket(sock->sock_fd, FIONBIO, &mode);
    if (result != NO_ERROR) {
        /*
         * As per:
         * https://msdn.microsoft.com/en-us/library/windows/desktop/ms740126(v=vs.85).aspx
         *
         * Ioctl and Ioctlsocket/WSAIoctl
         *
         * Various C language run-time systems use the IOCTLs for purposes
         * unrelated to Windows Sockets. As a consequence, the ioctlsocket
         * function and the WSAIoctl function were defined to handle socket
         * functions that were performed by IOCTL and fcntl in the Berkeley
         * Software Distribution.
         *
         * Since ioctlsocket is the Windows equivalent of ioctl/fcntl, just
         * set return type accordingly.
         */
        ret = TCW_ERR_FCNTL;
        goto done;
    }
#else
    int flags = fcntl(sock->sock_fd, F_GETFL);
    if (flags < 0) {
        EST_LOG_ERR("fcntl(F_GETFL) failed: %d", GET_SOCK_ERR());
        /* SOCK_ERR is already set */
        ret = TCW_ERR_FCNTL;
        goto done;
    }
    flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
    if (fcntl(sock->sock_fd, F_SETFL, flags) < 0) {
        EST_LOG_ERR("fcntl(F_SETFL) failed: %d", GET_SOCK_ERR());
        /* SOCK_ERR is already set */
        ret = TCW_ERR_FCNTL;
        goto done;
    }
#endif /* WIN32 */

done:
    return ret;
}
/*
 * Establish a socket with the remote server using libcurl. Do not have it
 * actually send a URL. Leverage libcurl's proxy support to just establish
 * the connection.
 */
static tcw_err_t tcw_curl_connect (tcw_sock_t *sock, tcw_opts_t *opts,
                                   const char *host, unsigned short int port)
{
    tcw_err_t ret = TCW_OK;
    size_t url_size;
    char *url = NULL;
    CURLcode curlcode;
    long curl_socket;
    long auth_bits;
    long proxy_type = -1;
    int saved_err;
    const char *proxy_type_str = "NONE";
    int n;

    sock->curl_handle = curl_easy_init();
    if (!sock->curl_handle) {
        EST_LOG_ERR("curl_easy_init failed");
        errno = ENOMEM;
        ret = TCW_ERR_ALLOC;
        goto done;
    }
    /*
     * All we want libcurl to do here is establish the connection to
     * the proxy server.  Once that's done we'll use the socket
     * as we normally do on a direct connect to the EST server
     */
    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_CONNECT_ONLY, 1);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_CONNECT_ONLY) returned %d: %s",
                    curlcode, curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }
    url_size = strlen(host) + TCW_URL_SCHEMA_PORT_SIZE;
    url = (char *)calloc(1, url_size);
    if (!url) {
        EST_LOG_ERR("calloc failed");
        errno = ENOMEM;
        ret = TCW_ERR_ALLOC;
        goto done;
    }
    /*
     * "http" here is telling libcurl not to wrap whatever data we send in
     *  SSL. 
     */
    n = snprintf(url, url_size-1, "http://%s:%hu", host, port);
    if (n < 0 || n >= (int)url_size) {
        errno = ENOMEM;
        ret = TCW_ERR_ALLOC;
        goto done;
    }
    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_URL, url);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_URL) returned %d: %s", curlcode,
                    curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }

    /*
     * proxy host and port
     */
    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXY, opts->proxy_host);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXY) returned %d: %s", curlcode,
                    curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }
    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXYPORT, opts->proxy_port);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXYPORT) returned %d: %s", curlcode,
                    curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }

    /*
     * proxy protocol including HTTP tunnel mode
     */
    if (opts->proxy_proto == EST_CLIENT_PROXY_HTTP_NOTUNNEL) {
        proxy_type = CURLPROXY_HTTP;
        proxy_type_str = "HTTP (no tunneling)";
    } else if (opts->proxy_proto == EST_CLIENT_PROXY_HTTP_TUNNEL) {
        proxy_type = CURLPROXY_HTTP;
        proxy_type_str = "HTTP (tunneling)";
    } else if (opts->proxy_proto == EST_CLIENT_PROXY_SOCKS4) {
        proxy_type = CURLPROXY_SOCKS4;
        proxy_type_str = "SOCKS4";
    } else if (opts->proxy_proto == EST_CLIENT_PROXY_SOCKS5) {
        proxy_type = CURLPROXY_SOCKS5;
        proxy_type_str = "SOCKS5";
    } else if (opts->proxy_proto == EST_CLIENT_PROXY_SOCKS4A) {
        proxy_type = CURLPROXY_SOCKS4A;
        proxy_type_str = "SOCKS4A";
    } else if (opts->proxy_proto == EST_CLIENT_PROXY_SOCKS5_HOSTNAME) {
        proxy_type = CURLPROXY_SOCKS5_HOSTNAME;
        proxy_type_str = "SOCKS5_HOSTNAME";
    }
    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXYTYPE, proxy_type);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXYTYPE) returned %d: %s",
                    curlcode, curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }
    if (opts->proxy_proto == EST_CLIENT_PROXY_HTTP_TUNNEL) {
        curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_HTTPPROXYTUNNEL, 1);
        if (curlcode != CURLE_OK) {
            EST_LOG_ERR("curl_easy_setopt(CURLOPT_HTTPPROXYTUNNEL) returned %d: %s",
                        curlcode, curl_easy_strerror(curlcode));
            errno = EINVAL;
            ret = TCW_ERR_OTHER;
            goto done;
        }
    }

    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXYAUTH, CURLAUTH_BASIC|CURLAUTH_ONLY);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXYAUTH) returned %d: %s",
                    curlcode, curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }

    /*
     * username and password
     */
    if (opts->proxy_username && opts->proxy_password) {
        curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXYUSERNAME,
                                    opts->proxy_username);
        if (curlcode != CURLE_OK) {
            EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXYUSERNAME) returned %d: %s",
                        curlcode, curl_easy_strerror(curlcode));
            errno = EINVAL;
            ret = TCW_ERR_OTHER;
            goto done;
        }
        curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXYPASSWORD,
                                    opts->proxy_password);
        if (curlcode != CURLE_OK) {
            EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXYPASSWORD) returned %d: %s",
                        curlcode, curl_easy_strerror(curlcode));
            errno = EINVAL;
            ret = TCW_ERR_OTHER;
            goto done;
        }
        auth_bits = 0;
        if (opts->proxy_auth & EST_CLIENT_PROXY_AUTH_BASIC) {
            auth_bits |= CURLAUTH_BASIC;
        }
        if (opts->proxy_auth & EST_CLIENT_PROXY_AUTH_NTLM) {
            auth_bits |= CURLAUTH_NTLM;
        }
        if (auth_bits) {
            curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_PROXYAUTH, auth_bits);
            if (curlcode != CURLE_OK) {
                EST_LOG_ERR("curl_easy_setopt(CURLOPT_PROXYAUTH) returned %d: %s",
                            curlcode, curl_easy_strerror(curlcode));
                errno = EINVAL;
                ret = TCW_ERR_OTHER;
                goto done;
            }
        }
    }

    /*
     * no signals generated from libcurl
     */
    curlcode = curl_easy_setopt(sock->curl_handle, CURLOPT_NOSIGNAL, 1);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_setopt(CURLOPT_NOSIGNAL) returned %d: %s",
                    curlcode, curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }

    /*
     * perform the curl request
     */
    EST_LOG_INFO("curl_easy_perform(%s), proxy type %s", url, proxy_type_str);
    curlcode = curl_easy_perform(sock->curl_handle);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_perform(%s) returned %d: %s", url, curlcode,
                    curl_easy_strerror(curlcode));
        if (curlcode == CURLE_COULDNT_RESOLVE_PROXY ||
            curlcode == CURLE_COULDNT_RESOLVE_HOST) {
            SET_SOCK_ERR_NONAME();
            ret = TCW_ERR_RESOLV;
            goto done;
        } else {
            SET_SOCK_ERR_CONN();
            ret = TCW_ERR_CONNECT;
            goto done;
        }
    }

    /*
     * retrieve the socket from libcurl
     */
    curlcode = curl_easy_getinfo(sock->curl_handle, CURLINFO_LASTSOCKET,
                                 &curl_socket);
    if (curlcode != CURLE_OK) {
        EST_LOG_ERR("curl_easy_getinfo(CURLINFO_LASTSOCKET) returned %d: %s",
                    curlcode, curl_easy_strerror(curlcode));
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }
    if (curl_socket == -1) {
        EST_LOG_ERR("CURLINFO_LASTSOCKET: invalid socket");
        errno = EINVAL;
        ret = TCW_ERR_OTHER;
        goto done;
    }
    sock->sock_fd = curl_socket;

    /* after connection is made, set socket to blocking */
    ret = set_blocking_mode(sock, 1);
    if (ret != TCW_OK) {
        /* SOCK_ERR is already set */
        EST_LOG_ERR("Failed to set socket to blocking");
        goto done;
    }

  done:
    free(url);
    url = NULL;
    if (ret != TCW_OK) {
        saved_err = GET_SOCK_ERR();
        tcw_curl_close(sock);
        SET_SOCK_ERR(saved_err);
    }

    return ret;
}
/*
 * entry point to establish a connection with the remote EST server
 */
tcw_err_t tcw_connect (tcw_sock_t *sock, tcw_opts_t *opts, const char *host,
                       unsigned short int port, SOCK_TYPE *sock_fd)
{
    tcw_err_t ret = TCW_OK;

    memset(sock, 0, sizeof(tcw_sock_t));
    sock->sock_fd = SOCK_INVALID;

    sock->proxy_proto = opts->proxy_proto;
    if (sock->proxy_proto != EST_CLIENT_PROXY_NONE) {
#ifdef HAVE_LIBCURL
        ret = tcw_curl_connect(sock, opts, host, port);
#else
        /*
         * We should not make it this far, but if we do,
         * log a message as to why this is wrong and return
         */
        EST_LOG_ERR("Proxy settings currently require libcurl");
        errno = EINVAL;
        ret = TCW_ERR_ARG;
        goto done;
#endif
    } else {
        ret = tcw_direct_connect(sock, opts, host, port);
    }
    if (ret != TCW_OK) {
        goto done;
    }
    EST_LOG_INFO("Successfully connected to %s:%hu", host, port);
    *sock_fd = sock->sock_fd;

done:
    return ret;
}
/*
 * entry point to establish a connection with the remote EST server
 */
tcw_err_t tcw_close (tcw_sock_t *sock)
{
    tcw_err_t ret = TCW_OK;

    if (sock->proxy_proto == EST_CLIENT_PROXY_NONE) {
        ret = tcw_direct_close(sock);
    } else {
#ifdef HAVE_LIBCURL
        ret = tcw_curl_close(sock);
#endif
    }

    return ret;
}

/*
 * Since we hijack the OpenSSL BUF_MEM with our
 * own data, this utility function allows us
 * to free the BUF_MEM without freeing the
 * underlying data.
 */
static void est_proxy_free_ossl_bufmem (BUF_MEM *b)
{
    b->data = NULL;
    BUF_MEM_free(b);
}
/*
 * bsearch_compare is used by the bsearch function to perform the
 * comparison of the nodes within the client context array.
 */
static int bsearch_compare(const void *pa, const void *pb)
{
    int result;
    CLIENT_CTX_LU_NODE_T *a = (CLIENT_CTX_LU_NODE_T *)pa;
    CLIENT_CTX_LU_NODE_T *b = (CLIENT_CTX_LU_NODE_T *)pb;
    
    if (a->threadid > b->threadid) result = 1;
    if (a->threadid < b->threadid) result = -1;
    if (a->threadid == b->threadid) result = 0;

    return (result);
}
/*
 * get_client_ctx() performs a search through a ordered array.
 * The key for the search is the current thread id and the value returned
 * is the client context that's been created for this thread.  If no
 * entry exists in the array for this thread id, a new one is created.
 */
static EST_CTX *get_client_ctx (EST_CTX *p_ctx) 
{
    EST_CTX *c_ctx = NULL;
    EST_ERROR rv;
    unsigned long cur_threadid = 0;
    unsigned long cur_pid = GETPID();
    CLIENT_CTX_LU_NODE_T *found_node;
    unsigned long zero_threadid = 0x0;
    CLIENT_CTX_LU_NODE_T *empty_node;
    int empty_index;

    /*
     * Windows TODO: This will likely need to be replaced with
     * GetCurrentThreadId()
     * In addition, this is really returning a pointer to an opaque value, so
     * what's being used here is typically a pointer in pthread based
     * environments and not the actual pthread id.  The only helper API to
     * access the actual id is pthread_equal().  If this must be used, then
     * the array search would best be changed to a linear search.
     * We mix in the PID of the current process with the thread ID in
     * case the application is forking new processes (e.g. NGINX).  
     */
#ifndef DISABLE_PTHREADS
    cur_threadid = (unsigned long) pthread_self();
#endif
    cur_threadid += cur_pid;

    found_node = (CLIENT_CTX_LU_NODE_T *) bsearch(&cur_threadid,
                                                  p_ctx->client_ctx_array,
                                                  cur_max_ctx_array,
                                                  sizeof(CLIENT_CTX_LU_NODE_T),
                                                  bsearch_compare);
    if (found_node == NULL) {
        
        /*
         * need to allocate a context and get it ready to be used.
         */
        c_ctx = est_client_init(p_ctx->ca_chain_raw, p_ctx->ca_chain_raw_len,
                                EST_CERT_FORMAT_PEM, NULL);
        if (c_ctx == NULL) {
            EST_LOG_ERR("Unable to allocate and initialize EST client context for Proxy use");
            return (NULL);
        }

        /*
         * The name is a bit misleading.  The identity cert and private
         * key used for proxy mode are the ones stored in the server_cert and
         * server_priv_key, however they are used in both directions, so here
         * when setting up the client side, it looks mixed up.  Might want to
         * change the name in context to hold these.
         */
        rv = est_client_set_auth(c_ctx, p_ctx->userid, p_ctx->password,
                                 p_ctx->server_cert, p_ctx->server_priv_key);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Unable to set authentication configuration in the client context for Proxy use");
	    est_destroy(c_ctx);
            return (NULL);
	}        

        rv = est_client_set_auth_cred_cb(c_ctx, p_ctx->auth_credentials_cb);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Unable to register authentication credential callback.");
            return (NULL);
        }

        /*
         * wrt path segment, unlike true client mode, the path segment will
         * be changing on every request going upstream, so no need to
         * obtain it locally at a proxy and set it one time, so it
         * should be left NULL.
         */
	rv = est_client_set_server(c_ctx, p_ctx->est_server, p_ctx->est_port_num, NULL);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Unable to set the upstream server configuration in the client context for Proxy use");
	    est_destroy(c_ctx);
            return (NULL);
	}

        rv = est_client_set_read_timeout(c_ctx, p_ctx->read_timeout);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Unable to set the SSL read timeout in the client context");
	    est_destroy(c_ctx);
            return (NULL);
	}        

        /*
         * make sure there's room for another entry
         */
        empty_node = (CLIENT_CTX_LU_NODE_T *) bsearch(&zero_threadid,
                                                      p_ctx->client_ctx_array,
                                                      cur_max_ctx_array,
                                                      sizeof(CLIENT_CTX_LU_NODE_T),
                                                      bsearch_compare);

        if (empty_node == NULL) {
            /*
             * we're out of space.  allocate a new array and copy over what's
             * already there.  Double the size of the current one.
             */
            CLIENT_CTX_LU_NODE_T *temp_array;
            
            cur_max_ctx_array *= 2;
            temp_array = (CLIENT_CTX_LU_NODE_T *) malloc(sizeof(CLIENT_CTX_LU_NODE_T)*cur_max_ctx_array);
            memzero_s(temp_array, sizeof(CLIENT_CTX_LU_NODE_T)*cur_max_ctx_array); 
            memcpy_s(temp_array, sizeof(CLIENT_CTX_LU_NODE_T)*cur_max_ctx_array,
                     p_ctx->client_ctx_array,sizeof(CLIENT_CTX_LU_NODE_T)*cur_max_ctx_array/2);
            free(p_ctx->client_ctx_array);
            p_ctx->client_ctx_array = temp_array;
            
            qsort(p_ctx->client_ctx_array, cur_max_ctx_array,
                  sizeof(CLIENT_CTX_LU_NODE_T), 
                  bsearch_compare);

            empty_node = (CLIENT_CTX_LU_NODE_T *) bsearch(&zero_threadid,
                                                          p_ctx->client_ctx_array,
                                                          cur_max_ctx_array,
                                                          sizeof(CLIENT_CTX_LU_NODE_T),
                                                          bsearch_compare);
        }
        empty_index = (int) (empty_node - p_ctx->client_ctx_array);

        /*
         * add to the array and sort it into its proper place
         */
        p_ctx->client_ctx_array[empty_index].threadid = cur_threadid;
        p_ctx->client_ctx_array[empty_index].client_ctx = c_ctx;
        
        qsort(p_ctx->client_ctx_array, cur_max_ctx_array,
              sizeof(CLIENT_CTX_LU_NODE_T), 
              bsearch_compare);
    } else {
        /*
         * the entry was found in the tree, return the client context for this
         * pid
         */
        c_ctx = found_node->client_ctx;
    }
    
    return(c_ctx);   
}
/*
 * proxy_cleanup() is invoked from est_destroy when the
 * current context is for proxy mode.
 */
void proxy_cleanup (EST_CTX *p_ctx) 
{
    int i;
    
    if (p_ctx->client_ctx_array == NULL) {
        return;
    }

    for (i=0; i<cur_max_ctx_array; i++) {
        if (p_ctx->client_ctx_array[i].client_ctx) {
            est_destroy(p_ctx->client_ctx_array[i].client_ctx);
        }
    }
    free(p_ctx->client_ctx_array);
    p_ctx->client_ctx_array = NULL;
}
/*
 * This routine will check the result code from an enroll
 * attempt and propagate the retry-after message to the 
 * client if needed.
 */
static EST_ERROR est_proxy_propagate_retry (EST_CTX *ctx, void *http_ctx)
{
    /*
     * The CA did not sign the request and has asked the
     * client to retry in the future.  This may occur if
     * the CA is not configured for automatic enrollment.
     * Send the HTTP retry response to the client.
     * We need to propagate the retry-after response to
     * the client.
     */
    EST_LOG_INFO("CA server requests retry, propagate this to the client (%d)", 
        ctx->retry_after_delay);
    if (EST_ERR_NONE != est_server_send_http_retry_after(ctx, http_ctx, ctx->retry_after_delay)) {
        return (EST_ERR_HTTP_WRITE);
    }
    return (EST_ERR_NONE);
}
/*
 * This routine will send a PKCS7 encoded certificate to
 * the EST client via HTTP. 
 */
static EST_ERROR est_proxy_propagate_pkcs7 (void *http_ctx, unsigned char *pkcs7, int pkcs7_len)
{
    char http_hdr[EST_HTTP_HDR_MAX];
    int hdrlen;

    /*
     * Send HTTP header
     */
    snprintf(http_hdr, EST_HTTP_HDR_MAX, "%s%s%s%s", EST_HTTP_HDR_200, EST_HTTP_HDR_EOL,
             EST_HTTP_HDR_STAT_200, EST_HTTP_HDR_EOL);
    hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
    snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CT,
             EST_HTTP_CT_PKCS7_CO, EST_HTTP_HDR_EOL);
    hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
    snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CE,
             EST_HTTP_CE_BASE64, EST_HTTP_HDR_EOL);
    hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
    snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %d%s%s", EST_HTTP_HDR_CL,
             pkcs7_len, EST_HTTP_HDR_EOL, EST_HTTP_HDR_EOL);
    if (!mg_write(http_ctx, http_hdr, strnlen_s(http_hdr, EST_HTTP_HDR_MAX))) {
            return (EST_ERR_HTTP_WRITE);
    }

    /*
     * Send the signed PKCS7 certificate in the body
     */
    if (!mg_write(http_ctx, pkcs7, pkcs7_len)) {
        EST_LOG_ERR("HTTP write error while propagating pkcs7");
        return (EST_ERR_HTTP_WRITE);
    }
    return (EST_ERR_NONE);
}
/*
 * est_proxy_retrieve_cacerts() issues a request to the server to obtain the
 * CA Certs chain to be used for Get CA Certs requests from clients.
 * The CA Cert chain returned from the server are passed back to the caller.
 *
 * It's the responsibility of the caller to free up this buffer.
 */
EST_ERROR est_proxy_retrieve_cacerts (EST_CTX *ctx, unsigned char **cacerts_rtn,
                                      int *cacerts_rtn_len)
{
    EST_CTX *client_ctx;
    EST_ERROR rv;
    int rcvd_cacerts_len;
    unsigned char *rcvd_cacerts;

    if (ctx == NULL) {
        EST_LOG_ERR("Ctx not passed to %s", __FUNCTION__);
        return (EST_ERR_NO_CTX);
    }
    if (cacerts_rtn == NULL || cacerts_rtn_len == NULL) {
        EST_LOG_ERR("Ctx not passed to %s", __FUNCTION__);
        return (EST_ERR_INVALID_PARAMETERS);        
    }
    
    *cacerts_rtn = NULL;
    *cacerts_rtn_len = 0;

    /*
     * Get the client context for this thread
     */
    client_ctx = get_client_ctx(ctx);
    if (!client_ctx) {
        EST_LOG_ERR("Unable to obtain client context for proxy operation");
        return (EST_ERR_NO_CTX);
    }

    rv = est_client_get_cacerts(client_ctx, &rcvd_cacerts_len);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Unable to retrieve CA Certs from upstream server RC = %s",
                    EST_ERR_NUM_TO_STR(rv));
        return (rv);
    }
    
    /*
     * Allocate a buffer to retrieve the CA certs
     * and get them copied in
     */
    rcvd_cacerts = malloc(rcvd_cacerts_len);
    if (rcvd_cacerts == NULL) {
        EST_LOG_ERR("Unable to malloc buffer for cacerts received from server");
        return (EST_ERR_MALLOC);
    }
    
    rv = est_client_copy_cacerts(client_ctx, rcvd_cacerts);
    if (rv != EST_ERR_NONE) {
        EST_LOG_ERR("Unable to copy CA Certs from upstream server RC = %s",
                    EST_ERR_NUM_TO_STR(rv));
        free(rcvd_cacerts);
        return (rv);
    }

    /*
     * The retrieving of the CA certs through the normal client
     * interface causes the client to go back into an uninitialized state.
     * In this case though, we're getting it just for passing it back
     * to the downstream clients, so we're going to put this client
     * context back into the initialized state
     */
    client_ctx->est_client_initialized = 1;
    
    *cacerts_rtn = rcvd_cacerts;
    *cacerts_rtn_len = rcvd_cacerts_len;
    return (EST_ERR_NONE);
}
/*
 * This routine will connect to the EST server and attempt
 * to enroll the CSR in the *pkcs10 buffer. Upon success
 * it will return the X509 cert in the *pkcs7 buffer.  The
 * length of the returned cert will be in *pkcs7_len.  
 * The *pkcs7 buffer should be allocated by the caller.
 */
static EST_ERROR est_proxy_send_enroll_request (EST_CTX *clnt_ctx, 
	                                        BUF_MEM *pkcs10, unsigned char *pkcs7,
						int *pkcs7_len, int reenroll)
{
    EST_ERROR rv;
    SSL *ssl_client;

    /*
     * Connect to the server
     */
    rv = est_client_connect(clnt_ctx, &ssl_client);
    if (rv != EST_ERR_NONE) {
        return (rv);
    }

    /*
     * Send the enroll request
     */
    rv = est_client_send_enroll_request(clnt_ctx, ssl_client,
                                        pkcs10, pkcs7, pkcs7_len, reenroll);

    /*
     * Disconnect from the server
     */
    est_client_disconnect(clnt_ctx, &ssl_client);

    return (rv);
}
/*
 * This routine will connect to the EST server and attempt
 * to enroll the CSR in the *pkcs10 buffer. Upon success
 * it will return the X509 cert in the *pkcs7 buffer.  The
 * length of the returned cert will be in *pkcs7_len.  
 * The *pkcs7 buffer should be allocated by the caller.
 */
static EST_ERROR est_proxy_set_path_segment (EST_CTX *client_ctx,
                                             char *path_segment)
{
    int path_segment_len;
    EST_ERROR rc;

    path_segment_len = strnlen_s(path_segment, EST_MAX_PATH_SEGMENT_LEN);
    
    rc = est_store_path_segment(client_ctx, path_segment, path_segment_len);
    if (rc != EST_ERR_NONE) {
        EST_LOG_ERR("Failed to store URI path segment.");
        return (rc);
    }
    return EST_ERR_NONE;
}
/*
 * This function is used by the server side of the EST proxy to respond to an
 * incoming Simple Enroll request.  This function is similar to the Client API
 * function, est_client_enroll_req(), except it bypasses some things that are
 * not done when functioning as a proxy, such as signing the CSR, not
 * inserting the TLS unique id and instead including the id-kp-cmcRA usage
 * extension.
 */
static EST_ERROR est_proxy_handle_simple_enroll (EST_CTX *ctx, void *http_ctx,
                                                 SSL *ssl, const char *ct,
                                                 char *body, int body_len,
					         char *path_seg, int reenroll)
{
    EST_ERROR rv;
    BUF_MEM *pkcs10;
    unsigned char *pkcs7;
    int pkcs7_len = 0;
    int diff;
    X509_REQ *csr = NULL;
    EST_CTX *client_ctx;
    errno_t safec_rc;
     
    /*
     * Make sure the client has sent us a PKCS10 CSR request
     */

    safec_rc = memcmp_s(ct, sizeof("application/pkcs10"), "application/pkcs10",
        sizeof("application/pkcs10"), &diff);

    if (safec_rc != EOK) {
        EST_LOG_INFO("memcmp_s error 0x%xO\n", safec_rc);
    }

    if (diff) {
        return (EST_ERR_BAD_CONTENT_TYPE);
    }

    /*
     * Authenticate the client
     */
    switch (est_enroll_auth(ctx, http_ctx, ssl, path_seg, reenroll)) {
    case EST_HTTP_AUTH:
    case EST_SRP_AUTH:
    case EST_CERT_AUTH:
        break;
    case EST_HTTP_AUTH_PENDING:
        return (EST_ERR_AUTH_PENDING);
        break;
    case EST_UNAUTHORIZED:
    default:
        return (EST_ERR_AUTH_FAIL);
        break;
    }

    /*
     * Parse the PKCS10 CSR from the client
     */
    csr = est_server_parse_csr((unsigned char*)body, body_len);
    if (!csr) {
	EST_LOG_ERR("Unable to parse the PKCS10 CSR sent by the client");
	return (EST_ERR_BAD_PKCS10);
    }
    
    /*
     * Perform a sanity check on the CSR
     */
    if (est_server_check_csr(csr)) {
	EST_LOG_ERR("PKCS10 CSR sent by the client failed sanity check");
	X509_REQ_free(csr);
	return (EST_ERR_BAD_PKCS10);
    }

    /*
     * Do the PoP check (Proof of Possession).  The challenge password
     * in the pkcs10 request should match the TLS unique ID.
     */
    rv = est_tls_uid_auth(ctx, ssl, csr);
    X509_REQ_free(csr);

    if (rv != EST_ERR_NONE) {
        return (EST_ERR_AUTH_FAIL_TLSUID);
    }

    /*
     * body now points to the pkcs10 data, pass
     * this to the enrollment routine.  Need to hi-jack
     * a BUF_MEM.  Attach the body to a new BUF_MEM
     */
    pkcs10 = BUF_MEM_new();
    pkcs10->data = body;
    pkcs10->length = body_len;
    pkcs10->max = body_len;

    /*
     * get the client context for this thread
     */
    client_ctx = get_client_ctx(ctx);
    if (!client_ctx) {
        EST_LOG_ERR("Unable to obtain client context for proxy operation");
        est_proxy_free_ossl_bufmem(pkcs10);
	return (EST_ERR_NO_CTX);
    }

    /*
     * path_segment.  The path seg value is coming in from the
     * downstream client on this request.  It's already been validated,
     * place it in ctx for use by client code.
     */
    if (path_seg) {
        est_proxy_set_path_segment(client_ctx, path_seg);
    }

    /*
     * Allocate some space to hold the cert that we
     * expect to receive from the EST server.
     */
    pkcs7 = malloc(EST_CA_MAX); 

    /*
     * Attempt to enroll the CSR from the client
     */
    rv = est_proxy_send_enroll_request(client_ctx, pkcs10, pkcs7, &pkcs7_len,
                                       reenroll);

    /*
     * Handle any errors that likely occurred
     */
    switch (rv) {
    case EST_ERR_AUTH_FAIL:
        /* Try one more time if we're doing Digest auth */
        if ((ctx->auth_mode == AUTH_DIGEST ||
             ctx->auth_mode == AUTH_BASIC  ||
             ctx->auth_mode == AUTH_TOKEN)) {
            
            EST_LOG_INFO("HTTP Auth failed, trying again with digest/basic parameters");

            rv = est_proxy_send_enroll_request(client_ctx, pkcs10, pkcs7, &pkcs7_len, reenroll);
	    if (rv == EST_ERR_CA_ENROLL_RETRY) {
	        rv = est_proxy_propagate_retry(client_ctx, http_ctx);
	    } else if (rv != EST_ERR_NONE) {
                EST_LOG_WARN("EST enrollment failed, error code is %d", rv);
            }
        }
        break;
    case EST_ERR_CA_ENROLL_RETRY:
	rv = est_proxy_propagate_retry(client_ctx, http_ctx);
	break;
    default:
        EST_LOG_WARN("Initial EST enrollment request error code is %d", rv);
	break;
    }

    client_ctx->auth_mode = AUTH_NONE;
    
    /*
     * Prevent OpenSSL from freeing our data
     */
    est_proxy_free_ossl_bufmem(pkcs10);

    /*
     * If we have a cert response from the EST server, let's forward
     * it back to the EST client
     */
    if (pkcs7_len > 0) {
        rv = est_proxy_propagate_pkcs7(http_ctx, pkcs7, pkcs7_len);
    }
    free(pkcs7);

    return (rv);
}
/*
 * This function is used by the server side of the EST proxy to respond to an
 * incoming cacerts request.  If the CA certs response has been set locally
 * then respond with this locally set buffer.  If not set, then issue a
 * request to the upstream server.
 */
static int est_proxy_handle_cacerts (EST_CTX *ctx, void *http_ctx,
                                     char *path_seg)
{
    EST_ERROR rv = EST_ERR_NONE;
    EST_CTX *client_ctx;
    int cacerts_len;

    if (ctx->ca_certs != NULL) {
        EST_LOG_INFO("Proxy: CA certs set locally, responding with locally set CA certs response");
        return(est_handle_cacerts(ctx, ctx->ca_certs, ctx->ca_certs_len,
                                  http_ctx, path_seg));
    } else {
        
        /*
         * get the client context for this thread
         */
        client_ctx = get_client_ctx(ctx);
        if (!client_ctx) {
            EST_LOG_ERR("Unable to obtain client context for proxy operation");
            return (EST_ERR_NO_CTX);
        }

        /*
         * path_segment.  The path seg value is coming in from the
         * downstream client on this request.  It's already been validated,
         * place it in ctx for use by client code.
         */
        if (path_seg) {    
            rv = est_proxy_set_path_segment(client_ctx, path_seg);
            if (rv != EST_ERR_NONE) {
                EST_LOG_ERR("Unable to save the path segment from the URI into the client context");
                return (rv);
            }
        }        

        /*
         * Invoke client code to retrieve the cacerts.
         * Note: there is no need to authenticate the client (see sec 4.5)
         */
        EST_LOG_INFO("Proxy: Attempting to retrieve CA certs from upstream server");
        rv = est_client_get_cacerts(client_ctx, &cacerts_len);

        /*
         * If the upstream request was successful, the retrieved CA certs will be
         * in the context
         */
        if (rv == EST_ERR_NONE) {
            EST_LOG_INFO("Proxy: CA certs retrieved successfully from server. Forwarding to EST client.");
            return(est_handle_cacerts(client_ctx, client_ctx->retrieved_ca_certs,
                                      client_ctx->retrieved_ca_certs_len,
                                      http_ctx, path_seg));
        } else {
            /*
             * Something went wrong with the upstream request to the
             * server.  Treat this as a not found condition.
             */
            EST_LOG_ERR("Proxy: Server not reachable or sent corrupt CA Certs");
            rv = EST_ERR_HTTP_NOT_FOUND;
        }
    }
    
    return (rv);
}
/*
 * This function is used by the server side of the EST proxy to respond to an
 * incoming CSR Attributes request.  This function is similar to the Client API
 * function, est_client_get_csrattrs().
  */
static int est_proxy_handle_csr_attrs (EST_CTX *ctx, void *http_ctx,
                                       char *path_seg)
{
    int rv = EST_ERR_NONE;
    int pop_present;
    char *csr_data, *csr_data_pop;
    int csr_len, csr_pop_len;
    EST_CTX *client_ctx;

    /*
     * get the client context for this thread
     */
    client_ctx = get_client_ctx(ctx);
    if (!client_ctx) {
        EST_LOG_ERR("Unable to obtain client context for proxy operation");
	return (EST_ERR_NO_CTX);
    }

    /*
     * path_segment.  The path seg value is coming in from the
     * downstream client on this request.  It's already been validated,
     * place it in ctx for use by client code.
     */
    if (path_seg) {
        rv = est_proxy_set_path_segment(client_ctx, path_seg);
        if (rv != EST_ERR_NONE) {
            EST_LOG_ERR("Unable to save the path segment from the URI into the client context");
            return (rv);
        }
    }

    /*
     * Invoke client code to retrieve the CSR attributes.
     * Note: there is no need to authenticate the client (see sec 4.5)
     */
    EST_LOG_INFO("Proxy: Attempting to retrieve CSR attrs from upstream server");
    rv = est_client_get_csrattrs(client_ctx, (unsigned char **)&csr_data, &csr_len);
    /*
     * csr_data points to the memory allocated to hold the csr attributes,
     * which will be freed in this call stack.  To prevent a double-free
     * we null the to pointer on the client context.
     */
    client_ctx->retrieved_csrattrs = NULL;
    client_ctx->retrieved_csrattrs_len = 0;
    if (rv == EST_ERR_NONE) {
	ctx->csr_pop_present = 0;
	if (ctx->server_enable_pop) {
	    rv = est_is_challengePassword_present(csr_data, csr_len, &pop_present);
	    if (rv != EST_ERR_NONE) {
		EST_LOG_ERR("Error during PoP/sanity check");
		est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
		return (EST_ERR_NONE);
	    }
	    ctx->csr_pop_present = pop_present;

	    if (!ctx->csr_pop_present) {
		if (csr_len == 0) {
                    csr_data = malloc(EST_CSRATTRS_POP_LEN + 1);
		    if (!csr_data) {
			return (EST_ERR_MALLOC);
		    }
		    strncpy_s(csr_data, EST_CSRATTRS_POP_LEN + 1, 
			      EST_CSRATTRS_POP, EST_CSRATTRS_POP_LEN);
		    csr_data[EST_CSRATTRS_POP_LEN] = 0;
		    csr_len = EST_CSRATTRS_POP_LEN;
		    return (est_send_csrattr_data(ctx, csr_data, csr_len, http_ctx));
		}
		rv = est_add_challengePassword(csr_data, csr_len, &csr_data_pop, &csr_pop_len);
		if (rv != EST_ERR_NONE) {
		    if (csr_data) {
		        free(csr_data);
		    }
		    EST_LOG_ERR("Error during add PoP");
		    est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
		    return (EST_ERR_NONE);
		}
		if (csr_data) {
		    free(csr_data);
		}
		csr_data = csr_data_pop;
		csr_len = csr_pop_len;
	    }
	}
    } else {
	EST_LOG_ERR("Server not reachable or sent corrupt attributes");
	est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
	return (EST_ERR_NONE);
    }
    return (est_send_csrattr_data(ctx, csr_data, csr_len, http_ctx));
}
/*
 * This function should be called by the web server layer when
 * a HTTP request arrives on the listening port of the EST proxy.
 * It will determine the EST request type and dispatch the request
 * to the appropriate handler.
 *
 * Paramters:
 *      ctx:	    Pointer to EST_CTX
 *      http_ctx:   Context pointer from web server
 *      method:     The HTML method in the request, should be either "GET" or "POST"
 *	uri:	    pointer to HTTP URI
 *	body:	    pointer to full HTML body contents
 *	body_len:   length of HTML body
 *	ct:         HTML content type header
 */
EST_ERROR est_proxy_http_request (EST_CTX *ctx, void *http_ctx,
                                  char *method, char *uri,
                                  char *body, int body_len, const char *ct)
{
    SSL *ssl;
    EST_ERROR rc;
    int diff;
    errno_t safec_rc;
    EST_OPERATION operation;
    char *path_seg = NULL;    
    EST_ERROR rv = EST_ERR_NONE;

    if (!ctx) {
        return (EST_ERR_NO_CTX);
    }

    /*
     * Verify the context is for a proxy, not a client or server
     */
    if (ctx->est_mode != EST_PROXY) {
        return (EST_ERR_BAD_MODE);
    }
    
    rv = est_parse_uri(uri, &operation, &path_seg);
    if (rv != EST_ERR_NONE) {
        est_send_http_error(ctx, http_ctx, rv);
        return (rv);
    }
    
    /*
     * See if this is a cacerts request
     */
    if (operation == EST_OP_CACERTS) {
        /* Only GET is allowed */
        safec_rc = strcmp_s(method, MAX_HTTP_METHOD_LEN, "GET", &diff);
        if (safec_rc != EOK) {
            EST_LOG_INFO("strcmp_s error 0x%xO\n", safec_rc);
        }

        if (diff) {
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }
        
        rc = est_proxy_handle_cacerts(ctx, http_ctx, path_seg);
        if (rc != EST_ERR_NONE) {
            est_send_http_error(ctx, http_ctx, rc);
            free(path_seg);
            path_seg = NULL;
            return (rc);
        }            
    }

    /*
     * See if this is a simple enrollment request
     */
    else if (operation == EST_OP_SIMPLE_ENROLL) {
        /* Only POST is allowed */
        safec_rc = strcmp_s(method, MAX_HTTP_METHOD_LEN, "POST", &diff);
        if (safec_rc != EOK) {
            EST_LOG_INFO("strcmp_s error 0x%xO\n", safec_rc);
        }

        if (diff) {
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }
	if (!ct) {
            EST_LOG_WARN("Incoming HTTP header has no Content-Type header\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
            free(path_seg);
            path_seg = NULL;
	    return (EST_ERR_BAD_CONTENT_TYPE); 
	}
        /*
         * In this case body is indicating that no content was passed in, and
         * this is a enroll request.  This cannot be correct because a CSR is
         * required.  If this continues, and we're in proxy mode, we'll try to
         * forward this non-existent CSR
         */
        if (body == NULL) {
            EST_LOG_WARN("Incoming HTTP header has no CSR content.\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_BAD_CONTENT_LEN);
        }
        
        /*
         * Get the SSL context, which is required for authenticating
         * the client.
         */
        ssl = (SSL*)mg_get_conn_ssl(http_ctx);
        if (!ssl) {
            est_send_http_error(ctx, http_ctx, EST_ERR_NO_SSL_CTX);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_NO_SSL_CTX);
        }

        rc = est_proxy_handle_simple_enroll(ctx, http_ctx, ssl, ct, body, body_len, path_seg, 0);
        if (rc != EST_ERR_NONE && rc != EST_ERR_AUTH_PENDING) {
            EST_LOG_WARN("Enrollment failed with rc=%d (%s)\n", 
		         rc, EST_ERR_NUM_TO_STR(rc));
	    if (rc == EST_ERR_AUTH_FAIL) {
		est_send_http_error(ctx, http_ctx, EST_ERR_AUTH_FAIL);
	    } else {
		est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
	    }
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_BAD_PKCS10);
        }
    }

    /*
     * See if this is a re-enrollment request
     */
    else if (operation == EST_OP_SIMPLE_REENROLL) {
        /* Only POST is allowed */
        safec_rc = strcmp_s(method, MAX_HTTP_METHOD_LEN, "POST", &diff);
        if (safec_rc != EOK) {
            EST_LOG_INFO("strcmp_s error 0x%xO\n", safec_rc);
        }

        if (diff) {
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }
	if (!ct) {
            EST_LOG_WARN("Incoming HTTP header has no Content-Type header\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
            free(path_seg);
            path_seg = NULL;
	    return (EST_ERR_BAD_CONTENT_TYPE); 
	}
        /*
         * In this case body is indicating that no content was passed in, and
         * this is a enroll request.  This cannot be correct because a CSR is
         * required.  If this continues, and we're in proxy mode, we'll try to
         * forward this non-existent CSR
         */
        if (body == NULL) {
            EST_LOG_WARN("Incoming HTTP header has no CSR content.\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_BAD_CONTENT_LEN);
        }
        
        /*
         * Get the SSL context, which is required for authenticating
         * the client.
         */
        ssl = (SSL*)mg_get_conn_ssl(http_ctx);
        if (!ssl) {
            est_send_http_error(ctx, http_ctx, EST_ERR_NO_SSL_CTX);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_NO_SSL_CTX);
        }

        rc = est_proxy_handle_simple_enroll(ctx, http_ctx, ssl, ct, body, body_len, path_seg, 1);
        if (rc != EST_ERR_NONE && rc != EST_ERR_AUTH_PENDING) {
            EST_LOG_WARN("Reenroll failed with rc=%d (%s)\n", 
		         rc, EST_ERR_NUM_TO_STR(rc));
	    if (rc == EST_ERR_AUTH_FAIL) {
		est_send_http_error(ctx, http_ctx, EST_ERR_AUTH_FAIL);
	    } else {
		est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
	    }
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_BAD_PKCS10);
        }
    }

#if 0
    /*
     * See if this is a keygen request
     * FIXME: this is currently not implemented
     */
    else if (strncmp(uri, EST_KEYGEN_URI, EST_URI_MAX_LEN) == 0) {

        /* Only POST is allowed */
        safec_rc = strcmp_s(method, MAX_HTTP_METHOD_LEN, "POST", &diff);
        if (safec_rc != EOK) {
            EST_LOG_INFO("strcmp_s error 0x%xO\n", safec_rc);
        }

        if (diff) {
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            return (EST_ERR_WRONG_METHOD);
        }
	if (!ct) {
            EST_LOG_WARN("Incoming HTTP header has no Content-Type header\n");
	    return (EST_ERR_BAD_CONTENT_TYPE); 
	}
        if (est_proxy_handle_keygen(ctx)) {
            est_send_http_error(ctx, http_ctx, 0); //FIXME: last param should not be zero
            return (EST_ERR_HTTP_WRITE);           //FIXME: need the appropriate return code
        }
    }
#endif

    /*
     * See if this is a CSR attributes request
     */
    else if (operation == EST_OP_CSRATTRS) {
        /* Only GET is allowed */
        safec_rc = strcmp_s(method, MAX_HTTP_METHOD_LEN, "GET", &diff);
        if (safec_rc != EOK) {
            EST_LOG_INFO("strcmp_s error 0x%xO\n", safec_rc);
        }

        if (diff) {
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }
        rc = est_proxy_handle_csr_attrs(ctx, http_ctx, path_seg);
	 if (rc != EST_ERR_NONE) {
            est_send_http_error(ctx, http_ctx, rc); 
            free(path_seg);
            path_seg = NULL;
            return (rc);
        }
    }

    /*
     * Send a 404 error if the URI didn't match 
     */
    else {
        est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NOT_FOUND);
    }

    free(path_seg);
    path_seg = NULL;
    return (EST_ERR_NONE);
}
/*! @brief est_proxy_start() is used by an application to start the EST proxy
    after est_proxy_init() and est_proxy_set_server() have been called and all
    the required callback functions have been provided by the application.

    @param ctx Pointer to the EST context

    libEST uses HTTP code from the Mongoose HTTP server.
    This function allows the application to start the HTTP
    services layer, which is required by EST.
 
    @return EST_ERROR.    
 */
EST_ERROR est_proxy_start (EST_CTX *ctx)
{
    EST_MG_CONTEXT *mgctx;

    if (!ctx) {
	EST_LOG_ERR("Null context");
	return (EST_ERR_NO_CTX);
    }

    mgctx = mg_start(ctx);
    if (mgctx) {
        ctx->mg_ctx = mgctx;
        return (EST_ERR_NONE);
    } else {
        return (EST_ERR_NO_SSL_CTX);
    }
}
/*! @brief est_proxy_stop() is used by an application to stop
    the EST proxy.  This should be called prior to est_destroy().
 
    @param ctx Pointer to the EST context

    libEST uses HTTP code from the Mongoose HTTP server.
    This function allows the application to stop the HTTP
    services layer.
 
    @return EST_ERROR.
 */
EST_ERROR est_proxy_stop (EST_CTX *ctx)
{
    EST_MG_CONTEXT *mgctx;

    if (!ctx) {
	EST_LOG_ERR("Null context");
	return (EST_ERR_NO_CTX);
    }

    mgctx = (EST_MG_CONTEXT*)ctx->mg_ctx;
    if (mgctx) {
        mg_stop(mgctx);
    }
    return (EST_ERR_NONE);
}
/*! @brief est_proxy_init() is used by an application to create
    a context in the EST library.  This context is used when invoking
    other functions in the API while in Proxy mode.
 
    @param ca_chain     Char array containing PEM encoded CA certs & CRL entries.
                        This chain of certificates is used as the trust anchor when
                        establishing a TLS connection.
    @param ca_chain_len Length of ca_chain char array. 
    @param cacerts_resp_chain Char array containing PEM encoded CA certs to
                              include in the /cacerts response.  This is
                              an optional parameter.  If it set, it contains
                              the chain of certificates used by the proxy to
                              respond to GET CA Certs requests from EST Clients.
                              If this parameter is not included, then the proxy
                              will obtain the CA certificate chain from the
                              configured upstream EST server.  If this parameter
                              is not NULL, then the correct length of this
                              buffer must be specified in cacerts_resp_chain_len.
    @param cacerts_resp_chain_len Length of cacerts_resp_chain char array
    @param cert_format Specifies the encoding of the local and external
                       certificate chains (PEM/DER).  
    @param http_realm Char array containing HTTP realm name for HTTP auth
    @param tls_id_cert Pointer to X509 that contains the proxy's certificate
                    for the TLS layer.
    @param tls_id_key Pointer to EVP_PKEY that contains the private key
                   associated with the proxy's certificate.
    @param uid  User ID to use for authenticating with server
    @param pwd  Password to use for authenticating with server

    This function allows an application to initialize an EST server context
    for proxy mode operation, which is used when operating as an RA.  The
    application must provide the trusted CA certificates to use for server
    operation using the ca_chain parameter.  This certificate set should
    include the explicit trust anchor certificate, any number of implicit
    trust anchor certificates, and any intermediate sub-CA certificates
    required to complete the chain of trust between the identity certificate
    passed into the tls_id_cert parameter and the root certificate for that
    identity certificate.  The CA certificates should be encoded using the
    format specified in the cert_format parameter (e.g. PEM) and may contain
    CRL entries that will be used when authenticating EST clients connecting
    to the server.  The applications must also provide the HTTP realm to use
    for HTTP authentication and the server cerificate/private key to use for
    TLS.
    
    Warning: Including additional intermediate sub-CA certificates that are
             not needed to complete the chain of trust may result in a
	     potential MITM attack.  
 
    @return EST_CTX.
 */
EST_CTX * est_proxy_init (unsigned char *ca_chain, int ca_chain_len,
                          unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
			  EST_CERT_FORMAT cert_format,
                          char *http_realm, 
			  X509 *tls_id_cert, EVP_PKEY *tls_id_key,
                          char *uid, char *pwd)
{
    EST_CTX *ctx;
    int len;

    est_log_version();

    /*
     * Sanity check the input
     */
    if (ca_chain == NULL) {
        EST_LOG_ERR("Trusted CA certificate set is empty");
        return NULL;
    }
    if (tls_id_cert == NULL) {
        EST_LOG_ERR("TLS cert is empty");
        return NULL;
    }
    if (tls_id_key == NULL) {
        EST_LOG_ERR("TLS private key is empty");
        return NULL;
    }
    if (http_realm == NULL) {
        EST_LOG_ERR("EST HTTP realm is NULL");
        return NULL;
    }
    if (cert_format != EST_CERT_FORMAT_PEM) {
        EST_LOG_ERR("Only PEM encoding of certificates is supported.");
        return NULL;
    }    

    /*
     * Verify the lengths of the cert chains 
     */
    len = (int) strnlen_s((char *)ca_chain, EST_CA_MAX);
    if (len != ca_chain_len) {
	EST_LOG_ERR("Length of ca_chain doesn't match ca_chain_len");
        return NULL;
    }
    if (cacerts_resp_chain) {    
        len = (int) strnlen_s((char *)cacerts_resp_chain, EST_CA_MAX);
        if (len != cacerts_resp_chain_len) {
            EST_LOG_ERR("Length of cacerts_resp_chain doesn't match cacerts_resp_chain_len");
            return NULL;
        }
    }
    
    /*
     * Allocate and set up the Proxy based EST Context.  This context will be
     * use when operating as the Server to the downstream clients.  EST Proxy mode
     * is basically a server function that requires client capabilities to
     * communicate to the upstream server when needed. 
     */
    ctx = malloc(sizeof(EST_CTX));
    if (!ctx) {
        EST_LOG_ERR("malloc failed");
        return NULL;
    }
    memzero_s(ctx, sizeof(EST_CTX));
    ctx->est_mode = EST_PROXY;
    ctx->retry_period = EST_RETRY_PERIOD_DEF;
    ctx->server_enable_pop = 1;
    ctx->require_http_auth = HTTP_AUTH_REQUIRED;
    ctx->server_read_timeout = EST_SSL_READ_TIMEOUT_DEF;

    if (est_client_set_uid_pw(ctx, uid, pwd) != EST_ERR_NONE) {
        EST_LOG_ERR("Failed to store the userid and password during proxy initialization");
        free(ctx);
        return NULL;
    }        
    
    /*
     * Load the CA certificates into local memory and retain
     * for future use.  This will be used for /cacerts requests.
     */
    if (cacerts_resp_chain) {    
        if (est_load_ca_certs(ctx, cacerts_resp_chain, cacerts_resp_chain_len)) {
            EST_LOG_ERR("Failed to load CA certificates response buffer");
            free(ctx);
            return NULL;
        }
    }
    
    /*
     * Load the CA certificate chain into an X509 store structure
     * This will be used in verifying incoming certs during TLS
     * establishement.
     * Also save a way a raw copy of the ca_chain buffer so that
     * it can be used when creating client contexts used to communincate
     * to the upstream server.
     */
    if (est_load_trusted_certs(ctx, ca_chain, ca_chain_len)) {
        EST_LOG_ERR("Failed to load trusted certificate store");
	est_destroy(ctx);
        return NULL;
    }
    ctx->ca_chain_raw =  malloc(ca_chain_len+1);
    if (!ctx->ca_chain_raw) {
        EST_LOG_ERR("malloc failed");
	est_destroy(ctx);
        return NULL;
    }
    memcpy_s((char *)ctx->ca_chain_raw, ca_chain_len+1, (char *)ca_chain, ca_chain_len);
    ctx->ca_chain_raw[ca_chain_len] = '\0';
    ctx->ca_chain_raw_len = ca_chain_len;
    
    strncpy_s(ctx->realm, MAX_REALM, http_realm, MAX_REALM);
    ctx->server_cert = tls_id_cert;
    ctx->server_priv_key = tls_id_key;
    ctx->auth_mode = AUTH_BASIC;
    ctx->read_timeout = EST_SSL_READ_TIMEOUT_DEF;
    ctx->retry_after_delay = 0;
    ctx->retry_after_date = 0;

    ctx->client_ctx_array = (CLIENT_CTX_LU_NODE_T *) malloc( sizeof(CLIENT_CTX_LU_NODE_T)*cur_max_ctx_array);
    memzero_s(ctx->client_ctx_array, sizeof(CLIENT_CTX_LU_NODE_T)*cur_max_ctx_array);
    
    return (ctx);
}
/*! @brief est_proxy_set_auth_mode() is used by an application layer to
    configure the HTTP authentication method to use for validating the
    identity of an EST client.
 
    @param ctx Pointer to the EST proxy context.  This was returned from
    est_proxy_init().
    @param amode Should be either AUTH_BASIC or AUTH_DIGEST

    This function can optionally be invoked by the application layer to change
    the default HTTP authentication mode.  The default mode is HTTP Basic
    authentication.  An application may desire to use Digest authentication
    instead, in which case this function can be used to set that mode.  This
    function should be invoked prior to starting the EST proxy.

    @return EST_ERROR.
 */
EST_ERROR est_proxy_set_auth_mode (EST_CTX *ctx, EST_HTTP_AUTH_MODE amode)
{
    return(est_server_set_auth_mode(ctx, amode));
}
/*! @brief est_proxy_set_auth_cred_cb() is used by an application to register
  its callback function. 
    
  @param ctx EST context obtained from the est_proxy_init() call.
  @param auth_credentials_cb  Function pointer to the application layer callback

  The registered callback function is used by the EST client library to obtain
  authentication credentials.  The application can provide authentication
  credentials during initialization if they are available, such as the userid
  and password used with HTTP basic authentication.  During the processing of
  a request, the EST client library will call this application callback in the
  event that it does not have the authentication credentials that are being
  requested by the EST server.

  The callback function definition must match the following function
  prototype,

  int (*auth_credentials_cb)(EST_HTTP_AUTH_HDR *auth_credentials);

  auth_credentials - A pointer to a EST_HTTP_AUTH_HDR structure.  The
                     structure is provided by the EST library and the callback
                     function fills in the specific credentials being
                     requested.  These credential values must be passed in the
                     format in which they will be sent to the server, that is,
                     the EST client library will perform no reformatting of
                     these credentials.  Ownership of the memory holding these
                     credential values is transferred from the application
                     layer to the EST library when the application layer
                     returns these values to the EST library.  This allows the
                     EST library to free up this memory as soon as it is done
                     using these values.
                         
  The return value from the callback must be one of the following values:

  EST_HTTP_AUTH_CRED_SUCCESS - If the callback was able to provide the
                               requested credentials.
  EST_HTTP_AUTH_CRED_NOT_AVAILABLE - If the callback could not provide the
                                     requested credentials.

  The auth_credentials_cb parameter can be set to NULL to reset the callback
  function.
  
  All string parameters are NULL terminated strings.
    
  @return EST_ERROR.
  EST_ERR_NONE - Success.
  EST_ERR_NO_CTX
*/
EST_ERROR est_proxy_set_auth_cred_cb (EST_CTX *ctx, auth_credentials_cb callback)
{
    return(est_client_set_auth_cred_cb(ctx, callback));
}
/*! @brief est_proxy_set_read_timeout() is used by an application to set
    timeout value of read operations.  After the EST proxy sends a request to
    the EST server it will attempt to read the response from the server.  This
    timeout value limits the amount of time the proxy will wait for the
    response.

    @param ctx Pointer to the EST context
    @param timeout Integer value representing the read timeout in seconds.
    The minimum value is EST_SSL_READ_TIMEOUT_MIN and the maximum value is
    EST_SSL_READ_TIMEOUT_MAX.
 
    @return EST_ERROR.
 */
EST_ERROR est_proxy_set_read_timeout (EST_CTX *ctx, int timeout)
{
    return(est_client_set_read_timeout(ctx, timeout));
}
/*! @brief est_proxy_set_server() is called by the application layer to
     specify the address/port of the EST server. It must be called after
     est_proxy_init() and prior to issuing any EST commands.
 
    @param ctx Pointer to EST context for a client session
    @param server Name of the EST server to connect to.  The ASCII string
    representing the name of the server is limited to 254 characters
    @param port TCP port on the EST server to connect
 
    @return EST_ERROR
    EST_ERR_NONE - Success.
    EST_ERR_NO_CTX - NULL value passed for EST context
    EST_ERR_INVALID_SERVER_NAME - NULL value passed for EST server name, or
    server name string too long
    EST_ERR_INVALID_PORT_NUM - Invalid port number input, less than zero or
    greater than 65535

    est_proxy_set_server error checks its input parameters and then stores
    both the hostname and port number into the EST context.
 */
EST_ERROR est_proxy_set_server (EST_CTX *ctx, const char *server, int port)
{
    
    if (!ctx) {
        return EST_ERR_NO_CTX;
    }

    if (server == NULL) {
        return EST_ERR_INVALID_SERVER_NAME;
    }
    if (EST_MAX_SERVERNAME_LEN-1 < strnlen_s(server, EST_MAX_SERVERNAME_LEN)) {
        return EST_ERR_INVALID_SERVER_NAME;
    }   
    
    if (port <= 0 || port > 65535) {
        return EST_ERR_INVALID_PORT_NUM;
    }
    
    strncpy_s(ctx->est_server, EST_MAX_SERVERNAME_LEN, server, 
              EST_MAX_SERVERNAME_LEN);
    ctx->est_port_num = port;
    
    return EST_ERR_NONE;
}

LIBEST_TEST_API void est_log (EST_LOG_LEVEL lvl, char *format, ...);
LIBEST_TEST_API void est_log_backtrace (void);
/* From est.c */
char * est_get_tls_uid(SSL *ssl, int is_client);
/* From est.c */
LIBEST_TEST_API EST_ERROR est_load_ca_certs(EST_CTX *ctx, unsigned char *raw, int size);
/* From est.c */
LIBEST_TEST_API EST_ERROR est_load_trusted_certs(EST_CTX *ctx, unsigned char *certs, int certs_len);
/* From est.c */
void est_log(EST_LOG_LEVEL lvl, char *format, ...);
/* From est.c */
LIBEST_TEST_API void est_log_version(void);
/* From est.c */
void est_hex_to_str(char *dst, unsigned char *src, int len);
/* From est.c */
int est_base64_encode (const char *src, int actual_src_len, char *dst, int max_dst_len);
/* From est.c */
LIBEST_TEST_API int est_base64_decode(const char *src, char *dst, int max_len);
/* From est_server.c */
int est_http_request(EST_CTX *ctx, void *http_ctx,
                     char *method, char *uri,
                     char *body, int body_len, const char *ct);
/* From est_client.c */
LIBEST_TEST_API EST_ERROR est_client_connect(EST_CTX *ctx, SSL **ssl);
/* From est_client.c */
int est_client_send_enroll_request(EST_CTX *ctx, SSL *ssl, BUF_MEM *bptr,
                                   unsigned char *pkcs7, int *pkcs7_len,
				   int reenroll);
/* From est_client.c */
LIBEST_TEST_API void est_client_disconnect(EST_CTX *ctx, SSL **ssl);
/* From est_client.c */
LIBEST_TEST_API int est_client_set_cert_and_key(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key);
/* From est_client.c */
EST_ERROR est_client_set_uid_pw(EST_CTX *ctx, const char *uid, const char *pwd);
/* From est_client_http.c */
EST_ERROR est_io_get_response (EST_CTX *ctx, SSL *ssl, EST_OPERATION op,
                         unsigned char **buf, int *payload_len);
/* From est_proxy.c */
LIBEST_TEST_API EST_ERROR est_proxy_http_request(EST_CTX *ctx, void *http_ctx,
                           char *method, char *uri,
                           char *body, int body_len, const char *ct);
/* From est_proxy.c */
void proxy_cleanup(EST_CTX *p_ctx);
/* From est_proxy.c */
EST_ERROR est_asn1_parse_attributes(const char *p, int len, int *offset);
/* From est_proxy.c */
EST_ERROR est_is_challengePassword_present(const char *base64_ptr, int b64_len, int *offset);
/* From est_proxy.c */
EST_ERROR est_add_challengePassword(const char *base64_ptr, int b64_len, char **new_csr, int *pop_len);
/* From est_proxy.c */
LIBEST_TEST_API EST_ERROR est_proxy_retrieve_cacerts (EST_CTX *ctx, unsigned char **cacerts_rtn,
                                      int *cacerts_rtn_len);
/* From est_proxy.c */
EST_ERROR est_send_csrattr_data(EST_CTX *ctx, char *csr_data, int csr_len, void *http_ctx);
/* From est_proxy.c */
void cleanse_auth_credentials(EST_HTTP_AUTH_HDR *auth_cred);
/* From est_proxy.c */
EST_ERROR est_parse_uri (char *uri, EST_OPERATION *operation,
                         char **path_seg);
/* From est_proxy.c */
EST_ERROR est_store_path_segment (EST_CTX *ctx, char *path_segment,
                                  int path_segment_len);
/* From est_proxy.c */
EST_OPERATION est_parse_operation (char *op_path);
/* From est_proxy.c */
int est_strcasecmp_s (char *s1, char *s2);

/** @file */
/*------------------------------------------------------------------
 * est/est.h - Public API for Enrollment over Secure Transport
 *
 * November, 2012
 *
 * Copyright (c) 2012-2014, 2016, 2017 by cisco Systems, Inc.
 * All rights reserved.
 **------------------------------------------------------------------
 */
#ifndef HEADER_EST_H
#define HEADER_EST_H

#ifdef WIN32
#ifdef LIBEST_EXPORTS
#define LIBEST_API __declspec(dllexport) 
#else
#define LIBEST_API __declspec(dllimport) 
#endif
#else
#define LIBEST_API
#endif

#include <openssl/ssl.h>
#include <openssl/engine.h>
#include <openssl/conf.h>
#include <openssl/srp.h>

#ifdef  __cplusplus
extern "C" {
#endif

/*
 * Allow for runtime checking of the path segment support
 */
#ifdef HAVE_URIPARSER
#define PATH_SEGMENT_SUPPORT_ENABLED 1
#endif
    
#define EST_MAX_FILE_LEN    (255)
#define EST_MAX_SERVERNAME_LEN    (255)
#define EST_PORTNUM_LEN          (sizeof(int))
#define EST_MAX_SERVERNAME_AND_PORT_LEN    (EST_MAX_SERVERNAME_LEN+EST_PORTNUM_LEN)
#define EST_MAX_CLIENT_CERT_LEN  (4096)
#define EST_MAX_PATH_SEGMENT_LEN (128)

typedef enum {
    EST_SERVER,
    EST_CLIENT,
    EST_PROXY
} EST_MODE;

    
typedef enum {
    EST_CLIENT_PROXY_NONE = -1,
    EST_CLIENT_PROXY_HTTP_NOTUNNEL = 0,
    EST_CLIENT_PROXY_HTTP_TUNNEL = 1,
    EST_CLIENT_PROXY_SOCKS4 = 4,
    EST_CLIENT_PROXY_SOCKS5 = 5,
    EST_CLIENT_PROXY_SOCKS4A = 6,
    EST_CLIENT_PROXY_SOCKS5_HOSTNAME = 7,
} EST_CLIENT_PROXY_PROTO;
    
/* These values can be ORed together: */
#define EST_CLIENT_PROXY_AUTH_NONE 0
#define EST_CLIENT_PROXY_AUTH_BASIC 1
#define EST_CLIENT_PROXY_AUTH_NTLM 8


#define FOREACH_EST_ERROR(E) \
    E(EST_ERR_NO_CTX) \
    E(EST_ERR_NO_CSR) \
    E(EST_ERR_NO_CERT) \
    E(EST_ERR_NO_KEY) \
    E(EST_ERR_INVALID_PARAMETERS) \
    E(EST_ERR_LOAD_CACERTS) \
    E(EST_ERR_LOAD_TRUST_CERTS) \
    E(EST_ERR_BAD_MODE) \
    E(EST_ERR_BAD_PKCS10) \
    E(EST_ERR_HTTP_WRITE) \
    E(EST_ERR_HTTP_UNSUPPORTED) \
    E(EST_ERR_HTTP_CANNOT_BUILD_HEADER) \
    E(EST_ERR_HTTP_BAD_REQ) \
    E(EST_ERR_HTTP_NOT_FOUND) \
    E(EST_ERR_HTTP_NO_CONTENT) \
    E(EST_ERR_HTTP_LOCKED) \
    E(EST_ERR_HTTP_INVALID_PATH_SEGMENT) \
    E(EST_ERR_HTTP_PATH_SEGMENT_NOT_SUPPORTED) \
    E(EST_ERR_BAD_CONTENT_TYPE) \
    E(EST_ERR_BAD_CONTENT_LEN) \
    E(EST_ERR_NO_SSL_CTX) \
    E(EST_ERR_AUTH_FAIL) \
    E(EST_ERR_AUTH_FAIL_TLSUID) \
    E(EST_ERR_AUTH_PENDING) \
    E(EST_ERR_CA_ENROLL_FAIL) \
    E(EST_ERR_CA_ENROLL_RETRY) \
    E(EST_ERR_WRONG_METHOD) \
    E(EST_ERR_X509_SIGN) \
    E(EST_ERR_X509_VER) \
    E(EST_ERR_X509_CN) \
    E(EST_ERR_X509_ATTR) \
    E(EST_ERR_X509_PUBKEY) \
    E(EST_ERR_MALLOC) \
    E(EST_ERR_SSL_WRITE) \
    E(EST_ERR_SSL_READ) \
    E(EST_ERR_SSL_NEW) \
    E(EST_ERR_SSL_CTX_NEW) \
    E(EST_ERR_SSL_CONNECT) \
    E(EST_ERR_SSL_CIPHER_LIST) \
    E(EST_ERR_PEM_READ) \
    E(EST_ERR_NULL_CALLBACK) \
    E(EST_ERR_IP_GETADDR) \
    E(EST_ERR_IP_CONNECT) \
    E(EST_ERR_INVALID_SERVER_NAME) \
    E(EST_ERR_INVALID_PORT_NUM) \
    E(EST_ERR_CLIENT_INVALID_KEY) \
    E(EST_ERR_CLIENT_NOT_INITIALIZED) \
    E(EST_ERR_ZERO_LENGTH_BUF) \
    E(EST_ERR_READ_BUFFER_TOO_SMALL) \
    E(EST_ERR_BUF_EXCEEDS_MAX_LEN) \
    E(EST_ERR_NO_CERTIFICATE) \
    E(EST_ERR_NO_CERTS_FOUND) \
    E(EST_ERR_FQDN_MISMATCH) \
    E(EST_ERR_SYSCALL) \
    E(EST_ERR_CSR_ALREADY_SIGNED) \
    E(EST_ERR_CSR_ATTR_MISSING) \
    E(EST_ERR_INVALID_DIGEST) \
    E(EST_ERR_CACERT_VERIFICATION) \
    E(EST_ERR_INVALID_TOKEN) \
    E(EST_ERR_INVALID_RETRY_VALUE) \
    E(EST_ERR_BAD_X509) \
    E(EST_ERR_BAD_BASE64) \
    E(EST_ERR_BAD_ASN1_HEX) \
    E(EST_ERR_BAD_ASN1_HEX_TOO_SHORT) \
    E(EST_ERR_BAD_ASN1_HEX_TOO_LONG) \
    E(EST_ERR_SRP_STRENGTH_LOW) \
    E(EST_ERR_SRP_USERID_BAD) \
    E(EST_ERR_SRP_PWD_BAD) \
    E(EST_ERR_CB_FAILED) \
    E(EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED) \
    E(EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL)    \
    E(EST_ERR_INVALID_CLIENT_PROXY_AUTH)    \
    E(EST_ERR_UNKNOWN)

#define GENERATE_ENUM(ENUM) ENUM,
#define GENERATE_STRING(STRING) #STRING,

/*! @enum EST_ERROR
 *  @brief This enum is used to indicate error conditions to the application layer.
 *         Most of the libEST functions return an error indication from this
 *         enumeration.  Applications should always check the returned error
 *         indication and gracefully handle errors.  When no error occurs, libEST
 *         will return EST_ERR_NONE, which has the value zero.
\n
\n EST_ERR_NONE  No error occurred.
\n EST_ERR_NO_CTX  The EST_CTX* was not provided when invoking the function.
\n EST_ERR_NO_CSR  The PKCS10 CSR was not provided when invoking the function.
\n EST_ERR_NO_CERT  No valid X509 certificate was provided when invoking the function.
\n EST_ERR_NO_KEY  The EVP_PKEY* was not provided when invoking the function.
\n EST_ERR_INVALID_PARAMETERS  An invalid argument was provided to the function.
\n EST_ERR_LOAD_CACERTS  The CA certifictes provided were not loaded.
\n EST_ERR_LOAD_TRUST_CERTS  The certificate chain of trusted certificates was not loaded.
\n EST_ERR_BAD_MODE  An EST operation was attempted while using the wrong mode of operation.  The valid modes are client, server, and proxy.  Some EST operations may only be performed in certain modes.
\n EST_ERR_BAD_PKCS10  The PKCS10 CSR received from the client is corrupted.
\n EST_ERR_HTTP_WRITE  An error occurred while writing the HTTP response on the socket. 
\n EST_ERR_HTTP_UNSUPPORTED  The EST server sent an unsupported HTTP status code in the response.
\n EST_ERR_HTTP_CANNOT_BUILD_HEADER  The HTTP header could not be built correctly.
\n EST_ERR_HTTP_BAD_REQ  The HTTP request was bad as reported by the server. 
\n EST_ERR_HTTP_NOT_FOUND  The HTTP requested information that is currently not found on the server. 
\n EST_ERR_HTTP_NO_CONTENT  The content requested is not available.
\n EST_ERR_HTTP_LOCKED  The resource that is being accessed is locked.
\n EST_ERR_HTTP_INVALID_PATH_SEGMENT  The URI path segment passed in is invalid, either too long or contains invalid characters.
\n EST_ERR_HTTP_PATH_SEGMENT_NOT_SUPPORTED  This build of EST does not support the use of an additional path segment in the URI.  EST needs to be rebuilt with the uriparser library to support path segments.
\n EST_ERR_BAD_CONTENT_TYPE  The HTTP content type header in the request was invalid.
\n EST_ERR_BAD_CONTENT_LEN  The HTTP content length header in the request specified a value that was too large.
\n EST_ERR_NO_SSL_CTX  The application did not provide a valid SSL_CTX* reference to the API.
\n EST_ERR_AUTH_FAIL  The EST server was unable to authentication the EST client.
\n EST_ERR_AUTH_FAIL_TLSUID  The authentication failure was due to an invalid challenge password in the PKCS10 CSR.
\n EST_ERR_AUTH_PENDING  An HTTP authentication challenge was sent to the client and the response is yet to arrive.
\n EST_ERR_CA_ENROLL_FAIL  The certificate authority was unable to sign the PKCS10 CSR. 
\n EST_ERR_CA_ENROLL_RETRY  The certificate authority has requested the client to retry the enroll request in the future, likely due to the CA not being configured for automatic enrollment.
\n EST_ERR_WRONG_METHOD  An invalid HTTP method (GET/POST) was used for the request.
\n EST_ERR_X509_SIGN  An error occurred in the OpenSSL library while trying to sign the PKCS10 CSR.
\n EST_ERR_X509_VER  An error occurred in the OpenSSL library while trying to set the version on the PKCS10 CSR.
\n EST_ERR_X509_CN  An error occurred in the OpenSSL library while trying to set the common name in the PKCS10 CSR.
\n EST_ERR_X509_ATTR  An error occurred in the OpenSSL library while trying to set the X509 attributes in the PKCS10 CSR.
\n EST_ERR_X509_PUBKEY  An error occurred in the OpenSSL library while trying to set the public key in the PKCS10 CSR.
\n EST_ERR_MALLOC  Unable to allocation malloc.  This likely indicates a critical failure on the host system.
\n EST_ERR_SSL_WRITE  An error occurred at the TLS layer while trying to write to the socket.
\n EST_ERR_SSL_READ  An error occurred at the TLS layer while trying to read from the socket.
\n EST_ERR_SSL_NEW  An error occurred in the OpenSSL library while trying to allocate the SSL* reference.
\n EST_ERR_SSL_CTX_NEW  An error occurred in the OpenSSL library while trying to allocate the SSL_CTX* reference.
\n EST_ERR_SSL_CONNECT  An error occurred in the OpenSSL library while trying to establish a TLS session with the server.
\n EST_ERR_SSL_CIPHER_LIST  An error occurred in the OpenSSL library while trying to set the allowed TLS cipher suites.
\n EST_ERR_PEM_READ  An error occurred in the OpenSSL library while trying to read the PEM encoded PKCS10 CSR.  This may be due to a corrupted PKCS10.
\n EST_ERR_NULL_CALLBACK  The application layer failed to provide the required callback function for the requested EST operation.
\n EST_ERR_IP_GETADDR  Unable to resolve the server host name.
\n EST_ERR_IP_CONNECT  Unable to connect to requested host/port.
\n EST_ERR_INVALID_SERVER_NAME  The server name provided to libEST was invalid.  It may not be NULL and it may not exceed the maximum server name length.
\n EST_ERR_INVALID_PORT_NUM  The TCP port number provided to libEST was invalid.  It must be greater than 0 and less than 65536.
\n EST_ERR_CLIENT_INVALID_KEY  The certificate and private key provided to libEST could not be loaded.  The private key must match the public key in the certificate.
\n EST_ERR_CLIENT_NOT_INITIALIZED  The application attempted to use a libEST API prior to invoking est_client_init().
\n EST_ERR_ZERO_LENGTH_BUF  The certificate received from the server had an invalid length.
\n EST_ERR_READ_BUFFER_TOO_SMALL  The I/O buffer provided for reading data from the socket is not large enough to receive the response from the server.
\n EST_ERR_BUF_EXCEEDS_MAX_LEN  The EST server sent a cacerts response that exceeded the maximum size allowed.
\n EST_ERR_NO_CERTIFICATE  An attempt was made to copy the certs from the context prior to the EST operation being performed.
\n EST_ERR_NO_CERTS_FOUND  No certificates were found in the trusted certificate list provided to libEST.
\n EST_ERR_FQDN_MISMATCH  The EST server name did not match the fully qualified domain name in the server's X509 certificate.
\n EST_ERR_SYSCALL  The OpenSSL library reported a system call error when attempting to establish the TLS session.
\n EST_ERR_CSR_ALREADY_SIGNED  The PKCS10 CSR provided to libEST already contained a signature.  libEST requires the CSR to not be signed since libEST is responsible for signing the CSR.
\n EST_ERR_CSR_ATTR_MISSING  The PKCS10 CSR received from the EST client does not contain all the required CSR attributes.
\n EST_ERR_INVALID_DIGEST  An invalid digest type was requested.   
\n EST_ERR_CACERT_VERIFICATION  Validation of the CA certificate chain received from the EST server has failed.
\n EST_ERR_INVALID_TOKEN  An invalid authorization token was received.
\n EST_ERR_INVALID_RETRY_VALUE  An invalid or missing retry-after was received from the server.
\n EST_ERR_BAD_X509  An invalid or corrupted X509 certificate was provided to libEST.  
\n EST_ERR_BAD_BASE64  An invalid or corrupted CSR Attribute Base64 encoded string was provided. 
\n EST_ERR_BAD_ASN1_HEX  An invalid or corrupted CSR Attribute ASN1 Hex string was provided.
\n EST_ERR_BAD_ASN1_HEX_TOO_SHORT  A CSR Attribute ASN1 Hex string is too short.
\n EST_ERR_BAD_ASN1_HEX_TOO_LONG  A CSR Attribute ASN1 Hex string is too long.
\n EST_ERR_SRP_STRENGTH_LOW  The SRP strength requested by the application was too small.
\n EST_ERR_SRP_USERID_BAD  The SRP user ID was not accepted.
\n EST_ERR_SRP_PWD_BAD  The SRP password was not accepted.
\n EST_ERR_CB_FAILED  The application layer call-back facility failed.
\n EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED  LibEST was not built with libcurl support.  Libcurl is required for client proxy mode.
\n EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL Invalid proxy protocol specified when configuring client mode for HTTP/Socks proxy.
\n EST_ERR_INVALID_CLIENT_PROXY_AUTH Invalid proxy authentication mode specified when configuring client mode for HTTP/Socks proxy.
\n EST_ERR_LAST  Last error in the enum definition. Should never be used.
*/
typedef enum {
    EST_ERR_NONE = 0,
    FOREACH_EST_ERROR(GENERATE_ENUM)
    EST_ERR_LAST
} EST_ERROR;
LIBEST_API extern const char *EST_ERR_STRINGS[]; 
#define EST_ERR_NUM_TO_STR(x) EST_ERR_STRINGS[x] 

typedef enum {
    AUTH_NONE,
    AUTH_BASIC,
    AUTH_DIGEST,
    AUTH_TOKEN,
    AUTH_FAIL
} EST_HTTP_AUTH_MODE;

typedef enum {
    HTTP_AUTH_NOT_REQUIRED = 0,
    HTTP_AUTH_REQUIRED,
} EST_HTTP_AUTH_REQUIRED;

typedef enum {
    EST_CERT_FORMAT_PEM = 1,
    EST_CERT_FORMAT_DER,
    EST_CERT_FORMAT_MAX
} EST_CERT_FORMAT;

#define EST_FORMAT_PEM EST_CERT_FORMAT_PEM
#define EST_FORMAT_DER EST_CERT_FORMAT_DER
    
/*
 * This enum allows the logging to be filtered to the
 * desired detailed level.  This is not a bitmask filter.  If
 * adding a new logging level, the order should be
 * maintained based on the urgency of the log message.
 */
typedef enum {
    EST_LOG_LVL_ERR = 1,
    EST_LOG_LVL_WARN,
    EST_LOG_LVL_INFO
} EST_LOG_LEVEL;

#define MAX_REALM 255
#define MAX_NONCE 64
#define MAX_UIDPWD 255
#define MAX_NC 9
#define MAX_QOP 10
#define MAX_RESPONSE 64
#define MIN_CSRATTRS 4
#define MAX_CSRATTRS 1024
#define MIN_ASN1_CSRATTRS 2
#define MAX_CSRATTRS_WITHPOP 1035
#define MAX_TOKEN_ERROR (255)
#define MAX_TOKEN_ERROR_DESC (255)
#define MAX_AUTH_TOKEN_LEN (512) 
#define MAX_HTTP_METHOD_LEN (5)

/*
 * The following values define the minimum, maximum, and default
 * values for the timeout value for the SSL read operations.
 * These values are used for both EST Client and Proxy operations.
 */
#define EST_SSL_READ_TIMEOUT_MIN 1
#define EST_SSL_READ_TIMEOUT_MAX 3600
#define EST_SSL_READ_TIMEOUT_DEF 10

/*! @struct EST_HTTP_AUTH_HDR
 *  @brief This structure is used to pass HTTP authentication parameters to
 *         the application.  libEST does not contain a user database
 *         for authenticating users.  It is expected the application will
 *         perform the user authentication against an external authentication
 *         server such as Radius.  This structure allows the HTTP authentication
 *         credentials to be passed from the libEST HTTP layer to
 *         the application.
 *  @var EST_HTTP_AUTH_HDR::mode
 *	Contains the HTTP authentication mode being used (Basic or Digest).
 *  @var EST_HTTP_AUTH_HDR::user
 *	Contains the user ID from the EST client to be authenticated.
 *  @var EST_HTTP_AUTH_HDR::pwd
 *	Contains the password from the EST client to be authenticated
 *	when HTTP basic authentication is used.
 *  @var EST_HTTP_AUTH_HDR::uri
 *	Contains the URI from the EST client for HTTP digest authentication.
 *  @var EST_HTTP_AUTH_HDR::cnonce
 *	Contains the nonce from the EST client for HTTP digest authentication.
 *  @var EST_HTTP_AUTH_HDR::qop
 *	Contains the operation from the EST client for HTTP digest authentication.
 *  @var EST_HTTP_AUTH_HDR::nc
 *	Contains the nonce count from the EST client for HTTP digest authentication.
 *  @var EST_HTTP_AUTH_HDR::nonce
 *	Contains the server nonce for HTTP digest authentication.
 *  @var EST_HTTP_AUTH_HDR::response
 *	Contains the client's digest value to verify.
 *  @var EST_HTTP_AUTH_HDR::auth_token
 *	Contains the client's token value to verify.
 */
typedef struct {
    EST_HTTP_AUTH_MODE mode;
    char *user;
    char *pwd;
    char *uri;
    char *cnonce;
    char *qop;
    char *nc;
    char *nonce;
    char *response;
    char *auth_token;
} EST_HTTP_AUTH_HDR;

/*
 * Defines the valid return codes that the application layer's auth credential
 * callback function can provide.
 */
typedef enum {
    EST_HTTP_AUTH_CRED_SUCCESS = 1,
    EST_HTTP_AUTH_CRED_NOT_AVAILABLE,
} EST_HTTP_AUTH_CRED_RC;
    
        
/*! @struct EST_CTX
 *  @brief This structure is used to maintain the state of EST operations
 *         on behalf of the application.  A single context can be used to
 *         represent a single instance of either an EST client, EST server,
 *         or EST proxy server.  None of the members on this structure
 *         are publically accessible.  Application should use the functions
 *         provided by the libEST API to manage the context.  A context
 *         is created using one of: est_client_init(), est_server_init(),
 *         or est_proxy_init().  When the context is no longer needed,
 *         the application shoud invoke est_destroy() to release all memory
 *         associated with the context.  
 */
typedef struct est_ctx EST_CTX;


/*! @typedef auth_credentials_cb
 *  @brief This typedef defines the prototype of the callback function
 *         that is to reside in the application code.  The application
 *         can register this function callback using the est_client_set_auth_cred_cb()
 *         API function.  This callback is called by the EST client library
 *         when it requires HTTP authentication credentials.
 *         This callback function takes as input a pointer to a EST_HTTP_AUTH_HDR
 *         structure.  The callback function must look at the mode structure
 *         element to determine which type of credentials are required.  If the
 *         mode is set to AUTH_BASIC or AUTH_DIGEST, the callback function must
 *         supply the user and pwd values.  If the mode is set to AUTH_TOKEN, the
 *         the callback must supply the auth_token value.  The auth_token value
 *         must be a base64 encoded string representing the access token.
 */
typedef EST_HTTP_AUTH_CRED_RC (*auth_credentials_cb)(EST_HTTP_AUTH_HDR *auth_credentials);


/*
 * Begin the public API prototypes
 */
LIBEST_API EST_ERROR est_enable_crl(EST_CTX *ctx);
LIBEST_API EST_ERROR est_init_logger(EST_LOG_LEVEL lvl, void (*loggerfunc)(char *, va_list));
LIBEST_API int est_get_api_level(void); 
LIBEST_API const char * est_get_version(void); 
LIBEST_API void est_enable_backtrace(int enable);
LIBEST_API EST_ERROR est_set_ex_data(EST_CTX *ctx, void *ex_data);
LIBEST_API void * est_get_ex_data(EST_CTX *ctx);
LIBEST_API EST_CTX * est_server_init(unsigned char *ca_chain, int ca_chain_len,
                          unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
			  EST_CERT_FORMAT cert_format,
                          char *http_realm, X509 *tls_cert,
                          EVP_PKEY *tls_key);
LIBEST_API EST_CTX * est_proxy_init(unsigned char *ca_chain, int ca_chain_len,
                         unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
			 EST_CERT_FORMAT cert_format,
                         char *http_realm, X509 *tls_cert,
                         EVP_PKEY *tls_key,
                         char *uid, char *pwd);
LIBEST_API EST_ERROR est_destroy(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_set_auth_mode(EST_CTX *ctx, EST_HTTP_AUTH_MODE amode);
LIBEST_API char *est_server_generate_auth_digest(EST_HTTP_AUTH_HDR *ah, char *HA1);
LIBEST_API EST_ERROR est_server_start(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_stop(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_enable_tls10(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_enable_srp(EST_CTX *ctx, int (*cb)(SSL *s, int *ad, void *arg));
LIBEST_API EST_ERROR est_server_enable_pop(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_disable_pop(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_handle_request(EST_CTX *ctx, int fd);
LIBEST_API EST_ERROR est_server_set_dh_parms(EST_CTX *ctx, DH *dh);
LIBEST_API EST_ERROR est_server_init_csrattrs(EST_CTX *ctx, char *csrattrs, int crsattrs_len);
LIBEST_API EST_ERROR est_server_set_retry_period(EST_CTX *ctx, int seconds);
LIBEST_API EST_ERROR est_server_set_ecdhe_curve(EST_CTX *ctx, int nid);
LIBEST_API EST_ERROR est_server_enforce_csrattr(EST_CTX *ctx);
LIBEST_API EST_ERROR est_server_set_read_timeout (EST_CTX *ctx, int timeout);
    
/*
 * EST proxy specific functions
 */
LIBEST_API EST_ERROR est_proxy_start(EST_CTX *ctx);
LIBEST_API EST_ERROR est_proxy_stop(EST_CTX *ctx);
LIBEST_API EST_ERROR est_proxy_set_server(EST_CTX *ctx, const char *server, int port);
LIBEST_API EST_ERROR est_proxy_set_auth_mode(EST_CTX *ctx, EST_HTTP_AUTH_MODE amode);
LIBEST_API EST_ERROR est_proxy_set_read_timeout(EST_CTX *ctx, int timeout);
LIBEST_API EST_ERROR est_proxy_set_auth_cred_cb(EST_CTX *ctx, auth_credentials_cb);

/*
 * The following functions are used by an EST client
 */
LIBEST_API EST_CTX *est_client_init(unsigned char *ca_chain, int ca_chain_len,
                         EST_CERT_FORMAT cert_format,
                         int (*cert_verify_cb)(X509 *, int));
LIBEST_API EST_ERROR est_client_set_auth(EST_CTX *ctx, const char *uid, const char *pwd,
                              X509 *client_cert, EVP_PKEY *private_key);
LIBEST_API EST_ERROR est_client_set_auth_cred_cb(EST_CTX *ctx, auth_credentials_cb);
LIBEST_API EST_ERROR est_client_set_server(EST_CTX *ctx, const char *server, int port, char *path_segment);
LIBEST_API EST_ERROR est_client_set_proxy(EST_CTX *ctx,
                                          EST_CLIENT_PROXY_PROTO proxy_proto,
                                          const char *proxy_server,
                                          unsigned short int proxy_port,
                                          unsigned int proxy_auth,
                                          const char *username,
                                          const char *password);    
LIBEST_API EST_ERROR est_client_provision_cert(EST_CTX *ctx, char *cn, 
	                            int *pkcs7_len,
				    int *ca_cert_len,
                                    EVP_PKEY *new_public_key);
LIBEST_API EST_ERROR est_client_enroll(EST_CTX *ctx, char *cn, int *pkcs7_len,
                            EVP_PKEY *new_public_key);
LIBEST_API EST_ERROR est_client_enroll_csr(EST_CTX *ctx, X509_REQ *csr, int *pkcs7_len, EVP_PKEY *priv_key);
LIBEST_API EST_ERROR est_client_reenroll(EST_CTX *ctx, X509 *cert, int *pkcs7_len, EVP_PKEY *priv_key);
LIBEST_API EST_ERROR est_client_copy_enrolled_cert(EST_CTX *ctx, unsigned char *pkcs7);
LIBEST_API EST_ERROR est_client_get_csrattrs(EST_CTX *ctx, unsigned char **csr_data, int *csr_len);
LIBEST_API EST_ERROR est_client_get_cacerts(EST_CTX *ctx, int *ca_certs_len);
LIBEST_API EST_ERROR est_client_copy_cacerts(EST_CTX *ctx, unsigned char *ca_certs);
LIBEST_API EST_ERROR est_client_set_sign_digest(EST_CTX *ctx, int nid); 
LIBEST_API EST_ERROR est_client_copy_retry_after(EST_CTX *ctx, int *retry_delay,
                                       time_t *retry_time);
LIBEST_API EST_ERROR est_client_set_read_timeout(EST_CTX *ctx, int timeout);
LIBEST_API EST_ERROR est_client_enable_basic_auth_hint(EST_CTX *ctx);
LIBEST_API EST_ERROR est_client_force_pop(EST_CTX *ctx);
LIBEST_API EST_ERROR est_client_unforce_pop(EST_CTX *ctx);
LIBEST_API EST_ERROR est_client_enable_srp(EST_CTX *ctx, int strength, char *uid, char *pwd); 
LIBEST_API int est_client_get_last_http_status(EST_CTX *ctx);

/*
 * The following callback entry points must be set by the application
 * when acting as an EST server or proxy.
 */
LIBEST_API EST_ERROR est_set_ca_enroll_cb(EST_CTX *ctx, int (*cb)(unsigned char * pkcs10, int p10_len,
                                                       unsigned char **pkcs7, int *pkcs7_len, 
                                                       char *user_id, X509 *peer_cert,
                                                       char *path_seg, void *ex_data));
LIBEST_API EST_ERROR est_set_ca_reenroll_cb(EST_CTX *ctx, int (*cb)(unsigned char * pkcs10, int p10_len,
                                                         unsigned char **pkcs7, int *pkcs7_len, 
                                                         char *user_id, X509 *peer_cert,
                                                         char *path_seg, void *ex_data));
LIBEST_API EST_ERROR est_set_csr_cb(EST_CTX * ctx, unsigned char *(*cb)(int*csr_len, char *path_seg, void *ex_data));
LIBEST_API EST_ERROR est_set_cacerts_cb(EST_CTX * ctx, unsigned char *(*cb)(int*csr_len, char *path_seg, void *ex_data));
LIBEST_API EST_ERROR est_set_http_auth_cb(EST_CTX * ctx,
                                          int (*cb)(EST_CTX*, EST_HTTP_AUTH_HDR*,
                                                    X509*, char *, void*));

    
LIBEST_API EST_ERROR est_set_http_auth_required(EST_CTX * ctx, EST_HTTP_AUTH_REQUIRED required);
LIBEST_API EST_ERROR est_add_attributes_helper(X509_REQ *req, int nid, void *string, int chtype);
LIBEST_API EST_ERROR est_get_attributes_helper(unsigned char **der_ptr, int *der_len, int *new_nid);
LIBEST_API EST_ERROR est_decode_attributes_helper(char *csrattrs, int csrattrs_len, 
  				       unsigned char **der_ptr, int *der_len);

/*
 * The following are helper functions to deal with
 * the OpenSSL data types for certs, keys, etc.
 */
LIBEST_API X509_REQ *est_read_x509_request(unsigned char *csr, int csr_len,
	                         EST_CERT_FORMAT csr_format);
LIBEST_API EVP_PKEY *est_load_key(unsigned char *key, int key_len, int format);
LIBEST_API int est_convert_p7b64_to_pem(unsigned char *certs_p7, int certs_len, unsigned char **pem);

/*
 * These are helper macros that an application can use
 * to initialize/de-initialize OpenSSL.  
 */
/*! @brief est_apps_startup() is used by an application to initialize 
    the OpenSSL library.  This should be called first prior to using
    any other functions in the libEST API. This is a helper function which invokes
    CRYPTO_malloc_init(), ERR_load_crypto_strings(), OpenSSL_add_all_algorithms(),
    ENGINE_load_builtin_engines(), SSL_library_init(), and SSL_load_error_strings().
 
    @return void.
 */
#define est_apps_startup() \
    do { CRYPTO_malloc_init(); \
         ERR_load_crypto_strings(); OpenSSL_add_all_algorithms(); \
         ENGINE_load_builtin_engines(); \
         SSL_library_init(); \
         SSL_load_error_strings(); } while (0)

/*! @brief est_apps_shutdown() is used by an application to de-initialize 
    the OpenSSL library.  This should be called to prevent memory
    leaks in the OpenSSL library.  This is a helper function which invokes
    CONF_modules_unload(), OBJ_cleanup(), EVP_cleanup(), ENGINE_cleanup(),
    CRYPTO_cleanup_all_ex_data(), ERR_remove_thread_state(), and
    ERR_free_strings().
 
    @return void.
 */
#define est_apps_shutdown() \
    do { CONF_modules_unload(1); \
         OBJ_cleanup(); EVP_cleanup(); ENGINE_cleanup(); \
         CRYPTO_cleanup_all_ex_data(); ERR_remove_thread_state(NULL); \
         ERR_free_strings(); } while (0)

#ifdef __cplusplus
}
#endif

#endif


/*****************************************************************************************
* Authorization routines
*****************************************************************************************/
int ossl_verify_cb (int ok, X509_STORE_CTX *ctx)
{
    int cert_error = X509_STORE_CTX_get_error(ctx);
    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);

    EST_LOG_INFO("enter function: ok=%d cert_error=%d", ok, cert_error);

    if (!ok) {
        if (current_cert) {
            X509_NAME_print_ex_fp(stdout,
                                  X509_get_subject_name(current_cert),
                                  0, XN_FLAG_ONELINE);
            printf("\n");
        }
        EST_LOG_INFO("%serror %d at %d depth lookup:%s\n",
                     X509_STORE_CTX_get0_parent_ctx(ctx) ? "[CRL path]" : "",
                     cert_error,
                     X509_STORE_CTX_get_error_depth(ctx),
                     X509_verify_cert_error_string(cert_error));
        switch (cert_error) {
        case X509_V_ERR_UNABLE_TO_GET_CRL:
            /*
             * We've enabled CRL checking in the TLS stack.  If
             * the application hasn't loaded a CRL, then this
             * verify error can occur.  The peer's cert is valid,
             * but we can't confirm if it was revoked.  We'll
             * warn the application.
             */
            EST_LOG_WARN("No CRL loaded, TLS peer will be allowed.");
            ok = 1;
            break;
        case X509_V_ERR_NO_EXPLICIT_POLICY:
        case X509_V_ERR_CERT_HAS_EXPIRED:

        /* since we are just checking the certificates, it is
         * ok if they are self signed. But we should still warn
         * the user.
         */

        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
        /* Continue after extension errors too */
        case X509_V_ERR_INVALID_CA:
        case X509_V_ERR_INVALID_NON_CA:
        case X509_V_ERR_PATH_LENGTH_EXCEEDED:
        case X509_V_ERR_INVALID_PURPOSE:
        case X509_V_ERR_CRL_HAS_EXPIRED:
        case X509_V_ERR_CRL_NOT_YET_VALID:
        case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
        case X509_V_ERR_CERT_REVOKED:
        default:
            EST_LOG_WARN("Certificate verify failed (reason=%d)",
                         cert_error);
            break;
        }
        return ok;
    }
    return (ok);
}
/*
 * This function is used to load an X509_STORE using raw
 * data from a buffer.  The data is expected to be PEM
 * encoded.
 *
 * Returns the number of certs added to the store
 */
static int ossl_init_cert_store_from_raw (X509_STORE *store,
                                           unsigned char *raw, int size)
{
    STACK_OF(X509_INFO) * sk = NULL;
    X509_INFO *xi;
    BIO *in;
    int cert_cnt = 0;

    in = BIO_new_mem_buf(raw, size);
    if (in == NULL) {
        EST_LOG_ERR("Unable to open the raw CA cert buffer\n");
        return 0;
    }

    /* This loads from a file, a stack of x509/crl/pkey sets */
    sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL);
    if (sk == NULL) {
        EST_LOG_ERR("Unable to read PEM encoded certs from BIO");
        BIO_free(in);
        return 0;
    }
    BIO_free(in);

    /* scan over it and pull out the CRL's */
    while (sk_X509_INFO_num(sk)) {
        xi = sk_X509_INFO_shift(sk);
        if (xi->x509 != NULL) {
            EST_LOG_INFO("Adding cert to store (%s)", xi->x509->name);
            X509_STORE_add_cert(store, xi->x509);
	    cert_cnt++;
        }
        if (xi->crl != NULL) {
            EST_LOG_INFO("Adding CRL to store");
            X509_STORE_add_crl(store, xi->crl);
        }
        X509_INFO_free(xi);
    }

    if (sk != NULL) {
        sk_X509_INFO_pop_free(sk, X509_INFO_free);
    }
    return (cert_cnt);
}
/*
 * This function is used to populate an X509_STORE structure,
 * which can be used by the OpenSSL TLS stack to verifying
 * a TLS peer.  The X509_STORE should already have been allocated.
 *
 * Parameters:
 *  store   - Pointer to X509_STORE structure to hold the certs
 *  raw1    - char array containing PEM encoded certs to put
 *            into the store.
 *  size1   - Length of the raw1 char array
 */
EST_ERROR ossl_init_cert_store (X509_STORE *store,
                                unsigned char *raw1, int size1)
{
    X509_STORE_set_flags(store, 0);
    int cnt;

    if (raw1) {
        cnt = ossl_init_cert_store_from_raw(store, raw1, size1);
	if (!cnt) {
	    EST_LOG_ERR("Cert count is zero for store");
	    return (EST_ERR_NO_CERTS_FOUND);
	}
    }
    return (EST_ERR_NONE);
}
/*
 * This function can be used to output the OpenSSL
 * error buffer.  This is useful when an OpenSSL
 * API call fails and you'd like to provide some
 * detail to the user regarding the cause of the
 * failure.
 */
void ossl_dump_ssl_errors ()
{
    BIO		*e = NULL;
    BUF_MEM	*bptr = NULL;

    e = BIO_new(BIO_s_mem());
    if (!e) {
	EST_LOG_ERR("BIO_new failed");
	return;
    }
    ERR_print_errors(e);
    (void)BIO_flush(e);
    BIO_get_mem_ptr(e, &bptr);
    EST_LOG_WARN("OSSL error: %s", bptr->data); 
    BIO_free_all(e);
}
/*! @brief est_convert_p7b64_to_pem() converts the base64 encoded
    PKCS7 response from the EST server into PEM format.   
 
    @param certs_p7 Points to a buffer containing the base64 encoded pkcs7 data.
    @param certs_len Indicates the size of the *certs_p7 buffer.
    @param pem Double pointer that will receive the PEM encoded data. 
 
    Several of the EST message return data that contains base64 encoded PKCS7
    certificates.  This function is used to convert the data to PEM format.
    This function will allocate memory pointed to by the **pem argument.
    The caller is responsible for releasing this memory.  The return value
    is the length of the PEM buffer, or -1 on error.
 
    @return int.
 */
int est_convert_p7b64_to_pem (unsigned char *certs_p7, int certs_len, unsigned char **pem)
{
    X509 *x;
    STACK_OF(X509) *certs = NULL;
    BIO *b64, *in, *out;
    unsigned char *cacerts_decoded = NULL;
    int  cacerts_decoded_len = 0;
    BIO *p7bio_in = NULL;
    PKCS7 *p7=NULL;
    int i, nid;
    unsigned char *pem_data;
    int pem_len;

    /*
     * Base64 decode the incoming ca certs buffer.  Decoding will
     * always take up no more than the original buffer.
     */
    b64 = BIO_new(BIO_f_base64());
    if (!b64) {
	EST_LOG_ERR("BIO_new failed");
	return (-1);
    }    
    in = BIO_new_mem_buf(certs_p7, certs_len);    
    if (!in) {
	EST_LOG_ERR("BIO_new failed");
	return (-1);
    }
    in = BIO_push(b64, in);    
    cacerts_decoded = malloc(certs_len);
    if (!cacerts_decoded) {
	EST_LOG_ERR("malloc failed");
	return (-1);
    }
    cacerts_decoded_len = BIO_read(in, cacerts_decoded, certs_len);    
    BIO_free_all(in);
    /*
     * Now get the PKCS7 formatted buffer of certificates read into a stack of
     * X509 certs
     */
    p7bio_in = BIO_new_mem_buf(cacerts_decoded, cacerts_decoded_len);
    if (!p7bio_in) {
        EST_LOG_ERR("BIO_new failed while attempting to create mem BIO");
        ossl_dump_ssl_errors();
        free(cacerts_decoded);
        return (-1);
    }
    p7 = d2i_PKCS7_bio(p7bio_in, NULL);
    if (!p7) {
	EST_LOG_ERR("PEM_read_bio_PKCS7 failed");
	ossl_dump_ssl_errors();
        free(cacerts_decoded);
	return (-1);
    }
    BIO_free_all(p7bio_in);
    free(cacerts_decoded);
    
    /*
     * Now that we've decoded the certs, get a reference
     * the the stack of certs
     */
    nid=OBJ_obj2nid(p7->type);
    switch (nid)
        {
        case NID_pkcs7_signed:
            certs = p7->d.sign->cert;
            break;
        case NID_pkcs7_signedAndEnveloped:
            certs = p7->d.signed_and_enveloped->cert;
            break;
        default:
            EST_LOG_ERR("Invalid NID value on PKCS7 structure");
	    PKCS7_free(p7);
	    return (-1);
            break;
        }

    if (!certs) {
        EST_LOG_ERR("Failed to attain X509 cert stack from PKCS7 data");
	PKCS7_free(p7);
	return (-1);
    }

    /*
     * Output the certs to a new BIO using the PEM format 
     */
    out = BIO_new(BIO_s_mem());
    if (!out) {
        EST_LOG_ERR("BIO_new failed");
	PKCS7_free(p7);
	return (-1);
    }
    for (i=0; i<sk_X509_num(certs); i++) {
        x=sk_X509_value(certs, i);
	PEM_write_bio_X509(out, x);
	BIO_puts(out, "\n");
    }
    (void)BIO_flush(out);

    /*
     * Now convert the BIO to char*
     */
    pem_len = (int) BIO_get_mem_data(out, (char**)&pem_data);
    if (pem_len <= 0) {
        EST_LOG_ERR("BIO_get_mem_data failed");
	PKCS7_free(p7);
	return (-1);
    }

    *pem = malloc(pem_len + 1);
    if (!*pem) {
        EST_LOG_ERR("malloc failed");
	PKCS7_free(p7);
	return (-1);
    }
    memcpy_s(*pem, pem_len, pem_data, pem_len);   
    (*pem)[pem_len] = 0;  //Make sure it's null termianted
    BIO_free_all(out);
    PKCS7_free(p7);
    return (pem_len);
}

/*
 * This function sends EST specific HTTP error responses.
 */
void est_send_http_error (EST_CTX *ctx, void *http_ctx, int fail_code)
{
    struct mg_connection *conn = (struct mg_connection*)http_ctx;

    switch (fail_code) {
    case EST_ERR_BAD_PKCS10:
	mg_send_http_error(conn, EST_HTTP_STAT_400, EST_HTTP_STAT_400_TXT, EST_BODY_BAD_PKCS10);
        break;
    case EST_ERR_AUTH_FAIL:
	mg_send_http_error(conn, EST_HTTP_STAT_401, EST_HTTP_STAT_401_TXT, EST_BODY_UNAUTHORIZED);
        break;
    case EST_ERR_WRONG_METHOD:
	mg_send_http_error(conn, EST_HTTP_STAT_400, EST_HTTP_STAT_400_TXT, EST_BODY_BAD_METH);
        break;
    case EST_ERR_NO_SSL_CTX:
	mg_send_http_error(conn, EST_HTTP_STAT_400, EST_HTTP_STAT_400_TXT, EST_BODY_BAD_SSL);
        break;
    case EST_ERR_HTTP_NOT_FOUND:
	mg_send_http_error(conn, EST_HTTP_STAT_404, EST_HTTP_STAT_404_TXT, EST_BODY_NOT_FOUND);
        break;
    case EST_ERR_HTTP_NO_CONTENT:
	mg_send_http_error(conn, EST_HTTP_STAT_204, EST_HTTP_STAT_204_TXT, "");
        break;
    default:
	mg_send_http_error(conn, EST_HTTP_STAT_400, EST_HTTP_STAT_400_TXT, EST_BODY_UNKNOWN_ERR);
        break;
    }
}
/*
 * This function sends a HTTP 202 Accepted response to the 
 * client with the retry-after value from the CA. This
 * notifies the client that it should check back later to
 * see if the CSR was approved.
 */
EST_ERROR est_server_send_http_retry_after (EST_CTX *ctx, void *http_ctx, int delay)
{
    char http_hdr[EST_HTTP_HDR_MAX];
    struct mg_connection *conn = (struct mg_connection*)http_ctx;

    snprintf(http_hdr, EST_HTTP_HDR_MAX, "%s%s%s%s%s: %d%s%s", 
	EST_HTTP_HDR_202,
        EST_HTTP_HDR_EOL, 
	EST_HTTP_HDR_STAT_202, 
	EST_HTTP_HDR_EOL,
	EST_HTTP_HDR_RETRY_AFTER, 
	delay, 
	EST_HTTP_HDR_EOL, 
	EST_HTTP_HDR_EOL);

    conn->status_code = EST_HTTP_STAT_202;
    if (!mg_write(http_ctx, http_hdr, strnlen_s(http_hdr, EST_HTTP_HDR_MAX))) {
        EST_LOG_ERR("HTTP write error while propagating retry-after");
        return (EST_ERR_HTTP_WRITE);
    }
    return (EST_ERR_NONE);
}
/*
 * This function handles an incoming cacerts request from
 * the client.
 */
int est_handle_cacerts (EST_CTX *ctx, unsigned char *ca_certs, int ca_certs_len,
                        void *http_ctx, char *path_seg)
{
    char http_hdr[EST_HTTP_HDR_MAX];
    int hdrlen;    
    
    if (ca_certs  == NULL) {
        return (EST_ERR_HTTP_NOT_FOUND);
    }
        
    /*
     * Send HTTP header
     */
    snprintf(http_hdr, EST_HTTP_HDR_MAX, "%s%s%s%s", EST_HTTP_HDR_200, EST_HTTP_HDR_EOL,
             EST_HTTP_HDR_STAT_200, EST_HTTP_HDR_EOL);
    hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
    snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CT,
             EST_HTTP_CT_PKCS7, EST_HTTP_HDR_EOL);
    hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
    snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CE,
             EST_HTTP_CE_BASE64, EST_HTTP_HDR_EOL);
    hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
    snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %d%s%s", EST_HTTP_HDR_CL,
             ca_certs_len, EST_HTTP_HDR_EOL, EST_HTTP_HDR_EOL);
    if (!mg_write(http_ctx, http_hdr, strnlen_s(http_hdr, EST_HTTP_HDR_MAX))) {
        return (EST_ERR_HTTP_WRITE);
    }

    /*
     * Send the CA certs in the body
     */
    if (!mg_write(http_ctx, ca_certs, ca_certs_len)) {
        return (EST_ERR_HTTP_WRITE);
    }

    EST_LOG_INFO("CA certs successfully sent to EST client");
    return (EST_ERR_NONE);
}
/*
 * Handle a CA certs request.  If the application layer has
 * registered a callback then call it.  Else, if the application
 * layer has provided a locally configured buffer then send it.
 * Else, return an error indicating that there are no CA Certs
 * available.
 */
static int est_server_handle_cacerts (EST_CTX *ctx, void *http_ctx,
                                      char *path_seg)
{
    EST_ERROR rv;
    int ca_certs_len;
    unsigned char *ca_certs;

    /*
     * If there is a call back set then call it.
     * otherwise, if there is a locally configured cacerts buffer,
     * then return that.
     * otherwise, return an error indicating that we don't have any cacerts
     */
    if (ctx->est_get_cacerts_cb) {

        EST_LOG_INFO("Server: Retrieving CA certs from application layer");
        ca_certs = ctx->est_get_cacerts_cb(&ca_certs_len, path_seg,ctx->ex_data);
        if (ca_certs) {

            EST_LOG_INFO("Server: Successfully retrieved CA certs from "
                         "application layer");
            rv = est_handle_cacerts(ctx, ca_certs, ca_certs_len, http_ctx,
                                    path_seg);
        } else {
            est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
            rv = EST_ERR_NONE;
        }
    } else if (ctx->ca_certs) {
        
        EST_LOG_INFO("Server: CA certs set locally, responding with "
                     "locally set CA certs response");
        rv = est_handle_cacerts(ctx, ctx->ca_certs, ctx->ca_certs_len,
                                      http_ctx, path_seg);
    } else {
        
        est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
        rv = EST_ERR_NONE;
    }
    return (rv);
}
/*! @brief est_server_generate_auth_digest() is used by an application 
    to calculate the HTTP Digest value based on the header values
    provided by an EST client.  
 
    @param ah Authentication header values from client, provided by libEST
    @param HA1 The precalculated HA1 value for the user.  HA1 is defined in
           RFC 2617.  It's the MD5 calculation of the user's ID, HTTP realm,
	   and the user's password.

    This is a helper function that an application can use to calculate
    the HTTP Digest value when performing HTTP Digest Authentication
    of an EST client.  libEST does not maintain a user database. 
    This is left up to the application, with the intent of integrating  
    an external user database (e.g. Radius/AAA).
    
    The HA1 value should be calculated by the application as
    defined in RFC 2617.  HA1 is the MD5 hash of the user ID, HTTP realm,
    and user password.  This MD5 value is then converted to a hex string.
    HA1 is expected to be 32 bytes long.
 
    @return char* containing the digest, or NULL if an error occurred.
 */
char *est_server_generate_auth_digest (EST_HTTP_AUTH_HDR *ah, char *HA1)
{
    EVP_MD_CTX *mdctx;
    const EVP_MD *md = EVP_md5();
    uint8_t ha2[EVP_MAX_MD_SIZE];
    unsigned int ha2_len;
    char ha2_str[33];
    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int d_len;
    char *rv;

    if (!ah) {
	EST_LOG_ERR("Null auth header");
        return (NULL);
    }

    if (!HA1) {
	EST_LOG_ERR("Null HA1");
        return (NULL);
    }

    /*
     * Calculate HA2 using method, URI,
     */
    mdctx = EVP_MD_CTX_create();
    EVP_DigestInit_ex(mdctx, md, NULL);
    EVP_DigestUpdate(mdctx, "POST", 4); 
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ah->uri, strnlen_s(ah->uri, MAX_REALM));
    EVP_DigestFinal(mdctx, ha2, &ha2_len);
    EVP_MD_CTX_destroy(mdctx);
    est_hex_to_str(ha2_str, ha2, ha2_len);

    /*
     * Calculate auth digest using HA1, nonce, nonce count, client nonce, qop, HA2
     */
    mdctx = EVP_MD_CTX_create();
    EVP_DigestInit_ex(mdctx, md, NULL);
    EVP_DigestUpdate(mdctx, HA1, 32); 
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ah->nonce, strnlen_s(ah->nonce, MAX_NONCE));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ah->nc, strnlen_s(ah->nc, MAX_NC));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ah->cnonce, strnlen_s(ah->cnonce, MAX_NONCE));
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, "auth", 4);
    EVP_DigestUpdate(mdctx, ":", 1);
    EVP_DigestUpdate(mdctx, ha2_str, ha2_len * 2);
    EVP_DigestFinal(mdctx, digest, &d_len);
    EVP_MD_CTX_destroy(mdctx);

    rv = malloc(33);
    est_hex_to_str(rv, digest, d_len);
    return (rv);
}
/*
 * This function allocates an HTTP authentication header
 * structure, which is used to pass the auth credentials
 * to the application layer to allow the app to authenticate
 * an EST client.
 */
static EST_HTTP_AUTH_HDR * est_create_ah()
{
    EST_HTTP_AUTH_HDR *ah;

    ah = malloc(sizeof(EST_HTTP_AUTH_HDR));
    memzero_s(ah, sizeof(EST_HTTP_AUTH_HDR));
    return (ah);
}
/*
 * This function frees all the elements on an HTTP
 * authentication header structure.
 */
static void est_destroy_ah(EST_HTTP_AUTH_HDR *ah)
{
    int len;

    if (!ah) return;
    if (ah->user) free(ah->user);
    if (ah->pwd) {
	/*
	 * Get the length of the password so it can be zeroized 
	 */
	len = strnlen_s(ah->pwd, MAX_UIDPWD);
	if (len) {
	    memzero_s(ah->pwd, len);
	}
	free(ah->pwd);
    }
    if (ah->uri) free(ah->uri);
    if (ah->cnonce) free(ah->cnonce);
    if (ah->qop) free(ah->qop);
    if (ah->nc) free(ah->nc);
    if (ah->nonce) free(ah->nonce);
    if (ah->response) free(ah->response);
    if (ah->auth_token) {
	len = strnlen_s(ah->auth_token, MAX_AUTH_TOKEN_LEN);
	if (len) {
	    memzero_s(ah->auth_token, len);
	}
	free(ah->auth_token);
    }
    free(ah);
}
/*
 * This function verifies that the peer either provided a certificate
 * that was verifed by the TLS stack, or HTTP authentication
 * credentials were provided. 
 *
 * Returns a EST_AUTH_STATE authorization result 
 */
EST_AUTH_STATE est_enroll_auth (EST_CTX *ctx, void *http_ctx, SSL *ssl,
	                        char *path_seg, int reenroll)
{
    EST_AUTH_STATE rv = EST_UNAUTHORIZED;
    X509 *peer = NULL;
    struct mg_connection *conn = (struct mg_connection*)http_ctx;
    EST_HTTP_AUTH_HDR *ah;
    EST_HTTP_AUTH_HDR_RESULT pr;
    int v_result;

    /*
     * Get client certificate from TLS stack.  
     */
    if ((peer = SSL_get_peer_certificate(ssl)) != NULL) {
        // check TLS based client authorization (is client cert authorized)
        v_result = (int) SSL_get_verify_result(ssl);
        if (X509_V_OK == v_result) {
            EST_LOG_INFO("TLS: client certificate is valid");
	    rv = EST_CERT_AUTH;
	}
	else if (X509_V_ERR_UNABLE_TO_GET_CRL == v_result) {
            EST_LOG_WARN("Peer cert is valid, but no CRL was loaded. Unable to determine if peer cert is revoked.");
	    rv = EST_CERT_AUTH;
        } else {
            EST_LOG_INFO("TLS: client certificate not verified (v_result=%d)",
		         v_result);
	    /* We need to bail since the client is using a bogus cert,
	     * no need to contiue with HTTP authentication below */
	    X509_free(peer);
	    return(EST_UNAUTHORIZED);
        }
    } else {
        EST_LOG_INFO("TLS: no peer certificate");
	rv = EST_UNAUTHORIZED;
    }

    /*
     * See if SRP is being used.  If so, there will be no
     * certificate.
     */
    if (rv != EST_CERT_AUTH && SSL_get_srp_username(ssl) != NULL) {
        EST_LOG_INFO("TLS: no certificate from client, SRP login is %s",
		SSL_get_srp_username(ssl));
	rv = EST_SRP_AUTH;
    }

    /*
     * If the application layer has enabled HTTP authentication we
     * will attempt HTTP authentication when TLS client auth fails
     * or when the require_http_auth flag is set by the application.
     * All this assumes the application layer has provided the HTTP auth
     * callback facility.
     */
    if (ctx->est_http_auth_cb && 
	(rv == EST_UNAUTHORIZED || HTTP_AUTH_REQUIRED == ctx->require_http_auth)) {
        /*
         * Try HTTP authentication.
         */
	ah = est_create_ah();
        pr = mg_parse_auth_header(conn, ah);
	switch (pr) {
        case EST_AUTH_HDR_GOOD:
	    /*
	     * Invoke the application specific auth check now 
	     * that we have the user's credentials
	     */
	    if (ctx->est_http_auth_cb(ctx, ah, peer, path_seg, ctx->ex_data)) {
		rv = EST_HTTP_AUTH;
	    } else {
                EST_LOG_WARN("HTTP authentication failed. Auth type=%d", 
                             ah->mode);
		rv = EST_UNAUTHORIZED;
	    }
	    break;
        case EST_AUTH_HDR_MISSING:
            // ask client to send us authorization headers
            mg_send_authorization_request(conn);
	    EST_LOG_INFO("HTTP auth headers missing, sending HTTP auth request to client.");
            rv = EST_HTTP_AUTH_PENDING;
	    break;
        case EST_AUTH_HDR_BAD:
	default:
            EST_LOG_WARN("Client sent incomplete HTTP authorization header"); 
	    if (reenroll && rv == EST_CERT_AUTH) {
		EST_LOG_INFO("Client cert was authenticated, HTTP auth not required for reenroll"); 
	    } else {
		rv = EST_UNAUTHORIZED;
	    }
	    break;
	}
	est_destroy_ah(ah);
    } 
    if (peer) {
	X509_free(peer);
    }
    return (rv);

}
/*
 * This function is used to determine if the EST client, which could be
 * an RA, is using a certificate that contains the id-kp-cmcRA usage
 * extension.  When this usage bit is present, the PoP check is disabled
 * to allow the RA use case. 
 *
 * This logic was taken from x509v3_cache_extensions() in v3_purp.c (OpenSSL).
 *
 * Returns 1 if the cert contains id-kp-cmcRA extended key usage extension.
 * Otherwise it returns 0.
 */
static int est_check_cmcRA (X509 *cert) 
{
    int cmcRA_found = 0;
    EXTENDED_KEY_USAGE *extusage;
    int i;
    ASN1_OBJECT *obj;

    /*
     * Get the extended key usage extension.  If found
     * loop through the values and look for the ik-kp-cmcRA
     * value in this extension.
     */
    if((extusage = X509_get_ext_d2i(cert, NID_ext_key_usage, NULL, NULL))) {
	/*
	 * Iterate through the extended key usage values
	 */
        for(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {
	    obj =  sk_ASN1_OBJECT_value(extusage,i);
	    /*
	     * Compare the current iteration with the global
	     * id-kp-cmcRA value that was created earlier
	     */
            if (!OBJ_cmp(obj, o_cmcRA)) {
                cmcRA_found = 1; 
                break;
            }
        }
        sk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);
    }

    return (cmcRA_found);
}
/*
 * This is a utility function to convert the base64 DER encoded
 * CSR to an OpenSSL X509_REQ pointer.  Returns NULL if there
 * was a problem.
 */
X509_REQ * est_server_parse_csr (unsigned char *pkcs10, int pkcs10_len)
{
    BIO *in, *b64;
    X509_REQ *req;

    /*
     * Get the original pkcs10 request from the client
     */
    b64 = BIO_new(BIO_f_base64());
    if (b64 == NULL) {
	EST_LOG_ERR("Unable to open PKCS10 b64 buffer");
	return (NULL);
    }
    in = BIO_new_mem_buf(pkcs10, pkcs10_len);
    if (in == NULL) {
	EST_LOG_ERR("Unable to open PKCS10 raw buffer");
	BIO_free(b64);
	return (NULL);
    }
    in = BIO_push(b64, in);

    /*
     * Read the PEM encoded pkcs10 cert request
     */
    if ((req = d2i_X509_REQ_bio(in, NULL)) == NULL) {
        EST_LOG_ERR("Problem reading DER encoded certificate request");
	ossl_dump_ssl_errors();
        BIO_free_all(in);
	return (NULL);
    }
    BIO_free_all(in);

    return req;
}
/*
 * This function implements the Proof of Posession check (PoP).  The TLS UID has
 * already been saved from the TLS session earlier.  This TLS UID should match the
 * value of the challengePassword attribute in the pkcs10 client certificate.  The
 * client will have provided this value when signing the pkcs10 cert request
 * with its private key, which proves the client is in possession of the private key.
 * This check is enforced as follows:
 *     1. If CSR contains the PoP, it must be valid.
 *     2. If CSR didn't contain the PoP and the server is configured
 *        to require the PoP, then the authentication fails.
 *     3. Otherwise, if CSR didn't contain the PoP and the server is not
 *        configured to require PoP, then authentication passes.
 *
 * Parameters:
 *	ctx:	    Pointer to EST context
 *	ssl:        Pointer to SSL context
 *	pkcs10:	    Pointer to raw PKCS10 data
 *	pkcs10_len: Length of raw PKCS10 data
 *
 * Return value:
 *	EST_ERR_NONE when PoP check passes
 */
int est_tls_uid_auth (EST_CTX *ctx, SSL *ssl, X509_REQ *req) 
{
    X509_ATTRIBUTE *attr;
    int i, j;

    ASN1_TYPE *at;
    ASN1_BIT_STRING *bs = NULL;
    ASN1_TYPE *t;
    int rv = EST_ERR_NONE;
    char *tls_uid;
    int diff;

    /*
     * Get the index of the challengePassword attribute in the request
     */
    i = X509_REQ_get_attr_by_NID(req, NID_pkcs9_challengePassword, -1);
    if (i < 0) {
        EST_LOG_INFO("Cert request does not contain PoP challengePassword attribute");
	/*
	 * If PoP is enabled, we must fail at this point
	 * since the client didn't send the channel binding
	 * info in the CSR.
	 */
	if (ctx->server_enable_pop) {
	    EST_LOG_WARN("PoP enabled, CSR was not authenticated");
            return (EST_ERR_AUTH_FAIL_TLSUID);
	} else {
	    return (EST_ERR_NONE);
	}
    } else {
        /*
         * Get a reference to the attribute now that we know where it's located
	 * RFC 7030 requires that we check the PoP when it's present
         */
        attr = X509_REQ_get_attr(req, i);

        /*
         * If we found the attribute, get the actual value of the challengePassword
         */
        if (attr) {
            if (attr->single) {
                t = attr->value.single;
                bs = t->value.bit_string;
            } else {
                j = 0;
                at = sk_ASN1_TYPE_value(attr->value.set, j);
                bs = at->value.asn1_string;
            }
        } else {
            EST_LOG_WARN("PoP challengePassword attribute not found in client cert request");
            return (EST_ERR_AUTH_FAIL_TLSUID);
        }

        /*
         * Now that we have the challengePassword from the client cert request,
         * compare it to the TLS UID we calculated on the server side.
         * This implements the PoP check to verify the client holds the private
         * key used to sign the cert request.
         */
        tls_uid = est_get_tls_uid(ssl, 0);
        if (tls_uid) {
	    i = memcmp_s(tls_uid, EST_TLS_UID_LEN, bs->data, EST_TLS_UID_LEN, &diff);
            if (i == EOK && !diff) {
                EST_LOG_INFO("PoP is valid");
                rv = EST_ERR_NONE;
            } else {
                EST_LOG_WARN("PoP is not valid");
                rv = EST_ERR_AUTH_FAIL_TLSUID;
            }
            free(tls_uid);
        } else {
            EST_LOG_WARN("Local TLS channel binding info is not available");
            rv = EST_ERR_AUTH_FAIL_TLSUID;
        }
    }

    return rv;
}
/*
 * This function performs a simple sanity check on a PKCS10
 * CSR.  It will check the signature in the CSR.
 * Returns 0 for success, non-zero if the sanity check failed.
 */
int est_server_check_csr (X509_REQ *req) 
{
    EVP_PKEY *pub_key = NULL;
    int rc;

    /*
     * Extract the public key from the CSR
     */
    if ((pub_key = X509_REQ_get_pubkey(req)) == NULL) {
	EST_LOG_ERR("Unable to extract public key from CSR");
	return 1;
    }

    /*
     * Verify the signature in the CSR 
     */
    rc = X509_REQ_verify(req, pub_key);
    EVP_PKEY_free(pub_key);

    /*
     * Check the result
     */
    if (rc < 0) {
	EST_LOG_ERR("CSR signature check failed");
        return 1;
    } else if (rc == 0) {
	EST_LOG_ERR("CSR signature mismatch");
        return 1;
    } else {
        return 0;
    }
}
/*
 * Frees the linked-list containing the attributes in
 * the client CSR.
 */
static void est_server_free_csr_oid_list (EST_OID_LIST *head)
{
    EST_OID_LIST *next_entry;

    if (!head) {
	return;
    }

    next_entry = head->next;
    while (next_entry) {
	free(head);
	head = next_entry;
	next_entry = head->next;
    }
    free(head);
}
/*
 * Adds a new entry to the tail of the list of attributes
 * in the client CSR.
 */
static void est_server_add_oid_to_list (EST_OID_LIST **list, EST_OID_LIST *new_entry) 
{
    EST_OID_LIST *head = *list;

    /*
     * If the list doesn't have a head yet, the new entry
     * simply becomes the head
     */
    if (head == NULL) { 
	*list = new_entry;
    } else {
	/*
	 * Walk the list to find the tail, add the new entry to the end
	 */
	while (head->next) {
	    head = head->next;
	}
	head->next = new_entry;
    }
}
/*
 * This is a recursive routine that walks through an ASN.1 blob
 * looking for ASN.1 object definitions.  For any that are
 * found, the OID for the object is added to the EST_OID_LIST (first argument).
 * The end result of this routine is **list will contain all the OID
 * values for every ASN.1 object in the blob.
 * This code was shamelessly taken from OpenSSL ans1_parse2(), which
 * explains some of the poorly chosen variable names.
 */
static int est_server_csr_asn1_parse (EST_OID_LIST **list, const unsigned char **blob, long length, int offset)
{
    EST_OID_LIST *new_entry;
    const unsigned char *ptr, *ep, *tot, *op, *opp;
    long len;
    int tag, xclass;
    int hl, j, r;
    ASN1_OBJECT *a_object = NULL;
    errno_t safec_rc; 

    ptr = *blob;
    tot = ptr + length;
    op = ptr - 1;
    while ((ptr < tot) && (op < ptr)) {
	op = ptr;
	j = ASN1_get_object(&ptr, &len, &tag, &xclass, length);
	if (j & 0x80) {
	    EST_LOG_ERR("Error in encoding"); 
	    *blob = ptr;
	    return (0);
	}
	hl = ptr - op;
	length -= hl;

	if (j & V_ASN1_CONSTRUCTED) {
	    ep = ptr + len;
	    if (len > length) {
		EST_LOG_ERR("length is greater than %ld",length);
		*blob = ptr;
		return (0);
	    }
	    if ((j == 0x21) && (len == 0)) {
		r = est_server_csr_asn1_parse(list, &ptr, (long)(tot-ptr), offset+(ptr - *blob));
		if (r == 0) { 
		    *blob = ptr;
		    return (0);
		}
		if ((r == 2) || (ptr >= tot)) break;
	    } else {
		while (ptr < ep) {
		    r = est_server_csr_asn1_parse(list, &ptr, (long)len, offset+(ptr - *blob));
		    if (r == 0) { 
			*blob = ptr;
			return (0);
		    }
		}
	    }
	} else if (xclass != 0) {
	    ptr += len;
	} else {
	    if (tag == V_ASN1_OBJECT) {
		opp = op;
		if (d2i_ASN1_OBJECT(&a_object, &opp, len+hl) != NULL) {
		    new_entry = malloc(sizeof(EST_OID_LIST));
		    if (!new_entry) {
			EST_LOG_ERR("malloc failure");
			est_server_free_csr_oid_list(*list);
			if (a_object != NULL) { ASN1_OBJECT_free(a_object); }
			*blob = ptr;
			return (0);
		    }
		    safec_rc = memset_s(new_entry, sizeof(EST_OID_LIST), 0x0, sizeof(EST_OID_LIST));
		    if (safec_rc != EOK) {
		        EST_LOG_INFO("memset_s error 0x%xO\n", safec_rc);
		    }
		    i2t_ASN1_OBJECT(new_entry->oid, EST_MAX_ATTR_LEN, a_object);
		    EST_LOG_INFO("Build CSR OID list: %s", new_entry->oid);
		    est_server_add_oid_to_list(list, new_entry);
		    if (a_object != NULL) {
			ASN1_OBJECT_free(a_object);
			a_object = NULL;
		    }
		} else {
		    EST_LOG_ERR("Bad ASN.1 object");
		    if (a_object != NULL) { ASN1_OBJECT_free(a_object); }
		    *blob = ptr;
		    return (0);
		}
	    } 
	    ptr += len;
	    if ((tag == V_ASN1_EOC) && (xclass == 0)) {
		*blob = ptr;
		return (2);
	    }
	}
	length -= len;
    }
    *blob = ptr;
    return (1);
}
/*
 * Utility function that populates a linked-list containing
 * the OID (or name) of the attributes present in the
 * client CSR.
 */
static EST_ERROR est_server_build_csr_oid_list (EST_OID_LIST **list, char *body, int body_len)
{
    unsigned char *der_data, *der_ptr;
    int der_len;
    int rv;

    /*
     * grab some space to hold the decoded CSR data
     */
    der_ptr = der_data = malloc(body_len*2);
    if (!der_data) {
	EST_LOG_ERR("malloc failed");
        return (EST_ERR_MALLOC);
    }

    /*
     * Decode the CSR data
     */
    der_len = est_base64_decode((char *)body, (char *)der_data, body_len*2);
    if (der_len <= 0) {
        EST_LOG_ERR("Invalid base64 encoded data");
	free(der_data);
        return (EST_ERR_BAD_BASE64);
    }

    rv = est_server_csr_asn1_parse(list, (const unsigned char **)&der_data, der_len, 0);
    if (!rv) {
	EST_LOG_ERR("Failed to build OID list from client provided CSR");
	est_server_free_csr_oid_list(*list);
	free(der_ptr);
	return (EST_ERR_UNKNOWN);
    }
    free(der_ptr);
    return (EST_ERR_NONE);
}
/*
 * This function checks the locally configured CSR attributes
 * against the attributes in the CSR.  If any attributes are
 * missing from the CSR, then an error is returned.
 */
static EST_ERROR est_server_all_csrattrs_present(EST_CTX *ctx, char *body, int body_len) 
{
    int tag, xclass, j, found_match, nid;
    long len;
    unsigned char *der_ptr, *save_ptr;
    ASN1_OBJECT *a_object;
    int max_len = MAX_CSRATTRS;
    char *csr_data;
    int csr_len;
    long out_len_save;
    unsigned char *der_data;
    int der_len, out_len;
    int a_len;
    char tbuf[EST_MAX_ATTR_LEN];
    EST_OID_LIST *csr_attr_oids = NULL; 
    EST_OID_LIST *oid_entry;
    int comparator;
    EST_ERROR rv;

    EST_LOG_INFO("CSR attributes enforcement is enabled");

    if (!ctx->server_csrattrs && !ctx->est_get_csr_cb) {
	EST_LOG_WARN("CSR attributes enforcement is enabled, but no attributes have been configured");
	return EST_ERR_NONE;
    }

    /*
     * Build the list of attributes present in the CSR.  This list will be
     * used later when we confirm the required attributes are present.
     */
    rv =  est_server_build_csr_oid_list(&csr_attr_oids, body, body_len);
    if (rv != EST_ERR_NONE) {
	return (rv);
    }

    /*
     * Get the CSR attributes configured on the server.  We'll need to 
     * look in the CSR to make sure the CSR provided each of these. 
     * Use the callback if configured, otherwise use the local copy.
     */
    if (ctx->est_get_csr_cb) {
	csr_data = (char *)ctx->est_get_csr_cb(&csr_len, NULL, ctx->ex_data);
	if (!csr_data) {
	    EST_LOG_ERR("Application layer failed to return CSR attributes");
	    est_server_free_csr_oid_list(csr_attr_oids);
	    return (EST_ERR_CB_FAILED);
	}
    } else {
        csr_data = malloc(ctx->server_csrattrs_len + 1);
	if (!csr_data) {
	    EST_LOG_ERR("malloc failure");
	    est_server_free_csr_oid_list(csr_attr_oids);
            return (EST_ERR_MALLOC);
        }
        strncpy_s(csr_data, ctx->server_csrattrs_len + 1, 
		  (char *)ctx->server_csrattrs, ctx->server_csrattrs_len);
	csr_data[ctx->server_csrattrs_len] = 0;
	csr_len = ctx->server_csrattrs_len;
    }
    EST_LOG_INFO("Checking CSR attrs present in CSR: %s", csr_data);

    /* 
     * We have the CSR configured on the server and it needs base64 decoding.
     * Check smallest possible base64 case here for now 
     * and sanity test will check min/max value for ASN.1 data
     */
    if (csr_len < MIN_CSRATTRS) {
	est_server_free_csr_oid_list(csr_attr_oids);
	free(csr_data);
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /*
     * grab some space to hold the decoded CSR data
     */
    der_data = malloc(csr_len*2);
    if (!der_data) {
	EST_LOG_ERR("malloc failed");
	est_server_free_csr_oid_list(csr_attr_oids);
	free(csr_data);
        return (EST_ERR_MALLOC);
    }

    /*
     * Decode the CSR data
     */
    der_len = est_base64_decode(csr_data, (char *)der_data, csr_len*2);
    free(csr_data);
    if (der_len <= 0) {
        EST_LOG_ERR("Invalid base64 encoded data");
	est_server_free_csr_oid_list(csr_attr_oids);
	free(der_data);
        return (EST_ERR_BAD_BASE64);
    }

    /*
     * pointer fun starts here, joy to OpenSSL
     */
    out_len_save = out_len = der_len;
    der_ptr = save_ptr = der_data;

    if (out_len_save > max_len) {
	EST_LOG_ERR("DER length exceeds max");
	est_server_free_csr_oid_list(csr_attr_oids);
	free(der_data);
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /* make sure its long enough to be ASN.1 */
    if (der_len < MIN_ASN1_CSRATTRS) {
	EST_LOG_ERR("DER too short");
	est_server_free_csr_oid_list(csr_attr_oids);
	free(der_data);
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /*
     * Iterate through the CSR attributes configured on the server
     */
    while (out_len > 0) {
	/*
	 * Get the next attributes
	 */
	j = ASN1_get_object((const unsigned char**)&der_ptr, &len, &tag, &xclass, out_len);

	EST_LOG_INFO("Sanity: tag=%d, len=%d, j=%d, out_len=%d", tag, len, j, out_len);
	if (j & 0x80) {
	    EST_LOG_ERR("Bad ASN1 hex");
	    est_server_free_csr_oid_list(csr_attr_oids);
	    free(der_data);
	    return (EST_ERR_BAD_ASN1_HEX);
        }
	switch (tag) {
	case V_ASN1_OBJECT:
            a_object = c2i_ASN1_OBJECT(NULL, (const unsigned char**)&der_ptr, len);
	    if (!a_object) {
		EST_LOG_ERR("a_object is null");
	        est_server_free_csr_oid_list(csr_attr_oids);
		free(der_data);
		return (EST_ERR_UNKNOWN);
	    }
	    /*
	     * If this is the challengePassword, no need to check it.
	     * This is already covered when authenticating the client
	     */
	    nid = OBJ_obj2nid(a_object);
	    if (nid == NID_pkcs9_challengePassword) {
		ASN1_OBJECT_free(a_object);
		break;
	    }

	    a_len = i2t_ASN1_OBJECT(tbuf, EST_MAX_ATTR_LEN, a_object);
	    EST_LOG_INFO("Looking for attr=%s in the CSR", tbuf);
	    ASN1_OBJECT_free(a_object);

	    /*
	     * If there were no attrubutes in the CSR, we can
	     * bail now.
	     */
	    if (csr_attr_oids == NULL) {
		EST_LOG_WARN("CSR did not contain any attributes, CSR will be rejected", tbuf);
		free(der_data);
	        return (EST_ERR_CSR_ATTR_MISSING);
	    }

	    found_match = 0;
	    oid_entry = csr_attr_oids;
	    /*
	     * Iterate through the attributes that are in the CSR
	     */
	    while (oid_entry) { 
		EST_LOG_INFO("Comparing %s to %s", tbuf, oid_entry->oid);
		strcmp_s(oid_entry->oid, (a_len < EST_MAX_ATTR_LEN ? a_len : EST_MAX_ATTR_LEN), tbuf, &comparator);
		if (!comparator) {
		    found_match = 1;
		    break;
		}
		oid_entry = oid_entry->next;
	    } 

	    if (!found_match) {
		EST_LOG_WARN("CSR did not contain %s attribute, CSR will be rejected", tbuf);
	        est_server_free_csr_oid_list(csr_attr_oids);
		free(der_data);
	        return (EST_ERR_CSR_ATTR_MISSING);
	    }
	    break;
	default:
	    /* have to adjust string pointer here, move on to the next item */
	    der_ptr += len;
	    break;
	case V_ASN1_SET:
	case V_ASN1_SEQUENCE:
	    break;
	}
	out_len = out_len_save - (der_ptr - save_ptr);
    }
    
    /*
     * One file check to ensure we didn't missing something when parsing
     * the locally configured CSR attributes.
     */
    if (out_len != 0) {
	EST_LOG_ERR("DER length not zero (%d)", out_len);
	est_server_free_csr_oid_list(csr_attr_oids);
	free(der_data);
        return (EST_ERR_BAD_ASN1_HEX);
    }

    /*
     * If we're lucky enough to make it this far, then it means all the
     * locally configured CSR attributes were found in the client's CSR.
     */
    est_server_free_csr_oid_list(csr_attr_oids);
    free(der_data);
    return (EST_ERR_NONE);
}
/*
 * This function is used by the server to process an incoming
 * Simple Enroll request from the client.
 */
static EST_ERROR est_handle_simple_enroll (EST_CTX *ctx, void *http_ctx, SSL *ssl,
                                           const char *ct, char *body, int body_len,
                                           char *path_seg, int reenroll)
{
    int rv, cert_len;
    struct mg_connection *conn = (struct mg_connection*)http_ctx;
    unsigned char *cert;
    char http_hdr[EST_HTTP_HDR_MAX];
    int hdrlen;
    X509 *peer_cert;
    X509_REQ *csr = NULL;
    int client_is_ra = 0;

    if (!reenroll && !ctx->est_enroll_pkcs10_cb) {
	EST_LOG_ERR("Null enrollment callback");
        return (EST_ERR_NULL_CALLBACK);
    }

    if (reenroll && !ctx->est_reenroll_pkcs10_cb) {
	EST_LOG_ERR("Null reenroll callback");
        return (EST_ERR_NULL_CALLBACK);
    }

    /*
     * Make sure the client has sent us a PKCS10 CSR request
     */
    if (strncmp(ct, "application/pkcs10", 18)) {
        return (EST_ERR_BAD_CONTENT_TYPE);
    }

    /*
     * Authenticate the client
     */
    switch (est_enroll_auth(ctx, http_ctx, ssl, path_seg, reenroll)) {
    case EST_HTTP_AUTH:
    case EST_SRP_AUTH:
    case EST_CERT_AUTH:
	/*
	 * this means the user was authorized, either through
	 * HTTP authoriztion or certificate authorization
	 */
        break;
    case EST_HTTP_AUTH_PENDING:
        return (EST_ERR_AUTH_PENDING);
        break;
    case EST_UNAUTHORIZED:
    default:
        return (EST_ERR_AUTH_FAIL);
        break;
    }

    /*
     * Parse the PKCS10 CSR from the client
     */
    csr = est_server_parse_csr((unsigned char*)body, body_len);
    if (!csr) {
	EST_LOG_ERR("Unable to parse the PKCS10 CSR sent by the client");
	return (EST_ERR_BAD_PKCS10);
    }
    
    /*
     * Perform a sanity check on the CSR
     */
    if (est_server_check_csr(csr)) {
	EST_LOG_ERR("PKCS10 CSR sent by the client failed sanity check");
	X509_REQ_free(csr);
	return (EST_ERR_BAD_PKCS10);
    }

    /*
     * Get the peer certificate if available.  This
     * identifies the client. The CA may desire
     * this information.
     */
    peer_cert = SSL_get_peer_certificate(ssl);

    if (peer_cert) {
	client_is_ra = est_check_cmcRA (peer_cert);
    }
    EST_LOG_INFO("id-kp-cmcRA present: %d", client_is_ra);

    /*
     * Do the PoP check (Proof of Possession).  The challenge password
     * in the pkcs10 request should match the TLS unique ID.
     * The PoP check is not performend when the client is an RA.
     */
    if (!client_is_ra) {
	rv = est_tls_uid_auth(ctx, ssl, csr);
	if (rv != EST_ERR_NONE) {
	    X509_REQ_free(csr);
	    X509_free(peer_cert);
	    return (EST_ERR_AUTH_FAIL_TLSUID);
	} 
    }

    /*
     * Check if we need to ensure the client included all the
     * CSR attributes required by the CA.
     */
    if (ctx->enforce_csrattrs) {
	if (EST_ERR_NONE != est_server_all_csrattrs_present(ctx, body, body_len)) {
	    X509_REQ_free(csr);
	    X509_free(peer_cert);
	    return (EST_ERR_CSR_ATTR_MISSING);
	}
    }

    /* body now points to the pkcs10 data, pass
     * this to the enrollment routine */
    if (reenroll) {
        rv = ctx->est_reenroll_pkcs10_cb((unsigned char*)body, body_len, 
                                         &cert, (int*)&cert_len,
                                         conn->user_id, peer_cert,
                                         path_seg, ctx->ex_data);
    } else {
        rv = ctx->est_enroll_pkcs10_cb((unsigned char*)body, body_len, 
                                       &cert, (int*)&cert_len,
                                       conn->user_id, peer_cert,
                                       path_seg, ctx->ex_data);
    }

    /*
     * Peer cert is no longer needed, delete it if we have one
     */
    if (peer_cert) {
	X509_free(peer_cert);
    }

    if (rv == EST_ERR_NONE && cert_len > 0) {
        /*
         * Send HTTP header
         */
        snprintf(http_hdr, EST_HTTP_HDR_MAX, "%s%s%s%s", EST_HTTP_HDR_200, EST_HTTP_HDR_EOL,
                 EST_HTTP_HDR_STAT_200, EST_HTTP_HDR_EOL);
        hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
        snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CT,
                 EST_HTTP_CT_PKCS7_CO, EST_HTTP_HDR_EOL);
        hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
        snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %s%s", EST_HTTP_HDR_CE,
                 EST_HTTP_CE_BASE64, EST_HTTP_HDR_EOL);
        hdrlen = strnlen_s(http_hdr, EST_HTTP_HDR_MAX);
        snprintf(http_hdr + hdrlen, EST_HTTP_HDR_MAX, "%s: %d%s%s", EST_HTTP_HDR_CL,
                 cert_len, EST_HTTP_HDR_EOL, EST_HTTP_HDR_EOL);
        if (!mg_write(http_ctx, http_hdr, strnlen_s(http_hdr, EST_HTTP_HDR_MAX))) {
            free(cert);
	    X509_REQ_free(csr);
            return (EST_ERR_HTTP_WRITE);
        }

        /*
         * Send the signed PKCS7 certificate in the body
         */
        if (!mg_write(http_ctx, cert, cert_len)) {
            free(cert);
	    X509_REQ_free(csr);
            return (EST_ERR_HTTP_WRITE);
        }
        free(cert);
    } else if (rv == EST_ERR_CA_ENROLL_RETRY) {
        /*
         * The CA did not sign the request and has asked the
         * client to retry in the future.  This may occur if
         * the CA is not configured for automatic enrollment.
         * Send the HTTP retry response to the client.
         */
        EST_LOG_INFO("CA server requests retry, possibly it's not setup for auto-enroll");
	if (EST_ERR_NONE != est_server_send_http_retry_after(ctx, http_ctx, ctx->retry_period)) { 
	    X509_REQ_free(csr);
            return (EST_ERR_HTTP_WRITE);
	}
    } else {
	X509_REQ_free(csr);
        return (EST_ERR_CA_ENROLL_FAIL);
    }

    X509_REQ_free(csr);
    return (EST_ERR_NONE);
}
/*
 * This function is used by the server to process an incoming
 * csr attributes request from the client.
 */
static int est_handle_csr_attrs (EST_CTX *ctx, void *http_ctx, char *path_seg)
{
    int rv = EST_ERR_NONE;
    int pop_present;
    char *csr_data, *csr_data_pop;
    int csr_len, csr_pop_len;

    if (!ctx->server_csrattrs && !ctx->est_get_csr_cb) {
        if (!ctx->server_enable_pop) {
  	        EST_LOG_ERR("Null csr callback");
		/* Send a 204 response indicating the server doesn't have a CSR */
		est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
		return (EST_ERR_NONE);
        } else {
	  csr_data = malloc(EST_CSRATTRS_POP_LEN + 1);
	    if (!csr_data) {
                return (EST_ERR_MALLOC);
	    }
	    strncpy_s(csr_data, EST_CSRATTRS_POP_LEN + 1, EST_CSRATTRS_POP, 
		      EST_CSRATTRS_POP_LEN);
	    csr_data[EST_CSRATTRS_POP_LEN] = 0;
	    csr_len = EST_CSRATTRS_POP_LEN;
	    return (est_send_csrattr_data(ctx, csr_data, csr_len, http_ctx));
        }
    }

    /*
     * Invoke CA server callback to retrieve the CSR.  Callback takes priority
     * over saved values in the context.
     * Note: there is no need to authenticate the client (see sec 4.5)
     */
    if (ctx->est_get_csr_cb) {
	csr_data = (char *)ctx->est_get_csr_cb(&csr_len, path_seg, ctx->ex_data);
	rv = est_asn1_parse_attributes(csr_data, csr_len, &pop_present);
	if (csr_len && (rv != EST_ERR_NONE)) {
            if (csr_data) {
                free(csr_data);
            }
	    est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
	    return (EST_ERR_NONE);
	}

	ctx->csr_pop_present = 0;
	if (ctx->server_enable_pop) {
	    rv = est_is_challengePassword_present(csr_data, csr_len, &pop_present);
	    if (rv != EST_ERR_NONE) {
		EST_LOG_ERR("Error during PoP/sanity check");
		if (csr_data) {
		    free(csr_data);
		}
		est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
		return (EST_ERR_NONE);
	    }
	    ctx->csr_pop_present = pop_present;

	    if (!ctx->csr_pop_present) {
		if (csr_len == 0) {
                    csr_data = malloc(EST_CSRATTRS_POP_LEN + 1);
		    if (!csr_data) {
			return (EST_ERR_MALLOC);
		    }
		    strncpy_s(csr_data, EST_CSRATTRS_POP_LEN + 1, 
			      EST_CSRATTRS_POP, EST_CSRATTRS_POP_LEN);
		    csr_data[EST_CSRATTRS_POP_LEN] = 0;
		    csr_len = EST_CSRATTRS_POP_LEN;
		    return (est_send_csrattr_data(ctx, csr_data, csr_len, http_ctx));
		}
		rv = est_add_challengePassword(csr_data, csr_len, &csr_data_pop, &csr_pop_len);
		if (rv != EST_ERR_NONE) {
		    if (csr_data) {
		        free(csr_data);
		    }
		    EST_LOG_ERR("Error during add PoP");
		    est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NO_CONTENT);
		    return (EST_ERR_NONE);
		}
		free(csr_data);
		csr_data = csr_data_pop;
		csr_len = csr_pop_len;
	    }
	}
    } else {
        csr_data = malloc(ctx->server_csrattrs_len + 1);
	if (!csr_data) {
            return (EST_ERR_MALLOC);
        }
        strncpy_s(csr_data, ctx->server_csrattrs_len + 1, 
		  (char *)ctx->server_csrattrs, ctx->server_csrattrs_len);
	csr_data[ctx->server_csrattrs_len] = 0;
	csr_len = ctx->server_csrattrs_len;
    }
    return (est_send_csrattr_data(ctx, csr_data, csr_len, http_ctx));
}
/*
 * This function should be called by the web server layer when
 * a HTTP request arrives on the listening port of the EST server.
 * It will determine the EST request type and dispatch the request
 * to the appropriate handler.
 *
 * Paramters:
 *      ctx:	    Pointer to EST_CTX
 *      http_ctx:   Context pointer from web server
 *      method:     The HTML method in the request, should be either "GET" or "POST"
 *	uri:	    pointer to HTTP URI
 *	body:	    pointer to full HTML body contents
 *	body_len:   length of HTML body
 *	ct:         HTML content type header
 */
int est_http_request (EST_CTX *ctx, void *http_ctx,
                      char *method, char *uri,
                      char *body, int body_len, const char *ct)
{
    SSL *ssl;
    int rc;
    EST_OPERATION operation;
    char *path_seg;
    EST_ERROR rv = EST_ERR_NONE;
    
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    /*
     * Verify the context is for a server, not a client
     */
    if (ctx->est_mode != EST_SERVER) {
        return (EST_ERR_BAD_MODE);
    }

    rv = est_parse_uri(uri, &operation, (char **)&path_seg);
    if (rv != EST_ERR_NONE) {
        est_send_http_error(ctx, http_ctx, rv);
        return (rv);
    }

    /*
     * See if this is a cacerts request
     */
    if (operation == EST_OP_CACERTS) {
        /* Only GET is allowed */
        if (strncmp(method, "GET", 3)) {
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }

        /* rc = est_handle_cacerts(ctx, ctx->ca_certs, ctx->ca_certs_len, */
        /*                         http_ctx, path_seg); */
        rc = est_server_handle_cacerts(ctx, http_ctx, path_seg);
        /* rc = est_server_handle_cacerts(ctx, http_ctx, path_seg); */
        if (rc != EST_ERR_NONE) {
            est_send_http_error(ctx, http_ctx, rc);
            free(path_seg);
            path_seg = NULL;
            return (rc);
        }
    }

    /*
     * See if this is a simple enrollment request
     */
    else if (operation == EST_OP_SIMPLE_ENROLL) {
        /* Only POST is allowed */
        if (strncmp(method, "POST", 4)) {
            EST_LOG_WARN("Incoming HTTP request used wrong method\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }
	if (!ct) {
            EST_LOG_WARN("Incoming HTTP header has no Content-Type header\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
            free(path_seg);
            path_seg = NULL;
	    return (EST_ERR_BAD_CONTENT_TYPE); 
	}
        /*
         * Get the SSL context, which is required for authenticating
         * the client.
         */
        ssl = (SSL*)mg_get_conn_ssl(http_ctx);
        if (!ssl) {
            est_send_http_error(ctx, http_ctx, EST_ERR_NO_SSL_CTX);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_NO_SSL_CTX);
        }

        rc = est_handle_simple_enroll(ctx, http_ctx, ssl, ct, body, body_len,
                                      path_seg, 0);
        if (rc != EST_ERR_NONE && rc != EST_ERR_AUTH_PENDING) {
            EST_LOG_WARN("Enrollment failed with rc=%d (%s)\n", 
		         rc, EST_ERR_NUM_TO_STR(rc));
	    if (rc == EST_ERR_AUTH_FAIL) {
		est_send_http_error(ctx, http_ctx, EST_ERR_AUTH_FAIL);
	    } else {
		est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
	    }
            free(path_seg);
            path_seg = NULL;
            return rc;
        }
    }

    /*
     * See if this is a re-enrollment request
     */
    else if (operation == EST_OP_SIMPLE_REENROLL) {
        /* Only POST is allowed */
        if (strncmp(method, "POST", 4)) {
            EST_LOG_WARN("Incoming HTTP request used wrong method\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }
	if (!ct) {
            EST_LOG_WARN("Incoming HTTP header has no Content-Type header\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
            free(path_seg);
            path_seg = NULL;
	    return (EST_ERR_BAD_CONTENT_TYPE); 
	}
        /*
         * Get the SSL context, which is required for authenticating
         * the client.
         */
        ssl = (SSL*)mg_get_conn_ssl(http_ctx);
        if (!ssl) {
            est_send_http_error(ctx, http_ctx, EST_ERR_NO_SSL_CTX);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_NO_SSL_CTX);
        }

        rc = est_handle_simple_enroll(ctx, http_ctx, ssl, ct, body, body_len,
                                      path_seg, 1);
        if (rc != EST_ERR_NONE && rc != EST_ERR_AUTH_PENDING) {
            EST_LOG_WARN("Reenroll failed with rc=%d (%s)\n", 
		         rc, EST_ERR_NUM_TO_STR(rc));
	    if (rc == EST_ERR_AUTH_FAIL) {
		est_send_http_error(ctx, http_ctx, EST_ERR_AUTH_FAIL);
	    } else {
		est_send_http_error(ctx, http_ctx, EST_ERR_BAD_PKCS10);
	    }
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_BAD_PKCS10);
        }
    }

#if 0
    /*
     * See if this is a keygen request
     * FIXME: this is currently not implemented
     */
    else if (strncmp(uri, EST_KEYGEN_URI, EST_URI_MAX_LEN) == 0) {
        /* Only POST is allowed */
        if (strncmp(method, "POST", 4)) {
            EST_LOG_WARN("Incoming HTTP request used wrong method\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            return (EST_ERR_WRONG_METHOD);
        }
	if (!ct) {
            EST_LOG_WARN("Incoming HTTP header has no Content-Type header\n");
	    return (EST_ERR_BAD_CONTENT_TYPE); 
	}
        if (est_handle_keygen(ctx)) {
            est_send_http_error(ctx, http_ctx, 0); //FIXME: last param should not be zero
            return (EST_ERR_HTTP_WRITE);           //FIXME: need the appropriate return code
        }
    }
#endif

    /*
     * See if this is a CSR attributes request
     */
    else if (operation == EST_OP_CSRATTRS) {
        /* Only GET is allowed */
        if (strncmp(method, "GET", 4)) {
            EST_LOG_WARN("Incoming HTTP request used wrong method\n");
            est_send_http_error(ctx, http_ctx, EST_ERR_WRONG_METHOD);
            free(path_seg);
            path_seg = NULL;
            return (EST_ERR_WRONG_METHOD);
        }

        rc = est_handle_csr_attrs(ctx, http_ctx, path_seg);
	if (rc != EST_ERR_NONE) {
            est_send_http_error(ctx, http_ctx, rc); 
            free(path_seg);
            path_seg = NULL;
            return (rc);
        }
    }

    /*
     * Send a 404 error if the URI didn't match 
     */
    else {
        est_send_http_error(ctx, http_ctx, EST_ERR_HTTP_NOT_FOUND);
    }
    
    free(path_seg);
    path_seg = NULL;
    return (EST_ERR_NONE);
}
/*! @brief est_server_start() is used by an application to start
    the EST server after est_server_init() has been called and
    all the required callback functions have been provided by
    the application.   
 
    @param ctx Pointer to the EST context

    libEST uses HTTP code from the Mongoose HTTP server.
    This function allows the application to start the HTTP
    services layer, which is required by EST.
 
    @return EST_ERROR.
 */
EST_ERROR est_server_start (EST_CTX *ctx)
{
    EST_MG_CONTEXT *mgctx;

    if (!ctx) {
	EST_LOG_ERR("Null context");
	return (EST_ERR_NO_CTX);
    }

    mgctx = mg_start(ctx);
    if (mgctx) {
        ctx->mg_ctx = mgctx;
        return (EST_ERR_NONE);
    } else {
        return (EST_ERR_NO_SSL_CTX);
    }
}
/*! @brief est_server_stop() is used by an application to stop
    the EST server.  This should be called prior to est_destroy().
 
    @param ctx Pointer to the EST context

    libEST uses HTTP code from the Mongoose HTTP server.
    This function allows the application to stop the HTTP
    services layer.
 
    @return EST_ERROR.
 */
EST_ERROR est_server_stop (EST_CTX *ctx)
{
    EST_MG_CONTEXT *mgctx;

    if (!ctx) {
	EST_LOG_ERR("Null context");
	return (EST_ERR_NO_CTX);
    }

    mgctx = (EST_MG_CONTEXT*)ctx->mg_ctx;
    if (mgctx) {
        mg_stop(mgctx);
    }
    return (EST_ERR_NONE);
}
/*! @brief est_server_init() is used by an application to create
    a context in the EST library when operating as an EST server that
    fronts a CA.  This context is used when invoking other functions in the API.
 
    @param ca_chain     Char array containing PEM encoded CA certs & CRL entries 
    @param ca_chain_len Length of ca_chain char array 
    @param cacerts_resp_chain Char array containing PEM encoded CA certs to include
                              in the /cacerts response
    @param cacerts_resp_chain_len Length of cacerts_resp_chain char array
    @param cert_format Specifies the encoding of the local and external
                       certificate chains (PEM/DER).  
    @param http_realm Char array containing HTTP realm name for HTTP auth
    @param tls_id_cert Pointer to X509 that contains the server's certificate
                    for the TLS layer.
    @param tls_id_key Pointer to EVP_PKEY that contains the private key
                   associated with the server's certificate.

    This function allows an application to initialize an EST server context
    that is used with a CA (not an RA).
    The application must provide the trusted CA certificates to use
    for server operation using the ca_chain parameter.  This certificate
    set should include the explicit trust anchor certificate, any number
    of implicit trust anchor certificates, and any intermediate sub-CA
    certificates required to complete the chain of trust between the
    identity certificate passed into the tls_id_cert parameter and the
    root certificate for that identity certificate.  
    The CA certificates should be encoded using
    the format specified in the cert_format parameter (e.g. PEM) and
    may contain CRL entries that will be used when authenticating
    EST clients connecting to the server.  
    The applications must also provide the HTTP realm to use for 
    HTTP authentication and the server cerificate/private key to use
    for the TLS stack to identify the server.
    
    Warning: Including additional intermediate sub-CA certificates that are
             not needed to complete the chain of trust may result in a
	     potential MITM attack.  
 
    @return EST_CTX.
 */
EST_CTX * est_server_init (unsigned char *ca_chain, int ca_chain_len,
                           unsigned char *cacerts_resp_chain, int cacerts_resp_chain_len,
			   EST_CERT_FORMAT cert_format,
                           char *http_realm, 
			   X509 *tls_id_cert, EVP_PKEY *tls_id_key)
{
    EST_CTX *ctx;
    int len;

    est_log_version();

    /*
     * Sanity check the input
     */
    if (ca_chain == NULL) {
        EST_LOG_ERR("Trusted CA certificate set is empty");
        return NULL;
    }
    if (cert_format != EST_CERT_FORMAT_PEM) {
        EST_LOG_ERR("Only PEM encoding of certificate changes is supported.");
        return NULL;
    }

    /* 
     * Check the length value, it should match.
     */
    len = (int) strnlen_s((char *)ca_chain, EST_CA_MAX);
    if (len != ca_chain_len) {
	EST_LOG_ERR("Length of ca_chain doesn't match ca_chain_len");
        return NULL;
    }
    if (cacerts_resp_chain) {        
        len = (int) strnlen_s((char *)cacerts_resp_chain, EST_CA_MAX);
        if (len != cacerts_resp_chain_len) {
            EST_LOG_ERR("Actual length of cacerts_resp_chain does not match "
                        "passed in length value");
            return NULL;
        }
    }

    if (tls_id_cert == NULL) {
        EST_LOG_ERR("TLS identity cert is empty");
        return NULL;
    }

    if (tls_id_key == NULL) {
        EST_LOG_ERR("Private key associated with TLS identity cert is empty");
        return NULL;
    }
    if (http_realm == NULL) {
        EST_LOG_ERR("EST HTTP realm is NULL");
        return NULL;
    }

    ctx = malloc(sizeof(EST_CTX));
    if (!ctx) {
        EST_LOG_ERR("malloc failed");
        return NULL;
    }
    memzero_s(ctx, sizeof(EST_CTX));
    ctx->est_mode = EST_SERVER;
    ctx->retry_period = EST_RETRY_PERIOD_DEF;
    ctx->require_http_auth = HTTP_AUTH_REQUIRED;
    ctx->server_read_timeout = EST_SSL_READ_TIMEOUT_DEF;

    /*
     * Load the CA certificates into local memory and retain
     * for future use.  This will be used for /cacerts requests.
     * They are optional parameters.  The alternative is for the
     * app layer to provide callback and return them on the fly.
     */
    if (cacerts_resp_chain) 
    {   
        if (est_load_ca_certs(ctx, cacerts_resp_chain, cacerts_resp_chain_len)) {
            EST_LOG_ERR("Failed to load CA certificates response buffer");
            free(ctx);
            return NULL;
        }
    }
    if (est_load_trusted_certs(ctx, ca_chain, ca_chain_len)) {
        EST_LOG_ERR("Failed to load trusted certficate store");
	free(ctx);
        return NULL;
    }

    strncpy_s(ctx->realm, MAX_REALM, http_realm, MAX_REALM);
    ctx->server_cert = tls_id_cert;
    ctx->server_priv_key = tls_id_key;
    ctx->auth_mode = AUTH_BASIC;
    ctx->server_enable_pop = 1;
    ctx->local_cacerts_processing = 1;

    /* 
     * Create a new ASN object for the id-kp-cmcRA OID.  
     * OpenSSL doesn't define this, so we need to create it
     * ourselves.
     * http://www.openssl.org/docs/crypto/OBJ_nid2obj.html
     */
    if (!o_cmcRA) {
	o_cmcRA = OBJ_txt2obj("1.3.6.1.5.5.7.3.28", 1);
	if (!o_cmcRA) {
	    EST_LOG_WARN("Failed to create OID for id-kp-cmcRA key usage checks");
	}
    }

    return (ctx);
}
/*! @brief est_server_set_auth_mode() is used by an application to configure
    the HTTP authentication method to use for validating the identity of
    an EST client.
 
    @param ctx   Pointer to the EST context
    @param amode Must be one of the following: AUTH_BASIC, AUTH_DIGEST, AUTH_TOKEN

    This function can optionally be invoked by the application to change the
    default HTTP authentication mode.  The default mode is HTTP Basic
    authentication.  An application may desire to use Digest or Token
    authentication instead, in which case this function can be used to set
    that mode.  This function must be invoked prior to starting the EST
    server.

    @return EST_ERROR.
 */
EST_ERROR est_server_set_auth_mode (EST_CTX *ctx, EST_HTTP_AUTH_MODE amode)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    switch (amode) {
    case AUTH_DIGEST:
        /*
         * Since HTTP digest auth uses MD5, make sure we're not in FIPS mode.
         */
	if (FIPS_mode()) {
	    EST_LOG_ERR("HTTP digest auth not allowed while in FIPS mode");
	    return (EST_ERR_BAD_MODE);
	}
        /* fallthrough */
    case AUTH_BASIC:        
    case AUTH_TOKEN:        
	ctx->auth_mode = amode;
	return (EST_ERR_NONE);
	break;
    default:
        EST_LOG_ERR("Unsupported HTTP authentication mode, only Basic, Digest and Token allowed");
	return (EST_ERR_BAD_MODE);
	break;
    }
}
/*! @brief est_set_ca_enroll_cb() is used by an application to install
    a handler for signing incoming PKCS10 requests.  
 
    @param ctx Pointer to the EST context
    @param cb Function address of the handler

    This function must be called prior to starting the EST server.  The
    callback function must match the following prototype:

        int func(unsigned char*, int, unsigned char**, int*, char*, X509*, char *, void *);

    This function is called by libEST when a certificate request
    needs to be signed by the CA server.  The application will need
    to forward the request to the signing authority and return
    the response.  The response should be a PKCS7 signed certificate.
 
    @return EST_ERROR.
 */
EST_ERROR est_set_ca_enroll_cb (EST_CTX *ctx, int (*cb)(unsigned char *pkcs10, int p10_len,
                                                        unsigned char **pkcs7, int *pkcs7_len,
                                                        char *user_id, X509 *peer_cert,
                                                        char *path_seg, void *ex_data))
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->est_enroll_pkcs10_cb = cb;

    return (EST_ERR_NONE);
}
/*! @brief est_set_ca_reenroll_cb() is used by an application to install
    a handler for re-enrolling certificates.  
 
    @param ctx Pointer to the EST context
    @param cb Function address of the handler

    This function must be called prior to starting the EST server.  The
    callback function must match the following prototype:

        int func(unsigned char*, int, unsigned char**, int*, char*, X509*)

    This function is called by libEST when a certificate 
    needs to be renewed by the CA server.  The application will need
    to forward the request to the signing authority and return
    the response.  The response should be a PKCS7 signed certificate.
 
    @return EST_ERROR.
 */
EST_ERROR est_set_ca_reenroll_cb (EST_CTX *ctx, int (*cb)(unsigned char *pkcs10, int p10_len,
                                                          unsigned char **pkcs7, int *pkcs7_len,
                                                          char *user_id, X509 *peer_cert,
                                                          char *path_seg, void *ex_data))
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->est_reenroll_pkcs10_cb = cb;

    return (EST_ERR_NONE);
}
/*! @brief est_set_http_auth_cb() is used by an application to install
    a handler for authenticating EST clients.
 
    @param ctx Pointer to the EST context
    @param cb Function address of the handler

    This function must be called prior to starting the EST server.  The
    callback function must match the following prototype:

    int (*cb)(EST_CTX *ctx, EST_HTTP_AUTH_HDR *ah, X509 *peer_cert,
              char *path_seg, void *ex_data)

    This function is called by libEST when performing HTTP authentication.
    libEST will pass the EST_HTTP_AUTH_HDR struct to the application,
    allowing the application to hook into a Radius, AAA, or some user
    authentication database.  The X509 certificate from the TLS 
    peer (EST client) is also provided through this callback facility, allowing
    the application layer to check for specific attributes in the 
    X509 certificate such as an 802.1AR device ID.  In addition,
    the path segment string is passed up if there was one in the
    request URI.
 
    @return EST_ERROR.
 */
EST_ERROR est_set_http_auth_cb (EST_CTX *ctx, 
                                int (*cb)(EST_CTX *ctx, EST_HTTP_AUTH_HDR *ah, 
                                          X509 *peer_cert, char *path_seg,
					  void *ex_data))
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->est_http_auth_cb = cb;

    return (EST_ERR_NONE);
}
/*! @brief est_set_http_auth_required() is used by an application to define whether
    HTTP authentication should be required in addition to using client certificates.
 
    @param ctx Pointer to the EST context
    @param required Flag indicating that HTTP authentication is required. Set 
    to HTTP_AUTH_REQUIRED value to require HTTP auth.  Set to HTTP_AUTH_NOT_REQUIRED 
    if HTTP auth should occur only when TLS client authentication fails.
 
    @return EST_ERROR.

    The default mode is HTTP_AUTH_REQUIRED.  This means that HTTP authentication
    will be attempted even when TLS client authentication succeeds.  If HTTP
    authentication is only needed when TLS client auth fails, then set this
    to HTTP_AUTH_NOT_REQUIRED.
 */
EST_ERROR est_set_http_auth_required (EST_CTX *ctx, EST_HTTP_AUTH_REQUIRED required)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->require_http_auth = required;

    return (EST_ERR_NONE);
}
/*! @brief est_server_enable_srp() is used by an application to enable 
    the TLS-SRP authentication.  This allows EST clients that provide 
    SRP credentials at the TLS layer to be authenticated by the EST
    server.  This function must be invoked to enable server-side
    SRP support. 

    @param ctx Pointer to the EST context
    @param cb Function address of the application specific SRP verifier handler

    This function should be invoked prior to starting the EST server.   
    This is used to specify the handler for SRP authentication at the TLS
    layer.  When a TLS-SRP cipher suite is negotiated at the TLS layer,
    the handler will be invoked by libEST to retrieve the SRP parameters
    for user authentication.  Your application must provide the SRP parameters
    for the user.  
    
    The handler should use the following logic:

    1. Invoke SSL_get_srp_username() to get the SRP user name from the
       TLS layer.
    2. Lookup the user's SRP parameters in the application specific
       user database.  These parameters include the N, g, s, and v 
       parameters.
    3. Invoke SSL_set_srp_server_param() to forward the SRP parameters
       to the TLS layer, allowing the TLS handshake to proceed.
       
    libEST includes an example server application that uses this handler
    for SRP support.  This example uses the OpenSSL SRP verifier file capability
    to manage SRP parameters for individual users.  Your application could use
    this approach, or it may utilize another facility for managing user specific
    SRP parameters.  Please refer to RFC 2945 and RFC 5054 for a full understanding
    of SRP.

    @return EST_ERROR.
 */
EST_ERROR est_server_enable_srp (EST_CTX *ctx, int (*cb)(SSL *s, int *ad, void *arg))
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    if (!cb) {
	EST_LOG_ERR("Null callback");
        return (EST_ERR_INVALID_PARAMETERS);
    }

    ctx->est_srp_username_cb = cb;
    ctx->enable_srp = 1;

    return (EST_ERR_NONE);
}
/*! @brief est_server_enable_pop() is used by an application to enable 
    the proof-of-possession check on the EST server.  This proves the 
    EST client that sent the CSR to the server is in possesion of the 
    private key that was used to sign the CSR.  This binds the TLS 
    session ID to the CSR.

    Note, if the CSR attributes configured on the server require PoP 
    checking, then there is no need to call this function to enable
    PoP.  The PoP will be enabled automatically under this scenario.
    
    Note, PoP checking is not possible when an EST proxy is used to
    between the EST client and EST server.  Since the proxy will not 
    be in possession of the private key, an EST server woul fail the
    PoP check.  However, an EST proxy can enable this feature to ensure 
    the EST client has the signing key.

    @param ctx Pointer to the EST context

    This function may be called at any time.   
 
    @return EST_ERROR.
 */
EST_ERROR est_server_enable_pop (EST_CTX *ctx)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->server_enable_pop = 1;
    return (EST_ERR_NONE);
}
/*! @brief est_server_disable_pop() is used by an application to disable 
    the proof-of-possession check on the EST server.  Please see
    the documenation for est_server_enable_pop() for more information
    on the proof-of-possession check.

    @param ctx Pointer to the EST context

    This function may be called at any time.   
 
    @return EST_ERROR.
 */
EST_ERROR est_server_disable_pop (EST_CTX *ctx)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    ctx->server_enable_pop = 0;
    return (EST_ERR_NONE);
}
/*! @brief est_server_set_retry_period() is used by an application to  
    change the default retry-after period sent to the EST client when
    the CA server is not configured for auto-enroll.  This retry-after
    value notifies the client about how long it should wait before
    attempting the enroll operation again to see if the CA has 
    approved the original CSR. 
 
    @param ctx Pointer to the EST context
    @param seconds Number of seconds the server will use in the
           retry-after response.

    This function may be called at any time after a context has
    been created.   
 
    @return EST_ERROR.
 */
EST_ERROR est_server_set_retry_period (EST_CTX *ctx, int seconds)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    if (seconds > EST_RETRY_PERIOD_MAX) {
	EST_LOG_ERR("Maximum retry-after period is %d seconds",
		EST_RETRY_PERIOD_MAX);
        return (EST_ERR_INVALID_PARAMETERS);
    }

    if (seconds < EST_RETRY_PERIOD_MIN) {
	EST_LOG_ERR("Minimum retry-after period is %d seconds",
		EST_RETRY_PERIOD_MIN);
        return (EST_ERR_INVALID_PARAMETERS);
    }

    ctx->retry_period = seconds;
    return (EST_ERR_NONE);
}
/*! @brief est_server_set_ecdhe_curve() is used by an application to 
    specify the ECC curve that should be used for ephemeral diffie-hellman
    keys during the TLS handshake.  Ephemeral diffie-hellman is enabled
    by libEST and provides better forward secrecy.  If the curve
    is not specified by the application using this function, then
    the prime256v1 curve is used as the default curve.  
 
    @param ctx Pointer to the EST context
    @param nid OpenSSL NID value for the desired curve

    This function must be called prior to starting the EST server.  
    The NID values are defined in <openssl/obj_mac.h>.  Typical NID 
    values provided to this function would include:
	
	NID_X9_62_prime192v1
	NID_X9_62_prime256v1
	NID_secp384r1
	NID_secp521r1
 
    @return EST_ERROR.
 */
EST_ERROR est_server_set_ecdhe_curve (EST_CTX *ctx, int nid)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }
    if (nid <= 0) {
	EST_LOG_ERR("Invalid NID value");
        return (EST_ERR_INVALID_PARAMETERS);
    }

    ctx->ecdhe_nid = nid;
    return (EST_ERR_NONE);
}
/*! @brief est_server_set_dh_parms() is used by an application to 
    specify the Diffie-Hellman parameters to be used for single
    use DH key generation during the TLS handshake.  If these 
    parameters are not used, then single-use DH key generation
    is not enabled.  This should be enabled to improve the 
    forward secrecy of the TLS handshake operation.  
    
    The DH parameters provided through this API should not be
    hard-coded in the application.  The parameters should be
    generated at the time of product installation.  Reusing the
    parameters across multiple installations of the product
    results in a vulnerable product.  
 
    @param ctx Pointer to the EST context
    @param parms Pointer to OpenSSL DH parameters

    This function must be called prior to starting the EST server.  
 
    @return EST_ERROR.
 */
EST_ERROR est_server_set_dh_parms (EST_CTX *ctx, DH *parms)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }
    if (!parms) {
        EST_LOG_ERR("Null DH parameters");
        return (EST_ERR_INVALID_PARAMETERS);
    }
    ctx->dh_tmp = DHparams_dup(parms);
    return (EST_ERR_NONE);
}
/*! @brief est_server_init_csrattrs() is used by an application to 
    initialize a fixed set of CSR attributes.  These attributes will
    be used by libEST in response to a client CSR attributes
    request.  The attributes must be an ASN.1 base64 encoded character
    string.

    @param ctx Pointer to the EST context
    @param csrattrs Pointer CSR attributes in ASN.1 base64 encoded format,
                    a NULL pointer clears the attributes and length.
    @param csrattrs_len Length of the CSR attributes character string

    The est_get_csr_cb callback function maintains precendence over this
    method for CSR attributes. If est_get_csr_cb is initialized by the
    application it will be used.  If not, then libEST will use the
    attributes initialized here.

    This function should be called prior to starting the EST server.  
    PoP configuration(est_server_enable_pop or est_server_disable_pop)
    should be called prior to this function.
    
    @return EST_ERROR.
 */
EST_ERROR est_server_init_csrattrs (EST_CTX *ctx, char *csrattrs, int csrattrs_len)
{
    int csrattrs_pop_len, pop_present, rv;
    char *csrattrs_data_pop = NULL;

    if (ctx == NULL) {
        return (EST_ERR_NO_CTX);
    }

    /*
     * Verify the context is for a server, not a client or proxy
     */
    if (ctx->est_mode != EST_SERVER) {
        return (EST_ERR_BAD_MODE);
    }

    EST_LOG_INFO("Attributes pointer is %p, len=%d", 
		 ctx->server_csrattrs, ctx->server_csrattrs_len);

    /* Free old version if previously initialized */
    if (ctx->server_csrattrs != NULL) {
        free(ctx->server_csrattrs);
        ctx->server_csrattrs = NULL;
        ctx->server_csrattrs_len = 0;
    }

    /* caller just wanted to clear it, so return */
    if (csrattrs == NULL) {
	return (EST_ERR_NONE);
    }

    /*
     * In order to run Client negative unit testing the parameter, 
     * PoP and parse checks all need to be disabled via #define
     * in a couple of places here.
     */

    /* 
     * check smallest possible base64 case here for now 
     * and sanity test will check min/max value for ASN.1 data
     */
    if (csrattrs_len < MIN_CSRATTRS) {
        return (EST_ERR_INVALID_PARAMETERS);
    }

    /* assume PoP not in CSR attributes */
    ctx->csr_pop_present = 0;
    if (ctx->server_enable_pop) {
        rv = est_is_challengePassword_present(csrattrs, csrattrs_len, &pop_present);
	if (rv != EST_ERR_NONE) {
	    EST_LOG_ERR("Error during PoP/sanity check");
	    return (EST_ERR_INVALID_PARAMETERS);
	}
	ctx->csr_pop_present = pop_present;

	if (!ctx->csr_pop_present) {
	    rv = est_add_challengePassword(csrattrs, csrattrs_len, 
					   &csrattrs_data_pop, &csrattrs_pop_len);
	    if (rv != EST_ERR_NONE) {
		EST_LOG_ERR("Error during add PoP");
		return (EST_ERR_INVALID_PARAMETERS);
	    }
	    csrattrs = csrattrs_data_pop;
	    csrattrs_len = csrattrs_pop_len;
	}
    } else {
        rv = est_asn1_parse_attributes(csrattrs, csrattrs_len, &pop_present);
	if (rv != EST_ERR_NONE) {
	    EST_LOG_ERR("Corrupt CSR Attributes");
	    return (EST_ERR_INVALID_PARAMETERS);
	}
    }    

    ctx->server_csrattrs = malloc(csrattrs_len + 1);
    if (!ctx->server_csrattrs) {
        if (csrattrs_data_pop) {
            free(csrattrs_data_pop);
	}
        return (EST_ERR_MALLOC);
    }
    ctx->server_csrattrs_len = csrattrs_len;

    strncpy_s((char *)ctx->server_csrattrs, csrattrs_len + 1, csrattrs, csrattrs_len);
    ctx->server_csrattrs[csrattrs_len] = 0;
    if (csrattrs_data_pop) {
      free(csrattrs_data_pop);
    }
    EST_LOG_INFO("Attributes pointer is %p, len=%d", ctx->server_csrattrs, 
		 ctx->server_csrattrs_len);
    return (EST_ERR_NONE);
}
/*! @brief est_server_enable_tls10() is a deprecated function. TLS 1.0
    is a violation of RFC7030 and it is no longer supported by the EST library.
    This function will log an error message and return EST_ERR_BAD_MODE.
    
    @param ctx Pointer to the EST context

    This function must be called prior to starting the EST server.  
 
    @return EST_ERROR.
 */
EST_ERROR est_server_enable_tls10 (EST_CTX *ctx)
{
	EST_LOG_ERR("TLS 1.0 is a violation of RFC7030 and therefore not supported");
        return (EST_ERR_BAD_MODE);

}
/*! @brief est_server_enforce_csrattrs() is used by an application to 
    enable checking of the CSR attributes on the EST server.  When
    enabled, the EST client must provide all the CSR attributes that
    were in the /csrattrs response sent by the server.  The enrollment
    will fail if the client fails to provide all the CSR attributes.
    This setting applies to simple enroll and reenroll operations.
    This setting applies only to server mode and has no bearing on
    proxy mode operation.
    
    @param ctx Pointer to the EST context

    This function must be called prior to starting the EST server.  
 
    @return EST_ERROR.
 */
EST_ERROR est_server_enforce_csrattr (EST_CTX *ctx)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }
    ctx->enforce_csrattrs = 1;
    return (EST_ERR_NONE);
}
/*! @brief est_server_set_read_timeout() is used by an application to set
    timeout value of server read operations.  Once a socket is opened the
    EST server begins attempting to read from this socket.  This
    timeout value limits the amount of time the client will wait for the
    response.  The default value is set to EST_SSL_READ_TIMEOUT_DEF.

    @param ctx Pointer to the EST context
    @param timeout Integer value representing the read timeout in seconds.
    The minimum value is EST_SSL_READ_TIMEOUT_MIN and the maximum value is
    EST_SSL_READ_TIMEOUT_MAX.
 
    @return EST_ERROR.
 */
EST_ERROR est_server_set_read_timeout (EST_CTX *ctx, int timeout)
{
    if (!ctx) {
	EST_LOG_ERR("Null context");
        return (EST_ERR_NO_CTX);
    }

    if (timeout < EST_SSL_READ_TIMEOUT_MIN ||
        timeout > EST_SSL_READ_TIMEOUT_MAX) {
	EST_LOG_ERR("Invalid read timeout value passed: %d ", timeout);
        return (EST_ERR_INVALID_PARAMETERS);
    }
        
    ctx->server_read_timeout = timeout;
    return (EST_ERR_NONE);
}

/*
** signed long to signed int
*/
int curlx_sltosi(long slnum)
{
#ifdef __INTEL_COMPILER
#  pragma warning(push)
#  pragma warning(disable:810) /* conversion may lose significant bits */
#endif

  assert(slnum >= 0);
#if (SIZEOF_INT < CURL_SIZEOF_LONG)
  assert((unsigned long) slnum <= (unsigned long) CURL_MASK_SINT);
#endif
  return (int)(slnum & (long) CURL_MASK_SINT);

#ifdef __INTEL_COMPILER
#  pragma warning(pop)
#endif
}
/*
 * parsedate()
 *
 * Returns:
 *
 * PARSEDATE_OK     - a fine conversion
 * PARSEDATE_FAIL   - failed to convert
 * PARSEDATE_LATER  - time overflow at the far end of time_t
 * PARSEDATE_SOONER - time underflow at the low end of time_t
 */
static int parsedate(const char *date, time_t *output);
/* returns:
   -1 no day
   0 monday - 6 sunday
*/
static int checkday(const char *check, size_t len)
{
  int i;
  const char * const *what;
  int found= 0;
  if(len > 3)
    what = &weekday[0];
  else
    what = &Curl_wkday[0];
  for(i=0; i<7; i++) {
    if(est_client_Curl_raw_equal(check, what[0])) {
      found=1;
      break;
    }
    what++;
  }
  return found?i:-1;
}
/* returns:
   -1 no day
   0 monday - 6 sunday
*/
static int checkmonth(const char *check)
{
  int i;
  const char * const *what;
  int found= 0;

  what = &Curl_month[0];
  for(i=0; i<12; i++) {
    if(est_client_Curl_raw_equal(check, what[0])) {
        found=1;
      break;
    }
    what++;
  }
  return found?i:-1; /* return the offset or -1, no real offset is -1 */
}
/* return the time zone offset between GMT and the input one, in number
   of seconds or -1 if the timezone wasn't found/legal */
static int checktz(const char *check)
{
  unsigned int i;
  const struct tzinfo *what;
  int found= 0;

  what = tz;
  for(i=0; i< sizeof(tz)/sizeof(tz[0]); i++) {
    if(est_client_Curl_raw_equal(check, what->name)) {
      found=1;
      break;
    }
    what++;
  }
  return found?what->offset*60:-1;
}
/* return the time zone offset between GMT and the input one, in number
   of seconds or -1 if the timezone wasn't found/legal */
static void skip_over_white(const char **date)
{
  /* skip everything that aren't letters or digits */
  while(**date && !ISALNUM(**date))
    (*date)++;
}
/* struct tm to time since epoch in GMT time zone.
 * This is similar to the standard mktime function but for GMT only, and
 * doesn't suffer from the various bugs and portability problems that
 * some systems' implementations have.
 */
static time_t my_timegm(struct my_tm *tm)
{
  static const int month_days_cumulative [12] =
    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
  int month, year, leap_days;

  if(tm->tm_year < 70)
    /* we don't support years before 1970 as they will cause this function
       to return a negative value */
    return -1;

  year = tm->tm_year + 1900;
  month = tm->tm_mon;
  if(month < 0) {
    year += (11 - month) / 12;
    month = 11 - (11 - month) % 12;
  }
  else if(month >= 12) {
    year -= month / 12;
    month = month % 12;
  }

  leap_days = year - (tm->tm_mon <= 1);
  leap_days = ((leap_days / 4) - (leap_days / 100) + (leap_days / 400)
               - (1969 / 4) + (1969 / 100) - (1969 / 400));

  return ((((time_t) (year - 1970) * 365
            + leap_days + month_days_cumulative [month] + tm->tm_mday - 1) * 24
           + tm->tm_hour) * 60 + tm->tm_min) * 60 + tm->tm_sec;
}
/*
 * parsedate()
 *
 * Returns:
 *
 * PARSEDATE_OK     - a fine conversion
 * PARSEDATE_FAIL   - failed to convert
 * PARSEDATE_LATER  - time overflow at the far end of time_t
 * PARSEDATE_SOONER - time underflow at the low end of time_t
 */
static int parsedate(const char *date, time_t *output)
{
  time_t t = 0;
  int wdaynum=-1;  /* day of the week number, 0-6 (mon-sun) */
  int monnum=-1;   /* month of the year number, 0-11 */
  int mdaynum=-1; /* day of month, 1 - 31 */
  int hournum=-1;
  int minnum=-1;
  int secnum=-1;
  int yearnum=-1;
  int tzoff=-1;
  struct my_tm tm;
  enum assume dignext = DATE_MDAY;
  const char *indate = date; /* save the original pointer */
  int part = 0; /* max 6 parts */

  while(*date && (part < 6)) {
    int found=0;

    skip_over_white(&date);

    if(ISALPHA(*date)) {
      /* a name coming up */
      char buf[EST_CURL_MAX_NAME_STR]="";
      size_t len;
      sscanf(date, "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]",
             buf);
      len = strnlen_s(buf, EST_CURL_MAX_NAME_STR);

      if(wdaynum == -1) {
        wdaynum = checkday(buf, len);
        if(wdaynum != -1)
          found = 1;
      }
      if(!found && (monnum == -1)) {
        monnum = checkmonth(buf);
        if(monnum != -1)
          found = 1;
      }

      if(!found && (tzoff == -1)) {
        /* this just must be a time zone string */
        tzoff = checktz(buf);
        if(tzoff != -1)
          found = 1;
      }

      if(!found)
        return PARSEDATE_FAIL; /* bad string */

      date += len;
    }
    else if(ISDIGIT(*date)) {
      /* a digit */
      int val;
      char *end;
      if((secnum == -1) &&
         (3 == sscanf(date, "%02d:%02d:%02d", &hournum, &minnum, &secnum))) {
        /* time stamp! */
        date += 8;
      }
      else if((secnum == -1) &&
              (2 == sscanf(date, "%02d:%02d", &hournum, &minnum))) {
        /* time stamp without seconds */
        date += 5;
        secnum = 0;
      }
      else {
        long lval;
        int error;
        int old_errno;

        old_errno = ERRNO;
        SET_ERRNO(0);
        lval = strtol(date, &end, 10);
        error = ERRNO;
        if(error != old_errno)
          SET_ERRNO(old_errno);

        if(error)
          return PARSEDATE_FAIL;

        if((lval > (long)INT_MAX) || (lval < (long)INT_MIN))
          return PARSEDATE_FAIL;

        val = curlx_sltosi(lval);

        if((tzoff == -1) &&
           ((end - date) == 4) &&
           (val <= 1400) &&
           (indate< date) &&
           ((date[-1] == '+' || date[-1] == '-'))) {
          /* four digits and a value less than or equal to 1400 (to take into
             account all sorts of funny time zone diffs) and it is preceded
             with a plus or minus. This is a time zone indication.  1400 is
             picked since +1300 is frequently used and +1400 is mentioned as
             an edge number in the document "ISO C 200X Proposal: Timezone
             Functions" at http://david.tribble.com/text/c0xtimezone.html If
             anyone has a more authoritative source for the exact maximum time
             zone offsets, please speak up! */
          found = 1;
          tzoff = (val/100 * 60 + val%100)*60;

          /* the + and - prefix indicates the local time compared to GMT,
             this we need ther reversed math to get what we want */
          tzoff = date[-1]=='+'?-tzoff:tzoff;
        }

        if(((end - date) == 8) &&
           (yearnum == -1) &&
           (monnum == -1) &&
           (mdaynum == -1)) {
          /* 8 digits, no year, month or day yet. This is YYYYMMDD */
          found = 1;
          yearnum = val/10000;
          monnum = (val%10000)/100-1; /* month is 0 - 11 */
          mdaynum = val%100;
        }

        if(!found && (dignext == DATE_MDAY) && (mdaynum == -1)) {
          if((val > 0) && (val<32)) {
            mdaynum = val;
            found = 1;
          }
          dignext = DATE_YEAR;
        }

        if(!found && (dignext == DATE_YEAR) && (yearnum == -1)) {
          yearnum = val;
          found = 1;
          if(yearnum < 1900) {
            if(yearnum > 70)
              yearnum += 1900;
            else
              yearnum += 2000;
          }
          if(mdaynum == -1)
            dignext = DATE_MDAY;
        }

        if(!found)
          return PARSEDATE_FAIL;

        date = end;
      }
    }

    part++;
  }

  if(-1 == secnum)
    secnum = minnum = hournum = 0; /* no time, make it zero */

  if((-1 == mdaynum) ||
     (-1 == monnum) ||
     (-1 == yearnum))
    /* lacks vital info, fail */
    return PARSEDATE_FAIL;

#if SIZEOF_TIME_T < 5
  /* 32 bit time_t can only hold dates to the beginning of 2038 */
  if(yearnum > 2037) {
    *output = 0x7fffffff;
    return PARSEDATE_LATER;
  }
#endif

  if(yearnum < 1970) {
    *output = 0;
    return PARSEDATE_SOONER;
  }

  if((mdaynum > 31) || (monnum > 11) ||
     (hournum > 23) || (minnum > 59) || (secnum > 60))
    return PARSEDATE_FAIL; /* clearly an illegal date */

  tm.tm_sec = secnum;
  tm.tm_min = minnum;
  tm.tm_hour = hournum;
  tm.tm_mday = mdaynum;
  tm.tm_mon = monnum;
  tm.tm_year = yearnum - 1900;

  /* my_timegm() returns a time_t. time_t is often 32 bits, even on many
     architectures that feature 64 bit 'long'.

     Some systems have 64 bit time_t and deal with years beyond 2038. However,
     even on some of the systems with 64 bit time_t mktime() returns -1 for
     dates beyond 03:14:07 UTC, January 19, 2038. (Such as AIX 5100-06)
  */
  t = my_timegm(&tm);

  /* time zone adjust (cast t to int to compare to negative one) */
  if(-1 != (int)t) {

    /* Add the time zone diff between local time zone and GMT. */
    long delta = (long)(tzoff!=-1?tzoff:0);

    if((delta>0) && (t + delta < t))
      return -1; /* time_t overflow */

    t += delta;
  }

  *output = t;

  return PARSEDATE_OK;
}
/*	Find next Field
**	---------------
**	Finds the next RFC822 token in a string
**	On entry,
**	*pstr	points to a string containing a word separated
**		by white white space "," ";" or "=". The word
**		can optionally be quoted using <"> or "<" ">"
**		Comments surrrounded by '(' ')' are filtered out
**
**  On exit,
**	*pstr	has been moved to the first delimiter past the
**		field
**		THE STRING HAS BEEN MUTILATED by a 0 terminator
**
**	Returns	a pointer to the first word or NULL on error
*/
static char * HTNextField (char ** pstr)
{
    char * p;
    char * start = NULL;

    if (!pstr || !*pstr) {
        return NULL;
    }
    p = *pstr;
    
    while (1) {
        /* Strip white space and other delimiters */
        while (*p && (isspace((int)*p) || *p == ',' || *p == ';' || *p == '=')) {
            p++;
        }
        if (!*p) {
            *pstr = p;
            return NULL;                                         /* No field */
        }

        if (*p == '"') {                                     /* quoted field */
            start = ++p;
            for (; *p && *p != '"'; p++) {
                if (*p == '\\' && *(p + 1)) {
                    p++;                               /* Skip escaped chars */
                }
            }
            break;                          /* kr95-10-9: needs to stop here */
        } else if (*p == '<') {             /* quoted field */
            start = ++p;
            for (; *p && *p != '>'; p++) {
                if (*p == '\\' && *(p + 1)) {
                    p++;                               /* Skip escaped chars */
                }
            }
            break;                          /* kr95-10-9: needs to stop here */
        } else if (*p == '(') {             /* Comment */
            for (; *p && *p != ')'; p++) {
                if (*p == '\\' && *(p + 1)) {
                    p++;                               /* Skip escaped chars */
                }
            }
            p++;
        } else {                                              /* Spool field */
            start = p;
            while (*p && !isspace((int)*p) && *p != ',' && *p != ';' && *p != '=') {
                p++;
            }
            break;                                                 /* Got it */
        }
    }
    if (*p) {
        *p++ = '\0';
    }
    *pstr = p;
    return start;
}
/*
 * This function parses the authentication tokens from
 * the server when the server is requesting HTTP digest
 * authentication.  The tokens are required to generate
 * a valid authentication response in future HTTP
 * requests.
 */
static EST_ERROR est_io_parse_auth_tokens (EST_CTX *ctx, char *hdr)
{
    int rv = EST_ERR_NONE;
    char *p = hdr;
    char *token = NULL;
    char *value = NULL;
    int diff;
    errno_t safec_rc;

    /*
     * header will come in with the basic or digest field still on the front.
     * skip over it.
     */

    token = HTNextField(&p);

    while ((token = HTNextField(&p))) {
        if (!est_strcasecmp_s(token, "realm")) {
            if ((value = HTNextField(&p))) {
                if (EOK != strncpy_s(ctx->realm, MAX_REALM, value, MAX_REALM)) {
                    rv = EST_ERR_INVALID_TOKEN;
                }
            } else {
                rv = EST_ERR_INVALID_TOKEN;
            }
        } else if (!est_strcasecmp_s(token, "nonce")) {
            if ((value = HTNextField(&p))) {
                if (EOK != strncpy_s(ctx->s_nonce, MAX_NONCE, value, MAX_NONCE)) {
                    rv = EST_ERR_INVALID_TOKEN;
                }                
            } else {
                rv = EST_ERR_INVALID_TOKEN;
            }
        } else if (!est_strcasecmp_s(token, "qop")) {
            if ((value = HTNextField(&p))) {

                if (value[0] == '\0') {
                    EST_LOG_WARN("Unsupported qop value: %s", value);
                } else {
                    safec_rc = memcmp_s(value, sizeof("auth"), "auth", sizeof("auth"), &diff);
                    if (safec_rc != EOK) {
                        EST_LOG_INFO("memcmp_s error 0x%xO\n", safec_rc);
                    }
                    if (diff && (safec_rc == EOK)) {
                        EST_LOG_WARN("Unsupported qop value: %s", value);
                    }
                }
            } else {
                rv = EST_ERR_INVALID_TOKEN;
            }
        } else if (!est_strcasecmp_s(token, "algorithm")) {
            if ((value = HTNextField(&p)) && est_strcasecmp_s(value, "md5")) {
                EST_LOG_ERR("Unsupported digest algorithm: %s", value);
                /*
                 **  We only support MD5 for the moment
                 */
                rv = EST_ERR_INVALID_TOKEN;
            }
        } else if (!est_strcasecmp_s(token, "error")) {
            if ((value = HTNextField(&p))) {
                if (EOK != strncpy_s(ctx->token_error, MAX_TOKEN_ERROR, value, MAX_TOKEN_ERROR)) {
                    rv = EST_ERR_INVALID_TOKEN;
                }
            } else {
                rv = EST_ERR_INVALID_TOKEN;
            }
        } else if (!est_strcasecmp_s(token, "error_description")) {
            if ((value = HTNextField(&p))) {
                if (EOK != strncpy_s(ctx->token_error_desc, MAX_TOKEN_ERROR_DESC, value, MAX_TOKEN_ERROR_DESC)) {
                    rv = EST_ERR_INVALID_TOKEN;
                }
            } else {
                rv = EST_ERR_INVALID_TOKEN;
            }
        } else {
            EST_LOG_WARN("Unsupported auth token ignored: %s", token);
        }

        if (rv == EST_ERR_INVALID_TOKEN) {
            memzero_s(ctx->s_nonce, MAX_NONCE+1);
            break;
        }   
    }
    return (rv);
}
/*
 * This function parses the authentication tokens from
 * the server when the server is requesting HTTP digest
 * authentication.  The tokens are required to generate
 * a valid authentication response in future HTTP
 * requests.
 */
static HTTP_HEADER * parse_http_headers (unsigned char **buf, int *num_headers)
{
    int i;
    HTTP_HEADER *hdrs;
    char *hdr_end;
    errno_t safec_rc;

    *num_headers = 0;
    hdrs = malloc(sizeof(HTTP_HEADER) * MAX_HEADERS);
    if (!hdrs) {
        EST_LOG_ERR("malloc failure");
        return (NULL);
    }

    /*
     * Find offset of header deliminter
     */
    safec_rc = strstr_s((char *) *buf, strnlen_s((char *) *buf, RSIZE_MAX_STR),
            "\r\n\r\n", MAX_HEADER_DELIMITER_LEN, &hdr_end);

    if (safec_rc != EOK) {
        EST_LOG_INFO("strstr_s error 0x%xO\n", safec_rc);
    }

    /*
     * Skip the first line
     */
    skip((char **)buf, "\r\n");

    for (i = 0; i < MAX_HEADERS; i++) {
        hdrs[i].name = skip_quoted((char **)buf, ":", " ", 0);
        hdrs[i].value = skip((char **)buf, "\r\n");
        fflush(stdout);
        EST_LOG_INFO("Found HTTP header -> %s:%s", hdrs[i].name, hdrs[i].value);
        fflush(stdout);
        if (hdrs[i].name[0] == '\0') {
            break;
        }
        *num_headers = i + 1;
        if ((*buf) > (unsigned char *)hdr_end) {
            break;
        }
    }
    EST_LOG_INFO("Found %d HTTP headers\n", *num_headers);
    return (hdrs);
}
/*
 * This function parses the HTTP status code
 * in the first header.  Only a handful of codes are
 * handled by EST.  We are not a full HTTP stack.  Any
 * unrecognized codes will result in an error.
 * Note that HTTP 1.1 is expected.
 */
static int est_io_parse_response_status_code (unsigned char *buf)
{
    if (!strncmp((const char *)buf, EST_HTTP_HDR_200,
                        strnlen_s(EST_HTTP_HDR_200, EST_HTTP_HDR_MAX))) {
        return 200;
    } else if (!strncmp((const char *)buf, EST_HTTP_HDR_202,
                        strnlen_s(EST_HTTP_HDR_202, EST_HTTP_HDR_MAX))) {
        return 202;
    } else if (!strncmp((const char *)buf, EST_HTTP_HDR_204,
                        strnlen_s(EST_HTTP_HDR_204, EST_HTTP_HDR_MAX))) {
        return 204;
    } else if (!strncmp((const char *)buf, EST_HTTP_HDR_400,
                        strnlen_s(EST_HTTP_HDR_400, EST_HTTP_HDR_MAX))) {
        return 400;
    } else if (!strncmp((const char *)buf, EST_HTTP_HDR_401,
                        strnlen_s(EST_HTTP_HDR_401, EST_HTTP_HDR_MAX))) {
        return 401;
    } else if (!strncmp((const char *)buf, EST_HTTP_HDR_404,
                        strnlen_s(EST_HTTP_HDR_404, EST_HTTP_HDR_MAX))) {
        return 404;
    } else if (!strncmp((const char *)buf, EST_HTTP_HDR_423,
                        strnlen_s(EST_HTTP_HDR_423, EST_HTTP_HDR_MAX))) {
        return 423;
    } else {
        EST_LOG_ERR("Unhandled HTTP response %s", buf);
        return -1;
    }
}
/*
 * This function searches for and processes the WWW-Authenticate header from
 * the server.  The result is the setting of the auth_mode value in the
 * context.  If there is no WWW-Authenticate header, or the values in the
 * header are invalid, it will set the auth_mode to a failure setting.  If
 * there are multiple Authenticate headers, only the first one will be
 * processed.
 */
static void est_io_parse_http_auth_request (EST_CTX *ctx,
                                            HTTP_HEADER *hdrs,
                                            int hdr_cnt)
{
    int i;
    EST_ERROR rv;
    int auth_found = 0;

    /*
     * Walk the headers looking for the WWW-Authenticate.  We'll
     * only process the first one.  If an erroneous second one
     * is included, it will be ignored.
     */
    for (i = 0; i < hdr_cnt; i++) {
        if (!strncmp(hdrs[i].name, EST_HTTP_HDR_AUTH, 16)) {

            auth_found = 1;
            
            if (!strncmp(hdrs[i].value, "Basic", 5)) {
                ctx->auth_mode = AUTH_BASIC;
                /* Parse the realm */
                rv = est_io_parse_auth_tokens(ctx, hdrs[i].value);
                if (rv != EST_ERR_NONE) {
                    ctx->auth_mode = AUTH_FAIL;
                }    
            } else
            if (!strncmp(hdrs[i].value, "Digest", 6)) {
                ctx->auth_mode = AUTH_DIGEST;
                /* Parse the realm and nonce */
                rv = est_io_parse_auth_tokens(ctx, hdrs[i].value);
                if (rv != EST_ERR_NONE) {
                    ctx->auth_mode = AUTH_FAIL;
                }    
            } else if (!strncmp(hdrs[i].value, "Bearer", 6)) {
                ctx->auth_mode = AUTH_TOKEN;
                /* Parse the realm and possible token error fields */
                rv = est_io_parse_auth_tokens(ctx, hdrs[i].value);
                if (rv != EST_ERR_NONE) {
                    ctx->auth_mode = AUTH_FAIL;
                }    
            } else {
                EST_LOG_ERR("Unsupported WWW-Authenticate method");
                ctx->auth_mode = AUTH_FAIL;
            }

            break;
        }
    }

    if (!auth_found) {
        EST_LOG_ERR("No WWW-Authenticate header found");
        ctx->auth_mode = AUTH_FAIL;
    }    
    return;
}
/*
 * This function takes in the list of headers that were in the server's
 * response, it walks through the headers looking for a Retry-After response
 * header.  If one is found, the value is parsed and saved away in the EST
 * context.  This value can be in one of two formats, both are represented as
 * an ASCII string.  The first format can be a count of the number of seconds
 * the client should wait before retrying the request.  The second format is a
 * time/date stamp of the point in time at which the client should retry the
 * request.  The result of this function is the setting of the retry_after
 * values in the context.  If no retry-after header was received, or was
 * received and could not be parsed, the values will be zero, otherwise, they
 * are set to the value received.
 *
 * NOTE: The EST client currently does not support the time/date format
 * response and will not process a response in this format.
 */
static EST_ERROR est_io_parse_http_retry_after_resp (EST_CTX *ctx,
                                                     HTTP_HEADER *hdrs,
                                                     int hdr_cnt)
{
    EST_ERROR rv = EST_ERR_INVALID_RETRY_VALUE;
    int i;
    int cmp_result, diff;
    int rc;
    long long int temp_ll;
    int found = 0;
    
    /*
     * Initialize assuming there was no retry-after header.
     */
    ctx->retry_after_delay = 0;
    ctx->retry_after_date = 0;
    
    for (i = 0; i < hdr_cnt; i++) {
        
        cmp_result = strcasecmp_s(hdrs[i].name, sizeof(EST_HTTP_HDR_RETRY_AFTER),
                                  EST_HTTP_HDR_RETRY_AFTER, &diff);
        if (cmp_result == EOK && !diff) {
            
            EST_LOG_INFO("Retry-After value = %s", hdrs[i].value);
            found = 1;
            /*
             * Determine whether or not the value is a date/time string
             * or is an integer representing the number of seconds
             * that the client must wait.
             */
            if (isalpha(*(char *)hdrs[i].value)) {
#ifdef RETRY_AFTER_DELAY_TIME_SUPPORT
                int rc;
                /*
                 * Convert the date/time string into a time_t
                 */
                rc = parsedate(hdrs[i].value, &ctx->retry_after_date);
                if (rc != PARSEDATE_OK) {
                    EST_LOG_ERR("Retry-After value could not be parsed");
                }
#else
                /*
                 * This format is not currently supported.
                 */
                EST_LOG_ERR("Retry-After value not in the correct format");
#endif                
            } else {
                /*
                 * make sure it's all digits, make sure it's no larger than a
                 * four byte integer, and cache away the value returned for
                 * the retry delay.
                 */
                rc = strisdigit_s(hdrs[i].value, 10); // max of 10 decimal places
                if (rc) {
                    temp_ll = atoll(hdrs[i].value);
                    if (temp_ll <= INT_MAX) {
                        ctx->retry_after_delay = (int) temp_ll;
                        rv = EST_ERR_CA_ENROLL_RETRY;
                    } else {
                        EST_LOG_ERR("Retry-After value too large");
                    }
                    
                } else {
                    EST_LOG_ERR("Retry-After value could not be parsed");
                }
            }
        }
    }
    if (found == 0) {
        EST_LOG_ERR("Retry-After header missing");
    }    
    return rv;
}
/*
 * This function verifies the content type header and also
 * returns the length of the content header.  The
 * content type is important.  For example, the content
 * type is expected to be pkcs7 on a simple enrollment.
 */
static int est_io_check_http_hdrs (HTTP_HEADER *hdrs, int hdr_cnt,
                                   EST_OPERATION op)
{
    int i;
    int cl = 0;
    int content_type_present = 0, content_length_present = 0;
    int cmp_result;

    /*
     * Traverse all the http headers and process the ones that need to be
     * checked
     */
    for (i = 0; i < hdr_cnt; i++) {
        /*
         * Content type
         */
        memcmp_s(hdrs[i].name, sizeof(EST_HTTP_HDR_CT), EST_HTTP_HDR_CT,
            sizeof(EST_HTTP_HDR_CT), &cmp_result);
        if (!cmp_result) {
            content_type_present = 1;
            /*
             * Verify content is pkcs7 data
             */
            memcmp_s(hdrs[i].value,
                     strnlen_s(est_op_map[op].content_type, est_op_map[op].length),
                     est_op_map[op].content_type, strnlen_s(est_op_map[op].content_type, est_op_map[op].length),
                      &cmp_result);
            if (cmp_result) {
                EST_LOG_ERR("HTTP content type is %s", hdrs[i].value);
                return 0;
                }
        } else {
            /*
             * Content Length
             */
            memcmp_s(hdrs[i].name, sizeof(EST_HTTP_HDR_CL), EST_HTTP_HDR_CL,
                sizeof(EST_HTTP_HDR_CL), &cmp_result);
            if (!cmp_result) {
                content_length_present = 1;
                cl = atoi(hdrs[i].value);
            }
        }
    }
    
    /*
     * Make sure all the necessary headers were present.
     */
    if (content_type_present == 0 ) {
        EST_LOG_ERR("Missing HTTP content type  header");
        return 0;
    } else if (content_length_present == 0 ) {
        EST_LOG_ERR("Missing HTTP content length header");
        return 0;
    } 
    
    return cl;
}
/*
 * This function verifies the content type header and also
 * returns the length of the content header.  The
 * content type is important.  For example, the content
 * type is expected to be pkcs7 on a simple enrollment.
 */
static int est_ssl_read (SSL *ssl, unsigned char *buf, int buf_max,
                       int sock_read_timeout) 
{
    int timeout;
    int read_fd;
    int rv;
    struct pollfd pfd;
    
    /*
     * load up the timeval struct to be passed to the select
     */
    timeout = sock_read_timeout * 1000;

    read_fd = SSL_get_fd(ssl);
    pfd.fd = read_fd;
    pfd.events = POLLIN;
    pfd.revents = 0;

    errno = 0;
    rv = POLL(&pfd, 1, timeout);
    if (rv == 0) {
        EST_LOG_ERR("Socket poll timeout.  No data received from server.");
        return -1;
    } else if ( rv == -1) {
        EST_LOG_ERR("Socket read failure. errno = %d", errno);
        return -1;
    } else {
        return (SSL_read(ssl, buf, buf_max));
    }
}
/*
 * This function extracts data from the SSL context and puts
 * it into a buffer.
 */
static int est_io_read_raw (SSL *ssl, unsigned char *buf, int buf_max,
                            int *read_cnt, int sock_read_timeout)
{
    int cur_cnt;
    char peek_read_buf;

    *read_cnt = 0;
    cur_cnt  = est_ssl_read(ssl, buf, buf_max, sock_read_timeout);
    if (cur_cnt < 0) {
        EST_LOG_ERR("TLS read error 1");
	ossl_dump_ssl_errors();
        return (EST_ERR_SSL_READ);
    }
    *read_cnt += cur_cnt;

    /*
     * Multiple calls to SSL_read may be required to get the full
     * HTTP payload.
     */
    while (cur_cnt > 0 && *read_cnt < buf_max) {
        cur_cnt = est_ssl_read(ssl, (buf + *read_cnt), (buf_max - *read_cnt),
                               sock_read_timeout);
        if (cur_cnt < 0) {
            EST_LOG_ERR("TLS read error");
	    ossl_dump_ssl_errors();
            return (EST_ERR_SSL_READ);
        }
        *read_cnt += cur_cnt;
    }

    if ((*read_cnt == buf_max) && SSL_peek(ssl, &peek_read_buf, 1)) {
        EST_LOG_ERR("Buffer too small for received message");
        return(EST_ERR_READ_BUFFER_TOO_SMALL);
    }
    
    return (EST_ERR_NONE);
}
/*
 * This function provides the primary entry point into
 * this module.  It's used by the EST client to read the
 * HTTP response from the server.  The data is read from
 * the SSL context and HTTP parsing is invoked.
 *
 * If EST_ERR_NONE is returned then the raw_buf buffer must
 * be freed by the caller, otherwise, it is freed here.
 */
EST_ERROR est_io_get_response (EST_CTX *ctx, SSL *ssl, EST_OPERATION op,
                               unsigned char **buf, int *payload_len)
{
    int rv = EST_ERR_NONE;
    HTTP_HEADER *hdrs;
    int hdr_cnt;
    int http_status;
    unsigned char *raw_buf, *payload_buf, *payload;    
    int raw_len = 0;
    

    raw_buf = malloc(EST_CA_MAX);
    if (raw_buf == NULL) {
        EST_LOG_ERR("Unable to allocate memory");
        return EST_ERR_MALLOC;
    }
    memzero_s(raw_buf, EST_CA_MAX);
    payload = raw_buf;
    
    /*
     * Read the raw data from the SSL connection
     */
    rv = est_io_read_raw(ssl, raw_buf, EST_CA_MAX, &raw_len, ctx->read_timeout);
    if (rv != EST_ERR_NONE) {
        EST_LOG_INFO("No valid response to process");
        free(raw_buf);
        return (rv);
    }
    if (raw_len <= 0) {
        EST_LOG_WARN("Received empty HTTP response from server");
        free(raw_buf);
        return (EST_ERR_HTTP_NOT_FOUND);
    }
    EST_LOG_INFO("Read %d bytes of HTTP data", raw_len);
    
    /*
     * Parse the HTTP header to get the status
     * Look for status 200 for success
     */
    http_status = est_io_parse_response_status_code(raw_buf);
    ctx->last_http_status = http_status;
    hdrs = parse_http_headers(&payload, &hdr_cnt);
    EST_LOG_INFO("HTTP status %d received", http_status);

    /*
     * Check the Status header first to see
     * if the server accepted our request.
     */
    switch (http_status) {
    case 200:
        /* Server reported OK, nothing to do */
        break;
    case 204:
    case 404:
        EST_LOG_ERR("Server responded with 204/404, no content or not found");
        if (op == EST_OP_CSRATTRS) {
	    rv = EST_ERR_NONE;
        } else if (http_status == 404) {
            rv = EST_ERR_HTTP_NOT_FOUND;            
        } else {
            rv = EST_ERR_UNKNOWN;
        }
        break;
    case 202:
        /* Server is asking for a retry */
        EST_LOG_INFO("EST server responded with retry-after");
        rv = est_io_parse_http_retry_after_resp(ctx, hdrs, hdr_cnt);
        break;
    case 400:
        EST_LOG_ERR("HTTP response from EST server was BAD REQUEST");
        rv = EST_ERR_HTTP_BAD_REQ;
	break;
    case 401:
        /* Server is requesting user auth credentials */
        EST_LOG_INFO("EST server requesting user authentication");

        /* Check if we've already tried authenticating, if so, then bail
         * First time through, auth_mode will be set to NONE
         */
        if (ctx->auth_mode == AUTH_DIGEST ||
            ctx->auth_mode == AUTH_BASIC ||
            ctx->auth_mode == AUTH_TOKEN) {
            ctx->auth_mode = AUTH_FAIL;
            rv = EST_ERR_AUTH_FAIL;
            break;
        }
        est_io_parse_http_auth_request(ctx, hdrs, hdr_cnt);
        rv = EST_ERR_AUTH_FAIL;
        break;
            
    case 423:
        EST_LOG_ERR("Server responded with 423, the content we are attempting to access is locked");
        rv = EST_ERR_HTTP_LOCKED;
        break;
    case -1:
        /* Unsupported HTTP response */
        EST_LOG_ERR("Unsupported HTTP response from EST server (%d)", http_status);
        rv = EST_ERR_UNKNOWN;
        break;
    default:
        /* Some other HTTP response was given, do we want to handle these? */
        EST_LOG_ERR("HTTP response from EST server was %d", http_status);
        rv = EST_ERR_HTTP_UNSUPPORTED;
        break;
    }

    if (rv == EST_ERR_NONE) {
        /*
         * Get the Content-Type and Content-Length headers
         * and verify the HTTP response contains the correct amount
         * of data.
         */
        *payload_len = est_io_check_http_hdrs(hdrs, hdr_cnt, op);
        EST_LOG_INFO("HTTP Content len=%d", *payload_len);

        if (*payload_len > EST_CA_MAX) {
            EST_LOG_ERR("Content Length larger than maximum value of %d.",
                        EST_CA_MAX);
            rv = EST_ERR_UNKNOWN;
            *payload_len = 0;
            *buf = NULL;
        } else if (*payload_len == 0) {
            *payload_len = 0;
            *buf = NULL;
        } else {
            /*
             * Allocate the buffer to hold the payload to be passed back
             */
            payload_buf = malloc(*payload_len);   
            if (!payload_buf) {
                EST_LOG_ERR("Unable to allocate memory");
                free(raw_buf);
                free(hdrs);
                return EST_ERR_MALLOC;
            }
            memcpy_s(payload_buf, *payload_len, payload, *payload_len);
            *buf = payload_buf;
        }
    }
    
    if (raw_buf) {
        free(raw_buf);
    }
    if (hdrs) {
        free(hdrs);
    }
    return (rv);
}

/*------------------------------------------------------------------
 * us895.c - Unit Tests for User Story 895 - Proxy CSR Attributes
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US895_SERVER_PORT   29895
#define US895_PROXY_PORT   29095

#ifndef WIN32
#define US895_CACERT        "CA/estCA/cacert.crt"
#define US895_TRUSTED_CERT  "CA/trustedcerts.crt"
#define SERVER_UT_CACERT    "CA/estCA/cacert.crt"
#define SERVER_UT_PUBKEY    "./est_client_ut_keypair"

#define US895_SERVER_IP     "127.0.0.1" 
#define US895_CACERTS       "CA/estCA/cacert.crt"
#define US895_TRUST_CERTS   "CA/trustedcerts.crt"
#define US895_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else
#define US895_CACERT        "CA\\estCA\\cacert.crt"
#define US895_TRUSTED_CERT  "CA\\trustedcerts.crt"
#define SERVER_UT_CACERT     "CA\\estCA\\cacert.crt"
#define SERVER_UT_PUBKEY    "est_client_ut_keypair"

#define US895_SERVER_IP     "127.0.0.1" 
#define US895_CACERTS       "CA\\estCA\\cacert.crt"
#define US895_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US895_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif

#define TEST_ATTR_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR_NOPOP "MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\0"
#define TEST_ATTR_NOPOPPOP "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR_POPADDED "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR1 "MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\0"
#define TEST_ATTR2 "MAA=\0"
#define TEST_ATTR7 "MA==\0"
#define TEST_ATTR2_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR8 "MAthisis badsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR3 "MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\0"
#define TEST_ATTR4_122 "MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR4_122POP "MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR5_117 "MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR5_117POP "MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ATTR6_116 "MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR_244 "MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_245 "MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"
#define TEST_ATTR_250 "MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_250POP "MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ALL_ATTR "MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\0"
#define TEST_1024_NOPOP "MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\0"

#define TEST_1025_NOPOP "MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_1024_POP "MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\0"

#define TEST_LONG_ATTR "MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"

#define EST_UT_MAX_CMD_LEN 255
extern EST_CTX *ectx;

static void us895_clean (void)
{
}

static int us895_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US895_SERVER_PORT,
                  US895_SERVER_CERTKEY,
                  US895_SERVER_CERTKEY,
                  "US895 test realm",
                  US895_CACERT,
                  US895_TRUSTED_CERT,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);

    if (rv) {
        return (rv);
    }

    /*
     * Next we start an EST proxy acting as an RA
     */
    rv = st_proxy_start(US895_PROXY_PORT,
                        US895_SERVER_CERTKEY,
                        US895_SERVER_CERTKEY,
                        "US895 test realm",
                        US895_CACERT,
                        US895_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US895_SERVER_PORT,
                        0,
                        nid);

    SLEEP(1);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us895_init_suite (void)
{
    int rv = 0;
    char cmd[EST_UT_MAX_CMD_LEN];

    printf("Starting EST Server CSR attributes unit tests.\n");

    /*
     * gen the keypair to be used for EST Proxy testing
     */
    snprintf(
        cmd,
        EST_UT_MAX_CMD_LEN,
        "openssl ecparam -name prime256v1 -genkey -out %s",
        SERVER_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US895_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    /*
     * start the server for the tests that need to talk to a server
     */
    us895_clean();

    /*
     * Start an instance of the EST server
     */
    rv = us895_start_server(0, 0);
    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us895_destroy_suite (void)
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
    return 0;
}

static unsigned char * handle_short_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR7);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_corrupt_csrattrs_request (int *csr_len,
                                                        char *path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR8);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_long_csrattrs_request (int *csr_len,
                                                     char *path_seg,
                                                     void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_LONG_ATTR);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_correct_csrattrs_request (int *csr_len,
                                                        char * path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR1);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_nopop_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR_NOPOP);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_empty_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = 0;
    csr_data = NULL;
    return (csr_data);
}

/*
 * Callback function passed to est_proxy_init()
 */
static int proxy_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__,
        openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Test1 - exercise the server side variations triggered
 *         by est_client_get_csrattrs()
 */
static void us895_test1 (void)
{
    EST_CTX *ctx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY * priv_key;
    int csr_len;
    unsigned char *csr_data = NULL;

    SLEEP(1);

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(SERVER_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(SERVER_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", SERVER_UT_PUBKEY);
        return;
    }

    ctx = est_client_init(
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        proxy_manual_cert_verify);
    CU_ASSERT(ctx != NULL);

    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ctx, US895_SERVER_IP, US895_PROXY_PORT, NULL);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    /* should get 204 with no data */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    /* Real base64 string - should pass */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_short_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_corrupt_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_long_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Setting the smallest base64 size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2));
    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR3));
    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));
    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* Enable PoP and test responses with PoP added */
    st_enable_pop();

    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_data != NULL);
    CU_ASSERT(csr_len = 20);
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_POP));
    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));
    CU_ASSERT(
        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));
    CU_ASSERT(
        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);

    /* Real base64 string needs PoP added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 116 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 244 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 245 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 250 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));
    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_nopop_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_empty_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* disable PoP */
    st_disable_pop();

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Real base64 string PoP should not be added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));
    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);

    if (ctx) {
        est_destroy(ctx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us895_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us895_proxy_csrattrs",
            us895_init_suite,
            us895_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "CSR Proxy Attributes API1", us895_test1)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us748.c - Unit Tests for User Story 748 - Proxy simple enroll
 *
 * August, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US748_RETRY_INTERVAL    3600
//#define US748_TCP_PORT        29001

#define US748_TCP_SERVER_PORT       15748
#define US748_TCP_PROXY_PORT        16748

#ifndef WIN32
static char test5_outfile[FILENAME_MAX] = "US748/test5.hdr";
#define US748_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US748_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
/* #define US748_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US748_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US748_PROXY_CERT "US748/cert.pem"  
#define US748_PROXY_KEY "US748/key.pem"
#define US748_CACERT "CA/estCA/cacert.crt"
#define US748_TRUSTED_CERT "CA/trustedcerts.crt"
#else
static char test5_outfile[FILENAME_MAX] = "US748\\test5.hdr";
#define US748_SERVER_CERT "CA\\estCA/private\\estservercertandkey.pem"
#define US748_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
/* #define US748_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US748_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US748_PROXY_CERT "US748\\cert.pem"  
#define US748_PROXY_KEY "US748\\key.pem"
#define US748_CACERT "CA\\estCA\\cacert.crt"
#define US748_TRUSTED_CERT "CA\\trustedcerts.crt"
#endif
/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US748_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the ec.req file:
 *
 * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM
 */
#define US748_PKCS10_DSA1024 "MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\nzn9HujlXNaTA1OhjmPmcJSxT"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the dsa.req file:
 *
 * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM
 */
#define US748_PKCS10_ECDSA256 "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

#define US748_PKCS10_CORRUPT "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

/*
 * The following is a valid CSR that already contains a PoP
 * challengePassword.  This was collected using estserver with
 * the dumpbin() function.  This CSR should never work since
 * the PoP value in it will be stale.
 */
#define US748_PKCS10_STALE_POP "MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40="

#define US748_ENROLL_URL_BA "https://127.0.0.1:15748/.well-known/est/simpleenroll"

#define US748_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US748_UIDPWD_GOOD   "estuser:estpwd"
#define US748_CACERTS       "CA/estCA/cacert.crt"
#define US748_EXPLICIT_CERT "US748/cert-RA.pem" 
#define US748_EXPLICIT_KEY  "US748/key-RA.pem"

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__, openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

static FILE *outfile;
static size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

static void us748_clean (void)
{
}

static int us748_start_server (int manual_enroll, int nid)
{
    int rv = 0;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US748_TCP_SERVER_PORT,
                  US748_SERVER_CERT,
                  US748_SERVER_KEY,
                  "estrealm",
                  US748_CACERT,
                  US748_TRUSTED_CERT,
                  "US748/estExampleCA.cnf",
                  manual_enroll, // manual enroll
                  0,  // disable PoP
                  nid); // ecdhe nid info
    SLEEP(1);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy acting as an RA.
     */
    rv = st_proxy_start(US748_TCP_PROXY_PORT,
                        US748_PROXY_CERT,
                        US748_PROXY_KEY,
                        "estrealm",
                        US748_CACERT,
                        US748_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US748_TCP_SERVER_PORT,
                        0,  // disable PoP
                        nid);  // ecdhe nid info
    SLEEP(1);

    return rv;
}

void us748_stop_server ()
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us748_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US748_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us748_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us748_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us748_destroy_suite (void)
{
    us748_stop_server();
    free(cacerts);
    return 0;
}

/*
 * Simple enroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * enrollment of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - EC prime 256
 *
 * This test case uses libcurl to test simple
 * enrollment of a 256 bit EC CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_ECDSA256,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - DSA prime 1024
 *
 * This test case uses libcurl to test simple
 * enrollment of a 1024 bit DSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_DSA1024,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - Corrupted PKCS10
 *
 * This test case uses libcurl to test simple
 * enrollment usinga corrupted CSR.  HTTP Basic
 * authentication is used.
 */
static void us748_test4 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_CORRUPT,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since the CSR is not valid, the server should
     * respond with a 400.
     */
    CU_ASSERT(rv == 400);
}

/*
 * Simple enroll - manual enrollment
 *
 * This test case verifies the server is
 * sending the appropriate retry-after response.
 */
static void us748_test5 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /* Stop the EST server */
    us748_stop_server();

    /* Restart the server with manual enrollment enabled */
    us748_start_server(1, 0);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, &write_func);
    fclose(outfile);

    /*
     * Since the server hasn't seen this CSR in the past,
     * it should respond with a retry-after 202 response.
     */
    CU_ASSERT(rv == 202);

    /*
     * Verify the retry-after value
     
     sprintf(cmd, "grep Retry-After %s | grep %d", test5_outfile,
     US748_RETRY_INTERVAL);
     rv = system(cmd);
     */
    rv = grep(test5_outfile, "Retry-After: 3600");
    CU_ASSERT(rv == 0);

    /*
     * We will avoid waiting the full retry period since we're
     * only simulating manual enrollment.  Wait a second and then
     * try to enroll the cert again.
     */
    SLEEP(1);
    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    /*
     * This enrollment request should succeed this time
     * Our simulated manual enrollment will automatically
     * enroll on the second attempt.
     */
    CU_ASSERT(rv == 200);

    /* Stop the EST server */
    us748_stop_server();

    /* Restart the server with manual enrollment disabled */
    us748_start_server(0, 0);
}

/*
 * Simple enroll - PoP check fails with curl
 *
 * This test case verifies the server is
 * verifying the PoP from the client CSR.  Since curl does not
 * set the PoP, the EST enrollment should fail.
 */
static void us748_test6 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_enable_pop();

    /*
     * Send a valid enroll request using curl.  Curl does not
     * include the PoP
     */
    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_RSA2048,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    /*
     * The server should respond with a failure code
     */
    CU_ASSERT(rv == 400);

    st_disable_pop();
}

/*
 * Simple enroll - PoP check succeeds with estclient
 *
 * This test case verifies the proxy is
 * verifying the PoP from the client CSR.  We use
 * estclient since it supports the PoP.
 */
static void us748_test7 (void)
{
    long rv;
    EST_CTX *c_ctx;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len;
    unsigned char *attr_data;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * This test case requires PoP to be enabled
     */
    st_enable_pop();

    /*
     * Create a client context
     */
    c_ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(c_ctx != NULL);
    if (!c_ctx) {
        return;
    }

    /*
     * Specify user ID and password since the server is running
     * in Basic Authentication mode.
     */
    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);
    est_client_set_server(c_ctx, "127.0.0.1", US748_TCP_PROXY_PORT, NULL);

    /*
     * get a keypair to be used in the enroll.
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(c_ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll a CSR
     */
    rv = est_client_enroll(c_ctx, "US748-test7 CN", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Client library has obtained the new client certificate.
     * Now retrieve it from the library.
     */
    pkcs7 = malloc(pkcs7_len);
    if (!pkcs7) {
        return;
    }
    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Clean up
     */
    est_destroy(c_ctx);
    EVP_PKEY_free(new_pkey);
    free(pkcs7);

    /*
     * Disable PoP for future test cases
     */
    st_disable_pop();
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 valid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes a valid PoP even when
 * the server didn't request it.  We have to use
 * CiscoEST as the client to generate a CSR containing
 * a valid PoP.  There's no way to include a valid PoP
 * using Curl since the TLS channel binding information
 * is not known in advance.
 */
//The following include should never be used by an application
//but we use it here to hack the EST_CTX values mid-way
//through this test
#include "../../src/est/est_locl.h"
static void us748_test9 (void)
{
    EST_CTX *ctx;
    int rv;
    unsigned char *cacerts;
    int caclen = 0;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len = 0;
    unsigned char *attr_data;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    /*
     * Read in the CA certs
     */
    caclen = read_binary_file(US748_CACERTS, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Init the client context
     */
    ctx = est_client_init(cacerts, caclen, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);

    /*
     * We'll use simple HTTP auth to identify ourselves
     */
    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_client_set_server(ctx, "127.0.0.1", US748_TCP_PROXY_PORT, NULL);

    /*
     * Create some space to hold the cert and generate
     * a private key
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll
     */
    ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
    //We need to force the challengePassword into the CSR    
    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    pkcs7 = malloc(pkcs7_len);
    rv = est_client_copy_enrolled_cert(ctx, pkcs7);

    free(pkcs7);
    est_destroy(ctx);
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 invalid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes an invalid PoP even when
 * the server didn't request it.
 */
static void us748_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,
    US748_PKCS10_STALE_POP,
    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * The enroll request should fail since the PoP was invalid
     * We expect a 400 response.
     */
    CU_ASSERT(rv == 400);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us748_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us748_srv_simpenroll",
            us748_init_suite,
            us748_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "Enroll RSA cert", us748_test1)) ||
        (NULL == CU_add_test(pSuite, "Enroll ECDSA cert", us748_test2)) ||
        (NULL == CU_add_test(pSuite, "Enroll DSA cert", us748_test3)) ||
        (NULL == CU_add_test(pSuite, "Enroll corrupted ECDSA cert", us748_test4)) ||
        (NULL == CU_add_test(pSuite, "Enroll retry-after manual approval ", us748_test5)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP fail with Curl", us748_test6)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP succeed with estclient", us748_test7)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes valid PoP", us748_test9)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes invalid PoP", us748_test10)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us3512.c - Unit Tests URI path segment support in the Server
 *
 * April, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include "../../util/test_utils.h"
#include "st_server.h"
#include "st_proxy.h"

#include "../../src/est/est_locl.h"

extern char tst_srvr_path_seg_enroll[];
extern char tst_srvr_path_seg_cacerts[];
extern char tst_srvr_path_seg_csrattrs[];
extern char tst_srvr_path_seg_auth[];
extern char tst_proxy_path_seg_auth[];

static int path_segment_support;

/*
 * max command line length when generating system commands
 */
#define EST_UT_MAX_CMD_LEN 256

#define US3512_SERVER_PORT      29496
#define US3512_SERVER_IP        "127.0.0.1"
#define US3512_UIDPWD_GOOD      "estuser:estpwd"
#define US3512_UID              "estuser"
#define US3512_PWD              "estpwd"
#ifndef WIN32
#define US3512_CACERTS          "CA/estCA/cacert.crt"
#define US3512_TRUST_CERTS      "CA/trustedcerts.crt"
#define US3512_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US3512_PROXY_CERT       "CA/estCA/private/estservercertandkey.pem"
#define US3512_PROXY_KEY        "CA/estCA/private/estservercertandkey.pem"
#define US3512_CACERT           "CA/estCA/cacert.crt"
/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define CLIENT_UT_CACERT        "CA/estCA/cacert.crt"
#define CLIENT_UT_PUBKEY        "./est_client_ut_keypair"
#else
#define US3512_CACERTS          "CA\\estCA\\cacert.crt"
#define US3512_TRUST_CERTS      "CA/trustedcerts.crt"
#define US3512_SERVER_CERTKEY   "CA\\estCA/private/estservercertandkey.pem"
#define US3512_PROXY_CERT       "CA\\estCA\\private/estservercertandkey.pem"
#define US3512_PROXY_KEY        "CA\\estCA\\private\\estservercertandkey.pem"
#define US3512_CACERT           "CA\\estCA\\cacert.crt"
/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define CLIENT_UT_CACERT        "CA\\estCA\\cacert.crt"
#define CLIENT_UT_PUBKEY        "est_client_ut_keypair"
#endif

#define US3512_ENROLL_URL_BA "https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll"
#define US3512_ENROLL_URL_BA_BACKSLASH "https://127.0.0.1:29496/.well-known/est/cacerts-\\somestring/simpleenroll"
#define US3512_ENROLL_URL_BA_NOSEGMENT "https://127.0.0.1:29496/.well-known/est/simpleenroll"
#define US3512_PKCS10_CT        "Content-Type: application/pkcs10" 

#define US3512_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

#define US3512_TCP_PROXY_PORT       16894
#define PATH_SEG_VALID    "somestring"
#define PATH_SEG_TOO_MANY_SEGS    "somestring1/somestring2"
#define PATH_SEG_IS_OPERATION    "cacerts"
#define PATH_SEG_CONTAINS_OPERATION    "cacertssomestring"
#define PATH_SEG_MAX "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
#define PATH_SEG_TOO_LONG "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"

#define US3512_PROXY_ENROLL_URL_VALID "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_VALID"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_TOO_LONG "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_TOO_LONG"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_MAX "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_MAX"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_TOO_MANY "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_TOO_MANY_SEGS"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_IS_OPERATION "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_IS_OPERATION"/simpleenroll"
#define US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_CONTAINS_OPERATION"/simpleenroll"
#define US3512_PROXY_CACERTS_URL_VALID "https://127.0.0.1:16894/.well-known/est/"PATH_SEG_VALID"/cacerts"

#define US3512_PKCS10_REQ    "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"

static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);

static void us3512_clean (void)
{
}

static int us3512_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start_nocacerts(US3512_SERVER_PORT,
                            US3512_SERVER_CERTKEY,
                            US3512_SERVER_CERTKEY,
                            "US3512 test realm",
                            US3512_CACERTS,
                            US3512_TRUST_CERTS,
                            "CA/estExampleCA.cnf",
                            manual_enroll,
                            0,
                            nid);

    SLEEP(1);

    /*
     * Next we start an EST proxy acting as an RA.
     */
    rv = st_proxy_start_nocacerts(US3512_TCP_PROXY_PORT,
                                  US3512_PROXY_CERT,
                                  US3512_PROXY_KEY,
                                  "estrealm",
                                  US3512_CACERT,
                                  US3512_TRUST_CERTS,
                                  "estuser",
                                  "estpwd",
                                  "127.0.0.1",
                                  US3512_SERVER_PORT,
                                  0,  // disable PoP
                                  0);  // ecdhe nid info
    SLEEP(1);

    return rv;
}

static int path_seg_supported (void)
{

    EST_CTX *ectx;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);

    rc = est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        "test_segment");
    if (rc == EST_ERR_NONE) {
        return 1;
    } else {
        return 0;
    }

    return 0;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.
 * 1. Generate the keypair to be used for this EST Client UT suite
 */
static int us3512_init_suite (void)
{
    int rv = 0;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    char cmd[EST_UT_MAX_CMD_LEN];
    printf("Starting EST Server path segment unit tests.\n");

    if (!path_segment_support) {
        printf(
            "URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \n");
        return 0;
    }

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
        "openssl ecparam -name prime256v1 -genkey -out %s",
        CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us3512_clean();
    /*
     * Start an instance of the EST server
     */
    rv = us3512_start_server(0, 0);
    SLEEP(2);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us3512_destroy_suite (void)
{

    st_stop();
    st_proxy_stop();
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__, openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Sanity check of the server side path segment processing.
 * - simple enroll
 * - direct to server
 * - with path segment
 * Outcome: pass
 */
static void us3512_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US3512_ENROLL_URL_BA_NOSEGMENT, US3512_PKCS10_CT,
    US3512_PKCS10_RSA2048,
    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * This function performs a basic simple enroll using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variety of test cases in this module.
 */
static void us3512_simple_enroll (char *cn, char *server,
                                  EST_ERROR expected_enroll_rv,
                                  char *path_segment)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US3512_SERVER_PORT, path_segment);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * taken from US899/test1
 * Simple enroll -  including a path segment in the uri.
 *
 * Path Segment testing
 * - This verifies the client includes a configured
 *   path segment properly and sends it.
 * - This verifies that the server correctly parses out
 *   a valid path segment and passes it up on a simple enroll.
 *
 */
static void us3512_test2 (void)
{
    LOG_FUNC_NM
    ;
    char *path_segment = "path_segment";

    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    us3512_simple_enroll("TC3512-2", US3512_SERVER_IP, EST_ERR_NONE,
        path_segment);

    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);
}

/*
 * taken from US898/test1
 * Simple re-enroll -  including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on a simple re-enroll
 *   as well as the auth callback.
 */
static void us3512_test3 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) * certs = NULL;
    int i;
    unsigned char *attr_data = NULL;
    int attr_len;
    char *path_segment = "path_seg_us3512_test3";
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        path_segment);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);
    if (rv != EST_ERR_NONE)
        return;

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out, NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i = OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
        certs = p7->d.sign->cert;
        break;
    case NID_pkcs7_signedAndEnveloped:
        certs = p7->d.signed_and_enveloped->cert;
        break;
    default:
        break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs)
        return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);

    /*
     * Wow, that's a lot of work, but we finally have the X509.
     * (don't you just love OpenSSL!!!)
     * Now that we have an X509 representation of the cert,
     * let's try to re-enroll this cert with the CA
     */
    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);

    /*
     * Cleanup
     */
    if (cert)
        X509_free(cert);
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * taken from US897/test11
 * CAcerts to the server - including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on the CA certs callback.
 */
static void us3512_test4 (void)
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY * priv_key;

    char *path_segment = "path_seg_us3512_test4";

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        path_segment);

    /*
     * clear out the global that proves that the path segment
     * made it to the application layer's cal back function
     */
    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);
    /*
     * verify that the path segment made it all the way to the callback function
     * at the application layer
     */
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/*
 * taken from US898/test1
 * CSRAttributes -  including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on a csr attributes callback
 */
static void us3512_test5 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    unsigned char *new_cert = NULL;
    X509 *cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;
    char *path_segment = "path_seg_us3512_test5";
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,
        path_segment);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * clear out the global that proves that the path segment
     * made it to the application layer's cal back function
     */
    memset(tst_srvr_path_seg_csrattrs, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    /*
     * issue the get ca certs request
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rv == EST_ERR_NONE);
    /*
     * verify that the path segment made it all the way to the callback function
     * at the application layer
     */
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_csrattrs) == 0);

    /*
     * Cleanup
     */
    if (cert)
        X509_free(cert);
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * Test the flow of path segments through proxy mode - valid path segment
 * SimpleEnroll
 */
static void us3512_test6 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);

    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    rv = curl_http_post(US3512_PROXY_ENROLL_URL_VALID, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD,
    US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    CU_ASSERT(strcmp(PATH_SEG_VALID, tst_srvr_path_seg_enroll) == 0);

    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Test the flow of path segments through proxy mode -
 *  path segment is set to the maximum size
 *
 */
static void us3512_test7 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_MAX, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that is too long, it
     * should get caught at the proxy and a 400 should be returned
     */
    CU_ASSERT(rv == 200);
}

/*
 * Test the flow of path segments through proxy mode -
 *  path segment that is too large
 *
 */
static void us3512_test8 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_LONG, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that is too long, it
     * should get caught at the proxy and a 400 should be returned
     */
    CU_ASSERT(rv == 400);
}

/*
 * Test segment that is an operation path
 *
 */
static void us3512_test9 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_IS_OPERATION, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that equals an operation we
     * should get a 400 in return
     */
    CU_ASSERT(rv == 400);
}

/*
 * Test segment that is an operation path
 *
 */
static void us3512_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_MANY, US3512_PKCS10_CT,
    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,
        NULL, NULL);
    /*
     * Since we passed in a path segment that equals an operation we
     * should get a 400 in return
     */
    CU_ASSERT(rv == 400);
}

/*
 * Test segment that contains a valid operation string within it,
 * in this case, at the front.  This is a valid path segment, so
 * the test should pass.
 *
 */
static void us3512_test11 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);

    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);
    memset(tst_proxy_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    rv = curl_http_post(US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION,
    US3512_PKCS10_CT, US3512_PKCS10_REQ,
    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);

    CU_ASSERT(
        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_srvr_path_seg_enroll) == 0);
    CU_ASSERT(
        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_proxy_path_seg_auth) == 0);

    /*
     * Since we passed in a path segment that equals an operation we
     * should get a 400 in return
     */
    CU_ASSERT(rv == 200);
}

/*
 * taken from US897/test11
 * CAcerts to the server - including a path segment in the uri.
 *
 * Path Segment testing
 * - Verifies the client includes a configured
 *   path segment
 * - Verifies that the server correctly parses out
 *   a valid path segment and passes it up on the CA certs callback.
 */
static void us3512_test12 (void)
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY * priv_key;

    char *path_segment = "path_seg_us3512_test4";

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US3512_SERVER_IP, US3512_TCP_PROXY_PORT,
        path_segment);

    /*
     * clear out the global that proves that the path segment
     * made it to the application layer's cal back function
     */
    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);
    /*
     * verify that the path segment made it all the way to the callback function
     * at the application layer
     */
    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us3512_add_suite (void)
{
    CU_ErrorCode CU_error;

#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us3512_server_path_seg",
            us3512_init_suite,
            us3512_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /*
     * check to see if path segment support has been compiled in
     */
    if (!path_seg_supported()) {
        printf("URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \n");
        path_segment_support = 0;
        return 0;
    }
    path_segment_support = 1;

    if (path_segment_support) {

        /* add the tests to the suite */
        /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
        if (
            (NULL == CU_add_test(pSuite, "EST Client: Simple enroll with no path segment", us3512_test1)) ||
            (NULL == CU_add_test(pSuite, "EST Server: Simple Enroll with path segment", us3512_test2)) ||
            (NULL == CU_add_test(pSuite, "EST Server: Simple Re-enroll with path segment", us3512_test3)) ||
            (NULL == CU_add_test(pSuite, "EST Server: CACerts with path segment", us3512_test4)) ||
            (NULL == CU_add_test(pSuite, "EST Server: CSRAttrs with path segment", us3512_test5)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment", us3512_test6)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment at the max", us3512_test7)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment too long", us3512_test8)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment that is operation", us3512_test9)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment containing too many segments", us3512_test10)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment containing an operation", us3512_test11)) ||
            (NULL == CU_add_test(pSuite, "EST Server: EST Proxy with path segment valid and cacerts", us3512_test12))
            )
            {
                CU_error = CU_get_error();
                printf("%d\n", CU_error);

                CU_cleanup_registry();
                printf("%s\n", CU_get_error_msg());
                return CU_get_error();
            }
        }
        return CUE_SUCCESS;
     #endif
}


/*------------------------------------------------------------------
 * us3612.c - Unit Tests for User Story US3612 - Encrypted Private Key Support
 *
 *
 *
 * July, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
*/

#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static char *key_password = NULL;
static int cacerts_len = 0;

#define US3612_SERVER_PORT   29899
#define US3612_SERVER_IP     "127.0.0.1"
#define US3612_UID           "estuser"
#define US3612_PWD           "estpwd"
#define US3612_GOOD_PWD "us3612"
#define US3612_BAD_PWD  "thiscantpossiblywork"
#define RSA_KEYSIZE 4096

/*
 * Key wrap algorithm optionally used to protect private keys
 */
#define EST_PRIVATE_KEY_ENC EVP_aes_128_cbc()

/*
 * The following certs are used for FQDN testing
 */
#ifndef WIN32
#define US3612_CACERTS       "CA/estCA/cacert.crt"
#define US3612_TRUST_CERTS   "CA/trustedcerts.crt"
#define US3612_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US3612_PRIVATE_KEY_FILE "US3612/us3612_key.pem"

#else
#define US3612_CACERTS       "CA\\estCA\\cacert.crt"
#define US3612_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US3612_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"
#define US3612_PRIVATE_KEY_FILE "US3612\\us3612_key.pem"

static CRITICAL_SECTION logger_critical_section;
static void us3612_logger_stderr (char *format, va_list l)
{
    EnterCriticalSection(&logger_critical_section);
    vfprintf(stderr, format, l);
    fflush(stderr);
    LeaveCriticalSection(&logger_critical_section);
}
#endif

unsigned char *BIO_copy_data(BIO *out, int *data_lenp) {
    unsigned char *data, *tdata;
    int data_len;

    data_len = BIO_get_mem_data(out, &tdata);
    data = malloc(data_len+1);
    if (data) {
        memcpy(data, tdata, data_len);
	data[data_len]='\0';  // Make sure it's \0 terminated, in case used as string
	if (data_lenp) {
	    *data_lenp = data_len;
	}
    } else {
        printf("malloc failed");
    }
    return data;
}

char *generate_private_RSA_key (int key_size, pem_password_cb *cb)
{
    char *key_data = NULL;

    RSA *rsa = RSA_new();
    if (!rsa) {
        return NULL;
    }
    BIGNUM *bn = BN_new();
    if (!bn) {
        RSA_free(rsa);
        return NULL;
    }

    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, key_size, bn, NULL);

    do {
        BIO *out = BIO_new(BIO_s_mem());
        if (!out) {
            break;
        }
        PEM_write_bio_RSAPrivateKey(out, rsa, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);
        key_data = (char *)BIO_copy_data(out, NULL);
        BIO_free(out);
        if (key_data && !key_data[0]) {
            // happens if passphrase entered via STDIN does not verify or has less than 4 characters
            free(key_data);
            key_data = NULL;
        }
    } while (cb && !key_data);

    RSA_free(rsa);
    BN_free(bn);
    return (key_data);
}

char *generate_private_EC_key (int curve_nid, pem_password_cb *cb)
{
    EC_KEY *eckey;
    EC_GROUP *group = NULL;
    char *key_data = NULL;
    int asn1_flag = OPENSSL_EC_NAMED_CURVE;
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    /*
     * Generate an EC key
     */

    eckey = EC_KEY_new();
    if (!eckey) {
        return NULL;
    }

    group = EC_GROUP_new_by_curve_name(curve_nid);
    EC_GROUP_set_asn1_flag(group, asn1_flag);
    EC_GROUP_set_point_conversion_form(group, form);
    EC_KEY_set_group(eckey, group);
    if (!EC_KEY_generate_key(eckey)) {
        return (NULL);
    }

    do {
        BIO *out = BIO_new(BIO_s_mem());
        if (!out) {
            break;
        }
        PEM_write_bio_ECPKParameters(out, group);
        PEM_write_bio_ECPrivateKey(out, eckey, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);
        key_data = (char *)BIO_copy_data(out, NULL);
        BIO_free(out);
        if (key_data && !strstr(key_data, "-----BEGIN EC PRIVATE KEY-----")) {
            // happens if passphrase entered via STDIN does not verify or has less than 4 characters
            free(key_data);
            key_data = NULL;
        }
    } while (cb && !key_data);

    EC_KEY_free(eckey);
    return (key_data);
}

static int string_password_cb (char *buf, int size, int wflag, void *data)
{
    /*
     * Hard code a password for this suite
     */
    strncpy(buf, key_password, size);
    return(strnlen(buf, size));
}


static void us3612_clean (void)
{
}

static int us3612_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US3612_SERVER_PORT,
              US3612_SERVER_CERTKEY,
              US3612_SERVER_CERTKEY,
              "US3612 test realm",
              US3612_CACERTS,
              US3612_TRUST_CERTS,
              "CA/estExampleCA.cnf",
          manual_enroll,
          0,
          nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us3612_init_suite (void)
{
    int rv;

#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us3612_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US3612_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
    return 1;
    }

    us3612_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us3612_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us3612_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Simple Enroll b- client
 * Load in a password prortected private key with
 * the correct passphrase and attempt to enroll for a certificate
 */
static void us3612_test1 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len,
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);

    /*
     * Read in our test private key
     * generated via the command below:
     *
     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096
     */

    key_password = US3612_GOOD_PWD;

    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);

    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TCUS3612-1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
    new_cert = malloc(pkcs7_len);
    CU_ASSERT(new_cert != NULL);
    rv = est_client_copy_enrolled_cert(ectx, new_cert);
    CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Simple enroll CSR
 *
 * Load in a password protected private key with the incorrect password
 * and attempt to enroll for a certificate. This will fail.
 */
static void us3612_test2 (void)
{
     EST_CTX *ectx;
     EVP_PKEY *key;
     int rv;
     int pkcs7_len = 0;
     unsigned char *new_cert = NULL;
     unsigned char *attr_data = NULL;
     int attr_len;

     /*
      * Create a client context
      */
     ectx = est_client_init(cacerts, cacerts_len,
                            EST_CERT_FORMAT_PEM,
                            client_manual_cert_verify);
     CU_ASSERT(ectx != NULL);

     /*
      * Set the authentication mode to use a user id/password
      */
     rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
     CU_ASSERT(rv == EST_ERR_NONE);

     /*
      * Set the EST server address/port
      */
     est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);

     /*
      * Read in our test private key
      * generated via the command below:
      *
      * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096
      */

     key_password = US3612_BAD_PWD;

     key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);

     CU_ASSERT(key == NULL);

     /*
      * Get the latest CSR attributes
      */
     rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
     CU_ASSERT(rv == EST_ERR_NONE);

     /*
      * Use the simplified API to enroll a CSR
      */
     rv = est_client_enroll(ectx, "TC3612-2", &pkcs7_len, key);
     CU_ASSERT(rv != EST_ERR_NONE);

     /*
      * Cleanup
      */
     EVP_PKEY_free(key);
     if (new_cert) free(new_cert);
     est_destroy(ectx);
}


/*
 * Simple enroll CSR
 *
 * Change the password used by the callback after reading
 * in the protected private key file.
 */
static void us3612_test3 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len,
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);

    /*
     * Read in our test private key
     * generated via the command below:
     *
     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096
     */

    key_password = US3612_GOOD_PWD;

    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);

    CU_ASSERT(key != NULL);

    /*
     * Change out the password, EVP_PKEY should remain unaffected
     */

    key_password = US3612_BAD_PWD;

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TCUS3612-3", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
    new_cert = malloc(pkcs7_len);
    CU_ASSERT(new_cert != NULL);
    rv = est_client_copy_enrolled_cert(ectx, new_cert);
    CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Test key generation utility functions
 * and associated password callbacks
 */
static void us3612_test4 (void)
{
    char * new_pkey = NULL;

    /*
     * Generate an RSA key without a password
     */

    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, NULL);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;

    /*
     * Generate an RSA key with password
     */

    key_password = US3612_GOOD_PWD;

    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, string_password_cb);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;

    /*
     * Generate an EC key without a password
     */

    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) "prime256v1"), NULL);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;


    /*
     * Generate an EC key with a password
     */
    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) "prime256v1"), string_password_cb);
    CU_ASSERT(new_pkey != NULL);
    printf("\n%s\n", new_pkey);
    free(new_pkey);
    new_pkey = NULL;

}

int us3612_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us3612_encrypted_private_keys",
                      us3612_init_suite,
              us3612_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /*
    * Add the tests to the suite
    */
   if ((NULL == CU_add_test(pSuite, "Client simple enroll w/ correct pwd", us3612_test1)) ||
       (NULL == CU_add_test(pSuite, "Client simple enroll w/ incorrect pwd", us3612_test2)) ||
       (NULL == CU_add_test(pSuite, "Client simple enroll w/ incorrect pwd", us3612_test3)) ||
       (NULL == CU_add_test(pSuite, "Keygen Test", us3612_test4)))
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}

/*------------------------------------------------------------------
 * us1159.c - Unit Tests for User Story 1159 - CSR Attributes enforce
 *
 * October, 2014
 *
 * Copyright (c) 2014, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include "test_utils.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>
#include "st_server.h"

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifndef WIN32
#define US1159_CACERTS          "CA/estCA/cacert.crt"
#define US1159_CACERT           "CA/estCA/cacert.crt"
#define US1159_SERVER_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US1159_SERVER_KEY       "CA/estCA/private/estservercertandkey.pem"
#else
#define US1159_CACERTS          "CA\\estCA\\cacert.crt"
#define US1159_CACERT           "CA\\estCA\\cacert.crt"
#define US1159_SERVER_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US1159_SERVER_KEY       "CA\\estCA\\private\\estservercertandkey.pem"
#endif
#define US1159_UID              "estuser"
#define US1159_PWD              "estpwd"

#define US1159_SERVER_PORT      15897
#define US1159_SERVER_IP        "127.0.0.1"

#define US1159_ATTR_POP_ONLY    "MAsGCSqGSIb3DQEJBw==\0"
#define US1159_ATTR_CN_ONLY     "MAUGA1UEAw==\0"
#define US1159_ATTR_TEST        "MHEGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBgUrgQQAIgYDVQQDBggqhkjOPQQDAg==\0"

extern EST_CTX *ectx;
static unsigned char *cacerts = NULL;
static int cacerts_len = 0;
static char *attrs;

static unsigned char * handle_csrattrs_request (int *csr_len, char *path_seg,
                                                void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(attrs);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, attrs, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static void us1159_clean (void)
{
}

int us1159_start_server ()
{
    int rv = 0;

    /*
     * Start an EST server acting as the CA
     */
    rv = st_start(US1159_SERVER_PORT,
                  US1159_SERVER_CERT,
                  US1159_SERVER_KEY,
                  "estrealm",
                  US1159_CACERT,
                  "CA/trustedcerts.crt",
                  "CA/estExampleCA.cnf",
                  0, // manual enroll
                  0,  // disable PoP
                  0); // ecdhe nid info
    if (rv != EST_ERR_NONE) {
        printf("\nUnable to start EST server for US1159.\n");
        return rv;
    }

    st_enable_csrattr_enforce();

    rv = est_set_csr_cb(ectx, &handle_csrattrs_request);
    if (rv != EST_ERR_NONE) {
        printf("\nUnable to set EST CSR Attributes callback for US1159.\n");
        return (rv);
    }

    SLEEP(1);

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1159_init_suite (void)
{
    int rv;

    us1159_clean();

    printf(
        "\nStarting server for CSR attributes enforcement unit tests (US1159).\n");

    attrs = US1159_ATTR_POP_ONLY;
    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1159_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1159_start_server();

    return rv;
}

void us1159_stop_server ()
{
    st_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1159_destroy_suite (void)
{
    us1159_stop_server();
    free(cacerts);
    printf("Completed CSR attributes enforcement unit tests.\n");
    return 0;
}

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * This function generates an EC public/private key
 * pair that will be used with the certificate
 * we provision.
 */
static EVP_PKEY * generate_ec_private_key (int nid)
{
    EC_KEY *eckey;
    EC_GROUP *group = NULL;
    BIO *out;
    unsigned char *tdata;
    unsigned char *key_data;
    int key_len;
    BIO *keyin;
    EVP_PKEY *new_priv_key;
    int asn1_flag = OPENSSL_EC_NAMED_CURVE;
    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;

    /*
     * Generate an EC key
     */
    group = EC_GROUP_new_by_curve_name(nid /*NID_X9_62_prime256v1*/);
    EC_GROUP_set_asn1_flag(group, asn1_flag);
    EC_GROUP_set_point_conversion_form(group, form);
    eckey = EC_KEY_new();
    EC_KEY_set_group(eckey, group);
    if (!EC_KEY_generate_key(eckey)) {
        printf("Failed to generate EC key\n");
        return NULL;
    }
    out = BIO_new(BIO_s_mem());
    PEM_write_bio_ECPKParameters(out, group);
    PEM_write_bio_ECPrivateKey(out, eckey, NULL, NULL, 0, NULL, NULL);
    key_len = BIO_get_mem_data(out, &tdata);
    key_data = malloc(key_len + 1);
    memcpy(key_data, tdata, key_len);
    EC_KEY_free(eckey);
    BIO_free(out);

    /*
     * read it back in to an EVP_PKEY struct
     */
    keyin = BIO_new(BIO_s_mem());
    keyin = BIO_new_mem_buf(key_data, key_len);

    /*
     * This reads in the private key file, which is expected to be a PEM
     * encoded private key.  If using DER encoding, you would invoke
     * d2i_PrivateKey_bio() instead.
     */
    new_priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    if (new_priv_key == NULL) {
        printf("\nError while reading PEM encoded private key\n");
        ERR_print_errors_fp(stderr);
        return NULL;
    }
    BIO_free(keyin);
    free(key_data);

    return (new_priv_key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing no CSR attributes other than
 * challengePassword. The enroll should succeed.
 */
static void us1159_test1 (void)
{
    EST_CTX *ctx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;

    LOG_FUNC_NM
    ;

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ctx, "Test 1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ctx);
}

/*
 * This routine builds a PKCS10 CSR.
 */
static EST_ERROR populate_x509_request (X509_REQ *req, EVP_PKEY *pkey, char *cn)
{
    X509_NAME *subj;
    int rv;

    /* setup version number */
    rv = X509_REQ_set_version(req, 0L);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_VER);
    }

    /*
     * Add Common Name entry
     */
    subj = X509_REQ_get_subject_name(req);
    rv = X509_NAME_add_entry_by_txt(subj, "CN", MBSTRING_ASC,
        (const unsigned char*) cn, -1, -1, 0);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_CN);
    }

    /*
     * Add serial number Name entry
     */
    rv = X509_NAME_add_entry_by_NID(subj, NID_serialNumber, MBSTRING_ASC,
        (unsigned char*) "12349999B", -1, -1, 0);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_CN);
    }

    /*
     * Add all the other attributes that the server will be expecting
     */
    rv = X509_REQ_add1_attr_by_txt(req, "1.3.6.1.1.1.1.22", MBSTRING_ASC,
        (const unsigned char*) "dummymac", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.1", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.2", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.3", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "2.999.4", MBSTRING_ASC,
        (const unsigned char*) "dummy", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "1.2.840.10045.2.1", MBSTRING_ASC,
        (const unsigned char*) "1.3.132.0.34", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_txt(req, "1.2.840.10045.4.3.3", MBSTRING_ASC,
        (const unsigned char*) "", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    rv = X509_REQ_add1_attr_by_NID(req, NID_serialNumber, MBSTRING_ASC,
        (const unsigned char*) "123456789A", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_UNKNOWN);
    }

    /*
     * Set the public key on the request
     */
    rv = X509_REQ_set_pubkey(req, pkey);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
        return (EST_ERR_X509_PUBKEY);
    }

    X509_REQ_print_fp(stderr, req);

    return (EST_ERR_NONE);
}

#if 0
/*
 * Sign an X509 certificate request using the digest and the key passed.
 * Returns OpenSSL error code from X509_REQ_sign_ctx();
 */
static int sign_X509_REQ(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
    int rv;
    EVP_PKEY_CTX *pkctx = NULL;
    EVP_MD_CTX mctx;

    EVP_MD_CTX_init(&mctx);

    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {
        return 0;
    }

    /*
     * Encode using DER (ASN.1)
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     */
    x->req_info->enc.modified = 1;
    rv = X509_REQ_sign_ctx(x, &mctx);

    EVP_MD_CTX_cleanup(&mctx);

    return (rv);
}
#endif

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR. The enroll should succeed.
 */
static void us1159_test2 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 2");
    CU_ASSERT(rv == EST_ERR_NONE);

#if 0
    /*
     * Sign the request
     */
    ossl_rv = sign_X509_REQ(req, key, EVP_sha256());
    CU_ASSERT(ossl_rv == 0);
    if (!ossl_rv) {
        ERR_print_errors_fp(stderr);
    }
#endif

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    if (new_cert)
        free(new_cert);
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR except that the 521-bit curve is used. The enroll
 * should fail since the server CSR attrs specify to
 * use the 384-bit curve.
 */
static void us1159_test3 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp521r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 3");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR except that SHA-384 is used for the
 * signature. The enroll should fail since the server
 * CSR attrs require SHA-256.
 */
static void us1159_test4 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 3");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Change to SHA-384 for the signature
     */
    rv = est_client_set_sign_digest(ctx, NID_sha384);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll when the
 * server has no CSR attributes configured to only
 * require the CommonName.  The CSR attributes on
 * the server are configured through the static API,
 * not the callback.
 */
static void us1159_test10 (void)
{
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * Disable the CSR attr callback on the server context
     */
    rv = est_set_csr_cb(ectx, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Configure the static CSR attributes value
     */
    rv = est_server_init_csrattrs(ectx, US1159_ATTR_CN_ONLY,
        strlen(US1159_ATTR_CN_ONLY));
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Enroll a new cert
     */
    rv = est_client_enroll(ctx, "Test 10", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR. The client also provides a large
 * quantity of additional attriutes.
 */
static void us1159_test20 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    int rv;
    EST_CTX *ctx = NULL;
    int i;
    char t_attr_str[50];

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 20");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Jam another 25 attributes into the request
     * We could do more, but this causes a failure on the EST server when
     * base64 decoding the CSR due to a safeC constraint.  The max string
     * size in safeC defaults to 4096 bytes.
     */
    for (i = 0; i < 25; i++) {
        sprintf(t_attr_str, "2.899.%d", i);
        rv = X509_REQ_add1_attr_by_txt(req, t_attr_str, MBSTRING_ASC,
            (const unsigned char*) "whatever", -1);
        CU_ASSERT(rv != 0);
        if (!rv) {
            ERR_print_errors_fp(stderr);
        }
    }

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    if (new_cert)
        free(new_cert);
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll with the
 * client providing all the required CSR attributes in
 * the CSR. The client also provides an attribute with
 * a very long name and value.
 */
static void us1159_test21 (void)
{
    X509_REQ *req = NULL;
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    /*
     * This sets the full list of attributes on the server
     */
    attrs = US1159_ATTR_TEST;

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    req = X509_REQ_new();
    CU_ASSERT(req != NULL);

    rv = populate_x509_request(req, key, "Test 21");
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Add an attribute with a long value
     */
    rv =
            X509_REQ_add1_attr_by_txt(req, "2.993.8", MBSTRING_ASC,
                (const unsigned char*) "This is an attribute with a very long value that could potentially cause a problem on the EST server.  0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789",
                -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
    }

    /*
     * Add an attribute with a long name
     */
    rv =
            X509_REQ_add1_attr_by_txt(req,
                "2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.7",
                MBSTRING_ASC, (const unsigned char*) "0123456789", -1);
    CU_ASSERT(rv != 0);
    if (!rv) {
        ERR_print_errors_fp(stderr);
    }
    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ctx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    if (new_cert)
        free(new_cert);
    if (ctx)
        est_destroy(ctx);
    if (req)
        X509_REQ_free(req);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll when the
 * server has no CSR attributes configured with
 * PoP enabled.
 */
static void us1159_test50 (void)
{
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    st_enable_pop();

    /*
     * Disable the CSR attr callback on the server context
     */
    rv = est_set_csr_cb(ectx, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    rv = est_client_force_pop(ctx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Enroll a new cert
     */
    rv = est_client_enroll(ctx, "Test 50", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (key)
        EVP_PKEY_free(key);
}

/*
 * This test attempts does a simple enroll when the
 * server has no CSR attributes configured with
 * PoP disabled.
 */
static void us1159_test51 (void)
{
    EVP_PKEY *key = NULL;
    int pkcs7_len = 0;
    int rv;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    st_disable_pop();

    /*
     * Disable the CSR attr callback on the server context
     */
    rv = est_set_csr_cb(ectx, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * generate a private key
     */
    key = generate_ec_private_key(NID_secp384r1);
    CU_ASSERT(key != NULL);

    /*
     * Create a client context
     */
    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ctx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);

    /*
     * Enroll a new cert
     */
    rv = est_client_enroll(ctx, "Test 51", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (ctx)
        est_destroy(ctx);
    if (key)
        EVP_PKEY_free(key);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us1159_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1159_csr_attr_enforce",
            us1159_init_suite,
            us1159_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
    if ((NULL == CU_add_test(pSuite, "No attributes required w/pop", us1159_test1)) ||
        (NULL == CU_add_test(pSuite, "All attributes provided w/pop", us1159_test2)) ||
        (NULL == CU_add_test(pSuite, "EC public key wrong curve w/pop", us1159_test3)) ||
        (NULL == CU_add_test(pSuite, "Wrong hash algorithm in signature w/pop", us1159_test4)) ||
        (NULL == CU_add_test(pSuite, "CN only using static config w/pop", us1159_test10)) ||
        (NULL == CU_add_test(pSuite, "A lot of attributes w/pop", us1159_test20)) ||
        (NULL == CU_add_test(pSuite, "Long attribute w/pop", us1159_test21)) ||
        (NULL == CU_add_test(pSuite, "No CSR attrs on server w/pop", us1159_test50)) ||
        (NULL == CU_add_test(pSuite, "No CSR attrs on server w/o pop", us1159_test51)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us903.c - Unit Tests for User Story 903 - Server simple enroll
 *
 * August, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifndef WIN32
static char test5_outfile[FILENAME_MAX] = "US903/test5.hdr";
#define US903_CACERTS       "CA/estCA/cacert.crt"
#define US903_EXPLICIT_CERT "US903/cert-RA.pem" 
#define US903_EXPLICIT_KEY  "US903/key-RA.pem"
#define US903_CACERTS       "CA/estCA/cacert.crt"
#define US903_TRUSTED_CERT  "CA/trustedcerts.crt"
#define US903_SERVER_CERT_AND_KEY "CA/estCA/private/estservercertandkey.pem"
#else
static char test5_outfile[FILENAME_MAX] = "US903\\test5.hdr";
#define US903_CACERTS       "CA\\estCA\\cacert.crt"
#define US903_EXPLICIT_CERT "US903\\cert-RA.pem" 
#define US903_EXPLICIT_KEY  "US903\\key-RA.pem"
#define US903_CACERTS       "CA\\estCA\\cacert.crt"
#define US903_TRUSTED_CERT  "CA\\trustedcerts.crt"
#define US903_SERVER_CERT_AND_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US903_RETRY_INTERVAL    3600
#define US903_TCP_PORT      29001

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US903_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the ec.req file:
 *
 * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM
 */
#define US903_PKCS10_DSA1024 "MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\nzn9HujlXNaTA1OhjmPmcJSxT"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the dsa.req file:
 *
 * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM
 */
#define US903_PKCS10_ECDSA256 "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

#define US903_PKCS10_CORRUPT "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

/*
 * The following is a valid CSR that already contains a PoP
 * challengePassword.  This was collected using estserver with
 * the dumpbin() function.  This CSR should never work since
 * the PoP value in it will be stale.
 */
#define US903_PKCS10_STALE_POP "MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40="

#define US903_ENROLL_URL_BA "https://127.0.0.1:29001/.well-known/est/simpleenroll"
#define US903_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US903_UIDPWD_GOOD   "estuser:estpwd"

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__,
        openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

static FILE *outfile;
static size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

static void us903_clean (void)
{
}

static int us903_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US903_TCP_PORT,
                  US903_SERVER_CERT_AND_KEY,
                  US903_SERVER_CERT_AND_KEY,
                  "US903 test realm",
                  US903_CACERTS,
                  US903_TRUSTED_CERT,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us903_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US903_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us903_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us903_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us903_destory_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}

/*
 * Simple enroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * enrollment of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
    US903_PKCS10_RSA2048,
    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - EC prime 256
 *
 * This test case uses libcurl to test simple
 * enrollment of a 256 bit EC CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_ECDSA256,US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - DSA prime 1024
 *
 * This test case uses libcurl to test simple
 * enrollment of a 1024 bit DSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_DSA1024, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - Corrupted PKCS10
 *
 * This test case uses libcurl to test simple
 * enrollment usinga corrupted CSR.  HTTP Basic
 * authentication is used.
 */
static void us903_test4 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_CORRUPT, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since the CSR is not valid, the server should
     * respond with a 400.
     */
    CU_ASSERT(rv == 400);
}

/*
 * Simple enroll - manual enrollment
 *
 * This test case verifies the server is
 * sending the appropriate retry-after response.
 */
static void us903_test5 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /* Stop the EST server */
    st_stop();

    /* Restart the server with manual enrollment enabled */
    us903_start_server(1, 0);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, &write_func);
    fclose(outfile);

    /*
     * Since the server hasn't seen this CSR in the past,
     * it should respond with a retry-after 202 response.
     */
    CU_ASSERT(rv == 202);

    /*
     * Verify the retry-after value
     */
    rv = grep(test5_outfile, "Retry-After: 3600");
    CU_ASSERT(rv == 0);

    /*
     * We will avoid waiting the full retry period since we're
     * only simulating manual enrollment.  Wait a second and then
     * try to enroll the cert again.
     */
    SLEEP(1);
    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);

    /*
     * This enrollment request should succeed this time
     * Our simulated manual enrollment will automatically
     * enroll on the second attempt.
     */
    CU_ASSERT(rv == 200);

    /* Stop the EST server */
    st_stop();

    /* Restart the server with manual enrollment disabled */
    us903_start_server(0, 0);
}

/*
 * Simple enroll - PoP check fails with curl
 *
 * This test case verifies the server is
 * verifying the PoP from the client CSR.  Since curl does not
 * set the PoP, the EST enrollment should fail.
 */
static void us903_test6 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_enable_pop();

    /*
     * Send a valid enroll request using curl.  Curl does not
     * include the PoP
     */
    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);

    /*
     * The server should respond with a failure code
     */
    CU_ASSERT(rv == 400);

    st_disable_pop();
}

/*
 * Simple enroll - PoP check succeeds with estclient
 *
 * This test case verifies the server is
 * verifying the PoP from the client CSR.  We use
 * estclient since it supports the PoP.
 */
static void us903_test7 (void)
{
    long rv;
    EST_CTX *c_ctx;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len;
    unsigned char *attr_data;
    int attr_len;
    int http_status;

    LOG_FUNC_NM
    ;

    /*
     * This test case requires PoP to be enabled
     */
    st_enable_pop();

    /*
     * Create a client context
     */
    c_ctx = est_client_init(
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(c_ctx != NULL);
    if (!c_ctx) {
        return;
    }

    /*
     * Specify user ID and password since the server is running
     * in Basic Authentication mode.
     */
    rv = est_client_set_auth(c_ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);
    est_client_set_server(c_ctx, "127.0.0.1", US903_TCP_PORT, NULL);

    /*
     * get a keypair to be used in the enroll.
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(c_ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll a CSR
     */
    rv = est_client_enroll(c_ctx, "US903-test7 CN", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Check HTTP status code received from server is 200
     */
    http_status = est_client_get_last_http_status(c_ctx);
    CU_ASSERT(http_status == 200);

    /*
     * Client library has obtained the new client certificate.
     * Now retrieve it from the library.
     */
    pkcs7 = malloc(pkcs7_len);
    if (!pkcs7) {
        return;
    }
    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Clean up
     */
    est_destroy(c_ctx);
    EVP_PKEY_free(new_pkey);
    free(pkcs7);

    /*
     * Disable PoP for future test cases
     */
    st_disable_pop();
}

/*
 * Simple enroll - Use a non-default ECDHE curve
 *
 * This test case verifies the est_server_set_ecdhe_curve()
 * function is working.
 */
static void us903_test8 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /* Stop the EST server */
    st_stop();

    /* Restart the server using the secp384r1 curve  */
    us903_start_server(0, NID_secp384r1);

    rv = curl_http_post(
        US903_ENROLL_URL_BA,
        US903_PKCS10_CT,
        US903_PKCS10_RSA2048,
        US903_UIDPWD_GOOD,
        US903_CACERTS,
        CURLAUTH_BASIC,
        "ECDHE-ECDSA-AES256-GCM-SHA384",
        NULL,
        NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 valid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes a valid PoP even when
 * the server didn't request it.  We have to use
 * CiscoEST as the client to generate a CSR containing
 * a valid PoP.  There's no way to include a valid PoP
 * using Curl since the TLS channel binding information
 * is not known in advance.
 */
//The following include should never be used by an application
//be we use it here to hack the EST_CTX values mid-way
//through this test
#include "../../src/est/est_locl.h"
static void us903_test9 (void)
{
    EST_CTX *ctx;
    int rv;
    unsigned char *cacerts;
    int caclen = 0;
    EVP_PKEY *new_pkey;
    unsigned char *pkcs7;
    int pkcs7_len = 0;
    unsigned char *attr_data;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    /*
     * Read in the CA certs
     */
    caclen = read_binary_file(US903_CACERTS, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Init the client context
     */
    ctx = est_client_init(
        cacerts,
        caclen,
        EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);

    /*
     * We'll use simple HTTP auth to identify ourselves
     */
    rv = est_client_set_auth(ctx, "estuser", "estpwd", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_client_set_server(ctx, "127.0.0.1", US903_TCP_PORT, NULL);

    /*
     * Create some space to hold the cert and generate
     * a private key
     */
    new_pkey = generate_private_key();

    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Attempt to enroll
     */
    ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
    //We need to force the challengePassword into the CSR    
    rv = est_client_enroll(ctx, "TestCase9", &pkcs7_len, new_pkey);
    CU_ASSERT(rv == EST_ERR_NONE);

    pkcs7 = malloc(pkcs7_len);
    rv = est_client_copy_enrolled_cert(ctx, pkcs7);

    free(pkcs7);
    est_destroy(ctx);
}

/*
 * Simple enroll - PoP is disabled, the CSR contains a
 *                 invalid PoP.
 *
 * This test case ensures the server can handle the
 * scenario where the CSR includes an invalid PoP even when
 * the server didn't request it.
 */
static void us903_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_disable_pop();

    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,
    US903_PKCS10_STALE_POP,
    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * The enroll request should fail since the PoP was invalid
     * We expect a 400 response.
     */
    CU_ASSERT(rv == 400);
}

/*
 * Simple enroll - PoP is enabled, the CSR contains a
 *                 invalid PoP, and the client uses
 *                 a cert that contains id-kp-cmcRA.
 *
 * This test case ensures the server disables the PoP
 * check when the client is using a cert that contains
 * id-kp-cmcRA, which indicates the client is an RA.
 */
static void us903_test11 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure our EST server has PoP disabled
     */
    st_enable_pop();

    rv = curl_http_post_certuid(
    US903_ENROLL_URL_BA,
    US903_PKCS10_CT,
    US903_PKCS10_STALE_POP,
    US903_UIDPWD_GOOD,
    US903_EXPLICIT_CERT,
    US903_EXPLICIT_KEY,
    US903_CACERTS, NULL);

    /*
     * Even though the PoP value doesn't match in this CSR,
     * the enroll will succeed since the client is using
     * an RA certificate. We expect a 200 response.
     */
    CU_ASSERT(rv == 200);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us903_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us903_srv_simpenroll",
            us903_init_suite,
            us903_destory_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "Enroll RSA cert", us903_test1)) ||
        (NULL == CU_add_test(pSuite, "Enroll ECDSA cert", us903_test2)) ||
        (NULL == CU_add_test(pSuite, "Enroll DSA cert", us903_test3)) ||
        (NULL == CU_add_test(pSuite, "Enroll corrupted ECDSA cert", us903_test4)) ||
        (NULL == CU_add_test(pSuite, "Enroll retry-after manual approval ", us903_test5)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP fail with Curl", us903_test6)) ||
        (NULL == CU_add_test(pSuite, "Enroll PoP succeed with estclient", us903_test7)) ||
        (NULL == CU_add_test(pSuite, "Non-default ECDHE curve", us903_test8)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes valid PoP", us903_test9)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP disabled, CSR includes invalid PoP", us903_test10)) ||
        (NULL == CU_add_test(pSuite, "Enroll w/PoP enabled using RA cert, CSR includes invalid PoP", us903_test11)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us4020.c - Unit Test for User Story 4020 - Unit test client
 *            proxy mode.  Test the new API function and
 *            verify correct operation of Client proxy modes.
 *
 * October, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include "est.h"
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include <errno.h>
#include <fcntl.h>

#define MAX_4020_CMDS 1024

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US4020_SERVER_DOMAIN_NAME "localhost.cisco.com"
#define US4020_SERVER_IP        "127.0.0.1"	
#define US4020_SERVER_TCP_PORT	40200

#define US4020_PROXY_IP         "127.0.0.1"	
#define US4020_PROXY_TCP_PORT	40208

#define US4020_UID	    "estuser"
#define US4020_PWD	    "estpwd"

#ifndef WIN32
#define US4020_CACERTS	     "CA/estCA/cacert.crt"
/* #define US4020_CACERT "CA/estCA/cacert.crt" */
/* #define US4020_SERVER_CERT "CA/estCA/private/estservercertandkey.pem" */
/* #define US4020_SERVER_KEY "CA/estCA/private/estservercertandkey.pem" */
/* #define US4020_CLIENT_CERT "CA/estCA/private/estservercertandkey.pem" */
/* #define US4020_CLIENT_KEY  "CA/estCA/private/estservercertandkey.pem" */
#else
#define US4020_CACERTS	     "CA\\estCA\\cacert.crt"
/* #define US4020_CACERT "CA\\estCA\\cacert.crt" */
/* #define US4020_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem" */
/* #define US4020_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem" */
/* #define US4020_CLIENT_CERT "CA\\estCA\\private\\estservercertandkey.pem" */
/* #define US4020_CLIENT_KEY  "CA\\estCA\\private/estservercertandkey.pem" */

static CRITICAL_SECTION logger_critical_section;  
static void us4020_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}
#endif 

static EVP_PKEY *generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}


static void us4020_clean (void)
{
}

int us4020_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US4020_SERVER_TCP_PORT, 
	          "CA/estCA/private/estservercertandkey.pem",
	          "CA/estCA/private/estservercertandkey.pem",
	          "estrealm",
	          "CA/estCA/cacert.crt",
	          "CA/trustedcerts.crt",
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

#define MAX_CMD_BUF 256
#define MAX_PID_BUF 128
static void shutdown_antinat (void)
{
    int fh;
    char read_pid[MAX_PID_BUF];
    char cmd[MAX_CMD_BUF];
    int rv = 0;
    
    fh = open ("./antinat-pid", O_RDWR, 0666);
    
    (void)read(fh, read_pid, MAX_PID_BUF);    
    printf("pid read back in = %s\n", read_pid);

    snprintf(cmd, MAX_CMD_BUF, "kill %s\n", read_pid);
    rv = system(cmd);

    if (rv) {
        printf("Failed to terminate antinat.\n");
    }
}

static void shutdown_haproxy (void)
{
    int fh;
/*     int readbyte_count = 0; */
    char read_pid[MAX_PID_BUF];
    char cmd[MAX_CMD_BUF];
    int rv = 0;

    fh = open ("./haproxy.pid", O_RDWR, 0666);
    
/*     readbyte_count = read(fh, read_pid, MAX_PID_BUF); */
    (void)read(fh, read_pid, MAX_PID_BUF);
    printf("pid read back in = %s\n", read_pid);

    snprintf(cmd, MAX_CMD_BUF, "kill %s\n", read_pid);
    rv = system(cmd);

    if (rv) {
        printf("Failed to terminate haproxy.\n");
    }
}


/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us4020_init_suite (void)
{
    int rv;
#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us4020_logger_stderr);
#else 
    est_init_logger(EST_LOG_LVL_INFO, NULL);
#endif    

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US4020_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us4020_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us4020_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us4020_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}


/*
 * Error check the parameters to the API
 */
static void us4020_test1 (void) 
{
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
     
    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  Attempt to call the API without a context
     */
    e_rc= est_client_set_proxy(NULL, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NO_CTX);

    /*
     * valid call
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * don't set the server 
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               NULL,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * server to empty string
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               "",
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * max server name 
     */
    char * max_server_name = "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345678901234567890123456789012345678901234567890"
                             "123456789012345";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               max_server_name,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * server name too long
     */
    char * long_server_name = "123456789012345678901234567890123456789012345678901234567890"
                              "123456789012345678901234567890123456789012345678901234567890"
                              "123456789012345678901234567890123456789012345678901234567890"
                              "123456789012345678901234567890123456789012345678901234567890"
                              "1234567890123456";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               long_server_name,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * don't set the port
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               0,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PORT_NUM);

    /* proxy protocol invalid */
    e_rc= est_client_set_proxy(ectx, 25,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);

    /* proxy protocol invalid */
    e_rc= est_client_set_proxy(ectx, -2,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);

    /* proxy auth invalid */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               25,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_AUTH);

    /*
     * max userid
     */
    char * max_userid = "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345678901234567890123456789012345678901234567890"
                        "123456789012345";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               max_userid, "estpwd");

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * userid too long
     */
    char * long_userid = "123456789012345678901234567890123456789012345678901234567890"
                         "123456789012345678901234567890123456789012345678901234567890"
                         "123456789012345678901234567890123456789012345678901234567890"
                         "123456789012345678901234567890123456789012345678901234567890"
                         "1234567890123456";

    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               long_userid, "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);

    /*
     * userid is an empty string
     */    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);

    /*
     * max pwd
     */
    char * max_pwd = "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345678901234567890123456789012345678901234567890"
                     "123456789012345";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", max_pwd);

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * pwd too long
     */    
    char * long_pwd = "123456789012345678901234567890123456789012345678901234567890"
                      "123456789012345678901234567890123456789012345678901234567890"
                      "123456789012345678901234567890123456789012345678901234567890"
                      "123456789012345678901234567890123456789012345678901234567890"
                      "1234567890123456";
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", long_pwd);

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);

    /*
     * password is an empty string
     */    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "");

    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);    
    
    est_destroy(ectx);
    
}


/*
 * Test for SOCKS 4 mode, no credentials, should pass
 *
 */
static void us4020_test2 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-2", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 4 mode, with credentials, should pass
 *
 */
static void us4020_test3 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-3", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode
 *
 */
static void us4020_test4 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
/*                                "estuser", "estpwd"); */
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-4", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 4A mode
 *
 */
static void us4020_test5 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
/*                                "estuser", "estpwd"); */
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-5", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with no credentials
 *
 */
static void us4020_test6 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);
    
    shutdown_antinat();
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with good credentials
 *
 */
static void us4020_test7 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg-goodcred.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);
    
    shutdown_antinat();
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with good credentials, but forgotten
 *
 */
static void us4020_test8 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg-goodcred.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);
    
    shutdown_antinat();
    est_destroy(ectx);
}


/*
 * Test for SOCKS 5 mode, with bad credentials
 *
 */
static void us4020_test9 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg-badcred.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-6", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);
    
    shutdown_antinat();
    est_destroy(ectx);
}


#if 0
/*
 * could be tested, but needs certifcates updated
 */
/*
 * Test for SOCKS 4A mode, with domain name 
 *
 */
static void us4020_test8 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a SOCKS 4 proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "antinat -xcUS4020/antinat-cfg.xml");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    /*
     *  socks4
     */
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_DOMAIN_NAME, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-7", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_antinat();    
    est_destroy(ectx);
}
#endif

/*
 * Test HTTP proxy mode
 *
 * NOTE: only non-tunnel mode is tested.  tunnel mode does not
 * work with CiscoEST server.
 */
static void us4020_test10 (void) 
{
    int sys_rc = 0;
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
    char cmd[MAX_4020_CMDS];
    EVP_PKEY *key;
    int pkcs7_len = 0;
     
    LOG_FUNC_NM;

    /*
     * Set up a HTTP proxy server locally
     */
    snprintf(cmd, MAX_4020_CMDS, "haproxy -D -f US4020/haproxy.cfg -p ./haproxy.pid");

    sys_rc = system(cmd);
    CU_ASSERT(sys_rc == 0);    
    
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);
    
    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,
                               US4020_PROXY_IP,
                               US4020_PROXY_TCP_PORT,
                               EST_CLIENT_PROXY_AUTH_BASIC,
                               "estuser", "estpwd");

    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    e_rc = est_client_enroll(ectx, "TC4020-8", &pkcs7_len, key);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    shutdown_haproxy();    
    est_destroy(ectx);
}


/*
 * Indicate whether client proxy support has been built into
 * the library or not
 */
static int client_proxy_enabled (void) 
{
    EST_ERROR e_rc;
    
    e_rc = est_client_set_proxy(NULL, 0, NULL, 0, 0, NULL, NULL);
    if (e_rc == EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED) {
        return 0;
    } else {
        return 1;
    }
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us4020_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us4020_tok_auth_client", 
	                  us4020_init_suite, 
			  us4020_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }
#ifndef WIN32
   /*
    * client proxy mode is only supported when libcurl has been specified.
    */
   if (client_proxy_enabled()){
       
       /* add the tests to the suite */
       if (
           (NULL == CU_add_test(pSuite, "parameter check API", us4020_test1)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 4 mode", us4020_test2)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 4 mode w/ credentials", us4020_test3)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode", us4020_test4)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 4A mode", us4020_test5)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, no credentials", us4020_test6)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, good credentials", us4020_test7)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, forgotten credentials", us4020_test8)) ||
           (NULL == CU_add_test(pSuite, "SOCKS 5 mode, bad credentials", us4020_test9)) ||
/*            (NULL == CU_add_test(pSuite, "SOCKS 4A mode with domain name instead of IP address", us4020_test7)) || */
           (NULL == CU_add_test(pSuite, "HTTP proxy", us4020_test10))
           )
           {
               CU_cleanup_registry();
               return CU_get_error();
           }
   }
#endif   
   return CUE_SUCCESS;
#endif
}

/*------------------------------------------------------------------
 * us896.c - Unit Tests for User Story 896 - Client CSR Attributes
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifndef WIN32
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define US896_CACERTS       "CA/estCA/cacert.crt"
#define US896_TRUST_CERTS   "CA/trustedcerts.crt"
#define US896_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else 
#define CLIENT_UT_CACERT "CA\\estCA\\cacert.crt"
#define US896_CACERTS       "CA\\estCA\\cacert.crt"
#define US896_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US896_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif 

#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"
#define US896_SERVER_PORT   29896
#define US896_SERVER_IP     "127.0.0.1" 
#define TEST_SHORT_ATTR "M==\0"
#define TEST_LONG_ATTR "MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"
#define TEST_CORRUPT_ATTR1 "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOIExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_CORRUPT_ATTR2 "MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFM12345TIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\0"

#define EST_UT_MAX_CMD_LEN 255

static void us896_clean(void) {
}

static int us896_start_server(int manual_enroll, int nid) {
    int rv;

    rv = st_start(US896_SERVER_PORT,
    US896_SERVER_CERTKEY,
    US896_SERVER_CERTKEY, "US896 test realm",
    US896_CACERTS,
    US896_TRUST_CERTS, "CA/estExampleCA.cnf", manual_enroll, 0, nid);

    SLEEP(1);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us896_init_suite(void) {
    int rv = 0;
    char cmd[EST_UT_MAX_CMD_LEN];

    printf("Starting EST Server CSR attributes unit tests.\n");

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
            "openssl ecparam -name prime256v1 -genkey -out %s",
            CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us896_clean();

    /*
     * Start an instance of the EST server 
     */
    rv = us896_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us896_destroy_suite(void) {
    st_stop();
    SLEEP(2);
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error) {
    BIO *bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
            "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
            __FUNCTION__, openssl_cert_error,
            X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Test1 - exercise the est_client_get_csrattrs() API.
 */
static void us896_test1(void) {
    int rc;
    unsigned char *csr_data;
    int csr_len;
    EST_CTX *ctx = NULL;

    LOG_FUNC_NM
    ;

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, NULL, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, NULL);
    CU_ASSERT(rc != EST_ERR_NONE);

}

/*
 * Test2 - exercise the response  variations triggered
 *         by est_client_get_csrattrs()
 */
static void us896_test2(void) {
    EST_CTX *ctx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY *priv_key;

    SLEEP(1);

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
            client_manual_cert_verify);
    CU_ASSERT(ctx != NULL);

    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ctx, US896_SERVER_IP, US896_SERVER_PORT, NULL);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ctx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    /* 
     * All of these are negative tests and require that code in the
     * EST server is modified such that it will allow bad/corrupted
     * attributes to be initialized so they can be sent to the client.
     */
#ifdef NEGATIVE_UNIT_TEST
    unsigned char *csr_data;
    int csr_len;

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR1, strlen(TEST_CORRUPT_ATTR1));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR2, strlen(TEST_CORRUPT_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    rc = est_server_init_csrattrs(ectx, TEST_SHORT_ATTR, strlen(TEST_SHORT_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc != EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

#endif

    if (ctx) {
        est_destroy(ctx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us896_add_suite(void) {
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us896_client_csrattrs",
            us896_init_suite,
            us896_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "CSR Client Attributes API1", us896_test1)) ||
            (NULL == CU_add_test(pSuite, "CSR Client Attributes API2 ", us896_test2)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us898.c - Unit Tests for User Story 898 - Client re-enroll 
 *
 * October, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <est_ossl_util.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US898_SERVER_PORT   29898
#define US898_SERVER_IP	    "127.0.0.1"	
#define US898_UID	    "estuser"
#define US898_PWD	    "estpwd"
#ifndef WIN32
#define US898_CACERTS	    "CA/estCA/cacert.crt"
#define US898_TRUST_CERTS   "CA/trustedcerts.crt"
#define US898_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"

#define US898_TC2_CERT_TXT "US898/tc2-new-cert.txt"
#define US898_TC2_CERT_B64 "US898/tc2-new-cert.pkcs7b64"
#define US898_TC2_CERT_PK7 "US898/tc2-new-cert.pkcs7"
#define US898_TC2_CERT_PEM "US898/tc2-new-cert.pem"

#define US898_TC10_CSR	"US898/tc10_csr.pem"
#define US898_TC10_KEY	"US898/tc10_key.pem"
#define US898_TC10_CERT	"US898/tc10_cert.pem"

#define US898_TC11_KEY	"US898/tc11_key.pem"
#define US898_TC11_CERT	"US898/tc11_cert.pem"
#else
  #define US898_CACERTS	    "CA\\estCA\\cacert.crt"
#define US898_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US898_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"

#define US898_TC2_CERT_TXT "US898\\tc2-new-cert.txt"
#define US898_TC2_CERT_B64 "US898\\tc2-new-cert.pkcs7b64"
#define US898_TC2_CERT_PK7 "US898\\tc2-new-cert.pkcs7"
#define US898_TC2_CERT_PEM "US898\\tc2-new-cert.pem"

#define US898_TC10_CSR	"US898\\tc10_csr.pem"
#define US898_TC10_KEY	"US898\\tc10_key.pem"
#define US898_TC10_CERT	"US898\\tc10_cert.pem"

#define US898_TC11_KEY	"US898\\tc11_key.pem"
#define US898_TC11_CERT	"US898\\tc11_cert.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us898_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}

#endif

static void us898_clean (void)
{
    char cmd[200];

    /*
     * These are all temporary files created 
     * by the various test cases.
     */
#ifndef WIN32
    sprintf(cmd, "rm %s", US898_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC2_CERT_PEM);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC10_CERT);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC10_KEY);
    system(cmd);
    sprintf(cmd, "rm %s", US898_TC10_CSR);
    system(cmd);
#else
    sprintf(cmd, "del %s", US898_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC2_CERT_PEM);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC10_CERT);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC10_KEY);
    system(cmd);
    sprintf(cmd, "del %s", US898_TC10_CSR);
    system(cmd);
#endif 
}

/*
 * This starts an instance of the EST server running on
 * a separate thread.  We use this to test the
 * client side API in this module.
 */
static int us898_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US898_SERVER_PORT, 
	          US898_SERVER_CERTKEY,
	          US898_SERVER_CERTKEY,
	          "estrealm",
	          US898_CACERTS,
	          US898_TRUST_CERTS,
	          "US898/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us898_init_suite (void)
{
    int rv;

#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us898_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US898_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us898_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us898_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us898_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        return (1);
    }    
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
//    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);


    BIO_free(bio_err);
    
    return approve;
}    

/*
 * This function performs a basic simple enroll using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variet of test cases in this module.
 */
static void us898_test1 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) *certs = NULL;
    int i;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TC-US898-1", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);
    if (rv != EST_ERR_NONE) return;

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.  
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out,NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i=OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
	certs = p7->d.sign->cert;
	break;
    case NID_pkcs7_signedAndEnveloped:
	certs = p7->d.signed_and_enveloped->cert;
	break;
    default:
	break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs) return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);


    /* 
     * Wow, that's a lot of work, but we finally have the X509.
     * (don't you just love OpenSSL!!!)
     * Now that we have an X509 representation of the cert,
     * let's try to re-enroll this cert with the CA
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    if (cert) X509_free(cert);
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  The expired certs contains
 * several X509 extensions. We verify the new issued
 * cert preserves these extensions using grep.  Note, 
 * preserving these extensions requires the OpenSSL CA
 * to enable the "copy_extensions" knob in the OpenSSL
 * config file.  This is why this test suite uses a
 * unique copy of estExampleCA.cnf.
 */
static void us898_test2 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    X509 *cert = NULL;
    BIO *in;
    char cmd[200];
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Save the cert to a local file
     */
    rv = write_binary_file(US898_TC2_CERT_B64, new_cert, pkcs7_len);
    CU_ASSERT(rv == 1);

    /*
     * Base 64 decode the cert response
     */
    sprintf(cmd, "openssl base64 -d -in %s -out %s", US898_TC2_CERT_B64, US898_TC2_CERT_PK7);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert the pkcs7 cert to a PEM cert
     */
    sprintf(cmd, "openssl pkcs7 -in %s -inform DER -print_certs -out %s", US898_TC2_CERT_PK7, US898_TC2_CERT_PEM);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert PEM cert to a textual representation of the cert
     */
    sprintf(cmd, "openssl x509 -text -in %s > %s", US898_TC2_CERT_PEM, US898_TC2_CERT_TXT);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Verify the jimbob DNS extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT, "jimbob");
    CU_ASSERT(rv == 0);

    /*
     * Verify the bobcat DNS extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT, "bobcat");
    CU_ASSERT(rv == 0);

    /*
     * Verify the IP address extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT,"172");
    CU_ASSERT(rv == 0);

    /*
     * Verify the Repudiation key usage extension was preserved
     */
    rv = grep(US898_TC2_CERT_TXT,"Repudiation");
    CU_ASSERT(rv == 0);

    /*
     * Verify the public key was preserved
     */
    rv = grep(US898_TC2_CERT_TXT, "00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50");
    CU_ASSERT(rv == 0);

    /*
     * Clean up
     */
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}

/*
 * Test the re-enroll API to ensure it gracefully
 * handles a null X509 cert pointer.
 */
static void us898_test3 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    int rv;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * re-enroll using a null x509 pointer.
     */
    rv = est_client_reenroll(ectx, NULL, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NO_CERT);

    /*
     * Clean up
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 * Test the re-enroll API to ensure it gracefully
 * handles a null EVP_PKEY pointer.
 */
static void us898_test4 (void) 
{
    EST_CTX *ectx;
    int pkcs7_len = 0;
    int rv;
    X509 *cert = NULL;
    unsigned char *cert_raw;
    int cert_len;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in an old cert that we can use for re-enroll
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * re-enroll using a null EVP_KEY pointer.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, NULL);
    CU_ASSERT(rv == EST_ERR_NO_KEY);

    /*
     * Clean up
     */
    X509_free(cert);
    est_destroy(ectx);
}

/*
 * This test attempts to re-enroll a corrupted cert
 * The public key in the cert is has been corrupted.
 */
static void us898_test5 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-corrupt.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-corrupt.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CLIENT_INVALID_KEY);

    /*
     * Clean up
     */
    est_destroy(ectx);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured for manual
 * approval.  The server will send back a retry-after
 * response.
 */
static void us898_test6 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Stop the server.
     */
    st_stop();

    /*
     * Restart the server with manual approval enabled
     */
    rv = us898_start_server(1, 0);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);

    /*
     * Clean up
     */
    est_destroy(ectx);

    /*
     * Stop the server.
     */
    st_stop();

    /*
     * Restart the server with manual approval disabled
     */
    rv = us898_start_server(0, 0);
    CU_ASSERT(rv == 0);
}

/*
 * Verify that a bogus user ID/password fails when
 * using HTTP basic auth.
 */
static void us898_test7 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, "hoagie", "chili", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);

    est_destroy(ectx);
}

/*
 * Verify that a good user ID/password passes when
 * using HTTP digest auth.
 */
static void us898_test8 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Enable HTTP digest authentication
     */
    st_enable_http_digest_auth();

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_destroy(ectx);

    /*
     * Re-enable HTTP basic authentication
     */
    st_enable_http_basic_auth();

}

/*
 * Verify that a bogus user ID/password fails when
 * using HTTP digest auth.
 */
static void us898_test9 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;
    int http_status;

    LOG_FUNC_NM;

    /*
     * Enable HTTP digest authentication
     */
    st_enable_http_digest_auth();

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, "jdoe", "panthers", NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file("US898/key-expired.pem", &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file("US898/cert-expired.pem", &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);

    /*
     * Check the HTTP status code from the reenroll operation
     */
    http_status = est_client_get_last_http_status(ectx);
    CU_ASSERT(http_status == 401);

    est_destroy(ectx);

    /*
     * Re-enable HTTP basic authentication
     */
    st_enable_http_basic_auth();

}

/*
 * Verify the server fails authentication when the
 * client sends a valid identity cert but doesn't 
 * provide HTTP auth credentials.
 */
static void us898_test10 (void) 
{
    char cmd[200];
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a CSR
     */
    sprintf(cmd, "openssl req -new -nodes -out %s -newkey rsa:2048 -keyout %s -subj /CN=127.0.0.1 "
	    "-config CA/estExampleCA.cnf", 
	    US898_TC10_CSR, US898_TC10_KEY);  
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Sign the CSR using our local CA
     */
    sprintf(cmd, "openssl ca -out %s -batch -config CA/estExampleCA.cnf -infiles %s", 
	    US898_TC10_CERT, US898_TC10_CSR);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US898_TC10_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US898_TC10_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);


    /*
     * Set the authentication mode to use the certificate 
     * No HTTP auth credentials are provided.
     */
    rv = est_client_set_auth(ectx, NULL, NULL, cert, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll a cert, should fail because we 
     * didn't provide valid HTTP auth credentials
     */
    rv = est_client_enroll(ectx, "TC-US898-10", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);

    /*
     * Re-Enroll the cert, should work since
     * we provide a valid cert to identify ourselves
     * and HTTP auth isn't required for re-enroll even when
     * the server has enabled HTTP auth.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_destroy(ectx);
}

/*
 * Verify the server fails authentication when the
 * client sends an expired identy cert and uses 
 * valid HTTP auth credentials.
 */
static void us898_test11 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US898_TC11_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US898_TC11_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in) return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert) return; 
    BIO_free_all(in);
    free(cert_raw);


    /*
     * Set the authentication mode to use the expired certificate 
     * and valid HTTP auth credentials.
     */
    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, cert, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    /*
     * Re-Enroll the cert 
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    est_destroy(ectx);
}


int us898_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us898_client_reenroll", 
	                  us898_init_suite, 
			  us898_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* 
    * Add the tests to the suite 
    */
   if ((NULL == CU_add_test(pSuite, "Simple enroll and re-enroll", us898_test1)) ||
       (NULL == CU_add_test(pSuite, "Re-enroll expired cert with extensions", us898_test2)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll using NULL cert", us898_test3)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll using NULL key", us898_test4)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll using corrupted X509 cert", us898_test5)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll retry-after", us898_test6)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll invalid UID/PWD Basic", us898_test7)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll valid UID/PWD Digest", us898_test8)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll invalid UID/PWD Digest", us898_test9)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll valid certificate no HTTP auth", us898_test10)) || 
       (NULL == CU_add_test(pSuite, "Re-enroll expired certificate with HTTP auth", us898_test11))) 
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us1864.c - Unit Tests for User Story 1864 - Enable Token Auth mode in server
 *
 * March, 2015
 *
 * Copyright (c) 2015, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include <errno.h>

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US1864_TCP_PORT     29001

/*
 * The following CSR was generated using the following openssl command and theng
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US1864_PKCS10_RSA2048   "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"
#define US1864_PKCS10_4096_REQ  "MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\n"

#define US1864_ENROLL_URL_BA    "https://127.0.0.1:29001/.well-known/est/simpleenroll"
#define US1864_PKCS10_CT        "Content-Type: application/pkcs10"
#define US1864_UIDPWD_GOOD      "estuser:estpwd"
#ifndef WIN32
#define US1864_CACERTS          "CA/estCA/cacert.crt"
#define US1864_CACERT           "CA/estCA/cacert.crt"
#define US1864_TRUSTED_CERT     "CA/trustedcerts.crt"
#define US1864_SERVER_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US1864_SERVER_KEY       "CA/estCA/private/estservercertandkey.pem"
#define US1864_CLIENT_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US1864_CLIENT_KEY       "CA/estCA/private/estservercertandkey.pem"
#else
#define US1864_CACERTS          "CA\\estCA\\cacert.crt"
#define US1864_CACERT           "CA\\estCA\\cacert.crt"
#define US1864_TRUSTED_CERT     "CA\\trustedcerts.crt"
#define US1864_SERVER_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US1864_SERVER_KEY       "CA\\estCA\\private\\estservercertandkey.pem"
#define US1864_CLIENT_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US1864_CLIENT_KEY       "CA\\estCA\\private\\estservercertandkey.pem"
#endif

/*
 * curl_data_cb is passed to Curl and will be called from Curl whenever data
 * has been received, or if this function has been specified to retrieve the
 * http headers.  In this test it's used to retrieve the http headers and
 * look for the "bearer" token Authorization challenge.
 */
static int bearer_found = 0;
static size_t curl_data_cb (void *ptr, size_t size, size_t nmemb,
                            void *userdata)
{
    void * rc;

    if (bearer_found == 0) {

        /*
         * WARNING: strstr can be dangerous because it assumes null terminated
         * strings.  In this case the http headers came from EST server and we
         * know they are null terminated
         */
        rc = strstr(ptr, "WWW-Authenticate: Bearer");
        if (rc) {
            bearer_found = 1;
        }
    }

    return size * nmemb;
}

static void us1864_clean (void)
{
}

static int us1864_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US1864_TCP_PORT,
                  US1864_SERVER_CERT,
                  US1864_SERVER_KEY,
                  "US1864 test realm",
                  US1864_CACERTS,
                  US1864_TRUSTED_CERT,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1864_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1864_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us1864_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1864_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1864_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}

/*
 * est_server_set_auth_mode() - unit test
 *
 * First, Test the parameters of est_server_set_auth_mode()
 */
static void us1864_test1 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;
    EST_ERROR est_rv;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1864_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US1864_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US1864_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * init EST in server mode
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
        EST_CERT_FORMAT_PEM, "testrealm", x, priv_key);

    CU_ASSERT(ctx != NULL);

    est_rv = est_server_set_auth_mode(ctx, AUTH_NONE);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);
    est_rv = est_server_set_auth_mode(ctx, AUTH_BASIC);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_server_set_auth_mode(ctx, AUTH_TOKEN);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_server_set_auth_mode(ctx, 0xffffffff);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);

    /*
     * Make sure we don't allow DIGEST mode when in FIPS mode
     */
    FIPS_mode_set(1);
    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);
    FIPS_mode_set(0);

    X509_free(x);
    EVP_PKEY_free(priv_key);

    est_destroy(ctx);
}

/*
 * Simple enroll - Token Auth Mode
 *
 * The goal of this test is to verify that the EST server responds with the
 * correct auth challenge when it's configured for Token Auth mode.  It will
 * first perform a sanity check by performing an HTTP Basic request while the
 * server is still in its default mode of HTTP Basic auth.  The test will then
 * configure the server for Token Auth mode and issue a request that does not
 * contain any auth header.  This should force the server to respond with a
 * token auth challenge header.
 */
static void us1864_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US1864_ENROLL_URL_BA, US1864_PKCS10_CT,
    US1864_PKCS10_RSA2048,
    US1864_UIDPWD_GOOD, US1864_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we specify BASIC and the server is still in BASIC
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    /*
     * Switch the server over to Token mode.
     *
     * NOTE: I see this being done in numerous places, and it's probably safe
     * in a test setting, but it is dangerous to change this on the fly in an
     * operational setting.  Also note, no return code for any of these
     * set/enable functions.
     */
    st_enable_http_token_auth();

    bearer_found = 0;

    rv = curl_http_post_cert_write(US1864_ENROLL_URL_BA,
    US1864_PKCS10_CT,
    US1864_PKCS10_RSA2048,
    US1864_CLIENT_CERT,
    US1864_CLIENT_KEY,
    US1864_CACERTS, curl_data_cb, curl_data_cb);

    /*
     * Since we changed auth modes on the server we expect this to now
     * fail.  We're not capturing the actual auth challenge we
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 401);
    CU_ASSERT(bearer_found == 1);

}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us1864_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1864_cfg_tok_auth",
            us1864_init_suite,
            us1864_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "Check parms", us1864_test1)) ||
        (NULL == CU_add_test(pSuite, "Attempt enroll - BASIC pass", us1864_test2))
        )
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
 #endif
 }


/*------------------------------------------------------------------
 * us2174.c - Unit Tests for User Story 2174 - Proxy simple enroll
 *
 * August, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US2174_RETRY_INTERVAL   3600
//#define US2174_TCP_PORT       29001

#define US2174_TCP_SERVER_PORT      52174
#define US2174_TCP_PROXY_PORT       62174

#ifndef WIN32
#define US2174_SERVER_CERT      "CA/estCA/private/estservercertandkey.pem"
#define US2174_SERVER_KEY       "CA/estCA/private/estservercertandkey.pem"
/* #define US2174_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US2174_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US2174_PROXY_CERT       "US2174/cert.pem"
#define US2174_PROXY_KEY        "US2174/key.pem"
#define US2174_CACERT           "CA/estCA/cacert.crt"
#define US2174_CACERTS          "CA/estCA/cacert.crt"
#define US2174_TRUSTED_CERTS    "CA/trustedcerts.crt"
#define US2174_EXPLICIT_CERT    "US2174/cert-RA.pem"
#define US2174_EXPLICIT_KEY     "US2174/key-RA.pem"

#else
#define US2174_SERVER_CERT      "CA\\estCA\\private\\estservercertandkey.pem"
#define US2174_SERVER_KEY       "CA\\estCA\\private/estservercertandkey.pem"
/* #define US2174_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"   */
/* #define US2174_PROXY_KEY "CA/estCA/private/estservercertandkey.pem" */
#define US2174_PROXY_CERT       "US2174\\cert.pem"
#define US2174_PROXY_KEY        "US2174\\key.pem"
#define US2174_CACERT           "CA\\estCA\\cacert.crt"
#define US2174_CACERTS          "CA\\estCA\\cacert.crt"
#define US2174_TRUSTED_CERTS    "CA\\trustedcerts.crt"
#define US2174_EXPLICIT_CERT    "US2174\\cert-RA.pem"
#define US2174_EXPLICIT_KEY     "US2174\\key-RA.pem"
#endif

#define US2174_SERVER_IP        "127.0.0.1"
#define US2174_TCP_PORT         US2174_TCP_SERVER_PORT

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US2174_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the ec.req file:
 *
 * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM
 */
#define US2174_PKCS10_DSA1024 "MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\nzn9HujlXNaTA1OhjmPmcJSxT"

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the dsa.req file:
 *
 * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM
 */
#define US2174_PKCS10_ECDSA256 "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

#define US2174_PKCS10_CORRUPT "MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\nX0Ifde9yzkROVBCEPvK0hcU5KsTO"

/*
 * The following is a valid CSR that already contains a PoP
 * challengePassword.  This was collected using estserver with
 * the dumpbin() function.  This CSR should never work since
 * the PoP value in it will be stale.
 */
#define US2174_PKCS10_STALE_POP "MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40="

#define US2174_ENROLL_URL_BA    "https://127.0.0.1:62175/.well-known/est/simpleenroll"
#define US2174_PKCS10_CT        "Content-Type: application/pkcs10" 
#define US2174_UIDPWD_GOOD      "estuser:estpwd"

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

#define GOOD_TOKEN "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U="
#define DIFFERENT_TOKEN "V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy"
#define NULL_TOKEN NULL;
#define LONG_TOKEN "SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U="
static char *test_token = "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=";

static int auth_cred_callback_called = 0;
static int auth_cred_force_error = 0;

/*
 * auth_credentials_token_cb() is the application layer callback function that will
 * return a token based authentication credential when called.  It's registered
 * with the EST Client using the est_client_set_auth_cred_cb().
 * The test function is required to set some global values in order to make this
 * callback operate the way that the test case wants.
 * - auth_cred_force_error = tell this function to force a response code error
 * - test_token = pointer to a hard coded string that is the token string to return
 *
 * This callback must provide the token credentials in a heap based buffer, and
 * ownership of that buffer is implicitly transferred to the ET client library upon
 * return.
 */
static EST_HTTP_AUTH_CRED_RC auth_credentials_token_cb (
        EST_HTTP_AUTH_HDR *auth_credentials)
{
    char *token_ptr = NULL;
    int token_len = 0;

    CU_ASSERT(auth_credentials->mode == AUTH_TOKEN);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }

    if (auth_credentials->mode == AUTH_TOKEN) {
        /*
         * If the test_token is set to anything, then we need to allocate
         * space from the heap and copy in the value.
         */
        if (test_token != NULL) {
            token_len = strlen(test_token); /* use strlen() so that the string can be as large
             as needed to test the EST client */
            if (token_len == 0) {
                printf(
                    "\nError determining length of token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }
            token_ptr = malloc(token_len + 1);
            if (token_ptr == NULL) {
                printf(
                    "\nError allocating token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }
            strncpy(token_ptr, test_token, strlen(test_token));
            token_ptr[token_len] = '\0';
        }
        /*
         * If we made it this far, token_ptr is pointing to a string
         * containing the token to be returned. Assign it and return success
         */
        auth_credentials->auth_token = token_ptr;

        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }

    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}

/*
 * auth_credentials_basic_cb() is the same as the token based one above, but
 * instead returns the basic credentials of userid and password
 */
static EST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb (
        EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_BASIC);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }

    if (auth_credentials->mode == AUTH_BASIC) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));

        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }

    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}

#if 0
/*
 * auth_credentials_digest_cb() is the same as the basic based one above, but
 * instead verfies that the auth_mode passed is digest
 */
static
EST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_DIGEST);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }

    if (auth_credentials->mode == AUTH_DIGEST) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));

        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }

    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}
#endif

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__, openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * us2174_simple_enroll() is used by test cases to perform a simple enroll.
 */
static void us2174_simple_enroll (char *cn, char *server,
                                  EST_ERROR expected_enroll_rv,
                                  auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    EST_ERROR e_rc;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

static
void us2174_simple_reenroll (char *cn, char *server,
                             EST_ERROR expected_enroll_rv,
                             auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;

    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) * certs = NULL;
    int i;

    EST_ERROR e_rc;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    est_destroy(ectx);
    ectx = NULL;
    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Now that we have the cert, switch the server over to token mode
     */
    st_enable_http_token_auth();

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US2174_TCP_PORT, NULL);

    /*
     * And attempt a reenroll while in token mode
     *
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.
     * PDB: This conversion code comes from other test cases.
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out, NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i = OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
        certs = p7->d.sign->cert;
        break;
    case NID_pkcs7_signedAndEnveloped:
        certs = p7->d.signed_and_enveloped->cert;
        break;
    default:
        break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs)
        return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);

    /*
     * PDB NOTE: At the moment, this is expected to fail since
     * the server does not yet understand requests with token authentication.
     * Once 1884 is complete, the below ASSERT will begin to fail and will need
     * to be changed to a passing response.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

static void us2174_clean (void)
{
}

static int us2174_start_server (int manual_enroll, int nid)
{
    int rv = 0;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US2174_TCP_SERVER_PORT,
                  US2174_SERVER_CERT,
                  US2174_SERVER_KEY,
                  "estrealm",
                  US2174_CACERT,
                  US2174_TRUSTED_CERTS,
                  "US2174/estExampleCA.cnf",
                  manual_enroll, // manual enroll
                  0,  // disable PoP
                  nid); // ecdhe nid info
    SLEEP(1);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy acting as an RA with the server side
     * operating in token auth mode.
     */
    rv = st_proxy_start_token(US2174_TCP_PROXY_PORT,
                              US2174_PROXY_CERT,
                              US2174_PROXY_KEY, "estrealm",
                              US2174_CACERT,
                              US2174_TRUSTED_CERTS,
                              "estuser",
                              "estpwd",
                              "127.0.0.1",
                              US2174_TCP_SERVER_PORT,
                              0); //  disable PoP

    SLEEP(1);

    return rv;
}

void us2174_stop_server ()
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us2174_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US2174_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us2174_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us2174_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us2174_destroy_suite (void)
{
    us2174_stop_server();
    free(cacerts);
    return 0;
}

#if 0
/*
 * Simple enroll -
 * proxy - BASIC
 * server - BASIC
 *
 * Make sure token auth mode did not break anything.
 *
 */
static void us2174_test1(void)
{
    long rv;

    LOG_FUNC_NM;

    rv = curl_http_post(US2174_ENROLL_URL_BA, US2174_PKCS10_CT,
            US2174_PKCS10_RSA2048,
            US2174_UIDPWD_GOOD, US2174_CACERTS, CURLAUTH_BASIC,
            NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}
#endif

/*
 * Simple enroll -
 * proxy - TOKEN
 * server - TOKEN
 *
 */
static void us2174_test2 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do token auth challenges
     * tell the server which tokens to accept
     */
    st_enable_http_token_auth();
    st_set_token(GOOD_TOKEN);
    /*
     * set the proxy to do token auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_token_auth();
    st_proxy_set_srv_valid_token(GOOD_TOKEN);
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us2174_simple_enroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/*
 * Simple enroll -
 * proxy - TOKEN
 * server - BASIC
 */
static void us2174_test3 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do BASIC auth challenges
     */
    st_enable_http_basic_auth();
    /*
     * set the proxy to do token auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_token_auth();
    st_proxy_set_srv_valid_token(GOOD_TOKEN);
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us2174_simple_enroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/*
 * Simple enroll -
 * proxy - BASIC
 * server - TOKEN
 */
static void us2174_test4 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do token auth challenges
     * tell the server which tokens to accept
     */
    st_enable_http_token_auth();
    st_set_token(GOOD_TOKEN);
    /*
     * set the proxy to do BASIC auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_basic_auth();
    /*     st_proxy_set_srv_valid_token(GOOD_TOKEN); */
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us2174_simple_enroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_basic_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/*
 * Simple RE-enroll -
 * proxy - TOKEN
 * server - TOKEN
 *
 */
static void us2174_test5 (void)
{
    LOG_FUNC_NM
    ;

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;

    /*
     * set server to do token auth challenges
     * tell the server which tokens to accept
     */
    st_enable_http_token_auth();
    st_set_token(GOOD_TOKEN);
    /*
     * set the proxy to do token auth challenges and
     * tell it what tokens to accept.
     */
    st_proxy_enable_http_token_auth();
    st_proxy_set_srv_valid_token(GOOD_TOKEN);
    /*
     * tell the client side of proxy which token credential to
     * use
     */
    st_proxy_set_clnt_token_cred(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple RE-enroll.
     *
     * RE-enroll should succeed.
     */
    us2174_simple_reenroll("TC2174-4", US2174_SERVER_IP, EST_ERR_NONE,
        auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us2174_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us2174_token_proxy",
            us2174_init_suite,
            us2174_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if (/* (NULL == CU_add_test(pSuite, "Proxy Enroll basic sanity test", us2174_test1)) || */
        (NULL == CU_add_test(pSuite, "Proxy Enroll token auth, both proxy and server", us2174_test2)) ||
        (NULL == CU_add_test(pSuite, "Proxy Enroll token auth, proxy token/server basic", us2174_test3)) ||
        (NULL == CU_add_test(pSuite, "Proxy Enroll token auth, proxy basic/server token", us2174_test4)) ||
        (NULL == CU_add_test(pSuite, "Proxy RE-Enroll token auth, proxy basic/server token", us2174_test5))
        )
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us1883.c - Unit Tests for User Story 1883 - Enable token auth mode for
 *            the EST Client.
 *
 * March, 2015
 *
 * Copyright (c) 2015, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include <errno.h>


static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US1883_SERVER_IP        "127.0.0.1"	
#define US1883_TCP_PORT		29001

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US1883_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"
#define US1883_PKCS10_4096_REQ "MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\n"
#define US1883_ENROLL_URL_BA "https://127.0.0.1:29001/.well-known/est/simpleenroll"
#define US1883_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US1883_UIDPWD_GOOD   "estuser:estpwd"
#ifndef WIN32
#define US1883_CACERTS	     "CA/estCA/cacert.crt"
#define US1883_CACERT "CA/estCA/cacert.crt"
#define US1883_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US1883_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
#define US1883_CLIENT_CERT "CA/estCA/private/estservercertandkey.pem"
#define US1883_CLIENT_KEY  "CA/estCA/private/estservercertandkey.pem"
#else
#define US1883_CACERTS	     "CA\\estCA\\cacert.crt"
#define US1883_CACERT "CA\\estCA\\cacert.crt"
#define US1883_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US1883_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US1883_CLIENT_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US1883_CLIENT_KEY  "CA\\estCA\\private/estservercertandkey.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us1883_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}

#endif 


static void us1883_clean (void)
{
}

static int us1883_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US1883_TCP_PORT, 
	          "CA/estCA/private/estservercertandkey.pem",
	          "CA/estCA/private/estservercertandkey.pem",
	          "estrealm",
	          "CA/estCA/cacert.crt",
	          "CA/trustedcerts.crt",
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1883_init_suite (void)
{
    int rv;
#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us1883_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1883_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us1883_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us1883_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1883_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}


static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}

#define GOOD_TOKEN "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U="
#define DIFFERENT_TOKEN "V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy"
#define NULL_TOKEN NULL;
#define LONG_TOKEN "SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U="
char *test_token = "WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=";

int auth_cred_callback_called = 0;
int auth_cred_force_error = 0;

/*
 * auth_credentials_token_cb() is the application layer callback function that will
 * return a token based authentication credential when called.  It's registered
 * with the EST Client using the est_client_set_auth_cred_cb().
 * The test function is required to set some global values in order to make this
 * callback operate the way that the test case wants.
 * - auth_cred_force_error = tell this function to force a response code error
 * - test_token = pointer to a hard coded string that is the token string to return
 *
 * This callback must provide the token credentials in a heap based buffer, and
 * ownership of that buffer is implicitly transferred to the ET client library upon
 * return.
 */
EST_HTTP_AUTH_CRED_RC auth_credentials_token_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    char *token_ptr = NULL;
    int token_len = 0;

    CU_ASSERT(auth_credentials->mode == AUTH_TOKEN);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }
    
    if (auth_credentials->mode == AUTH_TOKEN) {
        /*
         * If the test_token is set to anything, then we need to allocate
         * space from the heap and copy in the value.
         */
        if (test_token != NULL) {
            token_len = strlen(test_token); /* use strlen() so that the string can be as large
                                               as needed to test the EST client */
            if (token_len == 0) {
                printf("\nError determining length of token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }   
            token_ptr = malloc(token_len+1);
            if (token_ptr == NULL){
                printf("\nError allocating token string used for credentials\n");
                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;
            }   
            strncpy(token_ptr, test_token, strlen(test_token));
            token_ptr[token_len] = '\0';
        }
        /*
         * If we made it this far, token_ptr is pointing to a string
         * containing the token to be returned. Assign it and return success
         */
        auth_credentials->auth_token = token_ptr;
        
        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }
    
    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}

/*
 * auth_credentials_basic_cb() is the same as the token based one above, but
 * instead returns the basic credentials of userid and password
 */
EST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_BASIC);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }
    
    if (auth_credentials->mode == AUTH_BASIC) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));
        
        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }
    
    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}


/*
 * auth_credentials_digest_cb() is the same as the basic based one above, but
 * instead verfies that the auth_mode passed is digest
 */
EST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)
{
    CU_ASSERT(auth_credentials->mode == AUTH_DIGEST);

    /*
     * report that the callback has been called.
     */
    auth_cred_callback_called = 1;

    /*
     * See if the test is requesting to force an error response code from the
     * callback
     */
    if (auth_cred_force_error) {
        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
    }
    
    if (auth_credentials->mode == AUTH_DIGEST) {

        auth_credentials->user = malloc(sizeof("estuser"));
        strncpy(auth_credentials->user, "estuser", sizeof("estuser"));
        auth_credentials->pwd = malloc(sizeof("estpwd"));
        strncpy(auth_credentials->pwd, "estpwd", sizeof("estpwd"));
        
        return (EST_HTTP_AUTH_CRED_SUCCESS);
    }
    
    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);
}


/*
 * Test the est_client_set_auth_cred_cb API
 *
 * Exercise the parameters
 */
static void us1883_test1 (void) 
{
    EST_ERROR e_rc;
    EST_CTX *ectx = NULL;
     
    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /* Forgot to specify any parameters. Context will
     * get caught
     */
    e_rc = est_client_set_auth_cred_cb(NULL, NULL);
    CU_ASSERT(e_rc == EST_ERR_NO_CTX);

    /*
     * valid call
     */
    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_token_cb);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * attempt to reset the callback function
     */
    e_rc = est_client_set_auth_cred_cb(ectx, NULL);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    est_destroy(ectx);
}

/*
 * us1883_simple_enroll() is used by test cases to perform a simple enroll.
 */
static void us1883_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    EST_ERROR e_rc; 

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);
    
    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Perform a simple enroll first in order to get a valid cert, then perform the
 * reenroll.  The simple enroll needs to be successful, so it's currently
 * being done using basic mode because the EST server does not yet have token
 * based support.
 * PDB NOTE:  Once the server side token support have been implemented, this
 * this function can optionally be updated to do token mode on the first enroll,
 * but it's not absolutely necessary since the purpose of this is to test reenroll
 * and the initial enroll is needed just to get the cert.
 */
static
void us1883_simple_reenroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    EST_ERROR rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;

    PKCS7 *p7 = NULL;
    BIO *b64, *out;
    X509 *cert = NULL;
    STACK_OF(X509) *certs = NULL;
    int i;
    
    EST_ERROR e_rc;    

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Make sure the server is currently in  BASIC auth mode
     */
    st_enable_http_basic_auth();
    
    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_basic_cb);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    est_destroy(ectx);
    ectx = NULL;
    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);    
    
    /*
     * Now that we have the cert, switch the server over to token mode
     */
    st_enable_http_token_auth();
    
    e_rc = est_client_set_auth_cred_cb(ectx, callback);
    CU_ASSERT(e_rc == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);
    
    /*
     * And attempt a reenroll while in token mode
     *
     * Convert the cert to an X509.  Be warned this is
     * pure hackery.
     * PDB: This conversion code comes from other test cases.
     */
    b64 = BIO_new(BIO_f_base64());
    out = BIO_new_mem_buf(new_cert, pkcs7_len);
    out = BIO_push(b64, out);
    p7 = d2i_PKCS7_bio(out,NULL);
    CU_ASSERT(p7 != NULL);
    BIO_free_all(out);
    i=OBJ_obj2nid(p7->type);
    switch (i) {
    case NID_pkcs7_signed:
	certs = p7->d.sign->cert;
	break;
    case NID_pkcs7_signedAndEnveloped:
	certs = p7->d.signed_and_enveloped->cert;
	break;
    default:
	break;
    }
    CU_ASSERT(certs != NULL);
    if (!certs) return;
    /* our new cert should be the one and only
     * cert in the pkcs7 blob.  We shouldn't have to
     * iterate through the full list to find it. */
    cert = sk_X509_value(certs, 0);
    CU_ASSERT(cert != NULL);

    /*
     * PDB NOTE: At the moment, this is expected to fail since
     * the server does not yet understand requests with token authentication.
     * Once 1884 is complete, the below ASSERT will begin to fail and will need
     * to be changed to a passing response.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);
    
    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Test2 - Application layer did not register callback, causing an
 *         HTTP Aithentication header with an empty token credential
 *         
 * In this test,
 * - application layer DOES NOT register its callback
 * - EST Client gets the challenge, finds no callback registered and goes with
 *   the credentials it has stored in the Context, which is nothing.
 *   NOTE: This is the way the preloaded credential flow has always worked.
 * - enroll is sent with no token credentials
 * - server fails and does not give a certificate
 */
static void us1883_test2 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass no callback function to catch and handle the request for a token auth.
     *
     * enroll better fail due to missing credentials
     */
    us1883_simple_enroll("TC1883-2", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, NULL);

    /*
     * callback was never registered, so it should not have been invoked.
     */
    CU_ASSERT(auth_cred_callback_called == 0);
}


/*
 * Test3 - Application layer registers callback, BUT does not set any
 *         credentials when invoked.  Same result as previous test
 *         
 * In this test,
 * - application layer registers its callback
 * - EST Client gets the challenge, calls the callback, gets back an 
 *   empty credential structure and ends up sending an HTTP auth header
 *   with no credentials.
 *   NOTE: This is the way the preloaded credential flow has always worked.
 * - enroll is sent with no token credentials
 * - server fails and does not give a certificate
 */
static void us1883_test3 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = NULL_TOKEN;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Register the token based callback, but set it so that it passes back no token.
     *
     * enroll better fail due to missing credentials
     */
    us1883_simple_enroll("TC1883-3", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test4 - Good token is sent to server and is accepted.  Cert should
 * be generated and returned
 *
 * In this test,
 * - application layer registers its callback and responds with a valid token
 * - enroll is sent with this token credential
 * - server is set to match on this token and send back a cert
 */
static void us1883_test4 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = GOOD_TOKEN;

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should succeed.
     */
    us1883_simple_enroll("TC1883-4", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test EST client receiving a token auth challenge
 *
 * In this test, the application layer registers its callback and responds
 * with a failing return code.
 */
static void us1883_test5 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();

    auth_cred_callback_called = 0;
    /* Force the callback to give a failing return code */
    auth_cred_force_error = 1;
    test_token = GOOD_TOKEN;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * enroll better fail due to credentials not being supplied by the application layer
     * and eventual failure at the server due to missing credentials.
     */
    us1883_simple_enroll("TC1883-5", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test6 - Sanity test BASIC auth mode
 *
 * In this test,
 * - server into BASIC mode
 * - Client application registers its BASIC based callback
 * - Client should send the estuser/estpwd credentials and get a cert
 */
static void us1883_test6 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to BASIC mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_basic_auth();

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass a callback function to catch and handle the request for a token auth.
     *
     * enroll should pass because BASIC mode fully works.  Make sure that the
     * callback is called.  This will ensure that the credentials came from
     * the callback.
     */
    us1883_simple_enroll("TC1883-6", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_basic_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test7 - Make sure re-enroll works with the credential callback flow
 *         to obtain credentials
 *
 * In this test,
 * - server into TOKEN mode
 * - Client application registers its TOKEN based callback
 * - Client should send the valid token credential and get a cert
 */
static void us1883_test7 (void) 
{

    LOG_FUNC_NM;
    
    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = GOOD_TOKEN;

    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Re-enroll should succeed.
     *
     */
    us1883_simple_reenroll("TC1883-7", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test7 - Token credentials that are too long
 *
 * In this test,
 * - server into TOKEN mode and told to match against the GOOD token
 * - Client application registers its TOKEN based callback and is told to
 *   give back a token that is TOO LONG.
 * - Client should send a corrupted token that does not match the GOOD token.
 */
static void us1883_test8 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(GOOD_TOKEN);

    auth_cred_callback_called = 0;
    /* Force the callback to give a failing return code */
    auth_cred_force_error = 0;
    test_token = LONG_TOKEN;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass a callback function to catch and handle the request for a token auth.
     *
     */
    us1883_simple_enroll("TC1883-8", US1883_SERVER_IP, EST_ERR_AUTH_FAIL,
                         auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test7 - Test DIGEST mode with on demand credential flow
 *
 * In this test,
 * - server into DIGEST mode
 *   NOTE: This means the server is expecting: "estuser"/"estpwd" and "estrealm"
 *         These values are hardcoded into data in the st_server, so st_server
 *         must be started with estrealm so that it returns this realm to client
 *         so that the client returns it in its request.
 * - Client application registers its DIGEST based callback
 * - Client should send a valid DIGEST and get a cert
 */
static void us1883_test9 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to DIGEST mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_digest_auth();

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    
    /*
     * Set up the EST Client and have it perform a simple enroll.
     * Pass a callback function to catch and handle the request for a token auth.
     *
     * enroll should pass because DIGEST mode fully works.  Make sure that the
     * callback is called.  This will ensure that the credentials came from
     * the callback.
     */
    us1883_simple_enroll("TC1883-6", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_digest_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/*
 * Test4 - Valid token is provided by appliaction callback, but it's the WRONG
 *         token
 *
 * In this test,
 * - application layer registers its callback and responds with a valid token
 * - Server is set up for token mode, but with a different token.
 * - enroll is sent with this token credential
 * - server is set to match on this token and send back a cert
 */
static void us1883_test10 (void) 
{

    LOG_FUNC_NM;

    /*
     * Switch the server over to Token mode.
     * 
     * NOTE: I see the equivalent calls being made in numerous places, and
     * it's probably safe in a test setting, but it's dangerous to change
     * this on the fly in an operational setting.  Also note, no return code
     * for any of these set/enable functions.
     */
    st_enable_http_token_auth();
    /*
     * tell the server which token to check against.
     */
    st_set_token(DIFFERENT_TOKEN);

    auth_cred_callback_called = 0;
    auth_cred_force_error = 0;
    test_token = GOOD_TOKEN;

    /*
     * Set up the EST Client and have it perform a simple enroll.
     *
     * Enroll should FAIL because the tokens will not match
     */
    us1883_simple_enroll("TC1883-4", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);

    /*
     * callback should have been called
     */
    CU_ASSERT(auth_cred_callback_called == 1);
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us1883_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us1883_tok_auth_client", 
	                  us1883_init_suite, 
			  us1883_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* add the tests to the suite */
   if ((NULL == CU_add_test(pSuite, "parse response", us1883_test1)) ||
       (NULL == CU_add_test(pSuite, "simple enroll no cb", us1883_test2)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb no token", us1883_test3)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb good token", us1883_test4)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb bad rc", us1883_test5)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb basic mode", us1883_test6)) ||
       (NULL == CU_add_test(pSuite, "simple re-enroll reg cb good token", us1883_test7)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb token too long", us1883_test8)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb digest mode", us1883_test9)) ||
       (NULL == CU_add_test(pSuite, "simple enroll reg cb mismatched valid token", us1883_test10))
       )
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us900.c - Unit Tests for User Story 900 - Server CSR Attributes
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US900_SERVER_PORT   29900
#define US900_SERVER_IP     "127.0.0.1" 

#ifndef WIN32
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"
#define US900_CACERTS       "CA/estCA/cacert.crt"
#define US900_TRUST_CERTS   "CA/trustedcerts.crt"
#define US900_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else
#define CLIENT_UT_CACERT "CA\\estCA\\cacert.crt"
#define CLIENT_UT_PUBKEY "est_client_ut_keypair"
#define US900_CACERTS       "CA\\estCA/cacert.crt"
#define US900_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US900_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#endif

#define TEST_ATTR_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR_NOPOP "MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\0"
#define TEST_ATTR_NOPOPPOP "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR_POPADDED "MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\0"
#define TEST_ATTR1 "MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\0"
#define TEST_ATTR2 "MAA=\0"
#define TEST_ATTR7 "MA==\0"
#define TEST_ATTR2_POP "MAsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR8 "MAthisis badsGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR3 "MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\0"
#define TEST_ATTR4_122 "MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR4_122POP "MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\0"
#define TEST_ATTR5_117 "MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR5_117POP "MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ATTR6_116 "MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\0"
#define TEST_ATTR_244 "MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_245 "MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"
#define TEST_ATTR_250 "MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_ATTR_250POP "MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\0"
#define TEST_ALL_ATTR "MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\0"
#define TEST_1024_NOPOP "MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\0"

#define TEST_1025_NOPOP "MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\0"
#define TEST_1024_POP "MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\0"

#define TEST_LONG_ATTR "MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\0"

#define EST_UT_MAX_CMD_LEN 255
extern EST_CTX *ectx;

static void us900_clean (void)
{
}

static int us900_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US900_SERVER_PORT,
                  US900_SERVER_CERTKEY,
                  US900_SERVER_CERTKEY,
                  "US900 test realm",
                  US900_CACERTS,
                  US900_TRUST_CERTS,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);

    SLEEP(1);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us900_init_suite (void)
{
    int rv = 0;
    char cmd[EST_UT_MAX_CMD_LEN];

    printf("Starting EST Server CSR attributes unit tests.\n");

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(
        cmd,
        EST_UT_MAX_CMD_LEN,
        "openssl ecparam -name prime256v1 -genkey -out %s",
        CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);

    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us900_clean();

    /*
     * Start an instance of the EST server
     */
    rv = us900_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us900_destroy_suite (void)
{
    st_stop();
    SLEEP(2);
    return 0;
}

static unsigned char * handle_correct_csrattrs_request (int *csr_len,
                                                        char *path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR1);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_corrupt_csrattrs_request (int *csr_len,
                                                        char *path_seg,
                                                        void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR8);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_short_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR7);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_long_csrattrs_request (int *csr_len,
                                                     char *path_seg,
                                                     void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_LONG_ATTR);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_nopop_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = strlen(TEST_ATTR_NOPOP);
    csr_data = malloc(*csr_len + 1);
    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);
    csr_data[*csr_len] = 0;
    return (csr_data);
}

static unsigned char * handle_empty_csrattrs_request (int *csr_len,
                                                      char *path_seg,
                                                      void *app_data)
{
    unsigned char *csr_data;

    *csr_len = 0;
    csr_data = NULL;
    return (csr_data);
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO * bio_err;
    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
    int approve = 0;

    /*
     * Print out the specifics of this cert
     */
    printf(
        "%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
        __FUNCTION__,
        openssl_cert_error,
        X509_verify_cert_error_string(openssl_cert_error));

    printf("Failing Cert:\n");
    X509_print_fp(stdout, cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }

    BIO_free(bio_err);

    return approve;
}

/*
 * Test1 - exercise the est_server_init_csrattrs() API.
 */
static void us900_test1 (void)
{
    int rc;

    LOG_FUNC_NM
    ;

    /* NULL ctx - should fail */
    rc = est_server_init_csrattrs(NULL, "US900 test1", 10);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* NULL string - should pass */
    rc = est_server_init_csrattrs(ectx, NULL, 10);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Zero length - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 0);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Length too long - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", MAX_CSRATTRS + 1);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Real base64 string - should pass */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the smallest base64 size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting an illegally small base64 size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR7, strlen(TEST_ATTR7));
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* enable PoP */
    st_enable_pop();

    /* Real base64 string needs PoP added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 116 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 244 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 245 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 250 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* disable PoP */
    st_disable_pop();

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Real base64 string PoP should not be added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
}

/*
 * Test2 - exercise the server side variations triggered
 *         by est_client_get_csrattrs()
 */
static void us900_test2 (void)
{
    EST_CTX *ctx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    unsigned char *retrieved_cacerts = NULL;
    int retrieved_cacerts_len = 0;
    EVP_PKEY * priv_key;
    int csr_len;
    unsigned char *csr_data = NULL;

    SLEEP(1);

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
        printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ctx = est_client_init(
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        client_manual_cert_verify);
    CU_ASSERT(ctx != NULL);

    rc = est_client_set_auth(ctx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ctx, US900_SERVER_IP, US900_SERVER_PORT, NULL);

    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ctx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);

    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);

    /*
     * output the retrieved ca certs and compare to what they should be
     */
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);
    }
    free(retrieved_cacerts);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* should get 204 with no data */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);
    CU_ASSERT(csr_data == NULL);

    /* Real base64 string - should pass */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_corrupt_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_short_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_long_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }
    /* callback should supersede init csrattrs */
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2));
    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));
    CU_ASSERT(rc == EST_ERR_NONE);

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR3));
    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);

    /* clear csrattrs */
    rc = est_server_init_csrattrs(ectx, NULL, 0);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));
    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* Enable PoP and test responses with PoP added */
    st_enable_pop();

    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_data != NULL);
    CU_ASSERT(csr_len = 20);
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1024_NOPOP,
        strlen(TEST_1024_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_1024_POP));
    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 122 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));
    CU_ASSERT(
        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 117 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));
    CU_ASSERT(
        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);

    /* Real base64 string needs PoP added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    /* Not a real base64 string - should fail */
    rc = est_server_init_csrattrs(ectx, "US900 test1", 11);
    CU_ASSERT(rc != EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));
    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the smallest size */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* Setting the size 116 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 244 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 245 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Setting the size 250 */
    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));
    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR1));
    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_nopop_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));
    CU_ASSERT(
        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);

    if (est_set_csr_cb(ectx, &handle_empty_csrattrs_request)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));
    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);

    /* disable PoP */
    st_disable_pop();

    /* clear callback */
    if (est_set_csr_cb(ectx, NULL)) {
        printf("\nUnable to set EST CSR Attributes callback.  Aborting!!!\n");
        exit(1);
    }

    /* Real base64 string PoP should not be added - should pass */
    rc = est_server_init_csrattrs(
        ectx,
        TEST_ATTR_NOPOP,
        strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));
    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);

    /* All ASN.1 types supported by CiscoSSL */
    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));
    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);

    rc = est_server_init_csrattrs(
        ectx,
        TEST_1025_NOPOP,
        strlen(TEST_1025_NOPOP));
    CU_ASSERT(rc != EST_ERR_NONE);
    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));
    CU_ASSERT(rc != EST_ERR_NONE);

    if (ctx) {
        est_destroy(ctx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us900_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us900_srv_csrattrs",
            us900_init_suite,
            us900_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "CSR Server Attributes API1", us900_test1)) ||
        (NULL == CU_add_test(pSuite, "CSR Server Attributes API2", us900_test2)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us3496.c - Unit Tests URI path segment extension support 
 *
 * March, 2016
 *
 * Copyright (c) 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include "../../util/test_utils.h"
#include "st_server.h"

#include "../../src/est/est_locl.h"

extern char tst_srvr_path_seg_enroll[];
extern char tst_srvr_path_seg_auth[];

static int path_segment_support;

/*
 * max command line length when generating system commands
 */
#define EST_UT_MAX_CMD_LEN 256

/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"

#define US3496_SERVER_PORT   29496
#define US3496_SERVER_IP    "127.0.0.1"	
#define US3496_UIDPWD_GOOD   "estuser:estpwd"
#define US3496_UID           "estuser"
#define US3496_PWD           "estpwd"
#ifndef WIN32
#define US3496_CACERTS	    "CA/estCA/cacert.crt"
#define US3496_TRUST_CERTS   "CA/trustedcerts.crt"
#define US3496_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#else
#define US3496_CACERTS	    "CA\\estCA\\cacert.crt"
#define US3496_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US3496_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us3496_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}
#endif

#define US3496_ENROLL_URL_BA "https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll"
#define US3496_PKCS10_CT	    "Content-Type: application/pkcs10" 

#define US3496_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);

static void us3496_clean (void)
{
}

static int us3496_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US3496_SERVER_PORT, 
	          US3496_SERVER_CERTKEY,
	          US3496_SERVER_CERTKEY,
	          "US3496 test realm",
	          US3496_CACERTS,
	          US3496_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    
    SLEEP(1);
    return rv;
}

static int path_seg_supported(void) {

    EST_CTX *ectx;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);


    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, "test_segment");

    if (rc == EST_ERR_NONE) {
        return 1;
    } else {
        return 0;
    }

    return 0;
}


/*
 * This routine is called when CUnit initializes this test
 * suite. 
 * 1. Generate the keypair to be used for this EST Client UT suite
 */
static int us3496_init_suite (void)
{
    int rv = 0;
   
    char cmd[EST_UT_MAX_CMD_LEN];    
    printf("Starting EST Client/Proxy path segment unit tests.\n");

    /*
     * check to see if path segment support has been compiled in
     */
    if (!path_segment_support) {
        printf("URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \n");
        return 0;
    }
    
    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
             "openssl ecparam -name prime256v1 -genkey -out %s", CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);
    
    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us3496_clean();    
    /*
     * Start an instance of the EST server
     */
    rv = us3496_start_server(0, 0);
    SLEEP(2);
    
    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us3496_destroy_suite (void)
{
    
    st_stop();    
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}
    


/*
 * This test case tests the set server with valid parameters,
 * NO path segment
 */
static void us3496_test1 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, NULL);    
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is valid
 */
static void us3496_test2 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "somestring");
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that contains 2 segments, should fail
 */
static void us3496_test3 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "somestring1/somestring2");

    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * all valid characters
 */
#define PATH_SEG_ALL_VALID_CHARS "@%50%44%42ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-._~!$&'()*+,;="
static void us3496_test4 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                             PATH_SEG_ALL_VALID_CHARS);
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is invalid. invalid character.
 */
static void us3496_test5 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "someinvalid<string");
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is too long (129)
 */
#define path_segment_too_long "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
static void us3496_test6 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               path_segment_too_long);
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that is equal to an operation (cacerts)
 */
static void us3496_test7 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "cacerts");
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that contains an operation (cacerts),
 * in this case it's at the front of the string
 */
static void us3496_test8 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "cacerts-server");
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that is the empty string.
 * This should fail.
 */
static void us3496_test9 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               "");
    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down a path segment that contains a ':'.
 * This should pass.
 */
static void us3496_test10 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, "-._~:@!$&'()*+,;=");    
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * pass down path segment that is too long (129)
 */
#define path_segment_max "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678"
static void us3496_test11 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,
                               path_segment_max);
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us3496_add_suite (void)
{
    CU_ErrorCode CU_error;
    
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us3496_client_proxy_path_seg", 
	                  us3496_init_suite, 
			  us3496_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }
   
#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us3496_logger_stderr);
#endif

   /*
    * check to see if path segment support has been compiled in
    */
   if (!path_seg_supported()) {
       printf("URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \n");
       path_segment_support = 0;
       return 0;
   }
   path_segment_support = 1; 
   
   if (path_segment_support) {
       
       /* add the tests to the suite */
       /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
       if (
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, no path segment", us3496_test1)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, valid path segment", us3496_test2)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, multi segment path segment", us3496_test3)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, valid path segment - all valid chars", us3496_test4)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, invalid path segment", us3496_test5)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment too long", us3496_test6)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment equals operation string", us3496_test7)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment contains operation string", us3496_test8)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment is the empty string", us3496_test9)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment contains a colon", us3496_test10)) ||
           (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters, path segment is the max length", us3496_test11))
           ) {
           CU_error = CU_get_error();
           printf("%d\n", CU_error);
           
           CU_cleanup_registry();
           printf("%s\n", CU_get_error_msg());
           return CU_get_error();
       }
   }
   

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us897.c - Unit Tests for User Story 897 - Client CACerts 
 *
 * June, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif
#include "../../util/test_utils.h"
#include "st_server.h"

/*
 * max command line length when generating system commands
 */
#define EST_UT_MAX_CMD_LEN 256
#define EST_CA_MAX	    200000
/*
 * The CA certificate used to verify the EST server.  Grab it from the server's directory
 */
/* #define CLIENT_UT_CACERT "../../example/server/estCA/cacert.crt" */
#define US897_SERVER_PORT   29897
#define CLIENT_UT_PUBKEY "./est_client_ut_keypair"
#define US897_SERVER_IP	    "127.0.0.1"	
#define US897_UID	    "estuser"
#define US897_PWD	    "estpwd"

#ifndef WIN32
#define CLIENT_UT_CACERT "CA/estCA/cacert.crt"
#define US897_CACERTS	    "CA/estCA/cacert.crt"
#define US897_TRUST_CERTS   "CA/trustedcerts.crt"
#define US897_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS "US897/singlechain_10certs_trusted.crt"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING "US897/singlechain_9certs_missingcert.crt"
#define US897_CACERTS_SINGLE_CHAIN_EXPIRED "US897/singlechain_expired.crt"
#define US897_CACERTS_MULTI_CHAIN_CRLS "US897/trustedCHain10RevokedDepth6Implicit10andcacert.crt"
#else
#define CLIENT_UT_CACERT "CA\\estCA/cacert.crt"
#define US897_CACERTS	    "CA\\estCA\\cacert.crt"
#define US897_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US897_SERVER_CERTKEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS "US897\\singlechain_10certs_trusted.crt"
#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING "US897\\singlechain_9certs_missingcert.crt"
#define US897_CACERTS_SINGLE_CHAIN_EXPIRED "US897\\singlechain_expired.crt"
#define US897_CACERTS_MULTI_CHAIN_CRLS "US897\\trustedCHain10RevokedDepth6Implicit10andcacert.crt"
#endif 

static void us897_clean (void)
{
}

static int us897_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
	          US897_CACERTS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    
    SLEEP(1);
    return rv;
}


/*
 * This routine is called when CUnit initializes this test
 * suite. 
 * 1. Generate the keypair to be used for this EST Client UT suite
 */
static int us897_init_suite (void)
{
    int rv = 0;
    
    char cmd[EST_UT_MAX_CMD_LEN];    
    printf("Starting EST Client unit tests. PDB\n");

    /*
     * gen the keypair to be used for EST Client testing
     */
    snprintf(cmd, EST_UT_MAX_CMD_LEN,
             "openssl ecparam -name prime256v1 -genkey -out %s", CLIENT_UT_PUBKEY);
    printf("%s\n", cmd);
    
    rv = system(cmd);

    /*
     * start the server for the tests that need to talk to a server
     */
    us897_clean();    
    /*
     * Start an instance of the EST server
     */
    rv = us897_start_server(0, 0);
    SLEEP(2);
    
    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us897_destroy_suite (void)
{
    
    st_stop();    
    return 0;
}

/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}
    

/*
 * This test case initializes an EST client context
 * using local CA certs, no client cert, and a valid public key,
 * no userid and password.
 */
static void us897_test1 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;
    
    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    est_init_logger(EST_LOG_LVL_INFO, NULL);    
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
                             
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }    
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case initializes an EST client context
 * using no local CA certs.  This is expected to be a successful initialization
 * since the local CA trust anchor certs are not mandatory.
 */
static void us897_test2 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    ectx = est_client_init(NULL, 0, EST_CERT_FORMAT_PEM, client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    if (ectx) {
        est_destroy(ectx);
    }    
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case initializes an EST client context
 * using a local CA cert, no client cert,
 * and a valid public key, no userid and password.
 */
static void us897_test3 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}

#if 0
/*
 * This test case initializes an EST client context
 * using explict CA certs, no client cert, and a valid public key,
 * no userid and password.
 */
static void us897_test3 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }
    
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}
#endif


/*
 * This test case initializes an EST client context
 * using explict CA certs, no client cert, a public key,
 * and a userid and password.
 */
static void us897_test6 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "USER", "PASSWORD", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    if (ectx) {
        est_destroy(ectx);
    }    
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case initializes an EST client context
 * using explict CA certs, no client cert, a public key,
 * and a userid and NO password.
 */
static void us897_test7 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "USER", NULL, NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);

    if (ectx) {
        est_destroy(ectx);
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, NULL, "PASSWORD", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
    
    if (ectx) {
        est_destroy(ectx);
    }    
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the set server with valid parameters
 */
static void us897_test9 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    rc = est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);    
    CU_ASSERT(rc == EST_ERR_NONE);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the set server with invalid parameters
 */
static void us897_test10 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    char *server_name_too_long = "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890"\
        "12345678901234567890123456789012345678901234567890123456";
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    /*
     * Null server name
     */
    rc = est_client_set_server(ectx, NULL, US897_SERVER_PORT, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     * server too long
     */
    rc = est_client_set_server(ectx, server_name_too_long, US897_SERVER_PORT, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);

    /*
     *  port num less than 0
     */
    rc = est_client_set_server(ectx, US897_SERVER_IP, -1, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);

    /*
     * port num greater than max
     */
    rc = est_client_set_server(ectx, US897_SERVER_IP, 65536, NULL);
    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the Get CACerts request
 *
 */
static void us897_test11 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;

    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;
    EVP_PKEY *priv_key;

    SLEEP(1);
    
    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);    

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);
    
    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);

    /*
     * make sure that the context is no longer valid and the EST client is
     * back to the uninitialized state
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);
    CU_ASSERT(rc == EST_ERR_CLIENT_NOT_INITIALIZED);

    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the Get CACerts request with invalid input parameters
 *
 */
static void us897_test12 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;

    SLEEP(1);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, NULL);
    /*
     * should be successful, and should have obtained a valid buffer
     * containing the CA certs
     */
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single certificate
 */
static void us897_test13 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
	          US897_CACERTS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);
    
    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single chain with multiple certs
 */
static void us897_test14 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    retrieved_cacerts = malloc(retrieved_cacerts_len);
    
    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single chain with multiple certs and
 * a missing cert in the chain.  
 */
static void us897_test15 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);
    CU_ASSERT(retrieved_cacerts_len == 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a single chain with multiple certs 
 * with the intermediate cert expired.
 */
static void us897_test16 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_SINGLE_CHAIN_EXPIRED,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in thestartup  CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);
    CU_ASSERT(retrieved_cacerts_len == 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the CA cert response verification function.  It will
 * verify a CAcert response containing a multiple chains with multiple certs and
 * a CRL block.  The CRLs should be ignored.  
 */
static void us897_test17 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    

    /*
     * Stop the existing server.  Need to ensure that the server
     * is using a specific CA cert chain.
     */
    st_stop();
    SLEEP(2);

    /*
     * Spin up a new instance of the EST server
     * using a CA cert chain that contains just one cert
     */
    rc = st_start(US897_SERVER_PORT, 
	          US897_SERVER_CERTKEY,
	          US897_SERVER_CERTKEY,
	          "US897 test realm",
                  US897_CACERTS_MULTI_CHAIN_CRLS,
	          US897_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);

    CU_ASSERT(rc == 0);
    if (rc) return;
    SLEEP(1);

    /*
     * Read in the startup CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NONE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/*
 * This test case tests the SSL read set timeout API.
 * The setting of the min, the max, a value in between, and a value
 * beyond the max.
 */
static void us897_test18 (void) 
{
    EST_CTX *ectx;
    unsigned char *pkey = NULL;
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    EST_ERROR rc = EST_ERR_NONE;
    EVP_PKEY *priv_key;
    unsigned char *retrieved_cacerts = NULL;
    int  retrieved_cacerts_len = 0;    
  
    /*
     * Read in the startup CA certificates
     */
    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read in the private key file
     */
    priv_key = read_private_key(CLIENT_UT_PUBKEY);
    if (priv_key == NULL) {
	printf("\nError while reading private key file %s\n", CLIENT_UT_PUBKEY);
        return;
    }

    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    rc = est_client_set_auth(ectx, "", "", NULL, priv_key);
    CU_ASSERT(rc == EST_ERR_NONE);

    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);

    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MIN);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX);
    CU_ASSERT(rc == EST_ERR_NONE);
    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX+1);
    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);
    rc = est_client_set_read_timeout(ectx, 2);
    CU_ASSERT(rc == EST_ERR_NONE);

    /* Now proceed on with a GET /cacerts to verify that nothing gets broken */
    
    /*
     * issue the get ca certs request
     */
    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);

    /*
     * should be successful, and should have obtained a valid length
     * for the size of the CA certs buffer
     */
    CU_ASSERT(rc == EST_ERR_NONE);
    CU_ASSERT(retrieved_cacerts_len > 0);

    if (retrieved_cacerts_len) {
        /*
         * Shouldn't be in here, but if we are, malloc and call
         */
        retrieved_cacerts = malloc(retrieved_cacerts_len);
        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);

        /*
         * est should fail indicating that there's no cert to provide
         */
         CU_ASSERT(rc == EST_ERR_NONE);
    }    
    
    /*
     * output the retrieved ca certs and compare to what they should be
     */    
    if (retrieved_cacerts) {

        printf("\nRetrieved CA Certs buffer:\n %s\n", retrieved_cacerts);
        printf("Retrieved CA certs buffer length: %d\n", retrieved_cacerts_len);    
    }
    free(retrieved_cacerts);
    
    if (ectx) {
        est_destroy(ectx);
    }
    if (cacerts) {
        free(cacerts);
    }
    if (pkey) {
        free(pkey);
    }
}


/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us897_add_suite (void)
{
    CU_ErrorCode CU_error;
    
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us897_client_cacerts", 
	                  us897_init_suite, 
			  us897_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* add the tests to the suite */
   /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
   if ((NULL == CU_add_test(pSuite, "EST Client Init: local CA, private key ", us897_test1))  ||
       (NULL == CU_add_test(pSuite, "EST Client Init: no local CA", us897_test2)) ||
       (NULL == CU_add_test(pSuite, "EST Client Init: local CA, explicit CA, private key", us897_test3)) ||
/*        (NULL == CU_add_test(pSuite, "EST Client Init: local CA, explicit CA, client CA, private key", us897_test4)) || */
       (NULL == CU_add_test(pSuite, "EST Client Init: local CA, userid/password", us897_test6)) ||
       (NULL == CU_add_test(pSuite, "EST Client Init: local CA, userid/no password", us897_test7)) ||
/*        (NULL == CU_add_test(pSuite, "EST Client Init: local CA, no userid/password", us897_test8)) || */
       (NULL == CU_add_test(pSuite, "EST Client Set Server: correct parameters", us897_test9)) ||
       (NULL == CU_add_test(pSuite, "EST Client Set Server: no parameters", us897_test10)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: ca_cert valid parameters", us897_test11)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: missing ca_cert pointers", us897_test12)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-simple chain-success", us897_test13)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-multiple certs-success", us897_test14)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-broken chain-fail", us897_test15)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-bad date-fail", us897_test16)) ||
       (NULL == CU_add_test(pSuite, "EST Client CA Certs: verify chain-multiple chains-success", us897_test17)) ||
       (NULL == CU_add_test(pSuite, "EST Client SSL read timeout API", us897_test18))
       ) 
   {
      CU_error = CU_get_error();
      printf("%d\n", CU_error);
   
      CU_cleanup_registry();
      printf("%s\n", CU_get_error_msg());
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us1060.c - Unit Tests for User Story 1060 - TLS SRP support (Server/Proxy)
 *
 * May, 2014
 *
 * Copyright (c) 2014-2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#include <string.h>
#ifndef WIN32
#include <unistd.h>
#include <pthread.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "test_utils.h"
#include "curl_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US1060_SERVER_PORT      31060
#define US1060_SERVER_IP        "127.0.0.1"
#define US1060_UID              "estuser"
#define US1060_PWD              "estpwd"
#ifndef WIN32
#define US1060_CACERTS          "CA/estCA/cacert.crt"
#define US1060_TRUST_CERTS      "CA/trustedcerts.crt"
#define US1060_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US1060_VFILE            "US1060/passwd.srpv"

#define US1060_EXPLICIT_CERT    "US1060/explicit-cert.pem" 
#define US1060_EXPLICIT_KEY     "US1060/explicit-key.pem"
#define US1060_SELFSIGN_CERT    "US1060/selfsigned-cert.pem" 
#define US1060_SELFSIGN_KEY     "US1060/selfsigned-key.pem"
#else
#define US1060_CACERTS          "CA\\estCA\\cacert.crt"
#define US1060_TRUST_CERTS      "CA\\trustedcerts.crt"
#define US1060_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"
#define US1060_VFILE            "US1060\\passwd.srpv"

#define US1060_EXPLICIT_CERT    "US1060\\explicit-cert.pem" 
#define US1060_EXPLICIT_KEY     "US1060\\explicit-key.pem"
#define US1060_SELFSIGN_CERT    "US1060\\selfsigned-cert.pem" 
#define US1060_SELFSIGN_KEY     "US1060\\selfsigned-key.pem"
#endif

#define US1060_ENROLL_URL       "https://127.0.0.1:31060/.well-known/est/simpleenroll"
#define US1060_UIDPWD_GOOD      "estuser:estpwd"
#define US1060_UIDPWD_BAD       "estuser:xxx111222"
#define US1060_PKCS10_CT        "Content-Type: application/pkcs10"

#define US1060_PROXY_ENROLL_URL "https://127.0.0.1:41060/.well-known/est/simpleenroll"
#define US1060_PROXY_PORT       41060

#define US1060_PKCS10_REQ       "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"

static char *log_search_target = NULL;
static int search_target_found = 0;
static unsigned char *cacerts = NULL;
static int cacerts_len = 0;
static SRP_VBASE *srpdb = NULL;

#ifdef WIN32
CRITICAL_SECTION logger_critical_section;
#endif

/*
 * This is a simple callback used to override the default
 * logging facility in libest.  We'll use this to look
 * for specific debug output.
 */
static void us1060_logger_stderr (char *format, va_list l)
{
    char t_log[1024];
#ifndef WIN32
    flockfile(stderr);
#else
    EnterCriticalSection(&logger_critical_section);
#endif 
    if (log_search_target) {
        vsnprintf(t_log, 1024, format, l);
        if (strstr(t_log, log_search_target)) {
            search_target_found = 1;
        }
        fprintf(stderr, "%s", t_log);
    } else {
        vfprintf(stderr, format, l);
    }
    fflush(stderr);
#ifndef WIN32
    funlockfile(stderr);
#else
    LeaveCriticalSection(&logger_critical_section);
#endif
}

static int us1060_start_server (char *cert, char *key, int no_http_auth,
                                int enable_pop, int enable_srp)
{
    int rv;

    if (enable_srp) {
        rv = st_start_srp(US1060_SERVER_PORT,
                          cert,
                          key,
                          "US1060 test realm",
                          US1060_CACERTS,
                          US1060_TRUST_CERTS,
                          "CA/estExampleCA.cnf",
                          enable_pop,
                          US1060_VFILE);
    } else {
        rv = st_start(US1060_SERVER_PORT,
                      cert,
                      key,
                      "US1060 test realm",
                      US1060_CACERTS,
                      US1060_TRUST_CERTS,
                      "CA/estExampleCA.cnf",
                      0,
                      enable_pop,
                      0);
    }

    if (no_http_auth) {
        st_disable_http_auth();
    }

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1060_init_suite (void)
{
    int rv;

#ifdef WIN32
    /* Initialize critical section on Windows*/
    InitializeCriticalSection(&logger_critical_section);
#endif

    est_init_logger(EST_LOG_LVL_INFO, &us1060_logger_stderr);

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,
        1);

    /*
     * Start an instance of the proxy with SRP enabled
     */
    rv = st_proxy_start_srp(US1060_PROXY_PORT,
                            US1060_SERVER_CERTKEY,
                            US1060_SERVER_CERTKEY,
                            "US1060 proxy realm",
                            US1060_CACERTS,
                            US1060_TRUST_CERTS,
                            US1060_UID,
                            US1060_PWD,
                            US1060_SERVER_IP,
                            US1060_SERVER_PORT,
                            0,
                            US1060_VFILE);

    /*
     * Read in the CA certificates
     * Used for client-side API testing
     */
    cacerts_len = read_binary_file(US1060_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    srpdb = SRP_VBASE_new(NULL);
    if (!srpdb) {
        printf("\nUnable allocate SRP verifier database.  Aborting!!!\n");
    }
    if (SRP_VBASE_init(srpdb, US1060_VFILE) != SRP_NO_ERROR) {
        printf("\nUnable initialize SRP verifier database.  Aborting!!!\n");
    }

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1060_destroy_suite (void)
{
    if (srpdb) {
        SRP_VBASE_free(srpdb);
    }

    st_stop();
    st_proxy_stop();
    free(cacerts);
    return 0;
}

typedef enum {
    SRP_OFF, SRP_ON
} server_srp_mode;

typedef enum {
    SRP_GOOD, SRP_BAD, SRP_NONE,
} client_srp_mode;

typedef enum {
    HTTP_OFF, HTTP_OPTIONAL, HTTP_REQUIRED
} server_http_mode;

typedef struct {
    char *test_name;
    char *curl_cert;
    char *curl_key;
    char *curl_http_auth;
    client_srp_mode curl_srp;
    server_http_mode server_http;
    server_srp_mode server_srp;
    int expected_http_result;
} us1060_matrix;

/*
 * This is the unit test matrix for server-side SRP support.  Curl is
 * used as the EST client.  Because of this PoP is disabled on the
 * server for all test cases.  We try to cover a variety of configurations
 * and potential scenarios.  The client side variations include:
 *
 * curl_cert:  The certificate curl uses, which may be NULL
 * curl_key:   The key curl uses, which may be NULL
 * curl_http_auth:  The HTTP auth credentials used by curl.
 * client_srp_mode: Either GOOD, BAD, NONE.  Determines which SRP credentials are used
 *                  Curl.
 *
 * On the server side we configure the server using the following variations:
 *
 * server_http_mode:  HTTP auth is required, optional, or disabled.
 *                    (optional means it only occurs when TLS auth fails)
 * server_srp_mode:   SRP is either enabled or disabled on the server.
 *
 * expected_http_result:  This is the expected HTTP status code received on by Curl.
 *                        When SRP fails, this results in a failed TLS session.  Curl
 *                        returns a zero in this case since the HTTP layer can not
 *                        communicate.  If TLS succeeds, but HTTP auth fails, then
 *                        the server should return a HTTP 401 response to the client.
 *                        When enrollment succeeds, the server should send a
 *                        HTTP 200 response.
 *
 *
 */
static us1060_matrix test_matrix[] = {
    {"1", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 200},
    {"2", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},
    {"3", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 200},
    {"4", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},
    {"5", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},
    {"6", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 200},
    {"7", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},
    {"8", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},
    {"9", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},

    {"11", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 401},
    {"12", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},
    {"13", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 401},
    {"14", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},
    {"15", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},
    {"16", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 401},
    {"17", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},
    {"18", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},
    {"19", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},

    {"21", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},
    {"22", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},
    {"23", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},
    {"24", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},
    {"25", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},
    {"26", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},
    {"27", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},
    {"28", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},
    {"29", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},

    {"31", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},
    {"32", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},
    {"33", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},
    {"34", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},
    {"35", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},
    {"36", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 401},
    {"37", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},
    {"38", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},
    {"39", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},

    {"40", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  200},
    {"41", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  401},
    {"42", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},
    {"43", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},
    {"44", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  200},
    {"45", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  200},
    {"46", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},
    {"47", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},
    {"48", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},
    {"49", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},
    {"50", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 200},
    {"51", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 200},

    {"60", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},
    {"61", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},
    {"62", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},
    {"63", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},
    {"64", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  0},
    {"65", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  0},
    {"66", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},
    {"67", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},
    {"68", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},
    {"69", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},
    {"70", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 0},
    {"71", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 0},
};

/*
 * This is our worker for each entry in the test matrix above.
 * We read the configuration from the entry, configure the
 * server and client as needed, and attempt a simple enroll
 * using Curl as the client.
 * The argument i is the index of the entry in the table above.
 */
static void us1060_test_matrix_item (int i)
{
    long rv;

    LOG_FUNC_NM
    ;

    printf("\nRunning matrix test %s\n", test_matrix[i].test_name);

    /*
     * Stop the server and restart it to make sure
     * it's in the correct mode.
     */
    st_stop();
    SLEEP(1);
    if (test_matrix[i].server_srp == SRP_ON) {
        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,
            0, 0, 1);
    } else {
        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,
            0, 0, 0);
    }
    CU_ASSERT(rv == 0);

    /*
     * Set the server HTTP auth configuration
     */
    switch (test_matrix[i].server_http) {
    case HTTP_OFF:
        st_disable_http_auth();
        break;
    case HTTP_OPTIONAL:
        st_enable_http_auth();
        st_set_http_auth_optional();
        break;
    case HTTP_REQUIRED:
        st_enable_http_auth();
        st_set_http_auth_required();
        break;
    }

    switch (test_matrix[i].curl_srp) {
    case SRP_GOOD:
        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,
        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,
            NULL, "srp_user", "srp_pwd", NULL, NULL);
        break;
    case SRP_BAD:
        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,
        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,
            NULL, "srp_user", "boguspwd", NULL, NULL);
        break;
    case SRP_NONE:
        /*
         * Some of the SRP disabled test cases use a client
         * certificate.
         */
        if (test_matrix[i].curl_cert) {
            rv = curl_http_post_certuid(US1060_ENROLL_URL, US1060_PKCS10_CT,
            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,
                test_matrix[i].curl_cert, test_matrix[i].curl_key,
                US1060_CACERTS, NULL);
        } else {
            rv = curl_http_post(US1060_ENROLL_URL, US1060_PKCS10_CT,
            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,
            US1060_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
        }
        break;
    }
    CU_ASSERT(rv == test_matrix[i].expected_http_result);
    if (rv != test_matrix[i].expected_http_result) {
        printf("\nMatrix test %s failed with rv = %d\n",
            test_matrix[i].test_name, (int) rv);
    }
}

/*
 * This test case runs all the tests in the matrix
 */
static void us1060_test0 (void)
{
    int i;
    int test_cnt = sizeof(test_matrix) / sizeof(test_matrix[0]);

    for (i = 0; i < test_cnt; i++) {
        us1060_test_matrix_item(i);
    }
}

/*
 * This test case is verifies the happy path when EST
 * proxy is configured in SRP mode.  The client will attempt
 * to use SRP.  The connection between the proxy and
 * server does not use SRP.  We perform a simple enroll
 * operation.
 */
static void us1060_test200 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    /*
     * Restart the EST server with SRP disabled
     */
    st_stop();
    SLEEP(2);
    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,
        0);
    CU_ASSERT(rv == 0);

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ,
    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, "srp_user", "srp_pwd", NULL,
        NULL);
    /*
     * Since we passed in a valid SRP userID/password,
     * we expect the server to respond with success
     */
    CU_ASSERT(rv == 200);
}

/*
 * This test case is verifies the simple enroll fails
 * when the EST client provides a bad SRP password.
 * The connection between the proxy and server does not
 * use SRP.
 */
static void us1060_test201 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ,
    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, "srp_user", "boguspwd",
        NULL, NULL);
    CU_ASSERT(rv == 0);
}

/*
 * This test case is verifies the simple enroll fails
 * when the EST client provides a bad HTTP password
 * and SRP is used.  The connection between the proxy
 * and server does not use SRP.
 */
static void us1060_test202 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ,
    US1060_UIDPWD_BAD, NULL, CURLAUTH_BASIC, NULL, "srp_user", "srp_pwd", NULL,
        NULL);
    CU_ASSERT(rv == 401);
}

/*
 * This test case is verifies the simple enroll works
 * when the EST client provides no HTTP password
 * and SRP is used.  The connection between the proxy
 * and server does not use SRP.  HTTP auth is disabled
 * on the proxy.
 */
static void us1060_test203 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_http_disable(1);

    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,
    US1060_PKCS10_REQ, NULL, NULL, CURLAUTH_NONE, NULL, "srp_user", "srp_pwd",
        NULL, NULL);
    CU_ASSERT(rv == 200);
}

int us1060_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1060_tls_srp (server/proxy)",
            us1060_init_suite,
            us1060_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /*
     * Add the tests to the suite
     *
     * ********************IMPORTANT*********************
     * Do not change the order of these tests.
     * Some of the tests stop the EST server and restart
     * it using different certs.  If you change the order
     * then false negatives may occur.
     * **************************************************
     *
     */
    if ((NULL == CU_add_test(pSuite, "TLS-SRP server: matrix master", us1060_test0)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll w/SRP", us1060_test200)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll bad SRP pwd", us1060_test201)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll bad HTTP pwd", us1060_test202)) ||
        (NULL == CU_add_test(pSuite, "TLS-SRP proxy: enroll w/o HTTP auth", us1060_test203)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us893.c - Unit Tests for User Story 893 - proxy reenroll
 *
 * October, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include "st_proxy.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US893_TCP_SERVER_PORT       29893
#define US893_TCP_PROXY_PORT        29093

/*
 * The following CSR was generated using the following openssl command and then
 * using cat on the rsa.req file:
 *
 * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM
 */
#define US893_PKCS10_RSA2048 "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

#define US893_PKCS10_CORRUPT "MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDfffmdmd8j5ZyPY56eAuxarWssD\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X"

#define US893_SERVER_IP         "127.0.0.1" 
#define US893_REENROLL_URL_BA   "https://127.0.0.1:29093/.well-known/est/simplereenroll"
#define US893_PKCS10_CT         "Content-Type: application/pkcs10" 
#define US893_UIDPWD_GOOD       "estuser:estpwd"
#define US893_UID               "estuser"
#define US893_PWD               "estpwd"
#ifndef WIN32
#define US893_CACERTS           "CA/estCA/cacert.crt"
#define US893_TRUSTED_CERTS     "CA/trustedcerts.crt"
#define US893_SERVER_CERTKEY    "CA/estCA/private/estservercertandkey.pem"
#define US893_PROXY_CERT        "US893/cert.pem"
#define US893_PROXY_KEY         "US893/key.pem"
#define US893_UNTRUSTED_CERT    "US893/cert-untrusted.pem"
#define US893_UNTRUSTED_KEY     "US893/key-untrusted.pem"
#define US893_EXPIRED_KEY       "US893/key-expired.pem"
#define US893_EXPIRED_CERT      "US893/cert-expired.pem"

#define US893_TC2_CERT_TXT      "US893/tc2-new-cert.txt"
#define US893_TC2_CERT_B64      "US893/tc2-new-cert.pkcs7b64"
#define US893_TC2_CERT_PK7      "US893/tc2-new-cert.pkcs7"
#define US893_TC2_CERT_PEM      "US893/tc2-new-cert.pem"
#else
#define US893_CACERTS           "CA\\estCA\\cacert.crt"
#define US893_TRUSTED_CERTS     "CA\\trustedcerts.crt"
#define US893_SERVER_CERTKEY    "CA\\estCA\\private\\estservercertandkey.pem"
#define US893_PROXY_CERT        "US893\\cert.pem"
#define US893_PROXY_KEY         "US893\\key.pem"
#define US893_UNTRUSTED_CERT    "US893\\cert-untrusted.pem"
#define US893_UNTRUSTED_KEY     "US893\\key-untrusted.pem"
#define US893_EXPIRED_KEY       "US893\\key-expired.pem"
#define US893_EXPIRED_CERT      "US893\\cert-expired.pem"

#define US893_TC2_CERT_TXT      "US893\\tc2-new-cert.txt"
#define US893_TC2_CERT_B64      "US893\\tc2-new-cert.pkcs7b64"
#define US893_TC2_CERT_PK7      "US893\\tc2-new-cert.pkcs7"
#define US893_TC2_CERT_PEM      "US893\\tc2-new-cert.pem"
#endif

static void us893_clean (void)
{
    char cmd[200];

    /*
     * These are all temporary files created
     * by the various test cases.
     */
#ifndef WIN32
    sprintf(cmd, "rm %s", US893_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "rm %s", US893_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "rm %s", US893_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "rm %s", US893_TC2_CERT_PEM);
    system(cmd);
#else
    sprintf(cmd, "del %s", US893_TC2_CERT_TXT);
    system(cmd);
    sprintf(cmd, "del %s", US893_TC2_CERT_B64);
    system(cmd);
    sprintf(cmd, "del %s", US893_TC2_CERT_PK7);
    system(cmd);
    sprintf(cmd, "del %s", US893_TC2_CERT_PEM);
    system(cmd);
#endif
}

static int us893_start_server (int manual_enroll, int nid)
{
    int rv;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US893_TCP_SERVER_PORT,
                  US893_SERVER_CERTKEY,
                  US893_SERVER_CERTKEY,
                  "US893 test realm",
                  US893_CACERTS,
                  US893_TRUSTED_CERTS,
                  "US893/estExampleCA.cnf",
                  manual_enroll,
                  0,
                  nid);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy actging as an RA
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us893_init_suite (void)
{
    int rv;

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US893_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us893_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us893_start_server(0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us893_destory_suite (void)
{
    st_stop();
    st_proxy_stop();
    free(cacerts);
    return 0;
}

/*
 * Simple reenroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * reenroll of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.
 */
static void us893_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
    US893_PKCS10_RSA2048,
    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  The expired certs contains
 * several X509 extensions. We verify the new issued
 * cert preserves these extensions using grep.  Note,
 * preserving these extensions requires the OpenSSL CA
 * to enable the "copy_extensions" knob in the OpenSSL
 * config file.  This is why this test suite uses a
 * unique copy of estExampleCA.cnf.
 */
static void us893_test2 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    X509 *cert = NULL;
    BIO *in;
    char cmd[200];
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Save the cert to a local file
     */
    rv = write_binary_file(US893_TC2_CERT_B64, new_cert, pkcs7_len);
    CU_ASSERT(rv == 1);

    /*
     * Base 64 decode the cert response
     */
    sprintf(cmd, "openssl base64 -d -in %s -out %s", US893_TC2_CERT_B64,
    US893_TC2_CERT_PK7);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert the pkcs7 cert to a PEM cert
     */
    sprintf(cmd, "openssl pkcs7 -in %s -inform DER -print_certs -out %s",
    US893_TC2_CERT_PK7,
    US893_TC2_CERT_PEM);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Convert PEM cert to a textual representation of the cert
     */
    sprintf(cmd, "openssl x509 -text -in %s > %s", US893_TC2_CERT_PEM,
    US893_TC2_CERT_TXT);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * Verify the jimbob DNS extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "jimbob");
    CU_ASSERT(rv == 0);

    /*
     * Verify the bobcat DNS extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "bobcat");
    CU_ASSERT(rv == 0);

    /*
     * Verify the IP address extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "172");
    CU_ASSERT(rv == 0);

    /*
     * Verify the Repudiation key usage extension was preserved
     */
    rv = grep(US893_TC2_CERT_TXT, "Repudiation");
    CU_ASSERT(rv == 0);

    /*
     * Verify the public key was preserved
     */
    rv = grep(US893_TC2_CERT_TXT,
        "00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50");
    CU_ASSERT(rv == 0);

    /*
     * Clean up
     */
    if (new_cert)
        free(new_cert);
    est_destroy(ectx);
}

/*
 * Simple reenroll - Corrupt CSR
 *
 * Use libcurl to send a reenroll request containing
 * a corrupted CSR.
 */
static void us893_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
    US893_PKCS10_CORRUPT,
    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * Since we passed in a bad CSR,
     * we expect the server to respond with 400
     */
    CU_ASSERT(rv == 400);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured for manual
 * approval.  The server will send back a retry-after
 * response.  This verifies the proxy propagates the
 * retry-after response to the client.
 */
static void us893_test4 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int rv;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    int retry_val = 0;
    time_t time_val;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Stop the server.
     */
    st_stop();
    st_proxy_stop();

    /*
     * Restart the server with manual approval enabled
     */
    rv = us893_start_server(1, 0);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);

    /*
     * The server should be configured with a retry-after
     * value of 3600 seconds, which is the default.
     */
    rv = est_client_copy_retry_after(ectx, &retry_val, &time_val);
    CU_ASSERT(rv == EST_ERR_NONE);
    CU_ASSERT(retry_val == 3600);

    /*
     * Clean up
     */
    est_destroy(ectx);

    /*
     * Stop the server.
     */
    st_stop();
    st_proxy_stop();

    /*
     * Restart the server with manual approval disabled
     */
    rv = us893_start_server(0, 0);
    CU_ASSERT(rv == 0);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured with PoP
 * enabled, but the proxy server is using a cert
 * that doesn't contain id-kp-cmcRA.  This should
 * result in a failure.
 */
static void us893_test5 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is enabled on the server
     */
    st_enable_pop();

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_SERVER_CERTKEY,
                        US893_SERVER_CERTKEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Use libcurl to send an enroll request.  We use libcurl
     * because it will not include the PoP.
     */
    rv = curl_http_post(US893_REENROLL_URL_BA,
                        US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD,
                        US893_CACERTS,
                        CURLAUTH_BASIC,
                        NULL,
                        NULL,
                        NULL);
    /*
     * The PoP check should fail
     */
    CU_ASSERT(rv == 400);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser", "estpwd", "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured with PoP
 * disabled, but the proxy server is using a cert
 * that doesn't contain id-kp-cmcRA.  This should
 * result in a successful reenroll.
 */
static void us893_test6 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_SERVER_CERTKEY,
                        US893_SERVER_CERTKEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Use libcurl to send an enroll request.  We use libcurl
     * because it will not include the PoP.
     */
    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
    US893_PKCS10_RSA2048,
    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);
    /*
     * The reenroll should work since PoP is not enabled anywhere.
     */
    CU_ASSERT(rv == 200);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();
}

/*
 * This test attempts to re-enroll an expired cert
 * while the EST server is configured with PoP
 * disabled, but the proxy server is using a cert
 * that doesn't contain id-kp-cmcRA.  The CSR will
 * contain the PoP, which forces it to be checked.
 * This should result in a failure since the RA
 * cert doesn't contain id-kp-cmcRA.
 */
//The following include should never be used by an application
//be we use it here to hack the EST_CTX values mid-way
//through this test
#include "../../src/est/est_locl.h"
static void us893_test7 (void)
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    int pkcs7_len = 0;
    X509 *cert = NULL;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_SERVER_CERTKEY,
                        US893_SERVER_CERTKEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    ectx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this 
    //We need to force the challengePassword into the CSR
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();

    est_destroy(ectx);
}

/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  PoP is disabled on
 * the EST server.
 */
static void us893_test8 (void)
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    X509 *cert = NULL;
    int rv;
    int pkcs7_len = 0;
    BIO *in;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);

    /*
     * Read in the private key
     */
    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);
    CU_ASSERT(key_len > 0);
    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
    CU_ASSERT(key != NULL);
    free(key_raw);

    /*
     * Read in the old cert
     */
    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);
    CU_ASSERT(cert_len > 0);
    in = BIO_new_mem_buf(cert_raw, cert_len);
    CU_ASSERT(in != NULL);
    if (!in)
        return;
    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
    CU_ASSERT(cert != NULL);
    if (!cert)
        return;
    BIO_free_all(in);
    free(cert_raw);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Enroll an expired cert that contains x509 extensions.
     */
    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    est_destroy(ectx);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();
}

/*
 * This test case uses an existing expired cert and
 * attempts to re-enroll it.  PoP is disabled on
 * the EST server.  The CSR does not contain a PoP.
 */
static void us893_test9 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Make sure PoP is disabled on the server
     */
    st_disable_pop();

    /*
     * Use libcurl to send an enroll request.  We use libcurl
     * because it will not include the PoP.
     */
    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * The reenroll should work since PoP is not enabled anywhere.
     */
    CU_ASSERT(rv == 200);

    /*
     * Re-enable PoP on the server for the forthcoming test cases.
     */
    st_enable_pop();
}

/*
 * This test case uses a bad password configured on
 * the EST proxy context.  This should cause the EST
 * server to reject the reenroll request.
 */
static void us893_test10 (void)
{
    int rv;

    LOG_FUNC_NM
    ;

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "bogus",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    CU_ASSERT(rv == 401);


    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);
}

static void us893_test11 (void)
{
    int rv;
    long http_code = 0;
    CURL *hnd;
    struct curl_slist *slist1;

    LOG_FUNC_NM
    ;

    /*
     * Stop the proxy server so we can restart
     * it using a different identity cert.
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using an untrusted cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_UNTRUSTED_CERT,
                        US893_UNTRUSTED_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);

    /*
     * We don't use the normal curl util API here because
     * we need to disable TLS peer verification for this
     * special test case.
     */
    /*
     * Set the Content-Type header in the HTTP request
     */
    slist1 = NULL;
    slist1 = curl_slist_append(slist1, US893_PKCS10_CT);

    /*
     * Setup all the other fields that CURL requires
     */
    hnd = curl_easy_init();
    curl_easy_setopt(hnd, CURLOPT_URL, US893_REENROLL_URL_BA);
    curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);
    curl_easy_setopt(hnd, CURLOPT_USERPWD, US893_UIDPWD_GOOD);
    curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, US893_PKCS10_RSA2048);
    curl_easy_setopt(hnd, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)strlen(US893_PKCS10_RSA2048));
    curl_easy_setopt(hnd, CURLOPT_USERAGENT, "curl/7.27.0");
    curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);
    curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);
    curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);
    curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
    curl_easy_setopt(hnd, CURLOPT_CAINFO, US893_CACERTS);
    curl_easy_setopt(hnd, CURLOPT_VERBOSE, 1L);
    curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);
    curl_easy_setopt(hnd, CURLOPT_FORBID_REUSE, 1L);

    /*
     * Issue the HTTP request
     */
    curl_easy_perform(hnd);

    /*
     * Get the HTTP reponse status code from the server
     */
    curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &http_code);
    curl_easy_cleanup(hnd);
    hnd = NULL;
    curl_slist_free_all(slist1);
    slist1 = NULL;

    CU_ASSERT(http_code == 400);

    /*
     * Stop the proxy server
     */
    st_proxy_stop();

    /*
     * Restart the proxy server using the other cert
     */
    rv = st_proxy_start(US893_TCP_PROXY_PORT,
                        US893_PROXY_CERT,
                        US893_PROXY_KEY,
                        "US893 test realm",
                        US893_CACERTS,
                        US893_TRUSTED_CERTS,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US893_TCP_SERVER_PORT,
                        0,
                        0);
    CU_ASSERT(rv == 0);
}

/*
 * Simple reenroll - RSA 2048
 *
 * This test case uses libcurl to test simple
 * reenroll of a 2048 bit RSA CSR.  HTTP Basic
 * authentication is used.  However, PoP is now
 * enabled on the proxy, which should cause a
 * failure since libcurl doesn't include the PoP.
 */
static void us893_test12 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_enable_pop();

    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,
                        US893_PKCS10_RSA2048,
                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Should fail since the proxy will fail the PoP check
     */
    CU_ASSERT(rv == 400);

    st_proxy_disable_pop();
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us893_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us893_proxy_simpreenroll",
                           us893_init_suite,
                           us893_destory_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    if ((NULL == CU_add_test(pSuite, "ReEnroll RSA cert", us893_test1)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert", us893_test2)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll corrupt CSR", us893_test3)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert with retry-after", us893_test4)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll no proxy id-kp-cmcRA with srv PoP", us893_test5)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll no proxy id-kp-cmcRA w/o srv PoP", us893_test6)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll no proxy id-kp-cmcRA w/o srv PoP CSR PoP", us893_test7)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert w/o srv PoP CSR PoP", us893_test8)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll expired cert w/o srv PoP no CSR PoP", us893_test9)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll proxy misconfigured HTTP auth", us893_test10)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll proxy untrusted identity cert", us893_test11)) ||
        (NULL == CU_add_test(pSuite, "ReEnroll PoP enabled proxy no CSR PoP", us893_test12)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us899.c - Unit Tests for User Story 899 - Client simple enroll 
 *
 * September, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US899_SERVER_PORT   29899
#define US899_SERVER_IP	    "127.0.0.1"	
#define US899_UID	    "estuser"
#define US899_PWD	    "estpwd"

/*
 * The following certs are used for FQDN testing
 */
#ifndef WIN32
#define US899_CACERTS	    "CA/estCA/cacert.crt"
#define US899_TRUST_CERTS   "CA/trustedcerts.crt"
#define US899_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"

#define US899_SERVER_CERT_CN_MISMATCH	    "US899/cert_cn_mismatch.pem"
#define US899_SERVER_KEY_CN_MISMATCH	    "US899/key_cn_mismatch.pem"
#define US899_SERVER_CERT_CN_MISMATCH_IP    "US899/cert_cn_mismatch_ip.pem"
#define US899_SERVER_KEY_CN_MISMATCH_IP	    "US899/key_cn_mismatch_ip.pem"
#define US899_SERVER_CERT_CN_MATCH_WC       "US899/cert_cn_match_wc.pem"
#define US899_SERVER_KEY_CN_MATCH_WC	    "US899/key_cn_match_wc.pem"
#define US899_SERVER_CERT_CN_MISMATCH_WC    "US899/cert_cn_mismatch_wc.pem"
#define US899_SERVER_KEY_CN_MISMATCH_WC	    "US899/key_cn_mismatch_wc.pem"
#define US899_SERVER_CERT_SAN_MATCH	    "US899/cert_san_match.pem"
#define US899_SERVER_KEY_SAN_MATCH	    "US899/key_san_match.pem"
#define US899_SERVER_CERT_SAN_MISMATCH	    "US899/cert_san_mismatch.pem"
#define US899_SERVER_KEY_SAN_MISMATCH	    "US899/key_san_mismatch.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_IP   "US899/cert_san_mismatch_ip.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_IP    "US899/key_san_mismatch_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_IP      "US899/cert_san_match_ip.pem"
#define US899_SERVER_KEY_SAN_MATCH_IP       "US899/key_san_match_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_WC      "US899/cert_san_match_wc.pem"
#define US899_SERVER_KEY_SAN_MATCH_WC       "US899/key_san_match_wc.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_WC   "US899/cert_san_mismatch_wc.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_WC    "US899/key_san_mismatch_wc.pem"
#else 
#define US899_CACERTS	    "CA\\estCA\\cacert.crt"
#define US899_TRUST_CERTS   "CA\\trustedcerts.crt"
#define US899_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"

#define US899_SERVER_CERT_CN_MISMATCH	    "US899\\cert_cn_mismatch.pem"
#define US899_SERVER_KEY_CN_MISMATCH	    "US899\\key_cn_mismatch.pem"
#define US899_SERVER_CERT_CN_MISMATCH_IP    "US899\\cert_cn_mismatch_ip.pem"
#define US899_SERVER_KEY_CN_MISMATCH_IP	    "US899\\key_cn_mismatch_ip.pem"
#define US899_SERVER_CERT_CN_MATCH_WC       "US899\\cert_cn_match_wc.pem"
#define US899_SERVER_KEY_CN_MATCH_WC	    "US899\\key_cn_match_wc.pem"
#define US899_SERVER_CERT_CN_MISMATCH_WC    "US899\\cert_cn_mismatch_wc.pem"
#define US899_SERVER_KEY_CN_MISMATCH_WC	    "US899\\key_cn_mismatch_wc.pem"
#define US899_SERVER_CERT_SAN_MATCH	    "US899\\cert_san_match.pem"
#define US899_SERVER_KEY_SAN_MATCH	    "US899\\key_san_match.pem"
#define US899_SERVER_CERT_SAN_MISMATCH	    "US899\\cert_san_mismatch.pem"
#define US899_SERVER_KEY_SAN_MISMATCH	    "US899\\key_san_mismatch.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_IP   "US899\\cert_san_mismatch_ip.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_IP    "US899\\key_san_mismatch_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_IP      "US899\\cert_san_match_ip.pem"
#define US899_SERVER_KEY_SAN_MATCH_IP       "US899\\key_san_match_ip.pem"
#define US899_SERVER_CERT_SAN_MATCH_WC      "US899\\cert_san_match_wc.pem"
#define US899_SERVER_KEY_SAN_MATCH_WC       "US899\\key_san_match_wc.pem"
#define US899_SERVER_CERT_SAN_MISMATCH_WC   "US899\\cert_san_mismatch_wc.pem"
#define US899_SERVER_KEY_SAN_MISMATCH_WC    "US899\\key_san_mismatch_wc.pem"

static CRITICAL_SECTION logger_critical_section;  
static void us899_logger_stderr (char *format, va_list l) 
{
    EnterCriticalSection(&logger_critical_section);
	vfprintf(stderr, format, l);
	fflush(stderr);
    LeaveCriticalSection(&logger_critical_section); 
}
#endif 



#define US899_VALID_CSR_PEM "-----BEGIN CERTIFICATE REQUEST-----\nMIIBhDCB7gIBADBFMQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEh\nMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEB\nAQUAA4GNADCBiQKBgQC13wEG36vBY8Mq+uu80SKvkx0ZCt0lc18kaMSDLwML2IRS\n+SaCLEZbjJYeSxwZ9qXy4Rt1vFDRRTL57/lQTgT5kzKI2D2YUZ+Dg6wQqx/4t99S\naCv/lxcUTfIPiaqATUQxeZA+h7Fo0ti9wLSw6AQft9hibYPRJZ6zHa24lXwd7wID\nAQABoAAwDQYJKoZIhvcNAQEFBQADgYEAjwSjLqFAzoPGa4GKn7AEitepVA+3QjXL\n45LSzrVJMW4Jl8Ovm/aPatnFRQYm82rVKb7Sq4Ddo9nDJ9tgZ450oqIWbujUmGEU\nsUUxJSJ3vGXyQy+8NeTy4GmmsNWIwhSKMkqh7YVlBvgkwGoNFuQ8mD90prFmld+J\nhHBZXCaekrE=\n-----END CERTIFICATE REQUEST-----"


/*
 * Note: this array was generated using:  xdd -i req.der req.c
 */
static unsigned char US899_VALID_CSR_DER[] = {
  0x30, 0x82, 0x01, 0xa8, 0x30, 0x82, 0x01, 0x11, 0x02, 0x01, 0x00, 0x30,
  0x68, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
  0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,
  0x02, 0x6e, 0x63, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x07,
  0x0c, 0x03, 0x73, 0x73, 0x73, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55,
  0x04, 0x0a, 0x0c, 0x03, 0x64, 0x64, 0x64, 0x31, 0x0d, 0x30, 0x0b, 0x06,
  0x03, 0x55, 0x04, 0x0b, 0x0c, 0x04, 0x66, 0x6a, 0x6a, 0x64, 0x31, 0x0c,
  0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x03, 0x31, 0x32, 0x37,
  0x31, 0x13, 0x30, 0x11, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
  0x01, 0x09, 0x01, 0x16, 0x04, 0x6e, 0x6f, 0x6e, 0x65, 0x30, 0x81, 0x9f,
  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81,
  0x81, 0x00, 0xb9, 0x9f, 0xdd, 0xd0, 0xa4, 0xdf, 0x06, 0x50, 0xf5, 0x4e,
  0x85, 0x80, 0xeb, 0x2a, 0x1e, 0xff, 0x3c, 0x0f, 0x0d, 0x98, 0x6e, 0xfe,
  0x08, 0x74, 0xf4, 0xce, 0xf5, 0xfd, 0xf9, 0x2f, 0x86, 0x20, 0xf7, 0xcc,
  0x08, 0x05, 0xce, 0x98, 0x69, 0x5c, 0x8c, 0xbd, 0x20, 0xa7, 0x28, 0xf7,
  0xe4, 0x22, 0xfa, 0xaf, 0xe4, 0x15, 0xc4, 0xb9, 0x85, 0xcb, 0x0f, 0x11,
  0xc6, 0x55, 0x0d, 0x31, 0x5c, 0xfb, 0x5e, 0xcf, 0x8e, 0xd1, 0xde, 0x77,
  0x15, 0x2c, 0x8c, 0x4e, 0x88, 0x4e, 0x21, 0xb6, 0x69, 0x9c, 0xa7, 0x7d,
  0x06, 0xc5, 0x75, 0x3f, 0xdc, 0x18, 0xf6, 0x00, 0x51, 0xd5, 0x00, 0x47,
  0x62, 0xfc, 0x95, 0xc8, 0xd4, 0xef, 0x31, 0x4a, 0xb0, 0x15, 0xa9, 0x50,
  0x04, 0x6e, 0x13, 0x14, 0xd4, 0xbb, 0x56, 0x22, 0x6f, 0x3b, 0x91, 0xb6,
  0xeb, 0xba, 0x25, 0x8f, 0x12, 0xea, 0xfd, 0xd4, 0xd0, 0x6d, 0x02, 0x03,
  0x01, 0x00, 0x01, 0xa0, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,
  0x3b, 0xa5, 0xb4, 0x97, 0x6c, 0xea, 0xe4, 0x9f, 0xeb, 0x56, 0xca, 0x7a,
  0x7f, 0xfa, 0x53, 0x8d, 0xee, 0x6f, 0x7e, 0xa1, 0x08, 0x65, 0xe0, 0x05,
  0x5b, 0x0e, 0x5a, 0x92, 0xdb, 0x3c, 0xc5, 0x6d, 0x0d, 0xcd, 0x2c, 0xcd,
  0x4d, 0x10, 0x2a, 0x92, 0x78, 0x1d, 0xfb, 0x92, 0x66, 0x33, 0x18, 0xdd,
  0xf8, 0x78, 0xc5, 0x1a, 0x03, 0xf9, 0x58, 0x9f, 0x32, 0x49, 0xde, 0xd2,
  0x26, 0x78, 0x80, 0x87, 0x18, 0xf3, 0x6d, 0xc3, 0x35, 0x5d, 0x21, 0x8b,
  0x4c, 0x8c, 0x87, 0xef, 0xb1, 0xfc, 0x2c, 0xec, 0xdb, 0xd6, 0x00, 0xe5,
  0x21, 0xfa, 0x34, 0x5a, 0x3c, 0xc3, 0x82, 0x52, 0x6f, 0x81, 0x2a, 0x05,
  0xcc, 0xdc, 0x8a, 0x51, 0xf6, 0x65, 0x1d, 0xc5, 0x64, 0x86, 0xc1, 0x28,
  0xf5, 0x0c, 0x8f, 0x09, 0xd4, 0x84, 0x8f, 0x69, 0x04, 0x24, 0x65, 0xf4,
  0x47, 0x6c, 0x90, 0x57, 0x3c, 0x04, 0x4d, 0x52
};
static unsigned int US899_VALID_CSR_DER_LEN = 428;
#if 0
//Leaving this in for now, we may need this for some test cases
static FILE *outfile;
static size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr,size,nmemb,outfile);
    return written;
}
#endif

static void us899_clean (void)
{
}

static int us899_start_server (int manual_enroll, int nid)
{
    int rv;

    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERTKEY,
	          US899_SERVER_CERTKEY,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  manual_enroll,
		  0,
		  nid);
    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us899_init_suite (void)
{
    int rv;

#ifdef WIN32
    InitializeCriticalSection (&logger_critical_section);
    est_init_logger(EST_LOG_LVL_INFO, &us899_logger_stderr);
#endif

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US899_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
	return 1;
    }

    us899_clean();

    /*
     * Start an instance of the EST server with 
     * automatic enrollment enabled.
     */
    rv = us899_start_server(0, 0);

    return rv;
}


/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us899_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}


/*
 * Callback function passed to est_client_init()
 */
static int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)
{
    BIO *bio_err;
    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
    int approve = 0; 
    
    /*
     * Print out the specifics of this cert
     */
    printf("%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\n",
           __FUNCTION__, openssl_cert_error,
           X509_verify_cert_error_string(openssl_cert_error));
    
    printf("Failing Cert:\n");
    X509_print_fp(stdout,cur_cert);
    /*
     * Next call prints out the signature which can be used as the fingerprint
     * This fingerprint can be checked against the anticipated value to determine
     * whether or not the server's cert should be approved.
     */
    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);

    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {
        approve = 1;
    }    

    BIO_free(bio_err);
    
    return approve;
}    


static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);    

    pkey = EVP_PKEY_new();
    if (pkey==NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }        
    
    RSA_free(rsa);
    BN_free(bn);
    
    return (pkey);
}

static int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, char *cn)
{
    X509_NAME *subj;

    /* setup version number */
    if (!X509_REQ_set_version(req, 0L)) {
	printf("\nUnable to set X509 version#\n");
        return (-1);
    }

    /*
     * Add Common Name entry
     */
    subj = X509_REQ_get_subject_name(req);
    if (!X509_NAME_add_entry_by_txt(subj, "CN", MBSTRING_ASC,
                                    (unsigned char*)cn, -1, -1, 0)) {
	printf("\nUnable to create X509 Common Name entry\n");
        return (-1);
    }

    /*
     * Set the public key on the request
     */
    if (!X509_REQ_set_pubkey(req, pkey)) {
	printf("\nUnable to set X509 public key\n");
        return (-1);
    }

    return (0);
}

/*
 * Sign an X509 certificate request using the digest and the key passed.
 * Returns OpenSSL error code from X509_REQ_sign_ctx();
 */
static int sign_X509_req (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
    int rv;
    EVP_PKEY_CTX *pkctx = NULL;
    EVP_MD_CTX mctx;

    EVP_MD_CTX_init(&mctx);

    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {
        return 0;
    }

    /*
     * Encode using DER (ASN.1) 
     *
     * We have to set the modified flag on the X509_REQ because
     * OpenSSL keeps a cached copy of the DER encoded data in some
     * cases.  Setting this flag tells OpenSSL to run the ASN
     * encoding again rather than using the cached copy.
     */
    x->req_info->enc.modified = 1; 
    rv = X509_REQ_sign_ctx(x, &mctx);

    EVP_MD_CTX_cleanup(&mctx);

    return (rv);
}

/*
 * This function performs a basic simple enroll using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variety of test cases in this module.
 */
static void us899_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *attr_data = NULL;
    int attr_len;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);
    CU_ASSERT(rv == expected_enroll_rv);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
}


/*
 * Simple enroll -  
 *
 * This is a basic test to perform a /simpleenroll using a 
 * user ID and password to identify the client to the server. 
 * No identity certificate is used by the client.
 */
static void us899_test1 (void) 
{
    LOG_FUNC_NM;

    us899_simple_enroll("TC899-1", US899_SERVER_IP, EST_ERR_NONE); 
}


/*
 * Simple enroll CSR  
 *
 * This is a basic test to perform a /simpleenroll using a 
 * user ID and password to identify the client to the server. 
 * No identity certificate is used by the client.
 * This test case uses the alternate enroll method where the CSR
 * is provided by the application layer rather than having libest
 * generate the CSR.
 */
static void us899_test2 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    X509_REQ *csr;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Generate a CSR
     */
    csr = X509_REQ_new();
    CU_ASSERT(csr != NULL);
    rv = populate_x509_csr(csr, key, "US899-TC2");

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the alternate API to enroll an existing CSR
     */
    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    X509_REQ_free(csr);
    EVP_PKEY_free(key);
    if (new_cert) {
        free(new_cert);
    }
    est_destroy(ectx);
}

/*
 * Simple enroll CSR - Null 
 *
 * This is a basic test to perform a /simpleenroll using a 
 * user ID and password to identify the client to the server. 
 * No identity certificate is used by the client.
 * This test case uses the alternate enroll method where the CSR
 * is provided by the application layer rather than having libest
 * generate the CSR.  It attempts to pass in null CSR, which should
 * fail.
 */
static void us899_test3 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Use the alternate API to enroll a null CSR
     */
    rv = est_client_enroll_csr(ectx, NULL, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NO_CSR);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 * Simple enroll CSR - corrupted  
 *
 * This test checks the X509_REQ helper function is working proplery.
 */
static void us899_test4 (void) 
{
    X509_REQ *csr;
    unsigned char badreq[14] = "bogus request";

    LOG_FUNC_NM;

    /*
     * First try PEM decoding 
     */
    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_PEM);
    CU_ASSERT(csr == NULL);

    /*
     * Next try DER decoding 
     */
    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_DER);
    CU_ASSERT(csr == NULL);

    /*
     * Next try an invalid format
     */
    csr = est_read_x509_request(badreq, 13, 999);
    CU_ASSERT(csr == NULL);

    /*
     * Next try an invalid csr length
     */
    csr = est_read_x509_request(badreq, 999999, EST_CERT_FORMAT_PEM);
    CU_ASSERT(csr == NULL);

    /*
     * Next try a valid PEM encoded csr
     */
    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_PEM, strlen(US899_VALID_CSR_PEM), 
	                         EST_CERT_FORMAT_PEM);
    CU_ASSERT(csr != NULL);
    if (csr) {
	X509_REQ_free(csr);
    }

    /*
     * Next try a valid DER encoded csr
     */
    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_DER, US899_VALID_CSR_DER_LEN, 
	                         EST_CERT_FORMAT_DER);
    CU_ASSERT(csr != NULL);
    if (csr) {
	X509_REQ_free(csr);
    }
}

//C. Attempt to enroll a newly created CSR that's already been signed 
//   via est_client_enroll_csr
static void us899_test5 (void) 
{
    EST_CTX *ectx;
    EVP_PKEY *key;
    int rv;
    int pkcs7_len = 0;
    X509_REQ *csr;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM,
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * Generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Generate a new CSR
     */
    csr = X509_REQ_new();
    CU_ASSERT(csr != NULL);
    rv = populate_x509_csr(csr, key, "US899-TC5");
    CU_ASSERT(csr != NULL);

    /*
     * Sign the CSR
     */

    rv = sign_X509_req(csr,key,EVP_sha256()); 

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the alternate API to enroll an existing CSR.  This should pass.
     */
    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Cleanup
     */
    X509_REQ_free(csr);
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 * Simple enroll - FQDN mismatch hostname in CN 
 *
 * This test confirms that a mismatched host name on
 * the server cert CN will result in an auth failure
 * at the TLS layer on the client side.
 */
static void us899_test6 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MISMATCH,
	          US899_SERVER_KEY_CN_MISMATCH,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-6", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); 

}

/*
 * Simple enroll - FQDN mismatch IPv4 address in CN 
 *
 * This test confirms that a mismatched IP address in
 * the server cert CN will result in an auth failure
 * at the TLS layer on the client side.
 * Note: this test may be redundant since the IP address
 *       matching logic only occurs when the dNSName is 
 *       used instead of the CommonName.
 */
static void us899_test7 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MISMATCH_IP,
	          US899_SERVER_KEY_CN_MISMATCH_IP,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-7", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); 

}

/*
 * Simple enroll - FQDN matched wildcard in CN 
 *
 * This test confirms that wildcard matching logic
 * in the CN is working. The cert uses a wildcard
 * pattern of *.cisco.com with a server address
 * of localhost.cisco.com.
 */
static void us899_test8 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MATCH_WC,
	          US899_SERVER_KEY_CN_MATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-8", "localhost.cisco.com", EST_ERR_NONE); 

}

/*
 * Simple enroll - FQDN mismatched wildcard in CN 
 *
 * This test confirms that wildcard matching logic
 * in the CN is working. The cert uses a wildcard
 * pattern of *.google.com with a server address
 * of localhost.cisco.com.
 */
static void us899_test9 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_CN_MISMATCH_WC,
	          US899_SERVER_KEY_CN_MISMATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-9", "localhost.cisco.com", EST_ERR_FQDN_MISMATCH); 
}

/*
 * Simple enroll - FQDN matched hostname in SubjectAltName 
 *
 * This test confirms that a matched host name on
 * the server cert SubjectAltName ext will result in an auth success. 
 */
static void us899_test10 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MATCH,
	          US899_SERVER_KEY_SAN_MATCH,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-10", "localhost.cisco.com", EST_ERR_NONE); 
}

/*
 * Simple enroll - FQDN mismatched hostname in SubjectAltName 
 *
 * This test confirms that a mismatched host name on
 * the server cert SubjectAltName ext will result in an auth failure. 
 */
static void us899_test11 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MISMATCH,
	          US899_SERVER_KEY_SAN_MISMATCH,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-11", "localhost.cisco.com", EST_ERR_FQDN_MISMATCH); 
}

/*
 * Simple enroll - FQDN mismatched IPv4 address in SubjectAltName 
 *
 * This test confirms that a mismatched IPv4 address on
 * the server cert SubjectAltName ext will result in an auth failure. 
 */
static void us899_test12 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MISMATCH_IP,
	          US899_SERVER_KEY_SAN_MISMATCH_IP,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-12", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); 
}

/*
 * Simple enroll - FQDN matched IPv4 address in SubjectAltName 
 *
 * This test confirms that a matched IPv4 address on
 * the server cert SubjectAltName ext will result in an auth success. 
 */
static void us899_test13 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MATCH_IP,
	          US899_SERVER_KEY_SAN_MATCH_IP,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-13", US899_SERVER_IP, EST_ERR_NONE); 
}

/*
 * Simple enroll - FQDN matched hostname in SubjectAltName with wildcard 
 *
 * This test confirms that a hostname matches a wildcard pattern in
 * the server cert SubjectAltName ext, which will result in an auth success. 
 */
static void us899_test14 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MATCH_WC,
	          US899_SERVER_KEY_SAN_MATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-14", "localhost.cisco.com", EST_ERR_NONE); 
}

/*
 * Simple enroll - FQDN mismatched hostname in SubjectAltName with wildcard 
 *
 * This test confirms that a hostname mismatches a wildcard pattern in
 * the server cert SubjectAltName ext, which will result in an auth fail. 
 */
static void us899_test15 (void) 
{
    int rv;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Spin up a new instance of the EST server
     * using a certificate that contains a
     * bogus hostname in the CN
     */
    rv = st_start(US899_SERVER_PORT, 
	          US899_SERVER_CERT_SAN_MISMATCH_WC,
	          US899_SERVER_KEY_SAN_MISMATCH_WC,
	          "US899 test realm",
	          US899_CACERTS,
	          US899_TRUST_CERTS,
	          "CA/estExampleCA.cnf",
		  0, 0, 0);
    CU_ASSERT(rv == 0);
    if (rv) return;

    us899_simple_enroll("TC899-15", "localhost.cisco.com", EST_ERR_FQDN_MISMATCH); 
}


/*
 * Simple enroll - CRL check enabled on client
 *
 * We enable CRL checking on the client side.  We will
 * generate a CRL, but the server cert will not be
 * revoked.  The enroll should succeed.
 */
static void us899_test16 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    unsigned char *new_cert = NULL;
    unsigned char *cacrlcerts = NULL;
    int cacrlcerts_len = 0;
    unsigned char *attr_data = NULL;
    int attr_len;

    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to use a different cert.
     */
    st_stop();

    /*
     * Now that all the FQDN tests are completed, start
     * the normal server.
     */
    rv = us899_start_server(0, 0);
    CU_ASSERT(rv == 0);

    /*
     * Generate a CRL and append it to the CA chain
     * we're using on the client side.
     */
#ifndef WIN32
    system("openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem");
    SLEEP(1);
    system("cat CA/trustedcerts.crt > US899/test16trust.crt");
    SLEEP(1);
    system("cat US899/test16_crl.pem >> US899/test16trust.crt");
    SLEEP(1);
#else
    system("openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem");
    SLEEP(1);
    system("type CA\\trustedcerts.crt > US899\\test16trust.crt");
    SLEEP(1);
    system("type US899\\test16_crl.pem >> US899\\test16trust.crt");
    SLEEP(1);
#endif 

    /*
     * Read in the CA certificates
     */
    cacrlcerts_len = read_binary_file("US899/test16trust.crt", &cacrlcerts);
    CU_ASSERT(cacrlcerts > 0);
    if (cacrlcerts_len <= 0) {
	return;
    }

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacrlcerts, cacrlcerts_len, 
                           EST_CERT_FORMAT_PEM, 
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Enable CRL checking on the client
     */
    rv = est_enable_crl(ectx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TEST16-CN", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
	new_cert = malloc(pkcs7_len);
	CU_ASSERT(new_cert != NULL);
	rv = est_client_copy_enrolled_cert(ectx, new_cert);
	CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    if (new_cert) free(new_cert);
    est_destroy(ectx);
    free(cacrlcerts);
}

/*
 * Simple enroll - CRL check enabled on client
 *
 * We enable CRL checking on the client side.  We will
 * generate a CRL, the server cert will  be
 * revoked.  The enroll should fail.
 */
static void us899_test17 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    unsigned char *cacrlcerts = NULL;
    int cacrlcerts_len = 0;
    unsigned char *attr_data = NULL;
    int attr_len;
    
    LOG_FUNC_NM;

    /*
     * Revoke the server cert, generate a CRL and append it to the CA chain
     * we're using on the client side.
     */
#ifndef WIN32
    system("cp CA/estCA/index.txt CA/estCA/index.txt.save");
    SLEEP(1);
    system("openssl ca -config CA/estExampleCA.cnf -revoke CA/estCA/private/estservercertandkey.pem");
    SLEEP(1);
    system("openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test17_crl.pem");
    SLEEP(1);
    system("cat CA/trustedcerts.crt > US899/test17trust.crt");
    SLEEP(1);
    system("cat US899/test17_crl.pem >> US899/test17trust.crt");
    SLEEP(1);
    system("cp CA/estCA/index.txt.save CA/estCA/index.txt");
    SLEEP(1);
#else 
    system("copy CA\\estCA\\index.txt CA\\estCA\\index.txt.save");
    SLEEP(1);
    system("openssl ca -config CA\\estExampleCA.cnf -revoke CA\\estCA\\private\\estservercertandkey.pem");
	SLEEP(1); 
    system("openssl ca -config CA\\estExampleCA.cnf -gencrl -out US899\\test17_crl.pem");
    SLEEP(1);
    system("type CA\\trustedcerts.crt > US899\\test17trust.crt");
    SLEEP(1);
    system("type US899\\test17_crl.pem >> US899\\test17trust.crt");
    SLEEP(1);
    system("copy CA\\estCA\\index.txt.save CA\\estCA\\index.txt");
    SLEEP(1);
#endif 

    /*
     * Read in the CA certificates
     */
    cacrlcerts_len = read_binary_file("US899/test17trust.crt", &cacrlcerts);
    CU_ASSERT(cacrlcerts > 0);
    if (cacrlcerts_len <= 0) {
	return;
    }

    /*
     * Create a client context 
     */
    ectx = est_client_init(cacrlcerts, cacrlcerts_len, 
                           EST_CERT_FORMAT_PEM, 
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Enable CRL checking on the client
     */
    rv = est_enable_crl(ectx);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TEST17-CN", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);

    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
    free(cacrlcerts);
}

/*
 * Simple enroll - Receive Retry-After response 
 *
 * Client issues an Enroll request and receives
 * a Retry-After response.  Ensure that the
 * retry after value can be obtained from the client.
 */
static void us899_test18 (void) 
{
    int rv;
    EST_CTX *ectx;
    EVP_PKEY *key;
    int pkcs7_len = 0;
    int delay_secs = 0;
    time_t retry_date = 0;
    unsigned char *attr_data = NULL;
    int attr_len;
    
    LOG_FUNC_NM;

    /*
     * Stop the existing server.  This test case needs
     * the server to go into manual enroll mode
     */
    st_stop();

    /*
     * Start the server up in manual enroll mode
     */
    rv = us899_start_server(1, 0);
    CU_ASSERT(rv == 0);    

    /*
     * Create a client context using the default CA certs
     */
    ectx = est_client_init(cacerts, cacerts_len, 
                           EST_CERT_FORMAT_PEM, 
                           client_manual_cert_verify);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);

    /*
     * generate a private key
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Get the latest CSR attributes
     */
    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Use the simplified API to enroll a CSR
     */
    rv = est_client_enroll(ectx, "TEST18-CN", &pkcs7_len, key);
    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);

    if (rv == EST_ERR_CA_ENROLL_RETRY) {
        /*
         * go get the retry duration
         * make sure it's set to the default value
         */
        rv = est_client_copy_retry_after(ectx, &delay_secs, &retry_date);
        CU_ASSERT(rv == EST_ERR_NONE);
        CU_ASSERT(delay_secs == 3600);
    }
    
    /*
     * Cleanup
     */
    EVP_PKEY_free(key);
    est_destroy(ectx);
}

//TO DO
//
//Auth (HTTP basic auth enabled on server) 
//A. Enroll CSR using valid cert, no UID
//B. Enroll CSR using valid cert, valid UID
//C. Enroll CSR using valid cert, invalid UID
//D. Enroll CSR using invalid cert, no UID
//E. Enroll CSR using invalid cert, valid UID
//F. Enroll CSR using invalid cert, invalid UID
//
//Auth (HTTP digest auth enabled on server) 
//A. Enroll CSR using valid cert, no UID
//B. Enroll CSR using valid cert, valid UID
//C. Enroll CSR using valid cert, invalid UID
//D. Enroll CSR using invalid cert, no UID
//E. Enroll CSR using invalid cert, valid UID
//F. Enroll CSR using invalid cert, invalid UID
//

int us899_add_suite (void)
{
#ifdef HAVE_CUNIT
   CU_pSuite pSuite = NULL;

   /* add a suite to the registry */
   pSuite = CU_add_suite("us899_client_simpenroll", 
	                  us899_init_suite, 
			  us899_destroy_suite);
   if (NULL == pSuite) {
      CU_cleanup_registry();
      return CU_get_error();
   }

   /* 
    * Add the tests to the suite 
    *
    * ********************IMPORTANT*********************
    * Do not change the order of these tests.
    * Some of the tests stop the EST server and restart
    * it using different certs.  If you change the order
    * then false negatives may occur.
    * **************************************************
    *
    */
   if ((NULL == CU_add_test(pSuite, "Simple enroll", us899_test1)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll CSR", us899_test2)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll null CSR", us899_test3)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll corrupted CSR", us899_test4)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll signed CSR", us899_test5)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - hostname mismatch FQDN CN", us899_test6)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - IPv4 mismatch FQDN CN", us899_test7)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard match FQDN CN", us899_test8)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard mismatch FQDN CN", us899_test9)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - hostname match FQDN SAN", us899_test10)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - hostname mismatch FQDN SAN", us899_test11)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - IPv4 mismatch FQDN SAN", us899_test12)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - IPv4 match FQDN SAN", us899_test13)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard match FQDN SAN", us899_test14)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - wildcard mismatch FQDN SAN", us899_test15)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - CRL enabled, valid server cert", us899_test16)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - CRL enabled, revoked server cert", us899_test17)) ||
       (NULL == CU_add_test(pSuite, "Simple enroll - Retry-After received", us899_test18)))
   {
      CU_cleanup_registry();
      return CU_get_error();
   }

   return CUE_SUCCESS;
#endif
}



/*------------------------------------------------------------------
 * us1005.c - Unit Tests for User Story 1005 - Client easy provision
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#include <string.h>
#ifndef WIN32
#include <unistd.h>
#endif 
#include <est.h>
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>
#include <openssl/x509v3.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#ifdef WIN32
static CRITICAL_SECTION logger_critical_section;
#endif 

static unsigned char *cacerts = NULL;
static int cacerts_len = 0;

#define US1005_SERVER_PORT      31005
#define US1005_SERVER_IP    "127.0.0.1" 
#define US1005_UID          "estuser"
#define US1005_PWD          "estpwd"
#ifndef WIN32
#define US1005_CACERTS          "CA/estCA/cacert.crt"
#define US1005_TRUST_CERTS      "CA/trustedcerts.crt"
#define US1005_SERVER_CERTKEY   "CA/estCA/private/estservercertandkey.pem"
#define US1005_CLIENT_KEY       "US1005/implicit-key.pem"
#define US1005_CLIENT_CERT      "US1005/implicit-cert.pem"
#else
#define US1005_CACERTS          "CA\\estCA\\cacert.crt"
#define US1005_TRUST_CERTS      "CA\\trustedcerts.crt"
#define US1005_SERVER_CERTKEY   "CA\\estCA\\private\\estservercertandkey.pem"
#define US1005_CLIENT_KEY       "US1005\\implicit-key.pem"
#define US1005_CLIENT_CERT      "US1005\\implicit-cert.pem"
#endif 
#define US1005_CSR_NOPOP        "MBQGBysGAQEBARYGCWCGSAFlAwQCAg==\0"

static char *log_search_target = NULL;
static int search_target_found = 0;
/*
 * This is a simple callback used to override the default
 * logging facility in libest.  We'll use this to look
 * for specific debug output.
 */
static void us1005_logger_stderr (char *format, va_list l)
{
    char t_log[1024];
#ifndef WIN32
    flockfile(stderr);
#else
    EnterCriticalSection(&logger_critical_section);
#endif 
    if (log_search_target) {
        vsnprintf(t_log, 1024, format, l);
        if (strstr(t_log, log_search_target)) {
            search_target_found = 1;
        }
        fprintf(stderr, "%s", t_log);
    } else {
        vfprintf(stderr, format, l);
    }
    fflush(stderr);
#ifndef WIN32
    funlockfile(stderr);
#else
    LeaveCriticalSection(&logger_critical_section);
#endif 
}

static void us1005_clean (void)
{
}

static int us1005_start_server (int manual_enroll, int nid, int no_http_auth,
                                int enable_pop)
{
    int rv;

    rv = st_start(US1005_SERVER_PORT,
                  US1005_SERVER_CERTKEY,
                  US1005_SERVER_CERTKEY,
                  "US1005 test realm",
                  US1005_CACERTS,
                  US1005_TRUST_CERTS,
                  "CA/estExampleCA.cnf",
                  manual_enroll,
                  enable_pop,
                  nid);

    if (no_http_auth) {
        st_disable_http_auth();
    }

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us1005_init_suite (void)
{
    int rv;

#ifdef WIN32
    /* Initialize critical section on Windows*/
    InitializeCriticalSection(&logger_critical_section);
#endif 

    est_init_logger(EST_LOG_LVL_INFO, &us1005_logger_stderr);

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US1005_CACERTS, &cacerts);
    if (cacerts_len <= 0) {
        return 1;
    }

    us1005_clean();

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us1005_start_server(0, 0, 0, 0);

    return rv;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us1005_destroy_suite (void)
{
    st_stop();
    free(cacerts);
    return 0;
}

static EVP_PKEY * generate_private_key (void)
{
    RSA *rsa = RSA_new();
    BIGNUM *bn = BN_new();
    EVP_PKEY *pkey;

    /*
     * create an RSA keypair and assign them to a PKEY and return it.
     */
    BN_set_word(bn, 0x10001);
    RSA_generate_key_ex(rsa, 1024, bn, NULL);

    pkey = EVP_PKEY_new();
    if (pkey == NULL) {
        printf("\nError allocating PKEY structure for new key pair\n");
        return NULL;
    }
    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {
        printf("\nError assigning RSA key pair to PKEY structure\n");
        return NULL;
    }

    RSA_free(rsa);
    BN_free(bn);

    return (pkey);
}

/*
 * This function performs the easy provision operation using
 * a UID/PWD to identify the client to the server.  This
 * is used for a variety of test cases in this module.
 */
static void us1005_easy_provision (char *cn, char *server, int ba_hint,
                                   int use_cert)
{
    EST_CTX *ectx;
    EVP_PKEY *new_key;
    int rv;
    int pkcs7_len = 0;
    int ca_certs_len = 0;
    unsigned char *new_cert = NULL;
    EVP_PKEY *key = NULL;
    unsigned char *key_raw;
    int key_len;
    unsigned char *cert_raw;
    int cert_len;
    X509 *cert = NULL;
    BIO *in;

    /*
     * Create a client context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    if (use_cert) {
        /*
         * Read in the private key
         */
        key_len = read_binary_file(US1005_CLIENT_KEY, &key_raw);
        CU_ASSERT(key_len > 0);
        key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);
        CU_ASSERT(key != NULL);
        free(key_raw);

        /*
         * Read in the old cert
         */
        cert_len = read_binary_file(US1005_CLIENT_CERT, &cert_raw);
        CU_ASSERT(cert_len > 0);
        in = BIO_new_mem_buf(cert_raw, cert_len);
        CU_ASSERT(in != NULL);
        if (!in)
            return;
        cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);
        CU_ASSERT(cert != NULL);
        if (!cert)
            return;
        BIO_free_all(in);
        free(cert_raw);
    }

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, cert, key);
    CU_ASSERT(rv == EST_ERR_NONE);

    if (ba_hint) {
        rv = est_client_enable_basic_auth_hint(ectx);
        CU_ASSERT(rv == EST_ERR_NONE);
    }

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, server, US1005_SERVER_PORT, NULL);

    /*
     * generate a new private key
     */
    new_key = generate_private_key();
    CU_ASSERT(new_key != NULL);

    /*
     * Attempt to provision a new cert
     */
    rv = est_client_provision_cert(ectx, cn, &pkcs7_len, &ca_certs_len,
        new_key);
    CU_ASSERT(rv == EST_ERR_NONE);
    EVP_PKEY_free(new_key);

    /*
     * Retrieve the cert that was given to us by the EST server
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(pkcs7_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_enrolled_cert(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
        if (new_cert)
            free(new_cert);
    } else {
        est_destroy(ectx);
        return;
    }

    /*
     * Retrieve a copy of the new CA certs
     */
    if (rv == EST_ERR_NONE) {
        new_cert = malloc(ca_certs_len);
        CU_ASSERT(new_cert != NULL);
        rv = est_client_copy_cacerts(ectx, new_cert);
        CU_ASSERT(rv == EST_ERR_NONE);
        if (new_cert)
            free(new_cert);
    } else {
        est_destroy(ectx);
        return;
    }

    EVP_PKEY_free(key);
    X509_free(cert);

    /*
     * Cleanup
     */
    est_destroy(ectx);
}

/*
 * Easy provision - HTTP basic auth, no client cert
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test1 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-1", US1005_SERVER_IP, 0, 0);
}

/*
 * Easy provision - with HTTP basic auth hint enabled, no client cert
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test2 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-2", US1005_SERVER_IP, 1, 0);
}

/*
 * Easy provision - client cert with HTTP basic auth enabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test3 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-3", US1005_SERVER_IP, 0, 1);
}

/*
 * Easy provision - client cert with HTTP basic auth hint enabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test4 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-4", US1005_SERVER_IP, 1, 1);
}

/*
 * Null pointers test
 */
static void us1005_test5 (void)
{
    int p7len = 0;
    int calen = 0;
    EVP_PKEY *key;
    int rv;
    EST_CTX *ectx;

    LOG_FUNC_NM
    ;

    /*
     * Create a valid context
     */
    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);
    CU_ASSERT(ectx != NULL);

    /*
     * Set the authentication mode to use a user id/password
     */
    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, NULL, NULL);
    CU_ASSERT(rv == EST_ERR_NONE);

    /*
     * Set the EST server address/port
     */
    est_client_set_server(ectx, US1005_SERVER_IP, US1005_SERVER_PORT, NULL);

    /*
     * Create a valid key pair
     */
    key = generate_private_key();
    CU_ASSERT(key != NULL);

    /*
     * Try with a NULL context
     */
    rv = est_client_provision_cert(NULL, "TEST2", &p7len, &calen, key);
    CU_ASSERT(rv == EST_ERR_NO_CTX);

    /*
     * Try with a NULL p7 length
     */
    rv = est_client_provision_cert(ectx, "TEST2", NULL, &calen, key);
    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);

    /*
     * Try with a NULL cacerts length
     */
    rv = est_client_provision_cert(ectx, "TEST2", &p7len, NULL, key);
    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);

    /*
     * Try with a NULL key
     */
    rv = est_client_provision_cert(ectx, "TEST2", &p7len, &calen, NULL);
    CU_ASSERT(rv == EST_ERR_NO_KEY);

    EVP_PKEY_free(key);
    est_destroy(ectx);
}

/*
 *  Enable pop on server, enable CSR attributes on server w/o challengePassword OID
 */
static void us1005_test6 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP enabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 1);

    /*
     * Set the CSR attributes to a value that doesn't include challengePassword OID
     */
    st_set_csrattrs(US1005_CSR_NOPOP);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-6", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Disable pop on server, enable CSR attributes on server w/o challengePassword OID
 */
static void us1005_test7 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP disabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 0);

    /*
     * Set the CSR attributes to a value that doesn't include challengePassword OID
     */
    st_set_csrattrs(US1005_CSR_NOPOP);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Cert request does not contain PoP\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-7", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Enable pop on server, enable CSR attributes on server w/ challengePassword OID
 */
static void us1005_test8 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP enabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 1);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-8", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Disable pop on server, enable CSR attributes on server w/challengePassword OID
 */
static void us1005_test9 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP disabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 0);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-9", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Enable pop on server, disable CSR attributes on server
 */
static void us1005_test10 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP enabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 1);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);
    st_disable_csr_cb();

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Client will include challengePassword in CSR\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-10", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

/*
 *  Disable pop on server, disable CSR attributes on server
 */
static void us1005_test11 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with PoP disabled
     */
    st_stop();
    us1005_start_server(0, 0, 0, 0);

    /*
     * Set the CSR attributes to the default value, which includes challengePassword OID
     */
    st_set_csrattrs(NULL);
    st_disable_csr_cb();

    /*
     * We will search the debugs for the appropriate output
     * to confirm the PoP behavior is working as desired.
     */
    log_search_target = "Cert request does not contain PoP\0";
    search_target_found = 0;

    /*
     * Provision a new cert
     */
    us1005_easy_provision("TC1005-11", US1005_SERVER_IP, 0, 0);

    CU_ASSERT(search_target_found == 1);

    /*
     * Set the CSR attributes back to default value
     */
    st_set_csrattrs(NULL);
}

//
// The next two test caes repeate tests 3 & 4 but with
// HTTP auth disabled on the server.
//

/*
 * Easy provision - client cert with HTTP basic auth disabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test93 (void)
{
    LOG_FUNC_NM
    ;

    /*
     * Restart the server with HTTP auth disabled
     */
    st_stop();
    us1005_start_server(0, 0, 1, 0);

    us1005_easy_provision("TC1005-93", US1005_SERVER_IP, 0, 1);
}

/*
 * Easy provision - client cert with HTTP basic auth hint enabled
 *
 * This is a basic test to perform a a full trusted enroll
 * sequence of /cacerts, /csrattrs, and /simpleenroll using a
 * user ID and password to identify the client to the server.
 * No identity certificate is used by the client.
 */
static void us1005_test94 (void)
{
    LOG_FUNC_NM
    ;

    us1005_easy_provision("TC1005-94", US1005_SERVER_IP, 1, 1);
}

int us1005_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us1005_client_easy_provision",
            us1005_init_suite,
            us1005_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /*
     * Add the tests to the suite
     *
     * ********************IMPORTANT*********************
     * Do not change the order of these tests.
     * Some of the tests stop the EST server and restart
     * it using different certs.  If you change the order
     * then false negatives may occur.
     * **************************************************
     *
     */
    if ((NULL == CU_add_test(pSuite, "Easy provision - no cert", us1005_test1)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - no cert HTTP BA hint", us1005_test2)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert", us1005_test3)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert HTTP BA hint", us1005_test4)) ||
        (NULL == CU_add_test(pSuite, "Null pointers", us1005_test5)) ||
        (NULL == CU_add_test(pSuite, "Enable PoP - no challengePassword", us1005_test6)) ||
        (NULL == CU_add_test(pSuite, "Disable PoP - no challengePassword", us1005_test7)) ||
        (NULL == CU_add_test(pSuite, "Enable PoP - w/challengePassword", us1005_test8)) ||
        (NULL == CU_add_test(pSuite, "Disable PoP - w/challengePassword", us1005_test9)) ||
        (NULL == CU_add_test(pSuite, "Enable PoP - CSR disabled", us1005_test10)) ||
        (NULL == CU_add_test(pSuite, "Disable PoP - CSR disabled", us1005_test11)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert no server auth", us1005_test93)) ||
        (NULL == CU_add_test(pSuite, "Easy provision - w/cert HTTP BA hint no server auth", us1005_test94)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us901.c - Unit Tests for User Story 901 - Server cacerts
 *
 * June, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include "st_server.h"
#include <openssl/ssl.h>

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US901_PKCS10_REQ    "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"
#define US901_ENROLL_URL "https://127.0.0.1:29901/.well-known/est/simpleenroll"
#define US901_CACERT_URL "https://127.0.0.1:29901/.well-known/est/cacerts"
#define US901_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US901_UIDPWD_GOOD   "estuser:estpwd"
#define US901_UIDPWD_BAD    "estuser:bogus"
#define US901_SERVER_PORT 29901
#ifndef WIN32
#define US901_CACERTS       "CA/estCA/cacert.crt"
#define US901_EXPLICIT_CERT "US901/explicit-cert.pem" 
#define US901_EXPLICIT_KEY "US901/explicit-key.pem"
#define US901_IMPLICIT_CERT "US901/implicit-cert.pem" 
#define US901_IMPLICIT_KEY "US901/implicit-key.pem"
#define US901_REVOKED_CERT "US901/revoked-cert.pem" 
#define US901_REVOKED_KEY "US901/revoked-key.pem"
#define US901_SELFSIGN_CERT "US901/selfsigned-cert.pem" 
#define US901_SELFSIGN_KEY "US901/selfsigned-key.pem"
#define US901_CACERT "CA/estCA/cacert.crt"
#define US901_EXTCERT "CA/extCA/cacert.crt"
#define US901_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US901_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
#define US901_SERVER_CERTKEY "CA/estCA/private/estservercertandkey.pem"
static char test5_outfile[FILENAME_MAX] = "US901/test5.crt";
#else
#define US901_CACERTS       "CA\\estCA\\cacert.crt"
#define US901_EXPLICIT_CERT "US901\\explicit-cert.pem" 
#define US901_EXPLICIT_KEY "US901\\explicit-key.pem"
#define US901_IMPLICIT_CERT "US901\\implicit-cert.pem" 
#define US901_IMPLICIT_KEY "US901\\implicit-key.pem"
#define US901_REVOKED_CERT "US901\\revoked-cert.pem" 
#define US901_REVOKED_KEY "US901\\revoked-key.pem"
#define US901_SELFSIGN_CERT "US901\\selfsigned-cert.pem" 
#define US901_SELFSIGN_KEY "US901\\selfsigned-key.pem"
#define US901_CACERT "CA\\estCA\\cacert.crt"
#define US901_EXTCERT "CA\\extCA\\cacert.crt"
#define US901_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US901_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US901_SERVER_CERTKEY "CA\\estCA\\private/estservercertandkey.pem"
static char test5_outfile[FILENAME_MAX] = "US901\\test5.crt";
#endif

static void us901_clean(void) {
    char cmd[200];
    sprintf(cmd, "rm %s", test5_outfile);
    system(cmd);
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us901_init_suite(void) {
    us901_clean();

    est_init_logger(EST_LOG_LVL_INFO, NULL);

    return 0;
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us901_destory_suite(void) {
    return 0;
}

/*
 * Start the appropriate flavor of st_server
 * based what character is specified
 * B - Basic auth
 * D - Digest auth
 * C - CRL checking
 * N = No auth
 */
static int us901_start_server(char server_type) {
    int rv;

    switch (server_type) {
    case 'B':
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "CA/trustedcerts.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_enable_http_basic_auth();
        break;
    case 'D':
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "CA/trustedcerts.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_enable_http_digest_auth();
        break;
    case 'C':
        system(
                "openssl ca -config CA/estExampleCA.cnf -gencrl -out CA/estCA/crl.pem");
        SLEEP(1);
        system(
                "cat CA/trustedcerts.crt CA/estCA/crl.pem > US901/trustedcertsandcrl.crt");
        SLEEP(1);
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "US901/trustedcertsandcrl.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_enable_crl();
        st_disable_http_auth();
        break;
    case 'N':
        rv = st_start(US901_SERVER_PORT,
        US901_SERVER_CERTKEY,
        US901_SERVER_CERTKEY, "estrealm", "CA/estCA/cacert.crt",
                "CA/trustedcerts.crt", "CA/estExampleCA.cnf", 0, 0, 0);
        st_disable_http_auth();
        break;
    default:
        rv = -1;
        break;
    }

    return rv;
}

/*
 * HTTP Basic auth
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running and listing to port 8088 prior to this
 * test being run.
 */
static void us901_test1(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('B');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,
    NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    st_stop();
    SLEEP(1);

}

/*
 * HTTP Basic Auth failure
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST server,
 * while using a bogus password.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running prior to this test being run.
 */
static void us901_test2(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('B');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_BASIC,
    NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 400
     */
    CU_ASSERT(rv == 401);

    st_stop();
    SLEEP(1);
}

/*
 * HTTP Digest Auth
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running and listening to port 8087 prior to this
 * test being run.
 */
static void us901_test3(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_DIGEST,
    NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with success
     */
    CU_ASSERT(rv == 200);

    st_stop();
    SLEEP(1);
}

/*
 * HTTP Digest Auth fail
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST server.
 * This is the negative test case for Digest auth.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST server should be
 * running and listening to port 8087 prior to this
 * test being run.
 */
static void us901_test4(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_DIGEST,
    NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 401);
    st_stop();
    SLEEP(1);
}

static FILE *outfile;
static size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata) {
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

/*
 * This test case does a simple cacerts request
 * and looks for the HTTP 200 response code.
 */
static void us901_test5(void) {
    long rv;
    char cmd[200];
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_get(US901_CACERT_URL, US901_CACERTS, &write_func);
    fclose(outfile);

    /*
     * we expect the server to respond with a 200
     */
    CU_ASSERT(rv == 200);

    sprintf(cmd,
            "openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs",
            test5_outfile);
    rv = system(cmd);
    CU_ASSERT(rv == 0);
    st_stop();
    SLEEP(1);
}

static void us901_test_sslversion(const SSL_METHOD *m, int expect_fail) {
    BIO *conn;
    SSL *ssl;
    SSL_CTX *ssl_ctx = NULL;
    int rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    ssl_ctx = SSL_CTX_new(m);
    CU_ASSERT(ssl_ctx != NULL);

    /*
     * Now that the SSL context is ready, open a socket
     * with the server and bind that socket to the context.
     */
    conn = open_tcp_socket_ipv4("127.0.0.1", "29901");
    CU_ASSERT(conn != NULL);

    /*
     * Creaea SSL session context
     */
    ssl = SSL_new(ssl_ctx);
    SSL_set_bio(ssl, conn, conn);

    /*
     * Now that we have everything ready, let's initiate the TLS
     * handshake.
     */
    rv = SSL_connect(ssl);
    if (!expect_fail) {
        CU_ASSERT(rv > 0);
    } else {
        CU_ASSERT(rv <= 0);
    }

    /*
     * Cleanup all the data
     */
    SSL_shutdown(ssl);
    SSL_free(ssl);
    SSL_CTX_free(ssl_ctx);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to create a SSL 3.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us901_test6(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(SSLv3_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us901_test7(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(TLSv1_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.1 connection
 * with the EST server.  This should succeed.
 */
static void us901_test8(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(TLSv1_1_client_method(), 0);
}

/*
 * This test attempts to create a TLS 1.2 connection
 * with the EST server.  This should succeed.
 */
static void us901_test9(void) {
    LOG_FUNC_NM
    ;

    us901_test_sslversion(TLSv1_2_client_method(), 0);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. This should succeed.
 */
static void us901_test10(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('N');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_EXPLICIT_CERT,
    US901_EXPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the implicit cert
 * chain. This should succeed.
 */
static void us901_test11(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('N');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_IMPLICIT_CERT,
    US901_IMPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a revoked client certificate to
 * verify CRL checks are working in the TLS layer.
 * This should fail.
 */
static void us901_test12(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('R');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_REVOKED_CERT,
    US901_REVOKED_KEY,
    US901_CACERTS,
    NULL);

    /*
     * Since the client cert has been revoked the TLS handshake
     * will fail.  The EST server should return a 401 response.
     */
    CU_ASSERT(rv == 0);
    st_stop();
}

/*
 * This test attempts to use a self-signed client certificate to
 * verify cert chain will reject a cert that has not been
 * signed by a valid CA.  This should fail.
 */
static void us901_test13(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_SELFSIGN_CERT,
    US901_SELFSIGN_KEY,
    US901_CACERTS,
    NULL);

    /*
     * Since the client cert is not signed by either the local CA
     * or external CA, the TLS handshake will fail.
     * We will not receive an HTTP status message
     * from the server.
     */
    CU_ASSERT(rv == 0);
    st_stop();
}

/*
 * TLS anonymous cipher suites disabled
 *
 * This test case uses libcurl to test that the
 * EST server will not accept anonymous cipher
 * suites from the client.  We only test a single
 * cipher suite here.  This attempts to do a
 * simple enroll with the server.
 */
static void us901_test14(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC, "ADH-AES128-SHA256", NULL,
            NULL);
    /*
     * TLS handshake should have failed, curl should return 0
     */
    CU_ASSERT(rv == 0);
    st_stop();
    SLEEP(1);
}

/*
 * Null HTTP realm when initializing server
 */
static void us901_test15(void) {
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US901_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL realm
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
            EST_CERT_FORMAT_PEM,
            NULL, x, priv_key);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate when initializing server
 */
static void us901_test16(void) {
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *keyin;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US901_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL server key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
            EST_CERT_FORMAT_PEM, "testrealm", NULL, priv_key);
    CU_ASSERT(ctx == NULL);

    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate private key when initializing server
 */
static void us901_test17(void) {
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin;
    X509 *x;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US901_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Attempt to init EST server using NULL private key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,
            EST_CERT_FORMAT_PEM, "testrealm", x, NULL);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
}

/*
 * Null trusted CA chain when initializing server
 */
static void us901_test18(void) {
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL local CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init(NULL, 0, NULL, 0, EST_CERT_FORMAT_PEM, "testrealm", x,
            priv_key);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Corrupted CA chain when initializing server
 */
static void us901_test19(void) {
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY *priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US901_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US901_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server a corrupted CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_server_init((unsigned char*) "Bogus CA chain", 14,
            (unsigned char*) "Bogus CA chain", 14, EST_CERT_FORMAT_PEM,
            "testrealm", x, priv_key);
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * This test case attempts simple cacerts request using
 * POST instead of GET.  It should fail.
 */
static void us901_test20(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US901_CACERT_URL, US901_PKCS10_CT, US901_PKCS10_REQ,
    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,
    NULL, NULL, NULL);
    fclose(outfile);

    /*
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 400);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Valid HTTP authentication credentials are
 * also provided.  This should succeed.
 */
static void us901_test21(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('B');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_UIDPWD_GOOD,
    US901_EXPLICIT_CERT,
    US901_EXPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Invalid HTTP authentication credentials are
 * also provided.  This should fail with a 401 response.
 */
static void us901_test22(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('D');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_UIDPWD_BAD,
    US901_EXPLICIT_CERT,
    US901_EXPLICIT_KEY,
    US901_CACERTS,
    NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);
    st_stop();
    SLEEP(1);
}

/*
 * This test attempts to enroll without using a certificate
 * to identity the client, while using a good user ID/pwd.
 * However, the EST server is setup to only perform
 * certificate authentication (HTTP auth disabled).
 * This should fail with a 401 response.
 */
static void us901_test23(void) {
    long rv;
    int st_rv;

    st_rv = us901_start_server('N');
    if (st_rv) {
        return;
    }

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US901_ENROLL_URL,
    US901_PKCS10_CT,
    US901_PKCS10_REQ,
    US901_UIDPWD_GOOD,
    US901_CACERTS,
    CURLAUTH_BASIC,
    NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);
    st_stop();
    SLEEP(1);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us901_add_suite(void) {
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us901_srv_cacerts",
            us901_init_suite,
            us901_destory_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* add the tests to the suite */
    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
    if ((NULL == CU_add_test(pSuite, "HTTP Basic Auth", us901_test1)) ||
            (NULL == CU_add_test(pSuite, "HTTP Basic Auth Fail", us901_test2)) ||
            (NULL == CU_add_test(pSuite, "HTTP Digest Auth", us901_test3)) ||
            (NULL == CU_add_test(pSuite, "HTTP Digest Auth Fail", us901_test4)) ||
            (NULL == CU_add_test(pSuite, "Get CA Certificates", us901_test5)) ||
            (NULL == CU_add_test(pSuite, "SSL 3.0 Fail", us901_test6)) ||
            (NULL == CU_add_test(pSuite, "TLS 1.0 Fail", us901_test7)) ||
            (NULL == CU_add_test(pSuite, "TLS 1.1", us901_test8)) ||
            (NULL == CU_add_test(pSuite, "TLS 1.2", us901_test9)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - explicit cert chain", us901_test10)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - implicit cert chain", us901_test11)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - revoked cert", us901_test12)) ||
            (NULL == CU_add_test(pSuite, "Certificate auth - self-signed cert", us901_test13)) ||
            (NULL == CU_add_test(pSuite, "Anon cipher suite disabled", us901_test14)) ||
            (NULL == CU_add_test(pSuite, "NULL Realm", us901_test15)) ||
            (NULL == CU_add_test(pSuite, "NULL server cert", us901_test16)) ||
            (NULL == CU_add_test(pSuite, "NULL server key", us901_test17)) ||
            (NULL == CU_add_test(pSuite, "NULL local CA chain", us901_test18)) ||
            (NULL == CU_add_test(pSuite, "Corrupted local CA chain", us901_test19)) ||
            (NULL == CU_add_test(pSuite, "HTTP POST cacerts", us901_test20)) ||
            (NULL == CU_add_test(pSuite, "SimpleEnroll - good HTTP auth/good Cert", us901_test21)) ||
            (NULL == CU_add_test(pSuite, "SimpleEnroll - bad HTTP auth/good Cert", us901_test22)) ||
            (NULL == CU_add_test(pSuite, "SimpleEnroll - no HTTP auth/no Cert", us901_test23)))
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    return CUE_SUCCESS;
#endif
}


/*------------------------------------------------------------------
 * us894.c - Unit Tests for User Story 894 - Proxy cacerts
 *
 * November, 2013
 *
 * Copyright (c) 2013, 2016 by cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 *
 *  Proxy mode is primarily server mode where the processing of certain
 *  requests from clients are passed long to the upstream server using
 *  client mode functionality.  In the case of Get CACerts, proxy mode
 *  functions almost identically as server mode.  The CA certs response
 *  chain is passed in and is then sent in reply to the Get CACerts
 *  requests from downstream clients.
 *
 *  This test code is taken largely from US901, Server Get CACerts,
 *
 */
#include <stdio.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <est.h>
#include <curl/curl.h>
#include "curl_utils.h"
#include "test_utils.h"
#include <openssl/ssl.h>
#include "st_server.h"
#include "st_proxy.h"

#ifdef HAVE_CUNIT
#include "CUnit/Basic.h"
#include "CUnit/Automated.h"
#endif

#define US894_PKCS10_REQ    "MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\n"
#define US894_PKCS10_CT     "Content-Type: application/pkcs10" 
#define US894_UIDPWD_GOOD   "estuser:estpwd"
#define US894_UIDPWD_BAD    "estuser:bogus"
#ifndef WIN32
#define US894_CACERTS       "CA/estCA/cacert.crt"
#define US894_TRUSTED_CERT  "CA/trustedcerts.crt"
#define US894_TRUSTED_CERT_AND_CRL "US894/trustedcertsandcrl.crt"
#define US894_EXPLICIT_CERT "US894/explicit-cert.pem" 
#define US894_EXPLICIT_KEY "US894/explicit-key.pem"
#define US894_IMPLICIT_CERT "US894/implicit-cert.pem" 
#define US894_IMPLICIT_KEY "US894/implicit-key.pem"
#define US894_REVOKED_CERT "US894/revoked-cert.pem" 
#define US894_REVOKED_KEY "US894/revoked-key.pem"
#define US894_SELFSIGN_CERT "US894/selfsigned-cert.pem" 
#define US894_SELFSIGN_KEY "US894/selfsigned-key.pem"
#define US894_CACERT "CA/estCA/cacert.crt"
#define US894_EXTCERT "CA/extCA/cacert.crt"
#define US894_SERVER_CERT "CA/estCA/private/estservercertandkey.pem"
#define US894_SERVER_KEY "CA/estCA/private/estservercertandkey.pem"
#define US894_PROXY_CERT "CA/estCA/private/estservercertandkey.pem"  // change these other to dedicated ones
#define US894_PROXY_KEY "CA/estCA/private/estservercertandkey.pem"
static char test5_outfile[FILENAME_MAX] = "US894/test5.crt";
static char test26_outfile[FILENAME_MAX] = "US894/test26.crt";
static char test27_outfile[FILENAME_MAX] = "US894/test27.crt";
#else
#define US894_CACERTS       "CA\\estCA\\cacert.crt"
#define US894_TRUSTED_CERT "CA\\trustedcerts.crt"
#define US894_TRUSTED_CERT_AND_CRL  "US894\\trustedcertsandcrl.crt"
#define US894_EXPLICIT_CERT "US894\\explicit-cert.pem" 
#define US894_EXPLICIT_KEY "US894\\explicit-key.pem"
#define US894_IMPLICIT_CERT "US894\\implicit-cert.pem" 
#define US894_IMPLICIT_KEY "US894\\implicit-key.pem"
#define US894_REVOKED_CERT "US894\\revoked-cert.pem" 
#define US894_REVOKED_KEY "US894\\revoked-key.pem"
#define US894_SELFSIGN_CERT "US894\\selfsigned-cert.pem" 
#define US894_SELFSIGN_KEY "US894\\selfsigned-key.pem"
#define US894_CACERT "CA\\estCA\\cacert.crt"
#define US894_EXTCERT "CA\\extCA\\cacert.crt"
#define US894_SERVER_CERT "CA\\estCA\\private\\estservercertandkey.pem"
#define US894_SERVER_KEY "CA\\estCA\\private\\estservercertandkey.pem"
#define US894_PROXY_CERT "CA\\estCA\\private\\estservercertandkey.pem"  // change these other to dedicated ones
#define US894_PROXY_KEY "CA\\estCA\\private\\estservercertandkey.pem"

static char test5_outfile[FILENAME_MAX] = "US894\\test5.crt";
static char test26_outfile[FILENAME_MAX] = "US894\\test26.crt";
static char test27_outfile[FILENAME_MAX] = "US894\\test27.crt";
#endif

/* #define US894_TCP_SERVER_PORT_BASIC     12894 */
#define US894_ENROLL_URL "https://127.0.0.1:16894/.well-known/est/simpleenroll"
#define US894_CACERT_URL "https://127.0.0.1:16894/.well-known/est/cacerts"
/* #define US894_TCP_SERVER_PORT_DIGEST    13894 */
/* #define US894_TCP_SERVER_PORT_HTTP_DISABLE 14894 */
#define US894_TCP_SERVER_PORT       15894
#define US894_TCP_PROXY_PORT        16894

static void us894_clean (void)
{
    char cmd[200];
#ifndef WIN32
    sprintf(cmd, "rm %s", test5_outfile);
    system(cmd);
    sprintf(cmd, "rm %s", test26_outfile);
    system(cmd);
    sprintf(cmd, "rm %s", test27_outfile);
    system(cmd);
#else
    sprintf(cmd, "del %s", test5_outfile);
    system(cmd);
    sprintf(cmd, "del %s", test26_outfile);
    system(cmd);
    sprintf(cmd, "del %s", test27_outfile);
    system(cmd);
#endif
}

int us894_start_server ()
{
    int rv = 0;

    /*
     * First we start an EST server acting as the CA
     */
    rv = st_start(US894_TCP_SERVER_PORT,
                  US894_SERVER_CERT,
                  US894_SERVER_KEY,
                  "estrealm",
                  US894_CACERT,
                  US894_TRUSTED_CERT,
                  "US894/estExampleCA.cnf",
                  0,  // manual enroll
                  0,  // disable PoP
                  0); // ecdhe nid info
    SLEEP(1);
    if (rv != EST_ERR_NONE)
        return rv;

    /*
     * Next we start an EST proxy acting as an RA.
     */
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
    SLEEP(1);

    return rv;
}

/*
 * This routine is called when CUnit initializes this test
 * suite.  This can be used to allocate data or open any
 * resources required for all the test cases.
 */
static int us894_init_suite (void)
{
    int rv;

    us894_clean();

    printf("\nStarting EST Proxy Get CACerts unit tests.\n");

    /*
     * Start an instance of the EST server with
     * automatic enrollment enabled.
     */
    rv = us894_start_server();

    return rv;
}

void us894_stop_server ()
{
    st_stop();
    st_proxy_stop();
    SLEEP(2);
}

/*
 * This routine is called when CUnit uninitializes this test
 * suite.  This can be used to deallocate data or close any
 * resources that were used for the test cases.
 */
static int us894_destroy_suite (void)
{
    us894_stop_server();
    printf("Completed EST Proxy Get CACerts unit tests.\n");
    return 0;
}

/*
 * HTTP Basic auth
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST proxy/server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.
 */
static void us894_test1 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * HTTP Basic Auth failure, Bad Password
 *
 * This test case uses libcurl to test HTTP Basic
 * authentication is working on the EST proxy/server,
 * while using a bogus password.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.
 */
static void us894_test2 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 400
     */
    CU_ASSERT(rv == 401);
}

/*
 * HTTP Digest Auth
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST proxy/server.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.
 *
 * This test also tests the correct operation of est_proxy_set_auth()
 */
static void us894_test3 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_set_auth(AUTH_DIGEST);
    SLEEP(1);

    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_DIGEST,
                        NULL, NULL, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with success
     */
    CU_ASSERT(rv == 200);

    st_proxy_set_auth(AUTH_BASIC);
}

/*
 * HTTP Digest Auth fail
 *
 * This test case uses libcurl to test HTTP Digest
 * authentication is working on the EST proxy/server.
 * This is the negative test case for Digest auth.
 * It must use a simpleenroll message since the
 * cacerts message does not require the client
 * to be authenticated.  The EST proxy/server should be
 * running and listening to port 8087 prior to this
 * test being run.
 */
static void us894_test4 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_set_auth(AUTH_DIGEST);
    SLEEP(1);

    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_DIGEST,
                        NULL, NULL, NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 401);

    st_proxy_set_auth(AUTH_BASIC);
}

static FILE *outfile;
static size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)
{
    size_t written;
    written = fwrite(ptr, size, nmemb, outfile);
    return written;
}

/*
 * This test case does a simple cacerts request
 * and looks for the HTTP 200 response code.
 */
static void us894_test5 (void)
{
    long rv;
    char cmd[200];

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &write_func);
    fclose(outfile);

    /*
     * we expect the server to respond with a 200
     */
    CU_ASSERT(rv == 200);

    sprintf(
        cmd,
        "openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs",
        test5_outfile);
    rv = system(cmd);
    CU_ASSERT(rv == 0);
}

static void us894_test_sslversion (const SSL_METHOD *m, int expect_fail)
{
    BIO *conn;
    SSL *ssl;
    SSL_CTX *ssl_ctx = NULL;
    int rv;

    ssl_ctx = SSL_CTX_new(m);
    CU_ASSERT(ssl_ctx != NULL);

    /*
     * Now that the SSL context is ready, open a socket
     * with the server and bind that socket to the context.
     */
    conn = open_tcp_socket_ipv4("127.0.0.1", "16894");
    CU_ASSERT(conn != NULL);

    /*
     * Create an SSL session context
     */
    ssl = SSL_new(ssl_ctx);
    SSL_set_bio(ssl, conn, conn);

    /*
     * Now that we have everything ready, let's initiate the TLS
     * handshake.
     */
    rv = SSL_connect(ssl);
    if (!expect_fail) {
        CU_ASSERT(rv > 0);
    } else {
        CU_ASSERT(rv <= 0);
    }

    /*
     * Cleanup all the data
     */
    SSL_shutdown(ssl);
    SSL_free(ssl);
    SSL_CTX_free(ssl_ctx);

}

/*
 * This test attempts to create a SSL 3.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us894_test6 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(SSLv3_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.0 connection
 * with the EST server.  This should fail, as TLS 1.0
 * is not allowed.
 */
static void us894_test7 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(TLSv1_client_method(), 1);
}

/*
 * This test attempts to create a TLS 1.1 connection
 * with the EST server.  This should succeed.
 */
static void us894_test8 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(TLSv1_1_client_method(), 0);
}

/*
 * This test attempts to create a TLS 1.2 connection
 * with the EST server.  This should succeed.
 */
static void us894_test9 (void)
{
    LOG_FUNC_NM
    ;

    us894_test_sslversion(TLSv1_2_client_method(), 0);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. This should succeed.
 */
static void us894_test10 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = st_proxy_http_disable(1);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_EXPLICIT_CERT,
    US894_EXPLICIT_KEY,
    US894_CACERTS,
    NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    rv = st_proxy_http_disable(0);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentication is working.
 * The certificate used is signed by the implicit cert
 * chain. This should succeed.
 */
static void us894_test11 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = st_proxy_http_disable(1);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_IMPLICIT_CERT,
    US894_IMPLICIT_KEY,
    US894_CACERTS, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);

    rv = st_proxy_http_disable(0);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }
}

/*
 * This test attempts to use a revoked client certificate to
 * verify CRL checks are working in the TLS layer.
 * This should fail.
 */
static void us894_test12 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    st_proxy_stop();
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT_AND_CRL,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_REVOKED_CERT,
    US894_REVOKED_KEY,
    US894_CACERTS,
    NULL);


    /*
     * Since the client cert has been revoked the TLS handshake
     * will fail.  The EST server should return a 401 response.
     */
    CU_ASSERT(rv == 0);

    st_proxy_stop();
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
}

/*
 * This test attempts to use a self-signed client certificate to
 * verify cert chain will reject a cert that has not been
 * signed by a valid CA.  This should fail.
 */
static void us894_test13 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_cert(US894_ENROLL_URL,
    US894_PKCS10_CT,
    US894_PKCS10_REQ,
    US894_SELFSIGN_CERT,
    US894_SELFSIGN_KEY,
    US894_CACERTS, NULL);

    /*
     * Since the client cert is not signed by either the local CA
     * or external CA, the TLS handshake will fail.
     * We will not receive an HTTP status message
     * from the server.
     */
    CU_ASSERT(rv == 0);
}

/*
 * TLS anonymous cipher suites disabled
 *
 * This test case uses libcurl to test that the
 * EST server will not accept anonymous cipher
 * suites from the client.  We only test a single
 * cipher suite here.  This attempts to do a
 * simple enroll with the server.
 */
static void us894_test14 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,
                        "ADH-AES128-SHA256", NULL, NULL);
    /*
     * TLS handshake should have failed, curl should return 0
     */
    CU_ASSERT(rv == 0);
}

/*
 * Null HTTP realm when initializing server
 */
static void us894_test15 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST server using NULL realm
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         NULL,
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");

    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate when initializing server
 */
static void us894_test16 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *keyin;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy using NULL server key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         NULL,
                         priv_key,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx == NULL);

    EVP_PKEY_free(priv_key);
}

/*
 * Null Server certificate private key when initializing server
 */
static void us894_test17 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin;
    X509 *x;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Attempt to init EST proxy using NULL private key
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         NULL,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx == NULL);

    X509_free(x);
}

/*
 * Null trusted CA chain when initializing server
 */
static void us894_test18 (void)
{
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy using NULL local CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(NULL,
                         0,
                         NULL,
                         0,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Corrupted CA chain when initializing server
 */
static void us894_test19 (void)
{
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy a corrupted CA chain
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init((unsigned char*) "Bogus CA chain",
                         14,
                         (unsigned char*) "Bogus CA chain",
                         14,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");

    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * This test case attempts simple cacerts request using
 * POST instead of GET.  It should fail.
 */
static void us894_test20 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);

    outfile = fopen(test5_outfile, "w");
    rv = curl_http_post(US894_CACERT_URL, US894_PKCS10_CT, US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,
                        NULL, NULL, NULL);
    fclose(outfile);

    /*
     * we expect the server to respond with a 400
     */
    CU_ASSERT(rv == 400);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Valid HTTP authentication credentials are
 * also provided.  This should succeed.
 */
static void us894_test21 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US894_ENROLL_URL,
                                US894_PKCS10_CT,
                                US894_PKCS10_REQ,
                                US894_UIDPWD_GOOD,
                                US894_EXPLICIT_CERT,
                                US894_EXPLICIT_KEY,
                                US894_CACERTS, NULL);
    /*
     * Since we passed in a valid userID/password,
     * we expect the server to respond with 200
     */
    CU_ASSERT(rv == 200);
}

/*
 * This test attempts to use a client certificate to
 * verify the TLS client authentiaiton is working.
 * The certificate used is signed by the explicit cert
 * chain. Invalid HTTP authentication credentials are
 * also provided.  This should fail with a 401 response.
 */
static void us894_test22 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    SLEEP(1);
    rv = curl_http_post_certuid(US894_ENROLL_URL,
                                US894_PKCS10_CT,
                                US894_PKCS10_REQ,
                                US894_UIDPWD_BAD,
                                US894_EXPLICIT_CERT,
                                US894_EXPLICIT_KEY,
                                US894_CACERTS,
                                NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);
}

/*
 * This test attempts to enroll without using a certificate
 * to identity the client, while using a good user ID/pwd.
 * However, the EST server is setup to only perform
 * certificate authentication (HTTP auth disabled).
 * This should fail with a 401 response.
 */
static void us894_test23 (void)
{
    long rv;

    LOG_FUNC_NM
    ;

    rv = st_proxy_http_disable(1);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

    SLEEP(1);
    rv = curl_http_post(US894_ENROLL_URL,
                        US894_PKCS10_CT,
                        US894_PKCS10_REQ,
                        US894_UIDPWD_GOOD,
                        US894_CACERTS,
                        CURLAUTH_BASIC,
                        NULL,
                        NULL,
                        NULL);
    /*
     * Since we passed in an invalid userID/password,
     * we expect the server to respond with 401
     */
    CU_ASSERT(rv == 401);

    rv = st_proxy_http_disable(0);
    if (rv == -1) {
        printf("Could not set HTTP authentication callback\n");
        return;
    }

}

/*
 * Test the parameters of est_proxy_set_server()
 */
static void us894_test24 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;
    EST_ERROR est_rv;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * init EST in proxy mode
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(
        cacerts,
        cacerts_len,
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        "testrealm",
        x,
        priv_key,
        "estuser",
        "estpwd");

    CU_ASSERT(ctx != NULL);

    est_rv = est_proxy_set_server(NULL, "127.0.0.1", 8080);
    CU_ASSERT(est_rv == EST_ERR_NO_CTX);

    est_rv = est_proxy_set_server(ctx, NULL, 8080);
    CU_ASSERT(est_rv == EST_ERR_INVALID_SERVER_NAME);

    est_rv = est_proxy_set_server(ctx, "127.0.0.1", 65536);
    CU_ASSERT(est_rv == EST_ERR_INVALID_PORT_NUM);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Test the parameters of est_proxy_set_auth_mode()
 */
static void us894_test25 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;
    EST_ERROR est_rv;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * init EST in proxy mode
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(cacerts,
                         cacerts_len,
                         cacerts,
                         cacerts_len,
                         EST_CERT_FORMAT_PEM,
                         "testrealm",
                         x,
                         priv_key,
                         "estuser",
                         "estpwd");
    CU_ASSERT(ctx != NULL);

    est_rv = est_proxy_set_auth_mode(ctx, AUTH_NONE);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);
    est_rv = est_proxy_set_auth_mode(ctx, AUTH_BASIC);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_proxy_set_auth_mode(ctx, AUTH_DIGEST);
    CU_ASSERT(est_rv == EST_ERR_NONE);
    est_rv = est_proxy_set_auth_mode(ctx, 0xffffffff);
    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);

    est_rv = est_proxy_set_auth_mode(NULL, AUTH_BASIC);
    CU_ASSERT(est_rv == EST_ERR_NO_CTX);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/*
 * Test the optional setting of the CA Certs response chain in est_proxy_init()
 * test passthrough (cache disabled) mode of the CA Certs response chain.
 */
static void us894_test26 (void)
{
    long rv;
    char cmd[200];

    LOG_FUNC_NM
    ;

    st_proxy_stop();
    SLEEP(1);

    /*
     * restart the proxy without passing the ca certs response change parameter
     * param 5
     */
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        NULL,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
    SLEEP(1);

    outfile = fopen(test26_outfile, "w");
    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &write_func);
    fclose(outfile);

    /*
     * we expect the server to respond with a 200
     */
    CU_ASSERT(rv == 200);

    sprintf(
        cmd,
        "openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs",
        test26_outfile);
    rv = system(cmd);
    CU_ASSERT(rv == 0);

    /*
     * restart the proxy and include the CA Cert response chain
     */
    st_proxy_stop();
    SLEEP(1);
    rv = st_proxy_start(US894_TCP_PROXY_PORT,
                        US894_PROXY_CERT,
                        US894_PROXY_KEY,
                        "estrealm",
                        US894_CACERT,
                        US894_TRUSTED_CERT,
                        "estuser",
                        "estpwd",
                        "127.0.0.1",
                        US894_TCP_SERVER_PORT,
                        0,  // disable PoP
                        0);  // ecdhe nid info
    SLEEP(1);
}

/*
 * Test the passing of bad userid/password values to est_proxy_init to make sure
 * they're error checked.
 */
static void us894_test27 (void)
{
    unsigned char *cacerts = NULL;
    int cacerts_len = 0;
    BIO *certin, *keyin;
    X509 *x;
    EVP_PKEY * priv_key;
    int rv;
    EST_CTX *ctx;

    LOG_FUNC_NM
    ;

    /*
     * Read in the CA certificates
     */
    cacerts_len = read_binary_file(US894_CACERT, &cacerts);
    CU_ASSERT(cacerts_len > 0);

    /*
     * Read the server cert
     */
    certin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(certin, US894_SERVER_CERT);
    CU_ASSERT(rv > 0);
    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);
    CU_ASSERT(x != NULL);
    BIO_free(certin);

    /*
     * Read the server key
     */
    keyin = BIO_new(BIO_s_file_internal());
    rv = BIO_read_filename(keyin, US894_SERVER_KEY);
    CU_ASSERT(rv > 0);
    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);
    CU_ASSERT(priv_key != NULL);
    BIO_free(keyin);

    /*
     * Attempt to init EST proxy using NULL userid
     */
    est_init_logger(EST_LOG_LVL_INFO, NULL);
    ctx = est_proxy_init(
        cacerts,
        cacerts_len,
        cacerts,
        cacerts_len,
        EST_CERT_FORMAT_PEM,
        "estrealm",
        x,
        priv_key,
        NULL,
        "estpwd");

    CU_ASSERT(ctx == NULL);

    ctx =
            est_proxy_init(
                cacerts,
                cacerts_len,
                cacerts,
                cacerts_len,
                EST_CERT_FORMAT_PEM,
                "estrealm",
                x,
                priv_key,
                "bad_userid_too_long_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
                "estpwd");

    CU_ASSERT(ctx == NULL);

    X509_free(x);
    EVP_PKEY_free(priv_key);
}

/* The main() function for setting up and running the tests.
 * Returns a CUE_SUCCESS on successful running, another
 * CUnit error code on failure.
 */
int us894_add_suite (void)
{
#ifdef HAVE_CUNIT
    CU_pSuite pSuite = NULL;

    /* add a suite to the registry */
    pSuite = CU_add_suite("us894_proxy_cacerts",
            us894_init_suite,
            us894_destroy_suite);
    if (NULL == pSuite) {
        CU_cleanup_registry();
        return CU_get_error();
    }


    /* add the tests to the suite */
    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */
    if ((NULL == CU_add_test(pSuite, "HTTP Basic Auth", us894_test1)) ||
        (NULL == CU_add_test(pSuite, "HTTP Basic Auth Fail", us894_test2)) ||
        (NULL == CU_add_test(pSuite, "HTTP Digest Auth", us894_test3)) ||
        (NULL == CU_add_test(pSuite, "HTTP Digest Auth Fail", us894_test4)) ||
        (NULL == CU_add_test(pSuite, "Get CA Certificates", us894_test5)) ||
        (NULL == CU_add_test(pSuite, "SSL 3.0 Fail", us894_test6)) ||
        (NULL == CU_add_test(pSuite, "TLS 1.0 Fail", us894_test7)) ||
        (NULL == CU_add_test(pSuite, "TLS 1.1", us894_test8)) ||
        (NULL == CU_add_test(pSuite, "TLS 1.2", us894_test9)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - explicit cert chain", us894_test10)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - implicit cert chain", us894_test11)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - revoked cert", us894_test12)) ||
        (NULL == CU_add_test(pSuite, "Certificate auth - self-signed cert", us894_test13)) ||
        (NULL == CU_add_test(pSuite, "Anon cipher suite disabled", us894_test14)) ||
        (NULL == CU_add_test(pSuite, "NULL Realm", us894_test15)) ||
        (NULL == CU_add_test(pSuite, "NULL server cert", us894_test16)) ||
        (NULL == CU_add_test(pSuite, "NULL server key", us894_test17)) ||
        (NULL == CU_add_test(pSuite, "NULL local CA chain", us894_test18)) ||
        (NULL == CU_add_test(pSuite, "Corrupted local CA chain", us894_test19)) ||
        (NULL == CU_add_test(pSuite, "HTTP POST cacerts", us894_test20)) ||
        (NULL == CU_add_test(pSuite, "SimpleEnroll - good HTTP auth/good Cert", us894_test21)) ||
        (NULL == CU_add_test(pSuite, "SimpleEnroll - bad HTTP auth/good Cert", us894_test22)) ||
        (NULL == CU_add_test(pSuite, "SimpleEnroll - no HTTP auth/no Cert", us894_test23)) ||
        (NULL == CU_add_test(pSuite, "Set Server Invalid parameters", us894_test24)) ||
        (NULL == CU_add_test(pSuite, "Set Auth Mode Invalid parameters", us894_test25)) ||
        (NULL == CU_add_test(pSuite, "Optional CA Chain Response", us894_test26)) ||
        (NULL == CU_add_test(pSuite, "Bad userid/password for proxy init", us894_test27)))
    {
       CU_cleanup_registry();
       return CU_get_error();
    }


    return CUE_SUCCESS;
#endif
}


