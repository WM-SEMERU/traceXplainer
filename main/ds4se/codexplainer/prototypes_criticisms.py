# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/8.6_codexplainer.prototypes_criticisms.ipynb (unless otherwise specified).

__all__ = ['reshape_vectors', 'Clusterizer', 'KMedoidsClusterizer', 'CriticismFinder', 'plot_data_distributions',
           'plot_gmms', 'plot_overlap_gmm_compute_kl_div', 'plot_boundaries', 'perform_analysis']

# Cell

import numpy as np
import pandas as pd

from typing import Tuple, List, Optional, Any, Iterable, Dict
from abc import ABC, abstractmethod

from pathlib import Path

# ds4se
import ds4se
from ..utils.clusterization import *
from ..utils.visualization import *
from ..mgmnt.prep.files_mgmnt import load_np_vectors

# Cell

def reshape_vectors(vectors):
    result = []
    for v in vectors:
        result.append(v.reshape(500,1).T)
    return np.array(result)

# Cell


# General implementation aiming to allow the use of different clustering algorithms

class Clusterizer(ABC):
    def __init__(self):
        pass

    @abstractmethod
    def perform_clusterization(self, data_vectors: np.ndarray, dims: Optional[int]=2):
        """
        Perform clusterization on a given dataset

        """
        pass

# Cell

class KMedoidsClusterizer(Clusterizer):
    def __init__(self):
        # TODO
        super().__init__()

    def perform_clusterization(self, data_vectors: np, dims: Optional[int]=2) -> Tuple:
        """
        Perform clusterization using k-medoids
        - First perform dimensionality reduction by means of PCA + t-SNE
        - Finds best k

        :param data_vectors:
        :param dims: Int. indicating the number of dimensions for
                     dim. reduction

        :return: Tuple (reduced data, clusters, medoid ids, k_medoids_instance (pyclustering obj.))
        """
        return perform_clusterize_kmedoids(data_vectors, dims)


# Cell

class CriticismFinder:

    def get_critisicms(data, prototypes: List, n: Optional[int]=None,
                       distance: Optional[Any]=None) ->Tuple:
        """
        :param data: Dataset
        :param prototypes: List of found prototypes
        :param n: Numbers of criticisms to find
        :param distance: Distance object instantiating appropriate distance calculation

        :return: Tuple (criticisms points, criticisms ids)
        """
        crit_points, crit_ids = gen_criticisms(data, prototypes, n, distance)
        return crit_points, crit_ids

# Cell

def plot_data_distributions(cluster_data: Dict, model_key: str, model_name: str,
                            human_dist: str, human_key: str,
                            out_path: str, show: bool, export: bool):
    """
    Plot the couple of data distribution (individually) for a given model and a human distribution
    :param cluster_data: Dictionary containing cluster data for both distributions
    :param model_key: Str indicating the key for the model in the dict.
    :param model_name: Str indicating the model name (plotting purposes)
    :param human_dist: Str indicating the human distr. name (plotting purposes)
    :param human_key: Str indicating the human distr. key in the dict.
    :param out_path: Str indicating the destination path for generated figures
    :param show: bool indicating whether or not to show the plots
    :param export: bool indicating whether or not to export the plots
    """
    # Gen. model
    plot_data_distribution_2d(
        cluster_data[model_key][0],
        model_name, out_path,
        export=export, show=show
    )

    # Human distribution
    plot_data_distribution_2d(
        cluster_data[human_key][0],
        human_dist, out_path,
        export=export, show=show
    )

# Cell

def plot_gmms(cluster_data: Dict, model_key: str, model_name: str,
              human_dist: str, human_key: str,
              out_path: str, show: bool, export: bool):
    """
    Plot the distributions with the computed GMMs (individually) for both distributions
    :param cluster_data: Dictionary containing cluster data for both distributions
    :param model_key: Str indicating the key for the model in the dict.
    :param model_name: Str indicating the model name (plotting purposes)
    :param human_dist: Str indicating the human distr. name (plotting purposes)
    :param human_key: Str indicating the human distr. key in the dict.
    :param out_path: Str indicating the destination path for generated figures
    :param show: bool indicating whether or not to show the plots
    :param export: bool indicating whether or not to export the plots
    """
    # Plot for model distr.
    plot_gmm_2d_single_distribution(
        cluster_data[model_key], model_name,
        out_path, export=export, show=show
    )

    # Plot for human distr.
    plot_gmm_2d_single_distribution(
        cluster_data[human_key], human_dist,
        out_path, export=export, show=show
    )

# Cell

def plot_overlap_gmm_compute_kl_div(cluster_data: Dict, out_path: str, export: bool, show: bool):
    """
    Plot the overlapping distributions with GMM models and compute the KL-divergence for the
    couple of given distributions
    :param cluster_data: Dict containing the data for both distributions
    :param out_path: Str indicating the destination directory for the generated figures
    :param export: Bool indicating whether or not export the generated figures
    :param show: Bool indicating whether or not show the generated figures
    """
    gen_human_kldiv, human_gen_kldiv = plot_overlapping_gmms(cluster_data, 'results', export=False)
    return gen_human_kldiv, human_gen_kldiv

# Cell

# TODO: Implement for non-kmedoids clustering algorithms

def plot_boundaries(cluster_data: Dict, model_key: str, model_name: str,
                             human_dist: str, human_key: str, out_path: str,
                             show: bool, export: bool):
    """
    :param cluster_data: Dictionary containing cluster data for both distributions
    :param model_key: Str indicating the key for the model in the dict.
    :param model_name: Str indicating the model name (plotting purposes)
    :param human_dist: Str indicating the human distr. name (plotting purposes)
    :param human_key: Str indicating the human distr. key in the dict.
    :param out_path: Str indicating the destination path for generated figures
    :param show: bool indicating whether or not to show the plots
    :param export: bool indicating whether or not to export the plots
    """

    # Plot for generative model
    plot_kmedoids_decision_boundaries(
        cluster_data[model_key], model_name, out_path,
    )

    # Plot for human distribution
    plot_kmedoids_decision_boundaries(
        cluster_data[human_key], human_dist, out_path,
        show=show, export=export)

# Cell

def perform_analysis(model_config: str, model_name: str, model_key: str,
                     human_config: str, human_key: str,
                     vectors_storage_path: str,
                     figures_export_path: str,
                     clusterizer: Clusterizer,
                     n_experiments: Optional[int]=None,
                     enable_visualization: Optional[bool]=False,
                     export_figures: Optional[bool]=False
                    ) -> Tuple[np.ndarray, np.ndarray]:
    """
    """
    gen_sample_files = get_vectors_path_4_sample_set(model_config)
    trn_sample_files = get_vectors_path_4_sample_set(human_config)

    kl_div_gen_vs_human = []
    kl_div_human_vs_gen = []

    if n_experiments is not None:
        if len(gen_sample_files) < n_experiments or len(trn_sample_files) < n_experiments:
            # TODO: Handle error
            return

        gen_sample_files = gen_sample_files[:n_experiments]
        human_sample_files = trn_sample_files[:n_experiments]

    for i in range(n_experiments):
        gen_vectors = load_np_vectors(gen_sample_files[i])
        human_vectors = load_np_vectors(gen_sample_files[i])

        gen_cluster = clusterizer.perform_clusterization(gen_vectors, dims=2)
        human_cluster = clusterizer.perform_clusterization(human_vectors, dims=2)

        cluster_data = {
            model_key: gen_cluster,
            human_key: human
        }

        # Plot individual distributions
        plot_data_distributions(
            cluster_data, model_key, model_name,
            human_config, human_key, figures_export_path,
            enable_visualization, export_figures
        )

        # Plot GMMs
        plot_gmms(
            cluster_data, model_key, model_name,
            human_config, human_key, figures_export_path,
            enable_visualization, export_figures
        )

        # Plot overlapping GMMs & compute KL-divergence
        gen_human_kld, human_gen_kld = plot_overlap_gmm_compute_kl_div(
            cluster_data, figures_export_path,
            export_figures, enable_visualization
        )

        kl_div_gen_vs_human.append(gen_human_kd)
        kl_div_human_vs_gen.append(human_gen_kld)

        # TODO: Accumulate KL-div data

        # Plot decision boundaries
        plot_boundaries(cluster_data, model_key, model_name,
                                  human_config, human_key, figures_export_path,
                                  enable_visualization, export_figures
        )

    return np.array(kl_div_gen_vs_human), np.array(kl_div_human_vs_gen)